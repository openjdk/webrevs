{"files":[{"patch":"@@ -90,0 +90,5 @@\n+        <\/dependency>\n+        <dependency>\n+            <groupId>org.netbeans.api<\/groupId>\n+            <artifactId>org-openide-modules<\/artifactId>\n+            <version>${netbeans.version}<\/version>\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/pom.xml","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,6 @@\n+import com.sun.hotspot.igv.data.serialization.ParseMonitor;\n+import com.sun.hotspot.igv.data.serialization.Parser;\n+import com.sun.hotspot.igv.data.serialization.Printer;\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContext;\n+import com.sun.hotspot.igv.data.serialization.Printer.SerialData;\n+import com.sun.hotspot.igv.data.services.GraphViewer;\n@@ -33,0 +39,1 @@\n+import com.sun.hotspot.igv.settings.Settings;\n@@ -37,6 +44,9 @@\n-import java.io.IOException;\n-import java.io.ObjectInput;\n-import java.io.ObjectOutput;\n-import java.util.HashSet;\n-import java.util.Set;\n-import javax.swing.UIManager;\n+import java.io.*;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardOpenOption;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import javax.swing.*;\n@@ -44,0 +54,3 @@\n+import javax.swing.filechooser.FileFilter;\n+import org.netbeans.api.progress.ProgressHandle;\n+import org.netbeans.api.progress.ProgressHandleFactory;\n@@ -45,1 +58,0 @@\n-import org.openide.actions.GarbageCollectAction;\n@@ -53,0 +65,1 @@\n+import org.openide.util.Lookup;\n@@ -54,0 +67,2 @@\n+import org.openide.util.RequestProcessor;\n+import org.openide.windows.Mode;\n@@ -63,1 +78,0 @@\n-    public static OutlineTopComponent instance;\n@@ -65,0 +79,16 @@\n+    private static final GraphDocument document = new GraphDocument();\n+    private static final int WORK_UNITS = 10000;\n+    private static final RequestProcessor RP = new RequestProcessor(\"OutlineTopComponent\", 1);\n+    private static final FileFilter xmlFileFilter = new FileFilter() {\n+        @Override\n+        public boolean accept(File f) {\n+            return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n+        }\n+\n+        @Override\n+        public String getDescription() {\n+            return \"Graph files (*.xml)\";\n+        }\n+    };\n+    public static OutlineTopComponent instance;\n+    private final Set<FolderNode> selectedFolders = new HashSet<>();\n@@ -66,1 +96,0 @@\n-    private final GraphDocument document;\n@@ -68,1 +97,2 @@\n-    private SaveAllAction saveAllAction;\n+    private SaveAction saveAction;\n+    private SaveAsAction saveAsAction;\n@@ -71,1 +101,1 @@\n-    private final Set<FolderNode> selectedFolders = new HashSet<>();\n+    private Path documentPath = null;\n@@ -78,2 +108,0 @@\n-\n-        document = new GraphDocument();\n@@ -85,0 +113,69 @@\n+    public static GraphDocument getDocument() {\n+        return document;\n+    }\n+\n+    \/**\n+     * Gets default instance. Do not use directly: reserved for *.settings files only,\n+     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.\n+     * To obtain the singleton instance, use {@link #findInstance()}.\n+     *\/\n+    public static synchronized OutlineTopComponent getDefault() {\n+        if (instance == null) {\n+            instance = new OutlineTopComponent();\n+        }\n+        return instance;\n+    }\n+\n+    \/**\n+     * Obtain the OutlineTopComponent instance. Never call {@link #getDefault} directly!\n+     *\/\n+    public static synchronized OutlineTopComponent findInstance() {\n+        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\n+        if (win == null) {\n+            ErrorManager.getDefault().log(ErrorManager.WARNING, \"Cannot find Outline component. It will not be located properly in the window system.\");\n+            return getDefault();\n+        }\n+        if (win instanceof OutlineTopComponent) {\n+            return (OutlineTopComponent) win;\n+        }\n+        ErrorManager.getDefault().log(ErrorManager.WARNING, \"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\n+        return getDefault();\n+    }\n+\n+    \/**\n+     * Stores the provided graph document to the designated file path with associated contexts.\n+     *\/\n+    private static void saveGraphDocument(GraphDocument doc, String path) throws IOException {\n+        if (path == null) {\n+            return;\n+        }\n+\n+        Set<GraphContext> saveContexts = new HashSet<>();\n+        WindowManager manager = WindowManager.getDefault();\n+        for (Mode mode : manager.getModes()) {\n+            List<TopComponent> compList = new ArrayList<>(Arrays.asList(manager.getOpenedTopComponents(mode)));\n+            for (TopComponent comp : compList) {\n+                if (comp instanceof EditorTopComponent etc) {\n+                    InputGraph graph = etc.getModel().getGraph();\n+                    if (graph.isDiffGraph() && graph.getFirstGraph().getGroup() != graph.getSecondGraph().getGroup()) {\n+                        \/\/ don't save diff graphs comparing graphs from different groups\n+                        continue;\n+                    }\n+                    GraphContext graphContext = getGraphContext(etc);\n+                    saveContexts.add(graphContext);\n+                }\n+            }\n+        }\n+\n+        try (Writer writer = new OutputStreamWriter(new FileOutputStream(path))) {\n+            Printer.exportGraphDocument(writer, new SerialData<>(doc, saveContexts));\n+        }\n+    }\n+\n+    private static GraphContext getGraphContext(EditorTopComponent etc) {\n+        InputGraph openedGraph = etc.getModel().getFirstGraph();\n+        int posDiff = etc.getModel().getSecondPosition() - etc.getModel().getFirstPosition();\n+        Set<Integer> hiddenNodes = new HashSet<>(etc.getModel().getHiddenNodes());\n+        return new GraphContext(openedGraph, new AtomicInteger(posDiff), hiddenNodes);\n+    }\n+\n@@ -86,1 +183,3 @@\n-        manager = new ExplorerManager();\n+        setDocumentPath(null);\n+        FolderNode.clearGraphNodeMap();\n+        document.clear();\n@@ -88,0 +187,1 @@\n+        manager = new ExplorerManager();\n@@ -90,1 +190,0 @@\n-\n@@ -97,1 +196,1 @@\n-        toolbar.setMinimumSize(new Dimension(0,0)); \/\/ MacOS BUG with ToolbarWithOverflow\n+        toolbar.setMinimumSize(new Dimension(0, 0)); \/\/ MacOS BUG with ToolbarWithOverflow\n@@ -101,0 +200,1 @@\n+        toolbar.add(OpenAction.get(OpenAction.class));\n@@ -102,1 +202,1 @@\n-        toolbar.add(SaveAsAction.get(SaveAsAction.class).createContextAwareInstance(this.getLookup()));\n+        toolbar.addSeparator();\n@@ -104,3 +204,6 @@\n-        saveAllAction = SaveAllAction.get(SaveAllAction.class);\n-        saveAllAction.setEnabled(false);\n-        toolbar.add(saveAllAction);\n+        saveAction = SaveAction.get(SaveAction.class);\n+        saveAction.setEnabled(false);\n+        toolbar.add(saveAction);\n+        saveAsAction = SaveAsAction.get(SaveAsAction.class);\n+        saveAsAction.setEnabled(false);\n+        toolbar.add(saveAsAction);\n@@ -108,0 +211,1 @@\n+        toolbar.addSeparator();\n@@ -109,1 +213,0 @@\n-\n@@ -114,2 +217,0 @@\n-        toolbar.add(GarbageCollectAction.get(GarbageCollectAction.class).getToolbarPresenter());\n-\n@@ -125,1 +226,2 @@\n-        saveAllAction.setEnabled(enableButton);\n+        saveAction.setEnabled(enableButton);\n+        saveAsAction.setEnabled(enableButton);\n@@ -141,7 +243,0 @@\n-    public void clear() {\n-        document.clear();\n-        FolderNode.clearGraphNodeMap();\n-        root = new FolderNode(document);\n-        manager.setRootContext(root);\n-    }\n-\n@@ -153,32 +248,0 @@\n-    public GraphDocument getDocument() {\n-        return document;\n-    }\n-\n-    \/**\n-     * Gets default instance. Do not use directly: reserved for *.settings files only,\n-     * i.e. deserialization routines; otherwise you could get a non-deserialized instance.\n-     * To obtain the singleton instance, use {@link #findInstance()}.\n-     *\/\n-    public static synchronized OutlineTopComponent getDefault() {\n-        if (instance == null) {\n-            instance = new OutlineTopComponent();\n-        }\n-        return instance;\n-    }\n-\n-    \/**\n-     * Obtain the OutlineTopComponent instance. Never call {@link #getDefault} directly!\n-     *\/\n-    public static synchronized OutlineTopComponent findInstance() {\n-        TopComponent win = WindowManager.getDefault().findTopComponent(PREFERRED_ID);\n-        if (win == null) {\n-            ErrorManager.getDefault().log(ErrorManager.WARNING, \"Cannot find Outline component. It will not be located properly in the window system.\");\n-            return getDefault();\n-        }\n-        if (win instanceof OutlineTopComponent) {\n-            return (OutlineTopComponent) win;\n-        }\n-        ErrorManager.getDefault().log(ErrorManager.WARNING, \"There seem to be multiple components with the '\" + PREFERRED_ID + \"' ID. That is a potential source of errors and unexpected behavior.\");\n-        return getDefault();\n-    }\n-\n@@ -239,9 +302,6 @@\n-                    EditorTopComponent editor = EditorTopComponent.getActive();\n-                    if (editor != null) {\n-                        InputGraph firstGraph = editor.getModel().getFirstGraph();\n-                        GraphNode firstNode = FolderNode.getGraphNode(firstGraph);\n-                        InputGraph secondGraph = editor.getModel().getSecondGraph();\n-                        GraphNode secondNode = FolderNode.getGraphNode(secondGraph);\n-                        if (firstNode != null && secondNode != null) {\n-                            selectedGraphs = new GraphNode[]{firstNode, secondNode};\n-                        }\n+                    InputGraph firstGraph = graph.getFirstGraph();\n+                    GraphNode firstNode = FolderNode.getGraphNode(firstGraph);\n+                    InputGraph secondGraph = graph.getSecondGraph();\n+                    GraphNode secondNode = FolderNode.getGraphNode(secondGraph);\n+                    if (firstNode != null && secondNode != null) {\n+                        selectedGraphs = new GraphNode[]{firstNode, secondNode};\n@@ -274,4 +334,7 @@\n-    public void readExternal(ObjectInput objectInput) throws IOException, ClassNotFoundException {\n-        \/\/ Not called when user starts application for the first time\n-        super.readExternal(objectInput);\n-        ((BeanTreeView) this.treeView).setRootVisible(false);\n+    public boolean canClose() {\n+        SwingUtilities.invokeLater(() -> {\n+            this.clearWorkspace();\n+            this.open(); \/\/ Reopen the OutlineTopComponent\n+            this.requestActive();\n+        });\n+        return true;\n@@ -280,3 +343,211 @@\n-    @Override\n-    public void writeExternal(ObjectOutput objectOutput) throws IOException {\n-        super.writeExternal(objectOutput);\n+    private void setDocumentPath(String path) {\n+        if (path != null) {\n+            documentPath = Paths.get(path);\n+            setHtmlDisplayName(\"<html><b>\" + documentPath.getFileName().toString() + \"<\/b><\/html>\");\n+            setToolTipText(\"File: \" + path);\n+        } else {\n+            documentPath = null;\n+            setHtmlDisplayName(\"<html><i>untitled<\/i><\/html>\");\n+            setToolTipText(\"No file\");\n+        }\n+\n+    }\n+\n+    \/**\n+     * Clears the workspace by resetting the document path, clearing the document, and resetting the folder structure.\n+     * After clearing the workspace, it will be ready for new documents.\n+     *\/\n+    public void clearWorkspace() {\n+        setDocumentPath(null);\n+        document.clear();\n+        FolderNode.clearGraphNodeMap();\n+        root = new FolderNode(document);\n+        manager.setRootContext(root);\n+    }\n+\n+    \/**\n+     * Opens a file dialog to select and load a graph document.\n+     * Clears the workspace and adds the loaded document to the workspace.\n+     **\/\n+    public void openFile() {\n+        JFileChooser fc = new JFileChooser(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT));\n+        fc.setFileFilter(xmlFileFilter);\n+        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            clearWorkspace();\n+            String path = fc.getSelectedFile().getAbsolutePath();\n+            Settings.get().put(Settings.DIRECTORY, path);\n+            setDocumentPath(path);\n+            try {\n+                loadGraphDocument(path, true);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    private boolean overwriteDialog(String filename) {\n+        JFrame frame = new JFrame();\n+        String message = \"Do you want to overwrite \" + filename + \"?\";\n+        int result = JOptionPane.showConfirmDialog(frame, message, \"Confirm Overwrite\", JOptionPane.YES_NO_OPTION, JOptionPane.WARNING_MESSAGE);\n+        if (result == JOptionPane.YES_OPTION) {\n+            frame.dispose();\n+            return true;\n+        }\n+        frame.dispose();\n+        return false;\n+    }\n+\n+    \/**\n+     * Saves the current graph document.\n+     * If the document has no location, let the user specify the file location.\n+     *\/\n+    public void save() {\n+        if (documentPath == null) {\n+            saveAs();\n+            return;\n+        }\n+\n+        String filePath = documentPath.toAbsolutePath().toString();\n+        if (Files.exists(Paths.get(filePath)) && overwriteDialog(documentPath.getFileName().toString())) {\n+            try {\n+                saveGraphDocument(getDocument(), filePath);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        } else {\n+            saveAs();\n+        }\n+    }\n+\n+    public void saveAs() {\n+        JFileChooser fc = new JFileChooser();\n+        fc.setDialogTitle(\"Save As...\");\n+        fc.setFileFilter(xmlFileFilter);\n+        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n+        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            String path = fc.getSelectedFile().getAbsolutePath();\n+\n+            \/\/ Ask if the user wants to overwrite the file if it already exists\n+            if (Files.exists(Paths.get(path)) && !overwriteDialog(fc.getSelectedFile().getName())) {\n+                return; \/\/ user does not want to overwrite\n+            }\n+\n+            Settings.get().put(Settings.DIRECTORY, path);\n+            setDocumentPath(path);\n+            try {\n+                saveGraphDocument(getDocument(), path);\n+            } catch (IOException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Imports graph documents from one or more XML files.\n+     * Displays a file chooser dialog to select one or multiple XML files for import.\n+     * Each selected file is added to the workspace.\n+     **\/\n+    public void importFromXML() {\n+        JFileChooser fc = new JFileChooser();\n+        fc.setFileFilter(xmlFileFilter);\n+        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n+        fc.setMultiSelectionEnabled(true);\n+        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n+            for (final File file : fc.getSelectedFiles()) {\n+                String path = file.getAbsolutePath();\n+                Settings.get().put(Settings.DIRECTORY, path);\n+                try {\n+                    loadGraphDocument(path, false);\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Loads and opens the given set of graph contexts (opened graphs and hidden nodes).\n+     *\/\n+    private void loadContexts(Set<GraphContext> contexts) {\n+        RP.post(() -> {\n+            final GraphViewer viewer = Lookup.getDefault().lookup(GraphViewer.class);\n+            assert viewer != null;\n+            for (GraphContext context : contexts) {\n+\n+                final int difference = context.posDiff().get();\n+                final Set<Integer> hiddenNodes = context.hiddenNodes();\n+                final InputGraph firstGraph = context.inputGraph();\n+\n+                SwingUtilities.invokeLater(() -> {\n+                    InputGraph openedGraph = viewer.view(firstGraph, true);\n+                    if (openedGraph != null) {\n+                        EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n+                        if (etc != null) {\n+                            etc.getModel().setHiddenNodes(hiddenNodes);\n+                            if (difference > 0) {\n+                                int firstGraphIdx = firstGraph.getIndex();\n+                                etc.getModel().setPositions(firstGraphIdx, firstGraphIdx + difference);\n+                            }\n+                        }\n+                    }\n+                });\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Loads a graph document from the given file path, updating progress via a ProgressHandle.\n+     * Parse the XML file, add the parsed document to the workspace, and load associated contexts if specified.\n+     *\/\n+    private void loadGraphDocument(String path, boolean loadContext) throws IOException {\n+        RP.post(() -> {\n+            if (path == null || Files.notExists(Path.of(path))) {\n+                return;\n+            }\n+            File file = new File(path);\n+            final FileChannel channel;\n+            final long start;\n+            try {\n+                channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n+                start = channel.size();\n+            } catch (Exception ex) {\n+                Exceptions.printStackTrace(ex);\n+                return;\n+            }\n+\n+            final ProgressHandle handle = ProgressHandleFactory.createHandle(\"Opening file \" + file.getName());\n+            handle.start(WORK_UNITS);\n+\n+            ParseMonitor monitor = new ParseMonitor() {\n+                @Override\n+                public void updateProgress() {\n+                    try {\n+                        int prog = (int) (WORK_UNITS * (double) channel.position() \/ (double) start);\n+                        handle.progress(prog);\n+                    } catch (IOException ignored) {\n+                    }\n+                }\n+\n+                @Override\n+                public void setState(String state) {\n+                    updateProgress();\n+                    handle.progress(state);\n+                }\n+            };\n+            try {\n+                if (file.getName().endsWith(\".xml\")) {\n+                    final Parser parser = new Parser(channel, monitor, null);\n+                    final SerialData<GraphDocument> parsedData = parser.parse();\n+                    final GraphDocument parsedDoc = parsedData.data();\n+                    getDocument().addGraphDocument(parsedDoc);\n+                    if (loadContext) {\n+                        final Set<GraphContext> parsedContexts = parsedData.contexts();\n+                        loadContexts(parsedContexts);\n+                    }\n+                    SwingUtilities.invokeLater(this::requestActive);\n+                }\n+            } catch (IOException ex) {\n+                Exceptions.printStackTrace(ex);\n+            }\n+            handle.finish();\n+        });\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/OutlineTopComponent.java","additions":351,"deletions":80,"binary":false,"changes":431,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,11 +28,0 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.serialization.GraphParser;\n-import com.sun.hotspot.igv.data.serialization.ParseMonitor;\n-import com.sun.hotspot.igv.data.serialization.Parser;\n-import com.sun.hotspot.igv.settings.Settings;\n-import java.io.File;\n-import java.io.IOException;\n-import java.nio.channels.FileChannel;\n-import java.nio.file.StandardOpenOption;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n@@ -40,6 +29,3 @@\n-import javax.swing.JFileChooser;\n-import javax.swing.SwingUtilities;\n-import javax.swing.filechooser.FileFilter;\n-import org.netbeans.api.progress.ProgressHandle;\n-import org.netbeans.api.progress.ProgressHandleFactory;\n-import org.openide.util.*;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n@@ -54,1 +40,0 @@\n-    private static final int WORKUNITS = 10000;\n@@ -56,13 +41,3 @@\n-    public static FileFilter getFileFilter() {\n-        return new FileFilter() {\n-\n-            @Override\n-            public boolean accept(File f) {\n-                return f.getName().toLowerCase().endsWith(\".xml\") || f.isDirectory();\n-            }\n-\n-            @Override\n-            public String getDescription() {\n-                return \"Graph files (*.xml)\";\n-            }\n-        };\n+    public ImportAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Import from XML...\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -73,64 +48,1 @@\n-        JFileChooser fc = new JFileChooser();\n-        fc.setFileFilter(ImportAction.getFileFilter());\n-        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n-        fc.setMultiSelectionEnabled(true);\n-\n-        if (fc.showOpenDialog(null) == JFileChooser.APPROVE_OPTION) {\n-            for (final File file : fc.getSelectedFiles()) {\n-                File dir = file;\n-                if (!dir.isDirectory()) {\n-                    dir = dir.getParentFile();\n-                }\n-\n-                Settings.get().put(Settings.DIRECTORY, dir.getAbsolutePath());\n-                try {\n-                    final FileChannel channel = FileChannel.open(file.toPath(), StandardOpenOption.READ);\n-                    final ProgressHandle handle = ProgressHandleFactory.createHandle(\"Opening file \" + file.getName());\n-                    handle.start(WORKUNITS);\n-                    final long startTime = System.currentTimeMillis();\n-                    final long start = channel.size();\n-                    ParseMonitor monitor = new ParseMonitor() {\n-                            @Override\n-                            public void updateProgress() {\n-                                try {\n-                                    int prog = (int) (WORKUNITS * (double) channel.position() \/ (double) start);\n-                                    handle.progress(prog);\n-                                } catch (IOException ignored) {}\n-                            }\n-                            @Override\n-                            public void setState(String state) {\n-                                updateProgress();\n-                                handle.progress(state);\n-                            }\n-                        };\n-                    final GraphParser parser;\n-                    final OutlineTopComponent component = OutlineTopComponent.findInstance();\n-                    if (file.getName().endsWith(\".xml\")) {\n-                        parser = new Parser(channel, monitor, null);\n-                    } else {\n-                        parser = null;\n-                    }\n-                    RequestProcessor.getDefault().post(new Runnable() {\n-                            @Override\n-                            public void run() {\n-                                try {\n-                                    final GraphDocument document = parser.parse();\n-                                    if (document != null) {\n-                                        SwingUtilities.invokeLater(() -> {\n-                                            component.requestActive();\n-                                            component.getDocument().addGraphDocument(document);\n-                                        });\n-                                    }\n-                                } catch (IOException ex) {\n-                                    Exceptions.printStackTrace(ex);\n-                                }\n-                                handle.finish();\n-                                long stop = System.currentTimeMillis();\n-                                Logger.getLogger(getClass().getName()).log(Level.INFO, \"Loaded in \" + file + \" in \" + ((stop - startTime) \/ 1000.0) + \" seconds\");\n-                            }\n-                        });\n-                } catch (IOException ex) {\n-                    Exceptions.printStackTrace(ex);\n-                }\n-            }\n-        }\n+        OutlineTopComponent.findInstance().importFromXML();\n@@ -144,6 +56,0 @@\n-    public ImportAction() {\n-        putValue(Action.SHORT_DESCRIPTION, \"Open\");\n-        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n-        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-O\"));\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/ImportAction.java","additions":8,"deletions":102,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package com.sun.hotspot.igv.coordinator.actions;\n+\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n+import javax.swing.Action;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.Utilities;\n+import org.openide.util.actions.CallableSystemAction;\n+\n+public final class OpenAction extends CallableSystemAction {\n+\n+    public OpenAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Open...\");\n+        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n+        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-O\"));\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n+    @Override\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().openFile();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NbBundle.getMessage(OpenAction.class, \"CTL_OpenAction\");\n+    }\n+\n+    @Override\n+    public HelpCtx getHelpCtx() {\n+        return HelpCtx.DEFAULT_HELP;\n+    }\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/open.png\";\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/OpenAction.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -40,0 +41,5 @@\n+    public RemoveAction() {\n+        putValue(Action.SHORT_DESCRIPTION, getName());\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n@@ -50,4 +56,0 @@\n-    public RemoveAction() {\n-        putValue(Action.SHORT_DESCRIPTION, getName());\n-    }\n-\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAction.java","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -45,1 +46,2 @@\n-        putValue(Action.SHORT_DESCRIPTION, \"Remove all graphs and groups\");\n+        putValue(Action.SHORT_DESCRIPTION, \"clear workspace\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -65,1 +67,1 @@\n-        OutlineTopComponent.findInstance().clear();\n+        OutlineTopComponent.findInstance().clearWorkspace();\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/RemoveAllAction.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package com.sun.hotspot.igv.coordinator.actions;\n+\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n+import javax.swing.Action;\n+import org.openide.util.HelpCtx;\n+import org.openide.util.ImageUtilities;\n+import org.openide.util.NbBundle;\n+import org.openide.util.Utilities;\n+import org.openide.util.actions.CallableSystemAction;\n+\n+\n+public final class SaveAction extends CallableSystemAction {\n+\n+    public SaveAction() {\n+        putValue(Action.SHORT_DESCRIPTION, \"Save\");\n+        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n+        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-S\"));\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n+    }\n+\n+    @Override\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().save();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return NbBundle.getMessage(SaveAction.class, \"CTL_SaveAction\");\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save.png\";\n+    }\n+\n+    @Override\n+    public HelpCtx getHelpCtx() {\n+        return HelpCtx.DEFAULT_HELP;\n+    }\n+\n+    @Override\n+    protected boolean asynchronous() {\n+        return false;\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAction.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 1998, 2016, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package com.sun.hotspot.igv.coordinator.actions;\n-\n-import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n-import javax.swing.Action;\n-import org.openide.util.HelpCtx;\n-import org.openide.util.NbBundle;\n-import org.openide.util.Utilities;\n-import org.openide.util.actions.CallableSystemAction;\n-\n-\/**\n- *\n- * @author Thomas Wuerthinger\n- *\/\n-\n-public final class SaveAllAction extends CallableSystemAction {\n-\n-    @Override\n-    public void performAction() {\n-        final OutlineTopComponent component = OutlineTopComponent.findInstance();\n-        SaveAsAction.save(component.getDocument());\n-    }\n-\n-    @Override\n-    public String getName() {\n-        return NbBundle.getMessage(SaveAllAction.class, \"CTL_SaveAllAction\");\n-    }\n-\n-    public SaveAllAction() {\n-        putValue(Action.SHORT_DESCRIPTION, \"Save all groups to XML file...\");\n-        \/\/ D is the Control key on most platforms, the Command (meta) key on Macintosh\n-        putValue(Action.ACCELERATOR_KEY, Utilities.stringToKey(\"D-S\"));\n-    }\n-\n-    @Override\n-    protected String iconResource() {\n-        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/saveall.gif\";\n-    }\n-\n-    @Override\n-    public HelpCtx getHelpCtx() {\n-        return HelpCtx.DEFAULT_HELP;\n-    }\n-\n-    @Override\n-    protected boolean asynchronous() {\n-        return false;\n-    }\n-}\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAllAction.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,11 +27,1 @@\n-import com.sun.hotspot.igv.coordinator.FolderNode;\n-import com.sun.hotspot.igv.data.Folder;\n-import com.sun.hotspot.igv.data.GraphDocument;\n-import com.sun.hotspot.igv.data.Group;\n-import com.sun.hotspot.igv.data.serialization.Printer;\n-import com.sun.hotspot.igv.settings.Settings;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.OutputStreamWriter;\n-import java.io.Writer;\n-import java.nio.file.Files;\n+import com.sun.hotspot.igv.coordinator.OutlineTopComponent;\n@@ -39,2 +29,0 @@\n-import javax.swing.JFileChooser;\n-import org.openide.nodes.Node;\n@@ -42,0 +30,1 @@\n+import org.openide.util.ImageUtilities;\n@@ -43,1 +32,1 @@\n-import org.openide.util.actions.NodeAction;\n+import org.openide.util.actions.CallableSystemAction;\n@@ -49,1 +38,1 @@\n-public final class SaveAsAction extends NodeAction {\n+public final class SaveAsAction extends CallableSystemAction {\n@@ -52,1 +41,2 @@\n-        putValue(Action.SHORT_DESCRIPTION, \"Save selected groups to XML file...\");\n+        putValue(Action.SHORT_DESCRIPTION, \"Save as...\");\n+        putValue(Action.SMALL_ICON, ImageUtilities.loadImageIcon(iconResource(), true));\n@@ -56,40 +46,2 @@\n-    protected void performAction(Node[] activatedNodes) {\n-        GraphDocument doc = new GraphDocument();\n-        for (Node node : activatedNodes) {\n-            if (node instanceof FolderNode) {\n-                FolderNode folderNode = (FolderNode) node;\n-                Folder folder = folderNode.getFolder();\n-                if (folder instanceof Group) {\n-                    Group group = (Group) folder;\n-                    doc.addElement(group);\n-                }\n-            }\n-        }\n-        save(doc);\n-    }\n-\n-    public static void save(GraphDocument doc) {\n-        JFileChooser fc = new JFileChooser();\n-        fc.setFileFilter(ImportAction.getFileFilter());\n-        fc.setCurrentDirectory(new File(Settings.get().get(Settings.DIRECTORY, Settings.DIRECTORY_DEFAULT)));\n-\n-        if (fc.showSaveDialog(null) == JFileChooser.APPROVE_OPTION) {\n-            File file = fc.getSelectedFile();\n-            if (!file.getName().contains(\".\")) {\n-                file = new File(file.getAbsolutePath() + \".xml\");\n-            }\n-\n-            File dir = file;\n-            if (!dir.isDirectory()) {\n-                dir = dir.getParentFile();\n-            }\n-            Settings.get().put(Settings.DIRECTORY, dir.getAbsolutePath());\n-            try {\n-                try (Writer writer = new OutputStreamWriter(Files.newOutputStream(file.toPath()))) {\n-                    Printer p = new Printer();\n-                    p.export(writer, doc);\n-                }\n-            } catch (IOException e) {\n-                e.printStackTrace();\n-            }\n-        }\n+    public void performAction() {\n+        OutlineTopComponent.findInstance().saveAs();\n@@ -105,1 +57,1 @@\n-        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save.png\";\n+        return \"com\/sun\/hotspot\/igv\/coordinator\/images\/save_as.gif\";\n@@ -117,13 +69,0 @@\n-\n-    @Override\n-    protected boolean enable(Node[] nodes) {\n-        if (nodes.length > 0) {\n-            for (Node n : nodes) {\n-                if (!(n instanceof FolderNode) || ((FolderNode) n).isRootNode()) {\n-                    return false;\n-                }\n-            }\n-            return true;\n-        }\n-        return false;\n-    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/java\/com\/sun\/hotspot\/igv\/coordinator\/actions\/SaveAsAction.java","additions":10,"deletions":71,"binary":false,"changes":81,"status":"modified"},{"patch":"@@ -1,5 +1,2 @@\n-AdvancedOption_DisplayName_Coordinator=Settings\n-AdvancedOption_Tooltip_Coordinator=Visualization Tool Settings\n-CTL_OutlineTopComponent=Outline\n-CTL_SomeAction=test\n-HINT_OutlineTopComponent=Displays loaded groups of graphs.\n+CTL_OutlineTopComponent=Workspace\n+HINT_OutlineTopComponent=Opened groups of graphs.\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/Bundle.properties","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -1,1 +1,2 @@\n-CTL_ImportAction=Open...\n+CTL_ImportAction=Import...\n+CTL_OpenAction=Open...\n@@ -5,3 +6,3 @@\n-CTL_OutlineAction=Outline\n-CTL_SaveAsAction=Save selected groups...\n-CTL_SaveAllAction=Save all groups...\n+CTL_OutlineAction=Workspace\n+CTL_SaveAction=Save\n+CTL_SaveAsAction=Save as...\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/actions\/Bundle.properties","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/import.png","binary":true,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/open.png","binary":true,"status":"added"},{"patch":"","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/save_as.gif","additions":0,"deletions":0,"binary":false,"changes":0,"previous_filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/images\/saveall.gif","status":"renamed"},{"patch":"@@ -29,0 +29,2 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-OpenAction.instance\"\/>\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAction.instance\"\/>\n@@ -30,1 +32,0 @@\n-            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAllAction.instance\"\/>\n@@ -58,0 +59,4 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-OpenAction.shadow\">\n+                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-OpenAction.instance\"\/>\n+                <attr name=\"position\" intvalue=\"50\"\/>\n+            <\/file>\n@@ -74,0 +79,4 @@\n+            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAction.shadow\">\n+                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-SaveAction.instance\"\/>\n+                <attr name=\"position\" intvalue=\"600\"\/>\n+            <\/file>\n@@ -76,5 +85,1 @@\n-                <attr name=\"position\" intvalue=\"500\"\/>\n-            <\/file>\n-            <file name=\"com-sun-hotspot-igv-coordinator-actions-SaveAllAction.shadow\">\n-                <attr name=\"originalFile\" stringvalue=\"Actions\/File\/com-sun-hotspot-igv-coordinator-actions-SaveAllAction.instance\"\/>\n-                <attr name=\"position\" intvalue=\"600\"\/>\n+                <attr name=\"position\" intvalue=\"650\"\/>\n@@ -108,1 +113,0 @@\n-            <file name=\"org-openide-actions-SaveAllAction.shadow_hidden\"\/>\n@@ -110,0 +114,1 @@\n+            <file name=\"org-openide-actions-SaveAllAction.shadow_hidden\"\/>\n","filename":"src\/utils\/IdealGraphVisualizer\/Coordinator\/src\/main\/resources\/com\/sun\/hotspot\/igv\/coordinator\/layer.xml","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-public interface Folder {\n+public interface Folder extends Properties.Provider {\n@@ -36,0 +36,1 @@\n+    Properties getProperties();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Folder.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-public interface FolderElement {\n+public interface FolderElement extends Properties.Provider {\n@@ -33,0 +33,1 @@\n+    Properties getProperties();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/FolderElement.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-            for (FolderElement e : document.elements) {\n+            for (FolderElement e : document.getElements()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/GraphDocument.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -129,1 +129,1 @@\n-        String displayName = (getParent() == null ? \"\" : getParent().getElements().indexOf(this) + 1 + \" - \") + getName();\n+        String displayName = (getParent() == null ? \"\" : getIndex() + 1 + \" - \") + getName();\n@@ -136,0 +136,9 @@\n+    public int getIndex() {\n+        Folder parent = getParent();\n+        if (parent != null) {\n+            return parent.getElements().indexOf(this);\n+        } else {\n+            return -1;\n+        }\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/Group.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import com.sun.hotspot.igv.data.GraphDocument;\n+import com.sun.hotspot.igv.data.serialization.Printer.SerialData;\n@@ -31,1 +31,1 @@\n-    GraphDocument parse() throws IOException;\n+    SerialData parse() throws IOException;\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/GraphParser.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+import com.sun.hotspot.igv.data.Properties;\n@@ -27,0 +28,2 @@\n+import com.sun.hotspot.igv.data.serialization.Printer.GraphContext;\n+import com.sun.hotspot.igv.data.serialization.Printer.SerialData;\n@@ -34,4 +37,2 @@\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.Locale;\n-import java.util.Map;\n+import java.util.*;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -52,1 +53,0 @@\n-    public static final String INDENT = \"  \";\n@@ -56,0 +56,4 @@\n+    public static final String GRAPH_STATES_ELEMENT = \"graphStates\";\n+    public static final String STATE_ELEMENT = \"state\";\n+    public static final String STATE_POSITION_DIFFERENCE = \"difference\";\n+    public static final String POSITION_DIFFERENCE_PROPERTY = \"value\";\n@@ -63,0 +67,2 @@\n+    public static final String HIDDEN_NODES_ELEMENT = \"hiddenNodes\";\n+\n@@ -66,6 +72,0 @@\n-    public static final String GROUP_NAME_PROPERTY = \"name\";\n-    public static final String METHOD_IS_PUBLIC_PROPERTY = \"public\";\n-    public static final String METHOD_IS_STATIC_PROPERTY = \"static\";\n-    public static final String TRUE_VALUE = \"true\";\n-    public static final String NODE_NAME_PROPERTY = \"name\";\n-    public static final String EDGE_NAME_PROPERTY = \"name\";\n@@ -92,1 +92,0 @@\n-    public static final String ASSEMBLY_ELEMENT = \"assembly\";\n@@ -94,1 +93,1 @@\n-    private final TopElementHandler<GraphDocument> xmlDocument = new TopElementHandler<>();\n+    private final TopElementHandler<SerialData<GraphDocument>> xmlData = new TopElementHandler<>();\n@@ -100,2 +99,0 @@\n-    private int maxId = 0;\n-    private GraphDocument graphDocument;\n@@ -104,57 +101,0 @@\n-    private boolean invokeLater = true;\n-\n-    private int lookupID(String i) {\n-        try {\n-            return Integer.parseInt(i);\n-        } catch (NumberFormatException nfe) {\n-            \/\/ ignore\n-        }\n-        Integer id = idCache.get(i);\n-        if (id == null) {\n-            id = maxId++;\n-            idCache.put(i, id);\n-        }\n-        return id;\n-    }\n-\n-    \/\/ <graphDocument>\n-    private ElementHandler<GraphDocument, Object> topHandler = new ElementHandler<GraphDocument, Object>(TOP_ELEMENT) {\n-\n-        @Override\n-        protected GraphDocument start() throws SAXException {\n-            graphDocument = new GraphDocument();\n-            return graphDocument;\n-        }\n-    };\n-    \/\/ <group>\n-    private ElementHandler<Group, Folder> groupHandler = new XMLParser.ElementHandler<Group, Folder>(GROUP_ELEMENT) {\n-\n-        @Override\n-        protected Group start() throws SAXException {\n-            final Group group = new Group(this.getParentObject());\n-\n-            String differenceProperty = this.readAttribute(DIFFERENCE_PROPERTY);\n-            Parser.this.differenceEncoding.put(group, (differenceProperty != null && (differenceProperty.equals(\"1\") || differenceProperty.equals(\"true\"))));\n-\n-            ParseMonitor monitor = getMonitor();\n-            if (monitor != null) {\n-                monitor.setState(group.getName());\n-            }\n-\n-            final Folder parent = getParentObject();\n-            if (groupCallback == null || parent instanceof Group) {\n-                Runnable addToParent = () -> parent.addElement(group);\n-                if (invokeLater) {\n-                    SwingUtilities.invokeLater(addToParent);\n-                } else {\n-                    addToParent.run();\n-                }\n-            }\n-\n-            return group;\n-        }\n-\n-        @Override\n-        protected void end(String text) throws SAXException {\n-        }\n-    };\n@@ -162,1 +102,1 @@\n-    private ElementHandler<InputMethod, Group> methodHandler = new XMLParser.ElementHandler<InputMethod, Group>(METHOD_ELEMENT) {\n+    private final ElementHandler<InputMethod, SerialData<Group>> methodHandler = new XMLParser.ElementHandler<>(METHOD_ELEMENT) {\n@@ -166,3 +106,3 @@\n-\n-            InputMethod method = parseMethod(this, getParentObject());\n-            getParentObject().setMethod(method);\n+            Group group = getParentObject().data();\n+            InputMethod method = parseMethod(this, group);\n+            group.setMethod(method);\n@@ -172,12 +112,0 @@\n-\n-    private InputMethod parseMethod(XMLParser.ElementHandler<?,?> handler, Group group) throws SAXException {\n-        String s = handler.readRequiredAttribute(METHOD_BCI_PROPERTY);\n-        int bci = 0;\n-        try {\n-            bci = Integer.parseInt(s);\n-        } catch (NumberFormatException e) {\n-            throw new SAXException(e);\n-        }\n-        InputMethod method = new InputMethod(group, handler.readRequiredAttribute(METHOD_NAME_PROPERTY), handler.readRequiredAttribute(METHOD_SHORT_NAME_PROPERTY), bci);\n-        return method;\n-    }\n@@ -185,1 +113,1 @@\n-    private HandoverElementHandler<InputMethod> bytecodesHandler = new XMLParser.HandoverElementHandler<InputMethod>(BYTECODES_ELEMENT, true) {\n+    private final HandoverElementHandler<InputMethod> bytecodesHandler = new XMLParser.HandoverElementHandler<>(BYTECODES_ELEMENT, true) {\n@@ -188,1 +116,1 @@\n-        protected void end(String text) throws SAXException {\n+        protected void end(String text) {\n@@ -193,1 +121,1 @@\n-    private HandoverElementHandler<InputMethod> inlinedHandler = new XMLParser.HandoverElementHandler<>(INLINE_ELEMENT);\n+    private final HandoverElementHandler<InputMethod> inlinedHandler = new XMLParser.HandoverElementHandler<>(INLINE_ELEMENT);\n@@ -195,1 +123,1 @@\n-    private ElementHandler<InputMethod, InputMethod> inlinedMethodHandler = new XMLParser.ElementHandler<InputMethod, InputMethod>(METHOD_ELEMENT) {\n+    private final ElementHandler<InputMethod, InputMethod> inlinedMethodHandler = new XMLParser.ElementHandler<>(METHOD_ELEMENT) {\n@@ -204,2 +132,6 @@\n-    \/\/ <graph>\n-    private ElementHandler<InputGraph, Group> graphHandler = new XMLParser.ElementHandler<InputGraph, Group>(GRAPH_ELEMENT) {\n+    \/\/ <nodes>\n+    private final HandoverElementHandler<SerialData<InputGraph>> nodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    \/\/ <controlFlow>\n+    private final HandoverElementHandler<SerialData<InputGraph>> controlFlowHandler = new HandoverElementHandler<>(CONTROL_FLOW_ELEMENT);\n+    private final HandoverElementHandler<SerialData<InputGraph>> graphStatesHandler = new HandoverElementHandler<>(GRAPH_STATES_ELEMENT);\n+    private final ElementHandler<GraphContext, SerialData<InputGraph>> stateHandler = new ElementHandler<>(STATE_ELEMENT) {\n@@ -208,20 +140,6 @@\n-        protected InputGraph start() throws SAXException {\n-            String name = readAttribute(GRAPH_NAME_PROPERTY);\n-            InputGraph curGraph = new InputGraph(name);\n-            if (differenceEncoding.get(getParentObject())) {\n-                InputGraph previous = lastParsedGraph.get(getParentObject());\n-                lastParsedGraph.put(getParentObject(), curGraph);\n-                if (previous != null) {\n-                    for (InputNode n : previous.getNodes()) {\n-                        curGraph.addNode(n);\n-                    }\n-                    for (InputEdge e : previous.getEdges()) {\n-                        curGraph.addEdge(e);\n-                    }\n-                }\n-            }\n-            ParseMonitor monitor = getMonitor();\n-            if (monitor != null) {\n-                monitor.updateProgress();\n-            }\n-            return curGraph;\n+        protected GraphContext start() {\n+            SerialData<InputGraph> data = getParentObject();\n+            InputGraph inputGraph = data.data();\n+            GraphContext graphContext = new GraphContext(inputGraph, new AtomicInteger(0), new HashSet<>());\n+            data.contexts().add(graphContext);\n+            return graphContext;\n@@ -229,0 +147,3 @@\n+    };\n+    private final HandoverElementHandler<GraphContext> hiddenNodesHandler = new HandoverElementHandler<>(HIDDEN_NODES_ELEMENT);\n+    private final ElementHandler<GraphContext, GraphContext> hiddenNodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -231,47 +152,7 @@\n-        protected void end(String text) throws SAXException {\n-            \/\/ NOTE: Some graphs intentionally don't provide blocks. Instead\n-            \/\/       they later generate the blocks from other information such\n-            \/\/       as node properties (example: ServerCompilerScheduler).\n-            \/\/       Thus, we shouldn't assign nodes that don't belong to any\n-            \/\/       block to some artificial block below unless blocks are\n-            \/\/       defined and nodes are assigned to them.\n-\n-            final InputGraph graph = getObject();\n-            final Group parent = getParentObject();\n-            if (graph.getBlocks().size() > 0) {\n-                boolean blocksContainNodes = false;\n-                for (InputBlock b : graph.getBlocks()) {\n-                    if (b.getNodes().size() > 0) {\n-                        blocksContainNodes = true;\n-                        break;\n-                    }\n-                }\n-\n-                if (!blocksContainNodes) {\n-                    graph.clearBlocks();\n-                    blockConnections.clear();\n-                } else {\n-                    \/\/ Blocks and their nodes defined: add other nodes to an\n-                    \/\/  artificial \"no block\" block\n-                    InputBlock noBlock = null;\n-                    for (InputNode n : graph.getNodes()) {\n-                        if (graph.getBlock(n) == null) {\n-                            if (noBlock == null) {\n-                                noBlock = graph.addArtificialBlock();\n-                            }\n-\n-                            noBlock.addNode(n.getId());\n-                        }\n-\n-                        assert graph.getBlock(n) != null;\n-                    }\n-                }\n-            }\n-\n-            \/\/ Resolve block successors\n-            for (Pair<String, String> p : blockConnections) {\n-                final InputBlock left = graph.getBlock(p.getLeft());\n-                assert left != null;\n-                final InputBlock right = graph.getBlock(p.getRight());\n-                assert right != null;\n-                graph.addBlockEdge(left, right);\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(NODE_ID_PROPERTY);\n+            int nodeID;\n+            try {\n+                nodeID = Integer.parseInt(s);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -279,1 +160,5 @@\n-            blockConnections.clear();\n+            getParentObject().hiddenNodes().add(nodeID);\n+            return getParentObject();\n+        }\n+    };\n+    private final ElementHandler<GraphContext, GraphContext> differenceHandler = new ElementHandler<>(STATE_POSITION_DIFFERENCE) {\n@@ -281,5 +166,8 @@\n-            Runnable addToParent = () -> parent.addElement(graph);\n-            if (invokeLater) {\n-                SwingUtilities.invokeLater(addToParent);\n-            } else {\n-                addToParent.run();\n+        @Override\n+        protected GraphContext start() throws SAXException {\n+            String s = readRequiredAttribute(POSITION_DIFFERENCE_PROPERTY);\n+            int posDiff;\n+            try {\n+                posDiff = Integer.parseInt(s);\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n@@ -287,0 +175,2 @@\n+            getParentObject().posDiff().set(posDiff);\n+            return getParentObject();\n@@ -289,4 +179,0 @@\n-    \/\/ <nodes>\n-    private HandoverElementHandler<InputGraph> nodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n-    \/\/ <controlFlow>\n-    private HandoverElementHandler<InputGraph> controlFlowHandler = new HandoverElementHandler<>(CONTROL_FLOW_ELEMENT);\n@@ -294,1 +180,1 @@\n-    private ElementHandler<InputBlock, InputGraph> blockHandler = new ElementHandler<InputBlock, InputGraph>(BLOCK_ELEMENT) {\n+    private final ElementHandler<InputBlock, SerialData<InputGraph>> blockHandler = new ElementHandler<>(BLOCK_ELEMENT) {\n@@ -298,1 +184,1 @@\n-            InputGraph graph = getParentObject();\n+            InputGraph graph = getParentObject().data();\n@@ -308,1 +194,49 @@\n-    private HandoverElementHandler<InputBlock> blockNodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    private final HandoverElementHandler<InputBlock> blockNodesHandler = new HandoverElementHandler<>(NODES_ELEMENT);\n+    \/\/ <successors>\n+    private final HandoverElementHandler<InputBlock> successorsHandler = new HandoverElementHandler<>(SUCCESSORS_ELEMENT);\n+    \/\/ <successor>\n+    private final ElementHandler<InputBlock, InputBlock> successorHandler = new ElementHandler<>(SUCCESSOR_ELEMENT) {\n+\n+        @Override\n+        protected InputBlock start() throws SAXException {\n+            String name = readRequiredAttribute(BLOCK_NAME_PROPERTY);\n+            blockConnections.add(new Pair<>(getParentObject().getName(), name));\n+            return getParentObject();\n+        }\n+    };\n+    \/\/ <graph>\n+    private final HandoverElementHandler<SerialData<InputGraph>> edgesHandler = new HandoverElementHandler<>(EDGES_ELEMENT);\n+    \/\/ <edge>\n+    private final EdgeElementHandler edgeHandler = new EdgeElementHandler(EDGE_ELEMENT) {\n+\n+        @Override\n+        protected InputEdge start(InputEdge conn) {\n+            getParentObject().data().addEdge(conn);\n+            return conn;\n+        }\n+    };\n+    \/\/ <removeEdge>\n+    private final EdgeElementHandler removeEdgeHandler = new EdgeElementHandler(REMOVE_EDGE_ELEMENT) {\n+\n+        @Override\n+        protected InputEdge start(InputEdge conn) {\n+            getParentObject().data().removeEdge(conn);\n+            return conn;\n+        }\n+    };\n+    \/\/ <properties>\n+    private final HandoverElementHandler<Properties.Provider> propertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT);\n+    \/\/ <property>\n+    private final ElementHandler<String, Properties.Provider> propertyHandler = new XMLParser.ElementHandler<>(PROPERTY_ELEMENT, true) {\n+\n+        @Override\n+        public String start() throws SAXException {\n+            return readRequiredAttribute(PROPERTY_NAME_PROPERTY);\n+        }\n+\n+        @Override\n+        public void end(String text) {\n+            getParentObject().getProperties().setProperty(getObject(), text.trim());\n+        }\n+    };\n+    private int maxId = 0;\n@@ -310,1 +244,1 @@\n-    private ElementHandler<InputBlock, InputBlock> blockNodeHandler = new ElementHandler<InputBlock, InputBlock>(NODE_ELEMENT) {\n+    private final ElementHandler<InputBlock, InputBlock> blockNodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -316,1 +250,1 @@\n-            int id = 0;\n+            int id;\n@@ -326,12 +260,0 @@\n-    \/\/ <successors>\n-    private HandoverElementHandler<InputBlock> successorsHandler = new HandoverElementHandler<>(SUCCESSORS_ELEMENT);\n-    \/\/ <successor>\n-    private ElementHandler<InputBlock, InputBlock> successorHandler = new ElementHandler<InputBlock, InputBlock>(SUCCESSOR_ELEMENT) {\n-\n-        @Override\n-        protected InputBlock start() throws SAXException {\n-            String name = readRequiredAttribute(BLOCK_NAME_PROPERTY);\n-            blockConnections.add(new Pair<>(getParentObject().getName(), name));\n-            return getParentObject();\n-        }\n-    };\n@@ -339,1 +261,1 @@\n-    private ElementHandler<InputNode, InputGraph> nodeHandler = new ElementHandler<InputNode, InputGraph>(NODE_ELEMENT) {\n+    private final ElementHandler<InputNode, SerialData<InputGraph>> nodeHandler = new ElementHandler<>(NODE_ELEMENT) {\n@@ -344,1 +266,1 @@\n-            int id = 0;\n+            int id;\n@@ -351,1 +273,1 @@\n-            getParentObject().addNode(node);\n+            getParentObject().data().addNode(node);\n@@ -356,1 +278,1 @@\n-    private ElementHandler<InputNode, InputGraph> removeNodeHandler = new ElementHandler<InputNode, InputGraph>(REMOVE_NODE_ELEMENT) {\n+    private final ElementHandler<InputNode, SerialData<InputGraph>> removeNodeHandler = new ElementHandler<>(REMOVE_NODE_ELEMENT) {\n@@ -361,1 +283,1 @@\n-            int id = 0;\n+            int id;\n@@ -367,1 +289,1 @@\n-            return getParentObject().removeNode(id);\n+            return getParentObject().data().removeNode(id);\n@@ -370,5 +292,3 @@\n-    \/\/ <graph>\n-    private HandoverElementHandler<InputGraph> edgesHandler = new HandoverElementHandler<>(EDGES_ELEMENT);\n-\n-    \/\/ Local class for edge elements\n-    private class EdgeElementHandler extends ElementHandler<InputEdge, InputGraph> {\n+    private SerialData<GraphDocument> serialData;\n+    \/\/ <graphDocument>\n+    private final ElementHandler<SerialData<GraphDocument>, Object> topHandler = new ElementHandler<>(TOP_ELEMENT) {\n@@ -376,2 +296,4 @@\n-        public EdgeElementHandler(String name) {\n-            super(name);\n+        @Override\n+        protected SerialData<GraphDocument> start() {\n+            serialData = new SerialData<>(new GraphDocument(), new HashSet<>());\n+            return serialData;\n@@ -379,0 +301,3 @@\n+    };\n+    \/\/ <group>\n+    private final ElementHandler<SerialData<Group>, SerialData<? extends Folder>> groupHandler = new XMLParser.ElementHandler<>(GROUP_ELEMENT) {\n@@ -381,7 +306,3 @@\n-        protected InputEdge start() throws SAXException {\n-            int fromIndex = 0;\n-            int toIndex = 0;\n-            int from = -1;\n-            int to = -1;\n-            String label = null;\n-            String type = null;\n+        protected SerialData<Group> start() {\n+            final Folder folder = getParentObject().data();\n+            final Group group = new Group(folder);\n@@ -389,16 +310,2 @@\n-            try {\n-                String fromIndexString = readAttribute(FROM_INDEX_PROPERTY);\n-                if (fromIndexString != null) {\n-                    fromIndex = Integer.parseInt(fromIndexString);\n-                }\n-\n-                String toIndexString = readAttribute(TO_INDEX_PROPERTY);\n-                if (toIndexString == null) {\n-                    toIndexString = readAttribute(TO_INDEX_ALT_PROPERTY);\n-                }\n-                if (toIndexString != null) {\n-                    toIndex = Integer.parseInt(toIndexString);\n-                }\n-\n-                label = readAttribute(LABEL_PROPERTY);\n-                type = readAttribute(TYPE_PROPERTY);\n+            String differenceProperty = this.readAttribute(DIFFERENCE_PROPERTY);\n+            Parser.this.differenceEncoding.put(group, (differenceProperty != null && (differenceProperty.equals(\"1\") || differenceProperty.equals(\"true\"))));\n@@ -406,4 +313,3 @@\n-                from = lookupID(readRequiredAttribute(FROM_PROPERTY));\n-                to = lookupID(readRequiredAttribute(TO_PROPERTY));\n-            } catch (NumberFormatException e) {\n-                throw new SAXException(e);\n+            ParseMonitor monitor = getMonitor();\n+            if (monitor != null) {\n+                monitor.setState(group.getName());\n@@ -412,3 +318,3 @@\n-            InputEdge conn = new InputEdge((char) fromIndex, (char) toIndex, from, to, label, type == null ? \"\" : type);\n-            return start(conn);\n-        }\n+            if (groupCallback == null || folder instanceof Group) {\n+                folder.addElement(group);\n+            }\n@@ -416,2 +322,1 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            return conn;\n+            return new SerialData<>(group, getParentObject().contexts());\n@@ -419,3 +324,0 @@\n-    }\n-    \/\/ <edge>\n-    private EdgeElementHandler edgeHandler = new EdgeElementHandler(EDGE_ELEMENT) {\n@@ -424,3 +326,1 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            getParentObject().addEdge(conn);\n-            return conn;\n+        protected void end(String text) {\n@@ -429,2 +329,2 @@\n-    \/\/ <removeEdge>\n-    private EdgeElementHandler removeEdgeHandler = new EdgeElementHandler(REMOVE_EDGE_ELEMENT) {\n+    \/\/ <graph>\n+    private final ElementHandler<SerialData<InputGraph>, SerialData<Group>> graphHandler = new XMLParser.ElementHandler<>(GRAPH_ELEMENT) {\n@@ -433,3 +333,21 @@\n-        protected InputEdge start(InputEdge conn) throws SAXException {\n-            getParentObject().removeEdge(conn);\n-            return conn;\n+        protected SerialData<InputGraph> start() {\n+            Group group = getParentObject().data();\n+            String name = readAttribute(GRAPH_NAME_PROPERTY);\n+            InputGraph curGraph = new InputGraph(name);\n+            if (differenceEncoding.get(group)) {\n+                InputGraph previous = lastParsedGraph.get(group);\n+                lastParsedGraph.put(group, curGraph);\n+                if (previous != null) {\n+                    for (InputNode n : previous.getNodes()) {\n+                        curGraph.addNode(n);\n+                    }\n+                    for (InputEdge e : previous.getEdges()) {\n+                        curGraph.addEdge(e);\n+                    }\n+                }\n+            }\n+            ParseMonitor monitor = getMonitor();\n+            if (monitor != null) {\n+                monitor.updateProgress();\n+            }\n+            return new SerialData<>(curGraph, new HashSet<>());\n@@ -437,5 +355,0 @@\n-    };\n-    \/\/ <properties>\n-    private HandoverElementHandler<Properties.Provider> propertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT);\n-    \/\/ <properties>\n-    private HandoverElementHandler<Group> groupPropertiesHandler = new HandoverElementHandler<Group>(PROPERTIES_ELEMENT) {\n@@ -444,6 +357,23 @@\n-        public void end(String text) throws SAXException {\n-            if (groupCallback != null && getParentObject().getParent() instanceof GraphDocument) {\n-                final Group group = getParentObject();\n-                Runnable addStarted = () -> groupCallback.started(group);\n-                if (invokeLater) {\n-                    SwingUtilities.invokeLater(addStarted);\n+        protected void end(String text) {\n+            \/\/ NOTE: Some graphs intentionally don't provide blocks. Instead,\n+            \/\/       they later generate the blocks from other information such\n+            \/\/       as node properties (example: ServerCompilerScheduler).\n+            \/\/       Thus, we shouldn't assign nodes that don't belong to any\n+            \/\/       block to some artificial block below unless blocks are\n+            \/\/       defined and nodes are assigned to them.\n+\n+            final InputGraph graph = getObject().data();\n+\n+            final Group parent = getParentObject().data();\n+            if (!graph.getBlocks().isEmpty()) {\n+                boolean blocksContainNodes = false;\n+                for (InputBlock b : graph.getBlocks()) {\n+                    if (!b.getNodes().isEmpty()) {\n+                        blocksContainNodes = true;\n+                        break;\n+                    }\n+                }\n+\n+                if (!blocksContainNodes) {\n+                    graph.clearBlocks();\n+                    blockConnections.clear();\n@@ -451,1 +381,14 @@\n-                    addStarted.run();\n+                    \/\/ Blocks and their nodes defined: add other nodes to an\n+                    \/\/  artificial \"no block\" block\n+                    InputBlock noBlock = null;\n+                    for (InputNode n : graph.getNodes()) {\n+                        if (graph.getBlock(n) == null) {\n+                            if (noBlock == null) {\n+                                noBlock = graph.addArtificialBlock();\n+                            }\n+\n+                            noBlock.addNode(n.getId());\n+                        }\n+\n+                        assert graph.getBlock(n) != null;\n+                    }\n@@ -454,0 +397,13 @@\n+\n+            \/\/ Resolve block successors\n+            for (Pair<String, String> p : blockConnections) {\n+                final InputBlock left = graph.getBlock(p.getLeft());\n+                assert left != null;\n+                final InputBlock right = graph.getBlock(p.getRight());\n+                assert right != null;\n+                graph.addBlockEdge(left, right);\n+            }\n+            blockConnections.clear();\n+\n+            parent.addElement(graph);\n+            getParentObject().contexts().addAll(getObject().contexts());\n@@ -456,7 +412,2 @@\n-    \/\/ <property>\n-    private ElementHandler<String, Properties.Provider> propertyHandler = new XMLParser.ElementHandler<String, Properties.Provider>(PROPERTY_ELEMENT, true) {\n-\n-        @Override\n-        public String start() throws SAXException {\n-            return readRequiredAttribute(PROPERTY_NAME_PROPERTY);\n-         }\n+    \/\/ <properties>\n+    private final HandoverElementHandler<SerialData<Group>> groupPropertiesHandler = new HandoverElementHandler<>(PROPERTIES_ELEMENT) {\n@@ -466,1 +417,4 @@\n-            getParentObject().getProperties().setProperty(getObject(), text.trim());\n+            final Group group = getParentObject().data();\n+            if (groupCallback != null && group.getParent() instanceof GraphDocument) {\n+                groupCallback.started(group);\n+            }\n@@ -469,1 +423,0 @@\n-\n@@ -473,1 +426,0 @@\n-\n@@ -481,1 +433,1 @@\n-        xmlDocument.addChild(topHandler);\n+        xmlData.addChild(topHandler);\n@@ -498,0 +450,1 @@\n+        graphHandler.addChild(graphStatesHandler);\n@@ -501,0 +454,5 @@\n+        graphStatesHandler.addChild(stateHandler);\n+        stateHandler.addChild(differenceHandler);\n+        stateHandler.addChild(hiddenNodesHandler);\n+        hiddenNodesHandler.addChild(hiddenNodeHandler);\n+\n@@ -521,0 +479,25 @@\n+    private int lookupID(String i) {\n+        try {\n+            return Integer.parseInt(i);\n+        } catch (NumberFormatException nfe) {\n+            \/\/ ignore\n+        }\n+        Integer id = idCache.get(i);\n+        if (id == null) {\n+            id = maxId++;\n+            idCache.put(i, id);\n+        }\n+        return id;\n+    }\n+\n+    private InputMethod parseMethod(XMLParser.ElementHandler<?, ?> handler, Group group) throws SAXException {\n+        String s = handler.readRequiredAttribute(METHOD_BCI_PROPERTY);\n+        int bci;\n+        try {\n+            bci = Integer.parseInt(s);\n+        } catch (NumberFormatException e) {\n+            throw new SAXException(e);\n+        }\n+        return new InputMethod(group, handler.readRequiredAttribute(METHOD_NAME_PROPERTY), handler.readRequiredAttribute(METHOD_SHORT_NAME_PROPERTY), bci);\n+    }\n+\n@@ -523,1 +506,1 @@\n-    public GraphDocument parse() throws IOException {\n+    public SerialData<GraphDocument> parse() throws IOException {\n@@ -531,1 +514,1 @@\n-            reader.setContentHandler(new XMLParser(xmlDocument, monitor));\n+            reader.setContentHandler(new XMLParser(xmlData, monitor));\n@@ -541,2 +524,0 @@\n-        return graphDocument;\n-    }\n@@ -544,4 +525,1 @@\n-    \/\/ Whether the parser is allowed to defer connecting the parsed elements.\n-    \/\/ Setting to false is useful for synchronization in unit tests.\n-    public void setInvokeLater(boolean invokeLater) {\n-        this.invokeLater = invokeLater;\n+        return serialData;\n@@ -552,4 +530,4 @@\n-            SAXParserFactory pfactory = SAXParserFactory.newInstance();\n-            pfactory.setValidating(false);\n-            pfactory.setNamespaceAware(true);\n-            return pfactory.newSAXParser().getXMLReader();\n+            SAXParserFactory pFactory = SAXParserFactory.newInstance();\n+            pFactory.setValidating(false);\n+            pFactory.setNamespaceAware(true);\n+            return pFactory.newSAXParser().getXMLReader();\n@@ -560,0 +538,48 @@\n+\n+    \/\/ Local class for edge elements\n+    private class EdgeElementHandler extends ElementHandler<InputEdge, SerialData<InputGraph>> {\n+\n+        public EdgeElementHandler(String name) {\n+            super(name);\n+        }\n+\n+        @Override\n+        protected InputEdge start() throws SAXException {\n+            int fromIndex = 0;\n+            int toIndex = 0;\n+            int from;\n+            int to;\n+            String label;\n+            String type;\n+\n+            try {\n+                String fromIndexString = readAttribute(FROM_INDEX_PROPERTY);\n+                if (fromIndexString != null) {\n+                    fromIndex = Integer.parseInt(fromIndexString);\n+                }\n+\n+                String toIndexString = readAttribute(TO_INDEX_PROPERTY);\n+                if (toIndexString == null) {\n+                    toIndexString = readAttribute(TO_INDEX_ALT_PROPERTY);\n+                }\n+                if (toIndexString != null) {\n+                    toIndex = Integer.parseInt(toIndexString);\n+                }\n+\n+                label = readAttribute(LABEL_PROPERTY);\n+                type = readAttribute(TYPE_PROPERTY);\n+\n+                from = lookupID(readRequiredAttribute(FROM_PROPERTY));\n+                to = lookupID(readRequiredAttribute(TO_PROPERTY));\n+            } catch (NumberFormatException e) {\n+                throw new SAXException(e);\n+            }\n+\n+            InputEdge conn = new InputEdge((char) fromIndex, (char) toIndex, from, to, label, type == null ? \"\" : type);\n+            return start(conn);\n+        }\n+\n+        protected InputEdge start(InputEdge conn) {\n+            return conn;\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Parser.java","additions":306,"deletions":280,"binary":false,"changes":586,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.InputStream;\n@@ -32,0 +31,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.stream.Collectors;\n@@ -39,11 +40,0 @@\n-    private final InputStream in;\n-\n-    public Printer() {\n-        this(null);\n-    }\n-\n-    public Printer(InputStream inputStream) {\n-        this.in = inputStream;\n-    }\n-\n-    public void export(Writer writer, GraphDocument document) {\n@@ -51,0 +41,3 @@\n+    public static void exportGraphDocument(Writer writer, SerialData<Folder> serialData) {\n+        Folder folder = serialData.data();\n+        Set<GraphContext> contexts = serialData.contexts();\n@@ -52,1 +45,0 @@\n-\n@@ -54,12 +46,8 @@\n-            export(xmlWriter, document);\n-        } catch (IOException ignored) {}\n-    }\n-\n-    private void export(XMLWriter xmlWriter, GraphDocument document) throws IOException {\n-        xmlWriter.startTag(Parser.ROOT_ELEMENT);\n-        xmlWriter.writeProperties(document.getProperties());\n-        for (FolderElement e : document.getElements()) {\n-            if (e instanceof Group) {\n-                export(xmlWriter, (Group) e);\n-            } else if (e instanceof InputGraph) {\n-                export(xmlWriter, (InputGraph)e, null, false);\n+            xmlWriter.startTag(Parser.ROOT_ELEMENT);\n+            xmlWriter.writeProperties(folder.getProperties());\n+            for (FolderElement e : folder.getElements()) {\n+                if (e instanceof Group group) {\n+                    exportGroup(xmlWriter, group, contexts);\n+                } else if (e instanceof InputGraph graph) {\n+                    exportInputGraph(xmlWriter, graph, null, false, contexts);\n+                }\n@@ -67,4 +55,3 @@\n-        }\n-\n-        xmlWriter.endTag();\n-        xmlWriter.flush();\n+            xmlWriter.endTag();\n+            xmlWriter.flush();\n+        } catch (IOException ignored) {}\n@@ -73,1 +60,1 @@\n-    private void export(XMLWriter writer, Group g) throws IOException {\n+    private static void exportGroup(XMLWriter writer, Group g, Set<GraphContext> contexts) throws IOException {\n@@ -79,6 +66,2 @@\n-        boolean shouldExport = true;\n-        if (in != null) {\n-            char c = (char) in.read();\n-            if (c != 'y') {\n-                shouldExport = false;\n-            }\n+        if (g.getMethod() != null) {\n+            exportInputMethod(writer, g.getMethod());\n@@ -87,14 +70,7 @@\n-        if (shouldExport) {\n-            if (g.getMethod() != null) {\n-                export(writer, g.getMethod());\n-            }\n-\n-            InputGraph previous = null;\n-            for (FolderElement e : g.getElements()) {\n-                if (e instanceof InputGraph) {\n-                    InputGraph graph = (InputGraph) e;\n-                    export(writer, graph, previous, true);\n-                    previous = graph;\n-                } else if (e instanceof Group) {\n-                    export(writer, (Group) e);\n-                }\n+        InputGraph previous = null;\n+        for (FolderElement e : g.getElements()) {\n+            if (e instanceof InputGraph graph) {\n+                exportInputGraph(writer, graph, previous, true, contexts);\n+                previous = graph;\n+            } else if (e instanceof Group group) {\n+                exportGroup(writer, group, contexts);\n@@ -107,2 +83,1 @@\n-    public void export(XMLWriter writer, InputGraph graph, InputGraph previous, boolean difference) throws IOException {\n-\n+    private static void exportInputGraph(XMLWriter writer, InputGraph graph, InputGraph previous, boolean difference, Set<GraphContext> contexts) throws IOException {\n@@ -138,1 +113,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.NODE_ELEMENT\n@@ -142,1 +117,1 @@\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.NODES_ELEMENT\n@@ -172,1 +147,1 @@\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.EDGES_ELEMENT\n@@ -178,1 +153,1 @@\n-            if (b.getSuccessors().size() > 0) {\n+            if (!b.getSuccessors().isEmpty()) {\n@@ -183,1 +158,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.SUCCESSORS_ELEMENT\n@@ -186,2 +161,2 @@\n-            if (b.getNodes().size() > 0) {\n-            writer.startTag(Parser.NODES_ELEMENT);\n+            if (!b.getNodes().isEmpty()) {\n+                writer.startTag(Parser.NODES_ELEMENT);\n@@ -191,1 +166,1 @@\n-                writer.endTag();\n+                writer.endTag(); \/\/ Parser.NODES_ELEMENT\n@@ -194,1 +169,1 @@\n-            writer.endTag();\n+            writer.endTag(); \/\/ Parser.BLOCK_ELEMENT\n@@ -197,2 +172,5 @@\n-        writer.endTag();\n-        writer.endTag();\n+        writer.endTag(); \/\/ Parser.CONTROL_FLOW_ELEMENT\n+\n+        exportStates(writer, graph, contexts);\n+\n+        writer.endTag(); \/\/ Parser.GRAPH_ELEMENT\n@@ -201,1 +179,18 @@\n-    private void export(XMLWriter w, InputMethod method) throws IOException {\n+    private static void exportStates(XMLWriter writer, InputGraph exportingGraph, Set<GraphContext> contexts) throws IOException {\n+        Set<GraphContext> contextsContainingGraph = contexts.stream()\n+                .filter(context -> context.inputGraph().equals(exportingGraph))\n+                .collect(Collectors.toSet());\n+\n+        if (contextsContainingGraph.isEmpty()) {\n+            return;\n+        }\n+\n+        writer.startTag(Parser.GRAPH_STATES_ELEMENT);\n+\n+        for (GraphContext context : contextsContainingGraph) {\n+            assert exportingGraph == context.inputGraph();\n+\n+            writer.startTag(Parser.STATE_ELEMENT);\n+\n+            writer.simpleTag(Parser.STATE_POSITION_DIFFERENCE,\n+                    new Properties(Parser.POSITION_DIFFERENCE_PROPERTY, Integer.toString(context.posDiff().get())));\n@@ -203,0 +198,13 @@\n+            writer.startTag(Parser.HIDDEN_NODES_ELEMENT);\n+            for (Integer hiddenNodeID : context.hiddenNodes()) {\n+                writer.simpleTag(Parser.NODE_ELEMENT, new Properties(Parser.NODE_ID_PROPERTY, hiddenNodeID.toString()));\n+            }\n+            writer.endTag(); \/\/ Parser.HIDDEN_NODES_ELEMENT\n+\n+            writer.endTag(); \/\/ Parser.STATES_ELEMENT\n+        }\n+\n+        writer.endTag(); \/\/ Parser.GRAPH_STATE_ELEMENT\n+    }\n+\n+    private static void exportInputMethod(XMLWriter w, InputMethod method) throws IOException {\n@@ -207,1 +215,1 @@\n-        if (method.getInlined().size() > 0) {\n+        if (!method.getInlined().isEmpty()) {\n@@ -210,1 +218,1 @@\n-                export(w, m);\n+                exportInputMethod(w, m);\n@@ -232,1 +240,1 @@\n-    private Properties createProperties(InputEdge edge) {\n+    private static Properties createProperties(InputEdge edge) {\n@@ -245,0 +253,10 @@\n+\n+    public record GraphContext(InputGraph inputGraph, AtomicInteger posDiff, Set<Integer> hiddenNodes) { }\n+\n+    public record SerialData<T extends Properties.Provider>(T data,\n+                                                            Set<GraphContext> contexts) implements Properties.Provider {\n+        @Override\n+        public Properties getProperties() {\n+            return data.getProperties();\n+        }\n+    }\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/Printer.java","additions":86,"deletions":68,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-    void view(InputGraph graph, boolean newTab);\n+    InputGraph view(InputGraph graph, boolean newTab);\n@@ -36,1 +36,1 @@\n-    void viewDifference(InputGraph firstGraph, InputGraph secondGraph);\n+    InputGraph viewDifference(InputGraph firstGraph, InputGraph secondGraph);\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/main\/java\/com\/sun\/hotspot\/igv\/data\/services\/GraphViewer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import java.util.HashSet;\n@@ -65,1 +66,0 @@\n-        final Printer printer = new Printer();\n@@ -67,1 +67,1 @@\n-        printer.export(writer, document);\n+        Printer.exportGraphDocument(writer, new Printer.SerialData<>(document, new HashSet<>()));\n@@ -75,2 +75,2 @@\n-            parser.setInvokeLater(false);\n-            final GraphDocument parsedDocument = parser.parse();\n+            final Printer.SerialData<GraphDocument> exportData = parser.parse();\n+            final GraphDocument parsedDocument = exportData.data();\n","filename":"src\/utils\/IdealGraphVisualizer\/Data\/src\/test\/java\/com\/sun\/hotspot\/igv\/data\/serialization\/ParserTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -86,1 +86,2 @@\n-                        RequestProcessor.getDefault().post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n+                        RequestProcessor requestProcessor = new RequestProcessor();\n+                        requestProcessor.post(new Client(clientSocket, callback), 0, Thread.MAX_PRIORITY);\n","filename":"src\/utils\/IdealGraphVisualizer\/NetworkConnection\/src\/main\/java\/com\/sun\/hotspot\/igv\/connection\/Server.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -128,2 +128,1 @@\n-        if (group.getParent() instanceof GraphDocument) {\n-            final GraphDocument doc = (GraphDocument) group.getParent();\n+        if (group.getParent() instanceof GraphDocument doc) {\n@@ -312,2 +311,1 @@\n-                if (t instanceof EditorTopComponent) {\n-                    EditorTopComponent etc = (EditorTopComponent) t;\n+                if (t instanceof EditorTopComponent etc) {\n@@ -329,5 +327,7 @@\n-        Group group = getModel().getGroup();\n-        if (!group.getParent().getElements().contains(group) ||\n-            group.getGraphs().isEmpty()) {\n-            close();\n-        }\n+        SwingUtilities.invokeLater(() -> {\n+            Group group = getModel().getGroup();\n+            if (!group.getParent().getElements().contains(group) ||\n+                    group.getGraphs().isEmpty()) {\n+                close();\n+            }\n+        });\n@@ -408,2 +408,1 @@\n-                if (topComponent instanceof EditorTopComponent) {\n-                    EditorTopComponent editor = (EditorTopComponent) topComponent;\n+                if (topComponent instanceof EditorTopComponent editor) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":11,"deletions":12,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,0 @@\n-import com.sun.hotspot.igv.graph.Diagram;\n-import com.sun.hotspot.igv.settings.Settings;\n@@ -41,1 +39,1 @@\n-    public void viewDifference(InputGraph firstGraph, InputGraph secondGraph) {\n+    public InputGraph viewDifference(InputGraph firstGraph, InputGraph secondGraph) {\n@@ -44,1 +42,1 @@\n-            view(diffGraph, true);\n+            return view(diffGraph, true);\n@@ -46,5 +44,7 @@\n-            view(firstGraph, true);\n-            EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n-            if (etc != null) {\n-                etc.getModel().selectDiffGraph(secondGraph);\n-                etc.requestActive();\n+            if (view(firstGraph, true) != null) {\n+                EditorTopComponent etc = EditorTopComponent.findEditorForGraph(firstGraph);\n+                if (etc != null) {\n+                    etc.getModel().selectDiffGraph(secondGraph);\n+                    etc.requestActive();\n+                    return etc.getModel().getGraph();\n+                }\n@@ -52,0 +52,1 @@\n+            return null;\n@@ -56,1 +57,1 @@\n-    public void view(InputGraph graph, boolean newTab) {\n+    public InputGraph view(InputGraph graph, boolean newTab) {\n@@ -62,1 +63,1 @@\n-                return;\n+                return etc.getModel().getGraph();\n@@ -69,0 +70,1 @@\n+        return etc.getModel().getGraph();\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/GraphViewerImplementation.java","additions":14,"deletions":12,"binary":false,"changes":26,"status":"modified"}]}