{"files":[{"patch":"@@ -418,1 +418,3 @@\n-void ClassLoaderData::record_dependency(const Klass* k) {\n+\/\/ An explicit dependency might be needed to prevent unloading of Klass* k\n+\/\/ before this CLD is unloading.\n+bool ClassLoaderData::needs_dependency(const Klass* k) {\n@@ -424,1 +426,1 @@\n-  \/\/ Do not need to record dependency if the dependency is to a class whose\n+  \/\/ Do not need a dependency if the dependency is to a class whose\n@@ -429,1 +431,1 @@\n-    return;\n+    return false;\n@@ -434,3 +436,2 @@\n-    \/\/ Just return if a non-strong hidden class class is attempting to record a dependency\n-    \/\/ to itself.  (Note that every non-strong hidden class has its own unique class\n-    \/\/ loader data.)\n+    \/\/ An explicit dependency to itself is not needed.\n+    \/\/ (Note that every non-strong hidden class has its own unique class loader data.)\n@@ -438,1 +439,1 @@\n-      return;\n+      return false;\n@@ -446,2 +447,2 @@\n-    \/\/ Just return if this dependency is to a class with the same or a parent\n-    \/\/ class_loader.\n+    \/\/ K cannot be unloaded before this CLD is unloading if it has the same\n+    \/\/ or a parent class_loader.\n@@ -449,1 +450,1 @@\n-      return; \/\/ this class loader is in the parent list, no need to add it.\n+      return false;\n@@ -453,2 +454,9 @@\n-  \/\/ It's a dependency we won't find through GC, add it.\n-  if (!_handles.contains(to)) {\n+  \/\/ An explicit dependency is needed. Let's see if it's already recorded.\n+  return !_handles.contains(to);\n+}\n+\n+void ClassLoaderData::record_dependency(const Klass* k) {\n+  if (needs_dependency(k)) {\n+    \/\/ It's a dependency we won't find through GC, add it.\n+    ClassLoaderData * const to_cld = k->class_loader_data();\n+    oop to = to_cld->has_class_mirror_holder() ? k->java_mirror() : to_cld->class_loader();\n@@ -790,4 +798,0 @@\n-bool ClassLoaderData::handles_contain(oop obj) {\n-  return _handles.contains(obj);\n-}\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -293,1 +293,0 @@\n-  bool handles_contain(oop obj);\n@@ -300,0 +299,1 @@\n+  bool needs_dependency(const Klass* to);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -383,1 +383,0 @@\n-  static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1385,1 +1385,0 @@\n-\/\/ (See also ClassLoaderData::record_dependency())\n@@ -1395,3 +1394,1 @@\n-  oop to_holder = to_klass->klass_holder();\n-  ClassLoaderData * const to_cld = to_klass->class_loader_data();\n-  if (from_nm != nullptr && !to_cld->is_permanent_class_loader_data()) {\n+  if (from_nm != nullptr && !to_klass->class_loader_data()->is_permanent_class_loader_data()) {\n@@ -1405,13 +1402,2 @@\n-    if (to_cld->has_class_mirror_holder()) {\n-      if (from_cld == to_cld) {\n-        return;\n-      }\n-    } else {\n-      oop to = to_cld->class_loader();\n-      oop from = from_cld->class_loader();\n-\n-      if (from == to ||\n-          (!from_cld->is_boot_class_loader_data() &&\n-           java_lang_ClassLoader::isAncestor(from, to))) {\n-        return; \/\/ `to` is reachable by iterating parents of `from`\n-      }\n+    if (!from_cld->needs_dependency(to_klass)) {\n+      return; \/\/ dependency is not needed or has been recorded\n@@ -1420,4 +1406,4 @@\n-    \/\/ Search for to_holder in the oops. to_holder has to be reachable from the\n-    \/\/ receiver. If it is a constant among the oops, then there is also a path\n-    \/\/ from the caller to to_holder.\n-    Search2OopsClosure f(to_holder, receiver());\n+    \/\/ Search the oop constants of the caller for the holder of the target. Also\n+    \/\/ look for the receiver. If we find it then this means a permanent path to\n+    \/\/ the callee exists because the callee does not depend on the receiver.\n+    Search2OopsClosure f(to_klass->klass_holder(), receiver());\n@@ -1425,11 +1411,1 @@\n-    if (f.found()) {\n-      return;\n-    }\n-\n-    \/\/ The callers loader will keep the callee alive if a dependency has been recorded with\n-    \/\/ ClassLoaderData::record_dependency()\n-    if (from_cld->handles_contain(to_holder)) {\n-      return;\n-    }\n-\n-    {\n+    if (!f.found()) {\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":8,"deletions":32,"binary":false,"changes":40,"status":"modified"}]}