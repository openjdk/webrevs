{"files":[{"patch":"@@ -375,32 +375,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {\n-  BarrierSetNMethod* bs = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs == NULL) {\n-    return;\n-  }\n-\n-  Label bad_call;\n-  __ cbz(rmethod, bad_call);\n-\n-  \/\/ Pointer chase to the method holder to find out if the method is concurrently unloading.\n-  Label method_live;\n-  __ load_method_holder_cld(rscratch1, rmethod);\n-\n-  \/\/ Is it a strong CLD?\n-  __ ldrw(rscratch2, Address(rscratch1, ClassLoaderData::keep_alive_offset()));\n-  __ cbnz(rscratch2, method_live);\n-\n-  \/\/ Is it a weak but alive CLD?\n-  __ push(RegSet::of(r10), sp);\n-  __ ldr(r10, Address(rscratch1, ClassLoaderData::holder_offset()));\n-\n-  __ resolve_weak_handle(r10, rscratch1, rscratch2);\n-  __ mov(rscratch1, r10);\n-  __ pop(RegSet::of(r10), sp);\n-  __ cbnz(rscratch1, method_live);\n-\n-  __ bind(bad_call);\n-\n-  __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-  __ bind(method_live);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -119,1 +119,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4306,5 +4306,0 @@\n-void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {\n-  load_method_holder(rresult, rmethod);\n-  ldr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));\n-}\n-\n@@ -4337,15 +4332,0 @@\n-\/\/ ((WeakHandle)result).resolve();\n-void MacroAssembler::resolve_weak_handle(Register result, Register tmp1, Register tmp2) {\n-  assert_different_registers(result, tmp1, tmp2);\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  cbz(result, resolved);\n-\n-  \/\/ Only 64 bit platforms support GCs that require a tmp register\n-  \/\/ WeakHandle::resolve is an indirection like jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n-                 result, Address(result), tmp1, tmp2);\n-  bind(resolved);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -848,1 +848,0 @@\n-  void load_method_holder_cld(Register rresult, Register rmethod);\n@@ -857,1 +856,0 @@\n-  void resolve_weak_handle(Register result, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -789,3 +789,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -215,44 +215,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler *masm, Register tmp1, Register tmp2, Register tmp3) {\n-  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs_nm == nullptr) {\n-    return;\n-  }\n-\n-  assert_different_registers(tmp1, tmp2, tmp3);\n-\n-  __ block_comment(\"c2i_entry_barrier (c2i_entry_barrier) {\");\n-\n-  Register tmp1_class_loader_data = tmp1;\n-\n-  Label bad_call, skip_barrier;\n-\n-  \/\/ Fast path: If no method is given, the call is definitely bad.\n-  __ cmpdi(CCR0, R19_method, 0);\n-  __ beq(CCR0, bad_call);\n-\n-  \/\/ Load class loader data to determine whether the method's holder is concurrently unloading.\n-  __ load_method_holder(tmp1, R19_method);\n-  __ ld(tmp1_class_loader_data, in_bytes(InstanceKlass::class_loader_data_offset()), tmp1);\n-\n-  \/\/ Fast path: If class loader is strong, the holder cannot be unloaded.\n-  __ lwz(tmp2, in_bytes(ClassLoaderData::keep_alive_offset()), tmp1_class_loader_data);\n-  __ cmpdi(CCR0, tmp2, 0);\n-  __ bne(CCR0, skip_barrier);\n-\n-  \/\/ Class loader is weak. Determine whether the holder is still alive.\n-  __ ld(tmp2, in_bytes(ClassLoaderData::holder_offset()), tmp1_class_loader_data);\n-  __ resolve_weak_handle(tmp2, tmp1, tmp3, MacroAssembler::PreservationLevel::PRESERVATION_FRAME_LR_GP_FP_REGS);\n-  __ cmpdi(CCR0, tmp2, 0);\n-  __ bne(CCR0, skip_barrier);\n-\n-  __ bind(bad_call);\n-\n-  __ calculate_address_from_global_toc(tmp1, SharedRuntime::get_handle_wrong_method_stub(), true, true, false);\n-  __ mtctr(tmp1);\n-  __ bctr();\n-\n-  __ bind(skip_barrier);\n-\n-  __ block_comment(\"} c2i_entry_barrier (c2i_entry_barrier)\");\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3072,13 +3072,0 @@\n-void MacroAssembler::resolve_weak_handle(Register result, Register tmp1, Register tmp2,\n-                                         MacroAssembler::PreservationLevel preservation_level) {\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  cmpdi(CCR0, result, 0);\n-  beq(CCR0, resolved);\n-\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, result, noreg, result, tmp1, tmp2,\n-                 preservation_level);\n-  bind(resolved);\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -741,2 +741,0 @@\n-  void resolve_weak_handle(Register result, Register tmp1, Register tmp2,\n-                           MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1311,3 +1311,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm, \/* tmp register*\/ ic_klass, \/* tmp register*\/ receiver_klass, \/* tmp register*\/ code);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -328,35 +328,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {\n-  BarrierSetNMethod* bs = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs == NULL) {\n-    return;\n-  }\n-\n-  Label bad_call;\n-  __ beqz(xmethod, bad_call);\n-\n-  \/\/ Pointer chase to the method holder to find out if the method is concurrently unloading.\n-  Label method_live;\n-  __ load_method_holder_cld(t0, xmethod);\n-\n-  \/\/ Is it a strong CLD?\n-  __ lwu(t1, Address(t0, ClassLoaderData::keep_alive_offset()));\n-  __ bnez(t1, method_live);\n-\n-  \/\/ Is it a weak but alive CLD?\n-  __ push_reg(RegSet::of(x28), sp);\n-\n-  __ ld(x28, Address(t0, ClassLoaderData::holder_offset()));\n-\n-  __ resolve_weak_handle(x28, t0, t1);\n-  __ mv(t0, x28);\n-\n-  __ pop_reg(RegSet::of(x28), sp);\n-\n-  __ bnez(t0, method_live);\n-\n-  __ bind(bad_call);\n-\n-  __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-  __ bind(method_live);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -96,1 +96,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1994,16 +1994,0 @@\n-\/\/ ((WeakHandle)result).resolve()\n-void MacroAssembler::resolve_weak_handle(Register result, Register tmp1, Register tmp2) {\n-  assert_different_registers(result, tmp1, tmp2);\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  beqz(result, resolved);\n-\n-  \/\/ Only 64 bit platforms support GCs that require a tmp register\n-  \/\/ Only IN_HEAP loads require a thread_tmp register\n-  \/\/ WeakHandle::resolve is an indirection like jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n-                 result, Address(result), tmp1, tmp2);\n-  bind(resolved);\n-}\n-\n@@ -3267,5 +3251,0 @@\n-void MacroAssembler::load_method_holder_cld(Register result, Register method) {\n-  load_method_holder(result, method);\n-  ld(result, Address(result, InstanceKlass::class_loader_data_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  void resolve_weak_handle(Register result, Register tmp1, Register tmp2);\n@@ -1163,1 +1162,0 @@\n-  void load_method_holder_cld(Register result, Register method);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -679,3 +679,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,11 +131,1 @@\n-    \/\/ Work around the x86_32 bug that only manifests with Loom for some reason.\n-    \/\/ MacroAssembler::resolve_weak_handle calls this barrier with tmp_thread == noreg.\n-    if (thread == noreg) {\n-      if (dst != rcx && tmp1 != rcx) {\n-        thread = rcx;\n-      } else if (dst != rdx && tmp1 != rdx) {\n-        thread = rdx;\n-      } else if (dst != rdi && tmp1 != rdi) {\n-        thread = rdi;\n-      }\n-    }\n+    assert(thread != noreg, \"\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -431,46 +431,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {\n-  BarrierSetNMethod* bs = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs == nullptr) {\n-    return;\n-  }\n-\n-  Label bad_call;\n-  __ cmpptr(rbx, 0); \/\/ rbx contains the incoming method for c2i adapters.\n-  __ jcc(Assembler::equal, bad_call);\n-\n-  Register tmp1 = LP64_ONLY( rscratch1 ) NOT_LP64( rax );\n-  Register tmp2 = LP64_ONLY( rscratch2 ) NOT_LP64( rcx );\n-#ifndef _LP64\n-  __ push(tmp1);\n-  __ push(tmp2);\n-#endif \/\/ !_LP64\n-\n-  \/\/ Pointer chase to the method holder to find out if the method is concurrently unloading.\n-  Label method_live;\n-  __ load_method_holder_cld(tmp1, rbx);\n-\n-   \/\/ Is it a strong CLD?\n-  __ cmpl(Address(tmp1, ClassLoaderData::keep_alive_offset()), 0);\n-  __ jcc(Assembler::greater, method_live);\n-\n-   \/\/ Is it a weak but alive CLD?\n-  __ movptr(tmp1, Address(tmp1, ClassLoaderData::holder_offset()));\n-  __ resolve_weak_handle(tmp1, tmp2);\n-  __ cmpptr(tmp1, 0);\n-  __ jcc(Assembler::notEqual, method_live);\n-\n-#ifndef _LP64\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n-\n-  __ bind(bad_call);\n-  __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-  __ bind(method_live);\n-\n-#ifndef _LP64\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -106,1 +106,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5087,17 +5087,0 @@\n-\/\/ ((WeakHandle)result).resolve();\n-void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {\n-  assert_different_registers(rresult, rtmp);\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  cmpptr(rresult, 0);\n-  jcc(Assembler::equal, resolved);\n-\n-  \/\/ Only 64 bit platforms support GCs that require a tmp register\n-  \/\/ Only IN_HEAP loads require a thread_tmp register\n-  \/\/ WeakHandle::resolve is an indirection like jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n-                 rresult, Address(rresult, 0), rtmp, \/*tmp_thread*\/noreg);\n-  bind(resolved);\n-}\n-\n@@ -5112,5 +5095,0 @@\n-void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {\n-  load_method_holder(rresult, rmethod);\n-  movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -357,1 +357,0 @@\n-  void resolve_weak_handle(Register result, Register tmp);\n@@ -359,1 +358,0 @@\n-  void load_method_holder_cld(Register rresult, Register rmethod);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -966,3 +966,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1039,3 +1039,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -418,1 +418,3 @@\n-void ClassLoaderData::record_dependency(const Klass* k) {\n+\/\/ An explicit dependency might be needed to prevent unloading of Klass* k\n+\/\/ before this CLD is unloading.\n+bool ClassLoaderData::needs_dependency(const Klass* k) {\n@@ -424,1 +426,1 @@\n-  \/\/ Do not need to record dependency if the dependency is to a class whose\n+  \/\/ Do not need a dependency if the dependency is to a class whose\n@@ -429,1 +431,1 @@\n-    return;\n+    return false;\n@@ -434,3 +436,2 @@\n-    \/\/ Just return if a non-strong hidden class class is attempting to record a dependency\n-    \/\/ to itself.  (Note that every non-strong hidden class has its own unique class\n-    \/\/ loader data.)\n+    \/\/ An explicit dependency to itself is not needed.\n+    \/\/ (Note that every non-strong hidden class has its own unique class loader data.)\n@@ -438,1 +439,1 @@\n-      return;\n+      return false;\n@@ -446,4 +447,5 @@\n-    \/\/ Just return if this dependency is to a class with the same or a parent\n-    \/\/ class_loader.\n-    if (from == to || java_lang_ClassLoader::isAncestor(from, to)) {\n-      return; \/\/ this class loader is in the parent list, no need to add it.\n+    \/\/ K cannot be unloaded before this CLD is unloading if it has the same\n+    \/\/ or a parent class_loader.\n+    if (from == to ||\n+        (!from_cld->is_boot_class_loader_data() && java_lang_ClassLoader::isAncestor(from, to))) {\n+      return false;\n@@ -453,2 +455,9 @@\n-  \/\/ It's a dependency we won't find through GC, add it.\n-  if (!_handles.contains(to)) {\n+  \/\/ An explicit dependency is needed. Let's see if it's already recorded.\n+  return !_handles.contains(to);\n+}\n+\n+void ClassLoaderData::record_dependency(const Klass* k) {\n+  if (needs_dependency(k)) {\n+    \/\/ It's a dependency we won't find through GC, add it.\n+    ClassLoaderData * const to_cld = k->class_loader_data();\n+    oop to = to_cld->has_class_mirror_holder() ? k->java_mirror() : to_cld->class_loader();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":22,"deletions":13,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -299,0 +299,1 @@\n+  bool needs_dependency(const Klass* to);\n@@ -305,4 +306,0 @@\n-  \/\/ Offsets\n-  static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }\n-  static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -633,11 +633,8 @@\n-      \/\/ Only the metadata relocations contained in static\/opt virtual call stubs\n-      \/\/ contains the Method* passed to c2i adapters. It is the only metadata\n-      \/\/ relocation that needs to be walked, as it is the one metadata relocation\n-      \/\/ that violates the invariant that all metadata relocations have an oop\n-      \/\/ in the compiled method (due to deferred resolution and code patching).\n-\n-      \/\/ This causes dead metadata to remain in compiled methods that are not\n-      \/\/ unloading. Unless these slippery metadata relocations of the static\n-      \/\/ stubs are at least cleared, subsequent class redefinition operations\n-      \/\/ will access potentially free memory, and JavaThread execution\n-      \/\/ concurrent to class unloading may call c2i adapters with dead methods.\n+      \/\/ Only the metadata relocations contained in static\/opt virtual call\n+      \/\/ stubs contains the Method* passed to c2i adapters. It is the only\n+      \/\/ metadata relocation that violates the invariant that all metadata\n+      \/\/ relocations have an oop in the compiled method (due to deferred\n+      \/\/ resolution and code patching). It is assumed though that the holder oop\n+      \/\/ of the Method* is still reachable starting from the nmethod oops. This\n+      \/\/ is checked when statically bound calls are resolved.\n+      \/\/ (see SharedRuntime::resolve_sub_helper())\n@@ -660,7 +657,1 @@\n-        if (!method->method_holder()->is_loader_alive()) {\n-          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n-\n-          if (!r->metadata_is_immediate()) {\n-            r->fix_metadata_relocation();\n-          }\n-        }\n+        guarantee(method->method_holder()->is_loader_alive(), \"dangling pointer\");\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -383,1 +383,0 @@\n-  static ByteSize class_loader_data_offset()     { return in_ByteSize(offset_of(Klass, _class_loader_data)); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1378,0 +1378,67 @@\n+class Search2OopsClosure : public OopClosure {\n+    bool _found;\n+    const oop _o1;\n+    const oop _o2;\n+\n+public:\n+  Search2OopsClosure(oop obj1, oop obj2) : _found(false), _o1(obj1), _o2(obj2) { }\n+\n+  virtual void do_oop(oop* p) {\n+    if (!_found) {\n+      oop obj = NMethodAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+      if (obj != nullptr && (obj == _o1 || obj == _o2)) {\n+        _found = true;\n+      }\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+\n+  bool found() const {\n+    return _found;\n+  }\n+};\n+\n+\/\/ Check if the holder of the target method is reachable from the caller nmethod if\n+\/\/ the call is statically bound.\n+\/\/ Without that path the target method could get unloaded even if the caller\n+\/\/ nmethod is not unloading and a dangling Method* could be left int the static\n+\/\/ stub for the call.\n+static void check_path_to_callee(bool is_virtual,\n+                                 bool is_optimized,\n+                                 CompiledMethod* from_cm,\n+                                 Handle receiver,\n+                                 methodHandle to_method,\n+                                 Bytecodes::Code invoke_code,\n+                                 JavaThread* thread) {\n+  nmethod* from_nm = from_cm->as_nmethod_or_null();\n+  InstanceKlass* to_klass = to_method->method_holder();\n+  if (from_nm != nullptr && !to_klass->class_loader_data()->is_permanent_class_loader_data()) {\n+    RegisterMap regmap(thread,\n+                       RegisterMap::UpdateMap::skip,\n+                       RegisterMap::ProcessFrames::include,\n+                       RegisterMap::WalkContinuation::skip);\n+    Method* from_method = thread->last_java_vframe(&regmap)->method();\n+    ClassLoaderData* const from_cld = from_method->method_holder()->class_loader_data();\n+\n+    if (!from_cld->needs_dependency(to_klass)) {\n+      return; \/\/ dependency is not needed or has been recorded\n+    }\n+\n+    \/\/ Search the oop constants of the caller for the holder of the target. Also\n+    \/\/ look for the receiver. If we find it then this means a permanent path to\n+    \/\/ the callee exists because the callee does not depend on the receiver.\n+    Search2OopsClosure f(to_klass->klass_holder(), receiver());\n+    from_nm->oops_do(&f);\n+    if (!f.found()) {\n+      stringStream ss;\n+      to_method->print_short_name(&ss);\n+      guarantee(false, \"Missing dependency resolving %s%s (%s) call to %s\",\n+                (is_optimized) ? \"optimized \" : \"\", (is_virtual) ? \"virtual\" : \"static\",\n+                Bytecodes::name(invoke_code), ss.freeze());\n+    }\n+  }\n+}\n+\n@@ -1427,0 +1494,5 @@\n+  if (!is_virtual || is_optimized) {\n+    \/\/ The holder of the callee_method must be reachable from caller_nm\n+    check_path_to_callee(is_virtual, is_optimized, caller_nm, receiver, callee_method, invoke_code, current \/* thread *\/);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296440\n+ * @summary Test if the holder object of the target of compiled static or\n+ *          optimized virtual call is reachable from the caller nmethod. This\n+ *          prevents unloading of the target if the caller is not\n+ *          unloading. This is of course necessary if the call is still\n+ *          reachable but also if it is not reachable we want to avoid dangling\n+ *          Method* in the static stub.\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -Xbatch\n+ *                   -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                   compiler.dependencies.staticallyBound.TestStaticallyBoundTargetIsReachable\n+ *\/\n+\n+package compiler.dependencies.staticallyBound;\n+\n+import jdk.test.lib.classloader.DirectLeveledClassLoader;\n+\n+public class TestStaticallyBoundTargetIsReachable {\n+    public static void main(String[] args) {\n+        try {\n+            new InvokeInterfaceConstReceiver().runTest(args);\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    \/\/ Testcase where an invokeinterface is compiled to a static call because\n+    \/\/ the receiver object is constant.\n+    \/\/ The holder of the target is reachable following the receiver in the oop constants.\n+    \/\/\n+    \/\/ - invokeinterface with constant receiver in ClassA_LVL_1::testMethod_dojit\n+    \/\/ - ClassC_LVL_3 overrides the target method. This prevents CHA based optimization.\n+    \/\/   With CHA based optimization the target holder would be reachable following the\n+    \/\/   dependencies.\n+    \/\/ - The receiver class ClassB_LVL_3 is loaded by a child classloader.\n+    \/\/\n+    public static class InvokeInterfaceConstReceiver {\n+\n+        \/\/ Callee loaded by classloader L3 which is a child of L1\n+        public static class ClassB_LVL_3 implements RecvInterface {\n+            @Override\n+            public int testMethod_statically_bound_callee_dontinline_dojit() {\n+                return 2;\n+            }\n+        }\n+\n+        \/\/ Override target method to prevent CHA based optimization.\n+        public static class ClassC_LVL_3 extends ClassB_LVL_3 {\n+            @Override\n+            public int testMethod_statically_bound_callee_dontinline_dojit() {\n+                throw new Error(\"Should not reach here\");\n+            }\n+        }\n+\n+        public static interface RecvInterface {\n+            public int testMethod_statically_bound_callee_dontinline_dojit();\n+        }\n+\n+        \/\/ Decouple Caller\/Callee\n+        public static class Factory_LVL_2 {\n+            public static RecvInterface getReceiver() {\n+                new ClassC_LVL_3();              \/\/ load class that overrides target method\n+                return new ClassB_LVL_3();\n+            }\n+        }\n+\n+        \/\/ Caller loaded by L1. The target is loaded by L3 which is a child of L1.\n+        public static class ClassA_LVL_1 implements Runnable {\n+            static final RecvInterface constReceiver = Factory_LVL_2.getReceiver();\n+\n+            public void testMethod_dojit() {\n+                \/\/ the receiver for the invokeinterface is a constant\n+                constReceiver.testMethod_statically_bound_callee_dontinline_dojit();\n+            }\n+\n+            @Override\n+            public void run() {\n+                testMethod_dojit();\n+            }\n+        }\n+\n+        public void runTest(String[] args) throws Throwable {\n+            ClassLoader thisLoader = getClass().getClassLoader();\n+            System.err.println(\"CL: \" + thisLoader);\n+            ClassLoader ldl = new DirectLeveledClassLoader(thisLoader, 3);\n+            Class<?> cls = ldl.loadClass(getClass().getName() + \"$ClassA_LVL_1\");\n+            Runnable test = (Runnable) cls.getDeclaredConstructor().newInstance();\n+\n+            for (int i=0; i<30_000; i++) {\n+                test.run();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/dependencies\/staticallyBound\/TestStaticallyBoundTargetIsReachable.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.test.lib.classloader;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URL;\n+\n+\/**\n+ * Read the bytes of a class that would actually be loaded by the parent and define the class directly.\n+ *\/\n+public class DirectClassLoader extends ClassLoader {\n+\n+    public Class<?> findClass(String className) throws ClassNotFoundException {\n+        synchronized (getClassLoadingLock(className)) {\n+            \/\/ First, check if the class has already been loaded\n+            Class<?> c = findLoadedClass(className);\n+            if (c == null) {\n+                try {\n+                    String binaryName = className.replace(\".\", \"\/\") + \".class\";\n+                    URL url = getParent().getResource(binaryName);\n+                    if (url == null) {\n+                        throw new IOException(\"Resource not found: '\" + binaryName + \"'\");\n+                    }\n+                    InputStream is = url.openStream();\n+                    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+\n+                    int nRead;\n+                    byte[] data = new byte[16384];\n+                    while ((nRead = is.read(data, 0, data.length)) != -1) {\n+                        buffer.write(data, 0, nRead);\n+                    }\n+\n+                    byte[] b = buffer.toByteArray();\n+                    c = defineClass(className, b, 0, b.length);\n+                    System.out.println(this + \" defined class \" + className);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    throw new ClassNotFoundException(\"Could not define directly '\" + className + \"'\");\n+                }\n+            }\n+            return c;\n+        }\n+    }\n+\n+    \/**\n+     * Define the class with the given name directly and for convenience\n+     * instantiate it using the default constructor.\n+     *\/\n+    public Object newInstance(String className)\n+            throws ClassNotFoundException,\n+            InstantiationException, IllegalAccessException, IllegalArgumentException,\n+            InvocationTargetException, NoSuchMethodException, SecurityException {\n+        Class<?> c = findClass(className);\n+        return c.getDeclaredConstructor().newInstance();\n+    }\n+\n+    public DirectClassLoader(ClassLoader parent) {\n+        super(parent);\n+        System.identityHashCode(this);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/classloader\/DirectClassLoader.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.test.lib.classloader;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Build a hierarchy of classloaders L0 ... Ln to load classes according to name suffix LVL_m.\n+ *\n+ * For {@code 1 <= m <= n}, Lm delegates to its parent Lm-1 unless the class to be loaded has the name\n+ * suffix LVL_m. In that case it will define the class directly. L0 delegates to Ln in that case.\n+ * The name suffix LVL_0 is not allowed.\n+ *\n+ * {@link DirectLeveledClassLoader} corresponds to L0.\n+ * {@link LevelN} corresponds to others.\n+ * {@link Level1}, {@link Level2}, ... are only defined for better tracing.\n+ *\/\n+public class DirectLeveledClassLoader extends ClassLoader {\n+    private static final String CLASS_NAME_SUFFIX = \"LVL_\";\n+    private static final Pattern CLASS_PATTERN;\n+    static {\n+        CLASS_PATTERN = Pattern.compile(CLASS_NAME_SUFFIX + \"(\\\\d+)\");\n+    }\n+\n+    private final int maxLevel;\n+    private final LevelN bottom;\n+\n+    public DirectLeveledClassLoader(ClassLoader parent, int levels) {\n+        super(parent);\n+        maxLevel = levels;\n+        LevelN bot = null;\n+        int level = 1;\n+        \/\/ Have subclasses for levels 1 and 2 for better tracing\n+        if (levels > 0) {\n+            level++;\n+            bot = new Level1(this);\n+        }\n+        if (levels > 1) {\n+            level++;\n+            bot = new Level2(bot);\n+        }\n+        if (levels > 1) {\n+            level++;\n+            bot = new Level3(bot);\n+        }\n+        for (int i = 2; i < levels; i++) {\n+            bot = new LevelN(bot, level++);\n+        }\n+        bottom = bot;\n+    }\n+\n+    private static int getLevelFromName(String name) {\n+        Matcher m;\n+        int lvl = -1;\n+        if ((m = CLASS_PATTERN.matcher(name)).find()) {\n+            lvl = Integer.parseInt(m.group(1));\n+        }\n+        return lvl;\n+    }\n+\n+    protected Class<?> loadClass(String name, boolean resolve)\n+            throws ClassNotFoundException {\n+        int level = getLevelFromName(name);\n+        if (level >= 0) {\n+            if (level == 0 || level > maxLevel) {\n+                throw new Error(\"Level \" + level + \" is out of bounds [1, \" + maxLevel + \"]\");\n+            }\n+            System.err.println(this + \": delegating to bottom level for \" + name);\n+            return bottom.loadClass(name, resolve);\n+        }\n+        System.err.println(this + \": delegating to parent for \" + name);\n+        return super.loadClass(name, resolve);\n+    }\n+\n+    private static class LevelN extends DirectClassLoader {\n+        private final int level;\n+\n+        private LevelN(ClassLoader parent, int level) {\n+            super(parent);\n+            this.level = level;\n+        }\n+\n+        @Override\n+        protected Class<?> loadClass(String name, boolean resolve)\n+                throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(name)) {\n+                Class<?> c = findLoadedClass(name);\n+                if (c == null) {\n+                    String idh = Integer.toHexString(System.identityHashCode(this));\n+                    int lvl = getLevelFromName(name);\n+                    \/\/ System.err.println(this + \" loadClass(\" + name + \", \" + resolve + \") lvl:\" + lvl);\n+                    if (lvl >= 0 && this.level == lvl) {\n+                        System.err.println(getClass().getName() + \"@\" + idh + \": loading \" + name + \" at level \" + lvl);\n+                        c = findClass(name);\n+                    } else {\n+                        System.err.println(this + \": delegating to parent for \" + name);\n+                        c = super.loadClass(name, resolve);\n+                    }\n+                }\n+                if (resolve) {\n+                    resolveClass(c);\n+                }\n+                return c;\n+            }\n+        }\n+    }\n+\n+    \/\/ Encode level in classname for better tracing\n+    private static class Level1 extends LevelN {\n+        private Level1(ClassLoader parent) { super(parent, 1); }\n+    }\n+    private static class Level2 extends LevelN {\n+        private Level2(ClassLoader parent) { super(parent, 2); }\n+    }\n+    private static class Level3 extends LevelN {\n+        private Level3(ClassLoader parent) { super(parent, 3); }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/classloader\/DirectLeveledClassLoader.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}