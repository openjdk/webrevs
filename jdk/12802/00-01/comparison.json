{"files":[{"patch":"@@ -1354,0 +1354,26 @@\n+class Search2OopsClosure : public OopClosure {\n+    bool _found;\n+    const oop _o1;\n+    const oop _o2;\n+\n+public:\n+  Search2OopsClosure(oop obj1, oop obj2) : _found(false), _o1(obj1), _o2(obj2) { }\n+\n+  virtual void do_oop(oop* p) {\n+    if (!_found) {\n+      oop obj = NMethodAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+      if (obj != nullptr && (obj == _o1 || obj == _o2)) {\n+        _found = true;\n+      }\n+    }\n+  }\n+\n+  virtual void do_oop(narrowOop* p) {\n+    ShouldNotReachHere();\n+  }\n+\n+  bool found() const {\n+    return _found;\n+  }\n+};\n+\n@@ -1363,0 +1389,1 @@\n+                                 Handle receiver,\n@@ -1393,7 +1420,7 @@\n-    oop* const begin = from_nm->oops_begin();\n-    oop* const end = from_nm->oops_end();\n-    for (oop* p = begin; p < end; p++) {\n-      oop obj = NMethodAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n-      if (obj == to_holder) {\n-        return;\n-      }\n+    \/\/ Search for to_holder in the oops. to_holder has to be reachable from the\n+    \/\/ receiver. If it is a constant among the oops, then there is also a path\n+    \/\/ from the caller to to_holder.\n+    Search2OopsClosure f(to_holder, receiver());\n+    from_nm->oops_do(&f);\n+    if (f.found()) {\n+      return;\n@@ -1469,1 +1496,1 @@\n-    check_path_to_callee(is_virtual, is_optimized, caller_nm, callee_method, invoke_code, current \/* thread *\/);\n+    check_path_to_callee(is_virtual, is_optimized, caller_nm, receiver, callee_method, invoke_code, current \/* thread *\/);\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":35,"deletions":8,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8296440\n+ * @summary Test if the holder object of the target of compiled static or\n+ *          optimized virtual call is reachable from the caller nmethod. This\n+ *          prevents unloading of the target if the caller is not\n+ *          unloading. This is of course necessary if the call is still\n+ *          reachable but also if it is not reachable we want to avoid dangling\n+ *          Method* in the static stub.\n+ *\n+ * @library \/test\/lib \/\n+ *\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -Xbatch\n+ *                   -XX:CompileCommand=dontinline,*::*dontinline*\n+ *                   compiler.dependencies.staticallyBound.TestStaticallyBoundTargetIsReachable\n+ *\/\n+\n+package compiler.dependencies.staticallyBound;\n+\n+import jdk.test.lib.classloader.DirectLeveledClassLoader;\n+\n+public class TestStaticallyBoundTargetIsReachable {\n+    public static void main(String[] args) {\n+        try {\n+            new InvokeInterfaceConstReceiver().runTest(args);\n+        } catch (Throwable e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    \/\/ Testcase where an invokeinterface is compiled to a static call because\n+    \/\/ the receiver object is constant.\n+    \/\/ The holder of the target is reachable following the receiver in the oop constants.\n+    \/\/\n+    \/\/ - invokeinterface with constant receiver in ClassA_LVL_1::testMethod_dojit\n+    \/\/ - ClassC_LVL_3 overrides the target method. This prevents CHA based optimization.\n+    \/\/   With CHA based optimization the target holder would be reachable following the\n+    \/\/   dependencies.\n+    \/\/ - The receiver class ClassB_LVL_3 is loaded by a child classloader.\n+    \/\/\n+    public static class InvokeInterfaceConstReceiver {\n+\n+        \/\/ Callee loaded by classloader L3 which is a child of L1\n+        public static class ClassB_LVL_3 implements RecvInterface {\n+            @Override\n+            public int testMethod_statically_bound_callee_dontinline_dojit() {\n+                return 2;\n+            }\n+        }\n+\n+        \/\/ Override target method to prevent CHA based optimization.\n+        public static class ClassC_LVL_3 extends ClassB_LVL_3 {\n+            @Override\n+            public int testMethod_statically_bound_callee_dontinline_dojit() {\n+                throw new Error(\"Should not reach here\");\n+            }\n+        }\n+\n+        public static interface RecvInterface {\n+            public int testMethod_statically_bound_callee_dontinline_dojit();\n+        }\n+\n+        \/\/ Decouple Caller\/Callee\n+        public static class Factory_LVL_2 {\n+            public static RecvInterface getReceiver() {\n+                new ClassC_LVL_3();              \/\/ load class that overrides target method\n+                return new ClassB_LVL_3();\n+            }\n+        }\n+\n+        \/\/ Caller loaded by L1. The target is loaded by L3 which is a child of L1.\n+        public static class ClassA_LVL_1 implements Runnable {\n+            static final RecvInterface constReceiver = Factory_LVL_2.getReceiver();\n+\n+            public void testMethod_dojit() {\n+                \/\/ the receiver for the invokeinterface is a constant\n+                constReceiver.testMethod_statically_bound_callee_dontinline_dojit();\n+            }\n+\n+            @Override\n+            public void run() {\n+                testMethod_dojit();\n+            }\n+        }\n+\n+        public void runTest(String[] args) throws Throwable {\n+            ClassLoader thisLoader = getClass().getClassLoader();\n+            System.err.println(\"CL: \" + thisLoader);\n+            ClassLoader ldl = new DirectLeveledClassLoader(thisLoader, 3);\n+            Class<?> cls = ldl.loadClass(getClass().getName() + \"$ClassA_LVL_1\");\n+            Runnable test = (Runnable) cls.getDeclaredConstructor().newInstance();\n+\n+            for (int i=0; i<30_000; i++) {\n+                test.run();\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/dependencies\/staticallyBound\/TestStaticallyBoundTargetIsReachable.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.test.lib.classloader;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.URL;\n+\n+\/**\n+ * Read the bytes of a class that would actually be loaded by the parent and define the class directly.\n+ *\/\n+public class DirectClassLoader extends ClassLoader {\n+\n+    public Class<?> findClass(String className) throws ClassNotFoundException {\n+        synchronized (getClassLoadingLock(className)) {\n+            \/\/ First, check if the class has already been loaded\n+            Class<?> c = findLoadedClass(className);\n+            if (c == null) {\n+                try {\n+                    String binaryName = className.replace(\".\", \"\/\") + \".class\";\n+                    URL url = getParent().getResource(binaryName);\n+                    if (url == null) {\n+                        throw new IOException(\"Resource not found: '\" + binaryName + \"'\");\n+                    }\n+                    InputStream is = url.openStream();\n+                    ByteArrayOutputStream buffer = new ByteArrayOutputStream();\n+\n+                    int nRead;\n+                    byte[] data = new byte[16384];\n+                    while ((nRead = is.read(data, 0, data.length)) != -1) {\n+                        buffer.write(data, 0, nRead);\n+                    }\n+\n+                    byte[] b = buffer.toByteArray();\n+                    c = defineClass(className, b, 0, b.length);\n+                    System.out.println(this + \" defined class \" + className);\n+                } catch (IOException e) {\n+                    e.printStackTrace();\n+                    throw new ClassNotFoundException(\"Could not define directly '\" + className + \"'\");\n+                }\n+            }\n+            return c;\n+        }\n+    }\n+\n+    \/**\n+     * Define the class with the given name directly and for convenience\n+     * instantiate it using the default constructor.\n+     *\/\n+    public Object newInstance(String className)\n+            throws ClassNotFoundException,\n+            InstantiationException, IllegalAccessException, IllegalArgumentException,\n+            InvocationTargetException, NoSuchMethodException, SecurityException {\n+        Class<?> c = findClass(className);\n+        return c.getDeclaredConstructor().newInstance();\n+    }\n+\n+    public DirectClassLoader(ClassLoader parent) {\n+        super(parent);\n+        System.identityHashCode(this);\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/classloader\/DirectClassLoader.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -0,0 +1,141 @@\n+\/*\n+ * Copyright (c) 2023 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package jdk.test.lib.classloader;\n+\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Build a hierarchy of classloaders L0 ... Ln to load classes according to name suffix LVL_m.\n+ *\n+ * For {@code 1 <= m <= n}, Lm delegates to its parent Lm-1 unless the class to be loaded has the name\n+ * suffix LVL_m. In that case it will define the class directly. L0 delegates to Ln in that case.\n+ * The name suffix LVL_0 is not allowed.\n+ *\n+ * {@link DirectLeveledClassLoader} corresponds to L0.\n+ * {@link LevelN} corresponds to others.\n+ * {@link Level1}, {@link Level2}, ... are only defined for better tracing.\n+ *\/\n+public class DirectLeveledClassLoader extends ClassLoader {\n+    private static final String CLASS_NAME_SUFFIX = \"LVL_\";\n+    private static final Pattern CLASS_PATTERN;\n+    static {\n+        CLASS_PATTERN = Pattern.compile(CLASS_NAME_SUFFIX + \"(\\\\d+)\");\n+    }\n+\n+    private final int maxLevel;\n+    private final LevelN bottom;\n+\n+    public DirectLeveledClassLoader(ClassLoader parent, int levels) {\n+        super(parent);\n+        maxLevel = levels;\n+        LevelN bot = null;\n+        int level = 1;\n+        \/\/ Have subclasses for levels 1 and 2 for better tracing\n+        if (levels > 0) {\n+            level++;\n+            bot = new Level1(this);\n+        }\n+        if (levels > 1) {\n+            level++;\n+            bot = new Level2(bot);\n+        }\n+        if (levels > 1) {\n+            level++;\n+            bot = new Level3(bot);\n+        }\n+        for (int i = 2; i < levels; i++) {\n+            bot = new LevelN(bot, level++);\n+        }\n+        bottom = bot;\n+    }\n+\n+    private static int getLevelFromName(String name) {\n+        Matcher m;\n+        int lvl = -1;\n+        if ((m = CLASS_PATTERN.matcher(name)).find()) {\n+            lvl = Integer.parseInt(m.group(1));\n+        }\n+        return lvl;\n+    }\n+\n+    protected Class<?> loadClass(String name, boolean resolve)\n+            throws ClassNotFoundException {\n+        int level = getLevelFromName(name);\n+        if (level >= 0) {\n+            if (level == 0 || level > maxLevel) {\n+                throw new Error(\"Level \" + level + \" is out of bounds [1, \" + maxLevel + \"]\");\n+            }\n+            System.err.println(this + \": delegating to bottom level for \" + name);\n+            return bottom.loadClass(name, resolve);\n+        }\n+        System.err.println(this + \": delegating to parent for \" + name);\n+        return super.loadClass(name, resolve);\n+    }\n+\n+    private static class LevelN extends DirectClassLoader {\n+        private final int level;\n+\n+        private LevelN(ClassLoader parent, int level) {\n+            super(parent);\n+            this.level = level;\n+        }\n+\n+        @Override\n+        protected Class<?> loadClass(String name, boolean resolve)\n+                throws ClassNotFoundException {\n+            synchronized (getClassLoadingLock(name)) {\n+                Class<?> c = findLoadedClass(name);\n+                if (c == null) {\n+                    String idh = Integer.toHexString(System.identityHashCode(this));\n+                    int lvl = getLevelFromName(name);\n+                    \/\/ System.err.println(this + \" loadClass(\" + name + \", \" + resolve + \") lvl:\" + lvl);\n+                    if (lvl >= 0 && this.level == lvl) {\n+                        System.err.println(getClass().getName() + \"@\" + idh + \": loading \" + name + \" at level \" + lvl);\n+                        c = findClass(name);\n+                    } else {\n+                        System.err.println(this + \": delegating to parent for \" + name);\n+                        c = super.loadClass(name, resolve);\n+                    }\n+                }\n+                if (resolve) {\n+                    resolveClass(c);\n+                }\n+                return c;\n+            }\n+        }\n+    }\n+\n+    \/\/ Encode level in classname for better tracing\n+    private static class Level1 extends LevelN {\n+        private Level1(ClassLoader parent) { super(parent, 1); }\n+    }\n+    private static class Level2 extends LevelN {\n+        private Level2(ClassLoader parent) { super(parent, 2); }\n+    }\n+    private static class Level3 extends LevelN {\n+        private Level3(ClassLoader parent) { super(parent, 3); }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/classloader\/DirectLeveledClassLoader.java","additions":141,"deletions":0,"binary":false,"changes":141,"status":"added"}]}