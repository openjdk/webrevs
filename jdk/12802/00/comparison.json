{"files":[{"patch":"@@ -270,32 +270,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {\n-  BarrierSetNMethod* bs = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs == NULL) {\n-    return;\n-  }\n-\n-  Label bad_call;\n-  __ cbz(rmethod, bad_call);\n-\n-  \/\/ Pointer chase to the method holder to find out if the method is concurrently unloading.\n-  Label method_live;\n-  __ load_method_holder_cld(rscratch1, rmethod);\n-\n-  \/\/ Is it a strong CLD?\n-  __ ldrw(rscratch2, Address(rscratch1, ClassLoaderData::keep_alive_offset()));\n-  __ cbnz(rscratch2, method_live);\n-\n-  \/\/ Is it a weak but alive CLD?\n-  __ push(RegSet::of(r10), sp);\n-  __ ldr(r10, Address(rscratch1, ClassLoaderData::holder_offset()));\n-\n-  __ resolve_weak_handle(r10, rscratch1, rscratch2);\n-  __ mov(rscratch1, r10);\n-  __ pop(RegSet::of(r10), sp);\n-  __ cbnz(rscratch1, method_live);\n-\n-  __ bind(bad_call);\n-\n-  __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-  __ bind(method_live);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.cpp","additions":0,"deletions":32,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -73,1 +73,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/shared\/barrierSetAssembler_aarch64.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4244,5 +4244,0 @@\n-void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {\n-  load_method_holder(rresult, rmethod);\n-  ldr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));\n-}\n-\n@@ -4275,15 +4270,0 @@\n-\/\/ ((WeakHandle)result).resolve();\n-void MacroAssembler::resolve_weak_handle(Register result, Register tmp1, Register tmp2) {\n-  assert_different_registers(result, tmp1, tmp2);\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  cbz(result, resolved);\n-\n-  \/\/ Only 64 bit platforms support GCs that require a tmp register\n-  \/\/ WeakHandle::resolve is an indirection like jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n-                 result, Address(result), tmp1, tmp2);\n-  bind(resolved);\n-}\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":0,"deletions":20,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -841,1 +841,0 @@\n-  void load_method_holder_cld(Register rresult, Register rmethod);\n@@ -850,1 +849,0 @@\n-  void resolve_weak_handle(Register result, Register tmp1, Register tmp2);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -789,3 +789,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -215,44 +215,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler *masm, Register tmp1, Register tmp2, Register tmp3) {\n-  BarrierSetNMethod* bs_nm = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs_nm == nullptr) {\n-    return;\n-  }\n-\n-  assert_different_registers(tmp1, tmp2, tmp3);\n-\n-  __ block_comment(\"c2i_entry_barrier (c2i_entry_barrier) {\");\n-\n-  Register tmp1_class_loader_data = tmp1;\n-\n-  Label bad_call, skip_barrier;\n-\n-  \/\/ Fast path: If no method is given, the call is definitely bad.\n-  __ cmpdi(CCR0, R19_method, 0);\n-  __ beq(CCR0, bad_call);\n-\n-  \/\/ Load class loader data to determine whether the method's holder is concurrently unloading.\n-  __ load_method_holder(tmp1, R19_method);\n-  __ ld(tmp1_class_loader_data, in_bytes(InstanceKlass::class_loader_data_offset()), tmp1);\n-\n-  \/\/ Fast path: If class loader is strong, the holder cannot be unloaded.\n-  __ lwz(tmp2, in_bytes(ClassLoaderData::keep_alive_offset()), tmp1_class_loader_data);\n-  __ cmpdi(CCR0, tmp2, 0);\n-  __ bne(CCR0, skip_barrier);\n-\n-  \/\/ Class loader is weak. Determine whether the holder is still alive.\n-  __ ld(tmp2, in_bytes(ClassLoaderData::holder_offset()), tmp1_class_loader_data);\n-  __ resolve_weak_handle(tmp2, tmp1, tmp3, MacroAssembler::PreservationLevel::PRESERVATION_FRAME_LR_GP_FP_REGS);\n-  __ cmpdi(CCR0, tmp2, 0);\n-  __ bne(CCR0, skip_barrier);\n-\n-  __ bind(bad_call);\n-\n-  __ calculate_address_from_global_toc(tmp1, SharedRuntime::get_handle_wrong_method_stub(), true, true, false);\n-  __ mtctr(tmp1);\n-  __ bctr();\n-\n-  __ bind(skip_barrier);\n-\n-  __ block_comment(\"} c2i_entry_barrier (c2i_entry_barrier)\");\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.cpp","additions":0,"deletions":44,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -71,1 +71,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shared\/barrierSetAssembler_ppc.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3072,13 +3072,0 @@\n-void MacroAssembler::resolve_weak_handle(Register result, Register tmp1, Register tmp2,\n-                                         MacroAssembler::PreservationLevel preservation_level) {\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  cmpdi(CCR0, result, 0);\n-  beq(CCR0, resolved);\n-\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF, result, noreg, result, tmp1, tmp2,\n-                 preservation_level);\n-  bind(resolved);\n-}\n-\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":0,"deletions":13,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -741,2 +741,0 @@\n-  void resolve_weak_handle(Register result, Register tmp1, Register tmp2,\n-                           MacroAssembler::PreservationLevel preservation_level);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1311,3 +1311,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm, \/* tmp register*\/ ic_klass, \/* tmp register*\/ receiver_klass, \/* tmp register*\/ code);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -277,35 +277,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {\n-  BarrierSetNMethod* bs = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs == NULL) {\n-    return;\n-  }\n-\n-  Label bad_call;\n-  __ beqz(xmethod, bad_call);\n-\n-  \/\/ Pointer chase to the method holder to find out if the method is concurrently unloading.\n-  Label method_live;\n-  __ load_method_holder_cld(t0, xmethod);\n-\n-  \/\/ Is it a strong CLD?\n-  __ lwu(t1, Address(t0, ClassLoaderData::keep_alive_offset()));\n-  __ bnez(t1, method_live);\n-\n-  \/\/ Is it a weak but alive CLD?\n-  __ push_reg(RegSet::of(x28), sp);\n-\n-  __ ld(x28, Address(t0, ClassLoaderData::holder_offset()));\n-\n-  __ resolve_weak_handle(x28, t0, t1);\n-  __ mv(t0, x28);\n-\n-  __ pop_reg(RegSet::of(x28), sp);\n-\n-  __ bnez(t0, method_live);\n-\n-  __ bind(bad_call);\n-\n-  __ far_jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-  __ bind(method_live);\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":0,"deletions":35,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1994,16 +1994,0 @@\n-\/\/ ((WeakHandle)result).resolve()\n-void MacroAssembler::resolve_weak_handle(Register result, Register tmp1, Register tmp2) {\n-  assert_different_registers(result, tmp1, tmp2);\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  beqz(result, resolved);\n-\n-  \/\/ Only 64 bit platforms support GCs that require a tmp register\n-  \/\/ Only IN_HEAP loads require a thread_tmp register\n-  \/\/ WeakHandle::resolve is an indirection like jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n-                 result, Address(result), tmp1, tmp2);\n-  bind(resolved);\n-}\n-\n@@ -3267,5 +3251,0 @@\n-void MacroAssembler::load_method_holder_cld(Register result, Register method) {\n-  load_method_holder(result, method);\n-  ld(result, Address(result, InstanceKlass::class_loader_data_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":0,"deletions":21,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -181,1 +181,0 @@\n-  void resolve_weak_handle(Register result, Register tmp1, Register tmp2);\n@@ -1163,1 +1162,0 @@\n-  void load_method_holder_cld(Register result, Register method);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -679,3 +679,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -131,11 +131,1 @@\n-    \/\/ Work around the x86_32 bug that only manifests with Loom for some reason.\n-    \/\/ MacroAssembler::resolve_weak_handle calls this barrier with tmp_thread == noreg.\n-    if (thread == noreg) {\n-      if (dst != rcx && tmp1 != rcx) {\n-        thread = rcx;\n-      } else if (dst != rdx && tmp1 != rdx) {\n-        thread = rdx;\n-      } else if (dst != rdi && tmp1 != rdi) {\n-        thread = rdi;\n-      }\n-    }\n+    assert(thread != noreg, \"\");\n","filename":"src\/hotspot\/cpu\/x86\/gc\/g1\/g1BarrierSetAssembler_x86.cpp","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -324,46 +324,0 @@\n-void BarrierSetAssembler::c2i_entry_barrier(MacroAssembler* masm) {\n-  BarrierSetNMethod* bs = BarrierSet::barrier_set()->barrier_set_nmethod();\n-  if (bs == NULL) {\n-    return;\n-  }\n-\n-  Label bad_call;\n-  __ cmpptr(rbx, 0); \/\/ rbx contains the incoming method for c2i adapters.\n-  __ jcc(Assembler::equal, bad_call);\n-\n-  Register tmp1 = LP64_ONLY( rscratch1 ) NOT_LP64( rax );\n-  Register tmp2 = LP64_ONLY( rscratch2 ) NOT_LP64( rcx );\n-#ifndef _LP64\n-  __ push(tmp1);\n-  __ push(tmp2);\n-#endif \/\/ !_LP64\n-\n-  \/\/ Pointer chase to the method holder to find out if the method is concurrently unloading.\n-  Label method_live;\n-  __ load_method_holder_cld(tmp1, rbx);\n-\n-   \/\/ Is it a strong CLD?\n-  __ cmpl(Address(tmp1, ClassLoaderData::keep_alive_offset()), 0);\n-  __ jcc(Assembler::greater, method_live);\n-\n-   \/\/ Is it a weak but alive CLD?\n-  __ movptr(tmp1, Address(tmp1, ClassLoaderData::holder_offset()));\n-  __ resolve_weak_handle(tmp1, tmp2);\n-  __ cmpptr(tmp1, 0);\n-  __ jcc(Assembler::notEqual, method_live);\n-\n-#ifndef _LP64\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n-\n-  __ bind(bad_call);\n-  __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub()));\n-  __ bind(method_live);\n-\n-#ifndef _LP64\n-  __ pop(tmp2);\n-  __ pop(tmp1);\n-#endif\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.cpp","additions":0,"deletions":46,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -66,1 +66,0 @@\n-  virtual void c2i_entry_barrier(MacroAssembler* masm);\n","filename":"src\/hotspot\/cpu\/x86\/gc\/shared\/barrierSetAssembler_x86.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5087,17 +5087,0 @@\n-\/\/ ((WeakHandle)result).resolve();\n-void MacroAssembler::resolve_weak_handle(Register rresult, Register rtmp) {\n-  assert_different_registers(rresult, rtmp);\n-  Label resolved;\n-\n-  \/\/ A null weak handle resolves to null.\n-  cmpptr(rresult, 0);\n-  jcc(Assembler::equal, resolved);\n-\n-  \/\/ Only 64 bit platforms support GCs that require a tmp register\n-  \/\/ Only IN_HEAP loads require a thread_tmp register\n-  \/\/ WeakHandle::resolve is an indirection like jweak.\n-  access_load_at(T_OBJECT, IN_NATIVE | ON_PHANTOM_OOP_REF,\n-                 rresult, Address(rresult, 0), rtmp, \/*tmp_thread*\/noreg);\n-  bind(resolved);\n-}\n-\n@@ -5112,5 +5095,0 @@\n-void MacroAssembler::load_method_holder_cld(Register rresult, Register rmethod) {\n-  load_method_holder(rresult, rmethod);\n-  movptr(rresult, Address(rresult, InstanceKlass::class_loader_data_offset()));\n-}\n-\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":0,"deletions":22,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -344,1 +344,0 @@\n-  void resolve_weak_handle(Register result, Register tmp);\n@@ -346,1 +345,0 @@\n-  void load_method_holder_cld(Register rresult, Register rmethod);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -966,3 +966,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1039,3 +1039,0 @@\n-  BarrierSetAssembler* bs = BarrierSet::barrier_set()->barrier_set_assembler();\n-  bs->c2i_entry_barrier(masm);\n-\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -790,0 +790,4 @@\n+bool ClassLoaderData::handles_contain(oop obj) {\n+  return _handles.contains(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -293,0 +293,1 @@\n+  bool handles_contain(oop obj);\n@@ -305,4 +306,0 @@\n-  \/\/ Offsets\n-  static ByteSize holder_offset()     { return in_ByteSize(offset_of(ClassLoaderData, _holder)); }\n-  static ByteSize keep_alive_offset() { return in_ByteSize(offset_of(ClassLoaderData, _keep_alive)); }\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -633,11 +633,8 @@\n-      \/\/ Only the metadata relocations contained in static\/opt virtual call stubs\n-      \/\/ contains the Method* passed to c2i adapters. It is the only metadata\n-      \/\/ relocation that needs to be walked, as it is the one metadata relocation\n-      \/\/ that violates the invariant that all metadata relocations have an oop\n-      \/\/ in the compiled method (due to deferred resolution and code patching).\n-\n-      \/\/ This causes dead metadata to remain in compiled methods that are not\n-      \/\/ unloading. Unless these slippery metadata relocations of the static\n-      \/\/ stubs are at least cleared, subsequent class redefinition operations\n-      \/\/ will access potentially free memory, and JavaThread execution\n-      \/\/ concurrent to class unloading may call c2i adapters with dead methods.\n+      \/\/ Only the metadata relocations contained in static\/opt virtual call\n+      \/\/ stubs contains the Method* passed to c2i adapters. It is the only\n+      \/\/ metadata relocation that violates the invariant that all metadata\n+      \/\/ relocations have an oop in the compiled method (due to deferred\n+      \/\/ resolution and code patching). It is assumed though that the holder oop\n+      \/\/ of the Method* is still reachable starting from the nmethod oops. This\n+      \/\/ is checked when statically bound calls are resolved.\n+      \/\/ (see SharedRuntime::resolve_sub_helper())\n@@ -660,7 +657,1 @@\n-        if (!method->method_holder()->is_loader_alive()) {\n-          Atomic::store(r->metadata_addr(), (Method*)nullptr);\n-\n-          if (!r->metadata_is_immediate()) {\n-            r->fix_metadata_relocation();\n-          }\n-        }\n+        guarantee(method->method_holder()->is_loader_alive(), \"dangling pointer\");\n","filename":"src\/hotspot\/share\/code\/compiledMethod.cpp","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1445,0 +1445,64 @@\n+\/\/ Check if the holder of the target method is reachable from the caller nmethod if\n+\/\/ the call is statically bound.\n+\/\/ Without that path the target method could get unloaded even if the caller\n+\/\/ nmethod is not unloading and a dangling Method* could be left int the static\n+\/\/ stub for the call.\n+\/\/ (See also ClassLoaderData::record_dependency())\n+static void check_path_to_callee(bool is_virtual,\n+                                 bool is_optimized,\n+                                 CompiledMethod* from_cm,\n+                                 methodHandle to_method,\n+                                 Bytecodes::Code invoke_code,\n+                                 JavaThread* thread) {\n+  nmethod* from_nm = from_cm->as_nmethod_or_null();\n+  InstanceKlass* to_klass = to_method->method_holder();\n+  oop to_holder = to_klass->klass_holder();\n+  ClassLoaderData * const to_cld = to_klass->class_loader_data();\n+  if (from_nm != nullptr && !to_cld->is_permanent_class_loader_data()) {\n+    RegisterMap regmap(thread,\n+                       RegisterMap::UpdateMap::skip,\n+                       RegisterMap::ProcessFrames::include,\n+                       RegisterMap::WalkContinuation::skip);\n+    Method* from_method = thread->last_java_vframe(&regmap)->method();\n+    ClassLoaderData* const from_cld = from_method->method_holder()->class_loader_data();\n+\n+    if (to_cld->has_class_mirror_holder()) {\n+      if (from_cld == to_cld) {\n+        return;\n+      }\n+    } else {\n+      oop to = to_cld->class_loader();\n+      oop from = from_cld->class_loader();\n+\n+      if (from == to ||\n+          (!from_cld->is_boot_class_loader_data() &&\n+           java_lang_ClassLoader::isAncestor(from, to))) {\n+        return; \/\/ `to` is reachable by iterating parents of `from`\n+      }\n+    }\n+\n+    oop* const begin = from_nm->oops_begin();\n+    oop* const end = from_nm->oops_end();\n+    for (oop* p = begin; p < end; p++) {\n+      oop obj = NMethodAccess<ON_PHANTOM_OOP_REF | AS_NO_KEEPALIVE>::oop_load(p);\n+      if (obj == to_holder) {\n+        return;\n+      }\n+    }\n+\n+    \/\/ The callers loader will keep the callee alive if a dependency has been recorded with\n+    \/\/ ClassLoaderData::record_dependency()\n+    if (from_cld->handles_contain(to_holder)) {\n+      return;\n+    }\n+\n+    {\n+      stringStream ss;\n+      to_method->print_short_name(&ss);\n+      guarantee(false, \"Missing dependency resolving %s%s (%s) call to %s\",\n+                (is_optimized) ? \"optimized \" : \"\", (is_virtual) ? \"virtual\" : \"static\",\n+                Bytecodes::name(invoke_code), ss.freeze());\n+    }\n+  }\n+}\n+\n@@ -1494,0 +1558,5 @@\n+  if (!is_virtual || is_optimized) {\n+    \/\/ The holder of the callee_method must be reachable from caller_nm\n+    check_path_to_callee(is_virtual, is_optimized, caller_nm, callee_method, invoke_code, current \/* thread *\/);\n+  }\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":69,"deletions":0,"binary":false,"changes":69,"status":"modified"}]}