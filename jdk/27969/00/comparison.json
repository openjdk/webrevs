{"files":[{"patch":"@@ -2010,0 +2010,3 @@\n+    DEBUG_ONLY(int algm = MIN2(RegMask::num_registers(ireg), (int)Matcher::stack_alignment_in_slots()) * VMRegImpl::stack_slot_size);\n+    assert((src_lo_rc != rc_stack) || is_aligned(src_offset, algm), \"unaligned vector spill sp offset %d (src)\", src_offset);\n+    assert((dst_lo_rc != rc_stack) || is_aligned(dst_offset, algm), \"unaligned vector spill sp offset %d (dst)\", dst_offset);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1798,0 +1798,5 @@\n+    int src_offset = ra_->reg2offset(src_lo);\n+    int dst_offset = ra_->reg2offset(dst_lo);\n+    DEBUG_ONLY(int algm = MIN2(RegMask::num_registers(ideal_reg()), (int)Matcher::stack_alignment_in_slots()) * VMRegImpl::stack_slot_size);\n+    assert((src_lo_rc != rc_stack) || is_aligned(src_offset, algm), \"unaligned vector spill sp offset %d (src)\", src_offset);\n+    assert((dst_lo_rc != rc_stack) || is_aligned(dst_offset, algm), \"unaligned vector spill sp offset %d (dst)\", dst_offset);\n@@ -1800,2 +1805,0 @@\n-      int src_offset = ra_->reg2offset(src_lo);\n-      int dst_offset = ra_->reg2offset(dst_lo);\n@@ -1809,0 +1812,5 @@\n+#ifndef PRODUCT\n+      if (st != nullptr) {\n+        st->print(\"%-7s [R1_SP + #%d] -> [R1_SP + #%d] \\t\/\/ vector spill copy\", \"SPILL\", src_offset, dst_offset);\n+      }\n+#endif \/\/ !PRODUCT\n@@ -1813,1 +1821,0 @@\n-      int dst_offset = ra_->reg2offset(dst_lo);\n@@ -1815,13 +1822,2 @@\n-        if (is_aligned(dst_offset, 16)) {\n-          if (masm) {\n-            __ stxv(Rsrc, dst_offset, R1_SP); \/\/ matches storeV16_Power9\n-          }\n-          size += 4;\n-        } else {\n-          \/\/ Other alignment can be used by Vector API (VectorPayload in rearrangeOp,\n-          \/\/ observed with VectorRearrangeTest.java on Power9).\n-          if (masm) {\n-            __ addi(R0, R1_SP, dst_offset);\n-            __ stxvx(Rsrc, R0); \/\/ matches storeV16_Power9 (regarding element ordering)\n-          }\n-          size += 8;\n+        if (masm) {\n+          __ stxv(Rsrc, dst_offset, R1_SP); \/\/ matches storeV16_Power9\n@@ -1829,0 +1825,1 @@\n+        size += 4;\n@@ -1836,0 +1833,10 @@\n+#ifndef PRODUCT\n+      if (st != nullptr) {\n+        if (PowerArchitecturePPC64 >= 9) {\n+          st->print(\"%-7s %s, [R1_SP + #%d] \\t\/\/ vector spill copy\", \"STXV\", Matcher::regName[src_lo], dst_offset);\n+        } else {\n+          st->print(\"%-7s %s, R1_SP, %d \\t\/\/ vector spill copy\", \"ADDI\", Matcher::regName[src_lo], dst_offset);\n+          st->print(\"%-7s %s, [R1_SP] \\t\/\/ vector spill copy\", \"STXVD2X\", Matcher::regName[src_lo]);\n+        }\n+      }\n+#endif \/\/ !PRODUCT\n@@ -1840,1 +1847,0 @@\n-      int src_offset = ra_->reg2offset(src_lo);\n@@ -1842,11 +1848,2 @@\n-        if (is_aligned(src_offset, 16)) {\n-          if (masm) {\n-            __ lxv(Rdst, src_offset, R1_SP);\n-          }\n-          size += 4;\n-        } else {\n-          if (masm) {\n-            __ addi(R0, R1_SP, src_offset);\n-            __ lxvx(Rdst, R0);\n-          }\n-          size += 8;\n+        if (masm) {\n+          __ lxv(Rdst, src_offset, R1_SP);\n@@ -1854,0 +1851,1 @@\n+        size += 4;\n@@ -1861,0 +1859,10 @@\n+#ifndef PRODUCT\n+      if (st != nullptr) {\n+        if (PowerArchitecturePPC64 >= 9) {\n+          st->print(\"%-7s %s, [R1_SP + #%d] \\t\/\/ vector spill copy\", \"LXV\", Matcher::regName[dst_lo], src_offset);\n+        } else {\n+          st->print(\"%-7s %s, R1_SP, %d \\t\/\/ vector spill copy\", \"ADDI\", Matcher::regName[src_lo], src_offset);\n+          st->print(\"%-7s %s, [R1_SP] \\t\/\/ vector spill copy\", \"LXVD2X\", Matcher::regName[dst_lo]);\n+        }\n+      }\n+#endif \/\/ !PRODUCT\n@@ -1870,0 +1878,6 @@\n+#ifndef PRODUCT\n+      if (st != nullptr) {\n+        st->print(\"%-7s %s, %s, %s\\t\/\/ vector spill copy\",\n+                  \"XXLOR\", Matcher::regName[dst_lo], Matcher::regName[src_lo], Matcher::regName[src_lo]);\n+      }\n+#endif \/\/ !PRODUCT\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":42,"deletions":28,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-  uint16_t _num_regs;           \/\/ 2 for Longs and Doubles, 1 for all else\n+  uint16_t _num_regs;           \/\/ byte size of the value divided by 4\n","filename":"src\/hotspot\/share\/opto\/chaitin.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -286,7 +286,6 @@\n-  \/\/ Finally, make sure the incoming arguments take up an even number of\n-  \/\/ words, in case the arguments or locals need to contain doubleword stack\n-  \/\/ slots.  The rest of the system assumes that stack slot pairs (in\n-  \/\/ particular, in the spill area) which look aligned will in fact be\n-  \/\/ aligned relative to the stack pointer in the target machine.  Double\n-  \/\/ stack slots will always be allocated aligned.\n-  _new_SP = OptoReg::Name(align_up(_in_arg_limit, (int)RegMask::SlotsPerLong));\n+  \/\/ Allocated register sets are aligned to their size. Offsets to the stack\n+  \/\/ pointer have to be aligned to the size of the access. For this _new_SP is\n+  \/\/ aligned to the size of the largest register set with the stack alignment as\n+  \/\/ limit and a minimum of SlotsPerLong (2).\n+  int vector_aligment = MIN2(C->max_vector_size(), stack_alignment_in_bytes()) \/ VMRegImpl::stack_slot_size;\n+  _new_SP = OptoReg::Name(align_up(_in_arg_limit, MAX2((int)RegMask::SlotsPerLong, vector_aligment)));\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -357,10 +357,6 @@\n-  \/\/ Also, consider the maximum alignment size for a normally allocated\n-  \/\/ value.  Since we allocate register pairs but not register quads (at\n-  \/\/ present), this alignment is SlotsPerLong (== 2).  A normally\n-  \/\/ aligned allocated register is either a single register, or a pair\n-  \/\/ of adjacent registers, the lower-numbered being even.\n-  \/\/ See also is_aligned_Pairs() below, and the padding added before\n-  \/\/ Matcher::_new_SP to keep allocated pairs aligned properly.\n-  \/\/ If we ever go to quad-word allocations, SlotsPerQuad will become\n-  \/\/ the controlling alignment constraint.  Note that this alignment\n-  \/\/ requirement is internal to the allocator, and independent of any\n+  \/\/ We allocate single registers for 32 bit values and register pairs for 64\n+  \/\/ bit values. The number of registers allocated for vectors match their size. E.g. for 128 bit\n+  \/\/ vectors (VecX) we allocate a set of 4 registers. Allocated sets are adjacent and aligned.\n+  \/\/ See RegMask::find_first_set(), is_aligned_pairs(), is_aligned_sets(), and the padding added before\n+  \/\/ Matcher::_new_SP to keep allocated pairs and sets aligned properly.\n+  \/\/ Note that this alignment requirement is internal to the allocator, and independent of any\n","filename":"src\/hotspot\/share\/opto\/regmask.hpp","additions":6,"deletions":10,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1260,0 +1260,6 @@\n+    public static final String MEM_TO_REG_SPILL_COPY_TYPE = COMPOSITE_PREFIX + \"MEM_TO_REG_SPILL_COPY_TYPE\" + POSTFIX;\n+    static {\n+        String regex = START + \"MemToRegSpillCopy\" + MID + IS_REPLACED + \".*\" + END;\n+        machOnly(MEM_TO_REG_SPILL_COPY_TYPE, regex);\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2025 SAP SE. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package compiler.vectorapi;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import jdk.incubator.vector.IntVector;\n+import jdk.incubator.vector.VectorSpecies;\n+\n+import jdk.test.lib.Asserts;\n+\n+\/**\n+ * @test\n+ * @bug 8370473\n+ * @library \/test\/lib \/\n+ * @summary Test alignment of vector spill slots. It should match the vector size.\n+ * @modules jdk.incubator.vector\n+ * @requires vm.opt.final.MaxVectorSize == null | vm.opt.final.MaxVectorSize >= 16\n+ *\n+ * @run driver compiler.vectorapi.TestVectorSpilling\n+ *\/\n+\n+public class TestVectorSpilling {\n+\n+    private static final VectorSpecies<Integer> I_SPECIES = IntVector.SPECIES_128;\n+    private static int LENGTH = 1024;\n+\n+    private static int[] ia1;\n+    private static int[] ia2;\n+    private static int[] ir ;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"--add-modules=jdk.incubator.vector\");\n+    }\n+\n+    static class LData {\n+        \/\/ Rading from a volatile field prevents cse optimization\n+        static volatile long vF = 1042;\n+\n+        long l1, l2, l3, l4, l5, l6, l7, l8;\n+        public LData() {\n+            l1 = vF; l2 = vF; l3 = vF; l4 = vF; l5 = vF; l6 = vF; l7 = vF; l8 = vF;\n+        }\n+        public long sum() {\n+            return l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8;\n+        }\n+    }\n+\n+\n+    @Run(test = \"test16ByteSpilling\")\n+    static void test16ByteSpilling_runner() {\n+        test16ByteSpilling(1, 2, 3, 4, 5, 6, 7, 8, 9);\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.MEM_TO_REG_SPILL_COPY_TYPE, \"vectorx\", \"> 0\"},\n+        phase = {CompilePhase.FINAL_CODE})\n+    static long test16ByteSpilling(long l1, long l2, long l3, long l4, long l5, long l6, long l7, long l8,\n+                                   long l9 \/* odd stack arg *\/) {\n+        \/\/ To be scalar replaced and spilled to stack\n+        LData d1 = new LData();\n+        LData d2 = new LData();\n+        LData d3 = new LData();\n+\n+        for (int i = 0; i < LENGTH; i += I_SPECIES.length()) {\n+            IntVector a1v = IntVector.fromArray(I_SPECIES, ia1, i);\n+            IntVector a2v = IntVector.fromArray(I_SPECIES, ia2, i);\n+            int scalar = spillPoint();\n+            a1v.add(a2v)\n+               .add(scalar).intoArray(ir, i);\n+        }\n+\n+        return l1 + l2 + l3 + l4 + l5 + l6 + l7 + l8 + l9 + d1.sum() + d2.sum() + d3.sum();\n+    }\n+\n+    @DontInline\n+    static int spillPoint() {\n+        return 42;\n+    }\n+\n+    static {\n+        ia1 = new int[LENGTH];\n+        ia2 = new int[LENGTH];\n+        ir  = new int[LENGTH];\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/TestVectorSpilling.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"}]}