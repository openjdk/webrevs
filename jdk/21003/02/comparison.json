{"files":[{"patch":"@@ -81,1 +81,1 @@\n-     * This establish an approximate high-bound value for DOS times in\n+     * This establishes an approximate high-bound value for DOS times in\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -381,0 +381,4 @@\n+     * <p>\n+     * A ZipException will be thrown if the combined length, after encoding,\n+     * of the entry name, the extra field data, the entry comment and\n+     * {@linkplain #CENHDR CEN Header size}, exceeds 65,535 bytes.\n@@ -401,1 +405,3 @@\n-     * Closes the ZIP output stream as well as the stream being filtered.\n+     * Finishes writing the contents of the ZIP output stream and closes the\n+     * underlying stream. The stream being filtered will also be closed.\n+     *\n@@ -592,1 +598,2 @@\n-        writeShort(nameBytes.length);\n+        int nlen = nameBytes.length;\n+        writeShort(nlen);\n@@ -629,1 +636,2 @@\n-        byte[] commentBytes;\n+        byte[] commentBytes = null;\n+        int clen = 0;\n@@ -632,4 +640,1 @@\n-            writeShort(Math.min(commentBytes.length, 0xffff));\n-        } else {\n-            commentBytes = null;\n-            writeShort(0);\n+            clen = Math.min(commentBytes.length, 0xffff);\n@@ -637,0 +642,1 @@\n+        writeShort(clen);              \/\/ file comment length\n@@ -642,1 +648,1 @@\n-        writeBytes(nameBytes, 0, nameBytes.length);\n+        writeBytes(nameBytes, 0, nlen);\n@@ -682,0 +688,8 @@\n+\n+        \/\/ CEN header size + name length + comment length + extra length\n+        \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+        \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+        long headerSize = (long)CENHDR + nlen + clen + elen;\n+        if (headerSize > 0xFFFF ) {\n+            throw new ZipException(\"invalid CEN header (bad header size)\");\n+        }\n@@ -684,1 +698,1 @@\n-            writeBytes(commentBytes, 0, Math.min(commentBytes.length, 0xffff));\n+            writeBytes(commentBytes, 0, clen);\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipOutputStream.java","additions":23,"deletions":9,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -49,0 +49,9 @@\n+\n+    \/\/ Helps SparseOutputStream detect write of the last CEN entry\n+    private static final String LAST_CEN_COMMENT = \"LastCEN\";\n+    private static final byte[] LAST_CEN_COMMENT_BYTES =\n+            LAST_CEN_COMMENT.getBytes(StandardCharsets.UTF_8);\n+\n+    \/\/ Entry names produced in this test are fixed-length\n+    public static final int NAME_LENGTH = 10;\n+\n@@ -62,3 +71,2 @@\n-     *\n-     *  Since ZipOutputStream does not enforce the 'combined length' clause,\n-     *  we simply use 65,535 (0xFFFF) for the purpose of this test.\n+     *.\n+     * Create a maximum extra field which does not exceed 65,535 bytes\n@@ -66,1 +74,2 @@\n-    static final int MAX_EXTRA_FIELD_SIZE = 65_535;\n+    static final int MAX_EXTRA_FIELD_SIZE =\n+            65_535 - ZipFile.CENHDR - NAME_LENGTH - LAST_CEN_COMMENT.length();\n@@ -75,3 +84,0 @@\n-    \/\/ Entry names produced in this test are fixed-length\n-    public static final int NAME_LENGTH = 10;\n-\n@@ -87,4 +93,0 @@\n-    \/\/ Helps SparseOutputStream detect write of the last CEN entry\n-    private static final String LAST_CEN_COMMENT = \"LastCEN\";\n-    private static final byte[] LAST_CEN_COMMENT_BYTES = LAST_CEN_COMMENT.getBytes(StandardCharsets.UTF_8);\n-\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/CenSizeTooLarge.java","additions":13,"deletions":11,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,169 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8336025\n+ * @summary Verify that ZipOutputStream throws a ZipException when the\n+ * CEN header size + name length + comment length + extra length exceeds\n+ * 65,535 bytes\n+ * @run junit ZipOutputStreamMaxCenHdrTest\n+ *\/\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+import java.io.*;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipException;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+public class ZipOutputStreamMaxCenHdrTest {\n+\n+    \/\/ CEN header size + name length + comment length + extra length\n+    \/\/ should not exceed 65,535 bytes per the PKWare APP.NOTE\n+    \/\/ 4.4.10, 4.4.11, & 4.4.12.\n+    static final int MAX_COMBINED_CEN_HEADER_SIZE = 0xFFFF;\n+\n+    \/\/ Maximum possible size of name length + comment length + extra length\n+    \/\/ for entries in order to not exceed 65,489 bytes minus 46 bytes for the CEN\n+    \/\/ header length\n+    static final int MAX_NAME_COMMENT_EXTRA_SIZE =\n+            MAX_COMBINED_CEN_HEADER_SIZE - ZipFile.CENHDR;\n+\n+    \/\/ Tag for the 'unknown' field type, specified in APPNOTE.txt 'Third party mappings'\n+    static final short UNKNOWN_ZIP_TAG = (short) 0x9902;\n+\n+    \/\/ ZIP file to be used by the tests\n+    static final Path ZIP_FILE = Path.of(\"maxCENHdrTest.zip\");\n+\n+    \/**\n+     * Clean up prior to test run\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @BeforeEach\n+    public void startUp() throws IOException {\n+        Files.deleteIfExists(ZIP_FILE);\n+    }\n+\n+    \/**\n+     * Validate a ZipException is thrown when the combined CEN Header, name\n+     * length, comment length, and extra data length exceeds 65,535 bytes when\n+     * the ZipOutputStream is closed.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n+    void setCommentTest(int length) throws IOException {\n+        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n+        final byte[] bytes = new byte[length];\n+        Arrays.fill(bytes, (byte) 'a');\n+        ZipEntry zipEntry = new ZipEntry(\"\");\n+        \/\/ The comment length will trigger the ZipException\n+        zipEntry.setComment(new String(bytes, StandardCharsets.UTF_8));\n+        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n+        assertEquals(receivedException, expectZipException);\n+    }\n+\n+    \/**\n+     * Validate an ZipException is thrown when the combined CEN Header, name\n+     * length, comment length, and extra data length exceeds 65,535 bytes when\n+     * the ZipOutputStream is closed.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n+    void setNameTest(int length) throws IOException {\n+        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n+        final byte[] bytes = new byte[length];\n+        Arrays.fill(bytes, (byte) 'a');\n+        \/\/ The name length will trigger the ZipException\n+        ZipEntry zipEntry = new ZipEntry(new String(bytes, StandardCharsets.UTF_8));\n+        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n+        assertEquals(receivedException, expectZipException);\n+    }\n+\n+    \/**\n+     * Validate an ZipException is thrown when the combined CEN Header, name\n+     * length, comment length, and extra data length exceeds 65,535 bytes when\n+     * the ZipOutputStream is closed.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(ints = {MAX_COMBINED_CEN_HEADER_SIZE,\n+            MAX_COMBINED_CEN_HEADER_SIZE - 1,\n+            MAX_NAME_COMMENT_EXTRA_SIZE,\n+            MAX_NAME_COMMENT_EXTRA_SIZE - 1})\n+    void setExtraTest(int length) throws IOException {\n+        boolean expectZipException = length > MAX_NAME_COMMENT_EXTRA_SIZE;\n+        final byte[] bytes = new byte[length];\n+        \/\/ Little-endian ByteBuffer for updating the header fields\n+        ByteBuffer buffer = ByteBuffer.wrap(bytes).order(ByteOrder.LITTLE_ENDIAN);\n+        \/\/ We use the 'unknown' tag, specified in APPNOTE.TXT, 4.6.1 Third party mappings'\n+        buffer.putShort(UNKNOWN_ZIP_TAG);\n+        \/\/ Size of the actual (empty) data\n+        buffer.putShort((short) (length - 2 * Short.BYTES));\n+        ZipEntry zipEntry = new ZipEntry(\"\");\n+        \/\/ The extra data length will trigger the ZipException\n+        zipEntry.setExtra(bytes);\n+        boolean receivedException = writeZipEntry(zipEntry, expectZipException);\n+        assertEquals(receivedException, expectZipException);\n+    }\n+\n+    \/**\n+     * Write a single Zip entry using ZipOutputStream\n+     * @param zipEntry the ZipEntry to write\n+     * @param expectZipException true if a ZipException is expected, false otherwse\n+     * @return true if a ZipException was thrown\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static boolean writeZipEntry(ZipEntry zipEntry, boolean expectZipException)\n+            throws IOException {\n+        boolean receivedException = false;\n+        try (ZipOutputStream zos = new ZipOutputStream(\n+                new BufferedOutputStream(Files.newOutputStream(ZIP_FILE)))) {\n+            zos.putNextEntry(zipEntry);\n+            if (expectZipException) {\n+                ZipException ex = assertThrows(ZipException.class, zos::close);\n+                assertTrue(ex.getMessage().matches(\".*bad header size.*\"),\n+                        \"Unexpected ZipException message: \" + ex.getMessage());\n+                receivedException = true;\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Received Unexpected Exception\", e);\n+        }\n+        return receivedException;\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipOutputStream\/ZipOutputStreamMaxCenHdrTest.java","additions":169,"deletions":0,"binary":false,"changes":169,"status":"added"}]}