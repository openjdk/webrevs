{"files":[{"patch":"@@ -2115,5 +2115,0 @@\n-bool os::can_execute_large_page_memory() {\n-  \/\/ Does not matter, we do not support huge pages.\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/os\/aix\/os_aix.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1812,5 +1812,0 @@\n-bool os::can_execute_large_page_memory() {\n-  \/\/ Does not matter, we do not support huge pages.\n-  return false;\n-}\n-\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4018,4 +4018,0 @@\n-bool os::can_execute_large_page_memory() {\n-  return UseTransparentHugePages;\n-}\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3439,4 +3439,0 @@\n-bool os::can_execute_large_page_memory() {\n-  return true;\n-}\n-\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -358,10 +358,2 @@\n-  if (os::can_execute_large_page_memory()) {\n-    if (InitialCodeCacheSize < ReservedCodeCacheSize) {\n-      \/\/ Make sure that the page size allows for an incremental commit of the reserved space\n-      min_pages = MAX2(min_pages, (size_t)8);\n-    }\n-    return aligned ? os::page_size_for_region_aligned(ReservedCodeCacheSize, min_pages) :\n-                     os::page_size_for_region_unaligned(ReservedCodeCacheSize, min_pages);\n-  } else {\n-    return os::vm_page_size();\n-  }\n+  return aligned ? os::page_size_for_region_aligned(ReservedCodeCacheSize, min_pages) :\n+                   os::page_size_for_region_unaligned(ReservedCodeCacheSize, min_pages);\n@@ -1174,1 +1166,5 @@\n-    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, 8));\n+\n+    \/\/ If InitialCodeCacheSize is equal to ReservedCodeCacheSize, then it's more likely\n+    \/\/ users want to use the largest available page.\n+    const size_t min_pages = (InitialCodeCacheSize == ReservedCodeCacheSize) ? 1 : 8;\n+    ReservedCodeSpace rs = reserve_heap_memory(ReservedCodeCacheSize, page_size(false, min_pages));\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -534,1 +534,0 @@\n-  static bool   can_execute_large_page_memory();\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -75,2 +75,0 @@\n-compiler\/codecache\/CheckLargePages.java 8319795 linux-x64\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,3 @@\n-    private final static WhiteBox WHITE_BOX = WhiteBox.getWhiteBox();\n+    private final static long LP_1G = 1024 * 1024 * 1024;\n+    private final static boolean LARGE_PAGES_ENABLED;\n+    private final static long LARGE_PAGE_SIZE;\n@@ -49,0 +51,65 @@\n+    static {\n+        WhiteBox whiteBox = WhiteBox.getWhiteBox();\n+        LARGE_PAGES_ENABLED = whiteBox.getBooleanVMFlag(\"UseLargePages\");\n+        LARGE_PAGE_SIZE = (whiteBox.getBooleanVMFlag(\"UseLargePages\")) ? whiteBox.getVMLargePageSize() : 0;\n+    }\n+\n+    private static boolean isLargePageSizeEqual(long size) {\n+        return LARGE_PAGE_SIZE == size;\n+    }\n+\n+    private static void testSegmented2GbCodeCacheWith1GbPage() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-XX:+UseLargePages\",\n+                \"-XX:+SegmentedCodeCache\",\n+                \"-XX:InitialCodeCacheSize=2g\",\n+                \"-XX:ReservedCodeCacheSize=2g\",\n+                \"-XX:LargePageSizeInBytes=1g\",\n+                \"-Xlog:pagesize=info\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldMatch(\"Code cache size too small for \\\\S* pages\\\\. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\");\n+        out.shouldHaveExitValue(0);\n+        \/\/ Parse page sizes to find next biggest page\n+        String sizes = out.firstMatch(\"Usable page sizes:([^.]+)\", 1);\n+        List<Long> sizeList = Arrays.stream(sizes.trim().split(\"\\\\s*,\\\\s*\")).map(CheckLargePages::parseMemoryString)\n+                .sorted().toList();\n+        final int smallerPageSizeIndex = sizeList.indexOf(LARGE_PAGE_SIZE) - 1;\n+        Asserts.assertGreaterThanOrEqual(smallerPageSizeIndex, 0);\n+        final long smallerPageSize = sizeList.get(smallerPageSizeIndex);\n+        \/\/ Retrieve reverted page size from code cache warning\n+        String revertedSizeString = out.firstMatch(\n+                \"Code cache size too small for (\\\\S*) pages. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\", 2);\n+        Asserts.assertEquals(parseMemoryString(revertedSizeString), smallerPageSize);\n+    }\n+\n+    private static void testDefaultCodeCacheWith1GbLargePages() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-XX:+UseLargePages\",\n+                \"-XX:LargePageSizeInBytes=1g\",\n+                \"-XX:+PrintCodeCache\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.shouldContain(\"CodeHeap 'non-nmethods'\");\n+        out.shouldContain(\"CodeHeap 'profiled nmethods'\");\n+        out.shouldContain(\"CodeHeap 'non-profiled nmethods'\");\n+    }\n+\n+    private static void testNonSegmented1GbCodeCacheWith1GbLargePages() throws Exception {\n+        ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n+                \"-XX:+UseLargePages\",\n+                \"-XX:LargePageSizeInBytes=1g\",\n+                \"-XX:ReservedCodeCacheSize=1g\",\n+                \"-XX:InitialCodeCacheSize=1g\",\n+                \"-XX:+PrintCodeCache\",\n+                \"-Xlog:pagesize=info\",\n+                \"-version\");\n+        OutputAnalyzer out = new OutputAnalyzer(pb.start());\n+        out.shouldHaveExitValue(0);\n+        out.shouldNotContain(\"CodeHeap 'non-nmethods'\");\n+        out.shouldNotContain(\"CodeHeap 'profiled nmethods'\");\n+        out.shouldNotContain(\"CodeHeap 'non-profiled nmethods'\");\n+        out.shouldContain(\"UseLargePages=1, UseTransparentHugePages=0\");\n+        out.shouldMatch(\"CodeCache:  min=1[gG] max=1[gG] base=[^ ]+ size=1[gG] page_size=1[gG]\");\n+    }\n@@ -50,23 +117,4 @@\n-        final boolean largePages = WHITE_BOX.getBooleanVMFlag(\"UseLargePages\");\n-        final long largePageSize = WHITE_BOX.getVMLargePageSize();\n-        if (largePages && (largePageSize == 1024 * 1024 * 1024)) {\n-            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\n-                    \"-XX:+UseLargePages\",\n-                    \"-XX:+SegmentedCodeCache\",\n-                    \"-XX:InitialCodeCacheSize=2g\",\n-                    \"-XX:ReservedCodeCacheSize=2g\",\n-                    \"-XX:LargePageSizeInBytes=1g\",\n-                    \"-Xlog:pagesize=info\",\n-                    \"-version\");\n-            OutputAnalyzer out = new OutputAnalyzer(pb.start());\n-            out.shouldMatch(\"Code cache size too small for \\\\S* pages\\\\. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\");\n-            out.shouldHaveExitValue(0);\n-            \/\/ Parse page sizes to find next biggest page\n-            String sizes = out.firstMatch(\"Usable page sizes:([^.]+)\", 1);\n-            List<Long> sizeList = Arrays.stream(sizes.trim().split(\"\\\\s*,\\\\s*\")).map(CheckLargePages::parseMemoryString).sorted().toList();\n-            final int smallerPageSizeIndex = sizeList.indexOf(largePageSize) - 1;\n-            Asserts.assertGreaterThanOrEqual(smallerPageSizeIndex, 0);\n-            final long smallerPageSize = sizeList.get(smallerPageSizeIndex);\n-            \/\/ Retrieve reverted page size from code cache warning\n-            String revertedSizeString = out.firstMatch(\"Code cache size too small for (\\\\S*) pages. Reverting to smaller page size \\\\((\\\\S*)\\\\)\\\\.\", 2);\n-            Asserts.assertEquals(parseMemoryString(revertedSizeString), smallerPageSize);\n+        if (isLargePageSizeEqual(LP_1G)) {\n+            testSegmented2GbCodeCacheWith1GbPage();\n+            testDefaultCodeCacheWith1GbLargePages();\n+            testNonSegmented1GbCodeCacheWith1GbLargePages();\n@@ -74,2 +122,2 @@\n-            System.out.println(\"1GB large pages not supported: UseLargePages=\" + largePages +\n-                    (largePages ? \", largePageSize=\" + largePageSize : \"\") + \". Skipping\");\n+            System.out.println(\"1GB large pages not supported: UseLargePages=\" + LARGE_PAGES_ENABLED +\n+                    (LARGE_PAGES_ENABLED ? \", largePageSize=\" + LARGE_PAGE_SIZE : \"\") + \". Skipping\");\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckLargePages.java","additions":74,"deletions":26,"binary":false,"changes":100,"status":"modified"}]}