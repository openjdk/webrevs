{"files":[{"patch":"@@ -882,1 +882,1 @@\n-  ICache::invalidate_word((address)patch_addr);\n+  ICacheInvalidationContext::invalidate_word((address)patch_addr);\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(bool, NeoverseN1Errata1542419, false, DIAGNOSTIC,             \\\n+          \"Enable workaround for Neoverse N1 erratum 1542419\")          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -57,1 +58,2 @@\n-  ICache::invalidate_range(addr(), bytes);\n+\n+  ICacheInvalidationContext::invalidate_range(addr(), bytes);\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+bool VM_Version::_cache_dic_enabled;\n+bool VM_Version::_cache_idc_enabled;\n+\n@@ -66,0 +69,13 @@\n+static bool has_neoverse_n1_errata_1542419() {\n+  const int major_rev_num = VM_Version::cpu_variant();\n+  const int minor_rev_num = VM_Version::cpu_revision();\n+  \/\/ Neoverse N1: 0xd0c\n+  \/\/ Erratum 1542419 affects r3p0, r3p1 and r4p0.\n+  \/\/ It is fixed in r4p1 and later revisions, which are not affected.\n+  return (VM_Version::cpu_family() == VM_Version::CPU_ARM &&\n+          VM_Version::model_is(0xd0c) &&\n+          ((major_rev_num == 3 && minor_rev_num == 0) ||\n+           (major_rev_num == 3 && minor_rev_num == 1) ||\n+           (major_rev_num == 4 && minor_rev_num == 0)));\n+}\n+\n@@ -77,0 +93,3 @@\n+  _cache_dic_enabled = false;\n+  _cache_idc_enabled = false;\n+\n@@ -644,0 +663,17 @@\n+  if (FLAG_IS_DEFAULT(UseDeferredICacheInvalidation) && is_cache_idc_enabled() && is_cache_dic_enabled()) {\n+    FLAG_SET_DEFAULT(UseDeferredICacheInvalidation, true);\n+  }\n+\n+  if (FLAG_IS_DEFAULT(NeoverseN1Errata1542419) && has_neoverse_n1_errata_1542419()) {\n+    FLAG_SET_DEFAULT(NeoverseN1Errata1542419, true);\n+  }\n+\n+  if (NeoverseN1Errata1542419) {\n+    if (!has_neoverse_n1_errata_1542419()) {\n+      warning(\"NeoverseN1Errata1542419 is set for the CPU not having Neoverse N1 errata 1542419\");\n+    }\n+    if (FLAG_IS_DEFAULT(UseDeferredICacheInvalidation)) {\n+      FLAG_SET_DEFAULT(UseDeferredICacheInvalidation, true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  static bool _cache_dic_enabled;\n+  static bool _cache_idc_enabled;\n@@ -224,0 +226,3 @@\n+\n+  static bool is_cache_dic_enabled() { return _cache_dic_enabled; }\n+  static bool is_cache_idc_enabled() { return _cache_idc_enabled; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/icache.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+THREAD_LOCAL AArch64ICacheInvalidationContext* AArch64ICacheInvalidationContext::_current_context = nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,5 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\n@@ -40,1 +45,162 @@\n-    __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+    if (NeoverseN1Errata1542419) {\n+      assert(VM_Version::is_cache_idc_enabled(),\n+             \"Expect CTR_EL0.IDC to be enabled for Neoverse N1 with erratum \"\n+             \"1542419\");\n+      assert(!VM_Version::is_cache_dic_enabled(),\n+             \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum \"\n+             \"1542419\");\n+      asm volatile(\"dsb ish       \\n\"\n+                   \"ic  ivau, xzr \\n\"\n+                   \"dsb ish       \\n\"\n+                   \"isb           \\n\"\n+                   : : : \"memory\");\n+    } else {\n+      __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+    }\n+  }\n+};\n+\n+class AArch64ICacheInvalidationContext final : StackObj {\n+ private:\n+  NONCOPYABLE(AArch64ICacheInvalidationContext);\n+\n+  static THREAD_LOCAL AArch64ICacheInvalidationContext* _current_context;\n+\n+  AArch64ICacheInvalidationContext* _parent;\n+  address                           _code;\n+  int                               _size;\n+  ICacheInvalidation                _mode;\n+  bool                              _has_modified_code;\n+\n+ public:\n+  AArch64ICacheInvalidationContext(ICacheInvalidation mode)\n+      : _parent(nullptr), _code(nullptr), _size(0), _mode(mode), _has_modified_code(false) {\n+    _parent = _current_context;\n+    _current_context = this;\n+    if (_parent != nullptr) {\n+      \/\/ The parent context is in charge of icache invalidation.\n+      _mode = (_parent->mode() == ICacheInvalidation::IMMEDIATE) ? ICacheInvalidation::IMMEDIATE : ICacheInvalidation::NOT_NEEDED;\n+    }\n+  }\n+\n+  AArch64ICacheInvalidationContext()\n+      : AArch64ICacheInvalidationContext(UseDeferredICacheInvalidation\n+                                            ? ICacheInvalidation::DEFERRED\n+                                            : ICacheInvalidation::IMMEDIATE) {}\n+\n+  AArch64ICacheInvalidationContext(address code, int size)\n+      : _parent(nullptr),\n+        _code(code),\n+        _size(size),\n+        _mode(ICacheInvalidation::DEFERRED),\n+        _has_modified_code(true) {\n+    assert(_current_context == nullptr,\n+           \"nested ICacheInvalidationContext(code, size) not supported\");\n+    assert(code != nullptr, \"code must not be null for deferred invalidation\");\n+    assert(size > 0, \"size must be positive for deferred invalidation\");\n+\n+    _current_context = this;\n+\n+    if (UseDeferredICacheInvalidation) {\n+      \/\/ With hardware dcache and icache coherency, we don't need _code.\n+      _code = nullptr;\n+      _size = 0;\n+    }\n+  }\n+\n+  ~AArch64ICacheInvalidationContext() {\n+    _current_context = _parent;\n+\n+    if (_code != nullptr) {\n+      assert(_size > 0, \"size must be positive for deferred invalidation\");\n+      assert(_mode == ICacheInvalidation::DEFERRED, \"sanity\");\n+      assert(_has_modified_code, \"sanity\");\n+      assert(_parent == nullptr, \"sanity\");\n+\n+      ICache::invalidate_range(_code, _size);\n+      return;\n+    }\n+\n+    if (!_has_modified_code) {\n+      return;\n+    }\n+\n+    if (_parent != nullptr) {\n+      _parent->set_has_modified_code();\n+    }\n+\n+    if (_mode != ICacheInvalidation::DEFERRED) {\n+      return;\n+    }\n+\n+    assert(VM_Version::is_cache_idc_enabled(), \"Expect CTR_EL0.IDC to be enabled\");\n+\n+    asm volatile(\"dsb ish\" : : : \"memory\");\n+\n+    if (NeoverseN1Errata1542419) {\n+      assert(!VM_Version::is_cache_dic_enabled(),\n+             \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum \"\n+             \"1542419\");\n+\n+      \/\/ Errata 1542419: Neoverse N1 cores with the 'COHERENT_ICACHE' feature\n+      \/\/ may fetch stale instructions when software depends on\n+      \/\/ prefetch-speculation-protection instead of explicit synchronization.\n+      \/\/\n+      \/\/ Neoverse-N1 implementation mitigates the errata 1542419 with a\n+      \/\/ workaround:\n+      \/\/ - Disable coherent icache.\n+      \/\/ - Trap IC IVAU instructions.\n+      \/\/ - Execute:\n+      \/\/   - tlbi vae3is, xzr\n+      \/\/   - dsb sy\n+      \/\/ - Ignore trapped IC IVAU instructions.\n+      \/\/\n+      \/\/ `tlbi vae3is, xzr` invalidates all translation entries (all VAs, all\n+      \/\/ possible levels). It waits for all memory accesses using in-scope old\n+      \/\/ translation information to complete before it is considered complete.\n+      \/\/\n+      \/\/ As this workaround has significant overhead, Arm Neoverse N1 (MP050)\n+      \/\/ Software Developer Errata Notice version 29.0 suggests:\n+      \/\/\n+      \/\/ \"Since one TLB inner-shareable invalidation is enough to avoid this\n+      \/\/ erratum, the number of injected TLB invalidations should be minimized\n+      \/\/ in the trap handler to mitigate the performance impact due to this\n+      \/\/ workaround.\"\n+      \/\/ As the address for icache invalidation is not relevant and\n+      \/\/ IC IVAU instruction is ignored, we use XZR in it.\n+      asm volatile(\n+          \"ic  ivau, xzr \\n\"\n+          \"dsb ish       \\n\"\n+          :\n+          :\n+          : \"memory\");\n+    } else {\n+      assert(VM_Version::is_cache_dic_enabled(), \"Expect CTR_EL0.DIC to be enabled\");\n+    }\n+    asm volatile(\"isb\" : : : \"memory\");\n+  }\n+\n+  ICacheInvalidation mode() const { return _mode; }\n+\n+  void set_has_modified_code() {\n+    _has_modified_code = true;\n+  }\n+\n+  static AArch64ICacheInvalidationContext* current() {\n+    return _current_context;\n+  }\n+\n+  static void invalidate_range(address start, int nbytes) {\n+    if (UseDeferredICacheInvalidation) {\n+      assert(_current_context != nullptr &&\n+             (_current_context->mode() == ICacheInvalidation::DEFERRED ||\n+              _current_context->mode() == ICacheInvalidation::NOT_NEEDED),\n+            \"UseDeferredICacheInvalidation requires ICache invalidation mode to be deferred or unneeded.\");\n+      return;\n+    }\n+\n+    ICache::invalidate_range(start, nbytes);\n+  }\n+\n+  static void invalidate_word(address addr) {\n+    invalidate_range(addr, 4);\n@@ -44,0 +210,2 @@\n+#define PD_ICACHE_INVALIDATION_CONTEXT AArch64ICacheInvalidationContext\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":170,"deletions":2,"binary":false,"changes":172,"status":"modified"},{"patch":"@@ -172,0 +172,2 @@\n+  _cache_idc_enabled = ((ctr_el0 >> 28) & 0x1) != 0;\n+  _cache_dic_enabled = ((ctr_el0 >> 29) & 0x1) != 0;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -726,0 +726,5 @@\n+  assert(ICacheInvalidationContext::current() != nullptr,\n+         \"ICache invalidation context should be set\");\n+  assert(ICacheInvalidationContext::current()->mode() == ICacheInvalidation::DEFERRED ||\n+         ICacheInvalidationContext::current()->mode() == ICacheInvalidation::NOT_NEEDED,\n+         \"ICache invalidation should be deferred or unneeded\");\n@@ -748,3 +753,0 @@\n-\n-  \/\/ Flush generated code\n-  ICache::invalidate_range(dest_blob->code_begin(), dest_blob->code_size());\n@@ -933,2 +935,5 @@\n-  \/\/ Move all the code and relocations to the new blob:\n-  relocate_code_to(&cb);\n+  {\n+    ICacheInvalidationContext icic(ICacheInvalidation::NOT_NEEDED);\n+    \/\/ Move all the code and relocations to the new blob:\n+    relocate_code_to(&cb);\n+  }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -334,0 +334,8 @@\n+  if (code_size() == 0) {\n+    \/\/ Nothing to copy\n+    return;\n+  }\n+\n+  \/\/ Optimize ICache invalidation by batching it for the whole blob if\n+  \/\/ possible.\n+  ICacheInvalidationContext icic(code_begin(), code_size());\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -678,0 +678,1 @@\n+    ICacheInvalidationContext icic;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1328,2 +1328,7 @@\n-    code_buffer->copy_code_and_locs_to(this);\n-    code_buffer->copy_values_to(this);\n+    {\n+      \/\/ Optimize ICache invalidation by batching it for the whole blob if\n+      \/\/ possible.\n+      ICacheInvalidationContext icic(code_begin(), code_size());\n+      code_buffer->copy_code_and_locs_to(this);\n+      code_buffer->copy_values_to(this);\n+    }\n@@ -1552,1 +1557,5 @@\n-  nmethod* nm_copy = new (size(), code_blob_type) nmethod(*this);\n+  nmethod* nm_copy;\n+  {\n+    ICacheInvalidationContext icic(ICacheInvalidation::NOT_NEEDED);\n+    nm_copy = new (size(), code_blob_type) nmethod(*this);\n+  }\n@@ -1785,4 +1794,10 @@\n-    \/\/ Copy code and relocation info\n-    code_buffer->copy_code_and_locs_to(this);\n-    \/\/ Copy oops and metadata\n-    code_buffer->copy_values_to(this);\n+    {\n+      \/\/ Optimize ICache invalidation by batching it for the whole blob if\n+      \/\/ possible.\n+      ICacheInvalidationContext icic(code_begin(), code_size());\n+      \/\/ Copy code and relocation info\n+      code_buffer->copy_code_and_locs_to(this);\n+      \/\/ Copy oops and metadata\n+      code_buffer->copy_values_to(this);\n+    }\n+\n@@ -2043,1 +2058,1 @@\n-  fix_oop_relocations(nullptr, nullptr, \/*initialize_immediates=*\/ true);\n+  fix_all_oop_relocations();\n@@ -2055,1 +2070,1 @@\n-void nmethod::fix_oop_relocations(address begin, address end, bool initialize_immediates) {\n+void nmethod::fix_all_oop_relocations() {\n@@ -2057,1 +2072,1 @@\n-  RelocIterator iter(this, begin, end);\n+  RelocIterator iter(this);\n@@ -2059,0 +2074,1 @@\n+    bool modified_code = false;\n@@ -2061,1 +2077,1 @@\n-      if (initialize_immediates && reloc->oop_is_immediate()) {\n+      if (reloc->oop_is_immediate()) {\n@@ -2065,0 +2081,3 @@\n+      } else {\n+        \/\/ get the oop from the pool, and re-insert it into the instruction\n+        reloc->set_value(reloc->value());\n@@ -2066,2 +2085,0 @@\n-      \/\/ Refresh the oop-related bits of this instruction.\n-      reloc->fix_oop_relocation();\n@@ -2075,0 +2092,23 @@\n+void nmethod::fix_non_immediate_oop_relocations() {\n+  \/\/ re-patch all oop-bearing instructions, just in case some oops moved\n+  RelocIterator iter(this);\n+  ICacheInvalidationContext icic;\n+  while (iter.next()) {\n+    bool modified_code = false;\n+    if (iter.type() == relocInfo::oop_type) {\n+      oop_Relocation* reloc = iter.oop_reloc();\n+      if (!reloc->oop_is_immediate()) {\n+        \/\/ get the oop from the pool, and re-insert it into the instruction\n+        reloc->set_value(reloc->value());\n+        modified_code = true;\n+      }\n+    } else if (iter.type() == relocInfo::metadata_type) {\n+      metadata_Relocation* reloc = iter.metadata_reloc();\n+      modified_code = reloc->fix_metadata_relocation();\n+    }\n+    if (modified_code) {\n+      icic.set_has_modified_code();\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":53,"deletions":13,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -805,1 +805,0 @@\n-  void fix_oop_relocations(address begin, address end, bool initialize_immediates);\n@@ -812,2 +811,2 @@\n-  void fix_oop_relocations(address begin, address end) { fix_oop_relocations(begin, end, false); }\n-  void fix_oop_relocations()                           { fix_oop_relocations(nullptr, nullptr, false); }\n+  void fix_non_immediate_oop_relocations();\n+  void fix_all_oop_relocations();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -593,9 +593,0 @@\n-\n-void oop_Relocation::fix_oop_relocation() {\n-  if (!oop_is_immediate()) {\n-    \/\/ get the oop from the pool, and re-insert it into the instruction:\n-    set_value(value());\n-  }\n-}\n-\n-\n@@ -630,1 +621,1 @@\n-void metadata_Relocation::fix_metadata_relocation() {\n+bool metadata_Relocation::fix_metadata_relocation() {\n@@ -634,0 +625,1 @@\n+    return true;\n@@ -635,0 +627,1 @@\n+  return false;\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -991,2 +991,0 @@\n-  void fix_oop_relocation();        \/\/ reasserts oop value\n-\n@@ -1043,1 +1041,1 @@\n-  void fix_metadata_relocation();        \/\/ reasserts metadata value\n+  bool fix_metadata_relocation();        \/\/ reasserts metadata value\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  nm->fix_oop_relocations();\n+  nm->fix_non_immediate_oop_relocations();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NMethodClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    _nm->fix_oop_relocations();\n+    _nm->fix_non_immediate_oop_relocations();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -73,2 +74,4 @@\n-  \/\/ Heal barriers\n-  ZNMethod::nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic;\n+    \/\/ Heal barriers\n+    ZNMethod::nmethod_patch_barriers(nm);\n@@ -76,3 +79,4 @@\n-  \/\/ Heal oops\n-  ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n-  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+    \/\/ Heal oops\n+    ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n+    ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -1438,6 +1439,9 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n-\n-      \/\/ Heal oops\n-      ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      {\n+        ICacheInvalidationContext icic;\n+        \/\/ Heal barriers\n+        ZNMethod::nmethod_patch_barriers(nm);\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -721,6 +722,9 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n-\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      {\n+         ICacheInvalidationContext icic;\n+         \/\/ Heal barriers\n+         ZNMethod::nmethod_patch_barriers(nm);\n+\n+         \/\/ Heal oops\n+         ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n+         ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n@@ -756,4 +760,0 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n-\n@@ -770,3 +770,10 @@\n-      if (complete_disarm) {\n-        \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n-        ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+        ICacheInvalidationContext icic;\n+        if (complete_disarm) {\n+          \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n+          ZNMethod::nmethod_patch_barriers(nm);\n+        }\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -250,0 +251,4 @@\n+  ICacheInvalidationContext icic;\n+  if (gc_data(nm)->barriers()->is_nonempty()) {\n+    icic.set_has_modified_code();\n+  }\n@@ -286,1 +291,1 @@\n-    nm->fix_oop_relocations();\n+    nm->fix_non_immediate_oop_relocations();\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    nm->fix_oop_relocations();\n+    nm->fix_non_immediate_oop_relocations();\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2007,0 +2007,2 @@\n+  product(bool, UseDeferredICacheInvalidation, false, DIAGNOSTIC,           \\\n+          \"Defer multiple ICache invalidation to single invalidation\")      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+NOT_PRODUCT(THREAD_LOCAL DefaultICacheInvalidationContext* DefaultICacheInvalidationContext::_current_context = nullptr;)\n+\n","filename":"src\/hotspot\/share\/runtime\/icache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,5 @@\n+enum class ICacheInvalidation : uint8_t {\n+  NOT_NEEDED = 0,\n+  IMMEDIATE  = 1,\n+  DEFERRED   = 2\n+};\n@@ -132,0 +137,66 @@\n+class DefaultICacheInvalidationContext final : StackObj {\n+ private:\n+  NONCOPYABLE(DefaultICacheInvalidationContext);\n+\n+  NOT_PRODUCT(static THREAD_LOCAL DefaultICacheInvalidationContext* _current_context;)\n+\n+  address            _code;\n+  int                _size;\n+  ICacheInvalidation _mode;\n+\n+ public:\n+  DefaultICacheInvalidationContext(ICacheInvalidation mode)\n+      : _code(nullptr), _size(0), _mode(mode) {\n+    NOT_PRODUCT(_current_context = this);\n+  }\n+\n+  DefaultICacheInvalidationContext() : DefaultICacheInvalidationContext(ICacheInvalidation::IMMEDIATE) {}\n+\n+  DefaultICacheInvalidationContext(address code, int size)\n+      : _code(code), _size(size), _mode(ICacheInvalidation::DEFERRED) {\n+    NOT_PRODUCT(_current_context = this);\n+    assert(code != nullptr, \"code must not be null for deferred invalidation\");\n+    assert(size > 0, \"size must be positive for deferred invalidation\");\n+  }\n+\n+  ~DefaultICacheInvalidationContext() {\n+    NOT_PRODUCT(_current_context = nullptr);\n+    if (_code != nullptr) {\n+      assert(_mode == ICacheInvalidation::DEFERRED, \"sanity\");\n+      assert(_size > 0, \"size must be positive for deferred invalidation\");\n+      ICache::invalidate_range(_code, _size);\n+      _code = nullptr;\n+      _size = 0;\n+      _mode = ICacheInvalidation::NOT_NEEDED;\n+    }\n+  }\n+\n+  ICacheInvalidation mode() const {\n+    return _mode;\n+  }\n+\n+  void set_has_modified_code() {\n+    \/\/ No-op for the default implementation.\n+  }\n+\n+  static void invalidate_range(address start, int nbytes) {\n+    ICache::invalidate_range(start, nbytes);\n+  }\n+\n+  static void invalidate_word(address addr) {\n+    invalidate_range(addr, 4);\n+  }\n+\n+#ifdef ASSERT\n+  static DefaultICacheInvalidationContext* current() {\n+    return _current_context;\n+  }\n+#endif\n+};\n+\n+#ifdef PD_ICACHE_INVALIDATION_CONTEXT\n+using ICacheInvalidationContext = PD_ICACHE_INVALIDATION_CONTEXT;\n+#else\n+using ICacheInvalidationContext = DefaultICacheInvalidationContext;\n+#endif \/\/ PD_ICACHE_INVALIDATION_CONTEXT\n+\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":72,"deletions":1,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * @test id=parallel\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ParallelGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Parallel\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=g1\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for G1GC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.G1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=shenandoah\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=genshen\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for generational ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=z\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ZGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Z\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * Nmethods have GC barriers and OOPs embedded into their code. GCs can patch nmethod's code\n+ * which requires icache invalidation. Doing invalidation per instruction can be expensive.\n+ * CPU can support hardware dcache and icache coherence. This would allow to defer cache\n+ * invalidation.\n+ *\n+ * There are assertions for deferred cache invalidation. This test checks that all of them\n+ * are passed.\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestDeferredICacheInvalidation {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static class A {\n+        public String s1;\n+        public String s2;\n+        public String s3;\n+        public String s4;\n+        public String s5;\n+        public String s6;\n+        public String s7;\n+        public String s8;\n+        public String s9;\n+    }\n+\n+    public static A a = new A();\n+\n+    private static int compLevel;\n+\n+    public static class B {\n+        public static void test0() {\n+        }\n+\n+        public static void test1() {\n+            a.s1 = a.s1 + \"1\";\n+        }\n+\n+        public static void test2() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+        }\n+\n+        public static void test3() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+        }\n+\n+        public static void test4() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+        }\n+\n+        public static void test5() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+        }\n+\n+        public static void test6() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+        }\n+\n+        public static void test7() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+        }\n+\n+        public static void test8() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+        }\n+\n+        public static void test9() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+            a.s9 = a.s9 + \"9\";\n+        }\n+    }\n+\n+    private static void compileMethods() throws Exception {\n+        for (var m : B.class.getDeclaredMethods()) {\n+            if (!m.getName().startsWith(\"test\")) {\n+                continue;\n+            }\n+            m.invoke(null);\n+            WB.markMethodProfiled(m);\n+            WB.enqueueMethodForCompilation(m, compLevel);\n+            while (WB.isMethodQueuedForCompilation(m)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(m) != compLevel) {\n+                throw new IllegalStateException(\"Method \" + m + \" is not compiled at the compilation level: \" + compLevel + \". Got: \" + WB.getMethodCompilationLevel(m));\n+            }\n+        }\n+    }\n+\n+    public static void youngGC() throws Exception {\n+        a = null;\n+        WB.youngGC();\n+    }\n+\n+    public static void fullGC() throws Exception {\n+        a = null;\n+        WB.fullGC();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Boolean.TRUE.equals(WB.getBooleanVMFlag(\"UseDeferredICacheInvalidation\"))) {\n+            System.out.println(\"Skip. Test requires UseDeferredICacheInvalidation enabled.\");\n+        }\n+        compLevel = (args[1].equals(\"C1\")) ? 1 : 4;\n+        compileMethods();\n+        TestDeferredICacheInvalidation.class.getMethod(args[0]).invoke(null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestDeferredICacheInvalidation.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.gc;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.bench.util.InMemoryJavaCompiler;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+\n+\/*\n+ * Nmethods have OOPs and GC barriers emmedded into their code.\n+ * GCs patch them which causes invalidation of nmethods' code.\n+ *\n+ * This benchmark can be used to estimate the cost of patching\n+ * OOPs and GC barriers.\n+ *\n+ * We create 5000 nmethods which access fields of a class.\n+ * We measure the time of different GC cycles to see\n+ * the impact of patching nmethods.\n+ *\n+ * The benchmark parameters are method count and accessed field count.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3, jvmArgsAppend = {\n+    \"-XX:+UnlockDiagnosticVMOptions\",\n+    \"-XX:+UnlockExperimentalVMOptions\",\n+    \"-XX:+WhiteBoxAPI\",\n+    \"-Xbootclasspath\/a:lib-test\/wb.jar\",\n+    \"-XX:-UseCodeCacheFlushing\"\n+})\n+public class GCPatchingNmethodCost {\n+\n+    private static final int COMP_LEVEL = 1;\n+    private static final String FIELD_USER = \"FieldUser\";\n+\n+    public static Fields fields;\n+\n+    private static TestMethod[] methods = {};\n+    private static byte[] BYTE_CODE;\n+    private static WhiteBox WB;\n+\n+    @Param({\"5000\"})\n+    public int methodCount;\n+\n+    @Param({\"0\", \"2\", \"4\", \"8\"})\n+    public int accessedFieldCount;\n+\n+    public static class Fields {\n+        public String f1;\n+        public String f2;\n+        public String f3;\n+        public String f4;\n+        public String f5;\n+        public String f6;\n+        public String f7;\n+        public String f8;\n+        public String f9;\n+    }\n+\n+    private static final class TestMethod {\n+        private final Method method;\n+\n+        public TestMethod(Method method) throws Exception {\n+            this.method = method;\n+            WB.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile() throws Exception {\n+            method.invoke(null);\n+            WB.markMethodProfiled(method);\n+        }\n+\n+        public void invoke() throws Exception {\n+            method.invoke(null);\n+        }\n+\n+        public void compile() throws Exception {\n+            WB.enqueueMethodForCompilation(method, COMP_LEVEL);\n+            while (WB.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(method) != COMP_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled at the compilation level: \" + COMP_LEVEL + \". Got: \" + WB.getMethodCompilationLevel(method));\n+            }\n+        }\n+\n+        public NMethod getNMethod() {\n+            return NMethod.get(method, false);\n+        }\n+    }\n+\n+    private static ClassLoader createClassLoader() {\n+        return new ClassLoader() {\n+            @Override\n+            public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                if (!name.equals(FIELD_USER)) {\n+                    return super.loadClass(name);\n+                }\n+\n+                return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+            }\n+        };\n+    }\n+\n+    private static void createTestMethods(int accessedFieldCount, int count) throws Exception {\n+        String javaCode = \"public class \" + FIELD_USER + \" {\";\n+        String field = GCPatchingNmethodCost.class.getName() + \".fields.f\";\n+        javaCode += \"public static void accessFields() {\";\n+        for (int i = 1; i <= accessedFieldCount; i++) {\n+            javaCode += field + i + \"= \" + field + i + \" + \" + i + \";\";\n+        }\n+        javaCode += \"}}\";\n+\n+        BYTE_CODE = InMemoryJavaCompiler.compile(FIELD_USER, javaCode);\n+\n+        fields = new Fields();\n+\n+        methods = new TestMethod[count];\n+        for (int i = 0; i < count; i++) {\n+            var cl = createClassLoader().loadClass(FIELD_USER);\n+            Method method = cl.getMethod(\"accessFields\");\n+            methods[i] = new TestMethod(method);\n+            methods[i].profile();\n+            methods[i].compile();\n+        }\n+    }\n+\n+    private static void initWhiteBox() {\n+        WB = WhiteBox.getWhiteBox();\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupCodeCache() throws Exception {\n+        initWhiteBox();\n+        createTestMethods(accessedFieldCount, methodCount);\n+        Thread.sleep(1000);\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void youngGC() throws Exception {\n+        fields = null;\n+        WB.youngGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void fullGC() throws Exception {\n+        fields = null;\n+        WB.fullGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void systemGC() throws Exception {\n+        fields = null;\n+        System.gc();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/GCPatchingNmethodCost.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}