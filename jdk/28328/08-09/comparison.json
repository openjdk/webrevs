{"files":[{"patch":"@@ -882,2 +882,1 @@\n-  if (NeoverseN1Errata1542419) {\n-    \/\/ Instruction cache invalidation per barrier is expensive on Neoverse N1 having erratum 1542419.\n+  if (UseDeferredICacheInvalidation) {\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -132,0 +132,2 @@\n+  product(bool, UseDeferredICacheInvalidation, false, DIAGNOSTIC,       \\\n+          \"Defer multiple ICache invalidation to single invalidation\")  \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -660,2 +660,7 @@\n-  if (NeoverseN1Errata1542419 && !has_neoverse_n1_errata_1542419()) {\n-    warning(\"NeoverseN1Errata1542419 is set for the CPU not having Neoverse N1 errata 1542419\");\n+  if (NeoverseN1Errata1542419) {\n+    if (!has_neoverse_n1_errata_1542419()) {\n+      warning(\"NeoverseN1Errata1542419 is set for the CPU not having Neoverse N1 errata 1542419\");\n+    }\n+    if (FLAG_IS_DEFAULT(UseDeferredICacheInvalidation)) {\n+      FLAG_SET_DEFAULT(UseDeferredICacheInvalidation, true);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  if (NeoverseN1Errata1542419 && _needs_invalidation) {\n+  if (UseDeferredICacheInvalidation && _needs_invalidation) {\n@@ -42,2 +42,4 @@\n-  if (NeoverseN1Errata1542419 && current_icache_invalidation_context != nullptr) {\n-    assert(current_icache_invalidation_context->_needs_invalidation, \"ICacheInvalidationContext::deferred_invalidation must be invoked when icache invalidation is needed\");\n+  if (UseDeferredICacheInvalidation && current_icache_invalidation_context != nullptr) {\n+    assert(current_icache_invalidation_context->_needs_invalidation,\n+           \"ICacheInvalidationContext::deferred_invalidation must be invoked \"\n+           \"when icache invalidation is needed\");\n@@ -50,23 +52,7 @@\n-  if (NeoverseN1Errata1542419 && _needs_invalidation) {\n-    \/\/ Errata 1542419: Neoverse N1 cores with the 'COHERENT_ICACHE' feature may fetch stale\n-    \/\/ instructions when software depends on prefetch-speculation-protection\n-    \/\/ instead of explicit synchronization.\n-    \/\/\n-    \/\/ Neoverse-N1 implementation mitigates the errata 1542419 with a workaround:\n-    \/\/ - Disable coherent icache.\n-    \/\/ - Trap IC IVAU instructions.\n-    \/\/ - Execute:\n-    \/\/   - tlbi vae3is, xzr\n-    \/\/   - dsb sy\n-    \/\/ - Ignore trapped IC IVAU instructions.\n-    \/\/\n-    \/\/ `tlbi vae3is, xzr` invalidates all translation entries (all VAs, all possible levels).\n-    \/\/ It waits for all memory accesses using in-scope old translation information to complete\n-    \/\/ before it is considered complete.\n-    \/\/\n-    \/\/ As this workaround has significant overhead, Arm Neoverse N1 (MP050) Software Developer\n-    \/\/ Errata Notice version 29.0 suggests:\n-    \/\/\n-    \/\/ \"Since one TLB inner-shareable invalidation is enough to avoid this erratum, the number\n-    \/\/ of injected TLB invalidations should be minimized in the trap handler to mitigate\n-    \/\/ the performance impact due to this workaround.\"\n+  if (UseDeferredICacheInvalidation && _needs_invalidation) {\n+\n+    \/\/ For deferred icache invalidation, we expect hardware dcache\n+    \/\/ and icache to be coherent: CTR_EL0.IDC == 1 and CTR_EL0.DIC == 1\n+    \/\/ An exception is Neoverse N1 with erratum 1542419, which requires\n+    \/\/ a use of 'IC IVAU' instruction. In such a case, we expect\n+    \/\/ CTR_EL0.DIC == 0.\n@@ -74,2 +60,4 @@\n-    unsigned int cache_info = 0;\n-    asm volatile (\"mrs\\t%0, ctr_el0\":\"=r\" (cache_info));\n+    static unsigned int cache_info = 0;\n+    if (cache_info == 0) {\n+      asm volatile (\"mrs\\t%0, ctr_el0\":\"=r\" (cache_info));\n+    }\n@@ -79,1 +67,5 @@\n-    assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) == 0x0, \"Expect CTR_EL0.DIC to be disabled\");\n+    if (NeoverseN1Errata1542419) {\n+      assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) == 0x0, \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum 1542419\");\n+    } else {\n+      assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) != 0x0, \"Expect CTR_EL0.DIC to be enabled\");\n+    }\n@@ -82,7 +74,35 @@\n-    \/\/ As the address for icache invalidation is not relevant\n-    \/\/ and IC IVAU instruction is ignored, we use XZR in it.\n-    asm volatile(\"dsb ish       \\n\"\n-                 \"ic  ivau, xzr \\n\"\n-                 \"dsb ish       \\n\"\n-                 \"isb           \\n\"\n-                 : : : \"memory\");\n+    asm volatile(\"dsb ish\" : : : \"memory\");\n+\n+    if (NeoverseN1Errata1542419) {\n+      \/\/ Errata 1542419: Neoverse N1 cores with the 'COHERENT_ICACHE' feature\n+      \/\/ may fetch stale instructions when software depends on\n+      \/\/ prefetch-speculation-protection instead of explicit synchronization.\n+      \/\/\n+      \/\/ Neoverse-N1 implementation mitigates the errata 1542419 with a\n+      \/\/ workaround:\n+      \/\/ - Disable coherent icache.\n+      \/\/ - Trap IC IVAU instructions.\n+      \/\/ - Execute:\n+      \/\/   - tlbi vae3is, xzr\n+      \/\/   - dsb sy\n+      \/\/ - Ignore trapped IC IVAU instructions.\n+      \/\/\n+      \/\/ `tlbi vae3is, xzr` invalidates all translation entries (all VAs, all\n+      \/\/ possible levels). It waits for all memory accesses using in-scope old\n+      \/\/ translation information to complete before it is considered complete.\n+      \/\/\n+      \/\/ As this workaround has significant overhead, Arm Neoverse N1 (MP050)\n+      \/\/ Software Developer Errata Notice version 29.0 suggests:\n+      \/\/\n+      \/\/ \"Since one TLB inner-shareable invalidation is enough to avoid this\n+      \/\/ erratum, the number of injected TLB invalidations should be minimized\n+      \/\/ in the trap handler to mitigate the performance impact due to this\n+      \/\/ workaround.\"\n+      \/\/ As the address for icache invalidation is not relevant and\n+      \/\/ IC IVAU instruction is ignored, we use XZR in it.\n+      asm volatile(\"ic  ivau, xzr \\n\"\n+                   \"dsb ish       \\n\"\n+                   : : : \"memory\");\n+    }\n+\n+    asm volatile(\"isb\" : : : \"memory\");\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":56,"deletions":36,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * @test id=ParallelGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ParallelGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Parallel\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=G1GC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for G1GC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.G1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=ShenandoahGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=GenShenGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for generational ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ZGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Z\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * Nmethods have GC barriers and OOPs embedded into their code. GCs can patch nmethod's code\n+ * which requires icache invalidation. Doing invalidation per instruction can be expensive.\n+ * CPU can support hardware dcache and icache coherence. This would allow to defer cache\n+ * invalidation.\n+ *\n+ * There are assertions for deferred cache invalidation. This test checks that all of them\n+ * are passed.\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestDeferredICacheInvalidation {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static class A {\n+        public String s1;\n+        public String s2;\n+        public String s3;\n+        public String s4;\n+        public String s5;\n+        public String s6;\n+        public String s7;\n+        public String s8;\n+        public String s9;\n+    }\n+\n+    public static A a = new A();\n+\n+    private static int compLevel;\n+\n+    public static class B {\n+        public static void test0() {\n+        }\n+\n+        public static void test1() {\n+            a.s1 = a.s1 + \"1\";\n+        }\n+\n+        public static void test2() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+        }\n+\n+        public static void test3() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+        }\n+\n+        public static void test4() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+        }\n+\n+        public static void test5() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+        }\n+\n+        public static void test6() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+        }\n+\n+        public static void test7() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+        }\n+\n+        public static void test8() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+        }\n+\n+        public static void test9() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+            a.s9 = a.s9 + \"9\";\n+        }\n+    }\n+\n+    private static void compileMethods() throws Exception {\n+        for (var m : B.class.getDeclaredMethods()) {\n+            if (!m.getName().startsWith(\"test\")) {\n+                continue;\n+            }\n+            m.invoke(null);\n+            WB.markMethodProfiled(m);\n+            WB.enqueueMethodForCompilation(m, compLevel);\n+            while (WB.isMethodQueuedForCompilation(m)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(m) != compLevel) {\n+                throw new IllegalStateException(\"Method \" + m + \" is not compiled at the compilation level: \" + compLevel + \". Got: \" + WB.getMethodCompilationLevel(m));\n+            }\n+        }\n+    }\n+\n+    public static void youngGC() throws Exception {\n+        a = null;\n+        WB.youngGC();\n+    }\n+\n+    public static void fullGC() throws Exception {\n+        a = null;\n+        WB.fullGC();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Boolean.TRUE.equals(WB.getBooleanVMFlag(\"UseDeferredICacheInvalidation\"))) {\n+            System.out.println(\"Skip. Test requires UseDeferredICacheInvalidation enabled.\");\n+        }\n+        compLevel = (args[1].equals(\"C1\")) ? 1 : 4;\n+        compileMethods();\n+        TestDeferredICacheInvalidation.class.getMethod(args[0]).invoke(null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestDeferredICacheInvalidation.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"}]}