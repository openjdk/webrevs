{"files":[{"patch":"@@ -132,2 +132,0 @@\n-  product(bool, UseDeferredICacheInvalidation, false, DIAGNOSTIC,       \\\n-          \"Defer multiple ICache invalidation to single invalidation\")  \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-           \"ICache invalidation should be deferred or unneeded\");\n+           \"ICache invalidation should be deferred or unneeded.\");\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+  \/\/ It is fixed in r4p1 and later revisions, which are not affected.\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -27,3 +28,1 @@\n-class ICacheInvalidationContext;\n-\n-NOT_PRODUCT(THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context = nullptr;)\n+THREAD_LOCAL AArch64ICacheInvalidationContext* AArch64ICacheInvalidationContext::_current_context = nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"memory\/allocation.hpp\"\n@@ -31,9 +32,22 @@\n-#define PD_ICACHE_INVALIDATION_CONTEXT\n-\n-NOT_PRODUCT(extern THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context;)\n-\n-inline void ICacheInvalidationContext::pd_init() {\n-  assert(current_icache_invalidation_context == nullptr, \"nested ICacheInvalidationContext not supported\");\n-  NOT_PRODUCT(current_icache_invalidation_context = this);\n-  if (_mode == ICacheInvalidation::DEFERRED && _code == nullptr && !UseDeferredICacheInvalidation) {\n-    _mode = ICacheInvalidation::IMMEDIATE;\n+inline void assert_hardware_cache_coherency() {\n+  \/\/ For deferred icache invalidation, we expect hardware dcache\n+  \/\/ and icache to be coherent: CTR_EL0.IDC == 1 and CTR_EL0.DIC == 1\n+  \/\/ An exception is Neoverse N1 with erratum 1542419, which requires\n+  \/\/ a use of 'IC IVAU' instruction. In such a case, we expect\n+  \/\/ CTR_EL0.DIC == 0.\n+#ifdef ASSERT\n+  static unsigned int cache_info = 0;\n+  if (cache_info == 0) {\n+    asm volatile(\"mrs\\t%0, ctr_el0\" : \"=r\"(cache_info));\n+  }\n+  constexpr unsigned int CTR_IDC_SHIFT = 28;\n+  constexpr unsigned int CTR_DIC_SHIFT = 29;\n+  assert(((cache_info >> CTR_IDC_SHIFT) & 0x1) != 0x0,\n+         \"Expect CTR_EL0.IDC to be enabled\");\n+  if (NeoverseN1Errata1542419) {\n+    assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) == 0x0,\n+           \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum \"\n+           \"1542419\");\n+  } else {\n+    assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) != 0x0,\n+           \"Expect CTR_EL0.DIC to be enabled\");\n@@ -41,0 +55,1 @@\n+#endif\n@@ -43,5 +58,3 @@\n-#ifdef ASSERT\n-inline ICacheInvalidationContext* ICacheInvalidationContext::pd_current() {\n-  return current_icache_invalidation_context;\n-}\n-#endif\n+\/\/ Interface for updating the instruction cache.  Whenever the VM\n+\/\/ modifies code, part of the processor instruction cache potentially\n+\/\/ has to be flushed.\n@@ -49,9 +62,7 @@\n-inline void assert_hardware_cache_coherency() {\n-#ifdef ASSERT\n-    static unsigned int cache_info = 0;\n-    if (cache_info == 0) {\n-      asm volatile (\"mrs\\t%0, ctr_el0\":\"=r\" (cache_info));\n-    }\n-    constexpr unsigned int CTR_IDC_SHIFT = 28;\n-    constexpr unsigned int CTR_DIC_SHIFT = 29;\n-    assert(((cache_info >> CTR_IDC_SHIFT) & 0x1) != 0x0, \"Expect CTR_EL0.IDC to be enabled\");\n+class ICache : public AbstractICache {\n+ public:\n+  static void initialize(int phase);\n+  static void invalidate_word(address addr) {\n+    __builtin___clear_cache((char *)addr, (char *)(addr + 4));\n+  }\n+  static void invalidate_range(address start, int nbytes) {\n@@ -59,1 +70,6 @@\n-      assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) == 0x0, \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum 1542419\");\n+      assert_hardware_cache_coherency();\n+      asm volatile(\"dsb ish       \\n\"\n+                   \"ic  ivau, xzr \\n\"\n+                   \"dsb ish       \\n\"\n+                   \"isb           \\n\"\n+                   : : : \"memory\");\n@@ -61,1 +77,76 @@\n-      assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) != 0x0, \"Expect CTR_EL0.DIC to be enabled\");\n+      __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+    }\n+  }\n+};\n+\n+class AArch64ICacheInvalidationContext final : StackObj {\n+ private:\n+  NONCOPYABLE(AArch64ICacheInvalidationContext);\n+\n+  static THREAD_LOCAL AArch64ICacheInvalidationContext* _current_context;\n+\n+  AArch64ICacheInvalidationContext* _parent;\n+  address                           _code;\n+  int                               _size;\n+  ICacheInvalidation                _mode;\n+  bool                              _has_modified_code;\n+\n+ public:\n+  AArch64ICacheInvalidationContext(ICacheInvalidation mode)\n+      : _parent(nullptr), _code(nullptr), _size(0), _mode(mode), _has_modified_code(false) {\n+    _parent = _current_context;\n+    _current_context = this;\n+    if (_parent != nullptr) {\n+      \/\/ The parent context is in charge of icache invalidation.\n+      _mode = (_parent->mode() == ICacheInvalidation::IMMEDIATE) ? ICacheInvalidation::IMMEDIATE : ICacheInvalidation::NOT_NEEDED;\n+    }\n+  }\n+\n+  AArch64ICacheInvalidationContext()\n+      : AArch64ICacheInvalidationContext(UseDeferredICacheInvalidation\n+                                            ? ICacheInvalidation::DEFERRED\n+                                            : ICacheInvalidation::IMMEDIATE) {}\n+\n+  AArch64ICacheInvalidationContext(address code, int size)\n+      : _parent(nullptr),\n+        _code(code),\n+        _size(size),\n+        _mode(ICacheInvalidation::DEFERRED),\n+        _has_modified_code(true) {\n+    assert(_current_context == nullptr,\n+           \"nested ICacheInvalidationContext(code, size) not supported\");\n+    assert(code != nullptr, \"code must not be null for deferred invalidation\");\n+    assert(size > 0, \"size must be positive for deferred invalidation\");\n+\n+    _current_context = this;\n+\n+    if (UseDeferredICacheInvalidation) {\n+      \/\/ With hardware dcache and icache coherency, we don't need _code.\n+      _code = nullptr;\n+      _size = 0;\n+    }\n+  }\n+\n+  ~AArch64ICacheInvalidationContext() {\n+    _current_context = _parent;\n+\n+    if (_code != nullptr) {\n+      assert(_size > 0, \"size must be positive for deferred invalidation\");\n+      assert(_mode == ICacheInvalidation::DEFERRED, \"sanity\");\n+      assert(_has_modified_code, \"sanity\");\n+      assert(_parent == nullptr, \"sanity\");\n+\n+      ICache::invalidate_range(_code, _size);\n+      return;\n+    }\n+\n+    if (!_has_modified_code) {\n+      return;\n+    }\n+\n+    if (_parent != nullptr) {\n+      _parent->set_has_modified_code();\n+    }\n+\n+    if (_mode != ICacheInvalidation::DEFERRED) {\n+      return;\n@@ -63,2 +154,0 @@\n-#endif\n-}\n@@ -66,7 +155,0 @@\n-inline void ICacheInvalidationContext::pd_invalidate_icache() {\n-  if (_mode == ICacheInvalidation::DEFERRED && UseDeferredICacheInvalidation) {\n-    \/\/ For deferred icache invalidation, we expect hardware dcache\n-    \/\/ and icache to be coherent: CTR_EL0.IDC == 1 and CTR_EL0.DIC == 1\n-    \/\/ An exception is Neoverse N1 with erratum 1542419, which requires\n-    \/\/ a use of 'IC IVAU' instruction. In such a case, we expect\n-    \/\/ CTR_EL0.DIC == 0.\n@@ -104,3 +186,6 @@\n-      asm volatile(\"ic  ivau, xzr \\n\"\n-                   \"dsb ish       \\n\"\n-                   : : : \"memory\");\n+      asm volatile(\n+          \"ic  ivau, xzr \\n\"\n+          \"dsb ish       \\n\"\n+          :\n+          :\n+          : \"memory\");\n@@ -108,1 +193,0 @@\n-\n@@ -111,5 +195,0 @@\n-  NOT_PRODUCT(current_icache_invalidation_context = nullptr);\n-  _code = nullptr;\n-  _size = 0;\n-  _mode = ICacheInvalidation::NOT_NEEDED;\n-}\n@@ -117,3 +196,1 @@\n-\/\/ Interface for updating the instruction cache.  Whenever the VM\n-\/\/ modifies code, part of the processor instruction cache potentially\n-\/\/ has to be flushed.\n+  ICacheInvalidation mode() const { return _mode; }\n@@ -121,5 +198,2 @@\n-class ICache : public AbstractICache {\n- public:\n-  static void initialize(int phase);\n-  static void invalidate_word(address addr) {\n-    __builtin___clear_cache((char *)addr, (char *)(addr + 4));\n+  void set_has_modified_code() {\n+    _has_modified_code = true;\n@@ -127,11 +201,3 @@\n-  static void invalidate_range(address start, int nbytes) {\n-    if (NeoverseN1Errata1542419) {\n-      assert_hardware_cache_coherency();\n-      asm volatile(\"dsb ish       \\n\"\n-                   \"ic  ivau, xzr \\n\"\n-                   \"dsb ish       \\n\"\n-                   \"isb           \\n\"\n-                   : : : \"memory\");\n-    } else {\n-      __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n-    }\n+\n+  static AArch64ICacheInvalidationContext* current() {\n+    return _current_context;\n@@ -141,0 +207,2 @@\n+#define PD_ICACHE_INVALIDATION_CONTEXT AArch64ICacheInvalidationContext\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":131,"deletions":63,"binary":false,"changes":194,"status":"modified"},{"patch":"@@ -368,4 +368,0 @@\n-  if (rtype == relocInfo::oop_type &&\n-      !((oop_Relocation*)reloc)->oop_is_immediate()) {\n-    _has_non_immediate_oops = true;\n-  }\n@@ -730,0 +726,5 @@\n+  assert(ICacheInvalidationContext::current() != nullptr,\n+         \"ICache invalidation context should be set\");\n+  assert(ICacheInvalidationContext::current()->mode() == ICacheInvalidation::DEFERRED ||\n+         ICacheInvalidationContext::current()->mode() == ICacheInvalidation::NOT_NEEDED,\n+         \"ICache invalidation should be deferred or unneeded\");\n@@ -936,1 +937,0 @@\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -109,1 +109,0 @@\n-  bool        _has_non_immediate_oops;\n@@ -125,1 +124,0 @@\n-    _has_non_immediate_oops = false;\n@@ -286,4 +284,0 @@\n-  bool has_non_immediate_oops() const {\n-    return _has_non_immediate_oops;\n-  }\n-\n@@ -861,6 +855,0 @@\n-  bool has_non_immediate_oops() const {\n-    return _consts.has_non_immediate_oops()\n-        || _insts.has_non_immediate_oops()\n-        || _stubs.has_non_immediate_oops();\n-  }\n-\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -337,1 +337,0 @@\n-\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -684,2 +684,1 @@\n-    ICacheInvalidationContext icic(iter.method()->has_non_immediate_oops());\n-\n+    ICacheInvalidationContext icic;\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1234,1 +1234,0 @@\n-  _has_non_immediate_oops     = 0;\n@@ -1328,1 +1327,0 @@\n-    _has_non_immediate_oops  = code_buffer->has_non_immediate_oops();\n@@ -1334,1 +1332,0 @@\n-\n@@ -1491,1 +1488,0 @@\n-  _has_non_immediate_oops       = nm._has_non_immediate_oops;\n@@ -1705,2 +1701,0 @@\n-    _has_non_immediate_oops = code_buffer->has_non_immediate_oops();\n-\n@@ -1787,1 +1781,0 @@\n-\n@@ -2063,0 +2056,1 @@\n+  ICacheInvalidationContext icic;\n@@ -2064,0 +2058,1 @@\n+    bool modified_code = false;\n@@ -2070,0 +2065,1 @@\n+        icic.set_has_modified_code();\n@@ -2072,1 +2068,1 @@\n-      reloc->fix_oop_relocation();\n+      modified_code = reloc->fix_oop_relocation();\n@@ -2075,1 +2071,4 @@\n-      reloc->fix_metadata_relocation();\n+      modified_code = reloc->fix_metadata_relocation();\n+    }\n+    if (modified_code) {\n+      icic.set_has_modified_code();\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -277,2 +277,1 @@\n-          _load_reported:1,            \/\/ used by jvmti to track if an event has been posted for this nmethod\n-          _has_non_immediate_oops:1;\n+          _load_reported:1;            \/\/ used by jvmti to track if an event has been posted for this nmethod\n@@ -778,2 +777,0 @@\n-  bool  has_non_immediate_oops() const            { return _has_non_immediate_oops; }\n-\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -594,1 +594,1 @@\n-void oop_Relocation::fix_oop_relocation() {\n+bool oop_Relocation::fix_oop_relocation() {\n@@ -598,0 +598,1 @@\n+    return true;\n@@ -599,0 +600,1 @@\n+  return false;\n@@ -630,1 +632,1 @@\n-void metadata_Relocation::fix_metadata_relocation() {\n+bool metadata_Relocation::fix_metadata_relocation() {\n@@ -634,0 +636,1 @@\n+    return true;\n@@ -635,0 +638,1 @@\n+  return false;\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-  void fix_oop_relocation();        \/\/ reasserts oop value\n+  bool fix_oop_relocation();        \/\/ reasserts oop value\n@@ -1043,1 +1043,1 @@\n-  void fix_metadata_relocation();        \/\/ reasserts metadata value\n+  bool fix_metadata_relocation();        \/\/ reasserts metadata value\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"runtime\/icache.hpp\"\n@@ -91,2 +90,0 @@\n-  ICacheInvalidationContext icic(nm->has_non_immediate_oops());\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NMethodClosure.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"runtime\/icache.hpp\"\n@@ -145,2 +144,0 @@\n-      ICacheInvalidationContext icic(cur->has_non_immediate_oops());\n-\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,1 +37,0 @@\n-#include \"runtime\/icache.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,3 +70,0 @@\n-  ICacheInvalidationContext icic(nmethod_data->_has_non_immed_oops);\n-\n-  assert(nmethod_data->_has_non_immed_oops == nmethod_data->_nm->has_non_immediate_oops(), \"Inconsistent non-immed oops state\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,2 +75,1 @@\n-    ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n-\n+    ICacheInvalidationContext icic;\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1440,2 +1440,1 @@\n-        ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n-\n+        ICacheInvalidationContext icic;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -723,2 +723,1 @@\n-         ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n-\n+         ICacheInvalidationContext icic;\n@@ -772,7 +771,1 @@\n-        bool needs_icache_invalidation = ZNMethod::needs_non_immediate_oops_patching(nm);\n-        if (complete_disarm && ZNMethod::needs_barrier_patching(nm)) {\n-          needs_icache_invalidation = true;\n-        }\n-\n-        ICacheInvalidationContext icic(needs_icache_invalidation);\n-\n+        ICacheInvalidationContext icic;\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -205,6 +205,2 @@\n-  {\n-    ICacheInvalidationContext icic(needs_barrier_patching(nm));\n-\n-    \/\/ Patch nmethod barriers\n-    nmethod_patch_barriers(nm);\n-  }\n+  \/\/ Patch nmethod barriers\n+  nmethod_patch_barriers(nm);\n@@ -255,0 +251,4 @@\n+  ICacheInvalidationContext icic;\n+  if (gc_data(nm)->barriers()->is_nonempty()) {\n+    icic.set_has_modified_code();\n+  }\n@@ -374,7 +374,3 @@\n-        {\n-          ICacheInvalidationContext icic(ZNMethod::needs_non_immediate_oops_patching(nm));\n-\n-          \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n-          ZUncoloredRootProcessOopClosure cl(prev_color);\n-          ZNMethod::nmethod_oops_do_inner(nm, &cl);\n-        }\n+        \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n+        ZUncoloredRootProcessOopClosure cl(prev_color);\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n@@ -431,13 +427,0 @@\n-\n-bool ZNMethod::needs_icache_invalidation(nmethod* nm) {\n-  return needs_barrier_patching(nm) || needs_non_immediate_oops_patching(nm);\n-}\n-\n-bool ZNMethod::needs_barrier_patching(nmethod* nm) {\n-  return gc_data(nm)->barriers()->is_nonempty();\n-}\n-\n-bool ZNMethod::needs_non_immediate_oops_patching(nmethod* nm) {\n-  assert(gc_data(nm)->has_non_immediate_oops() == nm->has_non_immediate_oops(), \"Inconsistent non-immed oops state\");\n-  return gc_data(nm)->has_non_immediate_oops();\n-}\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":9,"deletions":26,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -77,4 +77,0 @@\n-\n-  static bool needs_icache_invalidation(nmethod* nm);\n-  static bool needs_barrier_patching(nmethod* nm);\n-  static bool needs_non_immediate_oops_patching(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-#include \"runtime\/icache.hpp\"\n@@ -84,2 +83,0 @@\n-    ICacheInvalidationContext icic(ZNMethod::needs_non_immediate_oops_patching(nm));\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2006,0 +2006,2 @@\n+  product(bool, UseDeferredICacheInvalidation, false, DIAGNOSTIC,           \\\n+          \"Defer multiple ICache invalidation to single invalidation\")      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+NOT_PRODUCT(THREAD_LOCAL DefaultICacheInvalidationContext* DefaultICacheInvalidationContext::_current_context = nullptr;)\n+\n","filename":"src\/hotspot\/share\/runtime\/icache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,43 +80,0 @@\n-class ICacheInvalidationContext : StackObj {\n- private:\n-  NONCOPYABLE(ICacheInvalidationContext);\n-\n-  address _code;\n-  int _size;\n-  ICacheInvalidation _mode;\n-\n-  void pd_init();\n-  void pd_invalidate_icache();\n-\n-  NOT_PRODUCT(static ICacheInvalidationContext* pd_current());\n-\n- public:\n-  \/\/ Hardware optimized icache invalidation which does not depend on what code is invalidated.\n-  ICacheInvalidationContext(ICacheInvalidation mode) : _code(nullptr), _size(0), _mode(mode) {\n-    pd_init();\n-  }\n-\n-  ICacheInvalidationContext(bool needs_invalidation)\n-      : ICacheInvalidationContext(needs_invalidation\n-                                     ? ICacheInvalidation::DEFERRED\n-                                     : ICacheInvalidation::NOT_NEEDED) {}\n-\n-  \/\/ Use hardware optimized icache invalidation if possible,\n-  \/\/ Otherwise invalidate the specified code range.\n-  ICacheInvalidationContext(address code, int size) : _code(code), _size(size), _mode(ICacheInvalidation::DEFERRED) {\n-    pd_init();\n-  }\n-\n-  ~ICacheInvalidationContext();\n-\n-#ifdef ASSERT\n-  static ICacheInvalidationContext* current() {\n-    return pd_current();\n-  }\n-#endif\n-\n-  ICacheInvalidation mode() const {\n-    return _mode;\n-  }\n-};\n-\n@@ -180,8 +137,23 @@\n-#ifndef PD_ICACHE_INVALIDATION_CONTEXT\n-  \/\/ Default implementation: do nothing\n-  inline void ICacheInvalidationContext::pd_init() {}\n-  inline void ICacheInvalidationContext::pd_invalidate_icache() {}\n-#ifdef ASSERT\n-  inline ICacheInvalidationContext* ICacheInvalidationContext::pd_current() {\n-    Unimplemented();\n-    return nullptr;\n+class DefaultICacheInvalidationContext final : StackObj {\n+ private:\n+  NONCOPYABLE(DefaultICacheInvalidationContext);\n+\n+  NOT_PRODUCT(static THREAD_LOCAL DefaultICacheInvalidationContext* _current_context;)\n+\n+  address            _code;\n+  int                _size;\n+  ICacheInvalidation _mode;\n+\n+ public:\n+  DefaultICacheInvalidationContext(ICacheInvalidation mode)\n+      : _code(nullptr), _size(0), _mode(mode) {\n+    NOT_PRODUCT(_current_context = this);\n+  }\n+\n+  DefaultICacheInvalidationContext() : DefaultICacheInvalidationContext(ICacheInvalidation::IMMEDIATE) {}\n+\n+  DefaultICacheInvalidationContext(address code, int size)\n+      : _code(code), _size(size), _mode(ICacheInvalidation::DEFERRED) {\n+    NOT_PRODUCT(_current_context = this);\n+    assert(code != nullptr, \"code must not be null for deferred invalidation\");\n+    assert(size > 0, \"size must be positive for deferred invalidation\");\n@@ -189,2 +161,0 @@\n-#endif \/\/ ASSERT\n-#endif \/\/ PD_ICACHE_INVALIDATION_CONTEXT\n@@ -192,8 +162,10 @@\n-inline ICacheInvalidationContext::~ICacheInvalidationContext() {\n-  pd_invalidate_icache();\n-  if (_code != nullptr) {\n-    assert(_mode == ICacheInvalidation::DEFERRED, \"sanity\");\n-    assert(_size > 0, \"size must be positive\");\n-    ICache::invalidate_range(_code, _size);\n-    _code = nullptr;\n-    _size = 0;\n+  ~DefaultICacheInvalidationContext() {\n+    NOT_PRODUCT(_current_context = nullptr);\n+    if (_code != nullptr) {\n+      assert(_mode == ICacheInvalidation::DEFERRED, \"sanity\");\n+      assert(_size > 0, \"size must be positive for deferred invalidation\");\n+      ICache::invalidate_range(_code, _size);\n+      _code = nullptr;\n+      _size = 0;\n+      _mode = ICacheInvalidation::NOT_NEEDED;\n+    }\n@@ -201,1 +173,21 @@\n-}\n+\n+  ICacheInvalidation mode() const {\n+    return _mode;\n+  }\n+\n+  void set_has_modified_code() {\n+    \/\/ No-op for the default implementation.\n+  }\n+\n+#ifdef ASSERT\n+  static DefaultICacheInvalidationContext* current() {\n+    return _current_context;\n+  }\n+#endif\n+};\n+\n+#ifdef PD_ICACHE_INVALIDATION_CONTEXT\n+using ICacheInvalidationContext = PD_ICACHE_INVALIDATION_CONTEXT;\n+#else\n+using ICacheInvalidationContext = DefaultICacheInvalidationContext;\n+#endif \/\/ PD_ICACHE_INVALIDATION_CONTEXT\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":55,"deletions":63,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @test id=ParallelGC\n+ * @test id=parallel\n@@ -33,2 +33,0 @@\n- * @requires os.family==\"linux\"\n- * @requires os.arch==\"aarch64\"\n@@ -45,1 +43,1 @@\n- * @test id=G1GC\n+ * @test id=g1\n@@ -50,2 +48,0 @@\n- * @requires os.family==\"linux\"\n- * @requires os.arch==\"aarch64\"\n@@ -62,1 +58,1 @@\n- * @test id=ShenandoahGC\n+ * @test id=shenandoah\n@@ -67,2 +63,0 @@\n- * @requires os.family==\"linux\"\n- * @requires os.arch==\"aarch64\"\n@@ -77,1 +71,1 @@\n- * @test id=GenShenGC\n+ * @test id=genshen\n@@ -82,2 +76,0 @@\n- * @requires os.family==\"linux\"\n- * @requires os.arch==\"aarch64\"\n@@ -94,1 +86,1 @@\n- * @test id=ZGC\n+ * @test id=z\n@@ -99,2 +91,0 @@\n- * @requires os.family==\"linux\"\n- * @requires os.arch==\"aarch64\"\n","filename":"test\/hotspot\/jtreg\/gc\/TestDeferredICacheInvalidation.java","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"}]}