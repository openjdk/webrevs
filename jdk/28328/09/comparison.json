{"files":[{"patch":"@@ -882,0 +882,9 @@\n+  if (UseDeferredICacheInvalidation) {\n+    \/\/ Defer the ICache invalidation to a later point where multiple patches can be handled together.\n+    \/\/\n+    \/\/ Note: We rely on the fact that this function is only called from places where deferred invalidation\n+    \/\/ is safe. This assumption helps to avoid overhead of accessing thread-local data here.\n+    assert(ICacheInvalidationContext::deferred_invalidation(), \"ICache invalidation should be deferred\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -130,0 +130,4 @@\n+  product(bool, NeoverseN1Errata1542419, false, DIAGNOSTIC,             \\\n+          \"Enable workaround for Neoverse N1 erratum 1542419\")          \\\n+  product(bool, UseDeferredICacheInvalidation, false, DIAGNOSTIC,       \\\n+          \"Defer multiple ICache invalidation to single invalidation\")  \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+\n+  if (ICacheInvalidationContext::deferred_invalidation()) {\n+    \/\/ Instruction cache invalidation per relocation can be expensive, e.g. on Neoverse N1 having erratum 1542419.\n+    \/\/ Defer the ICache invalidation to a later point where multiple patches can be handled together.\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,0 +66,12 @@\n+static bool has_neoverse_n1_errata_1542419() {\n+  const int major_rev_num = VM_Version::cpu_variant();\n+  const int minor_rev_num = VM_Version::cpu_revision();\n+  \/\/ Neoverse N1: 0xd0c\n+  \/\/ Erratum 1542419 affects r3p0, r3p1 and r4p0.\n+  return (VM_Version::cpu_family() == VM_Version::CPU_ARM &&\n+          VM_Version::model_is(0xd0c) &&\n+          ((major_rev_num == 3 && minor_rev_num == 0) ||\n+           (major_rev_num == 3 && minor_rev_num == 1) ||\n+           (major_rev_num == 4 && minor_rev_num == 0)));\n+}\n+\n@@ -644,0 +656,13 @@\n+  if (FLAG_IS_DEFAULT(NeoverseN1Errata1542419) && has_neoverse_n1_errata_1542419()) {\n+    FLAG_SET_DEFAULT(NeoverseN1Errata1542419, true);\n+  }\n+\n+  if (NeoverseN1Errata1542419) {\n+    if (!has_neoverse_n1_errata_1542419()) {\n+      warning(\"NeoverseN1Errata1542419 is set for the CPU not having Neoverse N1 errata 1542419\");\n+    }\n+    if (FLAG_IS_DEFAULT(UseDeferredICacheInvalidation)) {\n+      FLAG_SET_DEFAULT(UseDeferredICacheInvalidation, true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ICacheInvalidationContext;\n+\n+THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context = nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -29,0 +29,85 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define PD_ICACHE_INVALIDATION_CONTEXT\n+\n+extern THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context;\n+\n+inline void ICacheInvalidationContext::pd_init() {\n+  if (UseDeferredICacheInvalidation && _needs_invalidation) {\n+    current_icache_invalidation_context = this;\n+  }\n+}\n+\n+inline bool ICacheInvalidationContext::deferred_invalidation() {\n+  if (UseDeferredICacheInvalidation && current_icache_invalidation_context != nullptr) {\n+    assert(current_icache_invalidation_context->_needs_invalidation,\n+           \"ICacheInvalidationContext::deferred_invalidation must be invoked \"\n+           \"when icache invalidation is needed\");\n+    return true;\n+  }\n+  return false;\n+}\n+\n+inline void ICacheInvalidationContext::pd_invalidate_icache() {\n+  if (UseDeferredICacheInvalidation && _needs_invalidation) {\n+\n+    \/\/ For deferred icache invalidation, we expect hardware dcache\n+    \/\/ and icache to be coherent: CTR_EL0.IDC == 1 and CTR_EL0.DIC == 1\n+    \/\/ An exception is Neoverse N1 with erratum 1542419, which requires\n+    \/\/ a use of 'IC IVAU' instruction. In such a case, we expect\n+    \/\/ CTR_EL0.DIC == 0.\n+#ifdef ASSERT\n+    static unsigned int cache_info = 0;\n+    if (cache_info == 0) {\n+      asm volatile (\"mrs\\t%0, ctr_el0\":\"=r\" (cache_info));\n+    }\n+    constexpr unsigned int CTR_IDC_SHIFT = 28;\n+    constexpr unsigned int CTR_DIC_SHIFT = 29;\n+    assert(((cache_info >> CTR_IDC_SHIFT) & 0x1) != 0x0, \"Expect CTR_EL0.IDC to be enabled\");\n+    if (NeoverseN1Errata1542419) {\n+      assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) == 0x0, \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum 1542419\");\n+    } else {\n+      assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) != 0x0, \"Expect CTR_EL0.DIC to be enabled\");\n+    }\n+#endif\n+\n+    asm volatile(\"dsb ish\" : : : \"memory\");\n+\n+    if (NeoverseN1Errata1542419) {\n+      \/\/ Errata 1542419: Neoverse N1 cores with the 'COHERENT_ICACHE' feature\n+      \/\/ may fetch stale instructions when software depends on\n+      \/\/ prefetch-speculation-protection instead of explicit synchronization.\n+      \/\/\n+      \/\/ Neoverse-N1 implementation mitigates the errata 1542419 with a\n+      \/\/ workaround:\n+      \/\/ - Disable coherent icache.\n+      \/\/ - Trap IC IVAU instructions.\n+      \/\/ - Execute:\n+      \/\/   - tlbi vae3is, xzr\n+      \/\/   - dsb sy\n+      \/\/ - Ignore trapped IC IVAU instructions.\n+      \/\/\n+      \/\/ `tlbi vae3is, xzr` invalidates all translation entries (all VAs, all\n+      \/\/ possible levels). It waits for all memory accesses using in-scope old\n+      \/\/ translation information to complete before it is considered complete.\n+      \/\/\n+      \/\/ As this workaround has significant overhead, Arm Neoverse N1 (MP050)\n+      \/\/ Software Developer Errata Notice version 29.0 suggests:\n+      \/\/\n+      \/\/ \"Since one TLB inner-shareable invalidation is enough to avoid this\n+      \/\/ erratum, the number of injected TLB invalidations should be minimized\n+      \/\/ in the trap handler to mitigate the performance impact due to this\n+      \/\/ workaround.\"\n+      \/\/ As the address for icache invalidation is not relevant and\n+      \/\/ IC IVAU instruction is ignored, we use XZR in it.\n+      asm volatile(\"ic  ivau, xzr \\n\"\n+                   \"dsb ish       \\n\"\n+                   : : : \"memory\");\n+    }\n+\n+    asm volatile(\"isb\" : : : \"memory\");\n+\n+    current_icache_invalidation_context = nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":85,"deletions":0,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -73,2 +74,2 @@\n-  \/\/ Heal barriers\n-  ZNMethod::nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n@@ -76,3 +77,7 @@\n-  \/\/ Heal oops\n-  ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n-  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+    \/\/ Heal barriers\n+    ZNMethod::nmethod_patch_barriers(nm);\n+\n+    \/\/ Heal oops\n+    ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n+    ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -1437,2 +1438,2 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+        ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n@@ -1440,3 +1441,7 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        \/\/ Heal barriers\n+        ZNMethod::nmethod_patch_barriers(nm);\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -721,2 +722,2 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+         ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n@@ -724,3 +725,7 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+         \/\/ Heal barriers\n+         ZNMethod::nmethod_patch_barriers(nm);\n+\n+         \/\/ Heal oops\n+         ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n+         ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n@@ -756,4 +761,0 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n-\n@@ -770,3 +771,16 @@\n-      if (complete_disarm) {\n-        \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n-        ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+        bool needs_icache_invalidation = ZNMethod::needs_non_immediate_oops_patching(nm);\n+        if (complete_disarm && ZNMethod::needs_barrier_patching(nm)) {\n+          needs_icache_invalidation = true;\n+        }\n+\n+        ICacheInvalidationContext icic(needs_icache_invalidation);\n+\n+        if (complete_disarm) {\n+          \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n+          ZNMethod::nmethod_patch_barriers(nm);\n+        }\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -204,2 +205,6 @@\n-  \/\/ Patch nmethod barriers\n-  nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic(needs_barrier_patching(nm));\n+\n+    \/\/ Patch nmethod barriers\n+    nmethod_patch_barriers(nm);\n+  }\n@@ -369,3 +374,7 @@\n-        \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n-        ZUncoloredRootProcessOopClosure cl(prev_color);\n-        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        {\n+          ICacheInvalidationContext icic(ZNMethod::needs_non_immediate_oops_patching(nm));\n+\n+          \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n+          ZUncoloredRootProcessOopClosure cl(prev_color);\n+          ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        }\n@@ -422,0 +431,12 @@\n+\n+bool ZNMethod::needs_icache_invalidation(nmethod* nm) {\n+  return needs_barrier_patching(nm) || needs_non_immediate_oops_patching(nm);\n+}\n+\n+bool ZNMethod::needs_barrier_patching(nmethod* nm) {\n+  return gc_data(nm)->barriers()->is_nonempty();\n+}\n+\n+bool ZNMethod::needs_non_immediate_oops_patching(nmethod* nm) {\n+  return gc_data(nm)->has_non_immediate_oops();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+\n+  static bool needs_icache_invalidation(nmethod* nm);\n+  static bool needs_barrier_patching(nmethod* nm);\n+  static bool needs_non_immediate_oops_patching(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -83,0 +84,2 @@\n+    ICacheInvalidationContext icic(ZNMethod::needs_non_immediate_oops_patching(nm));\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,0 +74,20 @@\n+class ICacheInvalidationContext : StackObj {\n+ private:\n+  NONCOPYABLE(ICacheInvalidationContext);\n+\n+  bool _needs_invalidation;\n+\n+  void pd_init();\n+  void pd_invalidate_icache();\n+\n+ public:\n+  ICacheInvalidationContext(bool needs_invalidation) : _needs_invalidation(needs_invalidation) {\n+    pd_init();\n+  }\n+\n+  ~ICacheInvalidationContext() {\n+    pd_invalidate_icache();\n+  }\n+\n+  static bool deferred_invalidation();\n+};\n@@ -132,0 +152,9 @@\n+#ifndef PD_ICACHE_INVALIDATION_CONTEXT\n+  \/\/ Default implementation: do nothing\n+  inline void ICacheInvalidationContext::pd_init() {}\n+  inline void ICacheInvalidationContext::pd_invalidate_icache() {}\n+  inline bool ICacheInvalidationContext::deferred_invalidation() {\n+    return false;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,254 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * @test id=ParallelGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ParallelGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Parallel\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=G1GC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for G1GC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.G1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=ShenandoahGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=GenShenGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for generational ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=ZGC\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ZGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires os.family==\"linux\"\n+ * @requires os.arch==\"aarch64\"\n+ * @requires vm.gc.Z\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * Nmethods have GC barriers and OOPs embedded into their code. GCs can patch nmethod's code\n+ * which requires icache invalidation. Doing invalidation per instruction can be expensive.\n+ * CPU can support hardware dcache and icache coherence. This would allow to defer cache\n+ * invalidation.\n+ *\n+ * There are assertions for deferred cache invalidation. This test checks that all of them\n+ * are passed.\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestDeferredICacheInvalidation {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static class A {\n+        public String s1;\n+        public String s2;\n+        public String s3;\n+        public String s4;\n+        public String s5;\n+        public String s6;\n+        public String s7;\n+        public String s8;\n+        public String s9;\n+    }\n+\n+    public static A a = new A();\n+\n+    private static int compLevel;\n+\n+    public static class B {\n+        public static void test0() {\n+        }\n+\n+        public static void test1() {\n+            a.s1 = a.s1 + \"1\";\n+        }\n+\n+        public static void test2() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+        }\n+\n+        public static void test3() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+        }\n+\n+        public static void test4() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+        }\n+\n+        public static void test5() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+        }\n+\n+        public static void test6() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+        }\n+\n+        public static void test7() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+        }\n+\n+        public static void test8() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+        }\n+\n+        public static void test9() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+            a.s9 = a.s9 + \"9\";\n+        }\n+    }\n+\n+    private static void compileMethods() throws Exception {\n+        for (var m : B.class.getDeclaredMethods()) {\n+            if (!m.getName().startsWith(\"test\")) {\n+                continue;\n+            }\n+            m.invoke(null);\n+            WB.markMethodProfiled(m);\n+            WB.enqueueMethodForCompilation(m, compLevel);\n+            while (WB.isMethodQueuedForCompilation(m)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(m) != compLevel) {\n+                throw new IllegalStateException(\"Method \" + m + \" is not compiled at the compilation level: \" + compLevel + \". Got: \" + WB.getMethodCompilationLevel(m));\n+            }\n+        }\n+    }\n+\n+    public static void youngGC() throws Exception {\n+        a = null;\n+        WB.youngGC();\n+    }\n+\n+    public static void fullGC() throws Exception {\n+        a = null;\n+        WB.fullGC();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Boolean.TRUE.equals(WB.getBooleanVMFlag(\"UseDeferredICacheInvalidation\"))) {\n+            System.out.println(\"Skip. Test requires UseDeferredICacheInvalidation enabled.\");\n+        }\n+        compLevel = (args[1].equals(\"C1\")) ? 1 : 4;\n+        compileMethods();\n+        TestDeferredICacheInvalidation.class.getMethod(args[0]).invoke(null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestDeferredICacheInvalidation.java","additions":254,"deletions":0,"binary":false,"changes":254,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.gc;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.bench.util.InMemoryJavaCompiler;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+\n+\/*\n+ * Nmethods have OOPs and GC barriers emmedded into their code.\n+ * GCs patch them which causes invalidation of nmethods' code.\n+ *\n+ * This benchmark can be used to estimate the cost of patching\n+ * OOPs and GC barriers.\n+ *\n+ * We create 5000 nmethods which access fields of a class.\n+ * We measure the time of different GC cycles to see\n+ * the impact of patching nmethods.\n+ *\n+ * The benchmark parameters are method count and accessed field count.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3, jvmArgsAppend = {\n+    \"-XX:+UnlockDiagnosticVMOptions\",\n+    \"-XX:+UnlockExperimentalVMOptions\",\n+    \"-XX:+WhiteBoxAPI\",\n+    \"-Xbootclasspath\/a:lib-test\/wb.jar\",\n+    \"-XX:-UseCodeCacheFlushing\"\n+})\n+public class GCPatchingNmethodCost {\n+\n+    private static final int COMP_LEVEL = 1;\n+    private static final String FIELD_USER = \"FieldUser\";\n+\n+    public static Fields fields;\n+\n+    private static TestMethod[] methods = {};\n+    private static byte[] BYTE_CODE;\n+    private static WhiteBox WB;\n+\n+    @Param({\"5000\"})\n+    public int methodCount;\n+\n+    @Param({\"0\", \"2\", \"4\", \"8\"})\n+    public int accessedFieldCount;\n+\n+    public static class Fields {\n+        public String f1;\n+        public String f2;\n+        public String f3;\n+        public String f4;\n+        public String f5;\n+        public String f6;\n+        public String f7;\n+        public String f8;\n+        public String f9;\n+    }\n+\n+    private static final class TestMethod {\n+        private final Method method;\n+\n+        public TestMethod(Method method) throws Exception {\n+            this.method = method;\n+            WB.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile() throws Exception {\n+            method.invoke(null);\n+            WB.markMethodProfiled(method);\n+        }\n+\n+        public void invoke() throws Exception {\n+            method.invoke(null);\n+        }\n+\n+        public void compile() throws Exception {\n+            WB.enqueueMethodForCompilation(method, COMP_LEVEL);\n+            while (WB.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(method) != COMP_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled at the compilation level: \" + COMP_LEVEL + \". Got: \" + WB.getMethodCompilationLevel(method));\n+            }\n+        }\n+\n+        public NMethod getNMethod() {\n+            return NMethod.get(method, false);\n+        }\n+    }\n+\n+    private static ClassLoader createClassLoader() {\n+        return new ClassLoader() {\n+            @Override\n+            public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                if (!name.equals(FIELD_USER)) {\n+                    return super.loadClass(name);\n+                }\n+\n+                return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+            }\n+        };\n+    }\n+\n+    private static void createTestMethods(int accessedFieldCount, int count) throws Exception {\n+        String javaCode = \"public class \" + FIELD_USER + \" {\";\n+        String field = GCPatchingNmethodCost.class.getName() + \".fields.f\";\n+        javaCode += \"public static void accessFields() {\";\n+        for (int i = 1; i <= accessedFieldCount; i++) {\n+            javaCode += field + i + \"= \" + field + i + \" + \" + i + \";\";\n+        }\n+        javaCode += \"}}\";\n+\n+        BYTE_CODE = InMemoryJavaCompiler.compile(FIELD_USER, javaCode);\n+\n+        fields = new Fields();\n+\n+        methods = new TestMethod[count];\n+        for (int i = 0; i < count; i++) {\n+            var cl = createClassLoader().loadClass(FIELD_USER);\n+            Method method = cl.getMethod(\"accessFields\");\n+            methods[i] = new TestMethod(method);\n+            methods[i].profile();\n+            methods[i].compile();\n+        }\n+    }\n+\n+    private static void initWhiteBox() {\n+        WB = WhiteBox.getWhiteBox();\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupCodeCache() throws Exception {\n+        initWhiteBox();\n+        createTestMethods(accessedFieldCount, methodCount);\n+        Thread.sleep(1000);\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void youngGC() throws Exception {\n+        fields = null;\n+        WB.youngGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void fullGC() throws Exception {\n+        fields = null;\n+        WB.fullGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void systemGC() throws Exception {\n+        fields = null;\n+        System.gc();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/GCPatchingNmethodCost.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}