{"files":[{"patch":"@@ -882,0 +882,10 @@\n+  if (NeoverseN1Errata1542419) {\n+    \/\/ Instruction cache invalidation per barrier is expensive on Neoverse N1 having erratum 1542419.\n+    \/\/ Defer the ICache invalidation to a later point where multiple patches can be handled together.\n+    \/\/\n+    \/\/ Note: We rely on the fact that this function is only called from places where deferred invalidation\n+    \/\/ is safe. This assumption helps to avoid overhead of accessing thread-local data here.\n+    assert(ICacheInvalidationContext::deferred_invalidation(), \"ICache invalidation should be deferred\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(bool, NeoverseN1Errata1542419, false, DIAGNOSTIC,             \\\n+          \"Enable workaround for Neoverse N1 erratum 1542419\")          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+\n+  if (ICacheInvalidationContext::deferred_invalidation()) {\n+    \/\/ Instruction cache invalidation per relocation can be expensive, e.g. on Neoverse N1 having erratum 1542419.\n+    \/\/ Defer the ICache invalidation to a later point where multiple patches can be handled together.\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -66,0 +66,12 @@\n+static bool has_neoverse_n1_errata_1542419() {\n+  const int major_rev_num = VM_Version::cpu_variant();\n+  const int minor_rev_num = VM_Version::cpu_revision();\n+  \/\/ Neoverse N1: 0xd0c\n+  \/\/ Erratum 1542419 affects r3p0, r3p1 and r4p0.\n+  return (VM_Version::cpu_family() == VM_Version::CPU_ARM &&\n+          VM_Version::model_is(0xd0c) &&\n+          ((major_rev_num == 3 && minor_rev_num == 0) ||\n+           (major_rev_num == 3 && minor_rev_num == 1) ||\n+           (major_rev_num == 4 && minor_rev_num == 0)));\n+}\n+\n@@ -644,0 +656,8 @@\n+  if (FLAG_IS_DEFAULT(NeoverseN1Errata1542419) && has_neoverse_n1_errata_1542419()) {\n+    FLAG_SET_DEFAULT(NeoverseN1Errata1542419, true);\n+  }\n+\n+  if (NeoverseN1Errata1542419 && !has_neoverse_n1_errata_1542419()) {\n+    warning(\"NeoverseN1Errata1542419 is set for the CPU not having Neoverse N1 errata 1542419\");\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,29 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class ICacheInvalidationContext;\n+\n+THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context = nullptr;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.cpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"added"},{"patch":"@@ -29,0 +29,65 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define PD_ICACHE_INVALIDATION_CONTEXT\n+\n+extern THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context;\n+\n+inline void ICacheInvalidationContext::pd_init() {\n+  if (NeoverseN1Errata1542419 && _needs_invalidation) {\n+    current_icache_invalidation_context = this;\n+  }\n+}\n+\n+inline bool ICacheInvalidationContext::deferred_invalidation() {\n+  if (NeoverseN1Errata1542419 && current_icache_invalidation_context != nullptr) {\n+    assert(current_icache_invalidation_context->_needs_invalidation, \"ICacheInvalidationContext::deferred_invalidation must be invoked when icache invalidation is needed\");\n+    return true;\n+  }\n+  return false;\n+}\n+\n+inline void ICacheInvalidationContext::pd_invalidate_icache() {\n+  if (NeoverseN1Errata1542419 && _needs_invalidation) {\n+    \/\/ Errata 1542419: Neoverse N1 cores with the 'COHERENT_ICACHE' feature may fetch stale\n+    \/\/ instructions when software depends on prefetch-speculation-protection\n+    \/\/ instead of explicit synchronization.\n+    \/\/\n+    \/\/ Neoverse-N1 implementation mitigates the errata 1542419 with a workaround:\n+    \/\/ - Disable coherent icache.\n+    \/\/ - Trap IC IVAU instructions.\n+    \/\/ - Execute:\n+    \/\/   - tlbi vae3is, xzr\n+    \/\/   - dsb sy\n+    \/\/ - Ignore trapped IC IVAU instructions.\n+    \/\/\n+    \/\/ `tlbi vae3is, xzr` invalidates all translation entries (all VAs, all possible levels).\n+    \/\/ It waits for all memory accesses using in-scope old translation information to complete\n+    \/\/ before it is considered complete.\n+    \/\/\n+    \/\/ As this workaround has significant overhead, Arm Neoverse N1 (MP050) Software Developer\n+    \/\/ Errata Notice version 29.0 suggests:\n+    \/\/\n+    \/\/ \"Since one TLB inner-shareable invalidation is enough to avoid this erratum, the number\n+    \/\/ of injected TLB invalidations should be minimized in the trap handler to mitigate\n+    \/\/ the performance impact due to this workaround.\"\n+#ifdef ASSERT\n+    unsigned int cache_info = 0;\n+    asm volatile (\"mrs\\t%0, ctr_el0\":\"=r\" (cache_info));\n+    constexpr unsigned int CTR_IDC_SHIFT = 28;\n+    constexpr unsigned int CTR_DIC_SHIFT = 29;\n+    assert(((cache_info >> CTR_IDC_SHIFT) & 0x1) != 0x0, \"Expect CTR_EL0.IDC to be enabled\");\n+    assert(((cache_info >> CTR_DIC_SHIFT) & 0x1) == 0x0, \"Expect CTR_EL0.DIC to be disabled\");\n+#endif\n+\n+    \/\/ As the address for icache invalidation is not relevant\n+    \/\/ and IC IVAU instruction is ignored, we use XZR in it.\n+    asm volatile(\"dsb ish       \\n\"\n+                 \"ic  ivau, xzr \\n\"\n+                 \"dsb ish       \\n\"\n+                 \"isb           \\n\"\n+                 : : : \"memory\");\n+\n+    current_icache_invalidation_context = nullptr;\n+  }\n+}\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":65,"deletions":0,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -73,2 +74,2 @@\n-  \/\/ Heal barriers\n-  ZNMethod::nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n@@ -76,3 +77,7 @@\n-  \/\/ Heal oops\n-  ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n-  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+    \/\/ Heal barriers\n+    ZNMethod::nmethod_patch_barriers(nm);\n+\n+    \/\/ Heal oops\n+    ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n+    ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -1437,2 +1438,2 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+        ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n@@ -1440,3 +1441,7 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        \/\/ Heal barriers\n+        ZNMethod::nmethod_patch_barriers(nm);\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -721,2 +722,2 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+         ICacheInvalidationContext icic(ZNMethod::needs_icache_invalidation(nm));\n@@ -724,3 +725,7 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+         \/\/ Heal barriers\n+         ZNMethod::nmethod_patch_barriers(nm);\n+\n+         \/\/ Heal oops\n+         ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n+         ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n@@ -756,4 +761,0 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n-\n@@ -770,3 +771,16 @@\n-      if (complete_disarm) {\n-        \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n-        ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+        bool needs_icache_invalidation = ZNMethod::needs_non_immediate_oops_patching(nm);\n+        if (complete_disarm && ZNMethod::needs_barrier_patching(nm)) {\n+          needs_icache_invalidation = true;\n+        }\n+\n+        ICacheInvalidationContext icic(needs_icache_invalidation);\n+\n+        if (complete_disarm) {\n+          \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n+          ZNMethod::nmethod_patch_barriers(nm);\n+        }\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":26,"deletions":12,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -204,2 +205,6 @@\n-  \/\/ Patch nmethod barriers\n-  nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic(needs_barrier_patching(nm));\n+\n+    \/\/ Patch nmethod barriers\n+    nmethod_patch_barriers(nm);\n+  }\n@@ -369,3 +374,7 @@\n-        \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n-        ZUncoloredRootProcessOopClosure cl(prev_color);\n-        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        {\n+          ICacheInvalidationContext icic(ZNMethod::needs_non_immediate_oops_patching(nm));\n+\n+          \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n+          ZUncoloredRootProcessOopClosure cl(prev_color);\n+          ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        }\n@@ -422,0 +431,12 @@\n+\n+bool ZNMethod::needs_icache_invalidation(nmethod* nm) {\n+  return needs_barrier_patching(nm) || needs_non_immediate_oops_patching(nm);\n+}\n+\n+bool ZNMethod::needs_barrier_patching(nmethod* nm) {\n+  return gc_data(nm)->barriers()->is_nonempty();\n+}\n+\n+bool ZNMethod::needs_non_immediate_oops_patching(nmethod* nm) {\n+  return gc_data(nm)->has_non_immediate_oops();\n+}\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":26,"deletions":5,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -77,0 +77,4 @@\n+\n+  static bool needs_icache_invalidation(nmethod* nm);\n+  static bool needs_barrier_patching(nmethod* nm);\n+  static bool needs_non_immediate_oops_patching(nmethod* nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -83,0 +84,2 @@\n+    ICacheInvalidationContext icic(ZNMethod::needs_non_immediate_oops_patching(nm));\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,0 +74,20 @@\n+class ICacheInvalidationContext : StackObj {\n+ private:\n+  NONCOPYABLE(ICacheInvalidationContext);\n+\n+  bool _needs_invalidation;\n+\n+  void pd_init();\n+  void pd_invalidate_icache();\n+\n+ public:\n+  ICacheInvalidationContext(bool needs_invalidation) : _needs_invalidation(needs_invalidation) {\n+    pd_init();\n+  }\n+\n+  ~ICacheInvalidationContext() {\n+    pd_invalidate_icache();\n+  }\n+\n+  static bool deferred_invalidation();\n+};\n@@ -132,0 +152,9 @@\n+#ifndef PD_ICACHE_INVALIDATION_CONTEXT\n+  \/\/ Default implementation: do nothing\n+  inline void ICacheInvalidationContext::pd_init() {}\n+  inline void ICacheInvalidationContext::pd_invalidate_icache() {}\n+  inline bool ICacheInvalidationContext::deferred_invalidation() {\n+    return false;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":29,"deletions":0,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.gc;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.bench.util.InMemoryJavaCompiler;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+\n+\/*\n+ * Nmethods have OOPs and GC barriers emmedded into their code.\n+ * GCs patch them which causes invalidation of nmethods' code.\n+ *\n+ * This benchmark can be used to estimate the cost of patching\n+ * OOPs and GC barriers.\n+ *\n+ * We create 5000 nmethods which access fields of a class.\n+ * We measure the time of different GC cycles to see\n+ * the impact of patching nmethods.\n+ *\n+ * The benchmark parameters are method count and accessed field count.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3, jvmArgsAppend = {\n+    \"-XX:+UnlockDiagnosticVMOptions\",\n+    \"-XX:+UnlockExperimentalVMOptions\",\n+    \"-XX:+WhiteBoxAPI\",\n+    \"-Xbootclasspath\/a:lib-test\/wb.jar\",\n+    \"-XX:-UseCodeCacheFlushing\"\n+})\n+public class GCPatchingNmethodCost {\n+\n+    private static final int COMP_LEVEL = 1;\n+    private static final String FIELD_USER = \"FieldUser\";\n+\n+    public static Fields fields;\n+\n+    private static TestMethod[] methods = {};\n+    private static byte[] BYTE_CODE;\n+    private static WhiteBox WB;\n+\n+    @Param({\"5000\"})\n+    public int methodCount;\n+\n+    @Param({\"0\", \"2\", \"4\", \"8\"})\n+    public int accessedFieldCount;\n+\n+    public static class Fields {\n+        public String f1;\n+        public String f2;\n+        public String f3;\n+        public String f4;\n+        public String f5;\n+        public String f6;\n+        public String f7;\n+        public String f8;\n+        public String f9;\n+    }\n+\n+    private static final class TestMethod {\n+        private final Method method;\n+\n+        public TestMethod(Method method) throws Exception {\n+            this.method = method;\n+            WB.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile() throws Exception {\n+            method.invoke(null);\n+            WB.markMethodProfiled(method);\n+        }\n+\n+        public void invoke() throws Exception {\n+            method.invoke(null);\n+        }\n+\n+        public void compile() throws Exception {\n+            WB.enqueueMethodForCompilation(method, COMP_LEVEL);\n+            while (WB.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(method) != COMP_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled at the compilation level: \" + COMP_LEVEL + \". Got: \" + WB.getMethodCompilationLevel(method));\n+            }\n+        }\n+\n+        public NMethod getNMethod() {\n+            return NMethod.get(method, false);\n+        }\n+    }\n+\n+    private static ClassLoader createClassLoader() {\n+        return new ClassLoader() {\n+            @Override\n+            public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                if (!name.equals(FIELD_USER)) {\n+                    return super.loadClass(name);\n+                }\n+\n+                return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+            }\n+        };\n+    }\n+\n+    private static void createTestMethods(int accessedFieldCount, int count) throws Exception {\n+        String javaCode = \"public class \" + FIELD_USER + \" {\";\n+        String field = GCPatchingNmethodCost.class.getName() + \".fields.f\";\n+        javaCode += \"public static void accessFields() {\";\n+        for (int i = 1; i <= accessedFieldCount; i++) {\n+            javaCode += field + i + \"= \" + field + i + \" + \" + i + \";\";\n+        }\n+        javaCode += \"}}\";\n+\n+        BYTE_CODE = InMemoryJavaCompiler.compile(FIELD_USER, javaCode);\n+\n+        fields = new Fields();\n+\n+        methods = new TestMethod[count];\n+        for (int i = 0; i < count; i++) {\n+            var cl = createClassLoader().loadClass(FIELD_USER);\n+            Method method = cl.getMethod(\"accessFields\");\n+            methods[i] = new TestMethod(method);\n+            methods[i].profile();\n+            methods[i].compile();\n+        }\n+    }\n+\n+    private static void initWhiteBox() {\n+        WB = WhiteBox.getWhiteBox();\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupCodeCache() throws Exception {\n+        initWhiteBox();\n+        createTestMethods(accessedFieldCount, methodCount);\n+        Thread.sleep(1000);\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void youngGC() throws Exception {\n+        fields = null;\n+        WB.youngGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void fullGC() throws Exception {\n+        fields = null;\n+        WB.fullGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void systemGC() throws Exception {\n+        fields = null;\n+        System.gc();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/GCPatchingNmethodCost.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}