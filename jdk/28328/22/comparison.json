{"files":[{"patch":"@@ -882,0 +882,6 @@\n+  if (UseDeferredICacheInvalidation) {\n+    assert(ICacheInvalidationContext::is_deferring_icache_invalidation(),\n+           \"UseDeferredICacheInvalidation requires ICacheInvalidationContext to defer icache invalidation.\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(bool, NeoverseN1Errata1542419, false, DIAGNOSTIC,             \\\n+          \"Enable workaround for Neoverse N1 erratum 1542419\")          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+\n+  assert(_binding != nullptr, \"expect to be called with RelocIterator in use\");\n+\n+  if (UseDeferredICacheInvalidation) {\n+    return;\n+  }\n+\n@@ -118,1 +125,2 @@\n-void metadata_Relocation::pd_fix_value(address x) {\n+bool metadata_Relocation::pd_fix_value(address x) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -55,0 +55,3 @@\n+bool VM_Version::_cache_dic_enabled;\n+bool VM_Version::_cache_idc_enabled;\n+\n@@ -66,0 +69,13 @@\n+static bool has_neoverse_n1_errata_1542419() {\n+  const int major_rev_num = VM_Version::cpu_variant();\n+  const int minor_rev_num = VM_Version::cpu_revision();\n+  \/\/ Neoverse N1: 0xd0c\n+  \/\/ Erratum 1542419 affects r3p0, r3p1 and r4p0.\n+  \/\/ It is fixed in r4p1 and later revisions, which are not affected.\n+  return (VM_Version::cpu_family() == VM_Version::CPU_ARM &&\n+          VM_Version::model_is(0xd0c) &&\n+          ((major_rev_num == 3 && minor_rev_num == 0) ||\n+           (major_rev_num == 3 && minor_rev_num == 1) ||\n+           (major_rev_num == 4 && minor_rev_num == 0)));\n+}\n+\n@@ -77,0 +93,3 @@\n+  _cache_dic_enabled = false;\n+  _cache_idc_enabled = false;\n+\n@@ -644,0 +663,17 @@\n+  if (FLAG_IS_DEFAULT(UseDeferredICacheInvalidation) && is_cache_idc_enabled() && is_cache_dic_enabled()) {\n+    FLAG_SET_DEFAULT(UseDeferredICacheInvalidation, true);\n+  }\n+\n+  if (FLAG_IS_DEFAULT(NeoverseN1Errata1542419) && has_neoverse_n1_errata_1542419()) {\n+    FLAG_SET_DEFAULT(NeoverseN1Errata1542419, true);\n+  }\n+\n+  if (NeoverseN1Errata1542419) {\n+    if (!has_neoverse_n1_errata_1542419()) {\n+      warning(\"NeoverseN1Errata1542419 is set for the CPU not having Neoverse N1 errata 1542419\");\n+    }\n+    if (FLAG_IS_DEFAULT(UseDeferredICacheInvalidation)) {\n+      FLAG_SET_DEFAULT(UseDeferredICacheInvalidation, true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -56,0 +56,2 @@\n+  static bool _cache_dic_enabled;\n+  static bool _cache_idc_enabled;\n@@ -224,0 +226,3 @@\n+\n+  static bool is_cache_dic_enabled() { return _cache_dic_enabled; }\n+  static bool is_cache_idc_enabled() { return _cache_idc_enabled; }\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-void metadata_Relocation::pd_fix_value(address x) {\n+bool metadata_Relocation::pd_fix_value(address x) {\n@@ -115,0 +115,1 @@\n+    return true;\n@@ -131,0 +132,1 @@\n+  return false;\n","filename":"src\/hotspot\/cpu\/arm\/relocInfo_arm.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,2 @@\n-void metadata_Relocation::pd_fix_value(address x) {\n+bool metadata_Relocation::pd_fix_value(address x) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/ppc\/relocInfo_ppc.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -120,1 +120,2 @@\n-void metadata_Relocation::pd_fix_value(address x) {\n+bool metadata_Relocation::pd_fix_value(address x) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -175,1 +175,2 @@\n-void metadata_Relocation::pd_fix_value(address x) {\n+bool metadata_Relocation::pd_fix_value(address x) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/s390\/relocInfo_s390.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -178,1 +178,2 @@\n-void metadata_Relocation::pd_fix_value(address x) {\n+bool metadata_Relocation::pd_fix_value(address x) {\n+  return false;\n","filename":"src\/hotspot\/cpu\/x86\/relocInfo_x86.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-void metadata_Relocation::pd_fix_value(address x) {\n+bool metadata_Relocation::pd_fix_value(address x) {\n@@ -62,0 +62,1 @@\n+  return false;\n","filename":"src\/hotspot\/cpu\/zero\/relocInfo_zero.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,28 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/icache.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+NOT_PRODUCT(THREAD_LOCAL AArch64ICacheInvalidationContext* AArch64ICacheInvalidationContext::_current_context = nullptr;)\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"added"},{"patch":"@@ -29,0 +29,4 @@\n+#include \"memory\/allocation.hpp\"\n+#include \"runtime\/vm_version.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n@@ -40,1 +44,15 @@\n-    __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+    if (NeoverseN1Errata1542419) {\n+      assert(VM_Version::is_cache_idc_enabled(),\n+             \"Expect CTR_EL0.IDC to be enabled for Neoverse N1 with erratum \"\n+             \"1542419\");\n+      assert(!VM_Version::is_cache_dic_enabled(),\n+             \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum \"\n+             \"1542419\");\n+      asm volatile(\"dsb ish       \\n\"\n+                   \"ic  ivau, xzr \\n\"\n+                   \"dsb ish       \\n\"\n+                   \"isb           \\n\"\n+                   : : : \"memory\");\n+    } else {\n+      __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+    }\n@@ -44,0 +62,87 @@\n+class AArch64ICacheInvalidationContext : StackObj {\n+ private:\n+\n+#ifdef ASSERT\n+  static THREAD_LOCAL AArch64ICacheInvalidationContext* _current_context;\n+#endif\n+\n+  bool _has_modified_code;\n+\n+ public:\n+  NONCOPYABLE(AArch64ICacheInvalidationContext);\n+\n+  AArch64ICacheInvalidationContext()\n+      : _has_modified_code(false) {\n+    assert(_current_context == nullptr, \"nested ICacheInvalidationContext not supported\");\n+#ifdef ASSERT\n+    _current_context = this;\n+#endif\n+  }\n+\n+  ~AArch64ICacheInvalidationContext() {\n+    NOT_PRODUCT(_current_context = nullptr);\n+\n+    if (!_has_modified_code || !UseDeferredICacheInvalidation) {\n+      return;\n+    }\n+\n+    assert(VM_Version::is_cache_idc_enabled(), \"Expect CTR_EL0.IDC to be enabled\");\n+\n+    asm volatile(\"dsb ish\" : : : \"memory\");\n+\n+    if (NeoverseN1Errata1542419) {\n+      assert(!VM_Version::is_cache_dic_enabled(),\n+             \"Expect CTR_EL0.DIC to be disabled for Neoverse N1 with erratum \"\n+             \"1542419\");\n+\n+      \/\/ Errata 1542419: Neoverse N1 cores with the 'COHERENT_ICACHE' feature\n+      \/\/ may fetch stale instructions when software depends on\n+      \/\/ prefetch-speculation-protection instead of explicit synchronization.\n+      \/\/\n+      \/\/ Neoverse-N1 implementation mitigates the errata 1542419 with a\n+      \/\/ workaround:\n+      \/\/ - Disable coherent icache.\n+      \/\/ - Trap IC IVAU instructions.\n+      \/\/ - Execute:\n+      \/\/   - tlbi vae3is, xzr\n+      \/\/   - dsb sy\n+      \/\/ - Ignore trapped IC IVAU instructions.\n+      \/\/\n+      \/\/ `tlbi vae3is, xzr` invalidates all translation entries (all VAs, all\n+      \/\/ possible levels). It waits for all memory accesses using in-scope old\n+      \/\/ translation information to complete before it is considered complete.\n+      \/\/\n+      \/\/ As this workaround has significant overhead, Arm Neoverse N1 (MP050)\n+      \/\/ Software Developer Errata Notice version 29.0 suggests:\n+      \/\/\n+      \/\/ \"Since one TLB inner-shareable invalidation is enough to avoid this\n+      \/\/ erratum, the number of injected TLB invalidations should be minimized\n+      \/\/ in the trap handler to mitigate the performance impact due to this\n+      \/\/ workaround.\"\n+      \/\/ As the address for icache invalidation is not relevant and\n+      \/\/ IC IVAU instruction is ignored, we use XZR in it.\n+      asm volatile(\n+          \"ic  ivau, xzr \\n\"\n+          \"dsb ish       \\n\"\n+          :\n+          :\n+          : \"memory\");\n+    } else {\n+      assert(VM_Version::is_cache_dic_enabled(), \"Expect CTR_EL0.DIC to be enabled\");\n+    }\n+    asm volatile(\"isb\" : : : \"memory\");\n+  }\n+\n+  void set_has_modified_code() {\n+    _has_modified_code = true;\n+  }\n+\n+#ifdef ASSERT\n+  static bool is_deferring_icache_invalidation() {\n+    return _current_context != nullptr && UseDeferredICacheInvalidation;\n+  }\n+#endif\n+};\n+\n+#define PD_ICACHE_INVALIDATION_CONTEXT AArch64ICacheInvalidationContext\n+\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":106,"deletions":1,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -172,0 +172,2 @@\n+  _cache_idc_enabled = ((ctr_el0 >> 28) & 0x1) != 0;\n+  _cache_dic_enabled = ((ctr_el0 >> 29) & 0x1) != 0;\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/vm_version_linux_aarch64.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -748,3 +748,0 @@\n-\n-  \/\/ Flush generated code\n-  ICache::invalidate_range(dest_blob->code_begin(), dest_blob->code_size());\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -334,0 +334,5 @@\n+  if (code_size() == 0) {\n+    \/\/ Nothing to copy\n+    return;\n+  }\n+\n@@ -335,0 +340,1 @@\n+  ICache::invalidate_range(code_begin(), code_size());\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1332,0 +1332,1 @@\n+    ICache::invalidate_range(code_begin(), code_size());\n@@ -1816,0 +1817,1 @@\n+    ICache::invalidate_range(code_begin(), code_size());\n@@ -2043,1 +2045,1 @@\n-  fix_oop_relocations(nullptr, nullptr, \/*initialize_immediates=*\/ true);\n+  fix_all_oop_relocations();\n@@ -2055,1 +2057,1 @@\n-void nmethod::fix_oop_relocations(address begin, address end, bool initialize_immediates) {\n+void nmethod::fix_all_oop_relocations() {\n@@ -2057,1 +2059,1 @@\n-  RelocIterator iter(this, begin, end);\n+  RelocIterator iter(this);\n@@ -2059,0 +2061,1 @@\n+    bool modified_code = false;\n@@ -2061,1 +2064,1 @@\n-      if (initialize_immediates && reloc->oop_is_immediate()) {\n+      if (reloc->oop_is_immediate()) {\n@@ -2065,0 +2068,3 @@\n+      } else {\n+        \/\/ get the oop from the pool, and re-insert it into the instruction\n+        reloc->set_value(reloc->value());\n@@ -2066,2 +2072,0 @@\n-      \/\/ Refresh the oop-related bits of this instruction.\n-      reloc->fix_oop_relocation();\n@@ -2075,0 +2079,31 @@\n+void nmethod::fix_non_immediate_oop_relocations() {\n+  ICacheInvalidationContext icic;\n+  fix_non_immediate_oop_relocations(&icic);\n+}\n+\n+void nmethod::fix_non_immediate_oop_relocations(ICacheInvalidationContext* icic) {\n+  \/\/ re-patch all oop-bearing instructions, just in case some oops moved\n+  RelocIterator iter(this);\n+  bool modified_code = false;\n+  while (iter.next()) {\n+    bool modified_inst = false;\n+    if (iter.type() == relocInfo::oop_type) {\n+      oop_Relocation* reloc = iter.oop_reloc();\n+      if (!reloc->oop_is_immediate()) {\n+        \/\/ get the oop from the pool, and re-insert it into the instruction\n+        reloc->set_value(reloc->value());\n+        modified_inst = true;\n+      }\n+    } else if (iter.type() == relocInfo::metadata_type) {\n+      metadata_Relocation* reloc = iter.metadata_reloc();\n+      modified_inst = reloc->fix_metadata_relocation();\n+    }\n+    if (modified_inst) {\n+      modified_code = true;\n+    }\n+  }\n+  if (modified_code) {\n+    icic->set_has_modified_code();\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":41,"deletions":6,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+class ICacheInvalidationContext;\n@@ -805,1 +806,0 @@\n-  void fix_oop_relocations(address begin, address end, bool initialize_immediates);\n@@ -812,2 +812,3 @@\n-  void fix_oop_relocations(address begin, address end) { fix_oop_relocations(begin, end, false); }\n-  void fix_oop_relocations()                           { fix_oop_relocations(nullptr, nullptr, false); }\n+  void fix_non_immediate_oop_relocations();\n+  void fix_non_immediate_oop_relocations(ICacheInvalidationContext* icic);\n+  void fix_all_oop_relocations();\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -593,9 +593,0 @@\n-\n-void oop_Relocation::fix_oop_relocation() {\n-  if (!oop_is_immediate()) {\n-    \/\/ get the oop from the pool, and re-insert it into the instruction:\n-    set_value(value());\n-  }\n-}\n-\n-\n@@ -630,1 +621,1 @@\n-void metadata_Relocation::fix_metadata_relocation() {\n+bool metadata_Relocation::fix_metadata_relocation() {\n@@ -633,1 +624,1 @@\n-    pd_fix_value(value());\n+    return pd_fix_value(value());\n@@ -635,0 +626,1 @@\n+  return false;\n","filename":"src\/hotspot\/share\/code\/relocInfo.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -991,2 +991,0 @@\n-  void fix_oop_relocation();        \/\/ reasserts oop value\n-\n@@ -1034,1 +1032,2 @@\n-  void pd_fix_value(address x);\n+  \/\/ Returns true if code was modified.\n+  bool pd_fix_value(address x);\n@@ -1043,1 +1042,1 @@\n-  void fix_metadata_relocation();        \/\/ reasserts metadata value\n+  bool fix_metadata_relocation();        \/\/ reasserts metadata value\n","filename":"src\/hotspot\/share\/code\/relocInfo.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  nm->fix_oop_relocations();\n+  nm->fix_non_immediate_oop_relocations();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NMethodClosure.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    _nm->fix_oop_relocations();\n+    _nm->fix_non_immediate_oop_relocations();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -73,2 +74,4 @@\n-  \/\/ Heal barriers\n-  ZNMethod::nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic;\n+    \/\/ Heal barriers\n+    ZNMethod::nmethod_patch_barriers(nm, &icic);\n@@ -76,3 +79,4 @@\n-  \/\/ Heal oops\n-  ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n-  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+    \/\/ Heal oops\n+    ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n+    ZNMethod::nmethod_oops_do_inner(nm, &cl, &icic);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -1438,6 +1439,9 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n-\n-      \/\/ Heal oops\n-      ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      {\n+        ICacheInvalidationContext icic;\n+        \/\/ Heal barriers\n+        ZNMethod::nmethod_patch_barriers(nm, &icic);\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl, &icic);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -721,6 +722,9 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n-\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      {\n+         ICacheInvalidationContext icic;\n+         \/\/ Heal barriers\n+         ZNMethod::nmethod_patch_barriers(nm, &icic);\n+\n+         \/\/ Heal oops\n+         ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n+         ZNMethod::nmethod_oops_do_inner(nm, &cl, &icic);\n+      }\n@@ -756,4 +760,0 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n-\n@@ -770,3 +770,10 @@\n-      if (complete_disarm) {\n-        \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n-        ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+        ICacheInvalidationContext icic;\n+        if (complete_disarm) {\n+          \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n+          ZNMethod::nmethod_patch_barriers(nm, &icic);\n+        }\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl, &icic);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":20,"deletions":13,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -248,0 +249,5 @@\n+  ICacheInvalidationContext icic;\n+  nmethod_patch_barriers(nm, &icic);\n+}\n+\n+void ZNMethod::nmethod_patch_barriers(nmethod* nm, ICacheInvalidationContext* icic) {\n@@ -250,0 +256,3 @@\n+  if (gc_data(nm)->barriers()->is_nonempty()) {\n+    icic->set_has_modified_code();\n+  }\n@@ -261,0 +270,5 @@\n+  ICacheInvalidationContext icic;\n+  nmethod_oops_do_inner(nm, cl, &icic);\n+}\n+\n+void ZNMethod::nmethod_oops_do_inner(nmethod* nm, OopClosure* cl, ICacheInvalidationContext* icic) {\n@@ -286,1 +300,1 @@\n-    nm->fix_oop_relocations();\n+    nm->fix_non_immediate_oop_relocations(icic);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":15,"deletions":1,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+  static void nmethod_patch_barriers(nmethod* nm, ICacheInvalidationContext* icic);\n@@ -62,0 +63,1 @@\n+  static void nmethod_oops_do_inner(nmethod* nm, OopClosure* cl, ICacheInvalidationContext* icic);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    nm->fix_oop_relocations();\n+    nm->fix_non_immediate_oop_relocations();\n","filename":"src\/hotspot\/share\/memory\/iterator.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2008,0 +2008,2 @@\n+  product(bool, UseDeferredICacheInvalidation, false, DIAGNOSTIC,           \\\n+          \"Defer multiple ICache invalidation to single invalidation\")      \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,1 +74,0 @@\n-\n@@ -132,0 +131,29 @@\n+class DefaultICacheInvalidationContext : StackObj {\n+ public:\n+  NONCOPYABLE(DefaultICacheInvalidationContext);\n+\n+  DefaultICacheInvalidationContext() {}\n+\n+  ~DefaultICacheInvalidationContext() {}\n+\n+  void set_has_modified_code() {}\n+\n+#ifdef ASSERT\n+  static bool is_deferring_icache_invalidation() {\n+    return false;\n+  }\n+#endif\n+};\n+\n+#ifndef PD_ICACHE_INVALIDATION_CONTEXT\n+#define PD_ICACHE_INVALIDATION_CONTEXT DefaultICacheInvalidationContext\n+#endif \/\/ PD_ICACHE_INVALIDATION_CONTEXT\n+\n+class ICacheInvalidationContext final : public PD_ICACHE_INVALIDATION_CONTEXT {\n+ private:\n+  NONCOPYABLE(ICacheInvalidationContext);\n+\n+ public:\n+  using PD_ICACHE_INVALIDATION_CONTEXT::PD_ICACHE_INVALIDATION_CONTEXT;\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":29,"deletions":1,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package gc;\n+\n+\/*\n+ * @test id=parallel\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ParallelGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Parallel\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseParallelGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=g1\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for G1GC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.G1\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseG1GC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=shenandoah\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=genshen\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for generational ShenandoahGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Shenandoah\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseShenandoahGC -XX:+UnlockExperimentalVMOptions -XX:ShenandoahGCMode=generational -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * @test id=z\n+ * @bug 8370947\n+ * @summary Check no assertion is triggered when UseDeferredICacheInvalidation is enabled for ZGC\n+ * @library \/test\/lib\n+ * @requires vm.debug\n+ * @requires vm.gc.Z\n+ * @build jdk.test.whitebox.WhiteBox\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller jdk.test.whitebox.WhiteBox\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C1\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation youngGC C2\n+ * @run main\/othervm -Xbootclasspath\/a:. -XX:+UnlockDiagnosticVMOptions -XX:+WhiteBoxAPI -XX:+UseZGC -XX:-UseCodeCacheFlushing gc.TestDeferredICacheInvalidation fullGC C2\n+ *\/\n+\n+\/*\n+ * Nmethods have GC barriers and OOPs embedded into their code. GCs can patch nmethod's code\n+ * which requires icache invalidation. Doing invalidation per instruction can be expensive.\n+ * CPU can support hardware dcache and icache coherence. This would allow to defer cache\n+ * invalidation.\n+ *\n+ * There are assertions for deferred cache invalidation. This test checks that all of them\n+ * are passed.\n+ *\/\n+\n+import jdk.test.whitebox.WhiteBox;\n+\n+public class TestDeferredICacheInvalidation {\n+\n+    private static final WhiteBox WB = WhiteBox.getWhiteBox();\n+\n+    public static class A {\n+        public String s1;\n+        public String s2;\n+        public String s3;\n+        public String s4;\n+        public String s5;\n+        public String s6;\n+        public String s7;\n+        public String s8;\n+        public String s9;\n+    }\n+\n+    public static A a = new A();\n+\n+    private static int compLevel;\n+\n+    public static class B {\n+        public static void test0() {\n+        }\n+\n+        public static void test1() {\n+            a.s1 = a.s1 + \"1\";\n+        }\n+\n+        public static void test2() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+        }\n+\n+        public static void test3() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+        }\n+\n+        public static void test4() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+        }\n+\n+        public static void test5() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+        }\n+\n+        public static void test6() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+        }\n+\n+        public static void test7() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+        }\n+\n+        public static void test8() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+        }\n+\n+        public static void test9() {\n+            a.s1 = a.s1 + \"1\";\n+            a.s2 = a.s2 + \"2\";\n+            a.s3 = a.s3 + \"3\";\n+            a.s4 = a.s4 + \"4\";\n+            a.s5 = a.s5 + \"5\";\n+            a.s6 = a.s6 + \"6\";\n+            a.s7 = a.s7 + \"7\";\n+            a.s8 = a.s8 + \"8\";\n+            a.s9 = a.s9 + \"9\";\n+        }\n+    }\n+\n+    private static void compileMethods() throws Exception {\n+        for (var m : B.class.getDeclaredMethods()) {\n+            if (!m.getName().startsWith(\"test\")) {\n+                continue;\n+            }\n+            m.invoke(null);\n+            WB.markMethodProfiled(m);\n+            WB.enqueueMethodForCompilation(m, compLevel);\n+            while (WB.isMethodQueuedForCompilation(m)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(m) != compLevel) {\n+                throw new IllegalStateException(\"Method \" + m + \" is not compiled at the compilation level: \" + compLevel + \". Got: \" + WB.getMethodCompilationLevel(m));\n+            }\n+        }\n+    }\n+\n+    public static void youngGC() throws Exception {\n+        a = null;\n+        WB.youngGC();\n+    }\n+\n+    public static void fullGC() throws Exception {\n+        a = null;\n+        WB.fullGC();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        if (!Boolean.TRUE.equals(WB.getBooleanVMFlag(\"UseDeferredICacheInvalidation\"))) {\n+            System.out.println(\"Skip. Test requires UseDeferredICacheInvalidation enabled.\");\n+        }\n+        compLevel = (args[1].equals(\"C1\")) ? 1 : 4;\n+        compileMethods();\n+        TestDeferredICacheInvalidation.class.getMethod(args[0]).invoke(null);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/gc\/TestDeferredICacheInvalidation.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.gc;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.bench.util.InMemoryJavaCompiler;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+\n+\/*\n+ * Nmethods have OOPs and GC barriers emmedded into their code.\n+ * GCs patch them which causes invalidation of nmethods' code.\n+ *\n+ * This benchmark can be used to estimate the cost of patching\n+ * OOPs and GC barriers.\n+ *\n+ * We create 5000 nmethods which access fields of a class.\n+ * We measure the time of different GC cycles to see\n+ * the impact of patching nmethods.\n+ *\n+ * The benchmark parameters are method count and accessed field count.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3, jvmArgsAppend = {\n+    \"-XX:+UnlockDiagnosticVMOptions\",\n+    \"-XX:+UnlockExperimentalVMOptions\",\n+    \"-XX:+WhiteBoxAPI\",\n+    \"-Xbootclasspath\/a:lib-test\/wb.jar\",\n+    \"-XX:-UseCodeCacheFlushing\"\n+})\n+public class GCPatchingNmethodCost {\n+\n+    private static final int COMP_LEVEL = 1;\n+    private static final String FIELD_USER = \"FieldUser\";\n+\n+    public static Fields fields;\n+\n+    private static TestMethod[] methods = {};\n+    private static byte[] BYTE_CODE;\n+    private static WhiteBox WB;\n+\n+    @Param({\"5000\"})\n+    public int methodCount;\n+\n+    @Param({\"0\", \"2\", \"4\", \"8\"})\n+    public int accessedFieldCount;\n+\n+    public static class Fields {\n+        public String f1;\n+        public String f2;\n+        public String f3;\n+        public String f4;\n+        public String f5;\n+        public String f6;\n+        public String f7;\n+        public String f8;\n+        public String f9;\n+    }\n+\n+    private static final class TestMethod {\n+        private final Method method;\n+\n+        public TestMethod(Method method) throws Exception {\n+            this.method = method;\n+            WB.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile() throws Exception {\n+            method.invoke(null);\n+            WB.markMethodProfiled(method);\n+        }\n+\n+        public void invoke() throws Exception {\n+            method.invoke(null);\n+        }\n+\n+        public void compile() throws Exception {\n+            WB.enqueueMethodForCompilation(method, COMP_LEVEL);\n+            while (WB.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(method) != COMP_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled at the compilation level: \" + COMP_LEVEL + \". Got: \" + WB.getMethodCompilationLevel(method));\n+            }\n+        }\n+\n+        public NMethod getNMethod() {\n+            return NMethod.get(method, false);\n+        }\n+    }\n+\n+    private static ClassLoader createClassLoader() {\n+        return new ClassLoader() {\n+            @Override\n+            public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                if (!name.equals(FIELD_USER)) {\n+                    return super.loadClass(name);\n+                }\n+\n+                return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+            }\n+        };\n+    }\n+\n+    private static void createTestMethods(int accessedFieldCount, int count) throws Exception {\n+        String javaCode = \"public class \" + FIELD_USER + \" {\";\n+        String field = GCPatchingNmethodCost.class.getName() + \".fields.f\";\n+        javaCode += \"public static void accessFields() {\";\n+        for (int i = 1; i <= accessedFieldCount; i++) {\n+            javaCode += field + i + \"= \" + field + i + \" + \" + i + \";\";\n+        }\n+        javaCode += \"}}\";\n+\n+        BYTE_CODE = InMemoryJavaCompiler.compile(FIELD_USER, javaCode);\n+\n+        fields = new Fields();\n+\n+        methods = new TestMethod[count];\n+        for (int i = 0; i < count; i++) {\n+            var cl = createClassLoader().loadClass(FIELD_USER);\n+            Method method = cl.getMethod(\"accessFields\");\n+            methods[i] = new TestMethod(method);\n+            methods[i].profile();\n+            methods[i].compile();\n+        }\n+    }\n+\n+    private static void initWhiteBox() {\n+        WB = WhiteBox.getWhiteBox();\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupCodeCache() throws Exception {\n+        initWhiteBox();\n+        createTestMethods(accessedFieldCount, methodCount);\n+        Thread.sleep(1000);\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void youngGC() throws Exception {\n+        fields = null;\n+        WB.youngGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void fullGC() throws Exception {\n+        fields = null;\n+        WB.fullGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void systemGC() throws Exception {\n+        fields = null;\n+        System.gc();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/GCPatchingNmethodCost.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}