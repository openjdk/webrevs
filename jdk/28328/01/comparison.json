{"files":[{"patch":"@@ -882,0 +882,10 @@\n+  if (NeoverseN1Errata1542419) {\n+    \/\/ Instruction cache invalidation per barrier is expensive on Neoverse N1 having erratum 1542419.\n+    \/\/ Defer the ICache invalidation to a later point where multiple patches can be handled together.\n+    \/\/\n+    \/\/ Note: We rely on the fact that this function is only called from places where deferred invalidation\n+    \/\/ is safe. This assumption helps to avoid overhead of accessing thread-local data here.\n+    assert(ICacheInvalidationContext::deferred_invalidation(), \"ICache invalidation should be deferred\");\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -130,0 +130,2 @@\n+  product(bool, NeoverseN1Errata1542419, false, DIAGNOSTIC,             \\\n+          \"Enable workaround for Neoverse N1 erratum 1542419\")          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/globals_aarch64.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,0 +31,43 @@\n+#include \"code\/nmethod.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+#define PD_ICACHE_INVALIDATION_CONTEXT\n+\n+inline void ICacheInvalidationContext::pd_init(nmethod* nm) {\n+  if (NeoverseN1Errata1542419) {\n+    _nm = nm;\n+    _deferred_icache_invalidation = (_nm != nullptr);\n+  }\n+}\n+\n+inline void ICacheInvalidationContext::pd_invalidate_icache() {\n+  if (_nm != nullptr) {\n+    assert(NeoverseN1Errata1542419, \"Should only be set for Neoverse N1 erratum\");\n+    \/\/ Neoverse-N1 implementation mitigates erratum 1542419 with a workaround:\n+    \/\/ - Disable coherent icache.\n+    \/\/ - Trap IC IVAU instructions.\n+    \/\/ - Execute:\n+    \/\/   - tlbi vae3is, xzr\n+    \/\/   - dsb sy\n+    \/\/\n+    \/\/ `tlbi vae3is, xzr` invalidates translations for all address spaces (global for address).\n+    \/\/  It waits for all memory accesses using in-scope old translation information to complete\n+    \/\/  before it is considered complete.\n+    \/\/\n+    \/\/ As this workaround has significant overhead, Arm Neoverse N1 (MP050) Software Developer\n+    \/\/ Errata Notice version 29.0 suggests:\n+    \/\/\n+    \/\/ \"Since one TLB inner-shareable invalidation is enough to avoid this erratum, the number\n+    \/\/ of injected TLB invalidations should be minimized in the trap handler to mitigate\n+    \/\/ the performance impact due to this workaround.\"\n+    \/\/\n+    \/\/ As the address for icache invalidation is not relevant, we use the nmethod's code start address.\n+    ICache::invalidate_word(_nm->code_begin());\n+    _deferred_icache_invalidation = false;\n+  }\n+}\n+\n+inline bool ICacheInvalidationContext::deferred_invalidation() {\n+  return _deferred_icache_invalidation;\n+}\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/icache_aarch64.hpp","additions":43,"deletions":0,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -57,0 +57,7 @@\n+\n+  if (ICacheInvalidationContext::deferred_invalidation()) {\n+    \/\/ Instruction cache invalidation per relocation can be expensive, e.g. on Neoverse N1 having erratum 1542419.\n+    \/\/ Defer the ICache invalidation to a later point where multiple patches can be handled together.\n+    return;\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -644,0 +644,11 @@\n+  \/\/ Neoverse N1: 0xd0c\n+  if (_cpu == CPU_ARM && model_is(0xd0c) && FLAG_IS_DEFAULT(NeoverseN1Errata1542419)) {\n+    const int major_rev_num = cpu_variant();\n+    const int minor_rev_num = cpu_revision();\n+    if (!(major_rev_num >= 4 && minor_rev_num >= 1)) {\n+      \/\/ As Neoverse N1 r4p1 and later are not affected by the erratum,\n+      \/\/ enable the workaround by default for earlier revisions.\n+      FLAG_SET_DEFAULT(NeoverseN1Errata1542419, true);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -73,2 +74,2 @@\n-  \/\/ Heal barriers\n-  ZNMethod::nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic(nm);\n@@ -76,3 +77,7 @@\n-  \/\/ Heal oops\n-  ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n-  ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+    \/\/ Heal barriers\n+    ZNMethod::nmethod_patch_barriers(nm);\n+\n+    \/\/ Heal oops\n+    ZUncoloredRootProcessWeakOopClosure cl(ZNMethod::color(nm));\n+    ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+  }\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -1437,6 +1438,9 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n-\n-      \/\/ Heal oops\n-      ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      {\n+        ICacheInvalidationContext icic(nm);\n+        \/\/ Heal barriers\n+        ZNMethod::nmethod_patch_barriers(nm);\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootProcessOopClosure cl(ZNMethod::color(nm));\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -63,0 +63,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -721,6 +722,9 @@\n-      \/\/ Heal barriers\n-      ZNMethod::nmethod_patch_barriers(nm);\n-\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      {\n+         ICacheInvalidationContext icic(nm);\n+         \/\/ Heal barriers\n+         ZNMethod::nmethod_patch_barriers(nm);\n+\n+         \/\/ Heal oops\n+         ZUncoloredRootMarkOopClosure cl(ZNMethod::color(nm));\n+         ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+      }\n@@ -756,4 +760,0 @@\n-      \/\/ Heal oops\n-      ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n-      ZNMethod::nmethod_oops_do_inner(nm, &cl);\n-\n@@ -770,3 +770,11 @@\n-      if (complete_disarm) {\n-        \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n-        ZNMethod::nmethod_patch_barriers(nm);\n+      {\n+        ICacheInvalidationContext icic(nm);\n+\n+        if (complete_disarm) {\n+          \/\/ We are about to completely disarm the nmethod, must take responsibility to patch all barriers before disarming\n+          ZNMethod::nmethod_patch_barriers(nm);\n+        }\n+\n+        \/\/ Heal oops\n+        ZUncoloredRootMarkYoungOopClosure cl(prev_color);\n+        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -204,2 +205,6 @@\n-  \/\/ Patch nmethod barriers\n-  nmethod_patch_barriers(nm);\n+  {\n+    ICacheInvalidationContext icic(nm);\n+\n+    \/\/ Patch nmethod barriers\n+    nmethod_patch_barriers(nm);\n+  }\n@@ -369,3 +374,6 @@\n-        \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n-        ZUncoloredRootProcessOopClosure cl(prev_color);\n-        ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        {\n+          ICacheInvalidationContext icic(nm);\n+          \/\/ Heal oops and potentially mark young objects if there is a concurrent young collection.\n+          ZUncoloredRootProcessOopClosure cl(prev_color);\n+          ZNMethod::nmethod_oops_do_inner(nm, &cl);\n+        }\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -84,0 +85,1 @@\n+    ICacheInvalidationContext icic(nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zUnload.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -128,0 +128,2 @@\n+\n+THREAD_LOCAL bool ICacheInvalidationContext::_deferred_icache_invalidation = false;\n","filename":"src\/hotspot\/share\/runtime\/icache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -74,0 +74,24 @@\n+class nmethod;\n+\n+class ICacheInvalidationContext : StackObj {\n+  NONCOPYABLE(ICacheInvalidationContext);\n+\n+private:\n+  static THREAD_LOCAL bool _deferred_icache_invalidation;\n+\n+  nmethod* _nm;\n+\n+  void pd_init(nmethod* nm);\n+  void pd_invalidate_icache();\n+\n+public:\n+  ICacheInvalidationContext(nmethod* nm) : _nm(nullptr) {\n+    pd_init(nm);\n+  }\n+\n+  ~ICacheInvalidationContext() {\n+    pd_invalidate_icache();\n+  }\n+\n+  static bool deferred_invalidation();\n+};\n@@ -132,0 +156,9 @@\n+#ifndef PD_ICACHE_INVALIDATION_CONTEXT\n+  \/\/ Default implementation: do nothing\n+  inline void ICacheInvalidationContext::pd_init(nmethod*) {}\n+  inline void ICacheInvalidationContext::pd_invalidate_icache() {}\n+  inline bool ICacheInvalidationContext::deferred_invalidation() {\n+    return false;\n+  }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":33,"deletions":0,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.vm.gc;\n+\n+import java.lang.reflect.Method;\n+import java.util.*;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.CompilerControl;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Level;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import org.openjdk.bench.util.InMemoryJavaCompiler;\n+\n+import jdk.test.whitebox.WhiteBox;\n+import jdk.test.whitebox.code.NMethod;\n+\n+\/*\n+ * Nmethods have OOPs and GC barriers emmedded into their code.\n+ * GCs patch them which causes invalidation of nmethods' code.\n+ *\n+ * This benchmark can be used to estimate the cost of patching\n+ * OOPs and GC barriers.\n+ *\n+ * We create 5000 nmethods which access fields of a class.\n+ * We measure the time of different GC cycles to see\n+ * the impact of patching nmethods.\n+ *\n+ * The benchmark parameters are method count and accessed field count.\n+ *\/\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.MILLISECONDS)\n+@State(Scope.Benchmark)\n+@Fork(value = 3, jvmArgsAppend = {\n+    \"-XX:+UnlockDiagnosticVMOptions\",\n+    \"-XX:+UnlockExperimentalVMOptions\",\n+    \"-XX:+WhiteBoxAPI\",\n+    \"-Xbootclasspath\/a:lib-test\/wb.jar\",\n+    \"-XX:-UseCodeCacheFlushing\"\n+})\n+public class GCPatchingNmethodCost {\n+\n+    private static final int COMP_LEVEL = 1;\n+    private static final String FIELD_USER = \"FieldUser\";\n+\n+    public static Fields fields;\n+\n+    private static TestMethod[] methods = {};\n+    private static byte[] BYTE_CODE;\n+    private static WhiteBox WB;\n+\n+    @Param({\"5000\"})\n+    public int methodCount;\n+\n+    @Param({\"0\", \"2\", \"4\", \"8\"})\n+    public int accessedFieldCount;\n+\n+    public static class Fields {\n+        public String f1;\n+        public String f2;\n+        public String f3;\n+        public String f4;\n+        public String f5;\n+        public String f6;\n+        public String f7;\n+        public String f8;\n+        public String f9;\n+    }\n+\n+    private static final class TestMethod {\n+        private final Method method;\n+\n+        public TestMethod(Method method) throws Exception {\n+            this.method = method;\n+            WB.testSetDontInlineMethod(method, true);\n+        }\n+\n+        public void profile() throws Exception {\n+            method.invoke(null);\n+            WB.markMethodProfiled(method);\n+        }\n+\n+        public void invoke() throws Exception {\n+            method.invoke(null);\n+        }\n+\n+        public void compile() throws Exception {\n+            WB.enqueueMethodForCompilation(method, COMP_LEVEL);\n+            while (WB.isMethodQueuedForCompilation(method)) {\n+                Thread.onSpinWait();\n+            }\n+            if (WB.getMethodCompilationLevel(method) != COMP_LEVEL) {\n+                throw new IllegalStateException(\"Method \" + method + \" is not compiled at the compilation level: \" + COMP_LEVEL + \". Got: \" + WB.getMethodCompilationLevel(method));\n+            }\n+        }\n+\n+        public NMethod getNMethod() {\n+            return NMethod.get(method, false);\n+        }\n+    }\n+\n+    private static ClassLoader createClassLoader() {\n+        return new ClassLoader() {\n+            @Override\n+            public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                if (!name.equals(FIELD_USER)) {\n+                    return super.loadClass(name);\n+                }\n+\n+                return defineClass(name, BYTE_CODE, 0, BYTE_CODE.length);\n+            }\n+        };\n+    }\n+\n+    private static void createTestMethods(int accessedFieldCount, int count) throws Exception {\n+        String javaCode = \"public class \" + FIELD_USER + \" {\";\n+        String field = GCPatchingNmethodCost.class.getName() + \".fields.f\";\n+        javaCode += \"public static void accessFields() {\";\n+        for (int i = 1; i <= accessedFieldCount; i++) {\n+            javaCode += field + i + \"= \" + field + i + \" + \" + i + \";\";\n+        }\n+        javaCode += \"}}\";\n+\n+        BYTE_CODE = InMemoryJavaCompiler.compile(FIELD_USER, javaCode);\n+\n+        fields = new Fields();\n+\n+        methods = new TestMethod[count];\n+        for (int i = 0; i < count; i++) {\n+            var cl = createClassLoader().loadClass(FIELD_USER);\n+            Method method = cl.getMethod(\"accessFields\");\n+            methods[i] = new TestMethod(method);\n+            methods[i].profile();\n+            methods[i].compile();\n+        }\n+    }\n+\n+    private static void initWhiteBox() {\n+        WB = WhiteBox.getWhiteBox();\n+    }\n+\n+    @Setup(Level.Trial)\n+    public void setupCodeCache() throws Exception {\n+        initWhiteBox();\n+        createTestMethods(accessedFieldCount, methodCount);\n+        Thread.sleep(1000);\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void youngGC() throws Exception {\n+        fields = null;\n+        WB.youngGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void fullGC() throws Exception {\n+        fields = null;\n+        WB.fullGC();\n+    }\n+\n+    @Benchmark\n+    @Warmup(iterations = 0)\n+    @Measurement(iterations = 1)\n+    public void systemGC() throws Exception {\n+        fields = null;\n+        System.gc();\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/gc\/GCPatchingNmethodCost.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"}]}