{"files":[{"patch":"@@ -887,1 +887,4 @@\n-    assert(ICacheInvalidationContext::deferred_invalidation(), \"ICache invalidation should be deferred\");\n+    assert(ICacheInvalidationContext::current() != nullptr, \"ICache invalidation context should be set\");\n+    assert(ICacheInvalidationContext::current()->mode() == ICacheInvalidation::DEFERRED ||\n+           ICacheInvalidationContext::current()->mode() == ICacheInvalidation::NOT_NEEDED,\n+           \"ICache invalidation should be deferred or unneeded\");\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/zBarrierSetAssembler_aarch64.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -58,2 +59,1 @@\n-  if (ICacheInvalidationContext::deferred_invalidation()) {\n-    \/\/ Instruction cache invalidation per relocation can be expensive, e.g. on Neoverse N1 having erratum 1542419.\n+  if (UseDeferredICacheInvalidation) {\n@@ -61,0 +61,21 @@\n+    \/\/\n+    \/\/ Note: We rely on the fact that this function is only called from places where deferred invalidation\n+    \/\/ is safe. This assumption helps to avoid overhead of accessing thread-local data here.\n+    assert(ICacheInvalidationContext::current() != nullptr, \"ICache invalidation context should be set\");\n+    assert(ICacheInvalidationContext::current()->mode() == ICacheInvalidation::DEFERRED ||\n+           ICacheInvalidationContext::current()->mode() == ICacheInvalidation::NOT_NEEDED,\n+           \"ICache invalidation should be deferred or unneeded\");\n+#ifdef ASSERT\n+    if (_binding != nullptr && _binding->code() != nullptr) {\n+      nmethod *nm = _binding->code();\n+      if (!(BarrierSet::barrier_set()->barrier_set_nmethod()->is_armed(nm) ||\n+            SafepointSynchronize::is_at_safepoint() ||\n+            nm->is_unloading())) {\n+        ConditionalMutexLocker ml(NMethodState_lock, !NMethodState_lock->owned_by_self(), Mutex::_no_safepoint_check_flag);\n+        assert(nm->is_not_installed(),\n+             \"ICache invalidation context should only be used for armed \"\n+             \"or unloading or not installed nmethod or at safepoint\");\n+\n+      }\n+    }\n+#endif\n","filename":"src\/hotspot\/cpu\/aarch64\/relocInfo_aarch64.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -27,3 +27,1 @@\n-class ICacheInvalidationContext;\n-\n-THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context = nullptr;\n+NOT_PRODUCT(THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context = nullptr;)\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-extern THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context;\n+NOT_PRODUCT(extern THREAD_LOCAL ICacheInvalidationContext* current_icache_invalidation_context;)\n@@ -36,2 +36,4 @@\n-  if (UseDeferredICacheInvalidation && _needs_invalidation) {\n-    current_icache_invalidation_context = this;\n+  assert(current_icache_invalidation_context == nullptr, \"nested ICacheInvalidationContext not supported\");\n+  NOT_PRODUCT(current_icache_invalidation_context = this);\n+  if (_mode == ICacheInvalidation::DEFERRED && _code == nullptr && !UseDeferredICacheInvalidation) {\n+    _mode = ICacheInvalidation::IMMEDIATE;\n@@ -41,8 +43,3 @@\n-inline bool ICacheInvalidationContext::deferred_invalidation() {\n-  if (UseDeferredICacheInvalidation && current_icache_invalidation_context != nullptr) {\n-    assert(current_icache_invalidation_context->_needs_invalidation,\n-           \"ICacheInvalidationContext::deferred_invalidation must be invoked \"\n-           \"when icache invalidation is needed\");\n-    return true;\n-  }\n-  return false;\n+#ifdef ASSERT\n+inline ICacheInvalidationContext* ICacheInvalidationContext::pd_current() {\n+  return current_icache_invalidation_context;\n@@ -50,0 +47,1 @@\n+#endif\n@@ -51,8 +49,1 @@\n-inline void ICacheInvalidationContext::pd_invalidate_icache() {\n-  if (UseDeferredICacheInvalidation && _needs_invalidation) {\n-\n-    \/\/ For deferred icache invalidation, we expect hardware dcache\n-    \/\/ and icache to be coherent: CTR_EL0.IDC == 1 and CTR_EL0.DIC == 1\n-    \/\/ An exception is Neoverse N1 with erratum 1542419, which requires\n-    \/\/ a use of 'IC IVAU' instruction. In such a case, we expect\n-    \/\/ CTR_EL0.DIC == 0.\n+inline void assert_hardware_cache_coherency() {\n@@ -73,0 +64,10 @@\n+}\n+\n+inline void ICacheInvalidationContext::pd_invalidate_icache() {\n+  if (_mode == ICacheInvalidation::DEFERRED && UseDeferredICacheInvalidation) {\n+    \/\/ For deferred icache invalidation, we expect hardware dcache\n+    \/\/ and icache to be coherent: CTR_EL0.IDC == 1 and CTR_EL0.DIC == 1\n+    \/\/ An exception is Neoverse N1 with erratum 1542419, which requires\n+    \/\/ a use of 'IC IVAU' instruction. In such a case, we expect\n+    \/\/ CTR_EL0.DIC == 0.\n+    assert_hardware_cache_coherency();\n@@ -109,2 +110,0 @@\n-\n-    current_icache_invalidation_context = nullptr;\n@@ -112,0 +111,4 @@\n+  NOT_PRODUCT(current_icache_invalidation_context = nullptr);\n+  _code = nullptr;\n+  _size = 0;\n+  _mode = ICacheInvalidation::NOT_NEEDED;\n@@ -125,1 +128,10 @@\n-    __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+    if (NeoverseN1Errata1542419) {\n+      assert_hardware_cache_coherency();\n+      asm volatile(\"dsb ish       \\n\"\n+                   \"ic  ivau, xzr \\n\"\n+                   \"dsb ish       \\n\"\n+                   \"isb           \\n\"\n+                   : : : \"memory\");\n+    } else {\n+      __builtin___clear_cache((char *)start, (char *)(start + nbytes));\n+    }\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/icache_linux_aarch64.hpp","additions":34,"deletions":22,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -368,0 +368,4 @@\n+  if (rtype == relocInfo::oop_type &&\n+      !((oop_Relocation*)reloc)->oop_is_immediate()) {\n+    _has_non_immediate_oops = true;\n+  }\n@@ -748,3 +752,0 @@\n-\n-  \/\/ Flush generated code\n-  ICache::invalidate_range(dest_blob->code_begin(), dest_blob->code_size());\n@@ -933,2 +934,6 @@\n-  \/\/ Move all the code and relocations to the new blob:\n-  relocate_code_to(&cb);\n+  {\n+    ICacheInvalidationContext icic(ICacheInvalidation::NOT_NEEDED);\n+\n+    \/\/ Move all the code and relocations to the new blob:\n+    relocate_code_to(&cb);\n+  }\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+  bool        _has_non_immediate_oops;\n@@ -124,0 +125,1 @@\n+    _has_non_immediate_oops = false;\n@@ -284,0 +286,4 @@\n+  bool has_non_immediate_oops() const {\n+    return _has_non_immediate_oops;\n+  }\n+\n@@ -855,0 +861,6 @@\n+  bool has_non_immediate_oops() const {\n+    return _consts.has_non_immediate_oops()\n+        || _insts.has_non_immediate_oops()\n+        || _stubs.has_non_immediate_oops();\n+  }\n+\n","filename":"src\/hotspot\/share\/asm\/codeBuffer.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -334,0 +334,4 @@\n+  \/\/ Optimize ICache invalidation by batching it for the whole blob if\n+  \/\/ possible.\n+  ICacheInvalidationContext icic(code_begin(), code_size());\n+\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -684,0 +684,2 @@\n+    ICacheInvalidationContext icic(iter.method()->has_non_immediate_oops());\n+\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1234,0 +1234,1 @@\n+  _has_non_immediate_oops     = 0;\n@@ -1327,0 +1328,1 @@\n+    _has_non_immediate_oops  = code_buffer->has_non_immediate_oops();\n@@ -1328,2 +1330,8 @@\n-    code_buffer->copy_code_and_locs_to(this);\n-    code_buffer->copy_values_to(this);\n+    {\n+      \/\/ Optimize ICache invalidation by batching it for the whole blob if\n+      \/\/ possible.\n+      ICacheInvalidationContext icic(code_begin(), code_size());\n+\n+      code_buffer->copy_code_and_locs_to(this);\n+      code_buffer->copy_values_to(this);\n+    }\n@@ -1483,0 +1491,1 @@\n+  _has_non_immediate_oops       = nm._has_non_immediate_oops;\n@@ -1696,0 +1705,2 @@\n+    _has_non_immediate_oops = code_buffer->has_non_immediate_oops();\n+\n@@ -1765,4 +1776,11 @@\n-    \/\/ Copy code and relocation info\n-    code_buffer->copy_code_and_locs_to(this);\n-    \/\/ Copy oops and metadata\n-    code_buffer->copy_values_to(this);\n+    {\n+      \/\/ Optimize ICache invalidation by batching it for the whole blob if\n+      \/\/ possible.\n+      ICacheInvalidationContext icic(code_begin(), code_size());\n+\n+      \/\/ Copy code and relocation info\n+      code_buffer->copy_code_and_locs_to(this);\n+      \/\/ Copy oops and metadata\n+      code_buffer->copy_values_to(this);\n+    }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -277,1 +277,2 @@\n-          _load_reported:1;            \/\/ used by jvmti to track if an event has been posted for this nmethod\n+          _load_reported:1,            \/\/ used by jvmti to track if an event has been posted for this nmethod\n+          _has_non_immediate_oops:1;\n@@ -777,0 +778,2 @@\n+  bool  has_non_immediate_oops() const            { return _has_non_immediate_oops; }\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -90,0 +91,2 @@\n+  ICacheInvalidationContext icic(nm->has_non_immediate_oops());\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1NMethodClosure.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"runtime\/icache.hpp\"\n@@ -144,0 +145,2 @@\n+      ICacheInvalidationContext icic(cur->has_non_immediate_oops());\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/scavengableNMethods.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"runtime\/icache.hpp\"\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCodeRoots.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,3 @@\n+  ICacheInvalidationContext icic(nmethod_data->_has_non_immed_oops);\n+  \n+  assert(nmethod_data->_has_non_immed_oops == nmethod_data->_nm->has_non_immediate_oops(), \"Inconsistent non-immed oops state\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahNMethod.inline.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -441,0 +441,1 @@\n+  assert(gc_data(nm)->has_non_immediate_oops() == nm->has_non_immediate_oops(), \"Inconsistent non-immed oops state\");\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,6 @@\n+enum class ICacheInvalidation : uint8_t {\n+  NOT_NEEDED = 0,\n+  IMMEDIATE  = 1,\n+  DEFERRED   = 2\n+};\n+\n@@ -78,1 +84,3 @@\n-  bool _needs_invalidation;\n+  address _code;\n+  int _size;\n+  ICacheInvalidation _mode;\n@@ -83,0 +91,2 @@\n+  NOT_PRODUCT(static ICacheInvalidationContext* pd_current());\n+\n@@ -84,1 +94,13 @@\n-  ICacheInvalidationContext(bool needs_invalidation) : _needs_invalidation(needs_invalidation) {\n+  \/\/ Hardware optimized icache invalidation which does not depend on what code is invalidated.\n+  ICacheInvalidationContext(ICacheInvalidation mode) : _code(nullptr), _size(0), _mode(mode) {\n+    pd_init();\n+  }\n+\n+  ICacheInvalidationContext(bool needs_invalidation)\n+      : ICacheInvalidationContext(needs_invalidation\n+                                     ? ICacheInvalidation::DEFERRED\n+                                     : ICacheInvalidation::NOT_NEEDED) {}\n+\n+  \/\/ Use hardware optimized icache invalidation if possible,\n+  \/\/ Otherwise invalidate the specified code range.\n+  ICacheInvalidationContext(address code, int size) : _code(code), _size(size), _mode(ICacheInvalidation::DEFERRED) {\n@@ -88,2 +110,5 @@\n-  ~ICacheInvalidationContext() {\n-    pd_invalidate_icache();\n+  ~ICacheInvalidationContext();\n+\n+#ifdef ASSERT\n+  static ICacheInvalidationContext* current() {\n+    return pd_current();\n@@ -91,0 +116,1 @@\n+#endif\n@@ -92,1 +118,3 @@\n-  static bool deferred_invalidation();\n+  ICacheInvalidation mode() const {\n+    return _mode;\n+  }\n@@ -156,2 +184,4 @@\n-  inline bool ICacheInvalidationContext::deferred_invalidation() {\n-    return false;\n+#ifdef ASSERT\n+  inline ICacheInvalidationContext* ICacheInvalidationContext::pd_current() {\n+    Unimplemented();\n+    return nullptr;\n@@ -159,1 +189,13 @@\n-#endif\n+#endif \/\/ ASSERT\n+#endif \/\/ PD_ICACHE_INVALIDATION_CONTEXT\n+\n+inline ICacheInvalidationContext::~ICacheInvalidationContext() {\n+  pd_invalidate_icache();\n+  if (_code != nullptr) {\n+    assert(_mode == ICacheInvalidation::DEFERRED, \"sanity\");\n+    assert(_size > 0, \"size must be positive\");\n+    ICache::invalidate_range(_code, _size);\n+    _code = nullptr;\n+    _size = 0;\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/icache.hpp","additions":50,"deletions":8,"binary":false,"changes":58,"status":"modified"}]}