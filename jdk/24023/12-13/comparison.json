{"files":[{"patch":"@@ -811,1 +811,1 @@\n-class MergeLoadInfo : ResourceObj {\n+class MergeLoadInfo {\n@@ -814,3 +814,3 @@\n-  LoadNode* const    _load;\n-  Node*     const _combine;\n-  jint      const   _shift;\n+  LoadNode* _load;\n+  Node*     _combine;\n+  jint      _shift;\n@@ -818,1 +818,8 @@\n-  MergeLoadInfo(LoadNode* load, Node* combine, jint shift) : _load(load), _combine(combine), _shift(shift) {}\n+  \/\/ Constructor for invalid item\n+  MergeLoadInfo() : _load(nullptr), _combine(nullptr), _shift(-1) {}\n+  \/\/ Constructor\n+  MergeLoadInfo(LoadNode* load, Node* combine, jint shift) : _load(load), _combine(combine), _shift(shift) {\n+    assert(load != nullptr && combine != nullptr && shift != -1, \"invalid value\");\n+  }\n+\n+  MergeLoadInfo& operator=(const MergeLoadInfo& other) = default;\n@@ -820,0 +827,1 @@\n+  bool is_invalid() { return _load == nullptr; }\n@@ -828,1 +836,1 @@\n-typedef GrowableArray<MergeLoadInfo*> MergeLoadInfoList;\n+typedef GrowableArray<MergeLoadInfo> MergeLoadInfoList;\n@@ -841,1 +849,1 @@\n-  Node*     const    _combine;\n+  AddNode*  const    _combine;\n@@ -848,1 +856,1 @@\n-  MergePrimitiveLoads(PhaseGVN* phase, Node* combine) :\n+  MergePrimitiveLoads(PhaseGVN* phase, AddNode* combine) :\n@@ -862,1 +870,2 @@\n-  void collect_merge_list(MergeLoadInfoList& merge_list, const LoadNode* load);\n+  \/\/ Return the count of collected items, return -1 for failure\n+  int collect_merge_list(MergeLoadInfoList* merge_list, const LoadNode* load);\n@@ -864,1 +873,1 @@\n-  MergeLoadInfo* merge_load_info(LoadNode* load) const;\n+  MergeLoadInfo merge_load_info(LoadNode* load) const;\n@@ -866,1 +875,1 @@\n-  Node* make_merged_load(const MergeLoadInfoList& merge_list);\n+  Node* make_merged_load(const MergeLoadInfoList* merge_list, int count);\n@@ -876,0 +885,2 @@\n+  \/\/ Add operators of combine operator to IGVN worklist\n+  void add_operators_to_worklist(const AddNode* combine) const;\n@@ -940,1 +951,1 @@\n- * And it can be a candidate for merge load optimization\n+ * It can be a candidate for merge load optimization\n@@ -945,3 +956,10 @@\n-  if (check->outcnt() == 1 && check->unique_out()->Opcode() == _combine->Opcode()) {\n-    \/\/ It's in the middle of combine operators\n-    return false;\n+  if (check->outcnt() == 1 &&\n+      check->unique_out()->Opcode() == _combine->Opcode()) {\n+    AddNode* out = check->unique_out()->as_Add();\n+    if (out->is_merge_memops_checked()) {\n+      \/\/ the next operator is checked before, so _combine can be last one of combine operators\n+      return true;\n+    } else {\n+      \/\/ It's in the middle of combine operators\n+      return false;\n+    }\n@@ -953,1 +971,2 @@\n-MergeLoadInfo* MergePrimitiveLoads::merge_load_info(LoadNode* load) const {\n+MergeLoadInfo MergePrimitiveLoads::merge_load_info(LoadNode* load) const {\n+  const MergeLoadInfo invalid = MergeLoadInfo();\n@@ -970,1 +989,1 @@\n-          return nullptr;\n+          return invalid;\n@@ -981,1 +1000,1 @@\n-          return nullptr;\n+          return invalid;\n@@ -987,1 +1006,1 @@\n-          return nullptr;\n+          return invalid;\n@@ -992,1 +1011,1 @@\n-          return nullptr;\n+          return invalid;\n@@ -998,1 +1017,1 @@\n-        return nullptr;\n+        return invalid;\n@@ -1002,1 +1021,1 @@\n-    return nullptr;\n+    return invalid;\n@@ -1004,0 +1023,1 @@\n+\n@@ -1005,1 +1025,1 @@\n-  return new MergeLoadInfo(load, combine_oper, shift);\n+  return MergeLoadInfo(load, combine_oper, shift);\n@@ -1009,1 +1029,2 @@\n-  if (!has_no_merge_load_combine_below()) {\n+  if (_combine->is_merge_memops_checked() || !has_no_merge_load_combine_below()) {\n+    \/\/ no progress\n@@ -1012,0 +1033,1 @@\n+  _combine->set_merge_memops_checked(true);\n@@ -1030,1 +1052,2 @@\n-      return nullptr;\n+      add_operators_to_worklist(_combine);\n+      return _combine;\n@@ -1037,2 +1060,6 @@\n-  MergeLoadInfoList merge_list;\n-  collect_merge_list(merge_list, load);\n+  MergeLoadInfoList* merge_list = new GrowableArray<MergeLoadInfo>(8, 8, MergeLoadInfo());\n+  int count = collect_merge_list(merge_list, load);\n+  if (count == -1) {\n+    add_operators_to_worklist(_combine);\n+    return _combine;\n+  }\n@@ -1040,1 +1067,1 @@\n-  Node* replace = make_merged_load(merge_list);\n+  Node* replace = make_merged_load(merge_list, count);\n@@ -1043,1 +1070,29 @@\n-  return replace;\n+  if (replace == nullptr) {\n+    add_operators_to_worklist(_combine);\n+    return _combine;\n+  } else {\n+    return replace;\n+  }\n+}\n+\n+\/* When combine operator is checked and failed to make merged load,\n+ * push its operators to worklist\n+ *\/\n+void MergePrimitiveLoads::add_operators_to_worklist(const AddNode* combine) const {\n+  assert(combine->is_merge_memops_checked(), \"must be checked\");\n+  \/\/ add left operator\n+  Node* oper = combine->in(1);\n+  if (oper->Opcode() == Op_ConvI2L) {\n+    oper = oper->in(1);\n+  }\n+  if (is_supported_combine_opcode(oper->Opcode()) && !oper->as_Add()->is_merge_memops_checked()) {\n+    _phase->is_IterGVN()->_worklist.push(oper);\n+  }\n+  \/\/ add right operator\n+  oper = combine->in(2);\n+  if (oper->Opcode() == Op_ConvI2L) {\n+    oper = oper->in(1);\n+  }\n+  if (is_supported_combine_opcode(oper->Opcode()) && !oper->as_Add()->is_merge_memops_checked()) {\n+    _phase->is_IterGVN()->_worklist.push(oper);\n+  }\n@@ -1121,1 +1176,2 @@\n-void MergePrimitiveLoads::collect_merge_list(MergeLoadInfoList& merge_list, const LoadNode* load) {\n+\/\/ Return the count of collected items, return -1 for failure\n+int MergePrimitiveLoads::collect_merge_list(MergeLoadInfoList* merge_list, const LoadNode* load) {\n@@ -1124,0 +1180,2 @@\n+  assert(merge_list->length() == max_bytes, \"have enough item slots\");\n+  assert(merge_list->find_if([&](MergeLoadInfo item) {return !item.is_invalid();}) == -1, \"all items should be invalid\");\n@@ -1125,6 +1183,0 @@\n-  MergeLoadInfo* array[8] = {nullptr};\n-#ifdef ASSERT\n-  for (auto & i : array) {\n-    assert(i == nullptr, \"must be initialized\");\n-  }\n-#endif\n@@ -1139,3 +1191,3 @@\n-    MergeLoadInfo* info = merge_load_info(out);\n-    if (info == nullptr || !is_reachable_combine_nodes(info->_combine, _combine)) {\n-      NOT_PRODUCT( if (is_trace_basic() && info != nullptr) { tty->print(\"[TraceMergeLoads]: merge_list:unreachable combine nodes\"); info->_combine->dump(); tty->cr(); });\n+    MergeLoadInfo info = merge_load_info(out);\n+    if (info.is_invalid() || !is_reachable_combine_nodes(info._combine, _combine)) {\n+      NOT_PRODUCT( if (is_trace_basic() && !info.is_invalid()) { tty->print(\"[TraceMergeLoads]: merge_list:unreachable combine nodes\"); info._combine->dump(); tty->cr(); });\n@@ -1145,3 +1197,3 @@\n-    int index = info->_shift \/ (load->memory_size() * BitsPerByte);\n-    if (index < max_merged_nodes && array[index] == nullptr) {\n-      array[index] = info;\n+    int index = info._shift \/ (load->memory_size() * BitsPerByte);\n+    if (index < max_merged_nodes && merge_list->at(index).is_invalid()) {\n+      merge_list->at_put(index, info);\n@@ -1150,2 +1202,2 @@\n-      NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: merge_list:wrong index or duplicate loads at same place: index:%d\", index); out->dump(); array[index]->_load->dump(); tty->cr(); });\n-      return;\n+      NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: merge_list:wrong index or duplicate loads at same place: index:%d\", index); out->dump(); merge_list->at(index)._load->dump(); tty->cr(); });\n+      return -1;\n@@ -1158,3 +1210,4 @@\n-    for (auto & info : array) {\n-      if (info) {\n-        info->dump();\n+    for (int i=0; i<merge_list->length(); i++) {\n+      MergeLoadInfo* item = merge_list->adr_at(i);\n+      if (!item->is_invalid()) {\n+        item->dump();\n@@ -1169,1 +1222,1 @@\n-    return;\n+    return -1;\n@@ -1174,1 +1227,1 @@\n-    return;\n+    return -1;\n@@ -1182,3 +1235,4 @@\n-    MergeLoadInfo* info = array[i];\n-    if (info == nullptr) {\n-      return;\n+    \/\/ MergeLoadInfo* info = array[i];\n+    MergeLoadInfo* info = merge_list->adr_at(i);\n+    if (info->is_invalid()) {\n+      return -1;\n@@ -1187,1 +1241,1 @@\n-      MemoryAdjacentStatus adjacent = get_adjacent_load_status(array[i-1]->_load, info->_load);\n+      MemoryAdjacentStatus adjacent = get_adjacent_load_status(merge_list->at(i-1)._load, info->_load);\n@@ -1189,1 +1243,1 @@\n-        return;\n+        return -1;\n@@ -1194,1 +1248,1 @@\n-        return;\n+        return -1;\n@@ -1205,1 +1259,1 @@\n-        return;\n+        return -1;\n@@ -1214,1 +1268,1 @@\n-    return;\n+    return -1;\n@@ -1225,1 +1279,1 @@\n-    return;\n+    return -1;\n@@ -1231,1 +1285,1 @@\n-    return;\n+    return -1;\n@@ -1240,1 +1294,1 @@\n-    return;\n+    return -1;\n@@ -1244,3 +1298,0 @@\n-  for (int i=0; i<collected; i++) {\n-    merge_list.push(array[i]);\n-  }\n@@ -1250,3 +1301,2 @@\n-    for (int i=0; i < merge_list.length(); i++) {\n-      MergeLoadInfo* info = merge_list.at(i);\n-      info->dump();\n+    for (int i=0; i < collected; i++) {\n+      merge_list->at(i).dump();\n@@ -1256,1 +1306,1 @@\n-  return;\n+  return collected;\n@@ -1260,5 +1310,1 @@\n-Node* MergePrimitiveLoads::make_merged_load(const MergeLoadInfoList& merge_list) {\n-  if (merge_list.is_empty()) {\n-    return nullptr;\n-  }\n-\n+Node* MergePrimitiveLoads::make_merged_load(const MergeLoadInfoList* merge_list, int count) {\n@@ -1268,1 +1314,1 @@\n-    load = merge_list.at(0)->_load;\n+    load = merge_list->at(0)._load;\n@@ -1270,1 +1316,1 @@\n-    load = merge_list.at(merge_list.length()-1)->_load;\n+    load = merge_list->at(count-1)._load;\n@@ -1279,1 +1325,1 @@\n-  int merge_size = merge_list.length() * load->memory_size();\n+  int merge_size = count * load->memory_size();\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":121,"deletions":75,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -45,0 +45,2 @@\n+  \/\/ A flag to indicate if this node is checked by merge_memops phase\n+  bool _merge_memops_checked;\n@@ -46,1 +48,1 @@\n-  AddNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2) {\n+  AddNode( Node *in1, Node *in2 ) : Node(nullptr,in1,in2), _merge_memops_checked(false) {\n@@ -80,0 +82,3 @@\n+  bool is_merge_memops_checked()  const { return _merge_memops_checked; }\n+  void set_merge_memops_checked(bool v) { _merge_memops_checked = v;    }\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -186,2 +186,8 @@\n-        testGroups.get(\"test13\").put(\"test13R\", (_,_) -> { return test12R(aB.clone()); });\n-        testGroups.get(\"test13\").put(\"test13a\", (_,_) -> { return test12a(aB.clone()); });\n+        testGroups.get(\"test13\").put(\"test13R\", (_,_) -> { return test13R(aB.clone()); });\n+        testGroups.get(\"test13\").put(\"test13a\", (_,_) -> { return test13a(aB.clone()); });\n+\n+        \/\/ Merged value is combined with other operator\n+        testGroups.put(\"test14\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test14\").put(\"test14R\", (_,_) -> { return test14R(aS.clone()); });\n+        testGroups.get(\"test14\").put(\"test14a\", (_,_) -> { return test14a(aS.clone()); });\n+        testGroups.get(\"test14\").put(\"test14b\", (_,_) -> { return test14b(aS.clone()); });\n@@ -277,0 +283,3 @@\n+                 \"test14a\",\n+                 \"test14b\",\n+\n@@ -1783,0 +1792,67 @@\n+    \/**\n+     * Group 14: merged value is combined with other opeartor\n+     *\/\n+    @DontCompile\n+    static long[] test14R(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff))       |\n+                 ((long)(a[4] & 0xffff));\n+      long i2 =  ((long)(a[5] & 0xffff))       |\n+                (((long)(a[6] & 0xffff)) << 16)|\n+                (((long)(a[7] & 0xffff)) << 32)|\n+                (((long)(a[8] & 0xffff)) << 48)|\n+                (((long)(a[9] & 0xffff)));\n+      return new long[] {i1 | i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test14a(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff))       |\n+                 ((long)(a[4] & 0xffff));\n+      long i2 =  ((long)(a[5] & 0xffff))       |\n+                (((long)(a[6] & 0xffff)) << 16)|\n+                (((long)(a[7] & 0xffff)) << 32)|\n+                (((long)(a[8] & 0xffff)) << 48)|\n+                (((long)(a[9] & 0xffff)));\n+      return new long[] {i1 | i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test14b(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[5] & 0xffff))       |\n+                (((long)(a[6] & 0xffff)) << 16)|\n+                (((long)(a[7] & 0xffff)) << 32)|\n+                (((long)(a[8] & 0xffff)) << 48);\n+      long i3 =  ((long)(a[4] & 0xffff)) | ((long)(a[9] & 0xffff));\n+      return new long[] {i1 | i2 |i3};\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeLoads.java","additions":78,"deletions":2,"binary":false,"changes":80,"status":"modified"}]}