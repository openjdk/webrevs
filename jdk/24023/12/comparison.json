{"files":[{"patch":"@@ -306,1 +306,2 @@\n-  _trace_merge_stores_tags(TraceMergeStores::TAG_NUM, mtCompiler)\n+  _trace_merge_stores_tags(TraceMergeStores::TAG_NUM, mtCompiler),\n+  _trace_merge_loads_tags(TraceMergeLoads::TAG_NUM, mtCompiler)\n@@ -458,0 +459,10 @@\n+    if (!_modified[TraceMergeLoadsIndex]) {\n+      \/\/ Parse ccstr and create mask\n+      ccstrlist option;\n+      if (CompilerOracle::has_option_value(method, CompileCommandEnum::TraceMergeLoads, option)) {\n+        TraceMergeLoads::TagValidator validator(option, false);\n+        if (validator.is_valid()) {\n+          set.cloned()->set_trace_merge_loads_tags(validator.tags());\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+NOT_PRODUCT(cflags(TraceMergeLoads, ccstrlist, \"\", TraceMergeLoads)) \\\n@@ -134,0 +135,1 @@\n+  CHeapBitMap _trace_merge_loads_tags;\n@@ -220,0 +222,6 @@\n+  void set_trace_merge_loads_tags(const CHeapBitMap& tags) {\n+    _trace_merge_loads_tags.set_from(tags);\n+  };\n+  const CHeapBitMap& trace_merge_loads_tags() {\n+    return _trace_merge_loads_tags;\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -805,0 +805,6 @@\n+        if (!validator.is_valid()) {\n+          jio_snprintf(errorbuf, buf_size, \"Unrecognized tag name in %s: %s\", option2name(option), validator.what());\n+        }\n+      } else if (option == CompileCommandEnum::TraceMergeLoads) {\n+        TraceMergeLoads::TagValidator validator(value, true);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+NOT_PRODUCT(option(TraceMergeLoads, \"TraceMergeLoads\", Ccstrlist)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -360,0 +360,9 @@\n+        } else if (strncmp(option_key->name, \"TraceMergeLoads\", 15) == 0) {\n+          TraceMergeLoads::TagValidator validator(s, false);\n+\n+          valid = validator.is_valid();\n+          if (valid) {\n+            set->set_trace_merge_loads_tags(validator.tags());\n+          } else {\n+            error(VALUE_ERROR, \"Unrecognized tag name detected in TraceMergeLoads: %s\", validator.what());\n+          }\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/mempointer.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"opto\/traceMergeStoresTag.hpp\"\n@@ -772,0 +774,543 @@\n+\/* MergeLoads optimization\n+ * Optimize multiple loads into a merged load, like below java code:\n+ *\n+ *      return ((array[offset    ] & 0xff) << 24)\n+ *           | ((array[offset + 1] & 0xff) << 16)\n+ *           | ((array[offset + 2] & 0xff) <<  8)\n+ *           | ((array[offset + 3] & 0xff)      );\n+ *\n+ * The C2 IR graph is like:\n+ *\n+ *       Mem\n+ *        |---------+---------+----------+\n+ *        |         |         |          |\n+ *      LoadB1    LoadB2    LoadB3     LoadB4\n+ *        |         |         |          |\n+ *        |       LShift    LShift     LShift\n+ *        |         |         |          |\n+ *        +-> Or1 <-+         |          |\n+ *             |              |          |\n+ *             +---> Or2 <----+          |\n+ *                    |                  |\n+ *                    +-----> Or3 <------+\n+ *\n+ * It is transformed as a merged LoadI, which replace the Or3 node.\n+ *\n+ * Because array value is masked with constant 0xff\/0xffff, LoadS\/LoadB is converted to an unsigned load\n+ * and 'And' node is eliminated in previous IGVN phase. Please check AndINode::Ideal for reference\n+ *\n+ *\/\n+class MergePrimitiveLoads;\n+\n+\/*\n+ * A LoadNode and a combine Node pair which represent an item for merging,\n+ * now only OrI\/OrL are supported as combine operator, in future we can extend to add\/xor\n+ *\n+ * Note: combine operator can be shared in different MergeLoadInfo\n+ *\/\n+class MergeLoadInfo : ResourceObj {\n+  friend MergePrimitiveLoads;\n+private:\n+  LoadNode* const    _load;\n+  Node*     const _combine;\n+  jint      const   _shift;\n+public:\n+  MergeLoadInfo(LoadNode* load, Node* combine, jint shift) : _load(load), _combine(combine), _shift(shift) {}\n+\n+#ifdef ASSERT\n+  void dump() {\n+    tty->print_cr(\"MergeLoadInfo: load: %s(%d), combine: %d, shift: %d\",\n+                  _load->Name(), _load->_idx, _combine->_idx, _shift);\n+  }\n+#endif\n+};\n+\n+typedef GrowableArray<MergeLoadInfo*> MergeLoadInfoList;\n+\n+class MergePrimitiveLoads : public StackObj {\n+  \/\/ The adjacent status of 2 loads\n+  enum MemoryAdjacentStatus {\n+    Unknown,            \/\/ Initial state\n+    LowToHigh,          \/\/ Adjacent and first load access low address\n+    HighToLow,          \/\/ Adjacent and first load access high address\n+    NotAdjacent         \/\/ Not adjacent\n+  };\n+\n+private:\n+  PhaseGVN* const      _phase;\n+  Node*     const    _combine;\n+  MemoryAdjacentStatus _order;\n+  bool _require_reverse_bytes;    \/\/ Do we need to add a ReverseBytes for merged load\n+\n+  NOT_PRODUCT( const CHeapBitMap &_trace_tags; )\n+\n+public:\n+  MergePrimitiveLoads(PhaseGVN* phase, Node* combine) :\n+    _phase(phase), _combine(combine), _order(Unknown), _require_reverse_bytes(false)\n+    NOT_PRODUCT( COMMA _trace_tags(Compile::current()->directive()->trace_merge_loads_tags()) )\n+  {}\n+\n+  \/\/ try merge adjacent loads, and return replace node for origin _combine\n+  Node* run();\n+\n+private:\n+  \/\/ Detect if the embedding combine node is last one of combine operators\n+  bool has_no_merge_load_combine_below( ) const;\n+  \/\/ Check other_load and load are compatible\n+  bool is_compatible_load(const LoadNode* other_load, const LoadNode* load) const;\n+  \/\/ From the seed load to collect load items for merging\n+  void collect_merge_list(MergeLoadInfoList& merge_list, const LoadNode* load);\n+  \/\/ Construct merge information item from input load\n+  MergeLoadInfo* merge_load_info(LoadNode* load) const;\n+  \/\/ Make the merged load and optional ReverseByte for replace\n+  Node* make_merged_load(const MergeLoadInfoList& merge_list);\n+\n+  \/\/ Helper methods for merge loads optimization\n+  static bool is_supported_load_opcode(int opcode);\n+  static bool is_supported_combine_opcode(int opcode);\n+  \/\/ Check the two combine operator Nodes can be reachable from one to another, and intermediate nodes has the same type\n+  static bool is_reachable_combine_nodes(const Node* from, const Node* to);\n+  MemoryAdjacentStatus get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const;\n+  \/\/ Go through ConvI2L which is unique output of input node\n+  static const Node* bypass_i2l(const Node* n);\n+\n+#ifndef PRODUCT\n+  \/\/ Access to TraceMergeLoads tags\n+  bool is_trace(TraceMergeLoads::Tag tag) const {\n+    return _trace_tags.at(tag);\n+  }\n+\n+  bool is_trace_basic() const {\n+    return is_trace(TraceMergeLoads::Tag::BASIC);\n+  }\n+\n+  bool is_trace_pointer_parsing() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_PARSING);\n+  }\n+\n+  bool is_trace_pointer_aliasing() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_ALIASING);\n+  }\n+\n+  bool is_trace_pointer_adjacency() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_ADJACENCY);\n+  }\n+\n+  bool is_trace_success() const {\n+    return is_trace(TraceMergeLoads::Tag::SUCCESS);\n+  }\n+#endif\n+};\n+\n+bool MergePrimitiveLoads::is_supported_load_opcode(int opc) {\n+  \/\/ Check for B\/S\/C\/I\n+  switch(opc) {\n+    case Op_LoadB:\n+    case Op_LoadUB:\n+    case Op_LoadS:\n+    case Op_LoadUS:\n+    case Op_LoadI:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+bool MergePrimitiveLoads::is_supported_combine_opcode(int opc) {\n+  switch(opc) {\n+    case Op_OrI:\n+    case Op_OrL:\n+      return true;\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/\/ Go through ConvI2L which is unique output of input node\n+const Node* MergePrimitiveLoads::bypass_i2l(const Node* n) {\n+  if (n != nullptr && n->outcnt() == 1 && n->unique_out()->Opcode() == Op_ConvI2L) {\n+    return n->unique_out();\n+  } else {\n+    return n;\n+  }\n+};\n+\n+\/*\n+ * Check the _combine operator is the last one of combine operators\n+ * And it can be a candidate for merge load optimization\n+ *\/\n+bool MergePrimitiveLoads::has_no_merge_load_combine_below() const {\n+  assert(is_supported_combine_opcode(_combine->Opcode()), \"sanity\");\n+  const Node* check = bypass_i2l(_combine);\n+  if (check->outcnt() == 1 && check->unique_out()->Opcode() == _combine->Opcode()) {\n+    \/\/ It's in the middle of combine operators\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Construct merge information item from input load\n+MergeLoadInfo* MergePrimitiveLoads::merge_load_info(LoadNode* load) const {\n+  const Node* check = bypass_i2l(load);\n+  Node* combine_oper = nullptr;\n+  jint shift = -1;\n+\n+  \/\/ Check the Load node has the pattern \"(Or (LShift (Load .. ) ConI) ..)\" or \"(Or (Load ..) ..)\"\n+  for (DUIterator_Fast imax, iter = check->fast_outs(imax); iter < imax; iter++) {\n+    Node *out = check->fast_out(iter);\n+    switch (out->Opcode()) {\n+      case Op_OrI:\n+      case Op_OrL: {\n+        \/\/ match pattern: (Or (Load ..) ..)\n+        if (combine_oper == nullptr) {\n+          combine_oper = out;\n+          shift = 0;\n+        } else {\n+          \/\/ Too much Or usages\n+          return nullptr;\n+        }\n+        break;\n+      }\n+      case Op_LShiftI:\n+      case Op_LShiftL: {\n+        \/\/ match pattern: (Or (LShift (Load ..) ConI) ..)\n+        Node* shift_oper = out->isa_LShift();\n+        if (shift_oper->outcnt() != 1 ||                                               \/\/ Shift should has only one usage\n+            !is_supported_combine_opcode(shift_oper->unique_out()->Opcode()) ||    \/\/ Not used by combine operator\n+            !shift_oper->in(2)->is_ConI()) {                                         \/\/ Not shift by constant\n+          return nullptr;\n+        }\n+        if (combine_oper == nullptr) {\n+          combine_oper = shift_oper->unique_out();\n+        } else {\n+          \/\/ Too much combine operators\n+          return nullptr;\n+        }\n+        shift = shift_oper->in(2)->as_ConI()->get_int();\n+        if (shift % (load->memory_size() * BitsPerByte) != 0) {\n+          \/\/ Shift value is not aligned with memory size\n+          return nullptr;\n+        }\n+        break;\n+      }\n+      default:\n+        \/\/ can not handle other usage\n+        return nullptr;\n+    }\n+  }\n+  if (combine_oper == nullptr) {\n+    return nullptr;\n+  }\n+  assert(shift != -1, \"must be set\");\n+  return new MergeLoadInfo(load, combine_oper, shift);\n+}\n+\n+Node* MergePrimitiveLoads::run() {\n+  if (!has_no_merge_load_combine_below()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ go up through combine operators to find load node\n+  LoadNode* load = nullptr;\n+  Node* oper = _combine;\n+  NOT_PRODUCT(int steps = 0;)    \/\/ prevent dead loop in bad graph\n+  while (load == nullptr NOT_PRODUCT(&& steps < 30)) {\n+    assert(is_supported_combine_opcode(oper->Opcode())\n+           || oper->Opcode() == Op_ConvI2L || oper->is_LShift(), \"unexpected node\");\n+    Node* lhs = oper->in(1); \/\/ Check one input is enough\n+    assert(lhs != nullptr, \"sanity\");\n+    if (lhs->Opcode() == Op_ConvI2L || lhs->is_LShift() || lhs->Opcode() == _combine->Opcode()) {\n+      oper = lhs;\n+      continue;\n+    } else if (is_supported_load_opcode(lhs->Opcode())) {\n+      load = lhs->as_Load();\n+      break;\n+    } else {\n+      \/\/ not found\n+      return nullptr;\n+    }\n+  }\n+  assert(load != nullptr, \"reach loop limit\");\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] candidate:\"); _combine->dump(); tty->cr(); })\n+\n+  ResourceMark rm;\n+  MergeLoadInfoList merge_list;\n+  collect_merge_list(merge_list, load);\n+\n+  Node* replace = make_merged_load(merge_list);\n+  NOT_PRODUCT( if (is_trace_success() && replace != nullptr) { tty->print(\"[TraceMergeLoads] replace node is:\"); replace->dump(); tty->cr(); })\n+\n+  return replace;\n+}\n+\n+\/\/ Check other_load is compatible with load\n+bool MergePrimitiveLoads::is_compatible_load(const LoadNode* other_load, const LoadNode* load) const {\n+  if (other_load == nullptr ||\n+      !is_supported_load_opcode(other_load->Opcode()) ||\n+      load->memory_size() != other_load->memory_size()) {\n+    return false;\n+  }\n+\n+  assert(other_load->in(MemNode::Memory) == load->in(MemNode::Memory), \"sanity\");\n+\n+  \/\/ To simplify, assume all loads have same control.\n+  if (other_load->in(MemNode::Control) != load->in(MemNode::Control)) {\n+    return false;\n+  }\n+\n+  if (other_load->is_acquire() || !other_load->is_unordered()) {\n+    return false;\n+  }\n+\n+  \/\/ check alias\n+  Compile* C = _phase->C;\n+  if (C->get_alias_index(_phase->type(other_load->in(MemNode::Address))->is_ptr()) !=\n+      C->get_alias_index(_phase->type(load->in(MemNode::Address))->is_ptr())) {\n+    return false;\n+  }\n+\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: compatible_load:\"); other_load->dump(); tty->cr(); })\n+  return true;\n+}\n+\n+bool MergePrimitiveLoads::is_reachable_combine_nodes(const Node* from, const Node* to) {\n+  assert(from != nullptr && is_supported_combine_opcode(from->Opcode()), \"sanity\");\n+  assert(to != nullptr && is_supported_combine_opcode(to->Opcode()), \"sanity\");\n+\n+  const int max_search_steps = 8;\n+  int step = 0;\n+  const Node* check = from;\n+  while (step < max_search_steps) {\n+    if (check == to) {\n+      return true;\n+    }\n+    if (check->outcnt() != 1) {\n+      return false;\n+    }\n+    Node* next = check->unique_out();\n+    if (is_supported_combine_opcode(next->Opcode())) {\n+      check = next;\n+    } else {\n+      return false;\n+    }\n+    step++;\n+  }\n+  return false;\n+}\n+\n+MergePrimitiveLoads::MemoryAdjacentStatus MergePrimitiveLoads::get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const {\n+  ResourceMark rm;\n+#ifndef PRODUCT\n+  const TraceMemPointer trace(is_trace_pointer_parsing(),\n+                              is_trace_pointer_aliasing(),\n+                              is_trace_pointer_adjacency(),\n+                              true);\n+#endif\n+  const MemPointer pointer_first(first NOT_PRODUCT(COMMA trace));\n+  const MemPointer pointer_second(second NOT_PRODUCT(COMMA trace));\n+  if (pointer_first.is_adjacent_to_and_before(pointer_second)) {\n+    return MergePrimitiveLoads::LowToHigh;\n+  } else if (pointer_second.is_adjacent_to_and_before(pointer_first)) {\n+    return MergePrimitiveLoads::HighToLow;\n+  } else {\n+    return MergePrimitiveLoads::NotAdjacent;\n+  }\n+}\n+\n+\/\/ From the seed load to collect load items for merging\n+void MergePrimitiveLoads::collect_merge_list(MergeLoadInfoList& merge_list, const LoadNode* load) {\n+  const int max_bytes = 8; \/\/ The largest load is LoadLong\n+  const int max_merged_nodes = max_bytes\/load->memory_size();\n+\n+  MergeLoadInfo* array[8] = {nullptr};\n+#ifdef ASSERT\n+  for (auto & i : array) {\n+    assert(i == nullptr, \"must be initialized\");\n+  }\n+#endif\n+  \/\/ collect load nodes info from the same memory input\n+  Node* mem = load->in(MemNode::Memory);\n+  int collected = 0;\n+  \/\/ Collect draft merge list to array\n+  for (DUIterator_Fast imax, iter = mem->fast_outs(imax); iter < imax; iter++) {\n+    LoadNode* out = mem->fast_out(iter)->isa_Load();\n+    if (out == nullptr || !is_compatible_load(out, load)) continue;\n+\n+    MergeLoadInfo* info = merge_load_info(out);\n+    if (info == nullptr || !is_reachable_combine_nodes(info->_combine, _combine)) {\n+      NOT_PRODUCT( if (is_trace_basic() && info != nullptr) { tty->print(\"[TraceMergeLoads]: merge_list:unreachable combine nodes\"); info->_combine->dump(); tty->cr(); });\n+      continue;\n+    }\n+\n+    int index = info->_shift \/ (load->memory_size() * BitsPerByte);\n+    if (index < max_merged_nodes && array[index] == nullptr) {\n+      array[index] = info;\n+      collected ++;\n+    } else {\n+      NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: merge_list:wrong index or duplicate loads at same place: index:%d\", index); out->dump(); array[index]->_load->dump(); tty->cr(); });\n+      return;\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  if (is_trace_basic()) {\n+    tty->print_cr(\"[TraceMergeLoads]: dump draft merge info array, collected: %d\", collected);\n+    for (auto & info : array) {\n+      if (info) {\n+        info->dump();\n+      }\n+    }\n+  }\n+#endif\n+\n+  int bytes = collected * load->memory_size();\n+  if (collected < 2 || bytes < 4 || !is_power_of_2(bytes)) {\n+    \/\/ too few or not aligned\n+    return;\n+  }\n+\n+  if (_combine->bottom_type() == TypeLong::LONG && bytes < 8) {\n+    \/\/ not cover all bits of result\n+    return;\n+  }\n+\n+  \/\/ check loads are adjacent in the same order\n+  MemoryAdjacentStatus order = Unknown;\n+  bool find_candidate = false;\n+\n+  for (int i = 0; i < collected; i++) {\n+    MergeLoadInfo* info = array[i];\n+    if (info == nullptr) {\n+      return;\n+    }\n+    if (i > 0) {\n+      MemoryAdjacentStatus adjacent = get_adjacent_load_status(array[i-1]->_load, info->_load);\n+      if (adjacent == NotAdjacent) {\n+        return;\n+      } else if (order == Unknown) {\n+        order = adjacent;\n+      } else if (adjacent != order) {\n+        \/\/ Different adjacent order\n+        return;\n+      }\n+    }\n+\n+    \/\/ Check sign bit of load\n+    \/\/ For shifted value based on memory load, if it does not reach the sign bit of merged load,\n+    \/\/ the load must be an unsigned load\n+    if ((info->_shift + load->memory_size() * BitsPerByte) != (collected * load->memory_size() * BitsPerByte)) {\n+      if (!info->_load->is_unsigned()) {\n+        \/\/ no unsigned Load of LoadI, so LoadI can not be merged\n+        \/\/ we may check value, if it's greater than 0, it can be merged\n+        return;\n+      }\n+    }\n+\n+    find_candidate = find_candidate || info->_combine == _combine;\n+  } \/\/ end of for-loop\n+\n+  \/\/ candidate combine operator is not in the list\n+  if (!find_candidate) {\n+    return;\n+  }\n+\n+  _order = order;\n+\n+  \/\/ Check the merged load matches the platform endian and if require a reverse byte node\n+  \/\/ The list is sorted by shift value, the low bit part is in the beginning\n+  assert(order == LowToHigh || order == HighToLow, \"Invalid order should return early\");\n+#ifdef VM_LITTLE_ENDIAN\n+  \/\/ LowToHigh match the platform order\n+  if (order != LowToHigh && load->memory_size() != 1) {\n+    return;\n+  }\n+  _require_reverse_bytes = (order == HighToLow);\n+#else\n+  \/\/ HighToLow match the platform order\n+  if (order != HighToLow && load->memory_size() != 1) {\n+    return;\n+  }\n+  _require_reverse_bytes = (order == LowToHigh);\n+#endif\n+  if (_require_reverse_bytes &&\n+      (!Matcher::match_rule_supported(Op_ReverseBytesS) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesL))) {\n+    \/\/ Reverse Bytes is not supported\n+    return;\n+  }\n+\n+  \/\/ All checks are passed\n+  for (int i=0; i<collected; i++) {\n+    merge_list.push(array[i]);\n+  }\n+#ifdef ASSERT\n+  if (is_trace_basic()) {\n+    tty->print_cr(\"[TraceMergeLoads]: dump final merge info list, collected: %d\", collected);\n+    for (int i=0; i < merge_list.length(); i++) {\n+      MergeLoadInfo* info = merge_list.at(i);\n+      info->dump();\n+    }\n+  }\n+#endif\n+  return;\n+}\n+\n+\/\/ Make the merged load and optional ReverBytes for replace\n+Node* MergePrimitiveLoads::make_merged_load(const MergeLoadInfoList& merge_list) {\n+  if (merge_list.is_empty()) {\n+    return nullptr;\n+  }\n+\n+  LoadNode* load;\n+  \/\/ Get address of merged load\n+  if (_order == LowToHigh) {\n+    load = merge_list.at(0)->_load;\n+  } else {\n+    load = merge_list.at(merge_list.length()-1)->_load;\n+  }\n+  Node* adr  = load->in(MemNode::Address);\n+  Node* ctrl = load->in(MemNode::Control);\n+  Node* mem  = load->in(MemNode::Memory);\n+\n+  const TypePtr* at = load->adr_type();\n+  const Type* rt = nullptr;\n+\n+  int merge_size = merge_list.length() * load->memory_size();\n+  BasicType bt = T_ILLEGAL;\n+  switch (merge_size) {\n+    case 4: bt = T_INT;   rt = TypeInt::INT;   break;\n+    case 8: bt = T_LONG;  rt = TypeLong::LONG; break;\n+    case 2: \/\/ Not merged as LoadS\n+    default: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+\n+  LoadNode* merged_load = LoadNode::make(*_phase, ctrl, mem, adr,\n+                                         at, rt, bt, MemNode::unordered)->isa_Load();\n+\n+  if (merged_load == nullptr) {\n+    return nullptr;\n+  }\n+  NOT_PRODUCT( if (is_trace_success()) { tty->print(\"[TraceMergeLoads] merged load:\"); merged_load->dump(); tty->cr(); })\n+\n+  merged_load->set_unaligned_access();\n+  merged_load->set_mismatched_access();\n+\n+  Node* replace = merged_load;\n+  if (_require_reverse_bytes) {\n+    assert(load->memory_size() == 1, \"only implemented for bytes\");\n+    if (merge_size == 8) {\n+      replace = _phase->transform(new ReverseBytesLNode(merged_load));\n+    } else {\n+      assert(merge_size == 4, \"sanity\");\n+      replace = _phase->transform(new ReverseBytesINode(merged_load));\n+    }\n+    _phase->is_IterGVN()->_worklist.push(merged_load);\n+  }\n+\n+  return replace;\n+}\n+\n@@ -833,1 +1378,15 @@\n-  return AddNode::Ideal(phase, can_reshape);\n+\n+  Node* progress = AddNode::Ideal(phase, can_reshape);\n+  if (progress) {\n+    return progress;\n+  }\n+\n+  if (MergeLoads && UseUnalignedAccesses) {\n+    if (phase->C->merge_memops_phase()) {\n+      MergePrimitiveLoads merge(phase, this);\n+      return merge.run();\n+    } else {\n+      phase->C->record_for_merge_memops_igvn(this);\n+    }\n+  }\n+  return nullptr;\n@@ -913,1 +1472,14 @@\n-  return AddNode::Ideal(phase, can_reshape);\n+  Node* progress = AddNode::Ideal(phase, can_reshape);\n+  if (progress) {\n+    return progress;\n+  }\n+\n+  if (MergeLoads && UseUnalignedAccesses) {\n+    if (phase->C->merge_memops_phase()) {\n+      MergePrimitiveLoads merge(phase, this);\n+      return merge.run();\n+    } else {\n+      phase->C->record_for_merge_memops_igvn(this);\n+    }\n+  }\n+  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":574,"deletions":2,"binary":false,"changes":576,"status":"modified"},{"patch":"@@ -382,0 +382,3 @@\n+  product(bool, MergeLoads, true, DIAGNOSTIC,                               \\\n+          \"Optimize loads by combining values into larger load\")            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -406,2 +406,2 @@\n-  if (dead->for_merge_stores_igvn()) {\n-    remove_from_merge_stores_igvn(dead);\n+  if (dead->for_merge_memops_igvn()) {\n+    remove_from_merge_memops_igvn(dead);\n@@ -461,1 +461,1 @@\n-  remove_useless_nodes(_for_merge_stores_igvn, useful); \/\/ remove useless node recorded for merge stores IGVN pass\n+  remove_useless_nodes(_for_merge_memops_igvn, useful); \/\/ remove useless node recorded for merge stores\/loads IGVN pass\n@@ -636,1 +636,1 @@\n-      _merge_stores_phase(false),\n+      _merge_memops_phase(false),\n@@ -661,1 +661,1 @@\n-      _for_merge_stores_igvn(comp_arena(), 8, 0, nullptr),\n+      _for_merge_memops_igvn(comp_arena(), 8, 0, nullptr),\n@@ -916,1 +916,1 @@\n-      _merge_stores_phase(false),\n+      _merge_memops_phase(false),\n@@ -935,1 +935,1 @@\n-      _for_merge_stores_igvn(comp_arena(), 8, 0, nullptr),\n+      _for_merge_memops_igvn(comp_arena(), 8, 0, nullptr),\n@@ -1883,5 +1883,5 @@\n-void Compile::record_for_merge_stores_igvn(Node* n) {\n-  if (!n->for_merge_stores_igvn()) {\n-    assert(!_for_merge_stores_igvn.contains(n), \"duplicate\");\n-    n->add_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n-    _for_merge_stores_igvn.append(n);\n+void Compile::record_for_merge_memops_igvn(Node* n) {\n+  if (!n->for_merge_memops_igvn()) {\n+    assert(!_for_merge_memops_igvn.contains(n), \"duplicate\");\n+    n->add_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n+    _for_merge_memops_igvn.append(n);\n@@ -1891,3 +1891,3 @@\n-void Compile::remove_from_merge_stores_igvn(Node* n) {\n-  n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n-  _for_merge_stores_igvn.remove(n);\n+void Compile::remove_from_merge_memops_igvn(Node* n) {\n+  n->remove_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n+  _for_merge_memops_igvn.remove(n);\n@@ -1896,1 +1896,1 @@\n-\/\/ We need to wait with merging stores until RangeCheck smearing has removed the RangeChecks during\n+\/\/ We need to wait with merging stores\/loads until RangeCheck smearing has removed the RangeChecks during\n@@ -1909,8 +1909,8 @@\n-\/\/       since we never unset _merge_stores_phase.\n-void Compile::process_for_merge_stores_igvn(PhaseIterGVN& igvn) {\n-  C->set_merge_stores_phase();\n-\n-  if (_for_merge_stores_igvn.length() > 0) {\n-    while (_for_merge_stores_igvn.length() > 0) {\n-      Node* n = _for_merge_stores_igvn.pop();\n-      n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+\/\/       since we never unset _merge_memops_phase.\n+void Compile::process_for_merge_memops_igvn(PhaseIterGVN& igvn) {\n+  C->set_merge_memops_phase();\n+\n+  if (_for_merge_memops_igvn.length() > 0) {\n+    while (_for_merge_memops_igvn.length() > 0) {\n+      Node* n = _for_merge_memops_igvn.pop();\n+      n->remove_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n@@ -1921,2 +1921,2 @@\n-    assert(_for_merge_stores_igvn.length() == 0, \"no more delayed nodes allowed\");\n-    print_method(PHASE_AFTER_MERGE_STORES, 3);\n+    assert(_for_merge_memops_igvn.length() == 0, \"no more delayed nodes allowed\");\n+    print_method(PHASE_AFTER_MERGE_MEMOPS, 3);\n@@ -2500,1 +2500,1 @@\n-  process_for_merge_stores_igvn(igvn);\n+  process_for_merge_memops_igvn(igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-  bool                  _merge_stores_phase;    \/\/ Phase for merging stores, after post loop opts phase.\n+  bool                  _merge_memops_phase;    \/\/ Phase for merging stores\/loads, after post loop opts phase.\n@@ -379,1 +379,1 @@\n-  GrowableArray<Node*>  _for_merge_stores_igvn; \/\/ List of nodes for IGVN merge stores\n+  GrowableArray<Node*>  _for_merge_memops_igvn; \/\/ List of nodes for IGVN merge stores and loads\n@@ -775,5 +775,5 @@\n-  bool     merge_stores_phase() { return _merge_stores_phase;  }\n-  void set_merge_stores_phase() { _merge_stores_phase = true;  }\n-  void record_for_merge_stores_igvn(Node* n);\n-  void remove_from_merge_stores_igvn(Node* n);\n-  void process_for_merge_stores_igvn(PhaseIterGVN& igvn);\n+  bool     merge_memops_phase() { return _merge_memops_phase;  }\n+  void set_merge_memops_phase() { _merge_memops_phase = true;  }\n+  void record_for_merge_memops_igvn(Node* n);\n+  void remove_from_merge_memops_igvn(Node* n);\n+  void process_for_merge_memops_igvn(PhaseIterGVN& igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3458,1 +3458,1 @@\n-    if (phase->C->merge_stores_phase()) {\n+    if (phase->C->merge_memops_phase()) {\n@@ -3474,1 +3474,1 @@\n-      phase->C->record_for_merge_stores_igvn(this);\n+      phase->C->record_for_merge_memops_igvn(this);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -511,2 +511,2 @@\n-  if (for_merge_stores_igvn()) {\n-    \/\/ Don't add cloned node to Compile::_for_merge_stores_igvn list automatically.\n+  if (for_merge_memops_igvn()) {\n+    \/\/ Don't add cloned node to Compile::_for_merge_memops_igvn list automatically.\n@@ -514,1 +514,1 @@\n-    n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+    n->remove_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n@@ -626,2 +626,2 @@\n-  if (for_merge_stores_igvn()) {\n-    compile->remove_from_merge_stores_igvn(this);\n+  if (for_merge_memops_igvn()) {\n+    compile->remove_from_merge_memops_igvn(this);\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -837,1 +837,1 @@\n-    Flag_for_merge_stores_igvn       = 1 << 16,\n+    Flag_for_merge_memops_igvn       = 1 << 16,\n@@ -1083,1 +1083,1 @@\n-  bool for_merge_stores_igvn() const { return (_flags & Flag_for_merge_stores_igvn) != 0; }\n+  bool for_merge_memops_igvn() const { return (_flags & Flag_for_merge_memops_igvn) != 0; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-  flags(AFTER_MERGE_STORES,             \"After Merge Stores\") \\\n+  flags(AFTER_MERGE_MEMOPS,             \"After Merge Memops\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+namespace TraceMergeLoads = TraceMergeStores;\n","filename":"src\/hotspot\/share\/opto\/traceMergeStoresTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,1889 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import static compiler.lib.verify.Verify.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @bug 8345845\n+ * @summary Test merging of consecutive loads\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ *\n+ * @run main compiler.c2.TestMergeLoads unaligned\n+ * @run main compiler.c2.TestMergeLoads aligned\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8345845\n+ * @summary Test merging of consecutive loads\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ *\n+ * @run main compiler.c2.TestMergeLoads unaligned StressIGVN\n+ * @run main compiler.c2.TestMergeLoads aligned StressIGVN\n+ *\n+ *\/\n+public class TestMergeLoads {\n+    static int RANGE = 1000;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB = new byte[RANGE];\n+    char[] aC = new char[RANGE];\n+    short[] aS = new short[RANGE];\n+    int[] aI = new int[RANGE];\n+\n+    long aN = UNSAFE.allocateMemory(RANGE);\n+\n+    interface TestFunction {\n+        Object run(boolean isWarmUp, int rnd);\n+    }\n+\n+    Map<String, Map<String, TestFunction>> testGroups = new HashMap<String, Map<String, TestFunction>>();\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMergeLoads.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        for (String arg: args) {\n+            switch (arg) {\n+                case \"aligned\"     -> { framework.addFlags(\"-XX:-UseUnalignedAccesses\"); }\n+                case \"unaligned\"   -> { framework.addFlags(\"-XX:+UseUnalignedAccesses\"); }\n+                case \"StressIGVN\"   -> { framework.addFlags(\"-XX:+StressIGVN\"); }\n+                default -> { throw new RuntimeException(\"Test argument not recognized: \" + arg); }\n+            }\n+        }\n+        framework.start();\n+    }\n+\n+    public TestMergeLoads() {\n+        \/\/ Get int in little endian\n+        testGroups.put(\"test1\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test1\").put(\"test1R\", (_,_) -> { return test1R(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1a\", (_,_) -> { return test1a(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1b\", (_,_) -> { return test1b(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1c\", (_,_) -> { return test1c(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1d\", (_,_) -> { return test1d(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1e\", (_,_) -> { return test1e(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1f\", (_,_) -> { return test1f(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1g\", (_,_) -> { return test1g(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1h\", (_,_) -> { return test1h(aN); });\n+\n+        \/\/ Get long in little endian\n+        testGroups.put(\"test2\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test2\").put(\"test2R\", (_,_) -> { return test2R(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2a\", (_,_) -> { return test2a(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2b\", (_,_) -> { return test2b(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2c\", (_,_) -> { return test2c(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2d\", (_,_) -> { return test2d(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2e\", (_,_) -> { return test2e(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2f\", (_,_) -> { return test2f(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2g\", (_,_) -> { return test2g(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2h\", (_,_) -> { return test2h(aN); });\n+\n+        \/\/ Get int in big endian\n+        testGroups.put(\"test3\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test3\").put(\"test3R\", (_,_) -> { return test3R(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3a\", (_,_) -> { return test3a(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3b\", (_,_) -> { return test3b(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3c\", (_,_) -> { return test3c(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3d\", (_,_) -> { return test3d(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3e\", (_,_) -> { return test3e(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3f\", (_,_) -> { return test3f(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3g\", (_,_) -> { return test3g(aB.clone()); });\n+\n+        \/\/ Get long in big endian\n+        testGroups.put(\"test4\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test4\").put(\"test4R\", (_,_) -> { return test4R(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4a\", (_,_) -> { return test4a(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4b\", (_,_) -> { return test4b(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4c\", (_,_) -> { return test4c(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4d\", (_,_) -> { return test4d(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4e\", (_,_) -> { return test4e(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4f\", (_,_) -> { return test4f(aB.clone()); });\n+\n+        \/\/ Merge char as int\n+        testGroups.put(\"test5\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test5\").put(\"test5R\", (_,_) -> { return test5R(aC.clone()); });\n+        testGroups.get(\"test5\").put(\"test5a\", (_,_) -> { return test5a(aC.clone()); });\n+        testGroups.get(\"test5\").put(\"test5b\", (_,_) -> { return test5b(aC.clone()); });\n+\n+        \/\/ Merge char as long\n+        testGroups.put(\"test6\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test6\").put(\"test6R\", (_,_) -> { return test6R(aC.clone()); });\n+        testGroups.get(\"test6\").put(\"test6a\", (_,_) -> { return test6a(aC.clone()); });\n+        testGroups.get(\"test6\").put(\"test6b\", (_,_) -> { return test6b(aC.clone()); });\n+\n+        \/\/ Merge short as int\n+        testGroups.put(\"test7\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test7\").put(\"test7R\", (_,_) -> { return test7R(aS.clone()); });\n+        testGroups.get(\"test7\").put(\"test7a\", (_,_) -> { return test7a(aS.clone()); });\n+        testGroups.get(\"test7\").put(\"test7b\", (_,_) -> { return test7b(aS.clone()); });\n+\n+        \/\/ Merge short as long\n+        testGroups.put(\"test8\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test8\").put(\"test8R\", (_,_) -> { return test8R(aS.clone()); });\n+        testGroups.get(\"test8\").put(\"test8a\", (_,_) -> { return test8a(aS.clone()); });\n+        testGroups.get(\"test8\").put(\"test8b\", (_,_) -> { return test8b(aS.clone()); });\n+\n+        \/\/ Merge int as long\n+        testGroups.put(\"test9\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test9\").put(\"test9R\", (_,_) -> { return test9R(aI.clone()); });\n+        testGroups.get(\"test9\").put(\"test9a\", (_,_) -> { return test9a(aI.clone()); });\n+        testGroups.get(\"test9\").put(\"test9b\", (_,_) -> { return test9b(aI.clone()); });\n+\n+        \/\/ Shift value is not aligned\n+        testGroups.put(\"test10\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test10\").put(\"test10R\", (_,_) -> { return test10R(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+        testGroups.get(\"test10\").put(\"test10a\", (_,_) -> { return test10a(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+\n+        \/\/ Mask value is not aligned\n+        testGroups.put(\"test11\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test11\").put(\"test11R\", (_,_) -> { return test11R(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+        testGroups.get(\"test11\").put(\"test11a\", (_,_) -> { return test11a(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+\n+        \/\/ Load value has other usage\n+        testGroups.put(\"test12\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test12\").put(\"test12R\", (_,_) -> { return test12R(aB.clone()); });\n+        testGroups.get(\"test12\").put(\"test12a\", (_,_) -> { return test12a(aB.clone()); });\n+\n+        \/\/ Load value is not masked\n+        testGroups.put(\"test13\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test13\").put(\"test13R\", (_,_) -> { return test12R(aB.clone()); });\n+        testGroups.get(\"test13\").put(\"test13a\", (_,_) -> { return test12a(aB.clone()); });\n+\n+        \/\/ Mix different loads\n+        testGroups.put(\"test100\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test100\").put(\"test100R\", (_,_) -> { return test100R(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+        testGroups.get(\"test100\").put(\"test100a\", (_,_) -> { return test100a(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+    }\n+\n+    static void set_random(byte[] a, long addr) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+            UNSAFE.putByte(addr + i, a[i]);\n+        }\n+    }\n+\n+    static void set_random(char[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (char)RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test1a\",\n+                 \"test1b\",\n+                 \"test1c\",\n+                 \"test1d\",\n+                 \"test1e\",\n+                 \"test1f\",\n+                 \"test1g\",\n+                 \"test1h\",\n+\n+                 \"test2a\",\n+                 \"test2b\",\n+                 \"test2c\",\n+                 \"test2d\",\n+                 \"test2e\",\n+                 \"test2f\",\n+                 \"test2g\",\n+                 \"test2h\",\n+\n+                 \"test3a\",\n+                 \"test3b\",\n+                 \"test3c\",\n+                 \"test3d\",\n+                 \"test3e\",\n+                 \"test3f\",\n+                 \"test3g\",\n+\n+                 \"test4a\",\n+                 \"test4b\",\n+                 \"test4c\",\n+                 \"test4d\",\n+                 \"test4e\",\n+                 \"test4f\",\n+\n+                 \"test5a\",\n+                 \"test5b\",\n+\n+                 \"test6a\",\n+                 \"test6b\",\n+\n+                 \"test7a\",\n+                 \"test7b\",\n+\n+                 \"test8a\",\n+                 \"test8b\",\n+\n+                 \"test9a\",\n+                 \"test9b\",\n+\n+                 \"test10a\",\n+\n+                 \"test11a\",\n+\n+                 \"test12a\",\n+\n+                 \"test13a\",\n+\n+                 \"test100a\",\n+                })\n+    public void runTests(RunInfo info) {\n+        \/\/ Repeat many times, so that we also have multiple iterations for post-warmup to potentially recompile\n+        int iters = info.isWarmUp() ? 1_000 : 50_000;\n+        for (int iter = 0; iter < iters; iter++) {\n+            \/\/ Write random values to inputs\n+            set_random(aB, aN);     \/\/ setup for both byte array and natvie\n+            set_random(aC);\n+            set_random(aS);\n+\n+            \/\/ Run all tests\n+            for (Map.Entry<String, Map<String,TestFunction>> group_entry : testGroups.entrySet()) {\n+                String group_name = group_entry.getKey();\n+                Map<String, TestFunction> group = group_entry.getValue();\n+                Object gold = null;\n+                String gold_name = \"NONE\";\n+                for (Map.Entry<String,TestFunction> entry : group.entrySet()) {\n+                    String name = entry.getKey();\n+                    TestFunction test = entry.getValue();\n+                    Object result = test.run(info.isWarmUp(), iter);\n+                    if (gold == null) {\n+                        gold = result;\n+                        gold_name = name;\n+                    } else {\n+                        checkEQ(gold, result, \"group \" + group_name + \", gold \" + gold_name + \", test \" + name);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Group 1: get int in little endian mode\n+     *\/\n+    @DontCompile\n+    static int test1R(byte[] a) {\n+      return  (a[0] & 0xff)         |\n+             ((a[1] & 0xff) << 8 )  |\n+             ((a[2] & 0xff) << 16)  |\n+             ((a[3] & 0xff) << 24);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I,  \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test1a(byte[] a) {\n+      return  (a[0] & 0xff)         |\n+             ((a[1] & 0xff) << 8 )  |\n+             ((a[2] & 0xff) << 16)  |\n+             ((a[3] & 0xff) << 24);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test1b(byte[] a) {\n+      return UNSAFE.getIntUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ false);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I,  \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test1c(byte[] a) {\n+      return (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)        |\n+            ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 8 ) |\n+            ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) << 16) |\n+            ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff) << 24);\n+    }\n+\n+    \/\/ Shuffle order test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I,  \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test1d(byte[] a) {\n+      return ((a[3] & 0xff) << 24) |\n+              (a[0] & 0xff)        |\n+             ((a[2] & 0xff) << 16) |\n+             ((a[1] & 0xff) << 8 );\n+    }\n+\n+    \/\/ Shuffle order test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I,  \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test1e(byte[] a) {\n+      return ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 8 ) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff) << 24) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) << 16) |\n+              (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff);\n+    }\n+\n+    \/\/ volatile loads can not be merged\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test1f(byte[] a) {\n+      return  (UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       |\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 8 )|\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) << 16)|\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff) << 24);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test1g(byte[] a) {\n+      return  (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 8 )|\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) << 16)|\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff) << 24);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B,  \"0\",\n+          IRNode.LOAD_UB, \"0\",\n+          IRNode.LOAD_S,  \"0\",\n+          IRNode.LOAD_US, \"0\",\n+          IRNode.LOAD_I,  \"1\",\n+          IRNode.LOAD_L,  \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test1h(long address) {\n+      return  (UNSAFE.getByte(address + 0) & 0xff)       |\n+             ((UNSAFE.getByte(address + 1) & 0xff) << 8 )|\n+             ((UNSAFE.getByte(address + 2) & 0xff) << 16)|\n+             ((UNSAFE.getByte(address + 3) & 0xff) << 24);\n+    }\n+\n+    \/**\n+     * Group 2: get long in little endian mode\n+     *\/\n+    @DontCompile\n+    static long test2R(byte[] a) {\n+      return ((long)(a[0] & 0xff)       )|\n+            (((long)(a[1] & 0xff)) << 8 )|\n+            (((long)(a[2] & 0xff)) << 16)|\n+            (((long)(a[3] & 0xff)) << 24)|\n+            (((long)(a[4] & 0xff)) << 32)|\n+            (((long)(a[5] & 0xff)) << 40)|\n+            (((long)(a[6] & 0xff)) << 48)|\n+            (((long)(a[7] & 0xff)) << 56);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"big-endian\", \"true\"})\n+    static long test2a(byte[] a) {\n+      return ((long)(a[0] & 0xff)       )|\n+            (((long)(a[1] & 0xff)) << 8 )|\n+            (((long)(a[2] & 0xff)) << 16)|\n+            (((long)(a[3] & 0xff)) << 24)|\n+            (((long)(a[4] & 0xff)) << 32)|\n+            (((long)(a[5] & 0xff)) << 40)|\n+            (((long)(a[6] & 0xff)) << 48)|\n+            (((long)(a[7] & 0xff)) << 56);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test2b(byte[] a) {\n+      return UNSAFE.getLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ false);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test2c(byte[] a) {\n+      return ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       )|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 8 )|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 16)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 24)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 32)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 40)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) << 48)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff)) << 56);\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"big-endian\", \"true\"})\n+    static long test2d(byte[] a) {\n+      return (((long)(a[3] & 0xff)) << 24)|\n+             (((long)(a[6] & 0xff)) << 48)|\n+             (((long)(a[2] & 0xff)) << 16)|\n+             (((long)(a[1] & 0xff)) << 8 )|\n+             (((long)(a[4] & 0xff)) << 32)|\n+              ((long)(a[0] & 0xff)       )|\n+             (((long)(a[5] & 0xff)) << 40)|\n+             (((long)(a[7] & 0xff)) << 56);\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test2e(byte[] a) {\n+      return ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       )|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff)) << 56)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 24)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 40)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 32)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 16)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) << 48)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 8 );\n+    }\n+\n+    \/\/ can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test2f(byte[] a) {\n+      return ((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       )|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 8 )|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 16)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 24)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 32)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 40)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) << 48)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff)) << 56);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test2g(byte[] a) {\n+      return ((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       )|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 8 )|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 16)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 24)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 32)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 40)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) << 48)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff)) << 56);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B,  \"0\",\n+          IRNode.LOAD_UB, \"0\",\n+          IRNode.LOAD_S,  \"0\",\n+          IRNode.LOAD_US, \"0\",\n+          IRNode.LOAD_I,  \"0\",\n+          IRNode.LOAD_L,  \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test2h(long address) {\n+      return  ((long)(UNSAFE.getByte(address + 0) & 0xff))       |\n+             (((long)(UNSAFE.getByte(address + 1) & 0xff)) << 8 )|\n+             (((long)(UNSAFE.getByte(address + 2) & 0xff)) << 16)|\n+             (((long)(UNSAFE.getByte(address + 3) & 0xff)) << 24)|\n+             (((long)(UNSAFE.getByte(address + 4) & 0xff)) << 32)|\n+             (((long)(UNSAFE.getByte(address + 5) & 0xff)) << 40)|\n+             (((long)(UNSAFE.getByte(address + 6) & 0xff)) << 48)|\n+             (((long)(UNSAFE.getByte(address + 7) & 0xff)) << 56);\n+    }\n+\n+    \/**\n+     * Group 3: get int in big endian mode\n+     *\/\n+    @DontCompile\n+    static int test3R(byte[] a) {\n+      return ((a[0] & 0xff) << 24) |\n+             ((a[1] & 0xff) << 16) |\n+             ((a[2] & 0xff) <<  8) |\n+              (a[3] & 0xff);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test3a(byte[] a) {\n+      return ((a[0] & 0xff) << 24) |\n+             ((a[1] & 0xff) << 16) |\n+             ((a[2] & 0xff) <<  8) |\n+              (a[3] & 0xff);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test3b(byte[] a) {\n+      return UNSAFE.getIntUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ true);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test3c(byte[] a) {\n+      return ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8) |\n+              (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff);\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test3d(byte[] a) {\n+      return  (a[3] & 0xff)        |\n+             ((a[2] & 0xff) <<  8) |\n+             ((a[1] & 0xff) << 16) |\n+             ((a[0] & 0xff) << 24);\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test3e(byte[] a) {\n+      return ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+              (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)        |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8);\n+    }\n+\n+    \/\/ Can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test3f(byte[] a) {\n+      return ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8) |\n+              (UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff);\n+    }\n+\n+    \/\/ Can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test3g(byte[] a) {\n+      return ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8) |\n+              (UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff);\n+    }\n+\n+    \/**\n+     * Group 4: get long in big endian mode\n+     *\/\n+    @DontCompile\n+    static long test4R(byte[] a) {\n+      return (((long)(a[0] & 0xff)) << 56)|\n+             (((long)(a[1] & 0xff)) << 48)|\n+             (((long)(a[2] & 0xff)) << 40)|\n+             (((long)(a[3] & 0xff)) << 32)|\n+             (((long)(a[4] & 0xff)) << 24)|\n+             (((long)(a[5] & 0xff)) << 16)|\n+             (((long)(a[6] & 0xff)) <<  8)|\n+              ((long)(a[7] & 0xff));\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test4a(byte[] a) {\n+      return (((long)(a[0] & 0xff)) << 56)|\n+             (((long)(a[1] & 0xff)) << 48)|\n+             (((long)(a[2] & 0xff)) << 40)|\n+             (((long)(a[3] & 0xff)) << 32)|\n+             (((long)(a[4] & 0xff)) << 24)|\n+             (((long)(a[5] & 0xff)) << 16)|\n+             (((long)(a[6] & 0xff)) <<  8)|\n+              ((long)(a[7] & 0xff));\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"\n+        })\n+    static long test4b(byte[] a) {\n+      return UNSAFE.getLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ true);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test4c(byte[] a) {\n+      return (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)) << 56)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 48)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 40)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 32)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 24)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 16)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) <<  8)|\n+              ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff));\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test4d(byte[] a) {\n+      return (((long)(a[0] & 0xff)) << 56)|\n+             (((long)(a[5] & 0xff)) << 16)|\n+             (((long)(a[2] & 0xff)) << 40)|\n+             (((long)(a[1] & 0xff)) << 48)|\n+             (((long)(a[4] & 0xff)) << 24)|\n+             (((long)(a[6] & 0xff)) <<  8)|\n+             (((long)(a[3] & 0xff)) << 32)|\n+              ((long)(a[7] & 0xff));\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test4e(byte[] a) {\n+      return  ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff))       |\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)) << 56)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 40)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) <<  8)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 32)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 24)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 16)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 48);\n+    }\n+\n+    \/\/ Can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test4f(byte[] a) {\n+      return (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)) << 56)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 48)|\n+             (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 40)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 32)|\n+             (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 24)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 16)|\n+             (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) <<  8)|\n+              ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff));\n+    }\n+\n+    \/**\n+     * Group 5: merge char as int\n+     *\/\n+    @DontCompile\n+    static int[] test5R(char[] a) {\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      return new int[]{i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int[] test5a(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      return new int[]{i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int[] test5b(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xffff)) << 16)|\n+                ((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xffff));\n+      int i2 =  ((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xffff))       |\n+               (((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xffff)) << 16);\n+      return new int[]{i1, i2};\n+    }\n+\n+    \/**\n+     * Group 6: merge char as long\n+     *\/\n+    @DontCompile\n+    static long[] test6R(char[] a) {\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test6a(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test6b(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0 ) & 0xffff)) << 48)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2 ) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 ) & 0xffff)) << 16)|\n+                 ((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6 ) & 0xffff));\n+      long i2 =  ((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 ) & 0xffff))       |\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 10) & 0xffff)) << 16)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 12) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 14) & 0xffff)) << 48);\n+      return new long[] {i1, i2};\n+    }\n+\n+    \/**\n+     * Group 7: merge shorts as int\n+     *\/\n+    @DontCompile\n+    static int[] test7R(short[] a) {\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      return new int[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int[] test7a(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      return new int[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int[] test7b(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xffff)) << 16)|\n+                ((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xffff));\n+      int i2 =  ((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xffff))       |\n+               (((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xffff)) << 16);\n+      return new int[] {i1, i2};\n+    }\n+\n+    \/**\n+     * Group 8: merge short as long\n+     *\/\n+    @DontCompile\n+    static long[] test8R(short[] a) {\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test8a(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test8b(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0 ) & 0xffff)) << 48)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2 ) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 ) & 0xffff)) << 16)|\n+                 ((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6 ) & 0xffff));\n+      long i2 =  ((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 ) & 0xffff))       |\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 10) & 0xffff)) << 16)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 12) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 14) & 0xffff)) << 48);\n+      return new long[] {i1, i2};\n+    }\n+\n+    \/**\n+     * Group 9: merge int as long\n+     *\/\n+    @DontCompile\n+    static long[] test9R(int[] a) {\n+      long i1 = (((long)(a[0] & 0xffffffff)) << 32)|\n+                 ((long)(a[1] & 0xffffffff));\n+      long i2 =  ((long)(a[2] & 0xffffffff))       |\n+                (((long)(a[3] & 0xffffffff)) << 32);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test9a(int[] a) {\n+      long i1 = (((long)(a[0] & 0xffffffff)) << 32)|\n+                 ((long)(a[1] & 0xffffffff));\n+      long i2 =  ((long)(a[2] & 0xffffffff))       |\n+                (((long)(a[3] & 0xffffffff)) << 32);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test9b(int[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0 ) & 0xffffffff)) << 32)|\n+                 ((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 ) & 0xffffffff));\n+      long i2 =  ((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 ) & 0xffffffff))       |\n+                (((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 12) & 0xffffffff)) << 32);\n+      return new long[] {i1, i2};\n+    }\n+\n+    \/**\n+     * Group 10: shift value is not aligned\n+     *\/\n+    @DontCompile\n+    static long[] test10R(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xff)) << 47) |          \/\/ unaligned shift\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xffff))        |\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 47);         \/\/ unaligned shift\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xffff)) << 33) |        \/\/ unaligned shift\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xffffffff)) << 30);     \/\/ unaligned shift\n+      return new long[] {i1, i2, i3, i4};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test10a(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xff)) << 47) |          \/\/ unaligned shift\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xffff))        |\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 47);         \/\/ unaligned shift\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xffff)) << 33) |        \/\/ unaligned shift\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xffffffff)) << 30);     \/\/ unaligned shift\n+      return new long[] {i1, i2, i3, i4};\n+    }\n+\n+    \/**\n+     * Group 11: mask value is not aligned\n+     *\/\n+    @DontCompile\n+    static long[] test11R(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xfe)) << 48) |          \/\/ unaligned mask\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xfffe))        |        \/\/ unaligned mask\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 48);\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xefff)) << 32) |        \/\/ unaligned mask\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xfffffff0)) << 32);     \/\/ unaligned mask\n+      return new long[] {i1, i2, i3, i4};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test11a(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xfe)) << 48) |          \/\/ unaligned mask\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xfffe))        |        \/\/ unaligned mask\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 48);\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xefff)) << 32) |        \/\/ unaligned mask\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xfffffff0)) << 32);     \/\/ unaligned mask\n+      return new long[] {i1, i2, i3, i4};\n+    }\n+\n+    \/**\n+     * Group 12: load value has other usage\n+     *\/\n+    @DontCompile\n+    static long[] test12R(byte[] aB) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] & 0xff)) << 56);\n+      return new long[] {i1, aB[7]};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test12a(byte[] aB) {\n+      byte tmp = aB[7];\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(tmp & 0xff)) << 56);\n+      return new long[] {i1, tmp};\n+    }\n+\n+    \/**\n+     * Group 13: load value is not masked\n+     *\/\n+    @DontCompile\n+    static long[] test13R(byte[] aB) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+                ((long)(aB[1] )        << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] )) << 56);\n+      return new long[] {i1, aB[7]};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"6\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test13a(byte[] aB) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+                ((long)(aB[1]        ) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] )) << 56);\n+      return new long[] {i1, aB[7]};\n+    }\n+\n+    \/**\n+     * Group 100: Mix different patterns\n+     *\/\n+    @DontCompile\n+    static long[] test100R(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] & 0xff)) << 56);\n+      long i2 = ((long)(aB[2] & 0xff))        |\n+               (((long)(aB[3] & 0xff)) << 8 ) |\n+               (((long)(aB[4] & 0xff)) << 16) |\n+               (((long)(aB[5] & 0xff)) << 24) |\n+               (((long)(aB[6] & 0xff)) << 32) |\n+               (((long)(aB[7] & 0xff)) << 40) |\n+               (((long)(aB[8] & 0xff)) << 48) |\n+               (((long)(aB[9] & 0xff)) << 56);\n+      int i3 =  (aB[10] & 0xff)        +\n+               ((aB[11] & 0xff) << 8 ) +\n+               ((aB[12] & 0xff) << 16) +\n+               ((aB[13] & 0xff) << 24);\n+      int i4 =  (aB[14] & 0xff)        |\n+               ((aB[15] & 0xff) << 8 ) |\n+               ((aB[16] & 0xff) << 16) |\n+               ((aB[17] & 0xff) << 24);\n+      int i5 = (UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 20) & 0xff)        |  \/\/ it can be merged\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 21) & 0xff) << 8 ) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 22) & 0xff) << 16) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 23) & 0xff) << 24);\n+      long i6 = (((long)(aC[0] & 0xffff)) << 48)|\n+                (((long)(aC[1] & 0xffff)) << 32)|\n+                (((long)(aC[2] & 0xffff)) << 16)|\n+                 ((long)(aC[3] & 0xffff));\n+      long i7 =  ((long)(aC[4] & 0xffff))       |\n+                (((long)(aC[5] & 0xffff)) << 16)|\n+                (((long)(aC[6] & 0xffff)) << 32)|\n+                (((long)(aC[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2, i3, i4, i5, i6, i7};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"13\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test100a(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] & 0xff)) << 56);\n+      long i2 = ((long)(aB[2] & 0xff))        |\n+               (((long)(aB[3] & 0xff)) << 8 ) |\n+               (((long)(aB[4] & 0xff)) << 16) |\n+               (((long)(aB[5] & 0xff)) << 24) |\n+               (((long)(aB[6] & 0xff)) << 32) |\n+               (((long)(aB[7] & 0xff)) << 40) |\n+               (((long)(aB[8] & 0xff)) << 48) |\n+               (((long)(aB[9] & 0xff)) << 56);\n+      int i3 =  (aB[10] & 0xff)        +\n+               ((aB[11] & 0xff) << 8 ) +\n+               ((aB[12] & 0xff) << 16) +\n+               ((aB[13] & 0xff) << 24);\n+      int i4 =  (aB[14] & 0xff)        |     \/\/ it can be merged\n+               ((aB[15] & 0xff) << 8 ) |\n+               ((aB[16] & 0xff) << 16) |\n+               ((aB[17] & 0xff) << 24);\n+      int i5 = (UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 20) & 0xff)        |  \/\/ it can be merged\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 21) & 0xff) << 8 ) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 22) & 0xff) << 16) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 23) & 0xff) << 24);\n+      long i6 = (((long)(aC[0] & 0xffff)) << 48)|\n+                (((long)(aC[1] & 0xffff)) << 32)|\n+                (((long)(aC[2] & 0xffff)) << 16)|\n+                 ((long)(aC[3] & 0xffff));\n+      long i7 =  ((long)(aC[4] & 0xffff))       |\n+                (((long)(aC[5] & 0xffff)) << 16)|\n+                (((long)(aC[6] & 0xffff)) << 32)|\n+                (((long)(aC[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2, i3, i4, i5, i6, i7};\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeLoads.java","additions":1889,"deletions":0,"binary":false,"changes":1889,"status":"added"},{"patch":"@@ -100,1 +100,1 @@\n-    AFTER_MERGE_STORES(\"After Merge Stores\"),\n+    AFTER_MERGE_MEMOPS(\"After Merge Memops\"),\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompilePhase.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    private static void checkEQ(Object a, Object b, String context) {\n+    public static void checkEQ(Object a, Object b, String context) {\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/verify\/Verify.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}