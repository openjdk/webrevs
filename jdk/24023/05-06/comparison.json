{"files":[{"patch":"@@ -1937,1 +1937,1 @@\n-  static Node* by_pass_i2l(const LoadNode* load);\n+  static const Node* by_pass_i2l(const LoadNode* load);\n@@ -1978,1 +1978,1 @@\n-Node* MergePrimitiveLoads::by_pass_i2l(const LoadNode* l) {\n+const Node* MergePrimitiveLoads::by_pass_i2l(const LoadNode* l) {\n@@ -1982,1 +1982,1 @@\n-    return (Node*)l;\n+    return l;\n@@ -2009,1 +2009,1 @@\n-  Node* check = by_pass_i2l(_load);\n+  const Node* check = by_pass_i2l(_load);\n@@ -2017,1 +2017,1 @@\n-  Node* check = by_pass_i2l(load);\n+  const Node* check = by_pass_i2l(load);\n@@ -2246,11 +2246,1 @@\n-  \/\/ Check 1st element if it has last_op flag\n-  if (array[0]->last_op()) {\n-    if ((array[0]->_or->Opcode() == Op_OrI && bytes != 4) ||\n-        (array[0]->_or->Opcode() == Op_OrL && bytes != 8)) {\n-      \/\/ The merged load can not cover all bits of result value\n-      return;\n-    }\n-    last_op_index = 0;\n-  }\n-\n-  for (int i = 1; i < collected; i++) {\n+  for (int i = 0; i < collected; i++) {\n@@ -2261,8 +2251,10 @@\n-    MemoryAdjacentStatus adjacent = get_adjacent_load_status(array[i-1]->_load, info->_load);\n-    if (adjacent == NotAdjacent) {\n-      return;\n-    } else if (order == Unknown) {\n-      order = adjacent;\n-    } else if (adjacent != order) {\n-      \/\/ Different adjacent order\n-      return;\n+    if (i > 0) {\n+      MemoryAdjacentStatus adjacent = get_adjacent_load_status(array[i-1]->_load, info->_load);\n+      if (adjacent == NotAdjacent) {\n+        return;\n+      } else if (order == Unknown) {\n+        order = adjacent;\n+      } else if (adjacent != order) {\n+        \/\/ Different adjacent order\n+        return;\n+      }\n@@ -2333,0 +2325,9 @@\n+#ifdef ASSERT\n+  if (is_trace_basic()) {\n+    tty->print_cr(\"[TraceMergeLoads]: dump final merge info list, collected: %d\", collected);\n+    for (int i=0; i < merge_list.length(); i++) {\n+      MergeLoadInfo* info = merge_list.at(i);\n+      info->dump();\n+    }\n+  }\n+#endif\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":25,"deletions":24,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -981,1 +981,1 @@\n-Node* Node::find_out_with(int opcode1, int opcode2) {\n+Node* Node::find_out_with(int opcode1, int opcode2) const {\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -509,1 +509,1 @@\n-  Node* find_out_with(int opcode1, int opcode2);\n+  Node* find_out_with(int opcode1, int opcode2) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    int[] aI = new int[RANGE];\n@@ -99,0 +100,2 @@\n+        testGroups.get(\"test1\").put(\"test1f\", (_,_) -> { return test1f(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1g\", (_,_) -> { return test1g(aB.clone()); });\n@@ -108,0 +111,2 @@\n+        testGroups.get(\"test2\").put(\"test2f\", (_,_) -> { return test2f(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2g\", (_,_) -> { return test2g(aB.clone()); });\n@@ -115,0 +120,4 @@\n+        testGroups.get(\"test3\").put(\"test3d\", (_,_) -> { return test3d(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3e\", (_,_) -> { return test3e(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3f\", (_,_) -> { return test3f(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3g\", (_,_) -> { return test3g(aB.clone()); });\n@@ -122,0 +131,3 @@\n+        testGroups.get(\"test4\").put(\"test4d\", (_,_) -> { return test4d(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4e\", (_,_) -> { return test4e(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4f\", (_,_) -> { return test4f(aB.clone()); });\n@@ -146,0 +158,16 @@\n+\n+        \/\/ Merge int as long\n+        testGroups.put(\"test9\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test9\").put(\"test9R\", (_,_) -> { return test9R(aI.clone()); });\n+        testGroups.get(\"test9\").put(\"test9a\", (_,_) -> { return test9a(aI.clone()); });\n+        testGroups.get(\"test9\").put(\"test9b\", (_,_) -> { return test9b(aI.clone()); });\n+\n+        \/\/ Shift value is not aligned\n+        testGroups.put(\"test10\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test10\").put(\"test10R\", (_,_) -> { return test10R(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+        testGroups.get(\"test10\").put(\"test10a\", (_,_) -> { return test10a(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+\n+        \/\/ Mask value is not aligned\n+        testGroups.put(\"test11\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test11\").put(\"test11R\", (_,_) -> { return test11R(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+        testGroups.get(\"test11\").put(\"test11a\", (_,_) -> { return test11a(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n@@ -166,0 +194,6 @@\n+    static void set_random(int[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = RANDOM.nextInt();\n+        }\n+    }\n+\n@@ -172,0 +206,2 @@\n+                 \"test1f\",\n+                 \"test1g\",\n@@ -178,0 +214,2 @@\n+                 \"test2f\",\n+                 \"test2g\",\n@@ -182,0 +220,4 @@\n+                 \"test3d\",\n+                 \"test3e\",\n+                 \"test3f\",\n+                 \"test3g\",\n@@ -186,0 +228,3 @@\n+                 \"test4d\",\n+                 \"test4e\",\n+                 \"test4f\",\n@@ -198,0 +243,7 @@\n+\n+                 \"test9a\",\n+                 \"test9b\",\n+\n+                 \"test10a\",\n+\n+                 \"test11a\",\n@@ -312,0 +364,1 @@\n+    \/\/ Shuffle order test\n@@ -341,0 +394,1 @@\n+    \/\/ Shuffle order test\n@@ -370,0 +424,35 @@\n+    \/\/ volatile loads can not be merged\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test1f(byte[] a) {\n+      return  (UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       |\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 8 )|\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) << 16)|\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff) << 24);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test1g(byte[] a) {\n+      return  (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 8 )|\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) << 16)|\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff) << 24);\n+    }\n+\n@@ -465,0 +554,1 @@\n+    \/\/ Shuffle test\n@@ -498,0 +588,1 @@\n+    \/\/ Shuffle test\n@@ -531,0 +622,43 @@\n+    \/\/ can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test2f(byte[] a) {\n+      return ((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       )|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 8 )|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 16)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 24)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 32)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 40)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) << 48)|\n+            (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff)) << 56);\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test2g(byte[] a) {\n+      return ((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       )|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 8 )|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 16)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 24)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 32)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 40)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) << 48)|\n+            (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff)) << 56);\n+    }\n+\n@@ -660,0 +794,142 @@\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test3d(byte[] a) {\n+      return  (a[3] & 0xff)        |\n+             ((a[2] & 0xff) <<  8) |\n+             ((a[1] & 0xff) << 16) |\n+             ((a[0] & 0xff) << 24);\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"3\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_I, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static int test3e(byte[] a) {\n+      return ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+              (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)        |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8);\n+    }\n+\n+    \/\/ Can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test3f(byte[] a) {\n+      return ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+             ((UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8) |\n+              (UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff);\n+    }\n+\n+    \/\/ Can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test3g(byte[] a) {\n+      return ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+             ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8) |\n+              (UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff);\n+    }\n+\n@@ -800,0 +1076,137 @@\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test4d(byte[] a) {\n+      return (((long)(a[0] & 0xff)) << 56)|\n+             (((long)(a[5] & 0xff)) << 16)|\n+             (((long)(a[2] & 0xff)) << 40)|\n+             (((long)(a[1] & 0xff)) << 48)|\n+             (((long)(a[4] & 0xff)) << 24)|\n+             (((long)(a[6] & 0xff)) <<  8)|\n+             (((long)(a[3] & 0xff)) << 32)|\n+              ((long)(a[7] & 0xff));\n+    }\n+\n+    \/\/ Shuffle test\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\", \"riscv64\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"1\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"true\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIfPlatform   = {\"riscv64\", \"true\"},\n+        applyIfAnd = {\"UseUnalignedAccesses\", \"true\", \"UseZbb\", \"false\"})\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static long test4e(byte[] a) {\n+      return  ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff))       |\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)) << 56)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 40)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) <<  8)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 32)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 24)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 16)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 48);\n+    }\n+\n+    \/\/ Can not merge volatile load\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.REVERSE_BYTES_L, \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test4f(byte[] a) {\n+      return (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)) << 56)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 48)|\n+             (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 40)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 32)|\n+             (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 24)|\n+             (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 16)|\n+             (((long)(UNSAFE.getByteVolatile(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) <<  8)|\n+              ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff));\n+    }\n+\n@@ -1023,0 +1436,203 @@\n+\n+    \/**\n+     * Group 9: merge int as long\n+     *\/\n+    @DontCompile\n+    static long[] test9R(int[] a) {\n+      long i1 = (((long)(a[0] & 0xffffffff)) << 32)|\n+                 ((long)(a[1] & 0xffffffff));\n+      long i2 =  ((long)(a[2] & 0xffffffff))       |\n+                (((long)(a[3] & 0xffffffff)) << 32);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test9a(int[] a) {\n+      long i1 = (((long)(a[0] & 0xffffffff)) << 32)|\n+                 ((long)(a[1] & 0xffffffff));\n+      long i2 =  ((long)(a[2] & 0xffffffff))       |\n+                (((long)(a[3] & 0xffffffff)) << 32);\n+      return new long[] {i1, i2};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_S_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\"\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test9b(int[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0 ) & 0xffffffff)) << 32)|\n+                 ((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 ) & 0xffffffff));\n+      long i2 =  ((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 ) & 0xffffffff))       |\n+                (((long)(UNSAFE.getInt(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 12) & 0xffffffff)) << 32);\n+      return new long[] {i1, i2};\n+    }\n+\n+    \/**\n+     * Group 10: shift value is not aligned\n+     *\/\n+    @DontCompile\n+    static long[] test10R(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xff)) << 47) |          \/\/ unaligned shift\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xffff))        |\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 47);         \/\/ unaligned shift\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xffff)) << 33) |        \/\/ unaligned shift\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xffffffff)) << 30);     \/\/ unaligned shift\n+      return new long[] {i1, i2, i3, i4};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test10a(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xff)) << 47) |          \/\/ unaligned shift\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xffff))        |\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 47);         \/\/ unaligned shift\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xffff)) << 33) |        \/\/ unaligned shift\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xffffffff)) << 30);     \/\/ unaligned shift\n+      return new long[] {i1, i2, i3, i4};\n+    }\n+\n+    \/**\n+     * Group 11: mask value is not aligned\n+     *\/\n+    @DontCompile\n+    static long[] test11R(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xfe)) << 48) |          \/\/ unaligned mask\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xfffe))        |        \/\/ unaligned mask\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 48);\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xefff)) << 32) |        \/\/ unaligned mask\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xfffffff0)) << 32);     \/\/ unaligned mask\n+      return new long[] {i1, i2, i3, i4};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"8\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test11a(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[4]  & 0xff))        |\n+               (((long)(aB[5]  & 0xff)) << 8 ) |\n+               (((long)(aB[6]  & 0xff)) << 16) |\n+               (((long)(aB[7]  & 0xff)) << 24) |\n+               (((long)(aB[8]  & 0xff)) << 32) |\n+               (((long)(aB[9]  & 0xff)) << 40) |\n+               (((long)(aB[10] & 0xfe)) << 48) |          \/\/ unaligned mask\n+               (((long)(aB[11] & 0xff)) << 56);\n+\n+      long i2 = ((long)(aC[0]  & 0xfffe))        |        \/\/ unaligned mask\n+               (((long)(aC[1]  & 0xffff)) << 16) |\n+               (((long)(aC[2]  & 0xffff)) << 32) |\n+               (((long)(aC[3]  & 0xffff)) << 48);\n+\n+      long i3 = ((long)(aS[0]  & 0xffff))        |\n+               (((long)(aS[1]  & 0xffff)) << 16) |\n+               (((long)(aS[2]  & 0xefff)) << 32) |        \/\/ unaligned mask\n+               (((long)(aS[3]  & 0xffff)) << 48);\n+\n+      long i4 = ((long)(aI[0]  & 0xffffffff))        |\n+               (((long)(aI[1]  & 0xfffffff0)) << 32);     \/\/ unaligned mask\n+      return new long[] {i1, i2, i3, i4};\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeLoads.java","additions":616,"deletions":0,"binary":false,"changes":616,"status":"modified"}]}