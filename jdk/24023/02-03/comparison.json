{"files":[{"patch":"@@ -1862,1 +1862,1 @@\n- * And we can get some properties like shift and uncommon usage from it.\n+ * And we can get some properties like shift and last_op from it.\n@@ -1864,1 +1864,1 @@\n- * Note: OrNode may be shared\n+ * Note: OrNode can be shared in different MergeLoadInfo\n@@ -1872,1 +1872,0 @@\n-  bool _has_uncommon_usage;\n@@ -1876,3 +1875,1 @@\n-                                                           _has_uncommon_usage(false), _last_op(false) {}\n-  void set_has_uncommon_usage(bool v) { _has_uncommon_usage = v; }\n-  bool has_uncommon_usage()     const { return _has_uncommon_usage; }\n+                                                           _last_op(false) {}\n@@ -1884,1 +1881,1 @@\n-    tty->print_cr(\"MergeLoadInfo: load: %d, or: %d, shift: %d, has_uncommon_usage: %s, last_op: %s\",\n+    tty->print_cr(\"MergeLoadInfo: load: %d, or: %d, shift: %d, last_op: %s\",\n@@ -1886,1 +1883,0 @@\n-                        _has_uncommon_usage ? \"true\" : \"false\",\n@@ -1931,3 +1927,0 @@\n-  \/\/ Extract value from merged load or value for uncommon trap\n-  template <typename TypeClass>\n-  void extract_value_for_uncommon_trap(Node* merged, MergeLoadInfo* info);\n@@ -2014,16 +2007,3 @@\n-  switch(check->outcnt()) {\n-    case 1: {\n-      int opc = check->unique_out()->Opcode();\n-      return opc == Op_OrI || opc == Op_OrL;\n-    }\n-    case 2: {\n-      \/\/ It can has an optional output to uncommon trap\n-      Node *call = check->find_out_with(Op_CallStaticJava);\n-      if (call == nullptr || !call->as_CallStaticJava()->is_uncommon_trap()) {\n-        return false;\n-      }\n-      return check->find_out_with(Op_OrI, Op_OrL) != nullptr;\n-    }\n-    default:\n-      return false;\n-  }\n+  \/\/ The candidate load has unique out which is OrI\/OrL node\n+  return check->outcnt() == 1 &&\n+         check->find_out_with(Op_OrI, Op_OrL) != nullptr;\n@@ -2037,1 +2017,0 @@\n-  bool has_uncommon_trap_usage = false;\n@@ -2046,0 +2025,1 @@\n+        \/\/ match pattern: (Or (Load ..) ..)\n@@ -2054,7 +2034,0 @@\n-      case Op_CallStaticJava:\n-        if (!out->as_CallStaticJava()->is_uncommon_trap()) {\n-          \/\/ Only uncommon trap usage is accepted\n-          return nullptr;\n-        }\n-        has_uncommon_trap_usage = true;\n-        break;\n@@ -2064,0 +2037,1 @@\n+          \/\/ match pattern: (Or (LShift (Load ..) ConI) ..)\n@@ -2065,1 +2039,1 @@\n-          if (shift_oper->outcnt() != 1 ||                    \/\/ Expect only one usage to Or node\n+          if (shift_oper->outcnt() != 1 ||                  \/\/ Expect only one usage to Or node\n@@ -2097,1 +2071,0 @@\n-  info->set_has_uncommon_usage(has_uncommon_trap_usage);\n@@ -2164,4 +2137,0 @@\n-      }\n-      if (out == nullptr || (out->Opcode() == Op_CallStaticJava && out->as_CallStaticJava()->is_uncommon_trap())) {\n-        \/\/ Skip null or uncommon trap\n-        continue;\n@@ -2286,1 +2255,1 @@\n-      if (last_op_index >= 0) {\n+      if (last_op_index >= 0 && array[last_op_index]->_or != info->_or) {\n@@ -2342,0 +2311,1 @@\n+\n@@ -2405,10 +2375,0 @@\n-  \/\/ extract value for uncommon path\n-  for (int i=0; i<merge_list.length(); i++) {\n-    if (merge_list.at(i)->has_uncommon_usage()) {\n-      if (merge_size == 8) {\n-        extract_value_for_uncommon_trap<TypeLong>(replace, merge_list.at(i));\n-      } else {\n-        extract_value_for_uncommon_trap<TypeInt>(replace, merge_list.at(i));\n-      }\n-    }\n-  }\n@@ -2422,52 +2382,0 @@\n-template <typename TypeClass>\n-void MergePrimitiveLoads::extract_value_for_uncommon_trap(Node* merged, MergeLoadInfo* info) {\n-  assert(merged->bottom_type()->is_int() || merged->bottom_type()->is_long(), \"sanity\");\n-  int merged_bits = merged->bottom_type()->is_int() ? 32 : 64;\n-  int load_bits = info->_load->memory_size() * BitsPerByte;\n-  Node* value = merged;\n-  if (info->_load->is_unsigned()) {\n-    \/\/ RShift and Mask\n-    \/\/ merged value: |.........|value|........|\n-    \/\/                  l1      _load   l2\n-    \/\/  value is unsianged value from _load, _shift is l2\n-    \/\/  extract:  (merged >> l2) & ((1 << load_bits) - 1)\n-    \/\/\n-    if (info->_shift > 0) {\n-      value = make_urshift<TypeClass>(value, _phase->intcon(info->_shift));\n-    }\n-    if ((load_bits + info->_shift) < merged_bits) {\n-      assert(load_bits < 32, \"sanity\");\n-      int mask = (1 << load_bits) - 1;\n-      value = make_and<TypeClass>(value, _phase->intcon(mask));\n-    }\n-  } else {\n-    \/\/ LShift and RShift\n-    \/\/\n-    \/\/ merged value: |.........|value|........|\n-    \/\/                  l1      _load   l2\n-    \/\/  value is igned value from _load, _shift is l2\n-    \/\/  extract:  (merged << l1) >> (merged_bits - load_bits)\n-    \/\/\n-    if ((info->_load->memory_size() + info->_shift) < merged_bits) {\n-      value = LShiftNode::make(value, _phase->intcon(merged_bits - info->_shift - info->_load->memory_size()),\n-                               merged_bits == 32 ? T_INT: T_LONG);\n-    }\n-    value = make_rshift<TypeClass>(value, _phase->intcon(merged_bits - load_bits));\n-  }\n-  if (merged_bits == 64) {\n-    \/\/ need L2I\n-    value = new ConvL2INode(value);\n-  }\n-  assert(value != nullptr, \"sanity\");\n-\n-  \/\/ Replace the edge of uncommon trap\n-  Node * loaded = by_pass_i2l(info->_load);\n-  for (DUIterator_Last imin, i = loaded->last_outs(imin); i >= imin; --i) {\n-    Node* out = loaded->last_out(i);\n-    if (out->is_CallStaticJava()) {\n-      out->replace_edge(loaded, value, _phase);\n-    }\n-  }\n-  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] extract value for uncommon trap:\"); _load->dump(); value->dump(); tty->cr(); })\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":12,"deletions":104,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -405,12 +405,0 @@\n-template <typename TypeClass>\n-Node* make_rshift(Node* a, Node* b);\n-\n-template <>\n-inline Node* make_rshift<TypeLong>(Node* a, Node* b) {\n-  return new RShiftLNode(a, b);\n-}\n-\n-template <>\n-inline Node* make_rshift<TypeInt>(Node* a, Node* b) {\n-  return new RShiftINode(a, b);\n-}\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -54,0 +54,2 @@\n+    char[] aC = new char[RANGE];\n+    short[] aS = new short[RANGE];\n@@ -101,0 +103,24 @@\n+\n+        \/\/ Merge char as int\n+        testGroups.put(\"test5\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test5\").put(\"test5R\", (_,_) -> { return test5R(aC.clone()); });\n+        testGroups.get(\"test5\").put(\"test5a\", (_,_) -> { return test5a(aC.clone()); });\n+        testGroups.get(\"test5\").put(\"test5b\", (_,_) -> { return test5b(aC.clone()); });\n+\n+        \/\/ Merge char as long\n+        testGroups.put(\"test6\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test6\").put(\"test6R\", (_,_) -> { return test6R(aC.clone()); });\n+        testGroups.get(\"test6\").put(\"test6a\", (_,_) -> { return test6a(aC.clone()); });\n+        testGroups.get(\"test6\").put(\"test6b\", (_,_) -> { return test6b(aC.clone()); });\n+\n+        \/\/ Merge short as int\n+        testGroups.put(\"test7\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test7\").put(\"test7R\", (_,_) -> { return test7R(aS.clone()); });\n+        testGroups.get(\"test7\").put(\"test7a\", (_,_) -> { return test7a(aS.clone()); });\n+        testGroups.get(\"test7\").put(\"test7b\", (_,_) -> { return test7b(aS.clone()); });\n+\n+        \/\/ Merge short as long\n+        testGroups.put(\"test8\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test8\").put(\"test8R\", (_,_) -> { return test8R(aS.clone()); });\n+        testGroups.get(\"test8\").put(\"test8a\", (_,_) -> { return test8a(aS.clone()); });\n+        testGroups.get(\"test8\").put(\"test8b\", (_,_) -> { return test8b(aS.clone()); });\n@@ -109,0 +135,11 @@\n+    static void set_random(char[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (char)RANDOM.nextInt();\n+        }\n+    }\n+\n+    static void set_random(short[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (short)RANDOM.nextInt();\n+        }\n+    }\n@@ -121,1 +158,9 @@\n-                 \"test4c\"\n+                 \"test4c\",\n+                 \"test5a\",\n+                 \"test5b\",\n+                 \"test6a\",\n+                 \"test6b\",\n+                 \"test7a\",\n+                 \"test7b\",\n+                 \"test8a\",\n+                 \"test8b\",\n@@ -129,0 +174,2 @@\n+            set_random(aC);\n+            set_random(aS);\n@@ -233,2 +280,1 @@\n-     * Group 1\n-     *   get int in little endian mode\n+     * Group 1: get int in little endian mode\n@@ -290,2 +336,1 @@\n-     * Group 2\n-     *   get long in little endian mode\n+     * Group 2: get long in little endian mode\n@@ -359,2 +404,1 @@\n-     * Group 3\n-     *   get int in big endian mode\n+     * Group 3: get int in big endian mode\n@@ -416,2 +460,1 @@\n-     * Group 4\n-     *   get long in big endian mode\n+     * Group 4: get long in big endian mode\n@@ -483,0 +526,180 @@\n+\n+    \/**\n+     * Group 5: merge char as int\n+     *\/\n+    @DontCompile\n+    static Object[] test5R(char[] a) {\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      int[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test5a(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      int[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test5b(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xffff)) << 16)|\n+                ((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xffff));\n+      int i2 =  ((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xffff))       |\n+               (((int)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xffff)) << 16);\n+      int[] ret = {i1,i2};\n+      return new Object[]{ret};\n+    }\n+\n+    \/**\n+     * Group 6: merge char as long\n+     *\/\n+    @DontCompile\n+    static Object[] test6R(char[] a) {\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      long[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test6a(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      long[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test6b(char[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0 ) & 0xffff)) << 48)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2 ) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 ) & 0xffff)) << 16)|\n+                 ((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6 ) & 0xffff));\n+      long i2 =  ((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 ) & 0xffff))       |\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 10) & 0xffff)) << 16)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 12) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getChar(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 14) & 0xffff)) << 48);\n+      long[] ret = {i1,i2};\n+      return new Object[]{ret};\n+    }\n+\n+    \/**\n+     * Group 7: merge shorts as int\n+     *\/\n+    @DontCompile\n+    static Object[] test7R(short[] a) {\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      int[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test7a(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(a[0] & 0xffff)) << 16)|\n+                ((int)(a[1] & 0xffff));\n+      int i2 =  ((int)(a[2] & 0xffff))       |\n+               (((int)(a[3] & 0xffff)) << 16);\n+      int[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test7b(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      int i1 = (((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xffff)) << 16)|\n+                ((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xffff));\n+      int i2 =  ((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xffff))       |\n+               (((int)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xffff)) << 16);\n+      int[] ret = {i1,i2};\n+      return new Object[]{ret};\n+    }\n+\n+    \/**\n+     * Group 8: merge short as long\n+     *\/\n+    @DontCompile\n+    static Object[] test8R(short[] a) {\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      long[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test8a(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(a[0] & 0xffff)) << 48)|\n+                (((long)(a[1] & 0xffff)) << 32)|\n+                (((long)(a[2] & 0xffff)) << 16)|\n+                 ((long)(a[3] & 0xffff));\n+      long i2 =  ((long)(a[4] & 0xffff))       |\n+                (((long)(a[5] & 0xffff)) << 16)|\n+                (((long)(a[6] & 0xffff)) << 32)|\n+                (((long)(a[7] & 0xffff)) << 48);\n+      long[] ret = {i1, i2};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test8b(short[] a) {\n+      \/* only one group which access array in platform order can be merged *\/\n+      long i1 = (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0 ) & 0xffff)) << 48)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2 ) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4 ) & 0xffff)) << 16)|\n+                 ((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6 ) & 0xffff));\n+      long i2 =  ((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 8 ) & 0xffff))       |\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 10) & 0xffff)) << 16)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 12) & 0xffff)) << 32)|\n+                (((long)(UNSAFE.getShort(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 14) & 0xffff)) << 48);\n+      long[] ret = {i1,i2};\n+      return new Object[]{ret};\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeLoads.java","additions":232,"deletions":9,"binary":false,"changes":241,"status":"modified"}]}