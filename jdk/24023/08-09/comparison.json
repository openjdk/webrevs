{"files":[{"patch":"@@ -31,0 +31,1 @@\n+#include \"opto\/mempointer.hpp\"\n@@ -35,0 +36,1 @@\n+#include \"opto\/traceMergeStoresTag.hpp\"\n@@ -771,0 +773,547 @@\n+\/* MergeLoads optimization\n+ * Optimize multiple loads into a merged load, like below java code:\n+ *\n+ *      return ((array[offset    ] & 0xff) << 24)\n+ *           | ((array[offset + 1] & 0xff) << 16)\n+ *           | ((array[offset + 2] & 0xff) <<  8)\n+ *           | ((array[offset + 3] & 0xff)      );\n+ *\n+ * The C2 IR graph is like:\n+ *\n+ *       Mem\n+ *        |---------+---------+----------+\n+ *        |         |         |          |\n+ *      LoadB1    LoadB2    LoadB3     LoadB4\n+ *        |         |         |          |\n+ *        |       LShift    LShift     LShift\n+ *        |         |         |          |\n+ *        +-> Or1 <-+         |          |\n+ *             |              |          |\n+ *             +---> Or2 <----+          |\n+ *                    |                  |\n+ *                    +-----> Or3 <------+\n+ *\n+ * It is transformed as a merged LoadI, which replace the Or3 node.\n+ *\n+ * Because array value is logical and with constant 0xff\/0xffff, LoadS\/LoadB is converted to an unsigned load\n+ * and 'And' node is eliminated in previous IGVN phase. Please check AndINode::Ideal for reference\n+ *\n+ *\/\n+class MergePrimitiveLoads;\n+\n+\/*\n+ * A LoadNode and a combine Node pair which represent an item for merging,\n+ * now only OrI\/OrL are supported as combine operator, in future we can extend to add\/xor\n+ *\n+ * Note: combine operator can be shared in different MergeLoadInfo\n+ *\/\n+class MergeLoadInfo : ResourceObj {\n+  friend MergePrimitiveLoads;\n+private:\n+  LoadNode* const    _load;\n+  Node*     const _combine;\n+  int       const   _shift;\n+public:\n+  MergeLoadInfo(LoadNode* load, Node* combine, int shift) : _load(load), _combine(combine), _shift(shift) {}\n+\n+#ifdef ASSERT\n+  void dump() {\n+    tty->print_cr(\"MergeLoadInfo: load: %d, combine: %d, shift: %d\",\n+                  _load->_idx, _combine->_idx, _shift);\n+  }\n+#endif\n+};\n+\n+typedef GrowableArray<MergeLoadInfo*> MergeLoadInfoList;\n+\n+class MergePrimitiveLoads : public StackObj {\n+  \/\/ The adjacent status of 2 loads\n+  enum MemoryAdjacentStatus {\n+    Unknown,            \/\/ Initial state\n+    LowToHigh,          \/\/ Adjacent and first load access low address\n+    HighToLow,          \/\/ Adjacent and first load access high address\n+    NotAdjacent         \/\/ Not adjacent\n+  };\n+\n+private:\n+  PhaseGVN* const      _phase;\n+  Node*     const    _combine;\n+  MemoryAdjacentStatus _order;\n+  bool _require_reverse_bytes;    \/\/ Do we need add a ReverseBytes for merged load\n+\n+  NOT_PRODUCT( const CHeapBitMap &_trace_tags; )\n+\n+public:\n+  MergePrimitiveLoads(PhaseGVN* phase, Node* combine) :\n+    _phase(phase), _combine(combine), _order(Unknown), _require_reverse_bytes(false)\n+    NOT_PRODUCT( COMMA _trace_tags(Compile::current()->directive()->trace_merge_loads_tags()) )\n+  {}\n+\n+  \/\/ try merge adjacent loads, and return replace node for origin _combine\n+  Node* run();\n+\n+private:\n+  \/\/ Detect the embedding combine node is a candidate for merging loads\n+  bool is_merged_load_candidate( ) const;\n+  \/\/ Check other_load and load are compatible\n+  bool is_compatible_load(const LoadNode* other_load, const LoadNode* load) const;\n+  \/\/ From the seed load to collect load items for merging\n+  void collect_merge_list(MergeLoadInfoList& merge_list, const LoadNode* load);\n+  \/\/ Construct merge information item from input load\n+  MergeLoadInfo* merge_load_info(LoadNode* load) const;\n+  \/\/ Make the merged load and optional ReverseByte for replace\n+  Node* make_merged_load(const MergeLoadInfoList& merge_list);\n+\n+  \/\/ Helper methods for merge loads optimization\n+  static bool is_supported_load_opcode(int opcode);\n+  static bool is_supported_combine_opcode(int opcode);\n+  \/\/ Check the two combine operator Nodes can be reachable from one to another, and intermediate nodes has the same type\n+  static bool is_reachable_combine_nodes(const Node* from, const Node* to);\n+  MemoryAdjacentStatus get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const;\n+  \/\/ Go through ConvI2L which is unique output of input node\n+  static const Node* by_pass_i2l(const Node* n);\n+\n+#ifndef PRODUCT\n+  \/\/ Access to TraceMergeLoads tags\n+  bool is_trace(TraceMergeLoads::Tag tag) const {\n+    return _trace_tags.at(tag);\n+  }\n+\n+  bool is_trace_basic() const {\n+    return is_trace(TraceMergeLoads::Tag::BASIC);\n+  }\n+\n+  bool is_trace_pointer_parsing() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_PARSING);\n+  }\n+\n+  bool is_trace_pointer_aliasing() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_ALIASING);\n+  }\n+\n+  bool is_trace_pointer_adjacency() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_ADJACENCY);\n+  }\n+\n+  bool is_trace_success() const {\n+    return is_trace(TraceMergeLoads::Tag::SUCCESS);\n+  }\n+#endif\n+};\n+\n+bool MergePrimitiveLoads::is_supported_load_opcode(int opc) {\n+  \/\/ Check for B\/S\/C\/I\n+  if (opc != Op_LoadB && opc != Op_LoadUB &&\n+      opc != Op_LoadS && opc != Op_LoadUS &&\n+      opc != Op_LoadI) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool MergePrimitiveLoads::is_supported_combine_opcode(int opc) {\n+  return opc == Op_OrI || opc == Op_OrL;\n+}\n+\n+\/\/ Go through ConvI2L which is unique output of input node\n+const Node* MergePrimitiveLoads::by_pass_i2l(const Node* n) {\n+  if (n != nullptr && n->outcnt() == 1 && n->unique_out()->Opcode() == Op_ConvI2L) {\n+    return n->unique_out();\n+  } else {\n+    return n;\n+  }\n+};\n+\n+\/*\n+ * Check the _combine operator can be a candidate to trigger merge loads.\n+ * The candidate load has the pattern:\n+ *\n+ * Load -> OrI\/OrL\n+ *  It has no LShift usage and the And node is optimized out in previous optimization\n+ *\n+ *  The reference java code snippets are:\n+ *              ...\n+ *            | (((long) array[offset + 5] & 0xff) << 16)\n+ *            | (((long) array[offset + 6] & 0xff) << 8 )\n+ *            | (((long) array[offset + 7] & 0xff)      );                     <----- candidate\n+ *\n+ *              ((UNSAFE.getByte(array, address    ) & 0xff)      )            <----- candidate\n+ *            | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n+ *            | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n+ *            | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n+ *\/\n+bool MergePrimitiveLoads::is_merged_load_candidate() const {\n+  assert(is_supported_combine_opcode(_combine->Opcode()), \"sanity\");\n+  const Node* check = by_pass_i2l(_combine);\n+  if (check->outcnt() == 1 && check->unique_out()->Opcode() == _combine->Opcode()) {\n+    \/\/ It's in the middle of combine operators\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Construct merge information item from input load\n+MergeLoadInfo* MergePrimitiveLoads::merge_load_info(LoadNode* load) const {\n+  const Node* check = by_pass_i2l(load);\n+  Node* combine_oper = nullptr;\n+  int shift = -1;\n+\n+  \/\/ Check the Load node has the pattern \"(Or (LShift (Load .. ) ConI) ..)\" or \"(Or (Load ..) ..)\"\n+  for (DUIterator_Fast imax, iter = check->fast_outs(imax); iter < imax; iter++) {\n+    Node *out = check->fast_out(iter);\n+    switch (out->Opcode()) {\n+      case Op_OrI:\n+      case Op_OrL: {\n+        \/\/ match pattern: (Or (Load ..) ..)\n+        if (combine_oper == nullptr) {\n+          combine_oper = out;\n+          shift = 0;\n+        } else {\n+          \/\/ Too much Or usages\n+          return nullptr;\n+        }\n+        break;\n+      }\n+      case Op_LShiftI:\n+      case Op_LShiftL: {\n+        \/\/ match pattern: (Or (LShift (Load ..) ConI) ..)\n+        Node* shift_oper = out->isa_LShift();\n+        if (shift_oper->outcnt() != 1 ||                                               \/\/ Shift should has only one usage\n+            !is_supported_combine_opcode(shift_oper->unique_out()->Opcode()) ||    \/\/ Not used by combine operator\n+            !shift_oper->in(2)->is_ConI()) {                                         \/\/ Not shift by constant\n+          return nullptr;\n+        }\n+        if (combine_oper == nullptr) {\n+          combine_oper = shift_oper->unique_out();\n+        } else {\n+          \/\/ Too much combine operators\n+          return nullptr;\n+        }\n+        shift = shift_oper->in(2)->as_ConI()->get_int();\n+        if (shift % (load->memory_size() * BitsPerByte) != 0) {\n+          \/\/ Shift value is not aligned with memory size\n+          return nullptr;\n+        }\n+        break;\n+      }\n+      default:\n+        \/\/ can not handle other usage\n+        return nullptr;\n+    }\n+  }\n+  if (combine_oper == nullptr) {\n+    return nullptr;\n+  }\n+  assert(shift != -1, \"must be set\");\n+  return new MergeLoadInfo(load, combine_oper, shift);\n+}\n+\n+Node* MergePrimitiveLoads::run() {\n+  if (!is_merged_load_candidate()) {\n+    return nullptr;\n+  }\n+\n+  \/\/ go up through combine operators to find load node\n+  LoadNode* load = nullptr;\n+  Node* oper = _combine;\n+  NOT_PRODUCT(int steps = 0;)    \/\/ prevent dead loop in bad graph\n+  while (load == nullptr NOT_PRODUCT(&& steps < 30)) {\n+    assert(is_supported_combine_opcode(oper->Opcode())\n+           || oper->Opcode() == Op_ConvI2L || oper->is_LShift(), \"unexpected node\");\n+    Node* lhs = oper->in(1); \/\/ Check one input is enough\n+    assert(lhs != nullptr, \"sanity\");\n+    if (lhs->Opcode() == Op_ConvI2L || lhs->is_LShift() || lhs->Opcode() == _combine->Opcode()) {\n+      oper = lhs;\n+      continue;\n+    } else if (is_supported_load_opcode(lhs->Opcode())) {\n+      load = lhs->as_Load();\n+      break;\n+    } else {\n+      \/\/ not found\n+      return nullptr;\n+    }\n+  }\n+  assert(load != nullptr, \"reach loop limit\");\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] candidate:\"); _combine->dump(); tty->cr(); })\n+\n+  ResourceMark rm;\n+  MergeLoadInfoList merge_list;\n+  collect_merge_list(merge_list, load);\n+\n+  Node* replace = make_merged_load(merge_list);\n+  NOT_PRODUCT( if (is_trace_success() && replace != nullptr) { tty->print(\"[TraceMergeLoads] replace node is:\"); replace->dump(); tty->cr(); })\n+\n+  return replace;\n+}\n+\n+\/\/ Check other_load is compatible with load\n+bool MergePrimitiveLoads::is_compatible_load(const LoadNode* other_load, const LoadNode* load) const {\n+  if (other_load == nullptr ||\n+      !is_supported_load_opcode(other_load->Opcode()) ||\n+      load->memory_size() != other_load->memory_size()) {\n+    return false;\n+  }\n+\n+  assert(other_load->in(MemNode::Memory) == load->in(MemNode::Memory), \"sanity\");\n+\n+  \/\/ To simplify, assume all loads have same control.\n+  if (other_load->in(MemNode::Control) != load->in(MemNode::Control)) {\n+    return false;\n+  }\n+\n+  if (other_load->is_acquire() || !other_load->is_unordered()) {\n+    return false;\n+  }\n+\n+  \/\/ check alias\n+  Compile* C = _phase->C;\n+  if (C->get_alias_index(_phase->type(other_load->in(MemNode::Address))->is_ptr()) !=\n+      C->get_alias_index(_phase->type(load->in(MemNode::Address))->is_ptr())) {\n+    return false;\n+  }\n+\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: compatible_load:\"); other_load->dump(); tty->cr(); })\n+  return true;\n+}\n+\n+bool MergePrimitiveLoads::is_reachable_combine_nodes(const Node* from, const Node* to) {\n+  assert(from != nullptr && is_supported_combine_opcode(from->Opcode()), \"sanity\");\n+  assert(to != nullptr && is_supported_combine_opcode(to->Opcode()), \"sanity\");\n+\n+  const int max_search_steps = 8;\n+  int step = 0;\n+  const Node* check = from;\n+  while (step < max_search_steps) {\n+    if (check == to) {\n+      return true;\n+    }\n+    if (check->outcnt() != 1) {\n+      return false;\n+    }\n+    Node* next = check->unique_out();\n+    if (is_supported_combine_opcode(next->Opcode())) {\n+      check = next;\n+    } else {\n+      return false;\n+    }\n+    step++;\n+  }\n+  return false;\n+}\n+\n+MergePrimitiveLoads::MemoryAdjacentStatus MergePrimitiveLoads::get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const {\n+  ResourceMark rm;\n+#ifndef PRODUCT\n+  const TraceMemPointer trace(is_trace_pointer_parsing(),\n+                              is_trace_pointer_aliasing(),\n+                              is_trace_pointer_adjacency(),\n+                              true);\n+#endif\n+  const MemPointer pointer_first(first NOT_PRODUCT(COMMA trace));\n+  const MemPointer pointer_second(second NOT_PRODUCT(COMMA trace));\n+  if (pointer_first.is_adjacent_to_and_before(pointer_second)) {\n+    return MergePrimitiveLoads::LowToHigh;\n+  } else if (pointer_second.is_adjacent_to_and_before(pointer_first)) {\n+    return MergePrimitiveLoads::HighToLow;\n+  } else {\n+    return MergePrimitiveLoads::NotAdjacent;\n+  }\n+}\n+\n+\/\/ From the seed load to collect load items for merging\n+void MergePrimitiveLoads::collect_merge_list(MergeLoadInfoList& merge_list, const LoadNode* load) {\n+  const int max_bytes = 8; \/\/ The largest load is LoadLong\n+  const int max_merged_nodes = max_bytes\/load->memory_size();\n+\n+  MergeLoadInfo* array[8] = {nullptr};\n+#ifdef ASSERT\n+  for (auto & i : array) {\n+    assert(i == nullptr, \"must be initialized\");\n+  }\n+#endif\n+  \/\/ collect load nodes info from the same memory input\n+  Node* mem = load->in(MemNode::Memory);\n+  int collected = 0;\n+  \/\/ Collect draft merge list to array\n+  for (DUIterator_Fast imax, iter = mem->fast_outs(imax); iter < imax; iter++) {\n+    LoadNode* out = mem->fast_out(iter)->isa_Load();\n+    if (out == nullptr || !is_compatible_load(out, load)) continue;\n+\n+    MergeLoadInfo* info = merge_load_info(out);\n+    if (info == nullptr || !is_reachable_combine_nodes(info->_combine, _combine)) {\n+      NOT_PRODUCT( if (is_trace_basic() && info != nullptr) { tty->print(\"[TraceMergeLoads]: merge_list:unreachable combine nodes\"); info->_combine->dump(); tty->cr(); });\n+      continue;\n+    }\n+\n+    int index = info->_shift \/ (load->memory_size() * BitsPerByte);\n+    if (index < max_merged_nodes && array[index] == nullptr) {\n+      array[index] = info;\n+      collected ++;\n+    } else {\n+      NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: merge_list:wrong index or duplicate loads at same place: index:%d\", index); out->dump(); array[index]->_load->dump(); tty->cr(); });\n+      return;\n+    }\n+  }\n+\n+#ifdef ASSERT\n+  if (is_trace_basic()) {\n+    tty->print_cr(\"[TraceMergeLoads]: dump draft merge info array, collected: %d\", collected);\n+    for (auto & info : array) {\n+      if (info) {\n+        info->dump();\n+      }\n+    }\n+  }\n+#endif\n+\n+  int bytes = collected * load->memory_size();\n+  if (collected < 2 || bytes < 4 || !is_power_of_2(bytes)) {\n+    \/\/ too few or not aligned\n+    return;\n+  }\n+\n+  if (_combine->bottom_type() == TypeLong::LONG && bytes < 8) {\n+    \/\/ not cover all bits of result\n+    return;\n+  }\n+\n+  \/\/ check loads are adjacent in the same order\n+  MemoryAdjacentStatus order = Unknown;\n+  bool find_candidate = false;\n+\n+  for (int i = 0; i < collected; i++) {\n+    MergeLoadInfo* info = array[i];\n+    if (info == nullptr) {\n+      return;\n+    }\n+    if (i > 0) {\n+      MemoryAdjacentStatus adjacent = get_adjacent_load_status(array[i-1]->_load, info->_load);\n+      if (adjacent == NotAdjacent) {\n+        return;\n+      } else if (order == Unknown) {\n+        order = adjacent;\n+      } else if (adjacent != order) {\n+        \/\/ Different adjacent order\n+        return;\n+      }\n+    }\n+\n+    \/\/ Check sign bit of load\n+    \/\/ For shifted value based on memory load, if it does not reach the sign bit of merged load,\n+    \/\/ the load must be an unsigned load\n+    if ((info->_shift + load->memory_size() * BitsPerByte) != (collected * load->memory_size() * BitsPerByte)) {\n+      if (!info->_load->is_unsigned()) {\n+        \/\/ no unsigned Load of LoadI, so LoadI can not be merged\n+        \/\/ we may check value, if it's greater than 0, it can be merged\n+        return;\n+      }\n+    }\n+\n+    find_candidate = find_candidate || info->_combine == _combine;\n+  } \/\/ end of for-loop\n+\n+  \/\/ candidate combine operator is not in the list\n+  if (!find_candidate) {\n+    return;\n+  }\n+\n+  _order = order;\n+\n+  \/\/ Check the merged load matches the platform endian and if require a reverse byte node\n+  \/\/ The list is sorted by shift value, the low bit part is in the beginning\n+  assert(order == LowToHigh || order == HighToLow, \"Invalid order should return early\");\n+#ifdef VM_LITTLE_ENDIAN\n+  \/\/ LowToHigh match the platform order\n+  if (order != LowToHigh && load->memory_size() != 1) {\n+    return;\n+  }\n+  _require_reverse_bytes = (order == HighToLow);\n+#else\n+  \/\/ HighToLow match the platform order\n+  if (order != HighToLow && load->memory_size() != 1) {\n+    return;\n+  }\n+  _require_reverse_bytes = (order == LowToHigh);\n+#endif\n+  if (_require_reverse_bytes &&\n+      (!Matcher::match_rule_supported(Op_ReverseBytesS) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesL))) {\n+    \/\/ Reverse Bytes is not supported\n+    return;\n+  }\n+\n+  \/\/ All checks are passed\n+  for (int i=0; i<collected; i++) {\n+    merge_list.push(array[i]);\n+  }\n+#ifdef ASSERT\n+  if (is_trace_basic()) {\n+    tty->print_cr(\"[TraceMergeLoads]: dump final merge info list, collected: %d\", collected);\n+    for (int i=0; i < merge_list.length(); i++) {\n+      MergeLoadInfo* info = merge_list.at(i);\n+      info->dump();\n+    }\n+  }\n+#endif\n+  return;\n+}\n+\n+\/\/ Make the merged load and optional ReverBytes for replace\n+Node* MergePrimitiveLoads::make_merged_load(const MergeLoadInfoList& merge_list) {\n+  if (merge_list.is_empty()) {\n+    return nullptr;\n+  }\n+\n+  LoadNode* load;\n+  \/\/ Get address of merged load\n+  if (_order == LowToHigh) {\n+    load = merge_list.at(0)->_load;\n+  } else {\n+    load = merge_list.at(merge_list.length()-1)->_load;\n+  }\n+  Node* adr  = load->in(MemNode::Address);\n+  Node* ctrl = load->in(MemNode::Control);\n+  Node* mem  = load->in(MemNode::Memory);\n+\n+  const TypePtr* at = load->adr_type();\n+  const Type* rt = nullptr;\n+\n+  int merge_size = merge_list.length() * load->memory_size();\n+  BasicType bt = T_ILLEGAL;\n+  switch (merge_size) {\n+    case 4: bt = T_INT;   rt = TypeInt::INT;   break;\n+    case 8: bt = T_LONG;  rt = TypeLong::LONG; break;\n+    case 2: \/\/ Not merged as LoadS\n+    default: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+\n+  LoadNode* merged_load = LoadNode::make(*_phase, ctrl, mem, adr,\n+                                         at, rt, bt, MemNode::unordered)->isa_Load();\n+\n+  if (merged_load == nullptr) {\n+    return nullptr;\n+  }\n+  NOT_PRODUCT( if (is_trace_success()) { tty->print(\"[TraceMergeLoads] merged load:\"); merged_load->dump(); tty->cr(); })\n+\n+  merged_load->set_unaligned_access();\n+  merged_load->set_mismatched_access();\n+\n+  Node* replace = merged_load;\n+  if (_require_reverse_bytes) {\n+    assert(load->memory_size() == 1, \"only implemented for bytes\");\n+    if (merge_size == 8) {\n+      replace = _phase->transform(new ReverseBytesLNode(merged_load));\n+    } else {\n+      assert(merge_size == 4, \"sanity\");\n+      replace = _phase->transform(new ReverseBytesINode(merged_load));\n+    }\n+    _phase->is_IterGVN()->_worklist.push(merged_load);\n+  }\n+\n+  return replace;\n+}\n+\n@@ -832,0 +1381,9 @@\n+\n+  if (MergeLoads && UseUnalignedAccesses) {\n+    if (phase->C->merge_memops_phase()) {\n+      MergePrimitiveLoads merge(phase, this);\n+      return merge.run();\n+    } else {\n+      phase->C->record_for_merge_memops_igvn(this);\n+    }\n+  }\n@@ -906,0 +1464,8 @@\n+  if (MergeLoads && UseUnalignedAccesses) {\n+    if (phase->C->merge_memops_phase()) {\n+      MergePrimitiveLoads merge(phase, this);\n+      return merge.run();\n+    } else {\n+      phase->C->record_for_merge_memops_igvn(this);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":566,"deletions":0,"binary":false,"changes":566,"status":"modified"},{"patch":"@@ -1832,568 +1832,0 @@\n-\/* MergeLoads optimization\n- * Optimize multiple loads into a merged load, like below java code:\n- *\n- *      return ((array[offset    ] & 0xff) << 24)\n- *           | ((array[offset + 1] & 0xff) << 16)\n- *           | ((array[offset + 2] & 0xff) <<  8)\n- *           | ((array[offset + 3] & 0xff)      );\n- *\n- * The C2 IR graph is like:\n- *\n- *       Mem\n- *        |---------+---------+----------+\n- *        |         |         |          |\n- *      LoadB1    LoadB2    LoadB3     LoadB4\n- *        |         |         |          |\n- *        |       LShift    LShift     LShift\n- *        |         |         |          |\n- *        +-> Or1 <-+         |          |\n- *             |              |          |\n- *             +---> Or2 <----+          |\n- *                    |                  |\n- *                    +-----> Or3 <------+\n- *\n- * It is transformed as a merged LoadI, which replace the Or3 node.\n- *\n- * Because array value is logical and with constant 0xff\/0xffff, LoadS\/LoadB is converted to an unsigned load\n- * and 'And' node is eliminated in previous IGVN phase. Please check AndINode::Ideal for reference\n- *\n- *\/\n-class MergePrimitiveLoads;\n-\n-\/*\n- * LoadNode and OrNode pair which represent an item for merging,\n- * And we can get some properties like shift and last_op from it.\n- *\n- * Note: OrNode can be shared in different MergeLoadInfo\n- *\/\n-class MergeLoadInfo : ResourceObj {\n-  friend MergePrimitiveLoads;\n-private:\n-  LoadNode* const    _load;\n-  Node*     const      _or;\n-  int       const   _shift;\n-  bool            _last_op; \/\/ Indicate it's the last item of group, the _or node will be replaced by merged load\n-public:\n-  MergeLoadInfo(LoadNode* load, Node* orNode, int shift) : _load(load), _or(orNode), _shift(shift),\n-                                                           _last_op(false) {}\n-  void set_last_op(bool v)            { _last_op = v; }\n-  bool last_op()                const { return _last_op; }\n-\n-#ifdef ASSERT\n-  void dump() {\n-    tty->print_cr(\"MergeLoadInfo: load: %d, or: %d, shift: %d, last_op: %s\",\n-                        _load->_idx, _or->_idx, _shift,\n-                        _last_op ? \"true\" : \"false\");\n-  }\n-#endif\n-};\n-\n-typedef GrowableArray<MergeLoadInfo*> MergeLoadInfoList;\n-\n-class MergePrimitiveLoads : public StackObj {\n-  \/\/ The adjacent status of 2 loads\n-  enum MemoryAdjacentStatus {\n-    Unknown,            \/\/ Initial state\n-    LowToHigh,          \/\/ Adjacent and first load access low address\n-    HighToLow,          \/\/ Adjacent and first load access high address\n-    NotAdjacent         \/\/ Not adjacent\n-  };\n-\n-private:\n-  PhaseGVN* const      _phase;\n-  LoadNode* const       _load;\n-  int          _last_op_index;    \/\/ Index of the last item in merge_list\n-  MemoryAdjacentStatus _order;\n-  bool _require_reverse_bytes;    \/\/ Do we need add a ReverseBytes for merged load\n-\n-  NOT_PRODUCT( const CHeapBitMap &_trace_tags; )\n-\n-public:\n-  MergePrimitiveLoads(PhaseGVN* phase, LoadNode* load) :\n-    _phase(phase), _load(load), _last_op_index(-1), _order(Unknown), _require_reverse_bytes(false)\n-    NOT_PRODUCT( COMMA _trace_tags(Compile::current()->directive()->trace_merge_loads_tags()) )\n-    {}\n-\n-  LoadNode* run();\n-\n-private:\n-  \/\/ Detect the embedding _load is a candidate for merging loads\n-  bool is_merged_load_candidate( ) const;\n-  \/\/ Check other_load and _load are compatible\n-  bool is_compatible_load(const LoadNode* other_load) const;\n-  \/\/ From the candidate _load to collect load items for merging\n-  void collect_merge_list(MergeLoadInfoList& merge_list);\n-  \/\/ Construct merge information item from input load\n-  MergeLoadInfo* merge_load_info(LoadNode* load) const;\n-  \/\/ Make the merged load from list\n-  LoadNode* make_merged_load(const MergeLoadInfoList& merge_list);\n-\n-  \/\/ Helper methods for merge loads optimization\n-  static bool is_supported_opcode(int opcode);\n-  \/\/ Check the two Or Nodes can be reachable from one to another, and intermediate nodes are all Or Nodes\n-  static bool is_reachable_Or_nodes(const Node* from, const Node* to);\n-  MemoryAdjacentStatus get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const;\n-  \/\/ Go through ConvI2L which is unique output of the load\n-  static const Node* by_pass_i2l(const LoadNode* load);\n-\n-#ifndef PRODUCT\n-  \/\/ Access to TraceMergeLoads tags\n-  bool is_trace(TraceMergeLoads::Tag tag) const {\n-    return _trace_tags.at(tag);\n-  }\n-\n-  bool is_trace_basic() const {\n-    return is_trace(TraceMergeLoads::Tag::BASIC);\n-  }\n-\n-  bool is_trace_pointer_parsing() const {\n-    return is_trace(TraceMergeLoads::Tag::POINTER_PARSING);\n-  }\n-\n-  bool is_trace_pointer_aliasing() const {\n-    return is_trace(TraceMergeLoads::Tag::POINTER_ALIASING);\n-  }\n-\n-  bool is_trace_pointer_adjacency() const {\n-    return is_trace(TraceMergeLoads::Tag::POINTER_ADJACENCY);\n-  }\n-\n-  bool is_trace_success() const {\n-    return is_trace(TraceMergeLoads::Tag::SUCCESS);\n-  }\n-#endif\n-};\n-\n-bool MergePrimitiveLoads::is_supported_opcode(int opc) {\n-  \/\/ Check for B\/S\/C\/I\n-  if (opc != Op_LoadB && opc != Op_LoadUB &&\n-      opc != Op_LoadS && opc != Op_LoadUS &&\n-      opc != Op_LoadI) {\n-    return false;\n-  }\n-  return true;\n-}\n-\n-\/\/ Go through ConvI2L which is unique output of the load\n-const Node* MergePrimitiveLoads::by_pass_i2l(const LoadNode* l) {\n-  if (l != nullptr && l->outcnt() == 1 && l->unique_out()->Opcode() == Op_ConvI2L) {\n-    return l->unique_out();\n-  } else {\n-    return l;\n-  }\n-};\n-\n-\/*\n- * Check the _load can be a candidate load to trigger merge loads.\n- * The candidate load has the pattern:\n- *\n- * Load -> OrI\/OrL\n- *  It has no LShift usage and the And node is optimized out in previous optimization\n- *\n- *  The reference java code snippets are:\n- *              ...\n- *            | (((long) array[offset + 5] & 0xff) << 16)\n- *            | (((long) array[offset + 6] & 0xff) << 8 )\n- *            | (((long) array[offset + 7] & 0xff)      );                     <----- candidate\n- *\n- *              ((UNSAFE.getByte(array, address    ) & 0xff)      )            <----- candidate\n- *            | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n- *            | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n- *            | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n- *\/\n-bool MergePrimitiveLoads::is_merged_load_candidate() const {\n-  if (!is_supported_opcode(_load->Opcode()) ||\n-      _load->is_acquire() || !_load->is_unordered()) {\n-    return false;\n-  }\n-  const Node* check = by_pass_i2l(_load);\n-  \/\/ The candidate load has unique out which is OrI\/OrL node\n-  return check->outcnt() == 1 &&\n-         check->find_out_with(Op_OrI, Op_OrL) != nullptr;\n-}\n-\n-\/\/ Construct merge information item from input load\n-MergeLoadInfo* MergePrimitiveLoads::merge_load_info(LoadNode* load) const {\n-  const Node* check = by_pass_i2l(load);\n-  Node* or_oper = nullptr;\n-  int shift = -1;\n-  auto is_or_oper = [&](Node* n) { return n != nullptr && (n->Opcode() == Op_OrI || n->Opcode() == Op_OrL); };\n-\n-  \/\/ Check the Load node has the pattern \"(Or (LShift (Load .. ) ConI) ..)\" or \"(Or (Load ..) ..)\"\n-  for (DUIterator_Fast imax, iter = check->fast_outs(imax); iter < imax; iter++) {\n-    Node *out = check->fast_out(iter);\n-    switch (out->Opcode()) {\n-      case Op_OrI:\n-      case Op_OrL:\n-        \/\/ match pattern: (Or (Load ..) ..)\n-        if (or_oper == nullptr) {\n-          or_oper = out;\n-          shift = 0;\n-        } else {\n-          \/\/ Too much Or usages\n-          return nullptr;\n-        }\n-        break;\n-      case Op_LShiftI:\n-      case Op_LShiftL:\n-        {\n-          \/\/ match pattern: (Or (LShift (Load ..) ConI) ..)\n-          Node* shift_oper = out->isa_LShift();\n-          if (shift_oper->outcnt() != 1 ||                  \/\/ Expect only one usage to Or node\n-              !is_or_oper(shift_oper->unique_out()) ||      \/\/ Not used by Or node\n-              !shift_oper->in(2)->is_ConI()) {              \/\/ Not shift by constant\n-            return nullptr;\n-          }\n-          if (or_oper == nullptr) {\n-            or_oper = shift_oper->unique_out();\n-          } else {\n-            \/\/ Too much Or usages\n-            return nullptr;\n-          }\n-          shift = shift_oper->in(2)->as_ConI()->get_int();\n-          if (shift % (load->memory_size() * BitsPerByte) != 0) {\n-            \/\/ Shift value is not aligned with memory size\n-            return nullptr;\n-          }\n-          break;\n-        }\n-      default:\n-        \/\/ can not handle other usage\n-        return nullptr;\n-    }\n-  }\n-  if (or_oper == nullptr) {\n-    return nullptr;\n-  }\n-  assert(shift != -1, \"must be set\");\n-  \/\/ Check if the or_oper is the last operation of merge loads\n-  \/\/ If its unique output is another Or node, it may be in the middle of merge list\n-  \/\/ otherwise we reach the end of merge list\n-  bool last_op =  or_oper->outcnt() != 1 || !is_or_oper(or_oper->unique_out());\n-  MergeLoadInfo* info = new MergeLoadInfo(load, or_oper, shift);\n-  info->set_last_op(last_op);\n-  return info;\n-}\n-\n-LoadNode* MergePrimitiveLoads::run() {\n-  if (!is_merged_load_candidate()) {\n-    return nullptr;\n-  }\n-  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] candidate:\"); _load->dump(); tty->cr(); })\n-\n-  ResourceMark rm;\n-  MergeLoadInfoList merge_list;\n-  collect_merge_list(merge_list);\n-\n-  LoadNode* merged_load = make_merged_load(merge_list);\n-  NOT_PRODUCT( if (is_trace_success() && merged_load != nullptr) { tty->print(\"[TraceMergeLoads] merged load is:\"); merged_load->dump(); tty->cr(); })\n-\n-  return merged_load;\n-}\n-\n-\/\/ Check compatibility between _load and other_load.\n-bool MergePrimitiveLoads::is_compatible_load(const LoadNode* other_load) const {\n-  if (other_load == nullptr ||\n-      !is_supported_opcode(other_load->Opcode()) ||\n-      _load->memory_size() != other_load->memory_size()) {\n-    return false;\n-  }\n-\n-  assert(other_load->in(MemNode::Memory) == _load->in(MemNode::Memory), \"sanity\");\n-\n-  \/\/ To simplify, assume all loads have same control.\n-  if (other_load->in(MemNode::Control) != _load->in(MemNode::Control)) {\n-    return false;\n-  }\n-\n-  if (other_load->is_acquire() || !other_load->is_unordered()) {\n-    return false;\n-  }\n-\n-  \/\/ check alias\n-  Compile* C = _phase->C;\n-  if (C->get_alias_index(_phase->type(other_load->in(MemNode::Address))->is_ptr()) !=\n-      C->get_alias_index(_phase->type(_load->in(MemNode::Address))->is_ptr())) {\n-    return false;\n-  }\n-\n-  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: compatible_load:\"); other_load->dump(); tty->cr(); })\n-  return true;\n-}\n-\n-bool MergePrimitiveLoads::is_reachable_Or_nodes(const Node* from, const Node* to) {\n-  assert(from != nullptr && (from->Opcode() == Op_OrI || from->Opcode() == Op_OrL), \"sanity\");\n-  assert(to != nullptr && (to->Opcode() == Op_OrI || to->Opcode() == Op_OrL), \"sanity\");\n-  if (from == to) {\n-    return true;\n-  }\n-\n-  const int max_search_steps = 8;\n-  int step = 0;\n-  const Node* check = from;\n-  while (step < max_search_steps) {\n-    Node* next = nullptr;\n-    for (DUIterator_Fast imax, iter = check->fast_outs(imax); iter < imax; iter++) {\n-      Node* out = check->fast_out(iter);\n-      if (out == to) {\n-        return true;\n-      } else if (out->Opcode() == Op_OrI || out->Opcode() == Op_OrL){\n-        if (next != nullptr) {\n-          \/\/ Multiple Or usages\n-          return false;\n-        } else {\n-          next = out;\n-        }\n-      } else {\n-        \/\/ Other usage\n-        return false;\n-      }\n-    }\n-    if (next == nullptr) {\n-      return false;\n-    }\n-    check = next;\n-    step++;\n-  }\n-  return false;\n-}\n-\n-MergePrimitiveLoads::MemoryAdjacentStatus MergePrimitiveLoads::get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const {\n-  ResourceMark rm;\n-#ifndef PRODUCT\n-  const TraceMemPointer trace(is_trace_pointer_parsing(),\n-                              is_trace_pointer_aliasing(),\n-                              is_trace_pointer_adjacency(),\n-                              true);\n-#endif\n-  const MemPointer pointer_first(first NOT_PRODUCT(COMMA trace));\n-  const MemPointer pointer_second(second NOT_PRODUCT(COMMA trace));\n-  if (pointer_first.is_adjacent_to_and_before(pointer_second)) {\n-    return MergePrimitiveLoads::LowToHigh;\n-  } else if (pointer_second.is_adjacent_to_and_before(pointer_first)) {\n-    return MergePrimitiveLoads::HighToLow;\n-  } else {\n-    return MergePrimitiveLoads::NotAdjacent;\n-  }\n-}\n-\n-\/\/ From the candidate _load to collect load items for merging\n-void MergePrimitiveLoads::collect_merge_list(MergeLoadInfoList& merge_list) {\n-  const LoadNode* load = this->_load;\n-  const int max_bytes = 8; \/\/ The largest load is LoadLong\n-  const int max_merged_nodes = max_bytes\/load->memory_size();\n-\n-  MergeLoadInfo* array[8] = {nullptr};\n-#ifdef ASSERT\n-  for (auto & i : array) {\n-    assert(i == nullptr, \"must be initialized\");\n-  }\n-#endif\n-  \/\/ collect load nodes info from the same memory input\n-  Node* mem = _load->in(MemNode::Memory);\n-  MergeLoadInfo* base = merge_load_info(_load);\n-  assert(base != nullptr, \"The candidate _load must be checked\");\n-  int collected = 0;\n-  \/\/ Collect draft merge list to array\n-  for (DUIterator_Fast imax, iter = mem->fast_outs(imax); iter < imax; iter++) {\n-    LoadNode* out = mem->fast_out(iter)->isa_Load();\n-    if (out == nullptr || !is_compatible_load(out)) continue;\n-\n-    MergeLoadInfo* info = merge_load_info(out);\n-    if (info == nullptr ||\n-        (!is_reachable_Or_nodes(info->_or, base->_or) &&\n-         !is_reachable_Or_nodes(base->_or, info->_or))) {\n-      NOT_PRODUCT( if (is_trace_basic() && info != nullptr) { tty->print(\"[TraceMergeLoads]: merge_list:unreachable or nodes\"); base->_or->dump(); info->_or->dump(); tty->cr(); });\n-      continue;\n-    }\n-\n-    int index = info->_shift \/ (_load->memory_size() * BitsPerByte);\n-    if (index < max_merged_nodes && array[index] == nullptr) {\n-      array[index] = info;\n-      collected ++;\n-    } else {\n-      NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: merge_list:wrong index or duplicate loads at same place: index:%d\", index); out->dump(); array[index]->_load->dump(); tty->cr(); });\n-      return;\n-    }\n-  }\n-\n-#ifdef ASSERT\n-    if (is_trace_basic()) {\n-      tty->print_cr(\"[TraceMergeLoads]: dump draft merge info array, collected: %d\", collected);\n-      for (auto & info : array) {\n-        if (info) {\n-          info->dump();\n-        }\n-      }\n-    }\n-#endif\n-\n-  int bytes = collected * _load->memory_size();\n-  if (collected < 2 || bytes < 4 || !is_power_of_2(bytes)) {\n-    \/\/ too few or not aligned\n-    return;\n-  }\n-\n-  if (_load != array[0]->_load && _load != array[collected]->_load && array[0] == nullptr) {\n-    \/\/ candidate is not in the list\n-    return;\n-  }\n-\n-  \/\/ check loads are adjacent in the same order, and get the index of the last or operator\n-  MemoryAdjacentStatus order = Unknown;\n-  int last_op_index = -1;\n-\n-  for (int i = 0; i < collected; i++) {\n-    MergeLoadInfo* info = array[i];\n-    if (info == nullptr) {\n-      return;\n-    }\n-    if (i > 0) {\n-      MemoryAdjacentStatus adjacent = get_adjacent_load_status(array[i-1]->_load, info->_load);\n-      if (adjacent == NotAdjacent) {\n-        return;\n-      } else if (order == Unknown) {\n-        order = adjacent;\n-      } else if (adjacent != order) {\n-        \/\/ Different adjacent order\n-        return;\n-      }\n-    }\n-\n-    if (info->last_op()) {\n-      if (last_op_index >= 0 && array[last_op_index]->_or != info->_or) {\n-        \/\/ Found multiple ends of list\n-        return;\n-      } else {\n-        if ((info->_or->Opcode() == Op_OrI && bytes != 4) ||\n-            (info->_or->Opcode() == Op_OrL && bytes != 8)) {\n-          \/\/ The merged load can not cover all bits of result value\n-          return;\n-        }\n-        last_op_index = i;\n-      }\n-    }\n-\n-    \/\/ Check sign bit of load\n-    \/\/ For shifted value based on memory load, if it does not reach the sign bit of merged load,\n-    \/\/ the load must be an unsigned load\n-    if ((info->_shift + _load->memory_size() * BitsPerByte) != (collected * _load->memory_size() * BitsPerByte)) {\n-      if (!info->_load->is_unsigned()) {\n-        \/\/ no unsigned Load of LoadI, can we merge 2 LoadI?\n-        \/\/ we may check value, if it's greater than 0, it can be merged\n-        return;\n-      }\n-    }\n-  } \/\/ end of for-loop\n-\n-  if (last_op_index < 0) {\n-    \/\/ Not found last op\n-    return;\n-  }\n-\n-  \/\/ Check the merged load matches the platform endian and if require a reverse byte node\n-  \/\/ The list is sorted by shift value, the low bit part is in the beginning\n-  assert(order == LowToHigh || order == HighToLow, \"Invalid order should return early\");\n-#ifdef VM_LITTLE_ENDIAN\n-  \/\/ LowToHigh match the platform order\n-  if (order != LowToHigh && _load->memory_size() != 1) {\n-    return;\n-  }\n-  _require_reverse_bytes = (order == HighToLow);\n-#else\n-  \/\/ HighToLow match the platform order\n-  if (order != HighToLow && _load->memory_size() != 1) {\n-    return;\n-  }\n-  _require_reverse_bytes = (order == LowToHigh);\n-#endif\n-  if (_require_reverse_bytes &&\n-      (!Matcher::match_rule_supported(Op_ReverseBytesS) ||\n-       !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n-       !Matcher::match_rule_supported(Op_ReverseBytesL))) {\n-    \/\/ Reverse Bytes is not supported\n-    return;\n-  }\n-\n-  \/\/ All checks are passed\n-  _last_op_index = last_op_index;\n-  _order = order;\n-\n-  for (int i=0; i<collected; i++) {\n-    merge_list.push(array[i]);\n-  }\n-#ifdef ASSERT\n-  if (is_trace_basic()) {\n-    tty->print_cr(\"[TraceMergeLoads]: dump final merge info list, collected: %d\", collected);\n-    for (int i=0; i < merge_list.length(); i++) {\n-      MergeLoadInfo* info = merge_list.at(i);\n-      info->dump();\n-    }\n-  }\n-#endif\n-  return;\n-}\n-\n-\/\/ Make the merged load from list and replace the last Or oper\n-LoadNode* MergePrimitiveLoads::make_merged_load(const MergeLoadInfoList& merge_list) {\n-  if (merge_list.is_empty()) {\n-    return nullptr;\n-  }\n-\n-  assert(merge_list.length() >= 2 && _last_op_index >= 0 && _last_op_index < merge_list.length(), \"sanity\");\n-  LoadNode* load = _order == LowToHigh ? merge_list.at(0)->_load : merge_list.at(merge_list.length()-1)->_load;\n-  \/\/ Get address of merged load\n-  if (_order == LowToHigh) {\n-    load = merge_list.at(0)->_load;\n-  } else {\n-    load = merge_list.at(merge_list.length()-1)->_load;\n-  }\n-  Node* adr  = load->in(MemNode::Address);\n-  Node* ctrl = load->in(MemNode::Control);\n-  Node* mem  = load->in(MemNode::Memory);\n-  Node* last_op = merge_list.at(_last_op_index)->_or;\n-\n-  const TypePtr* at = load->adr_type();\n-  const Type* rt = nullptr;\n-\n-  int merge_size = merge_list.length() * _load->memory_size();\n-  BasicType bt = T_ILLEGAL;\n-  switch (merge_size) {\n-    case 4: bt = T_INT;   rt = TypeInt::INT;   break;\n-    case 8: bt = T_LONG;  rt = TypeLong::LONG; break;\n-    case 2: \/\/ Not merged as LoadS\n-    default: {\n-      ShouldNotReachHere();\n-      break;\n-    }\n-  }\n-\n-  LoadNode* merged_load = LoadNode::make(*_phase, ctrl, mem, adr,\n-                                         at, rt, bt, MemNode::unordered)->isa_Load();\n-\n-  if (merged_load == nullptr) {\n-    return nullptr;\n-  }\n-\n-  merged_load->set_unaligned_access();\n-  merged_load->set_mismatched_access();\n-\n-  Node* replace = merged_load;\n-  if (_require_reverse_bytes) {\n-    assert(_load->memory_size() == 1, \"only implemented for bytes\");\n-    if (merge_size == 8) {\n-      replace = _phase->transform(new ReverseBytesLNode(merged_load));\n-    } else {\n-      assert(merge_size == 4, \"sanity\");\n-      replace = _phase->transform(new ReverseBytesINode(merged_load));\n-    }\n-    NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] new ReverseBytes node:\"); replace->dump(); tty->cr(); })\n-    _phase->is_IterGVN()->_worklist.push(replace);\n-  }\n-\n-  assert(last_op != nullptr && (last_op->Opcode() == Op_OrI || last_op->Opcode() == Op_OrL), \"sanity\");\n-  _phase->is_IterGVN()->replace_node(last_op, replace);\n-  _phase->is_IterGVN()->_worklist.push(merged_load);\n-\n-  return merged_load;\n-}\n@@ -2537,10 +1969,0 @@\n-  if (MergeLoads && UseUnalignedAccesses) {\n-    if (phase->C->merge_memops_phase()) {\n-      MergePrimitiveLoads merge(phase, this);\n-      Node* merged = merge.run();\n-      if (merged != nullptr) { return merged; }\n-    } else {\n-      phase->C->record_for_merge_memops_igvn(this);\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":0,"deletions":578,"binary":false,"changes":578,"status":"modified"},{"patch":"@@ -70,0 +70,2 @@\n+    long aN = UNSAFE.allocateMemory(RANGE);\n+\n@@ -102,0 +104,1 @@\n+        testGroups.get(\"test1\").put(\"test1h\", (_,_) -> { return test1h(aN); });\n@@ -113,0 +116,1 @@\n+        testGroups.get(\"test2\").put(\"test2h\", (_,_) -> { return test2h(aN); });\n@@ -174,0 +178,10 @@\n+\n+        \/\/ Load value has other usage\n+        testGroups.put(\"test12\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test12\").put(\"test12R\", (_,_) -> { return test12R(aB.clone()); });\n+        testGroups.get(\"test12\").put(\"test12a\", (_,_) -> { return test12a(aB.clone()); });\n+\n+        \/\/ Mix different loads\n+        testGroups.put(\"test13\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test13\").put(\"test13R\", (_,_) -> { return test13R(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n+        testGroups.get(\"test13\").put(\"test13a\", (_,_) -> { return test13a(aB.clone(), aC.clone(), aS.clone(), aI.clone()); });\n@@ -176,1 +190,1 @@\n-    static void set_random(byte[] a) {\n+    static void set_random(byte[] a, long addr) {\n@@ -179,0 +193,1 @@\n+            UNSAFE.putByte(addr + i, a[i]);\n@@ -208,0 +223,1 @@\n+                 \"test1h\",\n@@ -216,0 +232,1 @@\n+                 \"test2h\",\n@@ -250,0 +267,4 @@\n+\n+                 \"test12a\",\n+\n+                 \"test13a\",\n@@ -256,1 +277,1 @@\n-            set_random(aB);\n+            set_random(aB, aN);     \/\/ setup for both byte array and natvie\n@@ -459,0 +480,17 @@\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B,  \"0\",\n+          IRNode.LOAD_UB, \"0\",\n+          IRNode.LOAD_S,  \"0\",\n+          IRNode.LOAD_US, \"0\",\n+          IRNode.LOAD_I,  \"1\",\n+          IRNode.LOAD_L,  \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static int test1h(long address) {\n+      return  (UNSAFE.getByte(address + 0) & 0xff)       |\n+             ((UNSAFE.getByte(address + 1) & 0xff) << 8 )|\n+             ((UNSAFE.getByte(address + 2) & 0xff) << 16)|\n+             ((UNSAFE.getByte(address + 3) & 0xff) << 24);\n+    }\n+\n@@ -665,0 +703,21 @@\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B,  \"0\",\n+          IRNode.LOAD_UB, \"0\",\n+          IRNode.LOAD_S,  \"0\",\n+          IRNode.LOAD_US, \"0\",\n+          IRNode.LOAD_I,  \"0\",\n+          IRNode.LOAD_L,  \"1\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long test2h(long address) {\n+      return  ((long)(UNSAFE.getByte(address + 0) & 0xff))       |\n+             (((long)(UNSAFE.getByte(address + 1) & 0xff)) << 8 )|\n+             (((long)(UNSAFE.getByte(address + 2) & 0xff)) << 16)|\n+             (((long)(UNSAFE.getByte(address + 3) & 0xff)) << 24)|\n+             (((long)(UNSAFE.getByte(address + 4) & 0xff)) << 32)|\n+             (((long)(UNSAFE.getByte(address + 5) & 0xff)) << 40)|\n+             (((long)(UNSAFE.getByte(address + 6) & 0xff)) << 48)|\n+             (((long)(UNSAFE.getByte(address + 7) & 0xff)) << 56);\n+    }\n+\n@@ -1639,0 +1698,145 @@\n+\n+    \/**\n+     * Group 12: load value has other usage\n+     *\/\n+    @DontCompile\n+    static long[] test12R(byte[] aB) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] )) << 56);\n+      return new long[] {i1, aB[7]};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"7\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test12a(byte[] aB) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] )) << 56);\n+      return new long[] {i1, aB[7]};\n+    }\n+\n+    \/**\n+     * Group 13: Mix different patterns\n+     *\/\n+    @DontCompile\n+    static long[] test13R(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] & 0xff)) << 56);\n+      long i2 = ((long)(aB[2] & 0xff))        |\n+               (((long)(aB[3] & 0xff)) << 8 ) |\n+               (((long)(aB[4] & 0xff)) << 16) |\n+               (((long)(aB[5] & 0xff)) << 24) |\n+               (((long)(aB[6] & 0xff)) << 32) |\n+               (((long)(aB[7] & 0xff)) << 40) |\n+               (((long)(aB[8] & 0xff)) << 48) |\n+               (((long)(aB[9] & 0xff)) << 56);\n+      int i3 =  (aB[10] & 0xff)        +\n+               ((aB[11] & 0xff) << 8 ) +\n+               ((aB[12] & 0xff) << 16) +\n+               ((aB[13] & 0xff) << 24);\n+      int i4 =  (aB[14] & 0xff)        |\n+               ((aB[15] & 0xff) << 8 ) |\n+               ((aB[16] & 0xff) << 16) |\n+               ((aB[17] & 0xff) << 24);\n+      int i5 = (UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 20) & 0xff)        |  \/\/ it can be merged\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 21) & 0xff) << 8 ) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 22) & 0xff) << 16) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 23) & 0xff) << 24);\n+      long i6 = (((long)(aC[0] & 0xffff)) << 48)|\n+                (((long)(aC[1] & 0xffff)) << 32)|\n+                (((long)(aC[2] & 0xffff)) << 16)|\n+                 ((long)(aC[3] & 0xffff));\n+      long i7 =  ((long)(aC[4] & 0xffff))       |\n+                (((long)(aC[5] & 0xffff)) << 16)|\n+                (((long)(aC[6] & 0xffff)) << 32)|\n+                (((long)(aC[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2, i3, i4, i5, i6, i7};\n+    }\n+\n+    @Test\n+    @IR(counts = {\n+          IRNode.LOAD_B_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+          IRNode.LOAD_UB_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"13\",\n+          IRNode.LOAD_S_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"2\",\n+          IRNode.LOAD_L_OF_CLASS,  \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"4\",\n+          IRNode.LOAD_I_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"char\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+\n+          IRNode.LOAD_S_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_US_OF_CLASS, \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_I_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"short\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+\n+          IRNode.LOAD_I_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+          IRNode.LOAD_L_OF_CLASS,  \"int\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"0\",\n+        },\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static long[] test13a(byte[] aB, char[] aC, short[] aS, int[] aI) {\n+      long i1 = ((long)(aB[0] & 0xff))        |\n+               (((long)(aB[1] & 0xff)) << 8 ) |\n+               (((long)(aB[2] & 0xff)) << 16) |\n+               (((long)(aB[3] & 0xff)) << 24) |\n+               (((long)(aB[4] & 0xff)) << 32) |\n+               (((long)(aB[5] & 0xff)) << 40) |\n+               (((long)(aB[6] & 0xff)) << 48) |\n+               (((long)(aB[7] & 0xff)) << 56);\n+      long i2 = ((long)(aB[2] & 0xff))        |\n+               (((long)(aB[3] & 0xff)) << 8 ) |\n+               (((long)(aB[4] & 0xff)) << 16) |\n+               (((long)(aB[5] & 0xff)) << 24) |\n+               (((long)(aB[6] & 0xff)) << 32) |\n+               (((long)(aB[7] & 0xff)) << 40) |\n+               (((long)(aB[8] & 0xff)) << 48) |\n+               (((long)(aB[9] & 0xff)) << 56);\n+      int i3 =  (aB[10] & 0xff)        +\n+               ((aB[11] & 0xff) << 8 ) +\n+               ((aB[12] & 0xff) << 16) +\n+               ((aB[13] & 0xff) << 24);\n+      int i4 =  (aB[14] & 0xff)        |     \/\/ it can be merged\n+               ((aB[15] & 0xff) << 8 ) |\n+               ((aB[16] & 0xff) << 16) |\n+               ((aB[17] & 0xff) << 24);\n+      int i5 = (UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 20) & 0xff)        |  \/\/ it can be merged\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 21) & 0xff) << 8 ) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 22) & 0xff) << 16) |\n+              ((UNSAFE.getByte(aB, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 23) & 0xff) << 24);\n+      long i6 = (((long)(aC[0] & 0xffff)) << 48)|\n+                (((long)(aC[1] & 0xffff)) << 32)|\n+                (((long)(aC[2] & 0xffff)) << 16)|\n+                 ((long)(aC[3] & 0xffff));\n+      long i7 =  ((long)(aC[4] & 0xffff))       |\n+                (((long)(aC[5] & 0xffff)) << 16)|\n+                (((long)(aC[6] & 0xffff)) << 32)|\n+                (((long)(aC[7] & 0xffff)) << 48);\n+      return new long[] {i1, i2, i3, i4, i5, i6, i7};\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeLoads.java","additions":206,"deletions":2,"binary":false,"changes":208,"status":"modified"}]}