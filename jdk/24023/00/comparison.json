{"files":[{"patch":"@@ -306,1 +306,2 @@\n-  _trace_merge_stores_tags(TraceMergeStores::TAG_NUM, mtCompiler)\n+  _trace_merge_stores_tags(TraceMergeStores::TAG_NUM, mtCompiler),\n+  _trace_merge_loads_tags(TraceMergeLoads::TAG_NUM, mtCompiler)\n@@ -458,0 +459,10 @@\n+    if (!_modified[TraceMergeLoadsIndex]) {\n+      \/\/ Parse ccstr and create mask\n+      ccstrlist option;\n+      if (CompilerOracle::has_option_value(method, CompileCommandEnum::TraceMergeLoads, option)) {\n+        TraceMergeLoads::TagValidator validator(option, false);\n+        if (validator.is_valid()) {\n+          set.cloned()->set_trace_merge_loads_tags(validator.tags());\n+        }\n+      }\n+    }\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.cpp","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+NOT_PRODUCT(cflags(TraceMergeLoads, ccstrlist, \"\", TraceMergeLoads)) \\\n@@ -134,0 +135,1 @@\n+  CHeapBitMap _trace_merge_loads_tags;\n@@ -220,0 +222,6 @@\n+  void set_trace_merge_loads_tags(const CHeapBitMap& tags) {\n+    _trace_merge_loads_tags.set_from(tags);\n+  };\n+  const CHeapBitMap& trace_merge_loads_tags() {\n+    return _trace_merge_loads_tags;\n+  };\n","filename":"src\/hotspot\/share\/compiler\/compilerDirectives.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -805,0 +805,6 @@\n+        if (!validator.is_valid()) {\n+          jio_snprintf(errorbuf, buf_size, \"Unrecognized tag name in %s: %s\", option2name(option), validator.what());\n+        }\n+      } else if (option == CompileCommandEnum::TraceMergeLoads) {\n+        TraceMergeLoads::TagValidator validator(value, true);\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -90,0 +90,1 @@\n+NOT_PRODUCT(option(TraceMergeLoads, \"TraceMergeLoads\", Ccstrlist)) \\\n","filename":"src\/hotspot\/share\/compiler\/compilerOracle.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -359,0 +359,9 @@\n+        } else if (strncmp(option_key->name, \"TraceMergeLoads\", 15) == 0) {\n+          TraceMergeLoads::TagValidator validator(s, false);\n+\n+          valid = validator.is_valid();\n+          if (valid) {\n+            set->set_trace_merge_loads_tags(validator.tags());\n+          } else {\n+            error(VALUE_ERROR, \"Unrecognized tag name detected in TraceMergeLoads: %s\", validator.what());\n+          }\n","filename":"src\/hotspot\/share\/compiler\/directivesParser.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -382,0 +382,3 @@\n+  product(bool, MergeLoads, true, DIAGNOSTIC,                               \\\n+          \"Optimize loads by combining values into larger load\")            \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/opto\/c2_globals.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -405,2 +405,2 @@\n-  if (dead->for_merge_stores_igvn()) {\n-    remove_from_merge_stores_igvn(dead);\n+  if (dead->for_merge_memops_igvn()) {\n+    remove_from_merge_memops_igvn(dead);\n@@ -459,1 +459,1 @@\n-  remove_useless_nodes(_for_merge_stores_igvn, useful); \/\/ remove useless node recorded for merge stores IGVN pass\n+  remove_useless_nodes(_for_merge_memops_igvn, useful); \/\/ remove useless node recorded for merge stores\/loads IGVN pass\n@@ -634,1 +634,1 @@\n-      _merge_stores_phase(false),\n+      _merge_memops_phase(false),\n@@ -659,1 +659,1 @@\n-      _for_merge_stores_igvn(comp_arena(), 8, 0, nullptr),\n+      _for_merge_memops_igvn(comp_arena(), 8, 0, nullptr),\n@@ -914,1 +914,1 @@\n-      _merge_stores_phase(false),\n+      _merge_memops_phase(false),\n@@ -933,1 +933,1 @@\n-      _for_merge_stores_igvn(comp_arena(), 8, 0, nullptr),\n+      _for_merge_memops_igvn(comp_arena(), 8, 0, nullptr),\n@@ -1881,5 +1881,5 @@\n-void Compile::record_for_merge_stores_igvn(Node* n) {\n-  if (!n->for_merge_stores_igvn()) {\n-    assert(!_for_merge_stores_igvn.contains(n), \"duplicate\");\n-    n->add_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n-    _for_merge_stores_igvn.append(n);\n+void Compile::record_for_merge_memops_igvn(Node* n) {\n+  if (!n->for_merge_memops_igvn()) {\n+    assert(!_for_merge_memops_igvn.contains(n), \"duplicate\");\n+    n->add_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n+    _for_merge_memops_igvn.append(n);\n@@ -1889,3 +1889,3 @@\n-void Compile::remove_from_merge_stores_igvn(Node* n) {\n-  n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n-  _for_merge_stores_igvn.remove(n);\n+void Compile::remove_from_merge_memops_igvn(Node* n) {\n+  n->remove_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n+  _for_merge_memops_igvn.remove(n);\n@@ -1894,1 +1894,1 @@\n-\/\/ We need to wait with merging stores until RangeCheck smearing has removed the RangeChecks during\n+\/\/ We need to wait with merging stores\/loads until RangeCheck smearing has removed the RangeChecks during\n@@ -1907,8 +1907,8 @@\n-\/\/       since we never unset _merge_stores_phase.\n-void Compile::process_for_merge_stores_igvn(PhaseIterGVN& igvn) {\n-  C->set_merge_stores_phase();\n-\n-  if (_for_merge_stores_igvn.length() > 0) {\n-    while (_for_merge_stores_igvn.length() > 0) {\n-      Node* n = _for_merge_stores_igvn.pop();\n-      n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+\/\/       since we never unset _merge_memops_phase.\n+void Compile::process_for_merge_memops_igvn(PhaseIterGVN& igvn) {\n+  C->set_merge_memops_phase();\n+\n+  if (_for_merge_memops_igvn.length() > 0) {\n+    while (_for_merge_memops_igvn.length() > 0) {\n+      Node* n = _for_merge_memops_igvn.pop();\n+      n->remove_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n@@ -1919,2 +1919,2 @@\n-    assert(_for_merge_stores_igvn.length() == 0, \"no more delayed nodes allowed\");\n-    print_method(PHASE_AFTER_MERGE_STORES, 3);\n+    assert(_for_merge_memops_igvn.length() == 0, \"no more delayed nodes allowed\");\n+    print_method(PHASE_AFTER_MERGE_MEMOPS, 3);\n@@ -2483,1 +2483,1 @@\n-  process_for_merge_stores_igvn(igvn);\n+  process_for_merge_memops_igvn(igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":27,"deletions":27,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-  bool                  _merge_stores_phase;    \/\/ Phase for merging stores, after post loop opts phase.\n+  bool                  _merge_memops_phase;    \/\/ Phase for merging stores\/loads, after post loop opts phase.\n@@ -378,1 +378,1 @@\n-  GrowableArray<Node*>  _for_merge_stores_igvn; \/\/ List of nodes for IGVN merge stores\n+  GrowableArray<Node*>  _for_merge_memops_igvn; \/\/ List of nodes for IGVN merge stores and loads\n@@ -771,5 +771,5 @@\n-  bool     merge_stores_phase() { return _merge_stores_phase;  }\n-  void set_merge_stores_phase() { _merge_stores_phase = true;  }\n-  void record_for_merge_stores_igvn(Node* n);\n-  void remove_from_merge_stores_igvn(Node* n);\n-  void process_for_merge_stores_igvn(PhaseIterGVN& igvn);\n+  bool     merge_memops_phase() { return _merge_memops_phase;  }\n+  void set_merge_memops_phase() { _merge_memops_phase = true;  }\n+  void record_for_merge_memops_igvn(Node* n);\n+  void remove_from_merge_memops_igvn(Node* n);\n+  void process_for_merge_memops_igvn(PhaseIterGVN& igvn);\n","filename":"src\/hotspot\/share\/opto\/compile.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1832,0 +1832,520 @@\n+\/* MergeLoads optimization\n+ * Optimize multiple loads into a merged load, like below java code:\n+ *\n+ *      return ((array[offset    ] & 0xff) << 24)\n+ *           | ((array[offset + 1] & 0xff) << 16)\n+ *           | ((array[offset + 2] & 0xff) <<  8)\n+ *           | ((array[offset + 3] & 0xff)      );\n+ *\n+ * The C2 IR graph is like:\n+ *\n+ *       Mem\n+ *        |---------+---------+----------+\n+ *        |         |         |          |\n+ *      LoadB1    LoadB2    LoadB3     LoadB4\n+ *        |         |         |          |\n+ *        |       LShift    LShift     LShift\n+ *        |         |         |          |\n+ *        +-> Or1 <-+         |          |\n+ *             |              |          |\n+ *             +---> Or2 <----+          |\n+ *                    |                  |\n+ *                    +-----> Or3 <------+\n+ *\n+ * It will be transformed as a merged LoadI and replace the Or3 node\n+ *\n+ *\/\n+class MergePrimitiveLoads;\n+\n+\/*\n+ * LoadNode and OrNode pair which represent an item for merging,\n+ * And we can get some properties like shift and uncommon usage from it.\n+ *\n+ * Note: OrNode may be shared\n+ *\/\n+class MergeLoadInfo : ResourceObj {\n+  friend MergePrimitiveLoads;\n+private:\n+  LoadNode*          _load;\n+  Node*                _or;\n+  int               _shift;\n+  bool _has_uncommon_usage;\n+  bool            _last_op; \/\/ Indicate it's the last item of group, the _or node will be replaced by merged load\n+public:\n+  MergeLoadInfo(LoadNode* load, Node* orNode, int shift) : _load(load), _or(orNode), _shift(shift),\n+                                                           _has_uncommon_usage(false), _last_op(false) {}\n+  void set_has_uncommon_usage(bool v) { _has_uncommon_usage = v; }\n+  bool has_uncommon_usage()     const { return _has_uncommon_usage; }\n+  void set_last_op(bool v)            { _last_op = v; }\n+  bool last_op()                const { return _last_op; }\n+\n+#ifdef ASSERT\n+  void dump() {\n+    tty->print_cr(\"MergeLoadInfo: load: %d, or: %d, shift: %d, has_uncommon_usage: %s, last_op: %s\",\n+                        _load->_idx, _or->_idx, _shift,\n+                        _has_uncommon_usage ? \"true\" : \"false\",\n+                        _last_op ? \"true\" : \"false\");\n+  }\n+#endif\n+};\n+\n+typedef GrowableArray<MergeLoadInfo*> MergeLoadInfoList;\n+\n+class MergePrimitiveLoads : public StackObj {\n+  \/\/ The adjacent status of 2 loads\n+  enum MemoryAdjacentStatus {\n+    Unknown,            \/\/ Initial state\n+    LowToHigh,          \/\/ Adjacent and first load access low address\n+    HighToLow,          \/\/ Adjacent and first load access high address\n+    NotAdjacent         \/\/ Not adjacent\n+  };\n+\n+private:\n+  PhaseGVN* const      _phase;\n+  LoadNode* const       _load;\n+  int          _last_op_index;    \/\/ Index of the last item in merged_list\n+  MemoryAdjacentStatus _order;\n+  bool _require_reverse_bytes;    \/\/ Do we need add a ReverseBytes for merged load\n+\n+  NOT_PRODUCT( const CHeapBitMap &_trace_tags; )\n+\n+public:\n+  MergePrimitiveLoads(PhaseGVN* phase, LoadNode* load) :\n+    _phase(phase), _load(load), _last_op_index(-1), _order(Unknown), _require_reverse_bytes(false)\n+    NOT_PRODUCT( COMMA _trace_tags(Compile::current()->directive()->trace_merge_loads_tags()) )\n+    {}\n+\n+  LoadNode* run();\n+\n+private:\n+  \/\/ Detect the embedding _load is a candidate for merging loads\n+  bool is_merged_load_candidate( ) const;\n+  \/\/ Check other_load and _load are compatible\n+  bool is_compatible_load(const LoadNode* other_load) const;\n+  \/\/ From the candidate _load to collect load items for merging\n+  void collect_merge_list(MergeLoadInfoList& merge_list);\n+  \/\/ Construct merge information item from input load\n+  MergeLoadInfo* merge_load_info(LoadNode* load) const;\n+  \/\/ Make the merged load from list\n+  LoadNode* make_merged_load(const MergeLoadInfoList& merge_list);\n+\n+  \/\/ Helper methods for merge loads optimization\n+  static bool is_supported_opcode(int opcode);\n+  MemoryAdjacentStatus get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const;\n+  \/\/ Go through ConvI2L which is unique output of the load\n+  static Node* by_pass_i2l(const LoadNode* load);\n+\n+#ifndef PRODUCT\n+  \/\/ Access to TraceMergeLoads tags\n+  bool is_trace(TraceMergeLoads::Tag tag) const {\n+    return _trace_tags.at(tag);\n+  }\n+\n+  bool is_trace_basic() const {\n+    return is_trace(TraceMergeLoads::Tag::BASIC);\n+  }\n+\n+  bool is_trace_pointer_parsing() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_PARSING);\n+  }\n+\n+  bool is_trace_pointer_aliasing() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_ALIASING);\n+  }\n+\n+  bool is_trace_pointer_adjacency() const {\n+    return is_trace(TraceMergeLoads::Tag::POINTER_ADJACENCY);\n+  }\n+\n+  bool is_trace_success() const {\n+    return is_trace(TraceMergeLoads::Tag::SUCCESS);\n+  }\n+#endif\n+};\n+\n+bool MergePrimitiveLoads::is_supported_opcode(int opc) {\n+  \/\/ Check for B\/S\/C\/I\n+  if (opc != Op_LoadB && opc != Op_LoadUB &&\n+      opc != Op_LoadS && opc != Op_LoadUS &&\n+      opc != Op_LoadI) {\n+    return false;\n+  }\n+  return true;\n+}\n+\n+\/\/ Go through ConvI2L which is unique output of the load\n+Node* MergePrimitiveLoads::by_pass_i2l(const LoadNode* l) {\n+  if ( l != nullptr && l->outcnt() == 1 && l->unique_out()->Opcode() == Op_ConvI2L) {\n+    return l->unique_out();\n+  } else {\n+    return (Node*)l;\n+  }\n+};\n+\n+\/*\n+ * Check the _load can be a candidate load to trigger merge loads.\n+ * The candidate load has the pattern:\n+ *\n+ * Load -> OrI\/OrL\n+ *  It has no LShift usage and the And node is optimized out in previous optimization\n+ *\n+ *  The reference java code snippets are:\n+ *              ...\n+ *            | (((long) array[offset + 5] & 0xff) << 16)\n+ *            | (((long) array[offset + 6] & 0xff) << 8 )\n+ *            | (((long) array[offset + 7] & 0xff)      );                     <----- candidate\n+ *\n+ *              ((UNSAFE.getByte(array, address    ) & 0xff)      )            <----- candidate\n+ *            | ((UNSAFE.getByte(array, address + 1) & 0xff) <<  8)\n+ *            | ((UNSAFE.getByte(array, address + 2) & 0xff) << 16)\n+ *            | ((UNSAFE.getByte(array, address + 3) & 0xff) << 24);\n+ *\/\n+bool MergePrimitiveLoads::is_merged_load_candidate() const {\n+  if (!is_supported_opcode(_load->Opcode()) ||\n+      _load->is_acquire() || !_load->is_unordered()) {\n+    return false;\n+  }\n+  Node* check = by_pass_i2l(_load);\n+  switch(check->outcnt()) {\n+    case 1: {\n+      int opc = check->unique_out()->Opcode();\n+      return opc == Op_OrI || opc == Op_OrL;\n+    }\n+    case 2: {\n+      \/\/ It can has an optional output to uncommon trap\n+      Node *call = check->find_out_with(Op_CallStaticJava);\n+      if (call == nullptr || !call->as_CallStaticJava()->is_uncommon_trap()) {\n+        return false;\n+      }\n+      return check->find_out_with(Op_OrI, Op_OrL) != nullptr;\n+    }\n+    default:\n+      return false;\n+  }\n+}\n+\n+\/\/ Construct merge information item from input load\n+MergeLoadInfo* MergePrimitiveLoads::merge_load_info(LoadNode* load) const {\n+  Node* check = by_pass_i2l(load);\n+  Node* or_oper = nullptr;\n+  int shift = -1;\n+  bool has_uncommon_trap_usage = false;\n+  auto is_or_oper = [&](Node* n) { return n != nullptr && (n->Opcode() == Op_OrI || n->Opcode() == Op_OrL); };\n+\n+  \/\/ Check the Load node has the pattern \"(Or (LShift (Load .. ) ConI) ..)\" or \"(Or (Load ..) ..)\"\n+  for (DUIterator_Fast imax, iter = check->fast_outs(imax); iter < imax; iter++) {\n+    Node *out = check->fast_out(iter);\n+    switch (out->Opcode()) {\n+      case Op_OrI:\n+      case Op_OrL:\n+        if (or_oper == nullptr) {\n+          or_oper = out;\n+          shift = 0;\n+        } else {\n+          \/\/ Too much Or usages\n+          return nullptr;\n+        }\n+        break;\n+      case Op_CallStaticJava:\n+        if (!out->as_CallStaticJava()->is_uncommon_trap()) {\n+          \/\/ Only uncommon trap usage is accepted\n+          return nullptr;\n+        }\n+        has_uncommon_trap_usage = true;\n+        break;\n+      case Op_LShiftI:\n+      case Op_LShiftL:\n+        {\n+          Node* shift_oper = out->isa_LShift();\n+          if (shift_oper->outcnt() != 1 ||                    \/\/ Expect only one usage to Or node\n+              !is_or_oper(shift_oper->unique_out()) ||      \/\/ Not used by Or node\n+              !shift_oper->in(2)->is_ConI()) {              \/\/ Not shift by constant\n+            return nullptr;\n+          }\n+          if (or_oper == nullptr) {\n+            or_oper = shift_oper->unique_out();\n+          } else {\n+            \/\/ Too much Or usages\n+            return nullptr;\n+          }\n+          shift = shift_oper->in(2)->as_ConI()->get_int();\n+          if (shift % (load->memory_size() * BitsPerByte) != 0) {\n+            \/\/ Shift value is not aligned with memory size\n+            return nullptr;\n+          }\n+          break;\n+        }\n+      default:\n+        \/\/ can not handle other usage\n+        return nullptr;\n+    }\n+  }\n+  if (or_oper == nullptr) {\n+    return nullptr;\n+  }\n+  assert(shift != -1, \"must be set\");\n+  \/\/ Check if the or_oper is the last operation of merge loads\n+  \/\/ If its unique output is another Or node, it may be in the middle of merge list\n+  \/\/ otherwise we reach the end of merge list\n+  bool last_op =  or_oper->outcnt() != 1 || !is_or_oper(or_oper->unique_out());\n+  MergeLoadInfo* info = new MergeLoadInfo(load, or_oper, shift);\n+  info->set_has_uncommon_usage(has_uncommon_trap_usage);\n+  info->set_last_op(last_op);\n+  return info;\n+}\n+\n+LoadNode* MergePrimitiveLoads::run() {\n+  if (!is_merged_load_candidate()) {\n+    return nullptr;\n+  }\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] candidate:\"); _load->dump(); tty->cr(); })\n+\n+  ResourceMark rm;\n+  MergeLoadInfoList merge_list;\n+  collect_merge_list(merge_list);\n+\n+  LoadNode* merged_load = make_merged_load(merge_list);\n+  NOT_PRODUCT( if (is_trace_success()) { tty->print(\"[TraceMergeLoads] merged load is:\"); merged_load->dump(); tty->cr(); })\n+\n+  return merged_load;\n+}\n+\n+\/\/ Check compatibility between _load and other_load.\n+bool MergePrimitiveLoads::is_compatible_load(const LoadNode* other_load) const {\n+  if (other_load == nullptr ||\n+      !is_supported_opcode(other_load->Opcode()) ||\n+      _load->memory_size() != other_load->memory_size()) {\n+    return false;\n+  }\n+\n+  assert(other_load->in(MemNode::Memory) == _load->in(MemNode::Memory), \"sanity\");\n+\n+  \/\/ To simplify, assume all loads have same control.\n+  if (other_load->in(MemNode::Control) != _load->in(MemNode::Control)) {\n+    return false;\n+  }\n+\n+  if (other_load->is_acquire() || !other_load->is_unordered()) {\n+    return false;\n+  }\n+\n+  \/\/ check alias\n+  Compile* C = _phase->C;\n+  if (C->get_alias_index(_phase->type(other_load->in(MemNode::Address))->is_ptr()) !=\n+      C->get_alias_index(_phase->type(_load->in(MemNode::Address))->is_ptr())) {\n+    return false;\n+  }\n+\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: compatible_load:\"); other_load->dump(); tty->cr(); })\n+  return true;\n+}\n+\n+MergePrimitiveLoads::MemoryAdjacentStatus MergePrimitiveLoads::get_adjacent_load_status(const LoadNode* first, const LoadNode* second) const {\n+  ResourceMark rm;\n+#ifndef PRODUCT\n+  const TraceMemPointer trace(is_trace_pointer_parsing(),\n+                              is_trace_pointer_aliasing(),\n+                              is_trace_pointer_adjacency(),\n+                              true);\n+#endif\n+  const MemPointer pointer_first(first NOT_PRODUCT(COMMA trace));\n+  const MemPointer pointer_second(second NOT_PRODUCT(COMMA trace));\n+  if (pointer_first.is_adjacent_to_and_before(pointer_second)) {\n+    return MergePrimitiveLoads::LowToHigh;\n+  } else if (pointer_second.is_adjacent_to_and_before(pointer_first)) {\n+    return MergePrimitiveLoads::HighToLow;\n+  } else {\n+    return MergePrimitiveLoads::NotAdjacent;\n+  }\n+}\n+\n+\/\/ From the candidate _load to collect load items for merging\n+void MergePrimitiveLoads::collect_merge_list(MergeLoadInfoList& merge_list) {\n+  const LoadNode* load = this->_load;\n+  const int max_bytes = 8; \/\/ The largest load is LoadLong\n+  const int max_merged_nodes = max_bytes\/load->memory_size();\n+\n+  MergeLoadInfo* array[8] = {nullptr};\n+#ifdef ASSERT\n+  for (auto & i : array) {\n+    assert(i == nullptr, \"must be initialized\");\n+  }\n+#endif\n+  \/\/ collect load nodes info from the same memory input\n+  Node* mem = _load->in(MemNode::Memory);\n+  int collected = 0;\n+  for (DUIterator_Fast imax, iter = mem->fast_outs(imax); iter < imax; iter++) {\n+    LoadNode* out = mem->fast_out(iter)->isa_Load();\n+    if (out == nullptr || !is_compatible_load(out)) continue;\n+\n+    MergeLoadInfo* info = merge_load_info(out);\n+    if (info == nullptr) continue;\n+    int index = info->_shift \/ (_load->memory_size() * BitsPerByte);\n+    if ( index < max_merged_nodes && array[index] == nullptr ) {\n+      array[index] = info;\n+      collected ++;\n+    } else {\n+      NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: merge_list:wrong index or duplicate loads at same place: index:%d\", index); out->dump(); array[index]->_load->dump(); tty->cr(); });\n+    }\n+  }\n+\n+#ifdef ASSERT\n+    if (is_trace_basic()) {\n+      tty->print_cr(\"[TraceMergeLoads]: dump draft merge info array, collected: %d\", collected);\n+      for (auto & info : array) {\n+        if (info) {\n+          info->dump();\n+        }\n+      }\n+    }\n+#endif\n+\n+  int bytes = collected * _load->memory_size();\n+  if (collected < 2 || !is_power_of_2(bytes)) {\n+    \/\/ too few or not aligned\n+    return;\n+  }\n+  if (_load != array[0]->_load && _load != array[collected]->_load && array[0] == nullptr) {\n+    \/\/ candidate is not in the list\n+    return;\n+  }\n+  \/\/ check loads are adjacent in the same order, and get the index of the last or operator\n+  MemoryAdjacentStatus order = Unknown;\n+  int last_op_index = array[0]->last_op() ? 0 : -1;\n+  for (int i = 1; i < collected; i++) {\n+    MergeLoadInfo* info = array[i];\n+    if (info == nullptr) {\n+      return;\n+    }\n+    MemoryAdjacentStatus adjacent = get_adjacent_load_status(array[i-1]->_load, info->_load);\n+    if (adjacent == NotAdjacent) {\n+      return;\n+    } else if (order == Unknown) {\n+      order = adjacent;\n+    } else if (adjacent != order) {\n+      \/\/ Different adjacent order\n+      return;\n+    }\n+\n+    if (info->last_op()) {\n+      if (last_op_index >= 0) {\n+        \/\/ Found multiple ends of list\n+        return;\n+      } else {\n+        last_op_index = i;\n+      }\n+    }\n+    \/\/ Check sign bit of load\n+    \/\/ For shifted value based on memory load, if it does not reach the sign bit of merged load,\n+    \/\/ the load must be an unsigned load\n+    if ((info->_shift + _load->memory_size() * BitsPerByte) != (collected * _load->memory_size() * BitsPerByte)) {\n+      if (!info->_load->is_unsigned()) {\n+        \/\/ no unsigned Load of LoadI, can we merge 2 LoadI?\n+        \/\/ we may check value, if it's greater than 0, it can be merged\n+        return;\n+      }\n+    }\n+  } \/\/ end of for-loop\n+\n+  if (last_op_index < 0) {\n+    \/\/ Not found last op\n+    return;\n+  }\n+\n+  \/\/ Check the merged load matches the platform endian and if require a reverse byte node\n+  \/\/ The list is sorted by shift value, the low bit part is in the beginning\n+  assert(order == LowToHigh || order == HighToLow, \"Invalid order should return early\");\n+#ifdef VM_LITTLE_ENDIAN\n+  \/\/ LowToHigh match the platform order\n+  if (order != LowToHigh && _load->memory_size() != 1) {\n+    return;\n+  }\n+  _require_reverse_bytes = (order == HighToLow);\n+#else\n+  \/\/ HighToLow match the platform order\n+  if (order != HighToLow && _load->memory_size() != 1) {\n+    return;\n+  }\n+  _require_reverse_bytes = (order == LowToHigh);\n+#endif\n+  if (_require_reverse_bytes &&\n+      (!Matcher::match_rule_supported(Op_ReverseBytesS) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesI) ||\n+       !Matcher::match_rule_supported(Op_ReverseBytesL))) {\n+    \/\/ Reverse Bytes is not supported\n+    return;\n+  }\n+\n+  \/\/ All checks are passed\n+  _last_op_index = last_op_index;\n+  _order = order;\n+  for (int i=0; i<collected; i++) {\n+    merge_list.push(array[i]);\n+  }\n+  return;\n+}\n+\n+\/\/ Make the merged load from list and replace the last Or oper\n+LoadNode* MergePrimitiveLoads::make_merged_load(const MergeLoadInfoList& merge_list) {\n+  if (merge_list.is_empty()) {\n+    return nullptr;\n+  }\n+\n+  assert(merge_list.length() >= 2 && _last_op_index >= 0 && _last_op_index < merge_list.length(), \"sanity\");\n+  LoadNode* load = _order == LowToHigh ? merge_list.at(0)->_load : merge_list.at(merge_list.length()-1)->_load;\n+  \/\/ Get address of merged load\n+  if (_order == LowToHigh) {\n+    load = merge_list.at(0)->_load;\n+  } else {\n+    load = merge_list.at(merge_list.length()-1)->_load;\n+  }\n+  Node* adr  = load->in(MemNode::Address);\n+  Node* ctrl = load->in(MemNode::Control);\n+  Node* mem  = load->in(MemNode::Memory);\n+  Node* last_op = merge_list.at(_last_op_index)->_or;\n+\n+  const TypePtr* at = load->adr_type();\n+  const Type* rt = nullptr;\n+\n+  int merge_size = merge_list.length() * _load->memory_size();\n+  BasicType bt = T_ILLEGAL;\n+  switch (merge_size) {\n+    case 2: bt = T_SHORT; rt = TypeInt::SHORT; break;\n+    case 4: bt = T_INT;   rt = TypeInt::INT;   break;\n+    case 8: bt = T_LONG;  rt = TypeLong::LONG; break;\n+    default: {\n+      ShouldNotReachHere();\n+      break;\n+    }\n+  }\n+\n+  LoadNode* merged_load = LoadNode::make(*_phase, ctrl, mem, adr,\n+                                         at, rt, bt, MemNode::unordered)->isa_Load();\n+\n+  if (merged_load == nullptr) {\n+    return nullptr;\n+  }\n+\n+  merged_load->set_unaligned_access();\n+\n+  \/\/ TODO: extract value for uncommon path\n+  Node* replace = merged_load;\n+  if (_require_reverse_bytes) {\n+    assert(_load->memory_size() == 1, \"only implemented for bytes\");\n+    if (merge_size == 8) {\n+      replace = _phase->transform(new ReverseBytesLNode(merged_load));\n+    } else if (merge_size == 4) {\n+      replace = _phase->transform(new ReverseBytesINode(merged_load));\n+    } else {\n+      assert(merge_size == 2, \"sanity check\");\n+      replace = _phase->transform(new ReverseBytesSNode(merged_load));\n+    }\n+    NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] new ReverseBytes node:\"); replace->dump(); tty->cr(); })\n+    _phase->is_IterGVN()->_worklist.push(replace);\n+  }\n+  assert(last_op != nullptr && (last_op->Opcode() == Op_OrI || last_op->Opcode() == Op_OrL), \"sanity\");\n+  _phase->is_IterGVN()->replace_node(last_op, replace);\n+  _phase->is_IterGVN()->_worklist.push(merged_load);\n+\n+  return merged_load;\n+}\n@@ -1965,1 +2485,15 @@\n-  return progress ? this : nullptr;\n+  if (progress) {\n+    return this;\n+  }\n+\n+  if (MergeLoads && UseUnalignedAccesses) {\n+    if (phase->C->merge_memops_phase()) {\n+      MergePrimitiveLoads merge(phase, this);\n+      Node* merged = merge.run();\n+      if (merged != nullptr) { return merged; }\n+    } else {\n+      phase->C->record_for_merge_memops_igvn(this);\n+    }\n+  }\n+\n+  return nullptr;\n@@ -3453,1 +3987,1 @@\n-    if (phase->C->merge_stores_phase()) {\n+    if (phase->C->merge_memops_phase()) {\n@@ -3469,1 +4003,1 @@\n-      phase->C->record_for_merge_stores_igvn(this);\n+      phase->C->record_for_merge_memops_igvn(this);\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":537,"deletions":3,"binary":false,"changes":540,"status":"modified"},{"patch":"@@ -511,2 +511,2 @@\n-  if (for_merge_stores_igvn()) {\n-    \/\/ Don't add cloned node to Compile::_for_merge_stores_igvn list automatically.\n+  if (for_merge_memops_igvn()) {\n+    \/\/ Don't add cloned node to Compile::_for_merge_memops_igvn list automatically.\n@@ -514,1 +514,1 @@\n-    n->remove_flag(Node::NodeFlags::Flag_for_merge_stores_igvn);\n+    n->remove_flag(Node::NodeFlags::Flag_for_merge_memops_igvn);\n@@ -623,2 +623,2 @@\n-  if (for_merge_stores_igvn()) {\n-    compile->remove_from_merge_stores_igvn(this);\n+  if (for_merge_memops_igvn()) {\n+    compile->remove_from_merge_memops_igvn(this);\n@@ -981,0 +981,10 @@\n+Node* Node::find_out_with(int opcode1, int opcode2) {\n+  for (DUIterator_Fast imax, i = fast_outs(imax); i < imax; i++) {\n+    Node* use = fast_out(i);\n+    if (use->Opcode() == opcode1 || use->Opcode() == opcode2) {\n+      return use;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":15,"deletions":5,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -508,0 +508,2 @@\n+  \/\/ Find out of current node that matches any of opcodes.\n+  Node* find_out_with(int opcode1, int opcode2);\n@@ -833,1 +835,1 @@\n-    Flag_for_merge_stores_igvn       = 1 << 16,\n+    Flag_for_merge_memops_igvn       = 1 << 16,\n@@ -1079,1 +1081,1 @@\n-  bool for_merge_stores_igvn() const { return (_flags & Flag_for_merge_stores_igvn) != 0; }\n+  bool for_merge_memops_igvn() const { return (_flags & Flag_for_merge_memops_igvn) != 0; }\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -91,1 +91,1 @@\n-  flags(AFTER_MERGE_STORES,             \"After Merge Stores\") \\\n+  flags(AFTER_MERGE_MEMOPS,             \"After Merge Memops\") \\\n","filename":"src\/hotspot\/share\/opto\/phasetype.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -137,0 +137,1 @@\n+namespace TraceMergeLoads = TraceMergeStores;\n","filename":"src\/hotspot\/share\/opto\/traceMergeStoresTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,326 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Utils;\n+import jdk.internal.misc.Unsafe;\n+import java.lang.reflect.Array;\n+import java.util.Map;\n+import java.util.HashMap;\n+import java.util.Random;\n+\n+\/*\n+ * @test\n+ * @summary Test merging of consecutive loads\n+ * @modules java.base\/jdk.internal.misc\n+ * @library \/test\/lib \/\n+ *\n+ * @run main compiler.c2.TestMergeLoads unaligned\n+ * @run main compiler.c2.TestMergeLoads aligned\n+ *\n+ * @requires os.arch != \"riscv64\" | vm.cpu.features ~= \".*zbb.*\"\n+ *\/\n+\n+public class TestMergeLoads {\n+    static int RANGE = 1000;\n+    private static final Unsafe UNSAFE = Unsafe.getUnsafe();\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    \/\/ Inputs\n+    byte[] aB = new byte[RANGE];\n+\n+    interface TestFunction {\n+        Object[] run(boolean isWarmUp, int rnd);\n+    }\n+\n+    Map<String, Map<String, TestFunction>> testGroups = new HashMap<String, Map<String, TestFunction>>();\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMergeLoads.class);\n+        framework.addFlags(\"--add-modules\", \"java.base\", \"--add-exports\", \"java.base\/jdk.internal.misc=ALL-UNNAMED\");\n+\n+        switch (args[0]) {\n+            case \"aligned\"     -> { framework.addFlags(\"-XX:-UseUnalignedAccesses\"); }\n+            case \"unaligned\"   -> { framework.addFlags(\"-XX:+UseUnalignedAccesses\"); }\n+            default -> { throw new RuntimeException(\"Test argument not recognized: \" + args[0]); }\n+        }\n+        framework.start();\n+    }\n+\n+    public TestMergeLoads() {\n+        testGroups.put(\"test1\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test1\").put(\"test1R\", (_,_) -> { return test1R(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1a\", (_,_) -> { return test1a(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1b\", (_,_) -> { return test1b(aB.clone()); });\n+        testGroups.get(\"test1\").put(\"test1c\", (_,_) -> { return test1c(aB.clone()); });\n+\n+        testGroups.put(\"test2\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test2\").put(\"test2R\", (_,_) -> { return test2R(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2a\", (_,_) -> { return test2a(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2b\", (_,_) -> { return test2b(aB.clone()); });\n+        testGroups.get(\"test2\").put(\"test2c\", (_,_) -> { return test2c(aB.clone()); });\n+    }\n+\n+    static void set_random(byte[] a) {\n+        for (int i = 0; i < a.length; i++) {\n+            a[i] = (byte)RANDOM.nextInt();\n+        }\n+    }\n+\n+    @Warmup(100)\n+    @Run(test = {\"test1a\",\n+                 \"test1b\",\n+                 \"test1c\",\n+                 \"test2a\",\n+                 \"test2b\",\n+                 \"test2c\"})\n+    public void runTests(RunInfo info) {\n+        \/\/ Repeat many times, so that we also have multiple iterations for post-warmup to potentially recompile\n+        int iters = info.isWarmUp() ? 1_000 : 50_000;\n+        for (int iter = 0; iter < iters; iter++) {\n+            \/\/ Write random values to inputs\n+            set_random(aB);\n+\n+            \/\/ Run all tests\n+            for (Map.Entry<String, Map<String,TestFunction>> group_entry : testGroups.entrySet()) {\n+                String group_name = group_entry.getKey();\n+                Map<String, TestFunction> group = group_entry.getValue();\n+                Object[] gold = null;\n+                String gold_name = \"NONE\";\n+                for (Map.Entry<String,TestFunction> entry : group.entrySet()) {\n+                    String name = entry.getKey();\n+                    TestFunction test = entry.getValue();\n+                    Object[] result = test.run(info.isWarmUp(), iter);\n+                    if (gold == null) {\n+                        gold = result;\n+                        gold_name = name;\n+                    } else {\n+                        verify(\"group \" + group_name + \", gold \" + gold_name + \", test \" + name, gold, result);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void verify(String name, Object[] gold, Object[] result) {\n+        if (gold.length != result.length) {\n+            throw new RuntimeException(\"verify \" + name + \": not the same number of outputs: gold.length = \" +\n+                                       gold.length + \", result.length = \" + result.length);\n+        }\n+        for (int i = 0; i < gold.length; i++) {\n+            Object g = gold[i];\n+            Object r = result[i];\n+            if (g.getClass() != r.getClass() || !g.getClass().isArray() || !r.getClass().isArray()) {\n+                throw new RuntimeException(\"verify \" + name + \": must both be array of same type:\" +\n+                                           \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                           \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+            if (g == r) {\n+                throw new RuntimeException(\"verify \" + name + \": should be two separate arrays (with identical content):\" +\n+                                           \" gold[\" + i + \"] == result[\" + i + \"]\");\n+            }\n+            if (Array.getLength(g) != Array.getLength(r)) {\n+                    throw new RuntimeException(\"verify \" + name + \": arrays must have same length:\" +\n+                                           \" gold[\" + i + \"].length = \" + Array.getLength(g) +\n+                                           \" result[\" + i + \"].length = \" + Array.getLength(r));\n+            }\n+            Class c = g.getClass().getComponentType();\n+            if (c == byte.class) {\n+                verifyB(name, i, (byte[])g, (byte[])r);\n+            } else if (c == short.class) {\n+                verifyS(name, i, (short[])g, (short[])r);\n+            } else if (c == int.class) {\n+                verifyI(name, i, (int[])g, (int[])r);\n+            } else if (c == long.class) {\n+                verifyL(name, i, (long[])g, (long[])r);\n+            } else {\n+                throw new RuntimeException(\"verify \" + name + \": array type not supported for verify:\" +\n+                                       \" gold[\" + i + \"].getClass() = \" + g.getClass().getSimpleName() +\n+                                       \" result[\" + i + \"].getClass() = \" + r.getClass().getSimpleName());\n+            }\n+        }\n+    }\n+\n+    static void verifyB(String name, int i, byte[] g, byte[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" = \" + String.format(\"%02X\", g[j] & 0xFF) +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j] +\n+                                           \" = \" + String.format(\"%02X\", r[j] & 0xFF));\n+            }\n+        }\n+    }\n+\n+    static void verifyS(String name, int i, short[] g, short[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyI(String name, int i, int[] g, int[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    static void verifyL(String name, int i, long[] g, long[] r) {\n+        for (int j = 0; j < g.length; j++) {\n+            if (g[j] != r[j]) {\n+                throw new RuntimeException(\"verify \" + name + \": arrays must have same content:\" +\n+                                           \" gold[\" + i + \"][\" + j + \"] = \" + g[j] +\n+                                           \" result[\" + i + \"][\" + j + \"] = \" + r[j]);\n+            }\n+        }\n+    }\n+\n+    @DontCompile\n+    static Object[] test1R(byte[] a) {\n+      int i1 = (a[0] & 0xff)         |\n+              ((a[1] & 0xff) << 8 )  |\n+              ((a[2] & 0xff) << 16)  |\n+              ((a[3] & 0xff) << 24);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_I, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test1a(byte[] a) {\n+      int i1 = (a[0] & 0xff)         |\n+              ((a[1] & 0xff) << 8 )  |\n+              ((a[2] & 0xff) << 16)  |\n+              ((a[3] & 0xff) << 24);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test1b(byte[] a) {\n+      int i1 = UNSAFE.getIntUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ false);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_I, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test1c(byte[] a) {\n+      int i1 =  (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)        |\n+               ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 8 ) |\n+               ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) << 16) |\n+               ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff) << 24);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @DontCompile\n+    static Object[] test2R(byte[] a) {\n+      long i1 =  ((long)(a[0] & 0xff)       )|\n+                (((long)(a[1] & 0xff)) << 8 )|\n+                (((long)(a[2] & 0xff)) << 16)|\n+                (((long)(a[3] & 0xff)) << 24)|\n+                (((long)(a[4] & 0xff)) << 32)|\n+                (((long)(a[5] & 0xff)) << 40)|\n+                (((long)(a[6] & 0xff)) << 48)|\n+                (((long)(a[7] & 0xff)) << 56);\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"big-endian\", \"true\"})\n+    static Object[] test2a(byte[] a) {\n+      long i1 =  ((long)(a[0] & 0xff)       )|\n+                (((long)(a[1] & 0xff)) << 8 )|\n+                (((long)(a[2] & 0xff)) << 16)|\n+                (((long)(a[3] & 0xff)) << 24)|\n+                (((long)(a[4] & 0xff)) << 32)|\n+                (((long)(a[5] & 0xff)) << 40)|\n+                (((long)(a[6] & 0xff)) << 48)|\n+                (((long)(a[7] & 0xff)) << 56);\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test2b(byte[] a) {\n+      long i1 = UNSAFE.getLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ false);\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test2c(byte[] a) {\n+      long i1 = ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)       )|\n+               (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 8 )|\n+               (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 16)|\n+               (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 24)|\n+               (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 32)|\n+               (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 40)|\n+               (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) << 48)|\n+               (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff)) << 56);\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeLoads.java","additions":326,"deletions":0,"binary":false,"changes":326,"status":"added"}]}