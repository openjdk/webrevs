{"files":[{"patch":"@@ -1931,0 +1931,3 @@\n+  \/\/ Extract value from merged load or value for uncommon trap\n+  template <typename TypeClass>\n+  void extract_value_for_uncommon_trap(Node* merged, MergeLoadInfo* info);\n@@ -1934,0 +1937,2 @@\n+  \/\/ Check the two Or Nodes can be reachable from one to another, and intermediate nodes are all Or Nodes\n+  static bool is_reachable_Or_nodes(const Node* from, const Node* to);\n@@ -2108,1 +2113,1 @@\n-  NOT_PRODUCT( if (is_trace_success()) { tty->print(\"[TraceMergeLoads] merged load is:\"); merged_load->dump(); tty->cr(); })\n+  NOT_PRODUCT( if (is_trace_success() && merged_load != nullptr) { tty->print(\"[TraceMergeLoads] merged load is:\"); merged_load->dump(); tty->cr(); })\n@@ -2143,0 +2148,41 @@\n+bool MergePrimitiveLoads::is_reachable_Or_nodes(const Node* from, const Node* to) {\n+  assert(from != nullptr && (from->Opcode() == Op_OrI || from->Opcode() == Op_OrL), \"sanity\");\n+  assert(to != nullptr && (to->Opcode() == Op_OrI || to->Opcode() == Op_OrL), \"sanity\");\n+  if (from == to) {\n+    return true;\n+  }\n+\n+  const int max_search_steps = 8;\n+  int step = 0;\n+  const Node* check = from;\n+  while (step < max_search_steps) {\n+    Node* next = nullptr;\n+    for (DUIterator_Fast imax, iter = check->fast_outs(imax); iter < imax; iter++) {\n+      Node* out = check->fast_out(iter);\n+      if (out == to) {\n+        return true;\n+      }\n+      if (out == nullptr || (out->Opcode() == Op_CallStaticJava && out->as_CallStaticJava()->is_uncommon_trap())) {\n+        \/\/ Skip null or uncommon trap\n+        continue;\n+      } else if (out->Opcode() == Op_OrI || out->Opcode() == Op_OrL){\n+        if (next != nullptr) {\n+          \/\/ Multiple Or usages\n+          return false;\n+        } else {\n+          next = out;\n+        }\n+      } else {\n+        \/\/ Other usage\n+        return false;\n+      }\n+    }\n+    if (next == nullptr) {\n+      return false;\n+    }\n+    check = next;\n+    step++;\n+  }\n+  return false;\n+}\n+\n@@ -2176,0 +2222,2 @@\n+  MergeLoadInfo* base = merge_load_info(_load);\n+  assert(base != nullptr, \"The candidate _load must be checked\");\n@@ -2182,1 +2230,7 @@\n-    if (info == nullptr) continue;\n+    if (info == nullptr ||\n+        (!is_reachable_Or_nodes(info->_or, base->_or) &&\n+         !is_reachable_Or_nodes(base->_or, info->_or))) {\n+      NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads]: merge_list:unreachable or nodes\"); base->_or->dump(); info->_or->dump(); tty->cr(); });\n+      continue;\n+    }\n+\n@@ -2184,1 +2238,1 @@\n-    if ( index < max_merged_nodes && array[index] == nullptr ) {\n+    if (index < max_merged_nodes && array[index] == nullptr) {\n@@ -2205,1 +2259,1 @@\n-  if (collected < 2 || !is_power_of_2(bytes)) {\n+  if (collected < 2 || bytes < 4 || !is_power_of_2(bytes)) {\n@@ -2237,0 +2291,5 @@\n+        if ((info->_or->Opcode() == Op_OrI && bytes != 4) ||\n+            (info->_or->Opcode() == Op_OrL && bytes != 8)) {\n+          \/\/ The merged load can not cover all bits of result value\n+          return;\n+        }\n@@ -2314,1 +2373,0 @@\n-    case 2: bt = T_SHORT; rt = TypeInt::SHORT; break;\n@@ -2317,0 +2375,1 @@\n+    case 2: \/\/ Not merged as LoadS\n@@ -2331,0 +2390,1 @@\n+  merged_load->set_mismatched_access();\n@@ -2332,1 +2392,0 @@\n-  \/\/ TODO: extract value for uncommon path\n@@ -2338,2 +2397,0 @@\n-    } else if (merge_size == 4) {\n-      replace = _phase->transform(new ReverseBytesINode(merged_load));\n@@ -2341,2 +2398,2 @@\n-      assert(merge_size == 2, \"sanity check\");\n-      replace = _phase->transform(new ReverseBytesSNode(merged_load));\n+      assert(merge_size == 4, \"sanity\");\n+      replace = _phase->transform(new ReverseBytesINode(merged_load));\n@@ -2347,0 +2404,11 @@\n+\n+  \/\/ extract value for uncommon path\n+  for (int i=0; i<merge_list.length(); i++) {\n+    if (merge_list.at(i)->has_uncommon_usage()) {\n+      if (merge_size == 8) {\n+        extract_value_for_uncommon_trap<TypeLong>(replace, merge_list.at(i));\n+      } else {\n+        extract_value_for_uncommon_trap<TypeInt>(replace, merge_list.at(i));\n+      }\n+    }\n+  }\n@@ -2354,0 +2422,52 @@\n+template <typename TypeClass>\n+void MergePrimitiveLoads::extract_value_for_uncommon_trap(Node* merged, MergeLoadInfo* info) {\n+  assert(merged->bottom_type()->is_int() || merged->bottom_type()->is_long(), \"sanity\");\n+  int merged_bits = merged->bottom_type()->is_int() ? 32 : 64;\n+  int load_bits = info->_load->memory_size() * BitsPerByte;\n+  Node* value = merged;\n+  if (info->_load->is_unsigned()) {\n+    \/\/ RShift and Mask\n+    \/\/ merged value: |.........|value|........|\n+    \/\/                  l1      _load   l2\n+    \/\/  value is unsianged value from _load, _shift is l2\n+    \/\/  extract:  (merged >> l2) & ((1 << load_bits) - 1)\n+    \/\/\n+    if (info->_shift > 0) {\n+      value = make_urshift<TypeClass>(value, _phase->intcon(info->_shift));\n+    }\n+    if ((load_bits + info->_shift) < merged_bits) {\n+      assert(load_bits < 32, \"sanity\");\n+      int mask = (1 << load_bits) - 1;\n+      value = make_and<TypeClass>(value, _phase->intcon(mask));\n+    }\n+  } else {\n+    \/\/ LShift and RShift\n+    \/\/\n+    \/\/ merged value: |.........|value|........|\n+    \/\/                  l1      _load   l2\n+    \/\/  value is igned value from _load, _shift is l2\n+    \/\/  extract:  (merged << l1) >> (merged_bits - load_bits)\n+    \/\/\n+    if ((info->_load->memory_size() + info->_shift) < merged_bits) {\n+      value = LShiftNode::make(value, _phase->intcon(merged_bits - info->_shift - info->_load->memory_size()),\n+                               merged_bits == 32 ? T_INT: T_LONG);\n+    }\n+    value = make_rshift<TypeClass>(value, _phase->intcon(merged_bits - load_bits));\n+  }\n+  if (merged_bits == 64) {\n+    \/\/ need L2I\n+    value = new ConvL2INode(value);\n+  }\n+  assert(value != nullptr, \"sanity\");\n+\n+  \/\/ Replace the edge of uncommon trap\n+  Node * loaded = by_pass_i2l(info->_load);\n+  for (DUIterator_Last imin, i = loaded->last_outs(imin); i >= imin; --i) {\n+    Node* out = loaded->last_out(i);\n+    if (out->is_CallStaticJava()) {\n+      out->replace_edge(loaded, value, _phase);\n+    }\n+  }\n+  NOT_PRODUCT( if (is_trace_basic()) { tty->print(\"[TraceMergeLoads] extract value for uncommon trap:\"); _load->dump(); value->dump(); tty->cr(); })\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":130,"deletions":10,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -405,0 +405,12 @@\n+template <typename TypeClass>\n+Node* make_rshift(Node* a, Node* b);\n+\n+template <>\n+inline Node* make_rshift<TypeLong>(Node* a, Node* b) {\n+  return new RShiftLNode(a, b);\n+}\n+\n+template <>\n+inline Node* make_rshift<TypeInt>(Node* a, Node* b) {\n+  return new RShiftINode(a, b);\n+}\n","filename":"src\/hotspot\/share\/opto\/mulnode.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+        \/\/ Get int in little endian\n@@ -80,0 +81,1 @@\n+        \/\/ Get long in little endian\n@@ -85,0 +87,14 @@\n+\n+        \/\/ Get int in big endian\n+        testGroups.put(\"test3\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test3\").put(\"test3R\", (_,_) -> { return test3R(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3a\", (_,_) -> { return test3a(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3b\", (_,_) -> { return test3b(aB.clone()); });\n+        testGroups.get(\"test3\").put(\"test3c\", (_,_) -> { return test3c(aB.clone()); });\n+\n+        \/\/ Get long in big endian\n+        testGroups.put(\"test4\", new HashMap<String,TestFunction>());\n+        testGroups.get(\"test4\").put(\"test4R\", (_,_) -> { return test4R(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4a\", (_,_) -> { return test4a(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4b\", (_,_) -> { return test4b(aB.clone()); });\n+        testGroups.get(\"test4\").put(\"test4c\", (_,_) -> { return test4c(aB.clone()); });\n@@ -99,1 +115,8 @@\n-                 \"test2c\"})\n+                 \"test2c\",\n+                 \"test3a\",\n+                 \"test3b\",\n+                 \"test3c\",\n+                 \"test4a\",\n+                 \"test4b\",\n+                 \"test4c\"\n+                })\n@@ -209,0 +232,4 @@\n+    \/**\n+     * Group 1\n+     *   get int in little endian mode\n+     *\/\n@@ -262,0 +289,4 @@\n+    \/**\n+     * Group 2\n+     *   get long in little endian mode\n+     *\/\n@@ -326,0 +357,126 @@\n+\n+    \/**\n+     * Group 3\n+     *   get int in big endian mode\n+     *\/\n+    @DontCompile\n+    static Object[] test3R(byte[] a) {\n+      int i1 = ((a[0] & 0xff) << 24) |\n+               ((a[1] & 0xff) << 16) |\n+               ((a[2] & 0xff) <<  8) |\n+                (a[3] & 0xff);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_I, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test3a(byte[] a) {\n+      int i1 = ((a[0] & 0xff) << 24) |\n+               ((a[1] & 0xff) << 16) |\n+               ((a[2] & 0xff) <<  8) |\n+                (a[3] & 0xff);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test3b(byte[] a) {\n+      int i1 = UNSAFE.getIntUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ true);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_I, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_I_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test3c(byte[] a) {\n+      int i1 = ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff) << 24) |\n+               ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff) << 16) |\n+               ((UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff) <<  8) |\n+                (UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff);\n+      int[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    \/**\n+     * Group 4\n+     *   get long in big endian mode\n+     *\/\n+    @DontCompile\n+    static Object[] test4R(byte[] a) {\n+      long i1 = (((long)(a[0] & 0xff)) << 56)|\n+                (((long)(a[1] & 0xff)) << 48)|\n+                (((long)(a[2] & 0xff)) << 40)|\n+                (((long)(a[3] & 0xff)) << 32)|\n+                (((long)(a[4] & 0xff)) << 24)|\n+                (((long)(a[5] & 0xff)) << 16)|\n+                (((long)(a[6] & 0xff)) <<  8)|\n+                 ((long)(a[7] & 0xff));\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"big-endian\", \"true\"})\n+    static Object[] test4a(byte[] a) {\n+      long i1 = (((long)(a[0] & 0xff)) << 56)|\n+                (((long)(a[1] & 0xff)) << 48)|\n+                (((long)(a[2] & 0xff)) << 40)|\n+                (((long)(a[3] & 0xff)) << 32)|\n+                (((long)(a[4] & 0xff)) << 24)|\n+                (((long)(a[5] & 0xff)) << 16)|\n+                (((long)(a[6] & 0xff)) <<  8)|\n+                 ((long)(a[7] & 0xff));\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"})\n+    static Object[] test4b(byte[] a) {\n+      long i1 = UNSAFE.getLongUnaligned(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET, \/* big-endian *\/ true);\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\",\n+                  IRNode.REVERSE_BYTES_L, \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatformAnd = {\"little-endian\", \"true\"})\n+    @IR(counts = {IRNode.LOAD_L_OF_CLASS, \"byte\\\\\\\\[int:>=0] \\\\\\\\(java\/lang\/Cloneable,java\/io\/Serializable\\\\\\\\)\", \"1\"},\n+        applyIf = {\"UseUnalignedAccesses\", \"true\"},\n+        applyIfPlatform = {\"big-endian\", \"true\"})\n+    static Object[] test4c(byte[] a) {\n+      long i1 = (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 0) & 0xff)) << 56)|\n+                (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 1) & 0xff)) << 48)|\n+                (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 2) & 0xff)) << 40)|\n+                (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 3) & 0xff)) << 32)|\n+                (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 4) & 0xff)) << 24)|\n+                (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 5) & 0xff)) << 16)|\n+                (((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 6) & 0xff)) <<  8)|\n+                 ((long)(UNSAFE.getByte(a, UNSAFE.ARRAY_BYTE_BASE_OFFSET + 7) & 0xff));\n+      long[] ret = {i1};\n+      return new Object[]{ret};\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestMergeLoads.java","additions":158,"deletions":1,"binary":false,"changes":159,"status":"modified"}]}