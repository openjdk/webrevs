{"files":[{"patch":"@@ -708,0 +708,10 @@\n+  void fencei() {\n+    unsigned insn = 0;\n+    patch((address)&insn,  6,  0, 0b0001111);      \/\/ opcode\n+    patch((address)&insn, 11,  7, 0b00000);        \/\/ rd\n+    patch((address)&insn, 14, 12, 0b001);          \/\/ func\n+    patch((address)&insn, 19, 15, 0b00000);        \/\/ rs1\n+    patch((address)&insn, 31, 20, 0b000000000000); \/\/ fm\n+    emit(insn);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -639,2 +639,6 @@\n-  \/\/ A full fence is generated before icache_flush by default in invalidate_word\n-  ICache::invalidate_range(addr, bytes);\n+  if (!UseCtxFencei) {\n+    \/\/ A full fence is generated before icache_flush by default in invalidate_word\n+    ICache::invalidate_range(addr, bytes);\n+  } else {\n+    OrderAccess::fence();\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/z\/zBarrierSetAssembler_riscv.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -125,1 +125,3 @@\n-          \"Far calls uses jal to trampoline.\")\n+          \"Far calls uses jal to trampoline.\")                                   \\\n+  product(bool, UseCtxFencei, false, EXPERIMENTAL,                               \\\n+          \"Use PR_RISCV_CTX_SW_FENCEI_ON to avoid explicit icache flush\")\n","filename":"src\/hotspot\/cpu\/riscv\/globals_riscv.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -3174,0 +3174,7 @@\n+void MacroAssembler::cmodx_fence() {\n+  BLOCK_COMMENT(\"cmodx fence\");\n+  if (VM_Version::supports_fencei_barrier()) {\n+    Assembler::fencei();\n+  }\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -434,0 +434,2 @@\n+  void cmodx_fence();\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,4 @@\n-  ICache::invalidate_range(addr(), bytes);\n+\n+  if (!UseCtxFencei) {\n+    ICache::invalidate_range(addr(), bytes);\n+  }\n","filename":"src\/hotspot\/cpu\/riscv\/relocInfo_riscv.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2431,0 +2431,8 @@\n+      \/\/ There are two ways this can work:\n+      \/\/ - The writer did system icache shootdown after the instruction stream update.\n+      \/\/   Hence do nothing.\n+      \/\/ - The writer trust us to make sure our icache is in sync before entering.\n+      \/\/   Hence use cmodx fence (fence.i, may change).\n+      if (UseCtxFencei) {\n+        __ cmodx_fence();\n+      }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -288,0 +288,1 @@\n+  static bool supports_fencei_barrier() { return ext_Zifencei.enabled(); }\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,18 @@\n+  \/\/ From 3 “Zifencei” Instruction-Fetch Fence, Version 2.0\n+  \/\/ \"RISC-V does not guarantee that stores to instruction memory will be made\n+  \/\/ visible to instruction fetches on a RISC-V hart until that hart executes a\n+  \/\/ FENCE.I instruction. A FENCE.I instruction ensures that a subsequent\n+  \/\/ instruction fetch on a RISC-V hart will see any previous data stores\n+  \/\/ already visible to the same RISC-V hart. FENCE.I does not ensure that other\n+  \/\/ RISC-V harts’ instruction fetches will observe the local hart’s stores in a\n+  \/\/ multiprocessor system.\"\n+  \/\/\n+  \/\/ Hence to be able to use fence.i directly we need a kernel that supports\n+  \/\/ PR_RISCV_CTX_SW_FENCEI_ON. Thus if context switch to another hart we are\n+  \/\/ ensured that instruction fetch will see any previous data stores\n+  \/\/\n+  \/\/ The alternative is using full system IPI (system wide icache sync) then\n+  \/\/ this barrier is not strictly needed. As this is emitted in runtime slow-path\n+  \/\/ we will just always emit it, typically after a safepoint.\n+  guarantee(VM_Version::supports_fencei_barrier(), \"Linux kernel require fence.i\");\n+  __asm__ volatile(\"fence.i\" : : : \"memory\");\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/orderAccess_linux_riscv.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include <sys\/prctl.h>\n@@ -85,0 +86,17 @@\n+\/\/ prctl PR_RISCV_SET_ICACHE_FLUSH_CTX is from Linux 6.9\n+#ifndef PR_RISCV_SET_ICACHE_FLUSH_CTX\n+#define PR_RISCV_SET_ICACHE_FLUSH_CTX 71\n+#endif\n+#ifndef PR_RISCV_CTX_SW_FENCEI_ON\n+#define PR_RISCV_CTX_SW_FENCEI_ON  0\n+#endif\n+#ifndef PR_RISCV_CTX_SW_FENCEI_OFF\n+#define PR_RISCV_CTX_SW_FENCEI_OFF 1\n+#endif\n+#ifndef PR_RISCV_SCOPE_PER_PROCESS\n+#define PR_RISCV_SCOPE_PER_PROCESS 0\n+#endif\n+#ifndef PR_RISCV_SCOPE_PER_THREAD\n+#define PR_RISCV_SCOPE_PER_THREAD  1\n+#endif\n+\n@@ -105,0 +123,1 @@\n+\n@@ -158,0 +177,18 @@\n+  \/\/ Linux kernel require Zifencei\n+  if (!ext_Zifencei.enabled()) {\n+    log_info(os, cpu)(\"Zifencei not found, required by Linux, enabling.\");\n+    ext_Zifencei.enable_feature();\n+  }\n+\n+  if (UseCtxFencei) {\n+    \/\/ Note that we can set this up only for effected threads\n+    \/\/ via PR_RISCV_SCOPE_PER_THREAD, i.e. on VM attach\/deattach.\n+    int ret = prctl(PR_RISCV_SET_ICACHE_FLUSH_CTX, PR_RISCV_CTX_SW_FENCEI_ON, PR_RISCV_SCOPE_PER_PROCESS);\n+    if (ret == 0) {\n+      log_debug(os, cpu)(\"UseCtxFencei (PR_RISCV_CTX_SW_FENCEI_ON) enabled.\");\n+    } else {\n+      FLAG_SET_ERGO(UseCtxFencei, false);\n+      log_info(os, cpu)(\"UseCtxFencei (PR_RISCV_CTX_SW_FENCEI_ON) disabled, unsupported by kernel.\");\n+    }\n+  }\n+\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/vm_version_linux_riscv.cpp","additions":37,"deletions":0,"binary":false,"changes":37,"status":"modified"}]}