{"files":[{"patch":"@@ -333,0 +333,8 @@\n+public:\n+\n+  enum class FLOAT_TYPE {\n+    half_precision,\n+    single_precision,\n+    double_precision\n+  };\n+\n@@ -1319,0 +1327,1 @@\n+  void  flh(FloatRegister Rd, Register Rs, const int32_t offset) { fp_load<0b001>(Rd, Rs, offset); }\n@@ -1400,0 +1409,40 @@\n+  void fadd_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00000>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fsub_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00001>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fmul_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00010>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fdiv_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00011>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fsqrt_h(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b01011>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fmin_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00101>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void fmax_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00101>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void fmadd_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne)  {\n+    assert_cond(UseZfh);\n+    fp_fm<H_16_hp, 0b1000011>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2166,1 +2166,3 @@\n-                                  bool is_double, bool is_min) {\n+                                  FLOAT_TYPE ft, bool is_min) {\n+  assert_cond((ft != FLOAT_TYPE::half_precision) || UseZfh);\n+\n@@ -2169,4 +2171,16 @@\n-  is_double ? fclass_d(t0, src1)\n-            : fclass_s(t0, src1);\n-  is_double ? fclass_d(t1, src2)\n-            : fclass_s(t1, src2);\n+  switch (ft) {\n+    case FLOAT_TYPE::half_precision:\n+      fclass_h(t0, src1);\n+      fclass_h(t1, src2);\n+      break;\n+    case FLOAT_TYPE::single_precision:\n+      fclass_s(t0, src1);\n+      fclass_s(t1, src2);\n+      break;\n+    case FLOAT_TYPE::double_precision:\n+      fclass_d(t0, src1);\n+      fclass_d(t1, src2);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -2176,2 +2190,13 @@\n-  is_double ? fadd_d(dst, src1, src2)\n-            : fadd_s(dst, src1, src2);\n+  switch (ft) {\n+    case FLOAT_TYPE::half_precision:\n+      fadd_h(dst, src1, src2);\n+      break;\n+    case FLOAT_TYPE::single_precision:\n+      fadd_s(dst, src1, src2);\n+      break;\n+    case FLOAT_TYPE::double_precision:\n+      fadd_d(dst, src1, src2);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -2181,3 +2206,14 @@\n-  if (is_double) {\n-    is_min ? fmin_d(dst, src1, src2)\n-           : fmax_d(dst, src1, src2);\n+  if (is_min) {\n+    switch (ft) {\n+      case FLOAT_TYPE::half_precision:\n+        fmin_h(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::single_precision:\n+        fmin_s(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::double_precision:\n+        fmin_d(dst, src1, src2);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -2185,2 +2221,13 @@\n-    is_min ? fmin_s(dst, src1, src2)\n-           : fmax_s(dst, src1, src2);\n+    switch (ft) {\n+      case FLOAT_TYPE::half_precision:\n+        fmax_h(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::single_precision:\n+        fmax_s(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::double_precision:\n+        fmax_d(dst, src1, src2);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":59,"deletions":12,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -177,1 +177,1 @@\n-                 bool is_double, bool is_min);\n+                 FLOAT_TYPE ft, bool is_min);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1083,0 +1083,1 @@\n+  INSN(flh);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1921,0 +1921,3 @@\n+      return VM_Version::supports_float16_to_float();\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n@@ -1922,0 +1925,9 @@\n+    case Op_AddHF:\n+    case Op_DivHF:\n+    case Op_FmaHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MulHF:\n+    case Op_SubHF:\n+    case Op_SqrtHF:\n+      return UseZfh;\n@@ -3060,0 +3072,21 @@\n+\/\/ Half Float Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Half Float Immediate: +0.0f.\n+operand immH0()\n+%{\n+  predicate(jint_cast(n->geth()) == 0);\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4911,0 +4944,33 @@\n+\/\/ Load Half Float Constant\n+instruct loadConH(fRegF dst, immH con) %{\n+  match(Set dst con);\n+\n+  ins_cost(LOAD_COST);\n+  format %{\n+    \"flh $dst, [$constantaddress]\\t# load from constant table: float=$con, #@loadConH\"\n+  %}\n+\n+  ins_encode %{\n+    assert(UseZfh || UseZfhmin, \"must\");\n+    __ flh(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    \/\/ TODO: add zfa instructions for half float, and optimize here.\n+  %}\n+\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n+instruct loadConH0(fRegF dst, immH0 con) %{\n+  match(Set dst con);\n+\n+  ins_cost(XFER_COST);\n+\n+  format %{ \"fmv.h.x $dst, zr\\t# float, #@loadConH0\" %}\n+\n+  ins_encode %{\n+    assert(UseZfh || UseZfhmin, \"must\");\n+    __ fmv_h_x(as_FloatRegister($dst$$reg), zr);\n+  %}\n+\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n@@ -7295,1 +7361,1 @@\n-                 false \/* is_double *\/, false \/* is_min *\/);\n+                 __ FLOAT_TYPE::single_precision, false \/* is_min *\/);\n@@ -7311,1 +7377,1 @@\n-                 false \/* is_double *\/, true \/* is_min *\/);\n+                 __ FLOAT_TYPE::single_precision, true \/* is_min *\/);\n@@ -7327,1 +7393,1 @@\n-                 true \/* is_double *\/, false \/* is_min *\/);\n+                 __ FLOAT_TYPE::double_precision, false \/* is_min *\/);\n@@ -7343,1 +7409,1 @@\n-                 true \/* is_double *\/, true \/* is_min *\/);\n+                 __ FLOAT_TYPE::double_precision, true \/* is_min *\/);\n@@ -8013,0 +8079,11 @@\n+instruct castHH(fRegF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n@@ -8175,0 +8252,110 @@\n+\/\/ half precision operations\n+\n+instruct reinterpretS2HF(fRegF dst, iRegINoSp src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fmv.h.x $dst, $src\" %}\n+  ins_encode %{\n+    __ fmv_h_x($dst$$FloatRegister, $src$$Register);\n+  %}\n+  ins_pipe(fp_i2f);\n+%}\n+\n+instruct convF2HFAndS2HF(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvt_h_s($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct reinterpretHF2S(iRegINoSp dst, fRegF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fmv.x.h $dst, $src\" %}\n+  ins_encode %{\n+    __ fmv_x_h($dst$$Register, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_f2i);\n+%}\n+\n+instruct convHF2SAndHF2F(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvt_s_h($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct sqrt_HF_reg(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (SqrtHF src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fsqrt.h $dst, $src\" %}\n+  ins_encode %{\n+    __ fsqrt_h($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_sqrt_s);\n+%}\n+\n+instruct binOps_HF_reg(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  match(Set dst (SubHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"binop_hf $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    switch(opcode) {\n+      case Op_AddHF: __ fadd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_SubHF: __ fsub_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_MulHF: __ fmul_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_DivHF: __ fdiv_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      default: assert(false, \"%s is not supported here\", NodeClassNames[opcode]); break;\n+    }\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+instruct min_max_HF_reg(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  match(Set dst (MinHF src1 src2));\n+  match(Set dst (MaxHF src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"min_max_hf $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    switch(opcode) {\n+      case Op_MinHF: __ minmax_fp($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                                  __ FLOAT_TYPE::half_precision, true);\n+                     break;\n+      case Op_MaxHF: __ minmax_fp($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                                  __ FLOAT_TYPE::half_precision, false);\n+                     break;\n+      default: assert(false, \"%s is not supported here\", NodeClassNames[opcode]); break;\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct fma_HF_reg(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  match(Set dst (FmaHF src2 (Binary dst src1)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fmadd.h $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    __ fmadd_h($dst$$FloatRegister, $dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":191,"deletions":4,"binary":false,"changes":195,"status":"modified"},{"patch":"@@ -6159,0 +6159,98 @@\n+  \/\/ x10 = input (float16)\n+  \/\/ f10 = result (float)\n+  \/\/ t1  = temporary register\n+  address generate_float16ToFloat() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubCodeMark mark(this, stub_id);\n+    address entry = __ pc();\n+    BLOCK_COMMENT(\"float16ToFloat:\");\n+\n+    FloatRegister dst = f10;\n+    Register src = x10;\n+    Label NaN_SLOW;\n+\n+    assert(VM_Version::supports_float16_to_float(), \"must\");\n+\n+    \/\/ On riscv, NaN needs a special process as fcvt does not work in that case.\n+    \/\/ On riscv, Inf does not need a special process as fcvt can handle it correctly.\n+    \/\/ but we consider to get the slow path to process NaN and Inf at the same time,\n+    \/\/ as both of them are rare cases, and if we try to get the slow path to handle\n+    \/\/ only NaN case it would sacrifise the performance for normal cases,\n+    \/\/ i.e. non-NaN and non-Inf cases.\n+\n+    \/\/ check whether it's a NaN or +\/- Inf.\n+    __ mv(t0, 0x7c00);\n+    __ andr(t1, src, t0);\n+    \/\/ jump to stub processing NaN and Inf cases.\n+    __ beq(t0, t1, NaN_SLOW);\n+\n+    \/\/ non-NaN or non-Inf cases, just use built-in instructions.\n+    __ fmv_h_x(dst, src);\n+    __ fcvt_s_h(dst, dst);\n+    __ ret();\n+\n+    __ bind(NaN_SLOW);\n+    \/\/ following instructions mainly focus on NaN, as riscv does not handle\n+    \/\/ NaN well with fcvt, but the code also works for Inf at the same time.\n+\n+    \/\/ construct a NaN in 32 bits from the NaN in 16 bits,\n+    \/\/ we need the payloads of non-canonical NaNs to be preserved.\n+    __ mv(t1, 0x7f800000);\n+    \/\/ sign-bit was already set via sign-extension if necessary.\n+    __ slli(t0, src, 13);\n+    __ orr(t1, t0, t1);\n+    __ fmv_w_x(dst, t1);\n+\n+    __ ret();\n+    return entry;\n+  }\n+\n+  \/\/ f10 = input (float)\n+  \/\/ x10 = result (float16)\n+  \/\/ f11 = temporary float register\n+  \/\/ t1  = temporary register\n+  address generate_floatToFloat16() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubCodeMark mark(this, stub_id);\n+    address entry = __ pc();\n+    BLOCK_COMMENT(\"floatToFloat16:\");\n+\n+    Register dst = x10;\n+    FloatRegister src = f10, ftmp = f11;\n+    Label NaN_SLOW;\n+\n+    assert(VM_Version::supports_float16_to_float(), \"must\");\n+\n+    \/\/ On riscv, NaN needs a special process as fcvt does not work in that case.\n+\n+    \/\/ check whether it's a NaN.\n+    \/\/ replace fclass with feq as performance optimization.\n+    __ feq_s(t0, src, src);\n+    \/\/ jump to stub processing NaN cases.\n+    __ beqz(t0, NaN_SLOW);\n+\n+    \/\/ non-NaN cases, just use built-in instructions.\n+    __ fcvt_h_s(ftmp, src);\n+    __ fmv_x_h(dst, ftmp);\n+    __ ret();\n+\n+    __ bind(NaN_SLOW);\n+    __ fmv_x_w(dst, src);\n+\n+    \/\/ preserve the payloads of non-canonical NaNs.\n+    __ srai(dst, dst, 13);\n+    \/\/ preserve the sign bit.\n+    __ srai(t1, dst, 13);\n+    __ slli(t1, t1, 10);\n+    __ mv(t0, 0x3ff);\n+    __ orr(t1, t1, t0);\n+\n+    \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n+    __ andr(dst, dst, t1);\n+\n+    __ ret();\n+    return entry;\n+  }\n+\n@@ -6528,0 +6626,6 @@\n+\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToFloat) &&\n+        vmIntrinsics::is_intrinsic_available(vmIntrinsics::_floatToFloat16)) {\n+      StubRoutines::_hf2f = generate_float16ToFloat();\n+      StubRoutines::_f2hf = generate_floatToFloat16();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":104,"deletions":0,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"classfile\/vmIntrinsics.hpp\"\n@@ -467,0 +468,15 @@\n+\n+bool VM_Version::is_intrinsic_supported(vmIntrinsicID id) {\n+  assert(id != vmIntrinsics::_none, \"must be a VM intrinsic\");\n+  switch (id) {\n+  case vmIntrinsics::_floatToFloat16:\n+  case vmIntrinsics::_float16ToFloat:\n+    if (!supports_float16_to_float()) {\n+      return false;\n+    }\n+    break;\n+  default:\n+    break;\n+  }\n+  return true;\n+}\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -300,0 +300,7 @@\n+\n+  static bool supports_float16_to_float() {\n+    return UseZfh || UseZfhmin;\n+  }\n+\n+  \/\/ Check intrinsic support\n+  static bool is_intrinsic_supported(vmIntrinsicID id);\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConvF2HFIdealizationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -117,1 +117,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -128,1 +128,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -140,1 +140,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -151,1 +151,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -162,1 +162,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -173,1 +173,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -184,1 +184,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -195,1 +195,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -206,1 +206,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -217,1 +217,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -229,1 +229,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -246,1 +246,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -283,1 +283,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -326,1 +326,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -359,1 +359,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -377,1 +377,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -394,1 +394,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -434,1 +434,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -457,1 +457,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -476,1 +476,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -511,1 +511,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -550,1 +550,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+        \"zfh\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -48,2 +48,0 @@\n-    @IR(applyIfCPUFeature = {\"zvfh\", \"true\"},\n-        counts = {IRNode.VECTOR_CAST_HF2F, IRNode.VECTOR_SIZE_ANY, \">= 1\", IRNode.VECTOR_CAST_F2HF, IRNode.VECTOR_SIZE_ANY, \" >= 1\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorization\/TestFloat16VectorConvChain.java","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}