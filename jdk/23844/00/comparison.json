{"files":[{"patch":"@@ -333,0 +333,8 @@\n+public:\n+\n+  enum class FLOAT_TYPE {\n+    half_precision,\n+    single_precision,\n+    double_precision\n+  };\n+\n@@ -1319,0 +1327,1 @@\n+  void  flh(FloatRegister Rd, Register Rs, const int32_t offset) { fp_load<0b001>(Rd, Rs, offset); }\n@@ -1400,0 +1409,40 @@\n+  void fadd_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00000>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fsub_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00001>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fmul_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00010>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fdiv_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00011>(Rd, Rs1, Rs2, rm);\n+  }\n+\n+  void fsqrt_h(FloatRegister Rd, FloatRegister Rs1, RoundingMode rm = rne) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b01011>(Rd, Rs1, 0b00000, rm);\n+  }\n+\n+  void fmin_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00101>(Rd, Rs1, Rs2, 0b000);\n+  }\n+\n+  void fmax_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2) {\n+    assert_cond(UseZfh);\n+    fp_base<H_16_hp, 0b00101>(Rd, Rs1, Rs2, 0b001);\n+  }\n+\n+  void fmadd_h(FloatRegister Rd, FloatRegister Rs1, FloatRegister Rs2, FloatRegister Rs3, RoundingMode rm = rne)  {\n+    assert_cond(UseZfh);\n+    fp_fm<H_16_hp, 0b1000011>(Rd, Rs1, Rs2, Rs3, rm);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2137,3 +2137,5 @@\n-                                  bool is_double, bool is_min) {\n-  assert_different_registers(dst, src1);\n-  assert_different_registers(dst, src2);\n+                                  FLOAT_TYPE ft, bool is_min) {\n+  assert_different_registers(dst, src1, src2);\n+  if (ft == FLOAT_TYPE::half_precision) {\n+    assert_cond(UseZfh);\n+  }\n@@ -2143,4 +2145,16 @@\n-  is_double ? fclass_d(t0, src1)\n-            : fclass_s(t0, src1);\n-  is_double ? fclass_d(t1, src2)\n-            : fclass_s(t1, src2);\n+  switch (ft) {\n+    case FLOAT_TYPE::half_precision:\n+      fclass_h(t0, src1);\n+      fclass_h(t1, src2);\n+      break;\n+    case FLOAT_TYPE::single_precision:\n+      fclass_s(t0, src1);\n+      fclass_s(t1, src2);\n+      break;\n+    case FLOAT_TYPE::double_precision:\n+      fclass_d(t0, src1);\n+      fclass_d(t1, src2);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -2150,2 +2164,13 @@\n-  is_double ? fadd_d(dst, src1, src2)\n-            : fadd_s(dst, src1, src2);\n+  switch (ft) {\n+    case FLOAT_TYPE::half_precision:\n+      fadd_h(dst, src1, src2);\n+      break;\n+    case FLOAT_TYPE::single_precision:\n+      fadd_s(dst, src1, src2);\n+      break;\n+    case FLOAT_TYPE::double_precision:\n+      fadd_d(dst, src1, src2);\n+      break;\n+    default:\n+      ShouldNotReachHere();\n+  }\n@@ -2155,3 +2180,14 @@\n-  if (is_double) {\n-    is_min ? fmin_d(dst, src1, src2)\n-           : fmax_d(dst, src1, src2);\n+  if (is_min) {\n+    switch (ft) {\n+      case FLOAT_TYPE::half_precision:\n+        fmin_h(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::single_precision:\n+        fmin_s(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::double_precision:\n+        fmin_d(dst, src1, src2);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -2159,2 +2195,13 @@\n-    is_min ? fmin_s(dst, src1, src2)\n-           : fmax_s(dst, src1, src2);\n+    switch (ft) {\n+      case FLOAT_TYPE::half_precision:\n+        fmax_h(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::single_precision:\n+        fmax_s(dst, src1, src2);\n+        break;\n+      case FLOAT_TYPE::double_precision:\n+        fmax_d(dst, src1, src2);\n+        break;\n+      default:\n+        ShouldNotReachHere();\n+    }\n@@ -2253,1 +2300,1 @@\n-static void float16_to_float_slow_path(C2_MacroAssembler& masm, C2GeneralStub<FloatRegister, Register, Register>& stub) {\n+static void float16_to_float_slow_path_c2(C2_MacroAssembler& masm, C2GeneralStub<FloatRegister, Register, Register>& stub) {\n@@ -2276,2 +2323,2 @@\n-void C2_MacroAssembler::float16_to_float(FloatRegister dst, Register src, Register tmp) {\n-  auto stub = C2CodeStub::make<FloatRegister, Register, Register>(dst, src, tmp, 20, float16_to_float_slow_path);\n+void C2_MacroAssembler::float16_to_float_c2(FloatRegister dst, Register src, Register tmp) {\n+  auto stub = C2CodeStub::make<FloatRegister, Register, Register>(dst, src, tmp, 20, float16_to_float_slow_path_c2);\n@@ -2299,1 +2346,1 @@\n-static void float_to_float16_slow_path(C2_MacroAssembler& masm, C2GeneralStub<Register, FloatRegister, Register>& stub) {\n+static void float_to_float16_slow_path_c2(C2_MacroAssembler& masm, C2GeneralStub<Register, FloatRegister, Register>& stub) {\n@@ -2324,2 +2371,2 @@\n-void C2_MacroAssembler::float_to_float16(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp) {\n-  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path);\n+void C2_MacroAssembler::float_to_float16_c2(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp) {\n+  auto stub = C2CodeStub::make<Register, FloatRegister, Register>(dst, src, xtmp, 130, float_to_float16_slow_path_c2);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":67,"deletions":20,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-                 bool is_double, bool is_min);\n+                 FLOAT_TYPE ft, bool is_min);\n@@ -175,2 +175,2 @@\n-  void float16_to_float(FloatRegister dst, Register src, Register tmp);\n-  void float_to_float16(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp);\n+  void float16_to_float_c2(FloatRegister dst, Register src, Register tmp);\n+  void float_to_float16_c2(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -6372,0 +6372,71 @@\n+\/\/ j.l.Float.float16ToFloat\n+void MacroAssembler::float16_to_float(FloatRegister dst, Register src, Register tmp) {\n+  Label NaN_SLOW, DONE;\n+\n+  \/\/ On riscv, NaN needs a special process as fcvt does not work in that case.\n+  \/\/ On riscv, Inf does not need a special process as fcvt can handle it correctly.\n+  \/\/ but we consider to get the slow path to process NaN and Inf at the same time,\n+  \/\/ as both of them are rare cases, and if we try to get the slow path to handle\n+  \/\/ only NaN case it would sacrifise the performance for normal cases,\n+  \/\/ i.e. non-NaN and non-Inf cases.\n+\n+  \/\/ check whether it's a NaN or +\/- Inf.\n+  mv(t0, 0x7c00);\n+  andr(tmp, src, t0);\n+  \/\/ jump to stub processing NaN and Inf cases.\n+  beq(t0, tmp, NaN_SLOW);\n+\n+  \/\/ non-NaN or non-Inf cases, just use built-in instructions.\n+  fmv_h_x(dst, src);\n+  fcvt_s_h(dst, dst);\n+  j(DONE);\n+\n+  bind(NaN_SLOW);\n+  \/\/ following instructions mainly focus on NaN, as riscv does not handle\n+  \/\/ NaN well with fcvt, but the code also works for Inf at the same time.\n+\n+  \/\/ construct a NaN in 32 bits from the NaN in 16 bits,\n+  \/\/ we need the payloads of non-canonical NaNs to be preserved.\n+  mv(tmp, 0x7f800000);\n+  \/\/ sign-bit was already set via sign-extension if necessary.\n+  slli(t0, src, 13);\n+  orr(tmp, t0, tmp);\n+  fmv_w_x(dst, tmp);\n+\n+  bind(DONE);\n+}\n+\n+\/\/ j.l.Float.floatToFloat16\n+void MacroAssembler::float_to_float16(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp) {\n+  Label NaN_SLOW, DONE;\n+\n+  \/\/ On riscv, NaN needs a special process as fcvt does not work in that case.\n+\n+  \/\/ check whether it's a NaN.\n+  \/\/ replace fclass with feq as performance optimization.\n+  feq_s(t0, src, src);\n+  \/\/ jump to stub processing NaN cases.\n+  beqz(t0, NaN_SLOW);\n+\n+  \/\/ non-NaN cases, just use built-in instructions.\n+  fcvt_h_s(ftmp, src);\n+  fmv_x_h(dst, ftmp);\n+  j(DONE);\n+\n+  bind(NaN_SLOW);\n+  fmv_x_w(dst, src);\n+\n+  \/\/ preserve the payloads of non-canonical NaNs.\n+  srai(dst, dst, 13);\n+  \/\/ preserve the sign bit.\n+  srai(xtmp, dst, 13);\n+  slli(xtmp, xtmp, 10);\n+  mv(t0, 0x3ff);\n+  orr(xtmp, xtmp, t0);\n+\n+  \/\/ get the result by merging sign bit and payloads of preserved non-canonical NaNs.\n+  andr(dst, dst, xtmp);\n+\n+  bind(DONE);\n+}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -628,0 +628,3 @@\n+  void float16_to_float(FloatRegister dst, Register src, Register tmp);\n+  void float_to_float16(Register dst, FloatRegister src, FloatRegister ftmp, Register xtmp);\n+\n@@ -1083,0 +1086,1 @@\n+  INSN(flh);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1921,0 +1921,2 @@\n+    case Op_ReinterpretS2HF:\n+    case Op_ReinterpretHF2S:\n@@ -1922,0 +1924,9 @@\n+    case Op_AddHF:\n+    case Op_DivHF:\n+    case Op_FmaHF:\n+    case Op_MaxHF:\n+    case Op_MinHF:\n+    case Op_MulHF:\n+    case Op_SubHF:\n+    case Op_SqrtHF:\n+      return UseZfh;\n@@ -3060,0 +3071,21 @@\n+\/\/ Half Float Immediate\n+operand immH()\n+%{\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n+\/\/ Half Float Immediate: +0.0f.\n+operand immH0()\n+%{\n+  predicate(jint_cast(n->geth()) == 0);\n+  match(ConH);\n+\n+  op_cost(0);\n+  format %{ %}\n+  interface(CONST_INTER);\n+%}\n+\n@@ -4913,0 +4945,33 @@\n+\/\/ Load Half Float Constant\n+instruct loadConH(fRegF dst, immH con) %{\n+  match(Set dst con);\n+\n+  ins_cost(LOAD_COST);\n+  format %{\n+    \"flh $dst, [$constantaddress]\\t# load from constant table: float=$con, #@loadConH\"\n+  %}\n+\n+  ins_encode %{\n+    assert(UseZfh || UseZfhmin, \"must\");\n+    __ flh(as_FloatRegister($dst$$reg), $constantaddress($con));\n+    \/\/ TODO: add zfa instructions for half float, and optimize here.\n+  %}\n+\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n+instruct loadConH0(fRegF dst, immH0 con) %{\n+  match(Set dst con);\n+\n+  ins_cost(XFER_COST);\n+\n+  format %{ \"fmv.h.x $dst, zr\\t# float, #@loadConH0\" %}\n+\n+  ins_encode %{\n+    assert(UseZfh || UseZfhmin, \"must\");\n+    __ fmv_h_x(as_FloatRegister($dst$$reg), zr);\n+  %}\n+\n+  ins_pipe(fp_load_constant_s);\n+%}\n+\n@@ -7297,1 +7362,1 @@\n-                 false \/* is_double *\/, false \/* is_min *\/);\n+                 __ FLOAT_TYPE::single_precision, false \/* is_min *\/);\n@@ -7313,1 +7378,1 @@\n-                 false \/* is_double *\/, true \/* is_min *\/);\n+                 __ FLOAT_TYPE::single_precision, true \/* is_min *\/);\n@@ -7329,1 +7394,1 @@\n-                 true \/* is_double *\/, false \/* is_min *\/);\n+                 __ FLOAT_TYPE::double_precision, false \/* is_min *\/);\n@@ -7345,1 +7410,1 @@\n-                 true \/* is_double *\/, true \/* is_min *\/);\n+                 __ FLOAT_TYPE::double_precision, true \/* is_min *\/);\n@@ -8015,0 +8080,11 @@\n+instruct castHH(fRegF dst)\n+%{\n+  match(Set dst (CastHH dst));\n+\n+  size(0);\n+  format %{ \"# castHH of $dst\" %}\n+  ins_encode(\/* empty encoding *\/);\n+  ins_cost(0);\n+  ins_pipe(pipe_class_empty);\n+%}\n+\n@@ -8160,1 +8236,1 @@\n-    __ float16_to_float($dst$$FloatRegister, $src$$Register, $tmp$$Register);\n+    __ float16_to_float_c2($dst$$FloatRegister, $src$$Register, $tmp$$Register);\n@@ -8172,1 +8248,1 @@\n-    __ float_to_float16($dst$$Register, $src$$FloatRegister, $ftmp$$FloatRegister, $xtmp$$Register);\n+    __ float_to_float16_c2($dst$$Register, $src$$FloatRegister, $ftmp$$FloatRegister, $xtmp$$Register);\n@@ -8177,0 +8253,110 @@\n+\/\/ half precision operations\n+\n+instruct reinterpretS2HF(fRegF dst, iRegINoSp src)\n+%{\n+  match(Set dst (ReinterpretS2HF src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fmv.h.x $dst, $src\" %}\n+  ins_encode %{\n+    __ fmv_h_x($dst$$FloatRegister, $src$$Register);\n+  %}\n+  ins_pipe(fp_i2f);\n+%}\n+\n+instruct convF2HFAndS2HF(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (ReinterpretS2HF (ConvF2HF src)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"convF2HFAndS2HF $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvt_h_s($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct reinterpretHF2S(iRegINoSp dst, fRegF src)\n+%{\n+  match(Set dst (ReinterpretHF2S src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fmv.x.h $dst, $src\" %}\n+  ins_encode %{\n+    __ fmv_x_h($dst$$Register, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_f2i);\n+%}\n+\n+instruct convHF2SAndHF2F(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (ConvHF2F (ReinterpretHF2S src)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"convHF2SAndHF2F $dst, $src\" %}\n+  ins_encode %{\n+    __ fcvt_s_h($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_uop_s);\n+%}\n+\n+instruct sqrt_HF_reg(fRegF dst, fRegF src)\n+%{\n+  match(Set dst (SqrtHF src));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fsqrt.h $dst, $src\" %}\n+  ins_encode %{\n+    __ fsqrt_h($dst$$FloatRegister, $src$$FloatRegister);\n+  %}\n+  ins_pipe(fp_sqrt_s);\n+%}\n+\n+instruct binOps_HF_reg(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  match(Set dst (AddHF src1 src2));\n+  match(Set dst (SubHF src1 src2));\n+  match(Set dst (MulHF src1 src2));\n+  match(Set dst (DivHF src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"binop_hf $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    switch(opcode) {\n+      case Op_AddHF: __ fadd_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_SubHF: __ fsub_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_MulHF: __ fmul_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      case Op_DivHF: __ fdiv_h($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister); break;\n+      default: assert(false, \"%s is not supported here\", NodeClassNames[opcode]); break;\n+    }\n+  %}\n+  ins_pipe(fp_dop_reg_reg_s);\n+%}\n+\n+instruct min_max_HF_reg(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  match(Set dst (MinHF src1 src2));\n+  match(Set dst (MaxHF src1 src2));\n+  effect(TEMP_DEF dst);\n+  format %{ \"min_max_hf $dst, $src1, $src2\" %}\n+  ins_encode %{\n+    int opcode = this->ideal_Opcode();\n+    switch(opcode) {\n+      case Op_MinHF: __ minmax_fp($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                                  __ FLOAT_TYPE::half_precision, true);\n+                     break;\n+      case Op_MaxHF: __ minmax_fp($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,\n+                                  __ FLOAT_TYPE::half_precision, false);\n+                     break;\n+      default: assert(false, \"%s is not supported here\", NodeClassNames[opcode]); break;\n+    }\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n+instruct fma_HF_reg(fRegF dst, fRegF src1, fRegF src2)\n+%{\n+  match(Set dst (FmaHF src2 (Binary dst src1)));\n+  effect(TEMP_DEF dst);\n+  format %{ \"fmadd.h $dst, $src1, $src2\\t# $dst = $dst * $src1 + $src2 fma packedH\" %}\n+  ins_encode %{\n+    __ fmadd_h($dst$$FloatRegister, $dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);\n+  %}\n+  ins_pipe(pipe_class_default);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":192,"deletions":6,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -6163,0 +6163,29 @@\n+  \/\/ x10 = input (float16)\n+  \/\/ f10 = result (float)\n+  \/\/ t1  = temporary register\n+  address generate_float16ToFloat() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::hf2f_id;\n+    StubCodeMark mark(this, stub_id);\n+    address entry = __ pc();\n+    BLOCK_COMMENT(\"float16ToFloat:\");\n+    __ float16_to_float(f10, x10, t1);\n+    __ ret();\n+    return entry;\n+  }\n+\n+  \/\/ f10 = input (float)\n+  \/\/ x10 = result (float16)\n+  \/\/ f11 = temporary float register\n+  \/\/ t1  = temporary register\n+  address generate_floatToFloat16() {\n+    __ align(CodeEntryAlignment);\n+    StubGenStubId stub_id = StubGenStubId::f2hf_id;\n+    StubCodeMark mark(this, stub_id);\n+    address entry = __ pc();\n+    BLOCK_COMMENT(\"floatToFloat16:\");\n+    __ float_to_float16(x10, f10, f11, t1);\n+    __ ret();\n+    return entry;\n+  }\n+\n@@ -6532,0 +6561,6 @@\n+\n+    if (vmIntrinsics::is_intrinsic_available(vmIntrinsics::_float16ToFloat) &&\n+        vmIntrinsics::is_intrinsic_available(vmIntrinsics::_floatToFloat16)) {\n+      StubRoutines::_hf2f = generate_float16ToFloat();\n+      StubRoutines::_f2hf = generate_floatToFloat16();\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConvF2HFIdealizationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"},\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"},\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/MulHFNodeIdealizationTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -104,1 +104,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -117,1 +117,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -128,1 +128,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -140,1 +140,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -151,1 +151,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -162,1 +162,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -173,1 +173,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -184,1 +184,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -195,1 +195,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -206,1 +206,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -217,1 +217,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -229,1 +229,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -246,1 +246,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -283,1 +283,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -326,1 +326,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -359,1 +359,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -377,1 +377,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -394,1 +394,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -434,1 +434,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -457,1 +457,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -476,1 +476,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -511,1 +511,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n@@ -550,1 +550,1 @@\n-        applyIfCPUFeature = {\"avx512_fp16\", \"true\"})\n+        applyIfCPUFeatureOr = {\"avx512_fp16\", \"true\", \"zfh\", \"true\"})\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestFloat16ScalarOperations.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -113,0 +113,1 @@\n+        \"zfh\",\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}