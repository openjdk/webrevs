{"files":[{"patch":"@@ -1887,1 +1887,1 @@\n-  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle, true \/* no_vm_op *\/);\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1940,18 +1940,0 @@\n-\/\/ VM operation to support JvmtiHandshake for unmounted virtual threads.\n-\/\/ Used by the JvmtiHandshake class only.\n-class VM_HandshakeUnmountedVirtualThread : public VM_Operation {\n-private:\n-  JvmtiUnitedHandshakeClosure* _hs_cl;\n-  Handle _target_h;\n-\n-public:\n-  VM_HandshakeUnmountedVirtualThread(JvmtiUnitedHandshakeClosure* hs_cl, Handle target_h)\n-    : VM_Operation(),\n-      _hs_cl(hs_cl),\n-      _target_h(target_h) {}\n-  VMOp_Type type() const { return VMOp_HandshakeUnmountedVirtualThread; }\n-  void doit() {\n-    _hs_cl->do_vthread(_target_h);\n-  }\n-};\n-\n@@ -1959,2 +1941,0 @@\n-\/\/ A VM_op is useed in a case if a JVMTI function implementation needs to walk\n-\/\/ the stack of an unmounted virtual thread.\n@@ -1963,1 +1943,1 @@\n-JvmtiHandshake::execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target, bool no_vm_op) {\n+JvmtiHandshake::execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target) {\n@@ -1978,1 +1958,1 @@\n-  execute(hs_cl, &tlh, java_thread, target_h, no_vm_op);\n+  execute(hs_cl, &tlh, java_thread, target_h);\n@@ -1982,2 +1962,0 @@\n-\/\/ A VM_op is useed in a case if a JVMTI function implementation needs to walk\n-\/\/ the stack of an unmounted virtual thread.\n@@ -1989,1 +1967,1 @@\n-                        JavaThread* target_jt, Handle target_h, bool no_vm_op) {\n+                        JavaThread* target_jt, Handle target_h) {\n@@ -1992,2 +1970,2 @@\n-  \/\/ needed when suspend is required for non-current target thread\n-  hs_cl->set_self(self);\n+  hs_cl->set_self(self);           \/\/ needed when suspend is required for non-current target thread\n+  hs_cl->set_target_h(target_h);   \/\/ need this to differentiate between virtual and carrier thread\n@@ -2000,6 +1978,1 @@\n-      if (no_vm_op) {\n-        hs_cl->do_vthread(target_h); \/\/ execute handshake closure callback on current thread directly\n-      } else {\n-        VM_HandshakeUnmountedVirtualThread op(hs_cl, target_h);\n-        VMThread::execute(&op);      \/\/ process it with a VM_op on VMThread\n-      }\n+      hs_cl->do_vthread(target_h); \/\/ execute handshake closure callback on current thread directly\n@@ -2009,1 +1982,0 @@\n-    hs_cl->set_target_h(target_h); \/\/ need this to differentiate between virtual and carrier thread\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":6,"deletions":34,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -494,2 +494,2 @@\n-                      JavaThread* target_jt, Handle target_h, bool no_vm_op = false);\n-  static void execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target, bool no_vm_op = false);\n+                      JavaThread* target_jt, Handle target_h);\n+  static void execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -81,1 +81,0 @@\n-  template(HandshakeUnmountedVirtualThread)       \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"}]}