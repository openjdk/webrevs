{"files":[{"patch":"@@ -1714,41 +1714,3 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  HandleMark hm(current_thread);\n-\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n-  ThreadsListHandle tlh(current_thread);\n-\n-  JavaThread* java_thread = nullptr;\n-  oop thread_obj = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n-\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n-      ResourceMark rm(current_thread);\n-\n-      VM_VirtualThreadGetStackTrace op(this, Handle(current_thread, thread_obj),\n-                                       start_depth, max_frame_count,\n-                                       frame_buffer, count_ptr);\n-      VMThread::execute(&op);\n-      return op.result();\n-    }\n-    VirtualThreadGetStackTraceClosure op(this, Handle(current_thread, thread_obj),\n-                                         start_depth, max_frame_count, frame_buffer, count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    return op.result();\n-  }\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a direct handshake for safety.\n-  if (java_thread == JavaThread::current()) {\n-    err = get_stack_trace(java_thread, start_depth, max_frame_count, frame_buffer, count_ptr);\n-  } else {\n-    \/\/ Get stack trace with handshake.\n-    GetStackTraceClosure op(this, start_depth, max_frame_count, frame_buffer, count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    err = op.result();\n-  }\n-\n-  return err;\n+  GetStackTraceClosure op(this, start_depth, max_frame_count, frame_buffer, count_ptr);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n@@ -1832,35 +1794,3 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  HandleMark hm(current_thread);\n-\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n-  ThreadsListHandle tlh(current_thread);\n-\n-  JavaThread* java_thread = nullptr;\n-  oop thread_obj = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n-\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n-      VM_VirtualThreadGetFrameCount op(this, Handle(current_thread, thread_obj),  count_ptr);\n-      VMThread::execute(&op);\n-      return op.result();\n-    }\n-    VirtualThreadGetFrameCountClosure op(this, Handle(current_thread, thread_obj), count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    return op.result();\n-  }\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a direct handshake for safety.\n-  if (java_thread == JavaThread::current()) {\n-    err = get_frame_count(java_thread, count_ptr);\n-  } else {\n-    \/\/ get java stack frame count with handshake.\n-    GetFrameCountClosure op(this, count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    err = op.result();\n-  }\n-  return err;\n+  GetFrameCountClosure op(this, count_ptr);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n@@ -1926,35 +1856,3 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  HandleMark hm(current_thread);\n-\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n-  ThreadsListHandle tlh(current_thread);\n-\n-  JavaThread* java_thread = nullptr;\n-  oop thread_obj = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n-\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n-      err = get_frame_location(thread_obj, depth, method_ptr, location_ptr);\n-      return err;\n-    }\n-    VirtualThreadGetFrameLocationClosure op(this, Handle(current_thread, thread_obj),\n-                                            depth, method_ptr, location_ptr);\n-    Handshake::execute(&op, java_thread);\n-    return op.result();\n-  }\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a direct handshake for safety.\n-  if (java_thread == JavaThread::current()) {\n-    err = get_frame_location(java_thread, depth, method_ptr, location_ptr);\n-  } else {\n-    \/\/ JVMTI get java stack frame location via direct handshake.\n-    GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);\n-    Handshake::execute(&op, java_thread);\n-    err = op.result();\n-  }\n-  return err;\n+  GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n@@ -1987,12 +1885,0 @@\n-  if (java_lang_VirtualThread::is_instance(thread_handle())) {\n-    VirtualThreadSetFramePopClosure op(this, thread_handle, state, depth);\n-    MutexLocker mu(current, JvmtiThreadState_lock);\n-    if (java_thread == nullptr || java_thread == current) {\n-      \/\/ Target virtual thread is unmounted or current.\n-      op.doit(java_thread, true \/* self *\/);\n-    } else {\n-      Handshake::execute(&op, java_thread);\n-    }\n-    return op.result();\n-  }\n-\n@@ -2001,5 +1887,1 @@\n-  if (java_thread == current) {\n-    op.doit(java_thread, true \/* self *\/);\n-  } else {\n-    Handshake::execute(&op, java_thread);\n-  }\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":10,"deletions":128,"binary":false,"changes":138,"status":"modified"},{"patch":"@@ -627,1 +627,4 @@\n-  return java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW &&\n+  oop cont = java_lang_VirtualThread::continuation(vt);\n+\n+  return !jdk_internal_vm_Continuation::done(cont) &&\n+         java_lang_VirtualThread::state(vt) != java_lang_VirtualThread::NEW &&\n@@ -1245,3 +1248,0 @@\n-  if (!JvmtiEnvBase::is_vthread_alive(vthread_oop)) {\n-    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-  }\n@@ -1302,3 +1302,0 @@\n-  if (!JvmtiEnvBase::is_vthread_alive(vthread_oop)) {\n-    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-  }\n@@ -1946,0 +1943,49 @@\n+\/\/ Supports platform and virtual threads.\n+\/\/ JvmtiVTMSTransitionDisabler is always set by this function.\n+void\n+JvmtiHandshake::execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target) {\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n+\n+  JvmtiVTMSTransitionDisabler disabler(target);\n+  ThreadsListHandle tlh(current);\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n+\n+  jvmtiError err = JvmtiEnvBase::get_threadOop_and_JavaThread(tlh.list(), target, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    hs_cl->set_result(err);\n+    return;\n+  }\n+  Handle target_h(current, thread_obj);\n+  execute(hs_cl, &tlh, java_thread, target_h);\n+}\n+\n+\/\/ Supports platform and virtual threads.\n+\/\/ A virtual thread is always identified by the target_h oop handle.\n+\/\/ The target_jt is always nullptr for an unmounted virtual thread.\n+\/\/ JvmtiVTMSTransitionDisabler has to be set before call to this function.\n+void\n+JvmtiHandshake::execute(JvmtiUnitedHandshakeClosure* hs_cl, ThreadsListHandle* tlh,\n+                        JavaThread* target_jt, Handle target_h) {\n+  bool self = target_jt == JavaThread::current();\n+\n+  hs_cl->set_self(self);           \/\/ needed when suspend is required for non-current target thread\n+  hs_cl->set_target_h(target_h);   \/\/ need this to differentiate between virtual and carrier thread\n+\n+  if (java_lang_VirtualThread::is_instance(target_h())) { \/\/ virtual thread\n+    if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+      return;\n+    }\n+    if (target_jt == nullptr) {    \/\/ unmounted virtual thread\n+      hs_cl->do_vthread(target_h); \/\/ execute handshake closure callback on current thread directly\n+    }\n+  }\n+  if (target_jt != nullptr) {      \/\/ mounted virtual or platform thread\n+    if (self) {                    \/\/ target thread is current\n+      hs_cl->do_thread(target_jt); \/\/ execute handshake closure callback on current thread directly\n+    } else {\n+      Handshake::execute(hs_cl, tlh, target_jt); \/\/ delegate to Handshake implementation\n+    }\n+  }\n+}\n@@ -2337,2 +2383,2 @@\n-SetFramePopClosure::doit(Thread *target, bool self) {\n-  ResourceMark rm;\n+SetFramePopClosure::do_thread(Thread *target) {\n+  Thread* current = Thread::current();\n@@ -2341,0 +2387,4 @@\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n+    return;\n+  }\n@@ -2342,1 +2392,1 @@\n-    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n@@ -2344,1 +2394,0 @@\n-  assert(_state->get_thread_or_saved() == java_thread, \"Must be\");\n@@ -2346,1 +2395,1 @@\n-  if (!self && !java_thread->is_suspended()) {\n+  if (!_self && !java_thread->is_suspended()) {\n@@ -2354,0 +2403,2 @@\n+  assert(_state->get_thread_or_saved() == java_thread, \"Must be\");\n+\n@@ -2362,0 +2413,13 @@\n+void\n+SetFramePopClosure::do_vthread(Handle target_h) {\n+  if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  if (!_self && !JvmtiVTSuspender::is_vthread_suspended(_target_h())) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return;\n+  }\n+  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_target_h());\n+  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n+}\n+\n@@ -2384,3 +2448,3 @@\n-VM_VirtualThreadGetStackTrace::doit() {\n-  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+GetStackTraceClosure::do_thread(Thread *target) {\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n@@ -2389,7 +2453,2 @@\n-  ResourceMark rm;\n-  javaVFrame* jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-\n-  _result = ((JvmtiEnvBase *)_env)->get_stack_trace(jvf,\n-                                                    _start_depth, _max_count,\n-                                                    _frame_buffer, _count_ptr);\n-}\n+  Thread* current = Thread::current();\n+  ResourceMark rm(current);\n@@ -2397,2 +2456,0 @@\n-void\n-GetStackTraceClosure::do_thread(Thread *target) {\n@@ -2407,0 +2464,14 @@\n+void\n+GetStackTraceClosure::do_vthread(Handle target_h) {\n+  if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  Thread* current = Thread::current();\n+  ResourceMark rm(current);\n+\n+  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(target_h());\n+  _result = ((JvmtiEnvBase *)_env)->get_stack_trace(jvf,\n+                                                    _start_depth, _max_count,\n+                                                    _frame_buffer, _count_ptr);\n+}\n+\n@@ -2456,5 +2527,0 @@\n-void\n-VM_VirtualThreadGetFrameCount::doit() {\n-  _result = ((JvmtiEnvBase*)_env)->get_frame_count(_vthread_h(), _count_ptr);\n-}\n-\n@@ -2465,0 +2531,6 @@\n+\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n+    return;\n+  }\n+\n@@ -2470,0 +2542,8 @@\n+void\n+GetFrameCountClosure::do_vthread(Handle target_h) {\n+  if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  _result = ((JvmtiEnvBase*)_env)->get_frame_count(target_h(), _count_ptr);\n+}\n+\n@@ -2473,0 +2553,6 @@\n+  assert(target == jt, \"just checking\");\n+\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n+    return;\n+  }\n@@ -2479,0 +2565,9 @@\n+void\n+GetFrameLocationClosure::do_vthread(Handle target_h) {\n+  if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  _result = ((JvmtiEnvBase*)_env)->get_frame_location(target_h(), _depth,\n+                                                      _method_ptr, _location_ptr);\n+}\n+\n@@ -2508,30 +2603,0 @@\n-void\n-VirtualThreadGetStackTraceClosure::do_thread(Thread *target) {\n-  assert(target->is_Java_thread(), \"just checking\");\n-  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-    return;\n-  }\n-  Thread* cur_thread = Thread::current();\n-  ResourceMark rm(cur_thread);\n-  HandleMark hm(cur_thread);\n-\n-  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-  _result = ((JvmtiEnvBase *)_env)->get_stack_trace(jvf,\n-                                                    _start_depth, _max_count,\n-                                                    _frame_buffer, _count_ptr);\n-}\n-\n-void\n-VirtualThreadGetFrameCountClosure::do_thread(Thread *target) {\n-  assert(target->is_Java_thread(), \"just checking\");\n-  _result = ((JvmtiEnvBase*)_env)->get_frame_count(_vthread_h(), _count_ptr);\n-}\n-\n-void\n-VirtualThreadGetFrameLocationClosure::do_thread(Thread *target) {\n-  assert(target->is_Java_thread(), \"just checking\");\n-  _result = ((JvmtiEnvBase*)_env)->get_frame_location(_vthread_h(), _depth,\n-                                                      _method_ptr, _location_ptr);\n-}\n-\n@@ -2560,15 +2625,0 @@\n-\n-void\n-VirtualThreadSetFramePopClosure::doit(Thread *target, bool self) {\n-  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-    return;\n-  }\n-  if (!self && !JvmtiVTSuspender::is_vthread_suspended(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-    return;\n-  }\n-  ResourceMark rm;\n-  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n-}\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":124,"deletions":74,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -466,0 +466,30 @@\n+\/\/ Used in combination with the JvmtiHandshake class.\n+\/\/ It is intended to support both platform and virtual threads.\n+class JvmtiUnitedHandshakeClosure : public HandshakeClosure {\n+ protected:\n+  Handle _target_h;\n+  jvmtiError _result;\n+  bool _self;\n+ public:\n+  JvmtiUnitedHandshakeClosure(const char* name)\n+    : HandshakeClosure(name),\n+      _target_h(Handle()),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE),\n+      _self(false) {}\n+\n+  \/\/ used by JvmtiHandshake::execute\n+  void set_target_h(Handle target_h) { _target_h = target_h; }\n+  void set_result(jvmtiError err) { _result = err; }\n+  void set_self(bool val) { _self = val; }\n+  jvmtiError result() { return _result; }\n+  virtual void do_vthread(Handle target_h) = 0;\n+};\n+\n+\/\/ The JvmtiHandshake supports virtual threads.\n+class JvmtiHandshake : public Handshake {\n+ public:\n+  static void execute(JvmtiUnitedHandshakeClosure* hs_cl, ThreadsListHandle* tlh,\n+                      JavaThread* target_jt, Handle target_h);\n+  static void execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target);\n+};\n+\n@@ -499,1 +529,1 @@\n-class SetFramePopClosure : public JvmtiHandshakeClosure {\n+class SetFramePopClosure : public JvmtiUnitedHandshakeClosure {\n@@ -507,1 +537,1 @@\n-    : JvmtiHandshakeClosure(\"SetFramePopClosure\"),\n+    : JvmtiUnitedHandshakeClosure(\"SetFramePopClosure\"),\n@@ -511,4 +541,2 @@\n-  void do_thread(Thread *target) {\n-    doit(target, false \/* self *\/);\n-  }\n-  void doit(Thread *target, bool self);\n+  void do_thread(Thread *target);\n+  void do_vthread(Handle target_h);\n@@ -577,1 +605,1 @@\n-class GetStackTraceClosure : public JvmtiHandshakeClosure {\n+class GetStackTraceClosure : public JvmtiUnitedHandshakeClosure {\n@@ -588,1 +616,1 @@\n-    : JvmtiHandshakeClosure(\"GetStackTrace\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetStackTrace\"),\n@@ -595,0 +623,1 @@\n+  void do_vthread(Handle target_h);\n@@ -687,48 +716,0 @@\n-class VM_VirtualThreadGetStackTrace : public VM_Operation {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint _start_depth;\n-  jint _max_count;\n-  jvmtiFrameInfo* _frame_buffer;\n-  jint* _count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VM_VirtualThreadGetStackTrace(JvmtiEnv *env, Handle vthread_h,\n-                                jint start_depth, jint max_count,\n-                                jvmtiFrameInfo* frame_buffer, jint* count_ptr)\n-    : _env(env),\n-      _vthread_h(vthread_h),\n-      _start_depth(start_depth),\n-      _max_count(max_count),\n-      _frame_buffer(frame_buffer),\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE)\n-  {}\n-\n-  VMOp_Type type() const { return VMOp_VirtualThreadGetStackTrace; }\n-  void doit();\n-  jvmtiError result() { return _result; }\n-};\n-\n-class VM_VirtualThreadGetFrameCount : public VM_Operation {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint* _count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VM_VirtualThreadGetFrameCount(JvmtiEnv *env, Handle vthread_h, jint* count_ptr)\n-    : _env(env),\n-      _vthread_h(vthread_h),\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE)\n-  {}\n-\n-  VMOp_Type type() const { return VMOp_VirtualThreadGetFrameCount; }\n-  void doit();\n-  jvmtiError result() { return _result; }\n-};\n-\n@@ -756,1 +737,1 @@\n-class GetFrameCountClosure : public JvmtiHandshakeClosure {\n+class GetFrameCountClosure : public JvmtiUnitedHandshakeClosure {\n@@ -763,1 +744,1 @@\n-    : JvmtiHandshakeClosure(\"GetFrameCount\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetFrameCount\"),\n@@ -767,0 +748,1 @@\n+  void do_vthread(Handle target_h);\n@@ -770,1 +752,1 @@\n-class GetFrameLocationClosure : public JvmtiHandshakeClosure {\n+class GetFrameLocationClosure : public JvmtiUnitedHandshakeClosure {\n@@ -780,1 +762,1 @@\n-    : JvmtiHandshakeClosure(\"GetFrameLocation\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetFrameLocation\"),\n@@ -786,0 +768,1 @@\n+  void do_vthread(Handle target_h);\n@@ -828,71 +811,0 @@\n-\/\/ HandshakeClosure to get virtual thread stack trace at safepoint.\n-class VirtualThreadGetStackTraceClosure : public HandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint _start_depth;\n-  jint _max_count;\n-  jvmtiFrameInfo *_frame_buffer;\n-  jint *_count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetStackTraceClosure(JvmtiEnv *env, Handle vthread_h,\n-                                    jint start_depth, jint max_count,\n-                                    jvmtiFrameInfo* frame_buffer, jint* count_ptr)\n-    : HandshakeClosure(\"VirtualThreadGetStackTrace\"),\n-      _env(env),\n-      _vthread_h(vthread_h),\n-       _start_depth(start_depth),\n-      _max_count(max_count),\n-      _frame_buffer(frame_buffer),\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n-\/\/ HandshakeClosure to count virtual thread stack frames at safepoint.\n-class VirtualThreadGetFrameCountClosure : public HandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint *_count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetFrameCountClosure(JvmtiEnv *env, Handle vthread_h, jint *count_ptr)\n-    : HandshakeClosure(\"VirtualThreadGetFrameCount\"),\n-      _env(env), _vthread_h(vthread_h), _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n-\/\/ HandshakeClosure get to virtual thread frame location at safepoint.\n-class VirtualThreadGetFrameLocationClosure : public HandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint _depth;\n-  jmethodID* _method_ptr;\n-  jlocation* _location_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetFrameLocationClosure(JvmtiEnv *env, Handle vthread_h, jint depth,\n-                                       jmethodID* method_ptr, jlocation* location_ptr)\n-    : HandshakeClosure(\"VirtualThreadGetFrameLocation\"),\n-      _env(env),\n-      _vthread_h(vthread_h),\n-      _depth(depth),\n-      _method_ptr(method_ptr),\n-      _location_ptr(location_ptr),\n-      _result(JVMTI_ERROR_NONE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n@@ -917,22 +829,0 @@\n-\/\/ HandshakeClosure to set frame pop for a virtual thread.\n-class VirtualThreadSetFramePopClosure : public JvmtiHandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  JvmtiThreadState* _state;\n-  jint _depth;\n-\n-public:\n-  VirtualThreadSetFramePopClosure(JvmtiEnv *env, Handle vthread_h, JvmtiThreadState* state, jint depth)\n-    : JvmtiHandshakeClosure(\"VirtualThreadSetFramePopClosure\"),\n-      _env(env),\n-      _vthread_h(vthread_h),\n-      _state(state),\n-      _depth(depth) {}\n-\n-  void do_thread(Thread *target) {\n-    doit(target, false \/* self *\/);\n-  }\n-  void doit(Thread *target, bool self);\n-};\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":43,"deletions":153,"binary":false,"changes":196,"status":"modified"},{"patch":"@@ -84,2 +84,0 @@\n-  template(VirtualThreadGetStackTrace)            \\\n-  template(VirtualThreadGetFrameCount)            \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"}]}