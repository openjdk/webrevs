{"files":[{"patch":"@@ -1714,41 +1714,4 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  HandleMark hm(current_thread);\n-\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n-  ThreadsListHandle tlh(current_thread);\n-\n-  JavaThread* java_thread = nullptr;\n-  oop thread_obj = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n-\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n-      ResourceMark rm(current_thread);\n-\n-      VM_VirtualThreadGetStackTrace op(this, Handle(current_thread, thread_obj),\n-                                       start_depth, max_frame_count,\n-                                       frame_buffer, count_ptr);\n-      VMThread::execute(&op);\n-      return op.result();\n-    }\n-    VirtualThreadGetStackTraceClosure op(this, Handle(current_thread, thread_obj),\n-                                         start_depth, max_frame_count, frame_buffer, count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    return op.result();\n-  }\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a direct handshake for safety.\n-  if (java_thread == JavaThread::current()) {\n-    err = get_stack_trace(java_thread, start_depth, max_frame_count, frame_buffer, count_ptr);\n-  } else {\n-    \/\/ Get stack trace with handshake.\n-    GetStackTraceClosure op(this, start_depth, max_frame_count, frame_buffer, count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    err = op.result();\n-  }\n-\n-  return err;\n+  ResourceMark rm;\n+  GetStackTraceClosure op(this, start_depth, max_frame_count, frame_buffer, count_ptr);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n@@ -1832,35 +1795,3 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  HandleMark hm(current_thread);\n-\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n-  ThreadsListHandle tlh(current_thread);\n-\n-  JavaThread* java_thread = nullptr;\n-  oop thread_obj = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n-\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n-      VM_VirtualThreadGetFrameCount op(this, Handle(current_thread, thread_obj),  count_ptr);\n-      VMThread::execute(&op);\n-      return op.result();\n-    }\n-    VirtualThreadGetFrameCountClosure op(this, Handle(current_thread, thread_obj), count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    return op.result();\n-  }\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a direct handshake for safety.\n-  if (java_thread == JavaThread::current()) {\n-    err = get_frame_count(java_thread, count_ptr);\n-  } else {\n-    \/\/ get java stack frame count with handshake.\n-    GetFrameCountClosure op(this, count_ptr);\n-    Handshake::execute(&op, java_thread);\n-    err = op.result();\n-  }\n-  return err;\n+  GetFrameCountClosure op(this, count_ptr);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n@@ -1926,35 +1857,3 @@\n-  JavaThread* current_thread = JavaThread::current();\n-  HandleMark hm(current_thread);\n-\n-  JvmtiVTMSTransitionDisabler disabler(thread);\n-  ThreadsListHandle tlh(current_thread);\n-\n-  JavaThread* java_thread = nullptr;\n-  oop thread_obj = nullptr;\n-  jvmtiError err = get_threadOop_and_JavaThread(tlh.list(), thread, &java_thread, &thread_obj);\n-  if (err != JVMTI_ERROR_NONE) {\n-    return err;\n-  }\n-\n-  if (java_lang_VirtualThread::is_instance(thread_obj)) {\n-    if (java_thread == nullptr) {  \/\/ Target virtual thread is unmounted.\n-      err = get_frame_location(thread_obj, depth, method_ptr, location_ptr);\n-      return err;\n-    }\n-    VirtualThreadGetFrameLocationClosure op(this, Handle(current_thread, thread_obj),\n-                                            depth, method_ptr, location_ptr);\n-    Handshake::execute(&op, java_thread);\n-    return op.result();\n-  }\n-\n-  \/\/ It is only safe to perform the direct operation on the current\n-  \/\/ thread. All other usage needs to use a direct handshake for safety.\n-  if (java_thread == JavaThread::current()) {\n-    err = get_frame_location(java_thread, depth, method_ptr, location_ptr);\n-  } else {\n-    \/\/ JVMTI get java stack frame location via direct handshake.\n-    GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);\n-    Handshake::execute(&op, java_thread);\n-    err = op.result();\n-  }\n-  return err;\n+  GetFrameLocationClosure op(this, depth, method_ptr, location_ptr);\n+  JvmtiHandshake::execute(&op, thread);\n+  return op.result();\n@@ -1987,12 +1886,0 @@\n-  if (java_lang_VirtualThread::is_instance(thread_handle())) {\n-    VirtualThreadSetFramePopClosure op(this, thread_handle, state, depth);\n-    MutexLocker mu(current, JvmtiThreadState_lock);\n-    if (java_thread == nullptr || java_thread == current) {\n-      \/\/ Target virtual thread is unmounted or current.\n-      op.doit(java_thread, true \/* self *\/);\n-    } else {\n-      Handshake::execute(&op, java_thread);\n-    }\n-    return op.result();\n-  }\n-\n@@ -2001,5 +1888,1 @@\n-  if (java_thread == current) {\n-    op.doit(java_thread, true \/* self *\/);\n-  } else {\n-    Handshake::execute(&op, java_thread);\n-  }\n+  JvmtiHandshake::execute(&op, &tlh, java_thread, thread_handle, true \/* no_vm_op *\/);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":11,"deletions":128,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -1245,3 +1245,0 @@\n-  if (!JvmtiEnvBase::is_vthread_alive(vthread_oop)) {\n-    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-  }\n@@ -1302,3 +1299,0 @@\n-  if (!JvmtiEnvBase::is_vthread_alive(vthread_oop)) {\n-    return JVMTI_ERROR_THREAD_NOT_ALIVE;\n-  }\n@@ -1946,0 +1940,77 @@\n+\/\/ VM operation to support JvmtiHandshake for unmounted virtual threads.\n+\/\/ Used by the JvmtiHandshake class only.\n+class VM_HandshakeUnmountedVirtualThread : public VM_Operation {\n+private:\n+  JvmtiUnitedHandshakeClosure* _hs_cl;\n+  Handle _target_h;\n+\n+public:\n+  VM_HandshakeUnmountedVirtualThread(JvmtiUnitedHandshakeClosure* hs_cl, Handle target_h)\n+    : VM_Operation(),\n+      _hs_cl(hs_cl),\n+      _target_h(target_h) {}\n+  VMOp_Type type() const { return VMOp_HandshakeUnmountedVirtualThread; }\n+  void doit() {\n+    _hs_cl->do_vthread(_target_h);\n+  }\n+};\n+\n+\/\/ Supports platform and virtual threads.\n+\/\/ A VM_op is useed in a case if a JVMTI function implementation needs to walk\n+\/\/ the stack of an unmounted virtual thread.\n+\/\/ JvmtiVTMSTransitionDisabler is always set by this function.\n+void\n+JvmtiHandshake::execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target, bool no_vm_op) {\n+  JavaThread* current = JavaThread::current();\n+  HandleMark hm(current);\n+\n+  JvmtiVTMSTransitionDisabler disabler(target);\n+  ThreadsListHandle tlh(current);\n+  JavaThread* java_thread = nullptr;\n+  oop thread_obj = nullptr;\n+\n+  jvmtiError err = JvmtiEnvBase::get_threadOop_and_JavaThread(tlh.list(), target, &java_thread, &thread_obj);\n+  if (err != JVMTI_ERROR_NONE) {\n+    hs_cl->set_result(err);\n+    return;\n+  }\n+  Handle target_h(current, thread_obj);\n+  execute(hs_cl, &tlh, java_thread, target_h, no_vm_op);\n+}\n+\n+\/\/ Supports platform and virtual threads.\n+\/\/ A VM_op is useed in a case if a JVMTI function implementation needs to walk\n+\/\/ the stack of an unmounted virtual thread.\n+\/\/ A virtual thread is always identified by the target_h oop handle.\n+\/\/ The target_jt is always nullptr for an unmounted virtual thread.\n+\/\/ JvmtiVTMSTransitionDisabler has to be set before call to this function.\n+void\n+JvmtiHandshake::execute(JvmtiUnitedHandshakeClosure* hs_cl, ThreadsListHandle* tlh,\n+                        JavaThread* target_jt, Handle target_h, bool no_vm_op) {\n+  bool self = target_jt == JavaThread::current();\n+\n+  \/\/ needed when suspend is required for non-current target thread\n+  hs_cl->set_self(self);\n+\n+  if (java_lang_VirtualThread::is_instance(target_h())) { \/\/ virtual thread\n+    if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+      return;\n+    }\n+    if (target_jt == nullptr) {    \/\/ unmounted virtual  thread\n+      if (no_vm_op) {\n+        hs_cl->do_vthread(target_h); \/\/ execute handshake closure callback on current thread directly\n+      } else {\n+        VM_HandshakeUnmountedVirtualThread op(hs_cl, target_h);\n+        VMThread::execute(&op);      \/\/ process it with a VM_op on VMThread\n+      }\n+    }\n+  }\n+  if (target_jt != nullptr) {      \/\/ mounted virtual or platform thread\n+    hs_cl->set_target_h(target_h); \/\/ need this to differentiate between virtual and carrier thread\n+    if (self) {                    \/\/ target thread is current\n+      hs_cl->do_thread(target_jt); \/\/ execute handshake closure callback on current thread directly\n+    } else {\n+      Handshake::execute(hs_cl, tlh, target_jt); \/\/ delegate to Handshake implementation\n+    }\n+  }\n+}\n@@ -2337,2 +2408,2 @@\n-SetFramePopClosure::doit(Thread *target, bool self) {\n-  ResourceMark rm;\n+SetFramePopClosure::do_thread(Thread *target) {\n+  Thread* current = Thread::current();\n@@ -2341,0 +2412,4 @@\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n+    return;\n+  }\n@@ -2342,1 +2417,1 @@\n-    return; \/* JVMTI_ERROR_THREAD_NOT_ALIVE (default) *\/\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n@@ -2344,1 +2419,0 @@\n-  assert(_state->get_thread_or_saved() == java_thread, \"Must be\");\n@@ -2346,1 +2420,1 @@\n-  if (!self && !java_thread->is_suspended()) {\n+  if (!_self && !java_thread->is_suspended()) {\n@@ -2354,0 +2428,2 @@\n+  assert(_state->get_thread_or_saved() == java_thread, \"Must be\");\n+\n@@ -2362,0 +2438,15 @@\n+void\n+SetFramePopClosure::do_vthread(Handle target_h) {\n+  Thread* current = Thread::current();\n+\n+  if (!JvmtiEnvBase::is_vthread_alive(_target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  if (!_self && !JvmtiVTSuspender::is_vthread_suspended(_target_h())) {\n+    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n+    return;\n+  }\n+  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_target_h());\n+  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n+}\n+\n@@ -2384,3 +2475,3 @@\n-VM_VirtualThreadGetStackTrace::doit() {\n-  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n+GetStackTraceClosure::do_thread(Thread *target) {\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n@@ -2389,7 +2480,2 @@\n-  ResourceMark rm;\n-  javaVFrame* jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-\n-  _result = ((JvmtiEnvBase *)_env)->get_stack_trace(jvf,\n-                                                    _start_depth, _max_count,\n-                                                    _frame_buffer, _count_ptr);\n-}\n+  Thread* current = Thread::current();\n+  ResourceMark rm(current);\n@@ -2397,2 +2483,0 @@\n-void\n-GetStackTraceClosure::do_thread(Thread *target) {\n@@ -2407,0 +2491,14 @@\n+void\n+GetStackTraceClosure::do_vthread(Handle target_h) {\n+  if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  Thread* current = Thread::current();\n+  ResourceMark rm(current);\n+\n+  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(target_h());\n+  _result = ((JvmtiEnvBase *)_env)->get_stack_trace(jvf,\n+                                                    _start_depth, _max_count,\n+                                                    _frame_buffer, _count_ptr);\n+}\n+\n@@ -2456,5 +2554,0 @@\n-void\n-VM_VirtualThreadGetFrameCount::doit() {\n-  _result = ((JvmtiEnvBase*)_env)->get_frame_count(_vthread_h(), _count_ptr);\n-}\n-\n@@ -2465,0 +2558,6 @@\n+\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n+    return;\n+  }\n+\n@@ -2470,0 +2569,8 @@\n+void\n+GetFrameCountClosure::do_vthread(Handle target_h) {\n+  if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  _result = ((JvmtiEnvBase*)_env)->get_frame_count(target_h(), _count_ptr);\n+}\n+\n@@ -2473,0 +2580,6 @@\n+  assert(target == jt, \"just checking\");\n+\n+  if (java_lang_VirtualThread::is_instance(_target_h())) { \/\/ virtual thread\n+    do_vthread(_target_h);\n+    return;\n+  }\n@@ -2479,0 +2592,9 @@\n+void\n+GetFrameLocationClosure::do_vthread(Handle target_h) {\n+  if (!JvmtiEnvBase::is_vthread_alive(target_h())) {\n+    return; \/\/ JVMTI_ERROR_THREAD_NOT_ALIVE (default)\n+  }\n+  _result = ((JvmtiEnvBase*)_env)->get_frame_location(target_h(), _depth,\n+                                                      _method_ptr, _location_ptr);\n+}\n+\n@@ -2508,30 +2630,0 @@\n-void\n-VirtualThreadGetStackTraceClosure::do_thread(Thread *target) {\n-  assert(target->is_Java_thread(), \"just checking\");\n-  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-    return;\n-  }\n-  Thread* cur_thread = Thread::current();\n-  ResourceMark rm(cur_thread);\n-  HandleMark hm(cur_thread);\n-\n-  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-  _result = ((JvmtiEnvBase *)_env)->get_stack_trace(jvf,\n-                                                    _start_depth, _max_count,\n-                                                    _frame_buffer, _count_ptr);\n-}\n-\n-void\n-VirtualThreadGetFrameCountClosure::do_thread(Thread *target) {\n-  assert(target->is_Java_thread(), \"just checking\");\n-  _result = ((JvmtiEnvBase*)_env)->get_frame_count(_vthread_h(), _count_ptr);\n-}\n-\n-void\n-VirtualThreadGetFrameLocationClosure::do_thread(Thread *target) {\n-  assert(target->is_Java_thread(), \"just checking\");\n-  _result = ((JvmtiEnvBase*)_env)->get_frame_location(_vthread_h(), _depth,\n-                                                      _method_ptr, _location_ptr);\n-}\n-\n@@ -2560,15 +2652,0 @@\n-\n-void\n-VirtualThreadSetFramePopClosure::doit(Thread *target, bool self) {\n-  if (!JvmtiEnvBase::is_vthread_alive(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_ALIVE;\n-    return;\n-  }\n-  if (!self && !JvmtiVTSuspender::is_vthread_suspended(_vthread_h())) {\n-    _result = JVMTI_ERROR_THREAD_NOT_SUSPENDED;\n-    return;\n-  }\n-  ResourceMark rm;\n-  javaVFrame *jvf = JvmtiEnvBase::get_vthread_jvf(_vthread_h());\n-  _result = ((JvmtiEnvBase*)_env)->set_frame_pop(_state, jvf, _depth);\n-}\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":150,"deletions":73,"binary":false,"changes":223,"status":"modified"},{"patch":"@@ -466,0 +466,32 @@\n+\/\/ Used in combination with the JvmtiHandshake class.\n+\/\/ It is intended to support both platform and virtual threads.\n+class JvmtiUnitedHandshakeClosure : public HandshakeClosure {\n+ protected:\n+  Handle _target_h;\n+  jvmtiError _result;\n+  bool _self;\n+ public:\n+  JvmtiUnitedHandshakeClosure(const char* name)\n+    : HandshakeClosure(name),\n+      _target_h(Handle()),\n+      _result(JVMTI_ERROR_THREAD_NOT_ALIVE),\n+      _self(false) {}\n+\n+  void set_target_h(Handle target_h) { _target_h = target_h; }\n+  void set_result(jvmtiError err) { _result = err; }\n+  void set_self(bool val) { _self = val; }\n+  jvmtiError result() { return _result; }\n+  virtual void do_vthread(Handle target_h) = 0;\n+};\n+\n+\/\/ The JvmtiHandshake supports virtual threads.\n+class JvmtiHandshake : public Handshake {\n+ protected:\n+  static bool is_vthread_handshake_safe(JavaThread* thread, oop vt);\n+\n+ public:\n+  static void execute(JvmtiUnitedHandshakeClosure* hs_cl, ThreadsListHandle* tlh,\n+                      JavaThread* target_jt, Handle target_h, bool no_vm_op = false);\n+  static void execute(JvmtiUnitedHandshakeClosure* hs_cl, jthread target, bool no_vm_op = false);\n+};\n+\n@@ -499,1 +531,1 @@\n-class SetFramePopClosure : public JvmtiHandshakeClosure {\n+class SetFramePopClosure : public JvmtiUnitedHandshakeClosure {\n@@ -507,1 +539,1 @@\n-    : JvmtiHandshakeClosure(\"SetFramePopClosure\"),\n+    : JvmtiUnitedHandshakeClosure(\"SetFramePopClosure\"),\n@@ -511,4 +543,2 @@\n-  void do_thread(Thread *target) {\n-    doit(target, false \/* self *\/);\n-  }\n-  void doit(Thread *target, bool self);\n+  void do_thread(Thread *target);\n+  void do_vthread(Handle target_h);\n@@ -577,1 +607,1 @@\n-class GetStackTraceClosure : public JvmtiHandshakeClosure {\n+class GetStackTraceClosure : public JvmtiUnitedHandshakeClosure {\n@@ -588,1 +618,1 @@\n-    : JvmtiHandshakeClosure(\"GetStackTrace\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetStackTrace\"),\n@@ -595,0 +625,1 @@\n+  void do_vthread(Handle target_h);\n@@ -687,48 +718,0 @@\n-class VM_VirtualThreadGetStackTrace : public VM_Operation {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint _start_depth;\n-  jint _max_count;\n-  jvmtiFrameInfo* _frame_buffer;\n-  jint* _count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VM_VirtualThreadGetStackTrace(JvmtiEnv *env, Handle vthread_h,\n-                                jint start_depth, jint max_count,\n-                                jvmtiFrameInfo* frame_buffer, jint* count_ptr)\n-    : _env(env),\n-      _vthread_h(vthread_h),\n-      _start_depth(start_depth),\n-      _max_count(max_count),\n-      _frame_buffer(frame_buffer),\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE)\n-  {}\n-\n-  VMOp_Type type() const { return VMOp_VirtualThreadGetStackTrace; }\n-  void doit();\n-  jvmtiError result() { return _result; }\n-};\n-\n-class VM_VirtualThreadGetFrameCount : public VM_Operation {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint* _count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VM_VirtualThreadGetFrameCount(JvmtiEnv *env, Handle vthread_h, jint* count_ptr)\n-    : _env(env),\n-      _vthread_h(vthread_h),\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE)\n-  {}\n-\n-  VMOp_Type type() const { return VMOp_VirtualThreadGetFrameCount; }\n-  void doit();\n-  jvmtiError result() { return _result; }\n-};\n-\n@@ -756,1 +739,1 @@\n-class GetFrameCountClosure : public JvmtiHandshakeClosure {\n+class GetFrameCountClosure : public JvmtiUnitedHandshakeClosure {\n@@ -763,1 +746,1 @@\n-    : JvmtiHandshakeClosure(\"GetFrameCount\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetFrameCount\"),\n@@ -767,0 +750,1 @@\n+  void do_vthread(Handle target_h);\n@@ -770,1 +754,1 @@\n-class GetFrameLocationClosure : public JvmtiHandshakeClosure {\n+class GetFrameLocationClosure : public JvmtiUnitedHandshakeClosure {\n@@ -780,1 +764,1 @@\n-    : JvmtiHandshakeClosure(\"GetFrameLocation\"),\n+    : JvmtiUnitedHandshakeClosure(\"GetFrameLocation\"),\n@@ -786,0 +770,1 @@\n+  void do_vthread(Handle target_h);\n@@ -828,71 +813,0 @@\n-\/\/ HandshakeClosure to get virtual thread stack trace at safepoint.\n-class VirtualThreadGetStackTraceClosure : public HandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint _start_depth;\n-  jint _max_count;\n-  jvmtiFrameInfo *_frame_buffer;\n-  jint *_count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetStackTraceClosure(JvmtiEnv *env, Handle vthread_h,\n-                                    jint start_depth, jint max_count,\n-                                    jvmtiFrameInfo* frame_buffer, jint* count_ptr)\n-    : HandshakeClosure(\"VirtualThreadGetStackTrace\"),\n-      _env(env),\n-      _vthread_h(vthread_h),\n-       _start_depth(start_depth),\n-      _max_count(max_count),\n-      _frame_buffer(frame_buffer),\n-      _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n-\/\/ HandshakeClosure to count virtual thread stack frames at safepoint.\n-class VirtualThreadGetFrameCountClosure : public HandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint *_count_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetFrameCountClosure(JvmtiEnv *env, Handle vthread_h, jint *count_ptr)\n-    : HandshakeClosure(\"VirtualThreadGetFrameCount\"),\n-      _env(env), _vthread_h(vthread_h), _count_ptr(count_ptr),\n-      _result(JVMTI_ERROR_NONE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n-\/\/ HandshakeClosure get to virtual thread frame location at safepoint.\n-class VirtualThreadGetFrameLocationClosure : public HandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  jint _depth;\n-  jmethodID* _method_ptr;\n-  jlocation* _location_ptr;\n-  jvmtiError _result;\n-\n-public:\n-  VirtualThreadGetFrameLocationClosure(JvmtiEnv *env, Handle vthread_h, jint depth,\n-                                       jmethodID* method_ptr, jlocation* location_ptr)\n-    : HandshakeClosure(\"VirtualThreadGetFrameLocation\"),\n-      _env(env),\n-      _vthread_h(vthread_h),\n-      _depth(depth),\n-      _method_ptr(method_ptr),\n-      _location_ptr(location_ptr),\n-      _result(JVMTI_ERROR_NONE) {}\n-\n-  void do_thread(Thread *target);\n-  jvmtiError result() { return _result; }\n-};\n-\n@@ -917,22 +831,0 @@\n-\/\/ HandshakeClosure to set frame pop for a virtual thread.\n-class VirtualThreadSetFramePopClosure : public JvmtiHandshakeClosure {\n-private:\n-  JvmtiEnv *_env;\n-  Handle _vthread_h;\n-  JvmtiThreadState* _state;\n-  jint _depth;\n-\n-public:\n-  VirtualThreadSetFramePopClosure(JvmtiEnv *env, Handle vthread_h, JvmtiThreadState* state, jint depth)\n-    : JvmtiHandshakeClosure(\"VirtualThreadSetFramePopClosure\"),\n-      _env(env),\n-      _vthread_h(vthread_h),\n-      _state(state),\n-      _depth(depth) {}\n-\n-  void do_thread(Thread *target) {\n-    doit(target, false \/* self *\/);\n-  }\n-  void doit(Thread *target, bool self);\n-};\n-\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":45,"deletions":153,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -81,0 +81,1 @@\n+  template(HandshakeUnmountedVirtualThread)       \\\n@@ -84,2 +85,0 @@\n-  template(VirtualThreadGetStackTrace)            \\\n-  template(VirtualThreadGetFrameCount)            \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"}]}