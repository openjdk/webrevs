{"files":[{"patch":"@@ -263,2 +263,48 @@\n-                    String result = getFinalPath(input);\n-                    if (result == null) {\n+                    long handle = INVALID_HANDLE_VALUE;\n+                    boolean reparsePointOpened = false;\n+                    try {\n+                        \/\/ first try opening while following links\n+                        handle = input.openForReadAttributeAccess(true);\n+                    } catch (WindowsException x) {\n+                        try {\n+                            \/\/ fall back to opening the reparse point itself\n+                            handle = input.openForReadAttributeAccess(false);\n+                            CloseHandle(handle);\n+                            handle = INVALID_HANDLE_VALUE;\n+\n+                            \/\/ set flag to suppress the IOException below\n+                            reparsePointOpened = true;\n+                        } catch (WindowsException y) {\n+                            \/\/ suppress exception from opening reparse point\n+                            x.addSuppressed(y);\n+                        }\n+                        \/\/ fail if opening failed, following or not following\n+                        if (!reparsePointOpened)\n+                            x.rethrowAsIOException(input);\n+                    }\n+\n+                    \/\/ attempt to get the final path if the handle is valid\n+                    String result = null;\n+                    if (handle != INVALID_HANDLE_VALUE) {\n+                        try {\n+                            result = stripPrefix(GetFinalPathNameByHandle(handle));\n+                        } catch (WindowsException x) {\n+                            \/\/ ERROR_INVALID_LEVEL is the error returned when\n+                            \/\/ not supported (a symlink to file on FAT32 or\n+                            \/\/ Samba server for example)\n+                            if (x.lastError() != ERROR_INVALID_LEVEL)\n+                                x.rethrowAsIOException(input);\n+                        } finally {\n+                            CloseHandle(handle);\n+                        }\n+                    }\n+\n+                    \/\/ if the final path is null or is the UNC version of\n+                    \/\/ a drive path, then derive the final path by stepping\n+                    \/\/ through the elements of the path\n+                    if (result == null ||\n+                        (Character.isLetter(input.toString().charAt(0)) &&\n+                        result.charAt(0) == '\\\\' &&\n+                        input.toString().charAt(1) == ':' &&\n+                        result.charAt(1) == '\\\\' &&\n+                        input.toString().charAt(2) == '\\\\')) {\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/fs\/WindowsLinkSupport.java","additions":48,"deletions":2,"binary":false,"changes":50,"status":"modified"}]}