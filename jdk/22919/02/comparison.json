{"files":[{"patch":"@@ -92,0 +92,3 @@\n+    private static final int MULT_MIN = Integer.MIN_VALUE \/ 10;\n+    private static final int MULT_MIN_2 = Integer.MIN_VALUE \/ 100;\n+\n@@ -519,13 +522,4 @@\n-        \/*\n-         * WARNING: This method may be invoked early during VM initialization\n-         * before IntegerCache is initialized. Care must be taken to not use\n-         * the valueOf method.\n-         *\/\n-\n-        if (s == null) {\n-            throw new NumberFormatException(\"Cannot parse null string\");\n-        }\n-\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        int len;\n+        byte[] value;\n+        if (s == null || radix != 10 || (len = (value = s.value()).length) == 0 || !s.isLatin1()) {\n+            return parseInt0(s, radix);\n@@ -533,9 +527,11 @@\n-\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n-        }\n-\n-        int len = s.length();\n-        if (len == 0) {\n-            throw NumberFormatException.forInputString(\"\", radix);\n+        int result = 0, c = value[0], c1, digit;\n+        boolean inRange = true, isDigit = false;\n+        int neg = c - '-';\n+        if (neg != 0\n+                && neg + 2 != 0 \/\/ firstChar != '+'\n+        ) {\n+            if (isDigit(c)) {\n+                result = '0' - c;\n+            } else {\n+                inRange = false;\n+            }\n@@ -543,5 +539,9 @@\n-        int digit = ~0xFF;\n-        int i = 0;\n-        char firstChar = s.charAt(i++);\n-        if (firstChar != '-' && firstChar != '+') {\n-            digit = digit(firstChar, radix);\n+        int limit = MIN_VALUE + (neg != 0 ? 1 : 0);\n+        int i = 1;\n+        while (i + 1 < len && (isDigit = isDigit((c = value[i]))) && isDigit(c1 = value[i + 1])) {\n+            digit = c * 10 + c1 - 528; \/\/ 528 = 48 * 11 = '0' * 10 + '0'\n+            if (!(inRange = (result > MULT_MIN_2))) {\n+                break;\n+            }\n+            result = result * 100 - digit;\n+            i += 2;\n@@ -549,10 +549,9 @@\n-        if (digit >= 0 || digit == ~0xFF && len > 1) {\n-            int limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n-            int multmin = limit \/ radix;\n-            int result = -(digit & 0xFF);\n-            boolean inRange = true;\n-            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n-                    && (inRange = result > multmin\n-                        || result == multmin && digit <= radix * multmin - limit)) {\n-                result = radix * result - digit;\n+        if (inRange) {\n+            if (i + 1 == len) {\n+                isDigit = isDigit((c = value[i]));\n+            }\n+            if (i != len && isDigit) {\n+                digit = c - '0';\n+                inRange = result > MULT_MIN || (result == MULT_MIN && digit <= (MULT_MIN * 10 - limit));\n+                result = result * 10 - digit;\n+                i++;\n@@ -560,2 +559,2 @@\n-            if (inRange && i == len && digit >= 0) {\n-                return firstChar != '-' ? -result : result;\n+            if (inRange && i == len && result <= 0) {\n+                return neg != 0 ? -result : result;\n@@ -564,1 +563,16 @@\n-        throw NumberFormatException.forInputString(s, radix);\n+        throw NumberFormatException.forInputString(s);\n+    }\n+\n+    private static int parseInt0(String s, int radix) {\n+        if (s == null) {\n+            throw NumberFormatException.emptyInput();\n+        }\n+        int len;\n+        if ((len = s.length()) == 0) {\n+            throw NumberFormatException.forInputString(s);\n+        }\n+        return parseInt(s, 0, len, radix);\n+    }\n+\n+    static boolean isDigit(int ch) {\n+        return ch >= '0' && ch <= '9';\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":54,"deletions":40,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -92,0 +92,2 @@\n+    private static final long MULT_MIN_2 = -92233720368547758L;\n+\n@@ -555,7 +557,4 @@\n-        if (s == null) {\n-            throw new NumberFormatException(\"Cannot parse null string\");\n-        }\n-\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        int len;\n+        byte[] value;\n+        if (s == null || radix != 10 || (len = (value = s.value()).length) == 0 || !s.isLatin1()) {\n+            return parseLong0(s, radix);\n@@ -563,9 +562,12 @@\n-\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n-        }\n-\n-        int len = s.length();\n-        if (len == 0) {\n-            throw NumberFormatException.forInputString(\"\", radix);\n+        int c = value[0], c1, digit;\n+        long result = 0;\n+        boolean inRange = true, isDigit = false;\n+        int neg = c - '-';\n+        if (neg != 0\n+                && neg + 2 != 0 \/\/ firstChar != '+'\n+        ) {\n+            if (Integer.isDigit(c)) {\n+                result = '0' - c;\n+            } else {\n+                inRange = false;\n+            }\n@@ -573,5 +575,9 @@\n-        int digit = ~0xFF;\n-        int i = 0;\n-        char firstChar = s.charAt(i++);\n-        if (firstChar != '-' && firstChar != '+') {\n-            digit = digit(firstChar, radix);\n+        long limit = MIN_VALUE + (neg != 0 ? 1L : 0L);\n+        int i = 1;\n+        while (i + 1 < len && (isDigit = Integer.isDigit((c = value[i]))) && Integer.isDigit(c1 = value[i + 1])) {\n+            digit = c * 10 + c1 - 528; \/\/ 528 = 48 * 11 = '0' * 10 + '0'\n+            if (!(inRange = (result > MULT_MIN_2 || (result == MULT_MIN_2 && digit <= (MULT_MIN_2 * 100 - limit))))) {\n+                break;\n+            }\n+            result = result * 100 - digit;\n+            i += 2;\n@@ -579,10 +585,9 @@\n-        if (digit >= 0 || digit == ~0xFF && len > 1) {\n-            long limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n-            long multmin = limit \/ radix;\n-            long result = -(digit & 0xFF);\n-            boolean inRange = true;\n-            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n-                    && (inRange = result > multmin\n-                        || result == multmin && digit <= (int) (radix * multmin - limit))) {\n-                result = radix * result - digit;\n+        if (inRange) {\n+            if (i + 1 == len) {\n+                isDigit = Integer.isDigit((c = value[i]));\n+            }\n+            if (i != len && isDigit) {\n+                digit = c - '0';\n+                result = result * 10 - digit;\n+                i++;\n+                \/\/ max len is 20, No need to check inRange\n@@ -590,2 +595,2 @@\n-            if (inRange && i == len && digit >= 0) {\n-                return firstChar != '-' ? -result : result;\n+            if (i == len && result <= 0) {\n+                return neg != 0 ? -result : result;\n@@ -594,1 +599,12 @@\n-        throw NumberFormatException.forInputString(s, radix);\n+        throw NumberFormatException.forInputString(s);\n+    }\n+\n+    private static long parseLong0(String s, int radix) {\n+        if (s == null) {\n+            throw NumberFormatException.emptyInput();\n+        }\n+        int len;\n+        if ((len = s.length()) == 0) {\n+            throw NumberFormatException.forInputString(s);\n+        }\n+        return parseLong(s, 0, len, radix);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":51,"deletions":35,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -57,0 +57,10 @@\n+    \/**\n+     * Factory method for making a {@code NumberFormatException}\n+     * given the specified input which caused the error.\n+     *\n+     * @param   s   the input causing the error\n+     *\/\n+    static NumberFormatException forInputString(String s) {\n+        return forInputString(s, 10);\n+    }\n+\n@@ -85,0 +95,4 @@\n+\n+    static NumberFormatException emptyInput() {\n+        return new NumberFormatException(\"Cannot parse null string\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/NumberFormatException.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,7 @@\n+    @Benchmark\n+    public void parseLong(Blackhole bh) {\n+        for (String s : strings) {\n+            bh.consume(Long.parseLong(s));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}