{"files":[{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -519,8 +520,4 @@\n-        \/*\n-         * WARNING: This method may be invoked early during VM initialization\n-         * before IntegerCache is initialized. Care must be taken to not use\n-         * the valueOf method.\n-         *\/\n-\n-        if (s == null) {\n-            throw new NumberFormatException(\"Cannot parse null string\");\n+        int len;\n+        byte[] value;\n+        if (s == null || radix != 10 || (len = (value = s.value()).length) == 0 || !s.isLatin1()) {\n+            return parseInt0(s, radix);\n@@ -528,4 +525,14 @@\n-\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+        int fc = value[0];\n+        int result = Integer.isDigitLatin1(fc)\n+                ? '0' - fc\n+                : len != 1 && (fc == '-' || fc == '+')\n+                ? 0\n+                : 1;  \/\/ or any value > 0\n+        int i = 1;\n+        int d;\n+        while (i + 1 < len\n+                && (d = DecimalDigits.digit2(value, i)) != -1\n+                && MIN_VALUE \/ 100 <= result & result <= 0) {\n+            result = result * 100 - d;  \/\/ overflow from d => result > 0\n+            i += 2;\n@@ -533,4 +540,5 @@\n-\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        if (i < len\n+                && Integer.isDigitLatin1(d = value[i])\n+                && MIN_VALUE \/ 10 <= result & result <= 0) {\n+            result = result * 10 + '0' - d;  \/\/ overflow from '0' - d => result > 0\n+            i += 1;\n@@ -538,4 +546,4 @@\n-\n-        int len = s.length();\n-        if (len == 0) {\n-            throw NumberFormatException.forInputString(\"\", radix);\n+        if (i == len\n+                & result <= 0\n+                & (MIN_VALUE < result || fc == '-')) {\n+            return fc == '-' ? result : -result;\n@@ -543,5 +551,6 @@\n-        int digit = ~0xFF;\n-        int i = 0;\n-        char firstChar = s.charAt(i++);\n-        if (firstChar != '-' && firstChar != '+') {\n-            digit = digit(firstChar, radix);\n+        throw NumberFormatException.forInputString(s);\n+    }\n+\n+    private static int parseInt0(String s, int radix) {\n+        if (s == null) {\n+            throw NumberFormatException.nullInput();\n@@ -549,14 +558,3 @@\n-        if (digit >= 0 || digit == ~0xFF && len > 1) {\n-            int limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n-            int multmin = limit \/ radix;\n-            int result = -(digit & 0xFF);\n-            boolean inRange = true;\n-            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n-                    && (inRange = result > multmin\n-                        || result == multmin && digit <= radix * multmin - limit)) {\n-                result = radix * result - digit;\n-            }\n-            if (inRange && i == len && digit >= 0) {\n-                return firstChar != '-' ? -result : result;\n-            }\n+        int len;\n+        if ((len = s.length()) == 0) {\n+            throw NumberFormatException.forInputString(s);\n@@ -564,1 +562,5 @@\n-        throw NumberFormatException.forInputString(s, radix);\n+        return parseInt(s, 0, len, radix);\n+    }\n+\n+    static boolean isDigitLatin1(int ch) {\n+        return CharacterDataLatin1.instance.isDigit(ch);\n@@ -640,1 +642,1 @@\n-            endIndex, i - (digit < -1 ? 0 : 1));\n+            endIndex, i - (digit < -1 ? 0 : 1), radix);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Integer.java","additions":44,"deletions":42,"binary":false,"changes":86,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -555,2 +556,4 @@\n-        if (s == null) {\n-            throw new NumberFormatException(\"Cannot parse null string\");\n+        int len;\n+        byte[] value;\n+        if (s == null || radix != 10 || (len = (value = s.value()).length) == 0 || !s.isLatin1()) {\n+            return parseLong0(s, radix);\n@@ -558,4 +561,14 @@\n-\n-        if (radix < Character.MIN_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s less than Character.MIN_RADIX\", radix));\n+        \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n+        int fc = value[0];\n+        long result = Integer.isDigitLatin1(fc)\n+                ? '0' - fc\n+                : len != 1 && (fc == '-' || fc == '+')\n+                ? 0\n+                : 1;  \/\/ or any value > 0\n+        int i = 1;\n+        int d;\n+        while (i + 1 < len\n+                && (d = DecimalDigits.digit2(value, i)) != -1\n+                && MIN_VALUE \/ 100 <= result & result <= 0) {\n+            result = result * 100 - d;  \/\/ overflow from d => result > 0\n+            i += 2;\n@@ -563,4 +576,5 @@\n-\n-        if (radix > Character.MAX_RADIX) {\n-            throw new NumberFormatException(String.format(\n-                \"radix %s greater than Character.MAX_RADIX\", radix));\n+        if (i < len\n+                && Integer.isDigitLatin1(d = value[i])\n+                && MIN_VALUE \/ 10 <= result & result <= 0) {\n+            result = result * 10 + '0' - d;  \/\/ overflow from '0' - d => result > 0\n+            i += 1;\n@@ -568,4 +582,4 @@\n-\n-        int len = s.length();\n-        if (len == 0) {\n-            throw NumberFormatException.forInputString(\"\", radix);\n+        if (i == len\n+                & result <= 0\n+                & (MIN_VALUE < result || fc == '-')) {\n+            return fc == '-' ? result : -result;\n@@ -573,5 +587,6 @@\n-        int digit = ~0xFF;\n-        int i = 0;\n-        char firstChar = s.charAt(i++);\n-        if (firstChar != '-' && firstChar != '+') {\n-            digit = digit(firstChar, radix);\n+        throw NumberFormatException.forInputString(s);\n+    }\n+\n+    private static long parseLong0(String s, int radix) {\n+        if (s == null) {\n+            throw NumberFormatException.nullInput();\n@@ -579,14 +594,3 @@\n-        if (digit >= 0 || digit == ~0xFF && len > 1) {\n-            long limit = firstChar != '-' ? MIN_VALUE + 1 : MIN_VALUE;\n-            long multmin = limit \/ radix;\n-            long result = -(digit & 0xFF);\n-            boolean inRange = true;\n-            \/* Accumulating negatively avoids surprises near MAX_VALUE *\/\n-            while (i < len && (digit = digit(s.charAt(i++), radix)) >= 0\n-                    && (inRange = result > multmin\n-                        || result == multmin && digit <= (int) (radix * multmin - limit))) {\n-                result = radix * result - digit;\n-            }\n-            if (inRange && i == len && digit >= 0) {\n-                return firstChar != '-' ? -result : result;\n-            }\n+        int len;\n+        if ((len = s.length()) == 0) {\n+            throw NumberFormatException.forInputString(s);\n@@ -594,1 +598,1 @@\n-        throw NumberFormatException.forInputString(s, radix);\n+        return parseLong(s, 0, len, radix);\n@@ -670,1 +674,1 @@\n-            endIndex, i - (digit < -1 ? 0 : 1));\n+            endIndex, i - (digit < -1 ? 0 : 1), radix);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Long.java","additions":40,"deletions":36,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,0 +57,10 @@\n+    \/**\n+     * Factory method for making a {@code NumberFormatException}\n+     * given the specified input which caused the error.\n+     *\n+     * @param   s   the input causing the error\n+     *\/\n+    static NumberFormatException forInputString(String s) {\n+        return forInputString(s, 10);\n+    }\n+\n@@ -85,0 +95,20 @@\n+\n+    \/**\n+     * Factory method for making a {@code NumberFormatException}\n+     * given the specified input which caused the error.\n+     *\n+     * <p>When {@code beginIndex} is 0 and {@code endIndex == s.length()}, this method\n+     * behaves exactly like {@link #forInputString(String, int)} in error handling,\n+     * including the format of thrown exceptions and diagnostic messages.\n+     *\/\n+    static NumberFormatException forCharSequence(CharSequence s,\n+            int beginIndex, int endIndex, int errorIndex, int radix) {\n+        if (s instanceof String && beginIndex == 0 && endIndex == s.length()) {\n+            return forInputString((String) s, radix);\n+        }\n+        return forCharSequence(s, beginIndex, endIndex, errorIndex);\n+    }\n+\n+    static NumberFormatException nullInput() {\n+        return new NumberFormatException(\"Cannot parse null string\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/NumberFormatException.java","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2025, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -29,0 +30,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -135,0 +137,47 @@\n+    \/**\n+     * Determine whether the two strings in bytes are both numbers. If they are, return d0 * 10 + d1, otherwise return -1\n+     * @param str The input LATIN1 encoded String value\n+     * @param offset the offset\n+     * @return If both characters are numbers, return d0 * 10 + d1, otherwise return -1\n+     *\/\n+    @ForceInline\n+    public static int digit2(byte[] str, int offset) {\n+        \/*\n+            Here we are doing a 2-Byte Vector operation on the short type.\n+\n+            x & 0xF0 != 0x30\n+            ---------------\n+            0 0b0011_0000 & 0b1111_0000 = 0b0011_0000\n+            1 0b0011_0001 & 0b1111_0000 = 0b0011_0000\n+            2 0b0011_0010 & 0b1111_0000 = 0b0011_0000\n+            3 0b0011_0011 & 0b1111_0000 = 0b0011_0000\n+            4 0b0011_0100 & 0b1111_0000 = 0b0011_0000\n+            5 0b0011_0101 & 0b1111_0000 = 0b0011_0000\n+            6 0b0011_0110 & 0b1111_0000 = 0b0011_0000\n+            7 0b0011_0111 & 0b1111_0000 = 0b0011_0000\n+            8 0b0011_1000 & 0b1111_0000 = 0b0011_0000\n+            9 0b0011_1001 & 0b1111_0000 = 0b0011_0000\n+\n+            (((d = x & 0x0F) + 0x06) & 0xF0) != 0\n+            ---------------\n+            0 ((0b0011_0000) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            1 ((0b0011_0001) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            2 ((0b0011_0010) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            3 ((0b0011_0011) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            4 ((0b0011_0100) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            5 ((0b0011_0101) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            6 ((0b0011_0110) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            7 ((0b0011_0111) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            8 ((0b0011_1000) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+            9 ((0b0011_1001) & 0b0000_1111 + 0b0110_0000) & 0b1111_0000 = 0b0110_0000\n+         *\/\n+        int d;\n+        short x = UNSAFE.getShortUnaligned(str, Unsafe.ARRAY_BYTE_BASE_OFFSET + offset, false);\n+        if ((((x & 0xF0F0) - 0x3030)\n+                | (((d = x & 0x0F0F) + 0x0606) & 0xF0F0)) != 0\n+        ) {\n+            return -1;\n+        }\n+        return (d & 0xF) * 10 + (d >> 8);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/DecimalDigits.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,0 +81,7 @@\n+    @Benchmark\n+    public void parseLong(Blackhole bh) {\n+        for (String s : strings) {\n+            bh.consume(Long.parseLong(s));\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/Longs.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"}]}