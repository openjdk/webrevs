{"files":[{"patch":"@@ -26,0 +26,5 @@\n+import java.io.BufferedWriter;\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n@@ -28,0 +33,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -34,0 +40,1 @@\n+    private static final int COMPILE_TIMEOUT = 60;\n@@ -46,1 +53,1 @@\n-        List<Path> javaFilePaths = Utils.writeSourcesToFiles(javaSources, sourceDir);\n+        List<Path> javaFilePaths = writeSourcesToFiles(javaSources, sourceDir);\n@@ -68,1 +75,1 @@\n-        Utils.executeCompileCommand(command);\n+        executeCompileCommand(command);\n@@ -82,1 +89,1 @@\n-        List<Path> jasmFilePaths = Utils.writeSourcesToFiles(jasmSources, sourceDir);\n+        List<Path> jasmFilePaths = writeSourcesToFiles(jasmSources, sourceDir);\n@@ -96,1 +103,1 @@\n-        command.add(Utils.getAsmToolsPath());\n+        command.add(getAsmToolsPath());\n@@ -104,1 +111,86 @@\n-        Utils.executeCompileCommand(command);\n+        executeCompileCommand(command);\n+    }\n+\n+    \/**\n+     * Get the path of asmtools, which is shipped with JTREG.\n+     *\/\n+    private static String getAsmToolsPath() {\n+        for (String path : Utils.getClassPaths()) {\n+            if (path.endsWith(\"jtreg.jar\")) {\n+                File jtreg = new File(path);\n+                File dir = jtreg.getAbsoluteFile().getParentFile();\n+                File asmtools = new File(dir, \"asmtools.jar\");\n+                if (!asmtools.exists()) {\n+                    throw new InternalCompileFrameworkException(\"Found jtreg.jar in classpath, but could not find asmtools.jar\");\n+                }\n+                return asmtools.getAbsolutePath();\n+            }\n+        }\n+        throw new InternalCompileFrameworkException(\"Could not find asmtools because could not find jtreg.jar in classpath\");\n+    }\n+\n+    private static void writeCodeToFile(String code, Path path) {\n+        Utils.printlnVerbose(\"File: \" + path);\n+\n+        \/\/ Ensure directory of the file exists.\n+        Path dir = path.getParent();\n+        try {\n+            Files.createDirectories(dir);\n+        } catch (Exception e) {\n+            throw new CompileFrameworkException(\"Could not create directory: \" + dir, e);\n+        }\n+\n+        \/\/ Write to file.\n+        try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n+            writer.write(code);\n+        } catch (Exception e) {\n+            throw new CompileFrameworkException(\"Could not write file: \" + path, e);\n+        }\n+    }\n+\n+    \/**\n+     * Write each source in {@code sources} to a file inside {@code sourceDir}.\n+     *\/\n+    private static List<Path> writeSourcesToFiles(List<SourceCode> sources, Path sourceDir) {\n+        List<Path> storedFiles = new ArrayList<>();\n+        for (SourceCode sourceCode : sources) {\n+            Path path = sourceDir.resolve(sourceCode.filePathName());\n+            writeCodeToFile(sourceCode.code(), path);\n+            storedFiles.add(path);\n+        }\n+        return storedFiles;\n+    }\n+\n+    \/**\n+     * Execute a given compilation, given as a {@code command}.\n+     *\/\n+    private static void executeCompileCommand(List<String> command) {\n+        Utils.printlnVerbose(\"Compile command: \" + String.join(\" \", command));\n+\n+        ProcessBuilder builder = new ProcessBuilder(command);\n+        builder.redirectErrorStream(true);\n+\n+        String output;\n+        int exitCode;\n+        try {\n+            Process process = builder.start();\n+            boolean exited = process.waitFor(COMPILE_TIMEOUT, TimeUnit.SECONDS);\n+            if (!exited) {\n+                process.destroyForcibly();\n+                System.out.println(\"Timeout: compile command: \" + String.join(\" \", command));\n+                throw new InternalCompileFrameworkException(\"Process timeout: compilation took too long.\");\n+            }\n+            output = new String(process.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n+            exitCode = process.exitValue();\n+        } catch (IOException e) {\n+            throw new InternalCompileFrameworkException(\"IOException during compilation\", e);\n+        } catch (InterruptedException e) {\n+            throw new CompileFrameworkException(\"InterruptedException during compilation\", e);\n+        }\n+\n+        if (exitCode != 0 || !output.isEmpty()) {\n+            System.err.println(\"Compilation failed.\");\n+            System.err.println(\"Exit code: \" + exitCode);\n+            System.err.println(\"Output: '\" + output + \"'\");\n+            throw new CompileFrameworkException(\"Compilation failed.\");\n+        }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/Compile.java","additions":97,"deletions":5,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-import java.io.BufferedWriter;\n@@ -30,2 +29,0 @@\n-import java.util.concurrent.TimeUnit;\n-import java.io.IOException;\n@@ -33,1 +30,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -42,1 +38,0 @@\n-    private static final int COMPILE_TIMEOUT = 60;\n@@ -86,85 +81,0 @@\n-\n-    \/**\n-     * Get the path of asmtools, which is shipped with JTREG.\n-     *\/\n-    public static String getAsmToolsPath() {\n-        for (String path : getClassPaths()) {\n-            if (path.endsWith(\"jtreg.jar\")) {\n-                File jtreg = new File(path);\n-                File dir = jtreg.getAbsoluteFile().getParentFile();\n-                File asmtools = new File(dir, \"asmtools.jar\");\n-                if (!asmtools.exists()) {\n-                    throw new InternalCompileFrameworkException(\"Found jtreg.jar in classpath, but could not find asmtools.jar\");\n-                }\n-                return asmtools.getAbsolutePath();\n-            }\n-        }\n-        throw new InternalCompileFrameworkException(\"Could not find asmtools because could not find jtreg.jar in classpath\");\n-    }\n-\n-    private static void writeCodeToFile(String code, Path path) {\n-        printlnVerbose(\"File: \" + path);\n-\n-        \/\/ Ensure directory of the file exists.\n-        Path dir = path.getParent();\n-        try {\n-            Files.createDirectories(dir);\n-        } catch (Exception e) {\n-            throw new CompileFrameworkException(\"Could not create directory: \" + dir, e);\n-        }\n-\n-        \/\/ Write to file.\n-        try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n-            writer.write(code);\n-        } catch (Exception e) {\n-            throw new CompileFrameworkException(\"Could not write file: \" + path, e);\n-        }\n-    }\n-\n-    \/**\n-     * Write each source in {@code sources} to a file inside {@code sourceDir}.\n-     *\/\n-    public static List<Path> writeSourcesToFiles(List<SourceCode> sources, Path sourceDir) {\n-        List<Path> storedFiles = new ArrayList<>();\n-        for (SourceCode sourceCode : sources) {\n-            Path path = sourceDir.resolve(sourceCode.filePathName());\n-            writeCodeToFile(sourceCode.code(), path);\n-            storedFiles.add(path);\n-        }\n-        return storedFiles;\n-    }\n-\n-    \/**\n-     * Execute a given compilation, given as a {@code command}.\n-     *\/\n-    public static void executeCompileCommand(List<String> command) {\n-        printlnVerbose(\"Compile command: \" + String.join(\" \", command));\n-\n-        ProcessBuilder builder = new ProcessBuilder(command);\n-        builder.redirectErrorStream(true);\n-\n-        String output;\n-        int exitCode;\n-        try {\n-            Process process = builder.start();\n-            boolean exited = process.waitFor(COMPILE_TIMEOUT, TimeUnit.SECONDS);\n-            if (!exited) {\n-                process.destroyForcibly();\n-                System.out.println(\"Timeout: compile command: \" + String.join(\" \", command));\n-                throw new InternalCompileFrameworkException(\"Process timeout: compilation took too long.\");\n-            }\n-            output = new String(process.getInputStream().readAllBytes(), StandardCharsets.UTF_8);\n-            exitCode = process.exitValue();\n-        } catch (IOException e) {\n-            throw new InternalCompileFrameworkException(\"IOException during compilation\", e);\n-        } catch (InterruptedException e) {\n-            throw new CompileFrameworkException(\"InterruptedException during compilation\", e);\n-        }\n-\n-        if (exitCode != 0 || !output.isEmpty()) {\n-            System.err.println(\"Compilation failed.\");\n-            System.err.println(\"Exit code: \" + exitCode);\n-            System.err.println(\"Output: '\" + output + \"'\");\n-            throw new CompileFrameworkException(\"Compilation failed.\");\n-        }\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/Utils.java","additions":0,"deletions":90,"binary":false,"changes":90,"status":"modified"}]}