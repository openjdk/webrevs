{"files":[{"patch":"@@ -33,1 +33,4 @@\n-* TODO\n+* This is the entry-point for the Compile Framework. Its purpose it to allow\n+* compilation and execution of Java and Jasm sources generated at runtime.\n+*\n+* Please reference the README.md for more explanation.\n@@ -43,1 +46,5 @@\n-    * TODO change name to escaped too???\n+    * Returns the classpath appended with the {@code classesDir}, where\n+    * the compiled classes are stored. This enables another VM to load\n+    * the compiled classes. Note, the string is already backslash escaped,\n+    * so that the windows paths which use backslashes can be used directly\n+    * as strings.\n@@ -50,1 +57,1 @@\n-    * TODO\n+    * Add a Java source to the compilation.\n@@ -57,1 +64,1 @@\n-    * TODO\n+    * Add a Jasm source to the compilation.\n@@ -73,1 +80,3 @@\n-    * TODO\n+    * Compile all sources: store the sources to the sources directory, compile\n+    * Java and Jasm sources and store the generated class-files in the classes\n+    * directory.\n@@ -94,1 +103,1 @@\n-    * TODO\n+    * Access a class from the compiled code.\n@@ -105,1 +114,5 @@\n-    * TODO\n+    * Invoke a static method from the compiled code.\n+    * @param className Class name of a compiled class.\n+    * @param methodName Method name of the class.\n+    * @param args List of arguments for the method invocation.\n+    * @return Return value from the invocation.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/CompileFramework.java","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+# Compile Framework\n+This compile framework allows the compilation and execution of Java and Jasm sources, which are generated at runtime.\n+\n+## Motivation\n+We want to be able to generate Java and Jasm source code in the form of Strings at runtime, then compile them, load the classes and invoke some methods. This allows us to write more elaborate tests. For example small dedicated fuzzers that are targetted at some specific compiler optimization.\n+\n+This is more powerful than hand-written tests, as we can generalize tests and cover more examples. It can also be better than a script-generated test: those are static and often the script is not checked in with the test. Also, the script is only run once, giving a static tests. Compilation at runtime allows us to randomly generate tests each time.\n+\n+Of course we could compile at runtime without this framework, but it abstracts away the complexity of compilation, and allows the test-writer to focus on the generation of the source code.\n+\n+## How to Use the Framework\n+\n+Please reference the examples found in [examples]{..\/..\/..\/testlibrary_tests\/compile_framework\/examples\/}. Some basic tests can be found in [tests]{..\/..\/..\/testlibrary_tests\/compile_framework\/tests\/}.\n+\n+Here a very simple example:\n+\n+    \/\/ Create a new CompileFramework instance.\n+    CompileFramework comp = new CompileFramework();\n+\n+    \/\/ Add a java source file.\n+    comp.addJavaSourceCode(\"XYZ\", \"<your XYZ definition string>\");\n+\n+    \/\/ Compile the source file.\n+    comp.compile();\n+\n+    \/\/ Object ret = XYZ.test(5);\n+    Object ret = comp.invoke(\"XYZ\", \"test\", new Object[] {5});\n+\n+### Creating a new Compile Framework Instance\n+\n+First, one must create a `new CompileFramework()`, which creates two directories: a sources and a classes directory. The sources directory is where all the sources are placed by the Compile Framework, and the classes directory is where all the compiled classes are placed by the Compile Framework.\n+\n+### Adding Sources to the Compilation\n+\n+Java and Jasm sources can be added to the compilation using `comp.addJavaSourceCode` and `comp.addJasmSourceCode`. The source classes can depend on each other, and they can also use the IR-Framework ([TestFrameworkJavaExample]{..\/..\/..\/testlibrary_tests\/compile_framework\/examples\/TestFrameworkJavaExample.java}).\n+\n+### Compiling\n+\n+All sources are compiled with `comp.compile()`. First, the sources are stored to the srouces directory, then compiled, and then the class-files stored in the classes directory. The respective directory names are printed, so that the user can easily access the generated files for debugging.\n+\n+### Interacting with the compiled code\n+\n+The compiled code is then loaded with a ClassLoader. The classes can be accessed directly with `comp.getClass(name)`. Specific methods can also be directly invoked with `comp.invoke`.\n+\n+Should one require the modified classpath that includes the compiled classes, this is available with `comp.getEscapedClassPathOfCompiledClasses()`. This can be necessary if the test launches any other VM's that also access the compiled classes. This is for example necessary when using the IR-Framework.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/README.md","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"}]}