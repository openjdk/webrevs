{"files":[{"patch":"@@ -37,2 +37,2 @@\n-* from the classpath (see {@code Utils.getClassPaths()}) and {@code classesDir}.\n-*\n+* from the classpath (see {@link Utils#getClassPaths()}) and {@code classesDir}.\n+* <p>\n@@ -52,2 +52,2 @@\n-            \/\/ Get all class paths, convert to urls.\n-            List<URL> urls = new ArrayList<URL>();\n+            \/\/ Get all class paths, convert to URLs.\n+            List<URL> urls = new ArrayList<>();\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/ClassLoaderBuilder.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-This compile framework allows the compilation and execution of Java and Jasm sources, which are generated at runtime.\n+The Compile Framework allows the compilation and execution of Java and Jasm sources, which are generated at runtime.\n@@ -7,1 +7,1 @@\n-This is more powerful than hand-written tests, as we can generalize tests and cover more examples. It can also be better than a script-generated test: those are static and often the script is not checked in with the test. Also, the script is only run once, giving a static tests. Compilation at runtime allows us to randomly generate tests each time.\n+This is more powerful than hand-written tests, as we can generalize tests and cover more examples. It can also be better than a script-generated test: those are static and often the script is not integrated with the generated test. Another limitation of a generator script is that it is only run once, creating fixed static tests. Compilation at runtime allows us to randomly generate tests each time.\n@@ -11,1 +11,1 @@\n-## How to Use the Framework\n+## How to Use the Compile Framework\n@@ -35,1 +35,1 @@\n-Java and Jasm sources can be added to the compilation using `comp.addJavaSourceCode` and `comp.addJasmSourceCode`. The source classes can depend on each other, and they can also use the IR-Framework ([TestFrameworkJavaExample](..\/..\/..\/testlibrary_tests\/compile_framework\/examples\/TestFrameworkJavaExample.java)).\n+Java and Jasm sources can be added to the compilation using `comp.addJavaSourceCode()` and `comp.addJasmSourceCode()`. The source classes can depend on each other, and they can also use the IR Framework ([TestFrameworkJavaExample](..\/..\/..\/testlibrary_tests\/compile_framework\/examples\/TestFrameworkJavaExample.java)).\n@@ -39,1 +39,1 @@\n-All sources are compiled with `comp.compile()`. First, the sources are stored to the srouces directory, then compiled, and then the class-files stored in the classes directory. The respective directory names are printed, so that the user can easily access the generated files for debugging.\n+All sources are compiled with `comp.compile()`. First, the sources are stored to the sources directory, then compiled, and then the class-files stored in the classes directory. The respective directory names are printed, so that the user can easily access the generated files for debugging.\n@@ -41,1 +41,1 @@\n-### Interacting with the compiled code\n+### Interacting with the Compiled Code\n@@ -43,1 +43,1 @@\n-The compiled code is then loaded with a ClassLoader. The classes can be accessed directly with `comp.getClass(name)`. Specific methods can also be directly invoked with `comp.invoke`.\n+The compiled code is then loaded with a `ClassLoader`. The classes can be accessed directly with `comp.getClass(name)`. Specific methods can also directly be invoked with `comp.invoke()`.\n@@ -45,1 +45,1 @@\n-Should one require the modified classpath that includes the compiled classes, this is available with `comp.getEscapedClassPathOfCompiledClasses()`. This can be necessary if the test launches any other VM's that also access the compiled classes. This is for example necessary when using the IR-Framework.\n+Should one require the modified classpath that includes the compiled classes, this is available with `comp.getEscapedClassPathOfCompiledClasses()`. This can be necessary if the test launches any other VMs that also access the compiled classes. This is for example necessary when using the IR Framework.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/README.md","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    * Create a temporary directory, with a unique name, so that there can be no collisions\n+    * Create a temporary directory with a unique name to avoid collisions\n@@ -165,3 +165,3 @@\n-            System.out.println(\"Compilation failed.\");\n-            System.out.println(\"Exit code: \" + exitCode);\n-            System.out.println(\"Output: '\" + output + \"'\");\n+            System.err.println(\"Compilation failed.\");\n+            System.err.println(\"Exit code: \" + exitCode);\n+            System.err.println(\"Output: '\" + output + \"'\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/compile_framework\/Utils.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * This test shows a compilation of multiple java and jasm source code files.\n+ * This test shows a compilation of multiple Java and Jasm source code files.\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/compile_framework\/examples\/CombinedJavaJasmExample.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}