{"files":[{"patch":"@@ -403,3 +403,0 @@\n-      if (field_off > field_offset)\n-        break;\n-      \/\/ could do binary search or check bins, but probably not worth it\n@@ -434,5 +431,0 @@\n-static int sort_field_by_offset(ciField** a, ciField** b) {\n-  return (*a)->offset_in_bytes() - (*b)->offset_in_bytes();\n-  \/\/ (no worries about 32-bit overflow...)\n-}\n-\n@@ -479,3 +471,0 @@\n-  \/\/ Now sort them by offset, ascending.\n-  \/\/ (In principle, they could mix with superclass fields.)\n-  fields->sort(sort_field_by_offset);\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  GrowableArray<ciField*>* _nonstatic_fields;\n+  GrowableArray<ciField*>* _nonstatic_fields;  \/\/ ordered by JavaFieldStream\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -379,2 +379,3 @@\n-    bool skip_internal = (compiled_method != nullptr) && !compiled_method->is_compiled_by_jvmci();\n-    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, skip_internal);\n+    guarantee(compiled_method != nullptr, \"deopt must be associated with an nmethod\");\n+    bool is_jvmci = compiled_method->is_compiled_by_jvmci();\n+    Deoptimization::reassign_fields(&deoptee, &map, objects, realloc_failures, is_jvmci);\n@@ -1454,17 +1455,12 @@\n-static int compare(ReassignedField* left, ReassignedField* right) {\n-  return left->_offset - right->_offset;\n-}\n-\n-\/\/ Restore fields of an eliminated instance object using the same field order\n-\/\/ returned by HotSpotResolvedObjectTypeImpl.getInstanceFields(true)\n-static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool skip_internal) {\n-  GrowableArray<ReassignedField>* fields = new GrowableArray<ReassignedField>();\n-  InstanceKlass* ik = klass;\n-  while (ik != nullptr) {\n-    for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.field_flags().is_injected())) {\n-        ReassignedField field;\n-        field._offset = fs.offset();\n-        field._type = Signature::basic_type(fs.signature());\n-        fields->append(field);\n-      }\n+\/\/ Gets the fields of `klass` that are eliminated by escape analysis and need to be reassigned\n+static GrowableArray<ReassignedField>* get_reassigned_fields(InstanceKlass* klass, GrowableArray<ReassignedField>* fields, bool is_jvmci) {\n+  InstanceKlass* super = klass->superklass();\n+  if (super != nullptr) {\n+    get_reassigned_fields(super, fields, is_jvmci);\n+  }\n+  for (AllFieldStream fs(klass); !fs.done(); fs.next()) {\n+    if (!fs.access_flags().is_static() && (is_jvmci || !fs.field_flags().is_injected())) {\n+      ReassignedField field;\n+      field._offset = fs.offset();\n+      field._type = Signature::basic_type(fs.signature());\n+      fields->append(field);\n@@ -1472,1 +1468,0 @@\n-    ik = ik->superklass();\n@@ -1474,1 +1469,6 @@\n-  fields->sort(compare);\n+  return fields;\n+}\n+\n+\/\/ Restore fields of an eliminated instance object employing the same field order used by the compiler.\n+static int reassign_fields_by_klass(InstanceKlass* klass, frame* fr, RegisterMap* reg_map, ObjectValue* sv, int svIndex, oop obj, bool is_jvmci) {\n+  GrowableArray<ReassignedField>* fields = get_reassigned_fields(klass, new GrowableArray<ReassignedField>(), is_jvmci);\n@@ -1556,1 +1556,1 @@\n-void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool skip_internal) {\n+void Deoptimization::reassign_fields(frame* fr, RegisterMap* reg_map, GrowableArray<ScopeValue*>* objects, bool realloc_failures, bool is_jvmci) {\n@@ -1600,1 +1600,1 @@\n-      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), skip_internal);\n+      reassign_fields_by_klass(ik, fr, reg_map, sv, 0, obj(), is_jvmci);\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -70,1 +70,0 @@\n-    private static final SortByOffset fieldSortingMethod = new SortByOffset();\n@@ -785,6 +784,0 @@\n-    static class SortByOffset implements Comparator<ResolvedJavaField> {\n-        public int compare(ResolvedJavaField a, ResolvedJavaField b) {\n-            return a.getOffset() - b.getOffset();\n-        }\n-    }\n-\n@@ -820,1 +813,0 @@\n-                Arrays.sort(result, fieldSortingMethod);\n@@ -879,1 +871,0 @@\n-        Arrays.sort(result, fieldSortingMethod);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-     * Returns the instance fields of this class, including\n+     * Returns the non-static fields of this class, including\n@@ -289,4 +289,2 @@\n-     * for array and primitive types. The order of fields returned by this method is stable. That\n-     * is, for a single JVM execution the same order is returned each time this method is called. It\n-     * is also the \"natural\" order, which means that the JVM would expect the fields in this order\n-     * if no specific order is given.\n+     * for array and primitive types. The order of fields declared by a single class returned by\n+     * this method is the same as {@link Class#getDeclaredFields}.\n@@ -294,3 +292,3 @@\n-     * @param includeSuperclasses if true, then instance fields for the complete hierarchy of this\n-     *            type are included in the result\n-     * @return an array of instance fields\n+     * @param includeSuperclasses if true, then non-static fields for the complete hierarchy of this\n+     *            type are included in the result with superclass fields coming before subclass fields\n+     * @return an array of non-static fields\n@@ -303,2 +301,1 @@\n-     * fields returned by this method is stable. That is, for a single JVM execution the same order\n-     * is returned each time this method is called.\n+     * fields returned by this method is the same as {@link Class#getDeclaredFields}.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaType.java","additions":7,"deletions":10,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+import java.util.ArrayList;\n@@ -75,0 +76,1 @@\n+import java.util.Collection;\n@@ -147,1 +149,1 @@\n-            Set<Field> reflectionFields = getInstanceFields(c, true);\n+            Set<Field> reflectionFields = Set.copyOf(getInstanceFields(c, true));\n@@ -875,1 +877,1 @@\n-    public static Set<Field> getInstanceFields(Class<?> c, boolean includeSuperclasses) {\n+    public static List<Field> getInstanceFields(Class<?> c, boolean includeSuperclasses) {\n@@ -877,1 +879,1 @@\n-            return Collections.emptySet();\n+            return List.of();\n@@ -879,1 +881,1 @@\n-        Set<Field> result = new HashSet<>();\n+        List<Field> result = new ArrayList<>();\n@@ -886,1 +888,3 @@\n-            result.addAll(getInstanceFields(c.getSuperclass(), true));\n+            List<Field> allFields = getInstanceFields(c.getSuperclass(), true);\n+            allFields.addAll(result);\n+            result = allFields;\n@@ -915,1 +919,1 @@\n-    public Field lookupField(Set<Field> fields, ResolvedJavaField key) {\n+    public Field lookupField(Collection<Field> fields, ResolvedJavaField key) {\n@@ -925,3 +929,0 @@\n-        if (f.getDeclaringClass().equals(metaAccess.lookupJavaType(Throwable.class)) && f.getName().equals(\"backtrace\")) {\n-            return true;\n-        }\n@@ -956,4 +957,12 @@\n-                Set<Field> expected = getInstanceFields(c, includeSuperclasses);\n-                ResolvedJavaField[] actual = type.getInstanceFields(includeSuperclasses);\n-                for (Field f : expected) {\n-                    assertNotNull(lookupField(actual, f));\n+                List<Field> reflectFields = getInstanceFields(c, includeSuperclasses);\n+                ResolvedJavaField[] fields = type.getInstanceFields(includeSuperclasses);\n+                int reflectFieldIndex = 0;\n+                for (int i = 0; i < fields.length; i++) {\n+                    ResolvedJavaField field = fields[i];\n+                    if (field.isInternal() || isHiddenFromReflection(field)) {\n+                        continue;\n+                    }\n+                    Field reflectField = reflectFields.get(reflectFieldIndex++);\n+                    ResolvedJavaField field2 = lookupField(fields, reflectField);\n+\n+                    assertEquals(\"ResolvedJavaType.getInstanceFields order differs from Class.getDeclaredFields\", field, field2);\n@@ -961,1 +970,1 @@\n-                for (ResolvedJavaField rf : actual) {\n+                for (ResolvedJavaField rf : fields) {\n@@ -963,1 +972,1 @@\n-                        assertEquals(rf.toString(), lookupField(expected, rf) != null, !rf.isInternal());\n+                        assertEquals(rf.toString(), lookupField(reflectFields, rf) != null, !rf.isInternal());\n@@ -968,2 +977,2 @@\n-                ResolvedJavaField[] actual2 = type.getInstanceFields(includeSuperclasses);\n-                assertArrayEquals(actual, actual2);\n+                ResolvedJavaField[] fields2 = type.getInstanceFields(includeSuperclasses);\n+                assertArrayEquals(fields, fields2);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaType.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"}]}