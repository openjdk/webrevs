{"files":[{"patch":"@@ -37,1 +37,2 @@\n-import java.util.Optional;\n+\n+import java.util.regex.Pattern;\n@@ -54,3 +55,0 @@\n-    private static final Path NS_MNT   = Path.of(\"ns\/mnt\");\n-    private static final Path NS_PID   = Path.of(\"ns\/pid\");\n-    private static final Path SELF     = PROC.resolve(\"self\");\n@@ -60,14 +58,0 @@\n-    private static final Optional<Path> SELF_MNT_NS;\n-\n-    static {\n-        Path nsPath = null;\n-\n-        try {\n-            nsPath = Files.readSymbolicLink(SELF.resolve(NS_MNT));\n-        } catch (IOException _) {\n-            \/\/ do nothing\n-        } finally {\n-            SELF_MNT_NS = Optional.ofNullable(nsPath);\n-        }\n-    }\n-\n@@ -100,0 +84,3 @@\n+\n+            boolean sentQuit = false;\n+\n@@ -101,1 +88,1 @@\n-                sendQuitTo(pid);\n+                sentQuit = checkCatchesAndSendQuitTo(pid, false);\n@@ -118,1 +105,1 @@\n-                        sendQuitTo(pid);\n+                        sentQuit = checkCatchesAndSendQuitTo(pid, false);\n@@ -121,0 +108,1 @@\n+\n@@ -124,2 +112,2 @@\n-                          \"target process %d doesn't respond within %dms \" +\n-                          \"or HotSpot VM not loaded\", socket_path, pid,\n+                          \"target process %d %s within %dms \" +\n+                          \"or HotSpot VM not loaded\", socket_path, pid, sentQuit ? \"doesn't respond\" : \"has not become ready\",\n@@ -268,65 +256,19 @@\n-        Optional<ProcessHandle> target = ProcessHandle.of(pid);\n-        Optional<ProcessHandle> ph = target;\n-        long nsPid = ns_pid;\n-        Optional<Path> prevPidNS = Optional.empty();\n-\n-        while (ph.isPresent()) {\n-            final var curPid = ph.get().pid();\n-            final var procPidPath = PROC.resolve(Long.toString(curPid));\n-            Optional<Path> targetMountNS = Optional.empty();\n-\n-            try {\n-                \/\/ attempt to read the target's mnt ns id\n-                targetMountNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_MNT)));\n-            } catch (IOException _) {\n-                \/\/ if we fail to read the target's mnt ns id then we either don't have access or it no longer exists!\n-                if (!Files.exists(procPidPath)) {\n-                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n-                }\n-                \/\/ the process still exists, but we don't have privileges to read its procfs\n-            }\n-\n-            final var sameMountNS = SELF_MNT_NS.isPresent() && SELF_MNT_NS.equals(targetMountNS);\n-\n-            if (sameMountNS) {\n-                return TMPDIR.toString(); \/\/ we share TMPDIR in common!\n-            } else {\n-                \/\/ we could not read the target's mnt ns\n-                final var procPidRootTmp = procPidPath.resolve(ROOT_TMP);\n-                if (Files.isReadable(procPidRootTmp)) {\n-                    return procPidRootTmp.toString(); \/\/ not in the same mnt ns but tmp is accessible via \/proc\n-                }\n-            }\n-\n-            \/\/ let's attempt to obtain the pid ns, best efforts to avoid crossing pid ns boundaries (as with a container)\n-            Optional<Path> curPidNS = Optional.empty();\n-\n-            try {\n-                \/\/ attempt to read the target's pid ns id\n-                curPidNS = Optional.ofNullable(Files.readSymbolicLink(procPidPath.resolve(NS_PID)));\n-            } catch (IOException _) {\n-                \/\/ if we fail to read the target's pid ns id then we either don't have access or it no longer exists!\n-                if (!Files.exists(procPidPath)) {\n-                    throw new IOException(String.format(\"unable to attach, %s non-existent! process: %d terminated\", procPidPath, pid));\n-                }\n-                \/\/ the process still exists, but we don't have privileges to read its procfs\n-            }\n-\n-            \/\/ recurse \"up\" the process hierarchy if appropriate. PID 1 cannot have a parent in the same namespace\n-            final var havePidNSes = prevPidNS.isPresent() && curPidNS.isPresent();\n-            final var ppid = ph.get().parent();\n-\n-            if (ppid.isPresent() && (havePidNSes && curPidNS.equals(prevPidNS)) || (!havePidNSes && nsPid > 1)) {\n-                ph = ppid;\n-                nsPid = getNamespacePid(ph.get().pid()); \/\/ get the ns pid of the parent\n-                prevPidNS = curPidNS;\n-            } else {\n-                ph = Optional.empty();\n-            }\n-        }\n-\n-        if (target.orElseThrow(AttachNotSupportedException::new).isAlive()) {\n-            return TMPDIR.toString(); \/\/ fallback...\n-        } else {\n-            throw new IOException(String.format(\"unable to attach, process: %d terminated\", pid));\n-        }\n+        final var procPidRoot = PROC.resolve(Long.toString(pid)).resolve(ROOT_TMP);\n+\n+        \/*\n+         * if target is elevated, we cant use \/proc\/<pid>\/... so we have to fallback to \/tmp, but that may not be shared\n+         * with the target\/attachee process, we can try, except in the case where the ns_pid also exists in this pid ns\n+         * which is ambiguous, if we share \/tmp with the intended target, the attach will succeed, if we do not,\n+         * then we will potentially attempt to attach to some arbitrary process with the same pid (in this pid ns)\n+         * as that of the intended target (in its * pid ns).\n+         *\n+         * so in that case we should prehaps throw - or risk sending SIGQUIT to some arbitrary process... which could kill it\n+         *\n+         * however we can also check the target pid's signal masks to see if it catches SIGQUIT and only do so if in\n+         * fact it does ... this reduces the risk of killing an innocent process in the current ns as opposed to\n+         * attaching to the actual target JVM ... c.f: checkCatchesAndSendQuitTo() below.\n+         *\n+         * note that if pid == ns_pid we are in a shared pid ns with the target and may (potentially) share \/tmp\n+         *\/\n+\n+        return (Files.isWritable(procPidRoot) ? procPidRoot : TMPDIR).toString();\n@@ -381,0 +323,66 @@\n+    private static final String FIELD = \"field\";\n+    private static final String MASK  = \"mask\";\n+\n+    private static final String SIGNAL_MASK_PATTERN = \"(?<\" + FIELD + \">Sig\\\\p{Alpha}{3}):\\\\s+(?<\" + MASK + \">\\\\p{XDigit}{16}).*\";\n+\n+    private static final long SIGQUIT = 1L << 2;\n+\n+    private static boolean checkCatchesAndSendQuitTo(int pid, boolean throwIfNotReady) throws AttachNotSupportedException, IOException {\n+        var quitIgn = false;\n+        var quitBlk = false;\n+        var quitCgt = false;\n+\n+        final var procPid = PROC.resolve(Integer.toString(pid));\n+\n+        final var p = Pattern.compile(SIGNAL_MASK_PATTERN);\n+\n+        var readBlk = false;\n+        var readIgn = false;\n+        var readCgt = false;\n+\n+\n+        if (!Files.exists(procPid)) throw new IOException(\"non existent JVM pid: \" + pid);\n+\n+        for (var line : Files.readAllLines(procPid.resolve(\"status\"))) {\n+\n+            if (!line.startsWith(\"Sig\")) continue; \/\/ to speed things up ... avoids the matcher\/RE invocation...\n+\n+            final var m = p.matcher(line);\n+\n+            if (!m.matches()) continue;\n+\n+            var       signals = m.group(MASK);\n+            final var slen    = signals.length();\n+\n+            signals = signals.substring(slen \/ 2 , slen); \/\/ only really interested in the non r\/t signals ...\n+\n+            final var sigquit = (Long.valueOf(signals, 16) & SIGQUIT) != 0L;\n+\n+            switch (m.group(FIELD)) {\n+                case \"SigBlk\": { quitBlk = sigquit; readBlk = true; break; }\n+                case \"SigIgn\": { quitIgn = sigquit; readCgt = true; break; }\n+                case \"SigCgt\": { quitCgt = sigquit; readIgn = true; break; }\n+            }\n+\n+            if (readBlk && readIgn && readCgt) break;\n+        }\n+\n+        final boolean  okToSendQuit = (!quitIgn && quitCgt); \/\/ ignore blocked as it may be temporary ...\n+\n+        if (okToSendQuit) {\n+            sendQuitTo(pid);\n+        } else if (throwIfNotReady) {\n+            final var cmdline = Files.lines(procPid.resolve(\"cmdline\")).findFirst();\n+\n+            var cmd = \"null\"; \/\/ default\n+\n+            if (cmdline.isPresent()) {\n+                cmd = cmdline.get();\n+                cmd = cmd.substring(0, cmd.length() - 1); \/\/ remove trailing \\0\n+            }\n+\n+            throw new AttachNotSupportedException(\"pid: \" + pid + \" cmd: '\" + cmd + \"' state is not ready to participate in attach handshake!\");\n+        }\n+\n+        return okToSendQuit;\n+    }\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":95,"deletions":87,"binary":false,"changes":182,"status":"modified"}]}