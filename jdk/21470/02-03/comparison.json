{"files":[{"patch":"@@ -2216,1 +2216,0 @@\n-    \/\/ %%% FIXME: ldc of Class can generate an exception\n","filename":"src\/hotspot\/share\/ci\/ciTypeFlow.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1961,0 +1961,2 @@\n+    \/\/ ciTypeFlow should trap if the ldc is in error state or if the constant is not loaded\n+    assert(!iter().is_in_error(), \"ldc is in error state\");\n@@ -1962,19 +1964,4 @@\n-    if (constant.is_loaded()) {\n-      const Type* con_type = Type::make_from_constant(constant);\n-      if (con_type != nullptr) {\n-        push_node(con_type->basic_type(), makecon(con_type));\n-      }\n-    } else {\n-      \/\/ If the constant is unresolved or in error state, run this BC in the interpreter.\n-      if (iter().is_in_error()) {\n-        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unhandled,\n-                                                        Deoptimization::Action_none),\n-                      nullptr, \"constant in error state\", true \/* must_throw *\/);\n-\n-      } else {\n-        int index = iter().get_constant_pool_index();\n-        uncommon_trap(Deoptimization::make_trap_request(Deoptimization::Reason_unloaded,\n-                                                        Deoptimization::Action_reinterpret,\n-                                                        index),\n-                      nullptr, \"unresolved constant\", false \/* must_throw *\/);\n-      }\n+    assert(constant.is_loaded(), \"constant is not loaded\");\n+    const Type* con_type = Type::make_from_constant(constant);\n+    if (con_type != nullptr) {\n+      push_node(con_type->basic_type(), makecon(con_type));\n","filename":"src\/hotspot\/share\/opto\/parse2.cpp","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"}]}