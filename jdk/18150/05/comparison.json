{"files":[{"patch":"@@ -1177,1 +1177,1 @@\n-  _is_alive_closure_cm(this),\n+  _is_alive_closure_cm(),\n@@ -1508,0 +1508,1 @@\n+  _is_alive_closure_cm.initialize(concurrent_mark());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -256,0 +256,1 @@\n+    G1ConcurrentMark* cm = G1CollectedHeap::heap()->concurrent_mark();\n@@ -258,1 +259,1 @@\n-                  p2i(r->top_at_mark_start()),\n+                  p2i(cm->top_at_mark_start(r)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -81,0 +81,12 @@\n+G1CMIsAliveClosure::G1CMIsAliveClosure() : _cm(nullptr) { }\n+\n+G1CMIsAliveClosure::G1CMIsAliveClosure(G1ConcurrentMark* cm) : _cm(cm) {\n+  assert(cm != nullptr, \"must be\");\n+}\n+\n+void G1CMIsAliveClosure::initialize(G1ConcurrentMark* cm) {\n+  assert(cm != nullptr, \"must be\");\n+  assert(_cm == nullptr, \"double initialize\");\n+  _cm = cm;\n+}\n+\n@@ -505,0 +517,1 @@\n+  _top_at_mark_starts(NEW_C_HEAP_ARRAY(HeapWord*, _g1h->max_reserved_regions(), mtGC)),\n@@ -651,0 +664,1 @@\n+  FREE_C_HEAP_ARRAY(HeapWord*, _top_at_mark_starts);\n@@ -696,1 +710,1 @@\n-        assert(_bitmap->get_next_marked_addr(r->top_at_mark_start(), r->end()) == r->end(), \"Should not have marked bits above tams\");\n+        assert(_bitmap->get_next_marked_addr(_cm->top_at_mark_start(r), r->end()) == r->end(), \"Should not have marked bits above tams\");\n@@ -740,1 +754,1 @@\n-      r->reset_top_at_mark_start();\n+      _cm->reset_top_at_mark_start(r);\n@@ -852,0 +866,2 @@\n+  G1ConcurrentMark* _cm;\n+\n@@ -853,0 +869,2 @@\n+  NoteStartOfMarkHRClosure() : HeapRegionClosure(), _cm(G1CollectedHeap::heap()->concurrent_mark()) { }\n+\n@@ -854,1 +872,3 @@\n-    r->note_start_of_marking();\n+    if (r->is_old_or_humongous() && !r->is_collection_set_candidate()) {\n+      _cm->update_top_at_mark_start(r);\n+    }\n@@ -1018,1 +1038,1 @@\n-  assert(hr->is_old() || hr->top_at_mark_start() == hr->bottom(),\n+  assert(hr->is_old() || top_at_mark_start(hr) == hr->bottom(),\n@@ -1020,1 +1040,1 @@\n-  assert(hr->top_at_mark_start() == region->start(),\n+  assert(top_at_mark_start(hr) == region->start(),\n@@ -1082,1 +1102,1 @@\n-  root_regions()->add(r->top_at_mark_start(), r->top());\n+  root_regions()->add(top_at_mark_start(r), r->top());\n@@ -1086,1 +1106,1 @@\n-  return root_regions()->contains(MemRegion(r->top_at_mark_start(), r->top()));\n+  return root_regions()->contains(MemRegion(top_at_mark_start(r), r->top()));\n@@ -1253,1 +1273,1 @@\n-        const bool is_live = hr->top_at_mark_start() == hr->bottom()\n+        const bool is_live = _cm->top_at_mark_start(hr) == hr->bottom()\n@@ -1269,1 +1289,1 @@\n-        hr->note_end_of_marking(_cm->live_bytes(hr->hrm_index()));\n+        hr->note_end_of_marking(_cm->top_at_mark_start(hr), _cm->live_bytes(hr->hrm_index()));\n@@ -1389,1 +1409,1 @@\n-      G1CMIsAliveClosure is_alive(_g1h);\n+      G1CMIsAliveClosure is_alive(this);\n@@ -1643,1 +1663,1 @@\n-    G1CMIsAliveClosure is_alive(&_g1h);\n+    G1CMIsAliveClosure is_alive(&_cm);\n@@ -1722,1 +1742,1 @@\n-    G1CMIsAliveClosure is_alive(_g1h);\n+    G1CMIsAliveClosure is_alive(this);\n@@ -1901,1 +1921,1 @@\n-      HeapWord* limit = curr_region->top_at_mark_start();\n+      HeapWord* limit = top_at_mark_start(curr_region);\n@@ -1903,1 +1923,1 @@\n-      log_trace(gc, marking)(\"Claim region %u bottom \" PTR_FORMAT \" tams \" PTR_FORMAT, curr_region->hrm_index(), p2i(curr_region->bottom()), p2i(curr_region->top_at_mark_start()));\n+      log_trace(gc, marking)(\"Claim region %u bottom \" PTR_FORMAT \" tams \" PTR_FORMAT, curr_region->hrm_index(), p2i(curr_region->bottom()), p2i(top_at_mark_start(curr_region)));\n@@ -2126,1 +2146,1 @@\n-  HeapWord* limit = hr->top_at_mark_start();\n+  HeapWord* limit = _cm->top_at_mark_start(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":35,"deletions":15,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -44,1 +44,0 @@\n-class G1ConcurrentMarkThread;\n@@ -46,0 +45,2 @@\n+class G1ConcurrentMark;\n+class G1ConcurrentMarkThread;\n@@ -48,1 +49,0 @@\n-class G1ConcurrentMark;\n@@ -99,1 +99,2 @@\n-  G1CollectedHeap* _g1h;\n+  G1ConcurrentMark* _cm;\n+\n@@ -101,1 +102,4 @@\n-  G1CMIsAliveClosure(G1CollectedHeap* g1h) : _g1h(g1h) { }\n+  G1CMIsAliveClosure();\n+  G1CMIsAliveClosure(G1ConcurrentMark* cm);\n+  void initialize(G1ConcurrentMark* cm);\n+\n@@ -540,0 +544,3 @@\n+  \/\/ Top pointer for each region at the start of marking. Must be valid for all committed\n+  \/\/ regions.\n+  HeapWord* volatile* _top_at_mark_starts;\n@@ -559,0 +566,10 @@\n+  \/\/ Update the TAMS for the given region to the current top.\n+  inline void update_top_at_mark_start(HeapRegion* r);\n+  \/\/ Reset the TAMS for the given region to bottom of that region.\n+  inline void reset_top_at_mark_start(HeapRegion* r);\n+\n+  inline HeapWord* top_at_mark_start(const HeapRegion* r) const;\n+  inline HeapWord* top_at_mark_start(uint region) const;\n+  \/\/ Returns whether the given object been allocated since marking start (i.e. >= TAMS in that region).\n+  inline bool obj_allocated_since_mark_start(oop obj) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -51,1 +51,0 @@\n-  HeapRegion* hr = _g1h->heap_region_containing(obj);\n@@ -53,1 +52,1 @@\n-  if (hr->obj_allocated_since_marking_start(obj)) {\n+  if (_cm->obj_allocated_since_mark_start(obj)) {\n@@ -58,1 +57,1 @@\n-  return _g1h->is_marked(obj);\n+  return _cm->is_marked_in_bitmap(obj);\n@@ -69,3 +68,1 @@\n-  HeapRegion* const hr = _g1h->heap_region_containing(obj);\n-\n-  if (hr->obj_allocated_since_marking_start(obj)) {\n+  if (obj_allocated_since_mark_start(obj)) {\n@@ -77,1 +74,4 @@\n-  assert(!hr->is_continues_humongous(), \"Should not try to mark object \" PTR_FORMAT \" in Humongous continues region %u above TAMS \" PTR_FORMAT, p2i(obj), hr->hrm_index(), p2i(hr->top_at_mark_start()));\n+  DEBUG_ONLY(HeapRegion* const hr = _g1h->heap_region_containing(obj);)\n+  assert(!hr->is_continues_humongous(),\n+         \"Should not try to mark object \" PTR_FORMAT \" in Humongous continues region %u above TAMS \" PTR_FORMAT,\n+         p2i(obj), hr->hrm_index(), p2i(top_at_mark_start(hr)));\n@@ -187,0 +187,25 @@\n+inline void G1ConcurrentMark::update_top_at_mark_start(HeapRegion* r) {\n+  uint const region = r->hrm_index();\n+  assert(region < _g1h->max_reserved_regions(), \"Tried to access TAMS for region %u out of bounds\", region);\n+  _top_at_mark_starts[region] = r->top();\n+}\n+\n+inline void G1ConcurrentMark::reset_top_at_mark_start(HeapRegion* r) {\n+  _top_at_mark_starts[r->hrm_index()] = r->bottom();\n+}\n+\n+inline HeapWord* G1ConcurrentMark::top_at_mark_start(const HeapRegion* r) const {\n+  return top_at_mark_start(r->hrm_index());\n+}\n+\n+inline HeapWord* G1ConcurrentMark::top_at_mark_start(uint region) const {\n+  assert(region < _g1h->max_reserved_regions(), \"Tried to access TARS for region %u out of bounds\", region);\n+  return _top_at_mark_starts[region];\n+}\n+\n+inline bool G1ConcurrentMark::obj_allocated_since_mark_start(oop obj) const {\n+  uint const region = _g1h->addr_to_region(obj);\n+  assert(region < _g1h->max_reserved_regions(), \"obj \" PTR_FORMAT \" outside heap %u\", p2i(obj), region);\n+  return cast_from_oop<HeapWord*>(obj) >= top_at_mark_start(region);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.inline.hpp","additions":32,"deletions":7,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -232,1 +232,1 @@\n-                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr)), p2i(hr->top_at_mark_start()));\n+                             HR_FORMAT_PARAMS(hr), p2i(pb), p2i(_cm->top_at_rebuild_start(hr)), p2i(_cm->top_at_mark_start(hr)));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRebuildAndScrub.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -127,1 +127,5 @@\n-  init_top_at_mark_start();\n+  G1CollectedHeap::heap()->concurrent_mark()->reset_top_at_mark_start(this);\n+\n+  _parsable_bottom = bottom();\n+  _garbage_bytes = 0;\n+\n@@ -229,1 +233,0 @@\n-  _top_at_mark_start(nullptr),\n@@ -417,0 +420,1 @@\n+  G1ConcurrentMark* cm = G1CollectedHeap::heap()->concurrent_mark();\n@@ -418,1 +422,1 @@\n-            p2i(top_at_mark_start()), p2i(parsable_bottom_acquire()), rem_set()->get_state_str());\n+            p2i(cm->top_at_mark_start(this)), p2i(parsable_bottom_acquire()), rem_set()->get_state_str());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -226,6 +226,0 @@\n-  \/\/ The start of the unmarked area. The unmarked area extends from this\n-  \/\/ word until the top and\/or end of the region, and is the part\n-  \/\/ of the region for which no marking was done, i.e. objects may\n-  \/\/ have been allocated in this part since the last mark phase.\n-  HeapWord* volatile _top_at_mark_start;\n-\n@@ -249,2 +243,0 @@\n-  inline void init_top_at_mark_start();\n-\n@@ -355,4 +347,0 @@\n-  \/\/ Get the start of the unmarked area in this region.\n-  HeapWord* top_at_mark_start() const;\n-  void set_top_at_mark_start(HeapWord* value);\n-\n@@ -369,7 +357,3 @@\n-  \/\/ Notify the region that concurrent marking is starting. Initialize\n-  \/\/ all fields related to the next marking info.\n-  inline void note_start_of_marking();\n-\n-  \/\/ Notify the region that concurrent marking has finished. Passes the number of\n-  \/\/ bytes between bottom and TAMS.\n-  inline void note_end_of_marking(size_t marked_bytes);\n+  \/\/ Notify the region that concurrent marking has finished. Passes TAMS and the number of\n+  \/\/ bytes marked between bottom and TAMS.\n+  inline void note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes);\n@@ -380,3 +364,0 @@\n-  \/\/ Notify the region that the (corresponding) bitmap has been cleared.\n-  inline void reset_top_at_mark_start();\n-\n@@ -543,4 +524,0 @@\n-  bool obj_allocated_since_marking_start(oop obj) const {\n-    return cast_from_oop<HeapWord*>(obj) >= top_at_mark_start();\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":3,"deletions":26,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -179,3 +179,0 @@\n-  \/\/ After a compaction the mark bitmap in a movable region is invalid.\n-  \/\/ But all objects are live, we get this by setting TAMS to bottom.\n-  init_top_at_mark_start();\n@@ -189,4 +186,0 @@\n-  _garbage_bytes = 0;\n-\n-  reset_top_at_mark_start();\n-\n@@ -197,0 +190,4 @@\n+  \/\/ After a full gc the mark information in a movable region is invalid. Reset marking\n+  \/\/ information.\n+  G1CollectedHeap::heap()->concurrent_mark()->reset_top_at_mark_start(this);\n+\n@@ -200,0 +197,2 @@\n+  _garbage_bytes = 0;\n+\n@@ -269,8 +268,0 @@\n-inline HeapWord* HeapRegion::top_at_mark_start() const {\n-  return Atomic::load(&_top_at_mark_start);\n-}\n-\n-inline void HeapRegion::set_top_at_mark_start(HeapWord* value) {\n-  Atomic::store(&_top_at_mark_start, value);\n-}\n-\n@@ -290,8 +281,1 @@\n-inline void HeapRegion::note_start_of_marking() {\n-  assert(top_at_mark_start() == bottom(), \"Region's TAMS must always be at bottom\");\n-  if (is_old_or_humongous() && !is_collection_set_candidate()) {\n-    set_top_at_mark_start(top());\n-  }\n-}\n-\n-inline void HeapRegion::note_end_of_marking(size_t marked_bytes) {\n+inline void HeapRegion::note_end_of_marking(HeapWord* top_at_mark_start, size_t marked_bytes) {\n@@ -300,2 +284,2 @@\n-  if (top_at_mark_start() != bottom()) {\n-    _garbage_bytes = byte_size(bottom(), top_at_mark_start()) - marked_bytes;\n+  if (top_at_mark_start != bottom()) {\n+    _garbage_bytes = byte_size(bottom(), top_at_mark_start) - marked_bytes;\n@@ -305,1 +289,1 @@\n-    _parsable_bottom = top_at_mark_start();\n+    _parsable_bottom = top_at_mark_start;\n@@ -313,17 +297,0 @@\n-inline void HeapRegion::init_top_at_mark_start() {\n-  reset_top_at_mark_start();\n-  _parsable_bottom = bottom();\n-  _garbage_bytes = 0;\n-}\n-\n-inline void HeapRegion::reset_top_at_mark_start() {\n-  \/\/ We do not need a release store here because\n-  \/\/\n-  \/\/ - if this method is called during concurrent bitmap clearing, we do not read\n-  \/\/ the bitmap any more for live\/dead information (we do not read the bitmap at\n-  \/\/ all at that point).\n-  \/\/ - otherwise we reclaim regions only during GC and we do not read tams and the\n-  \/\/ bitmap concurrently.\n-  set_top_at_mark_start(bottom());\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":10,"deletions":43,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -465,0 +465,1 @@\n+    HeapWord* top_at_mark_start = cm->top_at_mark_start(r);\n@@ -467,2 +468,3 @@\n-      guarantee(r->bottom() != r->top_at_mark_start(), \"region %u (%s) does not have TAMS set\",\n-                                                       r->hrm_index(), r->get_short_type_str());\n+      guarantee(r->bottom() != top_at_mark_start,\n+                \"region %u (%s) does not have TAMS set\",\n+                r->hrm_index(), r->get_short_type_str());\n@@ -478,1 +480,1 @@\n-      guarantee(r->bottom() == r->top_at_mark_start(),\n+      guarantee(r->bottom() == top_at_mark_start,\n@@ -480,1 +482,1 @@\n-                r->hrm_index(), r->get_short_type_str(), p2i(r->bottom()), p2i(r->top_at_mark_start()));\n+                r->hrm_index(), r->get_short_type_str(), p2i(r->bottom()), p2i(top_at_mark_start));\n@@ -545,1 +547,2 @@\n-      G1CMBitMap* bitmap = G1CollectedHeap::heap()->concurrent_mark()->mark_bitmap();\n+      G1ConcurrentMark* cm = G1CollectedHeap::heap()->concurrent_mark();\n+      G1CMBitMap* bitmap = cm->mark_bitmap();\n@@ -547,1 +550,1 @@\n-      HeapWord* start = _from_tams ? r->top_at_mark_start() : r->bottom();\n+      HeapWord* start = _from_tams ? cm->top_at_mark_start(r) : r->bottom();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapVerifier.cpp","additions":9,"deletions":6,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1136,1 +1136,1 @@\n-        hr->reset_top_at_mark_start();\n+        _g1h->concurrent_mark()->reset_top_at_mark_start(hr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"gc\/g1\/g1CollectedHeap.inline.hpp\"\n@@ -122,1 +123,1 @@\n-                                    p2i(r->top_at_mark_start()),\n+                                    p2i(cm->top_at_mark_start(r)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetTrackingPolicy.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -88,2 +88,2 @@\n-  HeapRegion* region = g1h->heap_region_containing(entry);\n-  if (entry >= region->top_at_mark_start()) {\n+  G1ConcurrentMark* cm = g1h->concurrent_mark();\n+  if (cm->obj_allocated_since_mark_start(cast_to_oop(entry))) {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SATBMarkQueueSet.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -548,3 +548,3 @@\n-      uint region = r->hrm_index();\n-      assert(r->top_at_mark_start() == r->bottom(), \"TAMS must not have been set for region %u\", region);\n-      assert(cm->live_bytes(region) == 0, \"Marking live bytes must not be set for region %u\", region);\n+      HeapWord* top_at_mark_start = cm->top_at_mark_start(r);\n+      assert(top_at_mark_start == r->bottom(), \"TAMS must not have been set for region %u\", r->hrm_index());\n+      assert(cm->live_bytes(r->hrm_index()) == 0, \"Marking live bytes must not be set for region %u\", r->hrm_index());\n@@ -553,1 +553,1 @@\n-      \/\/ regions wrt to marking), so we must clear their mark data (tams, bitmap)\n+      \/\/ regions wrt to marking), so we must clear their mark data (tams, bitmap, ...)\n@@ -562,1 +562,1 @@\n-        r->set_top_at_mark_start(r->top());\n+        cm->update_top_at_mark_start(r);\n@@ -564,1 +564,1 @@\n-        assert(cm->mark_bitmap()->get_next_marked_addr(r->bottom(), r->top_at_mark_start()) != r->top_at_mark_start(),\n+        assert(cm->mark_bitmap()->get_next_marked_addr(r->bottom(), cm->top_at_mark_start(r)) != cm->top_at_mark_start(r),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}