{"files":[{"patch":"@@ -0,0 +1,987 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/dynamicArchive.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"cds\/serializeClosure.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/metadataFactory.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/classpathStream.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/stringUtils.hpp\"\n+\n+#include <sys\/stat.h>\n+#include <errno.h>\n+\n+AOTCodeSourceConfig* AOTCodeSourceConfig::_dumptime_instance = nullptr;\n+const AOTCodeSourceConfig* AOTCodeSourceConfig::_runtime_instance = nullptr;\n+\n+\/\/ A CodeSourceStream represents a list of code sources, which can be iterated using\n+\/\/ start() and has_next().\n+class CodeSourceStream {\n+protected:\n+  GrowableArray<const char*> _array;\n+  int _current;\n+\n+  \/\/ Add one path to this stream.\n+  void add_one_path(const char* path) {\n+    _array.append(path);\n+  }\n+\n+  \/\/ Add all paths specified in cp; cp must be from -classpath or -Xbootclasspath\/a.\n+  void add_paths_in_classpath(const char* cp) {\n+    ClasspathStream cp_stream(cp);\n+    while (cp_stream.has_next()) {\n+      add_one_path(cp_stream.get_next());\n+    }\n+  }\n+\n+public:\n+  CodeSourceStream() : _array(), _current(0) {}\n+\n+  void print(outputStream* st) const {\n+    const char* sep = \"\";\n+    for (int i = 0; i < _array.length(); i++) {\n+      st->print(\"%s%s\", sep, _array.at(i));\n+      sep = os::path_separator();\n+    }\n+  }\n+\n+  void add(CodeSourceStream& css) {\n+    for (css.start(); css.has_next();) {\n+      add_one_path(css.get_next());\n+    }\n+  }\n+\n+  \/\/ Iteration\n+  void start() { _current = 0; }\n+  bool has_next() const { return _current < _array.length(); }\n+  const char* get_next() {\n+    return _array.at(_current++);\n+  }\n+\n+  int current() const { return _current; }\n+  bool is_empty() const { return _array.length() == 0; }\n+};\n+\n+class BootCpCodeSourceStream : public CodeSourceStream {\n+public:\n+  BootCpCodeSourceStream() : CodeSourceStream() {\n+    \/\/ Arguments::get_boot_class_path() contains $JAVA_HOME\/lib\/modules, but we treat that separately\n+    for (const char* bootcp = Arguments::get_boot_class_path(); *bootcp != '\\0'; ++bootcp) {\n+      if (*bootcp == *os::path_separator()) {\n+        ++ bootcp;\n+        add_paths_in_classpath(bootcp);\n+        break;\n+      }\n+    }\n+  }\n+};\n+\n+class AppCpCodeSourceStream : public CodeSourceStream {\n+public:\n+  AppCpCodeSourceStream() : CodeSourceStream() {\n+    const char* appcp = Arguments::get_appclasspath();\n+    if (strcmp(appcp, \".\") == 0) {\n+      appcp = \"\";\n+    }\n+    add_paths_in_classpath(appcp);\n+  }\n+};\n+\n+class ModulePathCodeSourceStream : public CodeSourceStream {\n+  bool _has_non_jar_modules;\n+public:\n+  ModulePathCodeSourceStream();\n+  bool has_non_jar_modules() { return _has_non_jar_modules; }\n+};\n+\n+\/\/ AllCodeSourceStreams is used to iterate over all the code sources that\n+\/\/ are available to the application from -Xbootclasspath, -classpath and --module-path\n+class AllCodeSourceStreams {\n+  BootCpCodeSourceStream _boot_cp;          \/\/ Specified by -Xbootclasspath\/a\n+  AppCpCodeSourceStream _app_cp;            \/\/ Specified by -classpath\n+  ModulePathCodeSourceStream _module_path;  \/\/ Specified by --module-path\n+  CodeSourceStream _boot_and_app_cp;        \/\/ Convenience for iterating over both _boot and _app\n+public:\n+  BootCpCodeSourceStream& boot_cp()             { return _boot_cp; }\n+  AppCpCodeSourceStream& app_cp()               { return _app_cp; }\n+  ModulePathCodeSourceStream& module_path()     { return _module_path; }\n+  CodeSourceStream& boot_and_app_cp()           { return _boot_and_app_cp; }\n+\n+  AllCodeSourceStreams() : _boot_cp(), _app_cp(), _module_path(), _boot_and_app_cp() {\n+    _boot_and_app_cp.add(_boot_cp);\n+    _boot_and_app_cp.add(_app_cp);\n+  }\n+};\n+\n+static bool has_jar_suffix(const char* filename) {\n+  \/\/ In jdk.internal.module.ModulePath.readModule(), it checks for the \".jar\" suffix.\n+  \/\/ Performing the same check here.\n+  const char* dot = strrchr(filename, '.');\n+  if (dot != nullptr && strcmp(dot + 1, \"jar\") == 0) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static int compare_module_path_by_name(const char** p1, const char** p2) {\n+  return strcmp(*p1, *p2);\n+}\n+\n+ModulePathCodeSourceStream::ModulePathCodeSourceStream() : CodeSourceStream(), _has_non_jar_modules(false) {\n+  \/\/ Note: for handling of --module-path, see\n+  \/\/   https:\/\/openjdk.org\/jeps\/261#Module-paths\n+  \/\/   https:\/\/docs.oracle.com\/en\/java\/javase\/23\/docs\/api\/java.base\/java\/lang\/module\/ModuleFinder.html#of(java.nio.file.Path...)\n+\n+  const char* jdk_module_path = Arguments::get_property(\"jdk.module.path\");\n+  if (jdk_module_path == nullptr) {\n+    return;\n+  }\n+\n+  ClasspathStream cp_stream(jdk_module_path);\n+  while (cp_stream.has_next()) {\n+    const char* path = cp_stream.get_next();\n+    DIR* dirp = os::opendir(path);\n+    if (dirp == nullptr && errno == ENOTDIR && has_jar_suffix(path)) {\n+      add_one_path(path);\n+    } else if (dirp != nullptr) {\n+      struct dirent* dentry;\n+      bool found_jar = false;\n+      while ((dentry = os::readdir(dirp)) != nullptr) {\n+        const char* file_name = dentry->d_name;\n+        if (has_jar_suffix(file_name)) {\n+          size_t full_name_len = strlen(path) + strlen(file_name) + strlen(os::file_separator()) + 1;\n+          char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n+          int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", path, os::file_separator(), file_name);\n+          assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n+          add_one_path(full_name);\n+          found_jar = true;\n+        } else if (strcmp(file_name, \".\") != 0 && strcmp(file_name, \"..\") != 0) {\n+          \/\/ Found some non jar entries\n+          _has_non_jar_modules = true;\n+          log_info(class, path)(\"Found non-jar path: '%s%s%s'\", path, os::file_separator(), file_name);\n+        }\n+      }\n+      if (!found_jar) {\n+        log_info(class, path)(\"Found exploded module path: '%s'\", path);\n+        _has_non_jar_modules = true;\n+      }\n+      os::closedir(dirp);\n+    } else {\n+      _has_non_jar_modules = true;\n+    }\n+  }\n+\n+  _array.sort(compare_module_path_by_name);\n+}\n+\n+AOTCodeSource* AOTCodeSource::allocate(JavaThread* current, const char* path, int index,\n+                                       Group group, bool from_cpattr, bool is_jrt) {\n+  size_t path_length = 0;\n+  size_t manifest_length = 0;\n+  bool check_time = false;\n+  time_t timestamp = 0;\n+  int64_t filesize = 0;\n+  FileType type = FileType::NORMAL;\n+  \/\/ Do not record the actual path of the jrt, as the entire JDK can be moved to a different\n+  \/\/ directory.\n+  const char* recorded_path = is_jrt ? \"\" : path;\n+  path_length = strlen(recorded_path);\n+\n+  struct stat st;\n+  if (os::stat(path, &st) == 0) {\n+    if ((st.st_mode & S_IFMT) == S_IFDIR) {\n+      type = FileType::DIR;\n+    } else {\n+      timestamp = st.st_mtime;\n+      filesize = st.st_size;\n+\n+      \/\/ The timestamp of $JAVA_HOME\/lib\/modules is not checked at runtime.\n+      check_time = !is_jrt;\n+    }\n+#ifdef _WINDOWS\n+  } else if (errno == ERROR_FILE_NOT_FOUND || errno == ERROR_PATH_NOT_FOUND) {\n+    \/\/ On Windows, the errno could be ERROR_PATH_NOT_FOUND (3) in case the directory\n+    \/\/ path doesn't exist.\n+    type = FileType::NOT_EXIST;\n+#endif\n+  } else if (errno == ENOENT) {\n+    \/\/ We allow the file to not exist, as long as it also doesn't exist during runtime.\n+    type = FileType::NOT_EXIST;\n+  } else {\n+    log_error(cds)(\"Unable to open file %s.\", path);\n+    MetaspaceShared::unrecoverable_loading_error();\n+  }\n+\n+  ResourceMark rm(current);\n+  char* manifest = nullptr;\n+\n+  if (!is_jrt && type == FileType::NORMAL) {\n+    manifest = read_manifest(current, path, manifest_length); \/\/ resource allocated\n+  }\n+\n+  size_t cs_size = header_size() +\n+    + path_length + 1 \/* nul-terminated *\/\n+    + manifest_length + 1; \/* nul-terminated *\/\n+\n+  AOTCodeSource* cs = (AOTCodeSource*)os::malloc(cs_size, mtClassShared);\n+  memset(cs, 0, cs_size);\n+  cs->_path_length = path_length;\n+  cs->_manifest_length = manifest_length;\n+  cs->_check_time = check_time;\n+  cs->_from_cpattr = from_cpattr;\n+  cs->_timestamp = timestamp;\n+  cs->_filesize = filesize;\n+  cs->_file_type = type;\n+  cs->_group = group;\n+  cs->_index = index;\n+\n+  strcpy(((char*)cs) + cs->path_offset(), recorded_path);\n+  if (manifest_length > 0) {\n+    memcpy(((char*)cs) + cs->manifest_offset(), manifest, manifest_length);\n+  }\n+  assert(*(cs->manifest() + cs->manifest_length()) == '\\0', \"should be nul-terminated\");\n+\n+  if (strstr(cs->manifest(), \"Multi-Release: true\") != nullptr) {\n+    cs->_is_multi_release_jar = true;\n+  }\n+\n+  if (strstr(cs->manifest(), \"Extension-List:\") != nullptr) {\n+    vm_exit_during_cds_dumping(err_msg(\"-Xshare:dump does not support Extension-List in JAR manifest: %s\", path));\n+  }\n+\n+  return cs;\n+}\n+\n+char* AOTCodeSource::read_manifest(JavaThread* current, const char* path, size_t& manifest_length) {\n+  manifest_length = 0;\n+\n+  struct stat st;\n+  if (os::stat(path, &st) != 0) {\n+    return nullptr;\n+  }\n+\n+  ClassPathEntry* cpe = ClassLoader::create_class_path_entry(current, path, &st);\n+  if (cpe == nullptr) {\n+    \/\/ <path> is a file, but not a JAR file\n+    return nullptr;\n+  }\n+  assert(cpe->is_jar_file(), \"should not be called with a directory\");\n+\n+  const char* name = \"META-INF\/MANIFEST.MF\";\n+  char* manifest;\n+  jint size;\n+  manifest = (char*) ((ClassPathZipEntry*)cpe)->open_entry(current, name, &size, true);\n+\n+  if (manifest == nullptr || size <= 0) { \/\/ No Manifest\n+    manifest_length = 0;\n+  } else {\n+    manifest_length = (size_t)size;\n+  }\n+\n+  delete cpe;\n+  return manifest;\n+}\n+\n+\/\/ The result is resource allocated.\n+char* AOTCodeSource::get_cpattr() const {\n+  if (_manifest_length == 0) {\n+    return nullptr;\n+  }\n+\n+  size_t buf_size = _manifest_length + 1;\n+  char* buf = NEW_RESOURCE_ARRAY(char, buf_size);\n+  memcpy(buf, manifest(), _manifest_length);\n+  buf[_manifest_length] = 0; \/\/ make sure it's 0-terminated\n+\n+  \/\/ See http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/jar\/jar.html#JAR%20Manifest\n+  \/\/ Replace all CR\/LF and CR with LF\n+  StringUtils::replace_no_expand(buf, \"\\r\\n\", \"\\n\");\n+  \/\/ Remove all new-line continuation (remove all \"\\n \" substrings)\n+  StringUtils::replace_no_expand(buf, \"\\n \", \"\");\n+\n+  const char* tag = \"Class-Path: \";\n+  size_t tag_len = strlen(tag);\n+  char* found = nullptr;\n+  char* line_start = buf;\n+  char* end = buf + _manifest_length;\n+\n+  assert(*end == 0, \"must be nul-terminated\");\n+\n+  while (line_start < end) {\n+    char* line_end = strchr(line_start, '\\n');\n+    if (line_end == nullptr) {\n+      \/\/ JAR spec require the manifest file to be terminated by a new line.\n+      break;\n+    }\n+    if (strncmp(tag, line_start, tag_len) == 0) {\n+      if (found != nullptr) {\n+        \/\/ Same behavior as jdk\/src\/share\/classes\/java\/util\/jar\/Attributes.java\n+        \/\/ If duplicated entries are found, the last one is used.\n+        log_warning(cds)(\"Warning: Duplicate name in Manifest: %s.\\n\"\n+                         \"Ensure that the manifest does not have duplicate entries, and\\n\"\n+                         \"that blank lines separate individual sections in both your\\n\"\n+                         \"manifest and in the META-INF\/MANIFEST.MF entry in the jar file:\\n%s\\n\", tag, path());\n+      }\n+      found = line_start + tag_len;\n+      assert(found <= line_end, \"sanity\");\n+      *line_end = '\\0';\n+    }\n+    line_start = line_end + 1;\n+  }\n+\n+  return found;\n+}\n+\n+AOTCodeSource* AOTCodeSource::write_to_archive() const {\n+  AOTCodeSource* archived_copy = (AOTCodeSource*)ArchiveBuilder::ro_region_alloc(total_size());\n+  memcpy((char*)archived_copy, (char*)this, total_size());\n+  return archived_copy;\n+}\n+\n+const char* AOTCodeSource::file_type_string() const {\n+  switch (_file_type) {\n+  case FileType::NORMAL: return \"file\";\n+  case FileType::DIR: return \"dir\";\n+  case FileType::NOT_EXIST: default: return \"not-exist\";\n+  }\n+}\n+\n+bool AOTCodeSource::check(const char* runtime_path, bool has_aot_linked_classes) const {\n+  struct stat st;\n+  if (os::stat(runtime_path, &st) != 0) {\n+    if (_file_type != FileType::NOT_EXIST) {\n+      log_warning(cds)(\"Required classpath entry does not exist: %s\", runtime_path);\n+      return false;\n+    }\n+  } else if ((st.st_mode & S_IFMT) == S_IFDIR) {\n+    if (_file_type == FileType::NOT_EXIST) {\n+      log_warning(cds)(\"'%s' must not exist\", runtime_path);\n+      return false;\n+    }\n+    if (_file_type == FileType::NORMAL) {\n+      log_warning(cds)(\"'%s' must be a file\", runtime_path);\n+      return false;\n+    }\n+    if (!os::dir_is_empty(runtime_path)) {\n+      log_warning(cds)(\"directory is not empty: '%s'\", runtime_path);\n+      return false;\n+    }\n+  } else {\n+    if (_file_type == FileType::NOT_EXIST) {\n+      log_warning(cds)(\"'%s' must not exist\", runtime_path);\n+      if (has_aot_linked_classes) {\n+        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n+                       \"file %s exists\", runtime_path);\n+        return false;\n+      } else {\n+        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n+                         \"file %s exists\", runtime_path);\n+        FileMapInfo::current_info()->set_has_platform_or_app_classes(false);\n+        if (DynamicArchive::is_mapped()) {\n+          FileMapInfo::dynamic_info()->set_has_platform_or_app_classes(false);\n+        }\n+      }\n+    }\n+    if (_file_type == FileType::DIR) {\n+      log_warning(cds)(\"'%s' must be a directory\", runtime_path);\n+      return false;\n+    }\n+    bool size_differs = _filesize != st.st_size;\n+    bool time_differs = _check_time && (_timestamp != st.st_mtime);\n+    if (size_differs || time_differs) {\n+      log_warning(cds)(\"This file is not the one used while building the shared archive file: '%s'%s%s\",\n+                       runtime_path,\n+                       time_differs ? \", timestamp has changed\" : \"\",\n+                       size_differs ? \", size has changed\" : \"\");\n+      return false;\n+    }\n+  }\n+\n+  log_info(class, path)(\"ok\");\n+  return true;\n+}\n+\n+void AOTCodeSourceConfig::dumptime_init(TRAPS) {\n+  assert(CDSConfig::is_dumping_archive(), \"\");\n+  _dumptime_instance = NEW_C_HEAP_OBJ(AOTCodeSourceConfig, mtClassShared);\n+  _dumptime_instance->dumptime_init_helper(CHECK);\n+}\n+\n+void AOTCodeSourceConfig::dumptime_init_helper(TRAPS) {\n+  ResourceMark rm;\n+  GrowableCodeSourceArray tmp_array;\n+  AllCodeSourceStreams all_css;\n+\n+  AOTCodeSource* jrt = AOTCodeSource::allocate(THREAD, ClassLoader::get_jrt_entry()->name(),\n+                                               0, Group::MODULES_IMAGE,\n+                                               \/*from_cpattr*\/false, \/*is_jrt*\/true);\n+  tmp_array.append(jrt);\n+\n+  parse(THREAD, tmp_array, all_css.boot_cp(), Group::BOOT_CLASSPATH, \/*parse_manifest*\/true);\n+  _boot_classpath_end = tmp_array.length();\n+\n+  parse(THREAD, tmp_array, all_css.app_cp(), Group::APP_CLASSPATH, \/*parse_manifest*\/true);\n+  _app_classpath_end = tmp_array.length();\n+\n+  parse(THREAD, tmp_array, all_css.module_path(), Group::MODULE_PATH, \/*parse_manifest*\/false);\n+  _module_end = tmp_array.length();\n+\n+  _code_sources =  MetadataFactory::new_array<AOTCodeSource*>(ClassLoaderData::the_null_class_loader_data(),\n+                                                               tmp_array.length(), CHECK);\n+  for (int i = 0; i < tmp_array.length(); i++) {\n+    _code_sources->at_put(i, tmp_array.at(i));\n+  }\n+\n+  const char* lcp = find_lcp(all_css.boot_and_app_cp(), _dumptime_lcp_len);\n+  if (_dumptime_lcp_len > 0) {\n+    os::free((void*)lcp);\n+    log_info(class, path)(\"Longest common prefix = %s (%zu chars)\", lcp, _dumptime_lcp_len);\n+  } else {\n+    assert(_dumptime_lcp_len == 0, \"sanity\");\n+    log_info(class, path)(\"Longest common prefix = <none> (0 chars)\");\n+  }\n+\n+  _has_non_jar_modules = all_css.module_path().has_non_jar_modules();\n+  _has_platform_classes = false;\n+  _has_app_classes = false;\n+  _max_used_index = 0;\n+}\n+\n+\/\/ Find the longest common prefix of two paths, up to max_lcp_len.\n+\/\/ E.g.   p1 = \"\/a\/b\/foo\"\n+\/\/        p2 = \"\/a\/b\/bar\"\n+\/\/        max_lcp_len = 3\n+\/\/ -> returns 3\n+static size_t find_lcp_of_two_paths(const char* p1, const char* p2, size_t max_lcp_len) {\n+  size_t lcp_len = 0;\n+  char sep = os::file_separator()[0];\n+  for (size_t i = 0; ; i++) {\n+    char c1 = *p1++;\n+    char c2 = *p2++;\n+    if (c1 == 0 || c2 == 0 || c1 != c2) {\n+      break;\n+    }\n+    if (c1 == sep) {\n+      lcp_len = i + 1;\n+      assert(lcp_len <= max_lcp_len, \"sanity\");\n+      if (lcp_len == max_lcp_len) {\n+        break;\n+      }\n+    }\n+  }\n+  return lcp_len;\n+}\n+\n+\/\/ cheap-allocated if lcp_len > 0\n+const char* AOTCodeSourceConfig::find_lcp(CodeSourceStream& css, size_t& lcp_len) {\n+  const char* first_path = nullptr;\n+  char sep = os::file_separator()[0];\n+\n+  for (css.start(); css.has_next(); ) {\n+    const char* path = css.get_next();\n+    if (first_path == nullptr) {\n+      first_path = path;\n+      const char* p = strrchr(first_path, sep);\n+      if (p == nullptr) {\n+        lcp_len = 0;\n+        return \"\";\n+      } else {\n+        lcp_len = p - first_path + 1;\n+      }\n+    } else {\n+      lcp_len = find_lcp_of_two_paths(first_path, path, lcp_len);\n+      if (lcp_len == 0) {\n+        return \"\";\n+      }\n+    }\n+  }\n+\n+  if (first_path != nullptr && lcp_len > 0) {\n+    char* lcp = NEW_C_HEAP_ARRAY(char, lcp_len + 1, mtClassShared);\n+    lcp[0] = 0;\n+    strncat(lcp, first_path, lcp_len);\n+    return lcp;\n+  } else {\n+    lcp_len = 0;\n+    return \"\";\n+  }\n+}\n+\n+void AOTCodeSourceConfig::parse(JavaThread* current, GrowableCodeSourceArray& tmp_array,\n+                                CodeSourceStream& css, Group group, bool parse_manifest) {\n+  for (css.start(); css.has_next(); ) {\n+    add_code_source(current, tmp_array, css.get_next(), group, parse_manifest, \/*from_cpattr*\/false);\n+  }\n+}\n+\n+void AOTCodeSourceConfig::add_code_source(JavaThread* current, GrowableCodeSourceArray& tmp_array,\n+                                          const char* path, Group group, bool parse_manifest, bool from_cpattr) {\n+  AOTCodeSource* cs = AOTCodeSource::allocate(current, path, tmp_array.length(), group, from_cpattr);\n+  tmp_array.append(cs);\n+\n+  if (!parse_manifest) {\n+    \/\/ parse_manifest is true for -classpath and -Xbootclasspath\/a, and false for --module-path.\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  char* cp_attr = cs->get_cpattr(); \/\/ resource allocated\n+  if (cp_attr != nullptr && strlen(cp_attr) > 0) {\n+    \/\/trace_class_path(\"found Class-Path: \", cp_attr); FIXME\n+\n+    char sep = os::file_separator()[0];\n+    const char* dir_name = cs->path();\n+    const char* dir_tail = strrchr(dir_name, sep);\n+#ifdef _WINDOWS\n+    \/\/ On Windows, we also support forward slash as the file separator when locating entries in the classpath entry.\n+    const char* dir_tail2 = strrchr(dir_name, '\/');\n+    if (dir_tail == nullptr) {\n+      dir_tail = dir_tail2;\n+    } else if (dir_tail2 != nullptr && dir_tail2 > dir_tail) {\n+      dir_tail = dir_tail2;\n+    }\n+#endif\n+    int dir_len;\n+    if (dir_tail == nullptr) {\n+      dir_len = 0;\n+    } else {\n+      dir_len = pointer_delta_as_int(dir_tail, dir_name) + 1;\n+    }\n+\n+    \/\/ Split the cp_attr by spaces, and add each file\n+    char* file_start = cp_attr;\n+    char* end = file_start + strlen(file_start);\n+\n+    while (file_start < end) {\n+      char* file_end = strchr(file_start, ' ');\n+      if (file_end != nullptr) {\n+        *file_end = 0;\n+        file_end += 1;\n+      } else {\n+        file_end = end;\n+      }\n+\n+      size_t name_len = strlen(file_start);\n+      if (name_len > 0) {\n+        ResourceMark rm(current);\n+        size_t libname_len = dir_len + name_len;\n+        char* libname = NEW_RESOURCE_ARRAY(char, libname_len + 1);\n+        int n = os::snprintf(libname, libname_len + 1, \"%.*s%s\", dir_len, dir_name, file_start);\n+        assert((size_t)n == libname_len, \"Unexpected number of characters in string\");\n+\n+        \/\/ Avoid infinite recursion when two JAR files refer to each\n+        \/\/ other via cpattr.\n+        bool found_duplicate = false;\n+        for (int i = boot_start(); i < tmp_array.length(); i++) {\n+          if (strcmp(tmp_array.at(i)->path(), libname) == 0) {\n+            found_duplicate = true;\n+            break;\n+          }\n+        }\n+        if (!found_duplicate) {\n+          add_code_source(current, tmp_array, libname, group, parse_manifest, \/*from_cpattr*\/true);\n+        }\n+      }\n+\n+      file_start = file_end;\n+    }\n+  }\n+}\n+\n+AOTCodeSource const* AOTCodeSourceConfig::code_source_at(int index) const {\n+  return _code_sources->at(index);\n+}\n+\n+int AOTCodeSourceConfig::get_module_shared_path_index(Symbol* location) const {\n+  if (location->starts_with(\"jrt:\", 4)) {\n+    assert(code_source_at(0)->is_modules_image(), \"sanity\");\n+    return 0;\n+  }\n+\n+  if (num_module_paths() == 0) {\n+    \/\/ The archive(s) were created without --module-path option\n+    return -1;\n+  }\n+\n+  if (!location->starts_with(\"file:\", 5)) {\n+    return -1;\n+  }\n+\n+  \/\/ skip_uri_protocol was also called during dump time -- see ClassLoaderExt::process_module_table()\n+  ResourceMark rm;\n+  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n+  for (int i = module_start(); i < module_end(); i++) {\n+    const AOTCodeSource* cs = code_source_at(i);\n+    assert(!cs->has_unnamed_module(), \"must be\");\n+    bool same = os::same_files(file, cs->path());\n+    log_debug(class, path)(\"get_module_shared_path_index (%d) %s : %s = %s\", i,\n+                           location->as_C_string(), cs->path(), same ? \"same\" : \"different\");\n+    if (same) {\n+      return i;\n+    }\n+  }\n+  return -1;\n+}\n+\n+\/\/ We allow non-empty dirs as long as no classes have been loaded from them.\n+void AOTCodeSourceConfig::check_nonempty_dirs() const {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+\n+  bool has_nonempty_dir = false;\n+  dumptime_iterate([&](AOTCodeSource* cs) {\n+    if (cs->index() > _max_used_index) {\n+      return false; \/\/ stop iterating\n+    }\n+    if (cs->is_dir()) {\n+      if (!os::dir_is_empty(cs->path())) {\n+        log_error(cds)(\"Error: non-empty directory '%s'\", cs->path());\n+        has_nonempty_dir = true;\n+      }\n+    }\n+    return true; \/\/ keep iterating\n+  });\n+\n+  if (has_nonempty_dir) {\n+    vm_exit_during_cds_dumping(\"Cannot have non-empty directory in paths\", nullptr);\n+  }\n+}\n+\n+AOTCodeSourceConfig* AOTCodeSourceConfig::write_to_archive() const {\n+  Array<AOTCodeSource*>* archived_copy = ArchiveBuilder::new_ro_array<AOTCodeSource*>(_code_sources->length());\n+  for (int i = 0; i < _code_sources->length(); i++) {\n+    archived_copy->at_put(i, _code_sources->at(i)->write_to_archive());\n+    ArchivePtrMarker::mark_pointer((address*)archived_copy->adr_at(i));\n+  }\n+\n+  AOTCodeSourceConfig* dumped = (AOTCodeSourceConfig*)ArchiveBuilder::ro_region_alloc(sizeof(AOTCodeSourceConfig));\n+  memcpy(dumped, this, sizeof(AOTCodeSourceConfig));\n+  dumped->_code_sources = archived_copy;\n+  ArchivePtrMarker::mark_pointer(&dumped->_code_sources);\n+\n+  return dumped;\n+}\n+\n+size_t AOTCodeSourceConfig::estimate_size_for_archive_helper() const {\n+  size_t size = ObjArrayKlass::header_size() * BytesPerWord;\n+  for (int i = 0; i < _code_sources->length(); i++) {\n+    size += _code_sources->at(i)->total_size();\n+  }\n+\n+  size = (size + 100) * 2;   \/\/ sanity\n+  return size;\n+}\n+\n+bool AOTCodeSourceConfig::check_classpaths(bool is_boot_classpath, bool has_aot_linked_classes,\n+                                           int index_start, int index_end,\n+                                           CodeSourceStream& runtime_css,\n+                                           bool use_lcp_match, const char* runtime_lcp,\n+                                           size_t runtime_lcp_len) const {\n+  if (index_start >= index_end && runtime_css.is_empty()) { \/\/ nothing to check\n+    return true;\n+  }\n+\n+  ResourceMark rm;\n+  const char* which = is_boot_classpath ? \"boot\" : \"app\";\n+  LogTarget(Info, class, path) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print(\"Checking %s classpath\", which);\n+    ls.print_cr(\"%s\", use_lcp_match ? \" (with longest common prefix substitution)\" : \"\");\n+    ls.print(\"- expected : '\");\n+    print_dumptime_classpath(ls, index_start, index_end, use_lcp_match, _dumptime_lcp_len, runtime_lcp, runtime_lcp_len);\n+    ls.print_cr(\"'\");\n+    ls.print(\"- actual   : '\");\n+    runtime_css.print(&ls);\n+    ls.print_cr(\"'\");\n+  }\n+\n+  runtime_css.start();\n+  for (int i = index_start; i < index_end; i++) {\n+    ResourceMark rm;\n+    const AOTCodeSource* cs = code_source_at(i);\n+    const char* effective_dumptime_path = cs->path();\n+    if (use_lcp_match) {\n+      effective_dumptime_path = substitute(effective_dumptime_path, _dumptime_lcp_len, runtime_lcp, runtime_lcp_len);\n+    }\n+\n+    log_info(class, path)(\"Checking '%s' %s%s\", effective_dumptime_path, cs->file_type_string(),\n+                          cs->from_cpattr() ? \" (from JAR manifest ClassPath attribute)\" : \"\");\n+    if (!cs->from_cpattr()) {\n+      if (!runtime_css.has_next()) {\n+        log_warning(cds)(\"%s classpath has fewer elements than expected\", which);\n+        return false;\n+      }\n+      const char* runtime_path = runtime_css.get_next();\n+      if (!os::same_files(effective_dumptime_path, runtime_path)) {\n+        log_warning(cds)(\"The name of %s classpath [%d] does not match: expected '%s', got '%s'\",\n+                         which, runtime_css.current(), effective_dumptime_path, runtime_path);\n+        return false;\n+      }\n+    }\n+\n+    if (!cs->check(effective_dumptime_path, has_aot_linked_classes)) {\n+      return false;\n+    }\n+  }\n+\n+  if (is_boot_classpath && runtime_css.has_next() && (need_to_check_app_classpath() || num_module_paths() > 0)) {\n+    if (check_paths_existence(runtime_css)) {\n+      log_warning(cds)(\"boot classpath is longer than expected\");\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+bool AOTCodeSourceConfig::check_paths_existence(CodeSourceStream& runtime_css) const {\n+  struct stat st;\n+  bool exist = false;\n+  runtime_css.start();\n+  while (runtime_css.has_next()) {\n+    const char* path = runtime_css.get_next();\n+    if (os::stat(path, &st) == 0 && st.st_size > 0) {\n+      exist = true;\n+      break;\n+    }\n+  }\n+  return exist;\n+}\n+\n+bool AOTCodeSourceConfig::check_module_paths(bool has_aot_linked_classes, int index_start, int index_end,\n+                                             CodeSourceStream& runtime_css,\n+                                             bool* has_extra_module_paths) const {\n+  if (index_start >= index_end && runtime_css.is_empty()) { \/\/ nothing to check\n+    return true;\n+  }\n+\n+  ResourceMark rm;\n+\n+  LogTarget(Info, class, path) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Checking module paths\");\n+    ls.print(\"- expected : '\");\n+    print_dumptime_classpath(ls, index_start, index_end, false, 0, nullptr, 0);\n+    ls.print_cr(\"'\");\n+    ls.print(\"- actual   : '\");\n+    runtime_css.print(&ls);\n+    ls.print_cr(\"'\");\n+  }\n+\n+  \/\/ Make sure all the dumptime module paths exist and are unchanged\n+  for (int i = index_start; i < index_end; i++) {\n+    const AOTCodeSource* cs = code_source_at(i);\n+    const char* dumptime_path = cs->path();\n+\n+    assert(!cs->from_cpattr(), \"not applicable for module path\");\n+    log_info(class, path)(\"Checking '%s' %s\", dumptime_path, cs->file_type_string());\n+\n+    if (!cs->check(dumptime_path, has_aot_linked_classes)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ We allow runtime_css to be a superset of the module paths specified in dumptime. E.g.,\n+  \/\/ Dumptime:    A:C\n+  \/\/ Runtime:     A:B:C\n+  runtime_css.start();\n+  for (int i = index_start; i < index_end; i++) {\n+    const AOTCodeSource* cs = code_source_at(i);\n+    const char* dumptime_path = cs->path();\n+\n+    while (true) {\n+      if (!runtime_css.has_next()) {\n+        log_warning(cds)(\"module path has fewer elements than expected\");\n+        *has_extra_module_paths = true;\n+        return true;\n+      }\n+      \/\/ Both this->code_sources() and runtime_css are alphabetically sorted. Skip\n+      \/\/ items in runtime_css until we see dumptime_path.\n+      const char* runtime_path = runtime_css.get_next();\n+      if (!os::same_files(dumptime_path, runtime_path)) {\n+        *has_extra_module_paths = true;\n+        return true;\n+      } else {\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (runtime_css.has_next()) {\n+    *has_extra_module_paths = true;\n+  }\n+\n+  return true;\n+}\n+\n+void AOTCodeSourceConfig::print_dumptime_classpath(LogStream& ls, int index_start, int index_end,\n+                                                   bool do_substitute, size_t remove_prefix_len,\n+                                                   const char* prepend, size_t prepend_len) const {\n+  const char* sep = \"\";\n+  for (int i = index_start; i < index_end; i++) {\n+    ResourceMark rm;\n+    const AOTCodeSource* cs = code_source_at(i);\n+    const char* path = cs->path();\n+    if (!cs->from_cpattr()) {\n+      ls.print(\"%s\", sep);\n+      if (do_substitute) {\n+        path = substitute(path, remove_prefix_len, prepend, prepend_len);\n+      }\n+      ls.print(\"%s\", path);\n+      sep = os::path_separator();\n+    }\n+  }\n+}\n+\n+\/\/ Returned path is resource-allocated\n+const char* AOTCodeSourceConfig::substitute(const char* path,         \/\/ start with this path (which was recorded from dump time)\n+                                            size_t remove_prefix_len, \/\/ remove this number of chars from the beginning\n+                                            const char* prepend,      \/\/ prepend this string\n+                                            size_t prepend_len) {     \/\/ length of the prepended string\n+  size_t len = strlen(path);\n+  assert(len > remove_prefix_len, \"sanity\");\n+  assert(prepend_len == strlen(prepend), \"sanity\");\n+  len -= remove_prefix_len;\n+  len += prepend_len;\n+\n+  char* buf = NEW_RESOURCE_ARRAY(char, len + 1);\n+  int n = os::snprintf(buf, len + 1, \"%s%s\", prepend, path + remove_prefix_len);\n+  assert(size_t(n) == len, \"sanity\");\n+\n+  return buf;\n+}\n+\n+\/\/ For performance, we avoid using LCP match if there's at least one\n+\/\/ CodeSource can be matched exactly: this means all other CodeSources must be\n+\/\/ matched exactly.\n+bool AOTCodeSourceConfig::need_lcp_match(AllCodeSourceStreams& all_css) const {\n+  if (!need_lcp_match_helper(boot_start(), boot_end(), all_css.boot_cp()) ||\n+      !need_lcp_match_helper(app_start(), app_end(), all_css.app_cp())) {\n+    return false;\n+  } else {\n+    return true;\n+  }\n+}\n+\n+bool AOTCodeSourceConfig::need_lcp_match_helper(int start, int end, CodeSourceStream& css) const {\n+  if (app_end() == boot_start()) {\n+    \/\/ No need to use lcp-match when there are no boot\/app paths.\n+    \/\/ TODO: LCP-match not yet supported for modules.\n+    return false;\n+  }\n+\n+  int i = start;\n+  for (css.start(); i < end && css.has_next(); ) {\n+    const AOTCodeSource* cs = code_source_at(i++);\n+    const char* runtime_path = css.get_next();\n+    if (cs->must_exist() && os::same_files(cs->path(), runtime_path)) {\n+      \/\/ Most likely, we will come to here at the first iteration.\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool AOTCodeSourceConfig::validate(bool has_aot_linked_classes, bool* has_extra_module_paths) const {\n+  ResourceMark rm;\n+  AllCodeSourceStreams all_css;\n+\n+  const char* jrt = ClassLoader::get_jrt_entry()->name();\n+  bool success = code_source_at(0)->check(jrt, has_aot_linked_classes);\n+  log_info(class, path)(\"Modules image %s validation: %s\", jrt, success ? \"passed\" : \"failed\");\n+  if (!success) {\n+    return false;\n+  }\n+  if (code_sources()->length() == 1) {\n+    if ((module_start() >= module_end()) && Arguments::get_property(\"jdk.module.path\") != nullptr) {\n+      *has_extra_module_paths = true;\n+    } else {\n+      *has_extra_module_paths = false;\n+    }\n+  } else {\n+    bool use_lcp_match = need_lcp_match(all_css);\n+    const char* runtime_lcp;\n+    size_t runtime_lcp_len;\n+\n+    log_info(class, path)(\"Longest common prefix substitution in boot\/app classpath matching: %s\",\n+                          use_lcp_match ? \"yes\" : \"no\");\n+    if (use_lcp_match) {\n+      runtime_lcp = find_lcp(all_css.boot_and_app_cp(), runtime_lcp_len);\n+      log_info(class, path)(\"Longest common prefix: %s (%zu chars)\", runtime_lcp, runtime_lcp_len);\n+    } else {\n+      runtime_lcp = nullptr;\n+      runtime_lcp_len = 0;\n+    }\n+\n+    success = check_classpaths(true, has_aot_linked_classes, boot_start(), boot_end(), all_css.boot_cp(),\n+                               use_lcp_match, runtime_lcp, runtime_lcp_len);\n+    log_info(class, path)(\"Archived boot classpath validation: %s\", success ? \"passed\" : \"failed\");\n+\n+    if (success && need_to_check_app_classpath()) {\n+      success = check_classpaths(false, has_aot_linked_classes, app_start(), app_end(), all_css.app_cp(),\n+                                 use_lcp_match, runtime_lcp, runtime_lcp_len);\n+      log_info(class, path)(\"Archived app classpath validation: %s\", success ? \"passed\" : \"failed\");\n+    }\n+\n+    if (success) {\n+      success = check_module_paths(has_aot_linked_classes, module_start(), module_end(), all_css.module_path(), has_extra_module_paths);\n+      log_info(class, path)(\"Archived module path validation: %s%s\", success ? \"passed\" : \"failed\",\n+                            (*has_extra_module_paths) ? \" (extra module paths found)\" : \"\");\n+    }\n+\n+    if (runtime_lcp_len > 0) {\n+      os::free((void*)runtime_lcp);\n+    }\n+  }\n+\n+  if (success) {\n+    _runtime_instance = this;\n+  } else {\n+    const char* mismatch_msg = \"shared class paths mismatch\";\n+    const char* hint_msg = log_is_enabled(Info, class, path) ?\n+        \"\" : \" (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n+    if (RequireSharedSpaces && !PrintSharedArchiveAndExit) {\n+      log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n+      MetaspaceShared::unrecoverable_loading_error();\n+    } else {\n+      log_warning(cds)(\"%s%s\", mismatch_msg, hint_msg);\n+    }\n+  }\n+  return success;\n+}\n","filename":"src\/hotspot\/share\/cds\/aotCodeSource.cpp","additions":987,"deletions":0,"binary":false,"changes":987,"status":"added"},{"patch":"@@ -0,0 +1,271 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCODESOURCE_HPP\n+#define SHARE_CDS_AOTCODESOURCE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class AllCodeSourceStreams;\n+class CodeSourceStream;\n+class LogStream;\n+\n+\/\/ An AOTCodeSource is a location where the application is configured to load Java classes\n+\/\/ from. It can be:\n+\/\/ - the location of $JAVA_HOME\/lib\/modules\n+\/\/ - an entry in -Xbootclasspath\/a\n+\/\/ - an entry in -classpath\n+\/\/ - a JAR file specified using --module-path.\n+\/\/\n+\/\/ AOTCodeSource is similar to java.security.CodeSource, except:\n+\/\/ - Only local files\/dirs are allowed. Directories must be empty. Network locations are not allowed.\n+\/\/ - No code signing information is recorded.\n+\/\/\n+\/\/ We avoid using pointers in AOTCodeSource to avoid runtime pointer relocation. Each AOTCodeSource\n+\/\/ is a variable-size structure:\n+\/\/    [ all fields specified below (sizeof(AOTCodeSource) bytes)          ]\n+\/\/    [ path (_path_length bytes, including the terminating zero)         ]\n+\/\/    [ manifest (_manifest_length bytes, including the terminating zero) ]\n+class AOTCodeSource {\n+public:\n+  enum class Group : int {\n+    MODULES_IMAGE,\n+    BOOT_CLASSPATH,\n+    APP_CLASSPATH,\n+    MODULE_PATH\n+  };\n+private:\n+  enum class FileType : int {\n+    NORMAL,\n+    DIR,\n+    NOT_EXIST\n+  };\n+  size_t   _path_length;     \/\/ does NOT include terminating zero\n+  size_t   _manifest_length; \/\/ does NOT include terminating zero\n+  bool     _check_time;\n+  bool     _from_cpattr;\n+  bool     _is_multi_release_jar; \/\/ is this a JAR file that has multi-release classes?\n+  FileType _file_type;\n+  Group    _group;\n+  int      _index; \/\/ index of this AOTCodeSource inside AOTCodeSourceConfig::_code_sources\n+  time_t   _timestamp;\n+  int64_t  _filesize;\n+\n+  static size_t header_size()      { return sizeof(AOTCodeSource); } \/\/ bytes\n+  size_t path_offset()       const { return header_size(); }\n+  size_t manifest_offset()   const { return path_offset() + _path_length + 1; }\n+  static char* read_manifest(JavaThread* current, const char* path, size_t& manifest_length);\n+\n+public:\n+  static AOTCodeSource* allocate(JavaThread* current, const char* path, int index, Group group,\n+                                 bool from_cpattr = false, bool is_jrt = false);\n+\n+  size_t total_size()                const { return manifest_offset() + _manifest_length + 1; }\n+  const char* path()                 const { return ((const char*)this) + path_offset();  }\n+  size_t manifest_length()           const { return _manifest_length; }\n+  const char* manifest()             const { return ((const char*)this) + manifest_offset(); }\n+  bool must_exist()                  const { return _file_type != FileType::NOT_EXIST; }\n+  bool must_not_exist()              const { return _file_type == FileType::NOT_EXIST; }\n+  bool is_dir()                      const { return _file_type == FileType::DIR; }\n+  int index()                        const { return _index; }\n+  bool is_modules_image()            const { return _group == Group::MODULES_IMAGE; }\n+  bool from_boot_classpath()         const { return _group == Group::BOOT_CLASSPATH; }\n+  bool from_app_classpath()          const { return _group == Group::APP_CLASSPATH; }\n+  bool from_module_path()            const { return _group == Group::MODULE_PATH; }\n+  bool is_multi_release_jar()        const { return _is_multi_release_jar; }\n+\n+  \/\/ Only boot\/app classpaths can contain unnamed module\n+  bool has_unnamed_module()          const { return from_boot_classpath() || from_app_classpath(); }\n+\n+  char* get_cpattr() const;\n+  AOTCodeSource* write_to_archive() const;\n+\n+  \/\/ Returns true IFF this AOTCodeSource is discovered from the -classpath or -Xbootclasspath\/a by parsing the\n+  \/\/ \"Class-Path\" attribute of a JAR file.\n+  bool from_cpattr() const { return _from_cpattr; }\n+  const char* file_type_string() const;\n+  bool check(const char* runtime_path, bool has_aot_linked_classes) const;\n+};\n+\n+\/\/ AOTCodeSourceConfig\n+\/\/\n+\/\/ Keep track of the set of AOTCodeSources used when an AOTCache is created.\n+\/\/ To load the AOTCache in a production run, the JVM must be using a compatible set of\n+\/\/ AOTCodeSources (subject to checks in AOTCodeSourceConfig::validate(bool&).\n+\/\/\n+\/\/ In general, validation is performed on AOTCodeSources to ensure the code sources used\n+\/\/ during AOTCache creation is the same as when the AOTCache is used during runtime.\n+\/\/ Non-existent entries are recored during AOTCache creation. Those non-existent entries\n+\/\/ must not exist during runtime.\n+\/\/\n+\/\/ Some details on validation:\n+\/\/ - the boot classpath could be appended during runtime if there's no app classpath and\n+\/\/   module path specified when an AOTCache is created;\n+\/\/ - the app classpath could be appended during runtime;\n+\/\/ - the module path during runtime could be a superset of the one specified during AOTCache creation.\n+\n+class AOTCodeSourceConfig : public CHeapObj<mtClassShared> {\n+  using Group = AOTCodeSource::Group;\n+  using GrowableCodeSourceArray = GrowableArrayCHeap<AOTCodeSource*, mtClassShared>;\n+\n+  \/\/ Note: both of the following are non-null if we are dumping a dynamic archive.\n+  static AOTCodeSourceConfig* _dumptime_instance;\n+  static const AOTCodeSourceConfig* _runtime_instance;\n+\n+  Array<AOTCodeSource*>* _code_sources; \/\/ jrt -> -Xbootclasspath\/a -> -classpath -> --module_path\n+  int _boot_classpath_end;\n+  int _app_classpath_end;\n+  int _module_end;\n+  bool _has_non_jar_modules;\n+  bool _has_platform_classes;\n+  bool _has_app_classes;\n+  int  _max_used_index;\n+  size_t _dumptime_lcp_len;\n+\n+  \/\/ accessors\n+  Array<AOTCodeSource*>* code_sources() const { return _code_sources; }\n+\n+  void parse(JavaThread* current, GrowableCodeSourceArray& tmp_array, CodeSourceStream& css,\n+             Group group, bool parse_manifest);\n+  void add_code_source(JavaThread* current, GrowableCodeSourceArray& tmp_array, const char* path,\n+                       Group group, bool parse_manifest, bool from_cpattr);\n+  void dumptime_init_helper(TRAPS);\n+\n+  bool check_classpaths(bool is_boot_classpath, bool has_aot_linked_classes,\n+                        int index_start, int index_end, CodeSourceStream& runtime_css,\n+                        bool use_lcp_match, const char* runtime_lcp, size_t runtime_lcp_len) const;\n+  bool check_module_paths(bool has_aot_linked_classes, int index_start, int index_end, CodeSourceStream& runtime_css,\n+                          bool* has_extra_module_paths) const;\n+  bool check_paths_existence(CodeSourceStream& runtime_css) const;\n+\n+  static const char* substitute(const char* path, size_t remove_prefix_len,\n+                                const char* prepend, size_t prepend_len);\n+  static const char* find_lcp(CodeSourceStream& css, size_t& lcp_len);\n+  bool need_lcp_match(AllCodeSourceStreams& all_css) const;\n+  bool need_lcp_match_helper(int start, int end, CodeSourceStream& css) const;\n+\n+  template <typename FUNC> void dumptime_iterate_helper(FUNC func) const {\n+    assert(_code_sources != nullptr, \"sanity\");\n+    int n = _code_sources->length();\n+    for (int i = 0; i < n; i++) {\n+      if (!func(_code_sources->at(i))) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  template <typename FUNC> void iterate(FUNC func) const {\n+    int n = code_sources()->length();\n+    for (int i = 0; i < n; i++) {\n+      if (!func(code_sources()->at(i))) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  void check_nonempty_dirs() const;\n+  bool need_to_check_app_classpath() const {\n+    return (num_app_classpaths() > 0) && (_max_used_index >= app_start()) && has_platform_or_app_classes();\n+  }\n+  size_t estimate_size_for_archive_helper() const;\n+\n+  void print_dumptime_classpath(LogStream& ls, int index_start, int index_limit,\n+                                bool do_substitute, size_t remove_prefix_len,\n+                                const char* prepend, size_t prepend_len) const;\n+public:\n+  static AOTCodeSourceConfig* dumptime() {\n+    assert(_dumptime_instance != nullptr, \"can only be called when dumping an AOT cache\");\n+    return _dumptime_instance;\n+  }\n+\n+  static const AOTCodeSourceConfig* runtime() {\n+    assert(_runtime_instance != nullptr, \"can only be called when using an AOT cache\");\n+    return _runtime_instance;\n+  }\n+\n+  \/\/ Common accessors\n+  int boot_start()                       const { return 1; }\n+  int boot_end()                         const { return _boot_classpath_end; }\n+  int app_start()                        const { return boot_end(); }\n+  int app_end()                          const { return _app_classpath_end; }\n+  int module_start()                     const { return app_end(); }\n+  int module_end()                       const { return _module_end; }\n+  bool has_platform_or_app_classes()     const { return _has_app_classes || _has_platform_classes; }\n+  bool has_non_jar_modules()             const { return _has_non_jar_modules; }\n+  int num_boot_classpaths()              const { return boot_end()   - boot_start();   }\n+  int num_app_classpaths()               const { return app_end()    - app_start();    }\n+  int num_module_paths()                 const { return module_end() - module_start(); }\n+\n+  int length() const {\n+    return _code_sources->length();\n+  }\n+\n+  const AOTCodeSource* code_source_at(int index) const;\n+  int get_module_shared_path_index(Symbol* location) const;\n+\n+  \/\/ Functions used only during dumptime\n+  static void dumptime_init(TRAPS);\n+  static size_t estimate_size_for_archive() {\n+    return _dumptime_instance->estimate_size_for_archive_helper();\n+  }\n+  static void dumptime_set_has_app_classes() {\n+    _dumptime_instance->_has_app_classes = true;\n+  }\n+\n+  static void dumptime_set_has_platform_classes() {\n+    _dumptime_instance->_has_platform_classes = true;\n+  }\n+\n+  static void dumptime_update_max_used_index(int index) {\n+    if (_dumptime_instance == nullptr) {\n+      assert(index == 0, \"sanity\");\n+    } else if (_dumptime_instance->_max_used_index < index) {\n+      _dumptime_instance->_max_used_index = index;\n+    }\n+  }\n+\n+  static void dumptime_check_nonempty_dirs() {\n+    _dumptime_instance->check_nonempty_dirs();\n+  }\n+\n+  static bool dumptime_is_ready() {\n+    return _dumptime_instance != nullptr;\n+  }\n+  template <typename FUNC> static void dumptime_iterate(FUNC func) {\n+    _dumptime_instance->dumptime_iterate_helper(func);\n+  }\n+\n+  AOTCodeSourceConfig* write_to_archive() const;\n+\n+  \/\/ Functions used only during runtime\n+  bool validate(bool has_aot_linked_classes, bool* has_extra_module_paths) const;\n+};\n+\n+\n+#endif \/\/ SHARE_CDS_AOTCODESOURCE_HPP\n","filename":"src\/hotspot\/share\/cds\/aotCodeSource.hpp","additions":271,"deletions":0,"binary":false,"changes":271,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-#include \"cds\/filemap.hpp\"\n","filename":"src\/hotspot\/share\/cds\/archiveHeapLoader.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"cds\/filemap.hpp\"\n","filename":"src\/hotspot\/share\/cds\/cdsConfig.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,1 +40,0 @@\n-  { \"FileMapHeader::_common_app_classpath_prefix_size\",   offset_of(FileMapHeader, _common_app_classpath_prefix_size)   },\n","filename":"src\/hotspot\/share\/cds\/cdsConstants.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -52,1 +53,1 @@\n-  SharedClassPathEntry* ent = FileMapInfo::shared_path(index);\n+  const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(index);\n@@ -55,1 +56,1 @@\n-  if (ent->is_modules_image()) {\n+  if (cs->is_modules_image()) {\n@@ -66,3 +67,2 @@\n-    \/\/   Each of the 3 SystemDictionaryShared::_shared_xxx arrays has the same length\n-    \/\/   as the shared classpath table in the shared archive (see\n-    \/\/   FileMap::_shared_path_table in filemap.hpp for details).\n+    \/\/   Each of the 3 CDSProtectionDomain::_shared_xxx arrays has the same length\n+    \/\/   as the shared classpath table in the shared archive.\n@@ -72,1 +72,1 @@\n-    \/\/     index = k->shared_classpath_index():\n+    \/\/     index = k->shared_classpath_index();\n@@ -74,1 +74,1 @@\n-    \/\/   FileMap::_shared_path_table[index] identifies the JAR file that contains k.\n+    \/\/   AOTCodeSourceConfig::_runtime_instance->_array->at(index) identifies the JAR file that contains k.\n@@ -87,1 +87,1 @@\n-    \/\/   the corresponding SystemDictionaryShared::get_shared_xxx() function.\n+    \/\/   the corresponding CDSProtectionDomain::get_shared_xxx() function.\n@@ -90,1 +90,1 @@\n-    int index_offset = index - ClassLoaderExt::app_class_paths_start_index();\n+    int index_offset = index - AOTCodeSourceConfig::runtime()->app_start();\n@@ -181,2 +181,2 @@\n-    SharedClassPathEntry* ent = FileMapInfo::shared_path(shared_path_index);\n-    size_t size = (size_t)ent->manifest_size();\n+    const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(shared_path_index);\n+    size_t size = cs->manifest_length();\n@@ -188,1 +188,1 @@\n-    const char* src = ent->manifest();\n+    const char* src = cs->manifest();\n@@ -201,1 +201,1 @@\n-    const char* path = FileMapInfo::shared_path_name(shared_path_index);\n+    const char* path = AOTCodeSourceConfig::runtime()->code_source_at(shared_path_index)->path();\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -261,1 +261,0 @@\n-  case MetaspaceObj::SharedClassPathEntryType:\n","filename":"src\/hotspot\/share\/cds\/cppVtables.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -92,1 +93,1 @@\n-  void write_archive(char* serialized_data);\n+  void write_archive(char* serialized_data, AOTCodeSourceConfig* cs_config);\n@@ -141,0 +142,1 @@\n+    AOTCodeSourceConfig* cs_config;\n@@ -151,0 +153,1 @@\n+      cs_config = AOTCodeSourceConfig::dumptime()->write_to_archive();\n@@ -164,1 +167,1 @@\n-    write_archive(serialized_data);\n+    write_archive(serialized_data, cs_config);\n@@ -175,1 +178,0 @@\n-    FileMapInfo::metaspace_pointers_do(it);\n@@ -338,2 +340,2 @@\n-void DynamicArchiveBuilder::write_archive(char* serialized_data) {\n-  _header->set_shared_path_table(FileMapInfo::shared_path_table().table());\n+void DynamicArchiveBuilder::write_archive(char* serialized_data, AOTCodeSourceConfig* cs_config) {\n+  _header->set_code_source_config(cs_config);\n@@ -392,2 +394,1 @@\n-    FileMapInfo::check_nonempty_dir_in_shared_path_table();\n-\n+    AOTCodeSourceConfig::dumptime_check_nonempty_dirs();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -159,1 +160,0 @@\n-  size_t longest_common_prefix_size = 0;\n@@ -176,4 +176,0 @@\n-  ResourceMark rm;\n-  GrowableArray<const char*>* app_cp_array = create_dumptime_app_classpath_array();\n-  int len = app_cp_array->length();\n-  longest_common_prefix_size = longest_common_app_classpath_prefix_len(len, app_cp_array);\n@@ -186,2 +182,1 @@\n-                    base_archive_name_offset,\n-                    longest_common_prefix_size);\n+                    base_archive_name_offset);\n@@ -192,1 +187,1 @@\n-                             size_t base_archive_name_offset, size_t common_app_classpath_prefix_size) {\n+                             size_t base_archive_name_offset) {\n@@ -199,1 +194,0 @@\n-  set_common_app_classpath_prefix_size((unsigned int)common_app_classpath_prefix_size);\n@@ -239,5 +233,0 @@\n-  _app_class_paths_start_index = ClassLoaderExt::app_class_paths_start_index();\n-  _app_module_paths_start_index = ClassLoaderExt::app_module_paths_start_index();\n-  _max_used_path_index = ClassLoaderExt::max_used_path_index();\n-  _num_module_paths = ClassLoader::num_module_path_entries();\n-\n@@ -246,2 +235,1 @@\n-  _has_platform_or_app_classes = ClassLoaderExt::has_platform_or_app_classes();\n-  _has_non_jar_in_classpath = ClassLoaderExt::has_non_jar_in_classpath();\n+  _has_platform_or_app_classes = AOTCodeSourceConfig::dumptime()->has_platform_or_app_classes();\n@@ -251,4 +239,0 @@\n-\n-  if (!CDSConfig::is_dumping_dynamic_archive()) {\n-    set_shared_path_table(info->_shared_path_table);\n-  }\n@@ -271,1 +255,0 @@\n-  st->print_cr(\"- common_app_classpath_size:      \" UINT32_FORMAT, common_app_classpath_prefix_size());\n@@ -297,5 +280,1 @@\n-  st->print_cr(\"- shared_path_table_offset:       0x%zx\", _shared_path_table_offset);\n-  st->print_cr(\"- app_class_paths_start_index:    %d\", _app_class_paths_start_index);\n-  st->print_cr(\"- app_module_paths_start_index:   %d\", _app_module_paths_start_index);\n-  st->print_cr(\"- num_module_paths:               %d\", _num_module_paths);\n-  st->print_cr(\"- max_used_path_index:            %d\", _max_used_path_index);\n+  st->print_cr(\"- code_source_config_offset:      0x%zx\", _code_source_config_offset);\n@@ -305,1 +284,0 @@\n-  st->print_cr(\"- has_non_jar_in_classpath:       %d\", _has_non_jar_in_classpath);\n@@ -324,84 +302,1 @@\n-void SharedClassPathEntry::init_as_non_existent(const char* path, TRAPS) {\n-  _type = non_existent_entry;\n-  set_name(path, CHECK);\n-}\n-\n-void SharedClassPathEntry::init(bool is_modules_image,\n-                                bool is_module_path,\n-                                ClassPathEntry* cpe, TRAPS) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  _timestamp = 0;\n-  _filesize  = 0;\n-  _from_class_path_attr = false;\n-\n-  struct stat st;\n-  if (os::stat(cpe->name(), &st) == 0) {\n-    if ((st.st_mode & S_IFMT) == S_IFDIR) {\n-      _type = dir_entry;\n-    } else {\n-      \/\/ The timestamp of the modules_image is not checked at runtime.\n-      if (is_modules_image) {\n-        _type = modules_image_entry;\n-      } else {\n-        _type = jar_entry;\n-        _timestamp = st.st_mtime;\n-        _from_class_path_attr = cpe->from_class_path_attr();\n-        _is_multi_release = cpe->is_multi_release_jar();\n-      }\n-      _filesize = st.st_size;\n-      _is_module_path = is_module_path;\n-    }\n-  } else {\n-    \/\/ The file\/dir must exist, or it would not have been added\n-    \/\/ into ClassLoader::classpath_entry().\n-    \/\/\n-    \/\/ If we can't access a jar file in the boot path, then we can't\n-    \/\/ make assumptions about where classes get loaded from.\n-    log_error(cds)(\"Unable to open file %s.\", cpe->name());\n-    MetaspaceShared::unrecoverable_loading_error();\n-  }\n-\n-  \/\/ No need to save the name of the module file, as it will be computed at run time\n-  \/\/ to allow relocation of the JDK directory.\n-  const char* name = is_modules_image  ? \"\" : cpe->name();\n-  set_name(name, CHECK);\n-}\n-\n-void SharedClassPathEntry::set_name(const char* name, TRAPS) {\n-  size_t len = strlen(name) + 1;\n-  _name = MetadataFactory::new_array<char>(ClassLoaderData::the_null_class_loader_data(), (int)len, CHECK);\n-  strcpy(_name->data(), name);\n-}\n-\n-void SharedClassPathEntry::copy_from(SharedClassPathEntry* ent, ClassLoaderData* loader_data, TRAPS) {\n-  assert(ent != nullptr, \"sanity\");\n-  _type = ent->_type;\n-  _is_module_path = ent->_is_module_path;\n-  _timestamp = ent->_timestamp;\n-  _filesize = ent->_filesize;\n-  _from_class_path_attr = ent->_from_class_path_attr;\n-  set_name(ent->name(), CHECK);\n-\n-  if (ent->is_jar() && ent->manifest() != nullptr) {\n-    Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n-                                                    ent->manifest_size(),\n-                                                    CHECK);\n-    char* p = (char*)(buf->data());\n-    memcpy(p, ent->manifest(), ent->manifest_size());\n-    set_manifest(buf);\n-  }\n-}\n-\n-const char* SharedClassPathEntry::name() const {\n-  if (CDSConfig::is_using_archive() && is_modules_image()) {\n-    \/\/ In order to validate the runtime modules image file size against the archived\n-    \/\/ size information, we need to obtain the runtime modules image path. The recorded\n-    \/\/ dump time modules image path in the archive may be different from the runtime path\n-    \/\/ if the JDK image has beed moved after generating the archive.\n-    return ClassLoader::get_jrt_entry()->name();\n-  } else {\n-    return _name->data();\n-  }\n-}\n-\n-bool SharedClassPathEntry::validate(bool is_class_path) const {\n+bool FileMapInfo::validate_code_source() {\n@@ -410,122 +305,6 @@\n-  struct stat st;\n-  const char* name = this->name();\n-\n-  bool ok = true;\n-  log_info(class, path)(\"checking shared classpath entry: %s\", name);\n-  if (os::stat(name, &st) != 0 && is_class_path) {\n-    \/\/ If the archived module path entry does not exist at runtime, it is not fatal\n-    \/\/ (no need to invalid the shared archive) because the shared runtime visibility check\n-    \/\/ filters out any archived module classes that do not have a matching runtime\n-    \/\/ module path location.\n-    log_warning(cds)(\"Required classpath entry does not exist: %s\", name);\n-    ok = false;\n-  } else if (is_dir()) {\n-    if (!os::dir_is_empty(name)) {\n-      log_warning(cds)(\"directory is not empty: %s\", name);\n-      ok = false;\n-    }\n-  } else {\n-    bool size_differs = _filesize != st.st_size;\n-    bool time_differs = has_timestamp() && _timestamp != st.st_mtime;\n-    if (time_differs || size_differs) {\n-      ok = false;\n-      if (PrintSharedArchiveAndExit) {\n-        log_warning(cds)(time_differs ? \"Timestamp mismatch\" : \"File size mismatch\");\n-      } else {\n-        const char* bad_file_msg = \"This file is not the one used while building the shared archive file:\";\n-        log_warning(cds)(\"%s %s\", bad_file_msg, name);\n-        if (!log_is_enabled(Info, cds)) {\n-          log_warning(cds)(\"%s %s\", bad_file_msg, name);\n-        }\n-        if (time_differs) {\n-          log_warning(cds)(\"%s timestamp has changed.\", name);\n-        }\n-        if (size_differs) {\n-          log_warning(cds)(\"%s size has changed.\", name);\n-        }\n-      }\n-    }\n-  }\n-\n-  if (PrintSharedArchiveAndExit && !ok) {\n-    \/\/ If PrintSharedArchiveAndExit is enabled, don't report failure to the\n-    \/\/ caller. Please see above comments for more details.\n-    ok = true;\n-    MetaspaceShared::set_archive_loading_failed();\n-  }\n-  return ok;\n-}\n-\n-bool SharedClassPathEntry::check_non_existent() const {\n-  assert(_type == non_existent_entry, \"must be\");\n-  log_info(class, path)(\"should be non-existent: %s\", name());\n-  struct stat st;\n-  if (os::stat(name(), &st) != 0) {\n-    log_info(class, path)(\"ok\");\n-    return true; \/\/ file doesn't exist\n-  } else {\n-    return false;\n-  }\n-}\n-\n-void SharedClassPathEntry::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_name);\n-  it->push(&_manifest);\n-}\n-\n-void SharedPathTable::metaspace_pointers_do(MetaspaceClosure* it) {\n-  it->push(&_entries);\n-}\n-\n-void SharedPathTable::dumptime_init(ClassLoaderData* loader_data, TRAPS) {\n-  const int num_entries =\n-    ClassLoader::num_boot_classpath_entries() +\n-    ClassLoader::num_app_classpath_entries() +\n-    ClassLoader::num_module_path_entries() +\n-    FileMapInfo::num_non_existent_class_paths();\n-  _entries = MetadataFactory::new_array<SharedClassPathEntry*>(loader_data, num_entries, CHECK);\n-  for (int i = 0; i < num_entries; i++) {\n-    SharedClassPathEntry* ent =\n-      new (loader_data, SharedClassPathEntry::size(), MetaspaceObj::SharedClassPathEntryType, THREAD) SharedClassPathEntry;\n-    _entries->at_put(i, ent);\n-  }\n-}\n-\n-void FileMapInfo::allocate_shared_path_table(TRAPS) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-  ClassPathEntry* jrt = ClassLoader::get_jrt_entry();\n-\n-  assert(jrt != nullptr,\n-         \"No modular java runtime image present when allocating the CDS classpath entry table\");\n-\n-  _shared_path_table.dumptime_init(loader_data, CHECK);\n-\n-  \/\/ 1. boot class path\n-  int i = 0;\n-  i = add_shared_classpaths(i, \"boot\",   jrt, CHECK);\n-  i = add_shared_classpaths(i, \"app\",    ClassLoader::app_classpath_entries(), CHECK);\n-  i = add_shared_classpaths(i, \"module\", ClassLoader::module_path_entries(), CHECK);\n-\n-  for (int x = 0; x < num_non_existent_class_paths(); x++, i++) {\n-    const char* path = _non_existent_class_paths->at(x);\n-    shared_path(i)->init_as_non_existent(path, CHECK);\n-  }\n-\n-  assert(i == _shared_path_table.size(), \"number of shared path entry mismatch\");\n-}\n-\n-int FileMapInfo::add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS) {\n-  while (cpe != nullptr) {\n-    bool is_jrt = (cpe == ClassLoader::get_jrt_entry());\n-    bool is_module_path = i >= ClassLoaderExt::app_module_paths_start_index();\n-    const char* type = (is_jrt ? \"jrt\" : (cpe->is_jar_file() ? \"jar\" : \"dir\"));\n-    log_info(class, path)(\"add %s shared path (%s) %s\", which, type, cpe->name());\n-    SharedClassPathEntry* ent = shared_path(i);\n-    ent->init(is_jrt, is_module_path, cpe, CHECK_0);\n-    if (cpe->is_jar_file()) {\n-      update_jar_manifest(cpe, ent, CHECK_0);\n-    }\n-    if (is_jrt) {\n-      cpe = ClassLoader::get_next_boot_classpath_entry(cpe);\n+  AOTCodeSourceConfig* config = header()->code_source_config();\n+  bool has_extra_module_paths;\n+  if (!config->validate(header()->has_aot_linked_classes(), &has_extra_module_paths)) {\n+    if (PrintSharedArchiveAndExit) {\n+      MetaspaceShared::set_archive_loading_failed();\n+      return true;\n@@ -533,270 +312,0 @@\n-      cpe = cpe->next();\n-    }\n-    i++;\n-  }\n-\n-  return i;\n-}\n-\n-void FileMapInfo::check_nonempty_dir_in_shared_path_table() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  bool has_nonempty_dir = false;\n-\n-  int last = _shared_path_table.size() - 1;\n-  if (last > ClassLoaderExt::max_used_path_index()) {\n-     \/\/ no need to check any path beyond max_used_path_index\n-     last = ClassLoaderExt::max_used_path_index();\n-  }\n-\n-  for (int i = 0; i <= last; i++) {\n-    SharedClassPathEntry *e = shared_path(i);\n-    if (e->is_dir()) {\n-      const char* path = e->name();\n-      if (!os::dir_is_empty(path)) {\n-        log_error(cds)(\"Error: non-empty directory '%s'\", path);\n-        has_nonempty_dir = true;\n-      }\n-    }\n-  }\n-\n-  if (has_nonempty_dir) {\n-    ClassLoader::exit_with_path_failure(\"Cannot have non-empty directory in paths\", nullptr);\n-  }\n-}\n-\n-void FileMapInfo::record_non_existent_class_path_entry(const char* path) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  log_info(class, path)(\"non-existent Class-Path entry %s\", path);\n-  if (_non_existent_class_paths == nullptr) {\n-    _non_existent_class_paths = new (mtClass) GrowableArray<const char*>(10, mtClass);\n-  }\n-  _non_existent_class_paths->append(os::strdup(path));\n-}\n-\n-int FileMapInfo::num_non_existent_class_paths() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  if (_non_existent_class_paths != nullptr) {\n-    return _non_existent_class_paths->length();\n-  } else {\n-    return 0;\n-  }\n-}\n-\n-int FileMapInfo::get_module_shared_path_index(Symbol* location) {\n-  if (location->starts_with(\"jrt:\", 4) && get_number_of_shared_paths() > 0) {\n-    assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-    return 0;\n-  }\n-\n-  if (ClassLoaderExt::app_module_paths_start_index() >= get_number_of_shared_paths()) {\n-    \/\/ The archive(s) were created without --module-path option\n-    return -1;\n-  }\n-\n-  if (!location->starts_with(\"file:\", 5)) {\n-    return -1;\n-  }\n-\n-  \/\/ skip_uri_protocol was also called during dump time -- see ClassLoaderExt::process_module_table()\n-  ResourceMark rm;\n-  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n-  for (int i = ClassLoaderExt::app_module_paths_start_index(); i < get_number_of_shared_paths(); i++) {\n-    SharedClassPathEntry* ent = shared_path(i);\n-    if (!ent->is_non_existent()) {\n-      assert(ent->in_named_module(), \"must be\");\n-      bool cond = strcmp(file, ent->name()) == 0;\n-      log_debug(class, path)(\"get_module_shared_path_index (%d) %s : %s = %s\", i,\n-                             location->as_C_string(), ent->name(), cond ? \"same\" : \"different\");\n-      if (cond) {\n-        return i;\n-      }\n-    }\n-  }\n-\n-  return -1;\n-}\n-\n-class ManifestStream: public ResourceObj {\n-  private:\n-  u1*   _buffer_start; \/\/ Buffer bottom\n-  u1*   _buffer_end;   \/\/ Buffer top (one past last element)\n-  u1*   _current;      \/\/ Current buffer position\n-\n- public:\n-  \/\/ Constructor\n-  ManifestStream(u1* buffer, int length) : _buffer_start(buffer),\n-                                           _current(buffer) {\n-    _buffer_end = buffer + length;\n-  }\n-\n-  static bool is_attr(u1* attr, const char* name) {\n-    return strncmp((const char*)attr, name, strlen(name)) == 0;\n-  }\n-\n-  static char* copy_attr(u1* value, size_t len) {\n-    char* buf = NEW_RESOURCE_ARRAY(char, len + 1);\n-    strncpy(buf, (char*)value, len);\n-    buf[len] = 0;\n-    return buf;\n-  }\n-};\n-\n-void FileMapInfo::update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS) {\n-  ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();\n-  ResourceMark rm(THREAD);\n-  jint manifest_size;\n-\n-  assert(cpe->is_jar_file() && ent->is_jar(), \"the shared class path entry is not a JAR file\");\n-  char* manifest = ClassLoaderExt::read_manifest(THREAD, cpe, &manifest_size);\n-  if (manifest != nullptr) {\n-    ManifestStream* stream = new ManifestStream((u1*)manifest,\n-                                                manifest_size);\n-    \/\/ Copy the manifest into the shared archive\n-    manifest = ClassLoaderExt::read_raw_manifest(THREAD, cpe, &manifest_size);\n-    Array<u1>* buf = MetadataFactory::new_array<u1>(loader_data,\n-                                                    manifest_size,\n-                                                    CHECK);\n-    char* p = (char*)(buf->data());\n-    memcpy(p, manifest, manifest_size);\n-    ent->set_manifest(buf);\n-  }\n-}\n-\n-char* FileMapInfo::skip_first_path_entry(const char* path) {\n-  size_t path_sep_len = strlen(os::path_separator());\n-  char* p = strstr((char*)path, os::path_separator());\n-  if (p != nullptr) {\n-    debug_only( {\n-      size_t image_name_len = strlen(MODULES_IMAGE_NAME);\n-      assert(strncmp(p - image_name_len, MODULES_IMAGE_NAME, image_name_len) == 0,\n-             \"first entry must be the modules image\");\n-    } );\n-    p += path_sep_len;\n-  } else {\n-    debug_only( {\n-      assert(ClassLoader::string_ends_with(path, MODULES_IMAGE_NAME),\n-             \"first entry must be the modules image\");\n-    } );\n-  }\n-  return p;\n-}\n-\n-int FileMapInfo::num_paths(const char* path) {\n-  if (path == nullptr) {\n-    return 0;\n-  }\n-  int npaths = 1;\n-  char* p = (char*)path;\n-  while (p != nullptr) {\n-    char* prev = p;\n-    p = strstr((char*)p, os::path_separator());\n-    if (p != nullptr) {\n-      p++;\n-      \/\/ don't count empty path\n-      if ((p - prev) > 1) {\n-       npaths++;\n-      }\n-    }\n-  }\n-  return npaths;\n-}\n-\n-\/\/ Returns true if a path within the paths exists and has non-zero size.\n-bool FileMapInfo::check_paths_existence(const char* paths) {\n-  ClasspathStream cp_stream(paths);\n-  bool exist = false;\n-  struct stat st;\n-  while (cp_stream.has_next()) {\n-    const char* path = cp_stream.get_next();\n-    if (os::stat(path, &st) == 0 && st.st_size > 0) {\n-      exist = true;\n-      break;\n-    }\n-  }\n-  return exist;\n-}\n-\n-GrowableArray<const char*>* FileMapInfo::create_dumptime_app_classpath_array() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);\n-  ClassPathEntry* cpe = ClassLoader::app_classpath_entries();\n-  while (cpe != nullptr) {\n-    path_array->append(cpe->name());\n-    cpe = cpe->next();\n-  }\n-  return path_array;\n-}\n-\n-GrowableArray<const char*>* FileMapInfo::create_path_array(const char* paths) {\n-  GrowableArray<const char*>* path_array = new GrowableArray<const char*>(10);\n-  JavaThread* current = JavaThread::current();\n-  ClasspathStream cp_stream(paths);\n-  bool non_jar_in_cp = header()->has_non_jar_in_classpath();\n-  while (cp_stream.has_next()) {\n-    const char* path = cp_stream.get_next();\n-    if (!non_jar_in_cp) {\n-      struct stat st;\n-      if (os::stat(path, &st) == 0) {\n-        path_array->append(path);\n-      }\n-    } else {\n-      const char* canonical_path = ClassLoader::get_canonical_path(path, current);\n-      if (canonical_path != nullptr) {\n-        char* error_msg = nullptr;\n-        jzfile* zip = ClassLoader::open_zip_file(canonical_path, &error_msg, current);\n-        if (zip != nullptr && error_msg == nullptr) {\n-          path_array->append(path);\n-        }\n-      }\n-    }\n-  }\n-  return path_array;\n-}\n-\n-bool FileMapInfo::classpath_failure(const char* msg, const char* name) {\n-  ClassLoader::trace_class_path(msg, name);\n-  if (PrintSharedArchiveAndExit) {\n-    MetaspaceShared::set_archive_loading_failed();\n-  }\n-  return false;\n-}\n-\n-unsigned int FileMapInfo::longest_common_app_classpath_prefix_len(int num_paths,\n-                                                                  GrowableArray<const char*>* rp_array) {\n-  if (num_paths == 0) {\n-    return 0;\n-  }\n-  unsigned int pos;\n-  for (pos = 0; ; pos++) {\n-    for (int i = 0; i < num_paths; i++) {\n-      if (rp_array->at(i)[pos] != '\\0' && rp_array->at(i)[pos] == rp_array->at(0)[pos]) {\n-        continue;\n-      }\n-      \/\/ search backward for the pos before the file separator char\n-      while (pos > 0) {\n-        if (rp_array->at(0)[--pos] == *os::file_separator()) {\n-          return pos + 1;\n-        }\n-      }\n-      return 0;\n-    }\n-  }\n-  return 0;\n-}\n-\n-bool FileMapInfo::check_paths(int shared_path_start_idx, int num_paths, GrowableArray<const char*>* rp_array,\n-                              unsigned int dumptime_prefix_len, unsigned int runtime_prefix_len) {\n-  int i = 0;\n-  int j = shared_path_start_idx;\n-  while (i < num_paths) {\n-    while (shared_path(j)->from_class_path_attr()) {\n-      \/\/ shared_path(j) was expanded from the JAR file attribute \"Class-Path:\"\n-      \/\/ during dump time. It's not included in the -classpath VM argument.\n-      j++;\n-    }\n-    assert(strlen(shared_path(j)->name()) > (size_t)dumptime_prefix_len, \"sanity\");\n-    const char* dumptime_path = shared_path(j)->name() + dumptime_prefix_len;\n-    assert(strlen(rp_array->at(i)) > (size_t)runtime_prefix_len, \"sanity\");\n-    const char* runtime_path = rp_array->at(i)  + runtime_prefix_len;\n-    if (!os::same_files(dumptime_path, runtime_path)) {\n@@ -805,125 +314,0 @@\n-    i++;\n-    j++;\n-  }\n-  return true;\n-}\n-\n-bool FileMapInfo::validate_boot_class_paths() {\n-  \/\/\n-  \/\/ - Archive contains boot classes only - relaxed boot path check:\n-  \/\/   Extra path elements appended to the boot path at runtime are allowed.\n-  \/\/\n-  \/\/ - Archive contains application or platform classes - strict boot path check:\n-  \/\/   Validate the entire runtime boot path, which must be compatible\n-  \/\/   with the dump time boot path. Appending boot path at runtime is not\n-  \/\/   allowed.\n-  \/\/\n-\n-  \/\/ The first entry in boot path is the modules_image (guaranteed by\n-  \/\/ ClassLoader::setup_boot_search_path()). Skip the first entry. The\n-  \/\/ path of the runtime modules_image may be different from the dump\n-  \/\/ time path (e.g. the JDK image is copied to a different location\n-  \/\/ after generating the shared archive), which is acceptable. For most\n-  \/\/ common cases, the dump time boot path might contain modules_image only.\n-  char* runtime_boot_path = Arguments::get_boot_class_path();\n-  char* rp = skip_first_path_entry(runtime_boot_path);\n-  assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-  int dp_len = header()->app_class_paths_start_index() - 1; \/\/ ignore the first path to the module image\n-  bool match = true;\n-\n-  bool relaxed_check = !header()->has_platform_or_app_classes();\n-  if (dp_len == 0 && rp == nullptr) {\n-    return true;   \/\/ ok, both runtime and dump time boot paths have modules_images only\n-  } else if (dp_len == 0 && rp != nullptr) {\n-    if (relaxed_check) {\n-      return true;   \/\/ ok, relaxed check, runtime has extra boot append path entries\n-    } else {\n-      ResourceMark rm;\n-      if (check_paths_existence(rp)) {\n-        \/\/ If a path exists in the runtime boot paths, it is considered a mismatch\n-        \/\/ since there's no boot path specified during dump time.\n-        match = false;\n-      }\n-    }\n-  } else if (dp_len > 0 && rp != nullptr) {\n-    int num;\n-    ResourceMark rm;\n-    GrowableArray<const char*>* rp_array = create_path_array(rp);\n-    int rp_len = rp_array->length();\n-    if (rp_len >= dp_len) {\n-      if (relaxed_check) {\n-        \/\/ only check the leading entries in the runtime boot path, up to\n-        \/\/ the length of the dump time boot path\n-        num = dp_len;\n-      } else {\n-        \/\/ check the full runtime boot path, must match with dump time\n-        num = rp_len;\n-      }\n-      match = check_paths(1, num, rp_array, 0, 0);\n-    } else {\n-      \/\/ create_path_array() ignores non-existing paths. Although the dump time and runtime boot classpath lengths\n-      \/\/ are the same initially, after the call to create_path_array(), the runtime boot classpath length could become\n-      \/\/ shorter. We consider boot classpath mismatch in this case.\n-      match = false;\n-    }\n-  }\n-\n-  if (!match) {\n-    \/\/ The paths are different\n-    return classpath_failure(\"[BOOT classpath mismatch, actual =\", runtime_boot_path);\n-  }\n-  return true;\n-}\n-\n-bool FileMapInfo::validate_app_class_paths(int shared_app_paths_len) {\n-  const char *appcp = Arguments::get_appclasspath();\n-  assert(appcp != nullptr, \"null app classpath\");\n-  int rp_len = num_paths(appcp);\n-  bool match = false;\n-  if (rp_len < shared_app_paths_len) {\n-    return classpath_failure(\"Run time APP classpath is shorter than the one at dump time: \", appcp);\n-  }\n-  if (shared_app_paths_len != 0 && rp_len != 0) {\n-    \/\/ Prefix is OK: E.g., dump with -cp foo.jar, but run with -cp foo.jar:bar.jar.\n-    ResourceMark rm;\n-    GrowableArray<const char*>* rp_array = create_path_array(appcp);\n-    if (rp_array->length() == 0) {\n-      \/\/ None of the jar file specified in the runtime -cp exists.\n-      return classpath_failure(\"None of the jar file specified in the runtime -cp exists: -Djava.class.path=\", appcp);\n-    }\n-    if (rp_array->length() < shared_app_paths_len) {\n-      \/\/ create_path_array() ignores non-existing paths. Although the dump time and runtime app classpath lengths\n-      \/\/ are the same initially, after the call to create_path_array(), the runtime app classpath length could become\n-      \/\/ shorter. We consider app classpath mismatch in this case.\n-      return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n-    }\n-\n-    \/\/ Handling of non-existent entries in the classpath: we eliminate all the non-existent\n-    \/\/ entries from both the dump time classpath (ClassLoader::update_class_path_entry_list)\n-    \/\/ and the runtime classpath (FileMapInfo::create_path_array), and check the remaining\n-    \/\/ entries. E.g.:\n-    \/\/\n-    \/\/ dump : -cp a.jar:NE1:NE2:b.jar  -> a.jar:b.jar -> recorded in archive.\n-    \/\/ run 1: -cp NE3:a.jar:NE4:b.jar  -> a.jar:b.jar -> matched\n-    \/\/ run 2: -cp x.jar:NE4:b.jar      -> x.jar:b.jar -> mismatched\n-\n-    int j = header()->app_class_paths_start_index();\n-    match = check_paths(j, shared_app_paths_len, rp_array, 0, 0);\n-    if (!match) {\n-      \/\/ To facilitate app deployment, we allow the JAR files to be moved *together* to\n-      \/\/ a different location, as long as they are still stored under the same directory\n-      \/\/ structure. E.g., the following is OK.\n-      \/\/     java -Xshare:dump -cp \/a\/Foo.jar:\/a\/b\/Bar.jar  ...\n-      \/\/     java -Xshare:auto -cp \/x\/y\/Foo.jar:\/x\/y\/b\/Bar.jar  ...\n-      unsigned int dumptime_prefix_len = header()->common_app_classpath_prefix_size();\n-      unsigned int runtime_prefix_len = longest_common_app_classpath_prefix_len(shared_app_paths_len, rp_array);\n-      if (dumptime_prefix_len != 0 || runtime_prefix_len != 0) {\n-        log_info(class, path)(\"LCP length for app classpath (dumptime: %u, runtime: %u)\",\n-                              dumptime_prefix_len, runtime_prefix_len);\n-        match = check_paths(j, shared_app_paths_len, rp_array,\n-                               dumptime_prefix_len, runtime_prefix_len);\n-      }\n-      if (!match) {\n-        return classpath_failure(\"[APP classpath mismatch, actual: -Djava.class.path=\", appcp);\n-      }\n-    }\n@@ -931,2 +315,0 @@\n-  return true;\n-}\n@@ -934,58 +316,1 @@\n-void FileMapInfo::log_paths(const char* msg, int start_idx, int end_idx) {\n-  LogTarget(Info, class, path) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"%s\", msg);\n-    const char* prefix = \"\";\n-    for (int i = start_idx; i < end_idx; i++) {\n-      ls.print(\"%s%s\", prefix, shared_path(i)->name());\n-      prefix = os::path_separator();\n-    }\n-    ls.cr();\n-  }\n-}\n-\n-void FileMapInfo::extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths) {\n-  GrowableArray<const char*>* path_array = create_path_array(runtime_path);\n-  int num_paths = path_array->length();\n-  for (int i = 0; i < num_paths; i++) {\n-    const char* name = path_array->at(i);\n-    ClassLoaderExt::extract_jar_files_from_path(name, module_paths);\n-  }\n-  \/\/ module paths are stored in sorted order in the CDS archive.\n-  module_paths->sort(ClassLoaderExt::compare_module_names);\n-}\n-\n-bool FileMapInfo::check_module_paths() {\n-  const char* runtime_path = Arguments::get_property(\"jdk.module.path\");\n-  int archived_num_module_paths = header()->num_module_paths();\n-  if (runtime_path == nullptr && archived_num_module_paths == 0) {\n-    return true;\n-  }\n-  if ((runtime_path == nullptr && archived_num_module_paths > 0) ||\n-      (runtime_path != nullptr && archived_num_module_paths == 0)) {\n-    return false;\n-  }\n-  ResourceMark rm;\n-  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(3);\n-  extract_module_paths(runtime_path, module_paths);\n-  int num_paths = module_paths->length();\n-  if (num_paths != archived_num_module_paths) {\n-    return false;\n-  }\n-  return check_paths(header()->app_module_paths_start_index(), num_paths, module_paths, 0, 0);\n-}\n-\n-bool FileMapInfo::validate_shared_path_table() {\n-  assert(CDSConfig::is_using_archive(), \"runtime only\");\n-\n-  _validating_shared_path_table = true;\n-\n-  \/\/ Load the shared path table info from the archive header\n-  _shared_path_table = header()->shared_path_table();\n-\n-  bool matched_module_paths = true;\n-  if (CDSConfig::is_dumping_dynamic_archive() || header()->has_full_module_graph()) {\n-    matched_module_paths = check_module_paths();\n-  }\n-  if (header()->has_full_module_graph() && !matched_module_paths) {\n+  if (header()->has_full_module_graph() && has_extra_module_paths) {\n@@ -993,1 +318,1 @@\n-    log_info(cds)(\"optimized module handling: disabled because of mismatched module paths\");\n+    log_info(cds)(\"optimized module handling: disabled because of extra module path(s) are specified\");\n@@ -1001,5 +326,1 @@\n-    \/\/\n-    \/\/ When dynamic archiving is enabled, the _shared_path_table is overwritten\n-    \/\/ to include the application path and stored in the top layer archive.\n-    assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-    if (header()->app_class_paths_start_index() > 1) {\n+    if (config->num_boot_classpaths() > 0) {\n@@ -1010,2 +331,2 @@\n-    if (header()->num_module_paths() > 0) {\n-      if (!matched_module_paths) {\n+    if (config->num_module_paths() > 0) {\n+      if (has_extra_module_paths) {\n@@ -1019,57 +340,0 @@\n-  log_paths(\"Expecting BOOT path=\", 0, header()->app_class_paths_start_index());\n-  log_paths(\"Expecting -Djava.class.path=\", header()->app_class_paths_start_index(), header()->app_module_paths_start_index());\n-\n-  int module_paths_start_index = header()->app_module_paths_start_index();\n-  int shared_app_paths_len = 0;\n-\n-  \/\/ validate the path entries up to the _max_used_path_index\n-  for (int i=0; i < header()->max_used_path_index() + 1; i++) {\n-    if (i < module_paths_start_index) {\n-      if (shared_path(i)->validate()) {\n-        \/\/ Only count the app class paths not from the \"Class-path\" attribute of a jar manifest.\n-        if (!shared_path(i)->from_class_path_attr() && i >= header()->app_class_paths_start_index()) {\n-          shared_app_paths_len++;\n-        }\n-        log_info(class, path)(\"ok\");\n-      } else {\n-        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n-          assert(!CDSConfig::is_using_archive(), \"UseSharedSpaces should be disabled\");\n-        }\n-        return false;\n-      }\n-    } else if (i >= module_paths_start_index) {\n-      if (shared_path(i)->validate(false \/* not a class path entry *\/)) {\n-        log_info(class, path)(\"ok\");\n-      } else {\n-        if (_dynamic_archive_info != nullptr && _dynamic_archive_info->_is_static) {\n-          assert(!CDSConfig::is_using_archive(), \"UseSharedSpaces should be disabled\");\n-        }\n-        return false;\n-      }\n-    }\n-  }\n-\n-  if (header()->max_used_path_index() == 0) {\n-    \/\/ default archive only contains the module image in the bootclasspath\n-    assert(shared_path(0)->is_modules_image(), \"first shared_path must be the modules image\");\n-  } else {\n-    if (!validate_boot_class_paths() || !validate_app_class_paths(shared_app_paths_len)) {\n-      const char* mismatch_msg = \"shared class paths mismatch\";\n-      const char* hint_msg = log_is_enabled(Info, class, path) ?\n-          \"\" : \" (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n-      if (RequireSharedSpaces) {\n-        log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n-        MetaspaceShared::unrecoverable_loading_error();\n-      } else {\n-        log_warning(cds)(\"%s%s\", mismatch_msg, hint_msg);\n-      }\n-      return false;\n-    }\n-  }\n-\n-  if (!validate_non_existent_class_paths()) {\n-    return false;\n-  }\n-\n-  _validating_shared_path_table = false;\n-\n@@ -1080,1 +344,1 @@\n-  size_t sz = sizeof(ClassPathEntry*) * get_number_of_shared_paths();\n+  size_t sz = sizeof(ClassPathEntry*) * AOTCodeSourceConfig::runtime()->length();\n@@ -1088,28 +352,0 @@\n-bool FileMapInfo::validate_non_existent_class_paths() {\n-  \/\/ All of the recorded non-existent paths came from the Class-Path: attribute from the JAR\n-  \/\/ files on the app classpath. If any of these are found to exist during runtime,\n-  \/\/ it will change how classes are loading for the app loader. For safety, disable\n-  \/\/ loading of archived platform\/app classes (currently there's no way to disable just the\n-  \/\/ app classes).\n-\n-  assert(CDSConfig::is_using_archive(), \"runtime only\");\n-  for (int i = header()->app_module_paths_start_index() + header()->num_module_paths();\n-       i < get_number_of_shared_paths();\n-       i++) {\n-    SharedClassPathEntry* ent = shared_path(i);\n-    if (!ent->check_non_existent()) {\n-      if (header()->has_aot_linked_classes()) {\n-        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n-                       \"file %s exists\", ent->name());\n-        return false;\n-      } else {\n-        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n-                         \"file %s exists\", ent->name());\n-        header()->set_has_platform_or_app_classes(false);\n-      }\n-    }\n-  }\n-\n-  return true;\n-}\n-\n@@ -1368,6 +604,0 @@\n-  int common_path_size = header()->common_app_classpath_prefix_size();\n-  if (common_path_size < 0) {\n-      log_warning(cds)(\"common app classpath prefix len < 0\");\n-      return false;\n-  }\n-\n@@ -1380,1 +610,0 @@\n-      log_info(cds)(\"common_app_classpath_size: \" UINT32_FORMAT, header()->common_app_classpath_prefix_size());\n@@ -2460,2 +1689,0 @@\n-SharedPathTable FileMapInfo::_shared_path_table;\n-bool FileMapInfo::_validating_shared_path_table = false;\n@@ -2463,1 +1690,0 @@\n-GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = nullptr;\n@@ -2472,1 +1698,1 @@\n-\/\/ [2] validate_shared_path_table - this is done later, because the table is in the RW\n+\/\/ [2] validate_shared_path_table - this is done later, because the table is in the RO\n@@ -2693,4 +1919,2 @@\n-    SharedClassPathEntry* scpe = shared_path(i);\n-    assert(scpe->is_jar(), \"must be\"); \/\/ other types of scpe will not produce archived classes\n-\n-    const char* path = scpe->name();\n+    const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(i);\n+    const char* path = cs->path();\n@@ -2703,1 +1927,1 @@\n-      ent = ClassLoader::create_class_path_entry(THREAD, path, &st, false, false, scpe->is_multi_release());\n+      ent = ClassLoader::create_class_path_entry(THREAD, path, &st);\n@@ -2727,1 +1951,1 @@\n-  assert(path_index < (int)get_number_of_shared_paths(), \"sanity\");\n+  assert(path_index < AOTCodeSourceConfig::runtime()->length(), \"sanity\");\n@@ -2737,0 +1961,1 @@\n+  const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(path_index);\n@@ -2738,1 +1963,4 @@\n-  if (class_loader() != nullptr && !cpe->is_modules_image() && cpe->is_multi_release_jar()) {\n+  if (class_loader() != nullptr && cs->is_multi_release_jar()) {\n+    \/\/ This class was loaded from a multi-release JAR file during dump time. The\n+    \/\/ process for finding its classfile is complex. Let's defer to the Java code\n+    \/\/ in java.lang.ClassLoader.\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":28,"deletions":800,"binary":false,"changes":828,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+class AOTCodeSourceConfig;\n@@ -54,83 +55,0 @@\n-class SharedClassPathEntry : public MetaspaceObj {\n-  enum {\n-    modules_image_entry,\n-    jar_entry,\n-    dir_entry,\n-    non_existent_entry,\n-    unknown_entry\n-  };\n-\n-  void set_name(const char* name, TRAPS);\n-\n-  u1     _type;\n-  bool   _is_module_path;\n-  bool   _from_class_path_attr;\n-  bool   _is_multi_release;\n-  time_t _timestamp;          \/\/ jar timestamp,  0 if is directory, modules image or other\n-  int64_t      _filesize;     \/\/ jar\/jimage file size, -1 if is directory, -2 if other\n-  Array<char>* _name;\n-  Array<u1>*   _manifest;\n-\n-public:\n-  SharedClassPathEntry() : _type(0), _is_module_path(false),\n-                           _from_class_path_attr(false), _is_multi_release(false), _timestamp(0),\n-                           _filesize(0), _name(nullptr), _manifest(nullptr) {}\n-  static int size() {\n-    static_assert(is_aligned(sizeof(SharedClassPathEntry), wordSize), \"must be\");\n-    return (int)(sizeof(SharedClassPathEntry) \/ wordSize);\n-  }\n-  void init(bool is_modules_image, bool is_module_path, ClassPathEntry* cpe, TRAPS);\n-  void init_as_non_existent(const char* path, TRAPS);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-  MetaspaceObj::Type type() const { return SharedClassPathEntryType; }\n-  bool validate(bool is_class_path = true) const;\n-\n-  \/\/ The _timestamp only gets set for jar files.\n-  bool has_timestamp() const {\n-    return _timestamp != 0;\n-  }\n-  bool is_dir()           const { return _type == dir_entry; }\n-  bool is_modules_image() const { return _type == modules_image_entry; }\n-  bool is_jar()           const { return _type == jar_entry; }\n-  bool is_non_existent()  const { return _type == non_existent_entry; }\n-  bool from_class_path_attr() { return _from_class_path_attr; }\n-  bool is_multi_release()     { return _is_multi_release; }\n-  time_t timestamp() const { return _timestamp; }\n-  const char* name() const;\n-  const char* manifest() const {\n-    return (_manifest == nullptr) ? nullptr : (const char*)_manifest->data();\n-  }\n-  int manifest_size() const {\n-    return (_manifest == nullptr) ? 0 : _manifest->length();\n-  }\n-  void set_manifest(Array<u1>* manifest) {\n-    _manifest = manifest;\n-  }\n-  bool check_non_existent() const;\n-  void copy_from(SharedClassPathEntry* ent, ClassLoaderData* loader_data, TRAPS);\n-  bool in_named_module() {\n-    return is_modules_image() || \/\/ modules image doesn't contain unnamed modules\n-           _is_module_path;      \/\/ module path doesn't contain unnamed modules\n-  }\n-};\n-\n-class SharedPathTable {\n-  Array<SharedClassPathEntry*>* _entries;\n-public:\n-  SharedPathTable() : _entries(nullptr) {}\n-  SharedPathTable(Array<SharedClassPathEntry*>* entries) : _entries(entries) {}\n-\n-  void dumptime_init(ClassLoaderData* loader_data, TRAPS);\n-  void metaspace_pointers_do(MetaspaceClosure* it);\n-\n-  int size() {\n-    return _entries == nullptr ? 0 : _entries->length();\n-  }\n-  SharedClassPathEntry* path_at(int index) {\n-    return _entries->at(index);\n-  }\n-  Array<SharedClassPathEntry*>* table() {return _entries;}\n-  void set_table(Array<SharedClassPathEntry*>* table) {_entries = table;}\n-};\n-\n-\n@@ -206,3 +124,0 @@\n-  bool _has_non_jar_in_classpath;                 \/\/ non-jar file entry exists in classpath\n-  unsigned int _common_app_classpath_prefix_size; \/\/ size of the common prefix of app class paths\n-                                                  \/\/    0 if no common prefix exists\n@@ -215,12 +130,2 @@\n-  \/\/ The following is a table of all the boot\/app\/module path entries that were used\n-  \/\/ during dumping. At run time, we validate these entries according to their\n-  \/\/ SharedClassPathEntry::_type. See:\n-  \/\/      check_nonempty_dir_in_shared_path_table()\n-  \/\/      validate_shared_path_table()\n-  \/\/      validate_non_existent_class_paths()\n-  size_t _shared_path_table_offset;\n-\n-  jshort _app_class_paths_start_index;  \/\/ Index of first app classpath entry\n-  jshort _app_module_paths_start_index; \/\/ Index of first module path entry\n-  jshort _max_used_path_index;          \/\/ max path index referenced during CDS dump\n-  int    _num_module_paths;             \/\/ number of module path entries\n+  size_t _code_source_config_offset;\n+\n@@ -229,1 +134,1 @@\n-  bool   _has_platform_or_app_classes;  \/\/ Archive contains app classes\n+  bool   _has_platform_or_app_classes;  \/\/ Archive contains app or platform classes\n@@ -244,2 +149,2 @@\n-  char* from_mapped_offset(size_t offset) const {\n-    return mapped_base_address() + offset;\n+  template <typename T> T from_mapped_offset(size_t offset) const {\n+    return (T)(mapped_base_address() + offset);\n@@ -248,0 +153,4 @@\n+  template <typename T> void set_as_offset(T p, size_t *offset) {\n+    set_as_offset((char*)p, offset);\n+  }\n+\n@@ -256,1 +165,0 @@\n-  unsigned int common_app_classpath_prefix_size() const { return _common_app_classpath_prefix_size;         }\n@@ -264,1 +172,0 @@\n-  void set_common_app_classpath_prefix_size(unsigned int s) { _common_app_classpath_prefix_size = s;         }\n@@ -275,3 +182,3 @@\n-  char* cloned_vtables()                   const { return from_mapped_offset(_cloned_vtables_offset); }\n-  char* early_serialized_data()            const { return from_mapped_offset(_early_serialized_data_offset); }\n-  char* serialized_data()                  const { return from_mapped_offset(_serialized_data_offset); }\n+  char* cloned_vtables()                   const { return from_mapped_offset<char*>(_cloned_vtables_offset); }\n+  char* early_serialized_data()            const { return from_mapped_offset<char*>(_early_serialized_data_offset); }\n+  char* serialized_data()                  const { return from_mapped_offset<char*>(_serialized_data_offset); }\n@@ -282,1 +189,0 @@\n-  bool has_non_jar_in_classpath()          const { return _has_non_jar_in_classpath; }\n@@ -294,5 +200,0 @@\n-  \/\/ FIXME: These should really return int\n-  jshort max_used_path_index()             const { return _max_used_path_index; }\n-  jshort app_module_paths_start_index()    const { return _app_module_paths_start_index; }\n-  jshort app_class_paths_start_index()     const { return _app_class_paths_start_index; }\n-  int    num_module_paths()                const { return _num_module_paths; }\n@@ -312,2 +213,6 @@\n-  void set_shared_path_table(SharedPathTable table) {\n-    set_as_offset((char*)table.table(), &_shared_path_table_offset);\n+  void set_code_source_config(AOTCodeSourceConfig* table) {\n+    set_as_offset(table, &_code_source_config_offset);\n+  }\n+\n+  AOTCodeSourceConfig* code_source_config() {\n+    return from_mapped_offset<AOTCodeSourceConfig*>(_code_source_config_offset);\n@@ -321,5 +226,0 @@\n-  SharedPathTable shared_path_table() const {\n-    return SharedPathTable((Array<SharedClassPathEntry*>*)\n-                           from_mapped_offset(_shared_path_table_offset));\n-  }\n-\n@@ -335,2 +235,1 @@\n-                size_t base_archive_name_size, size_t base_archive_name_offset,\n-                size_t common_app_classpath_size);\n+                size_t base_archive_name_size, size_t base_archive_name_offset);\n@@ -361,3 +260,0 @@\n-  static SharedPathTable       _shared_path_table;\n-  static bool                  _validating_shared_path_table;\n-\n@@ -372,1 +268,0 @@\n-  static GrowableArray<const char*>* _non_existent_class_paths;\n@@ -378,4 +273,0 @@\n-  static SharedPathTable shared_path_table() {\n-    return _shared_path_table;\n-  }\n-\n@@ -383,3 +274,0 @@\n-  static void metaspace_pointers_do(MetaspaceClosure* it) {\n-    _shared_path_table.metaspace_pointers_do(it);\n-  }\n@@ -411,2 +299,0 @@\n-  jshort app_module_paths_start_index()       const { return header()->app_module_paths_start_index(); }\n-  jshort app_class_paths_start_index()        const { return header()->app_class_paths_start_index(); }\n@@ -497,6 +383,1 @@\n-  static void allocate_shared_path_table(TRAPS);\n-  static int add_shared_classpaths(int i, const char* which, ClassPathEntry *cpe, TRAPS);\n-  static void check_nonempty_dir_in_shared_path_table();\n-  bool check_module_paths();\n-  bool validate_shared_path_table();\n-  bool validate_non_existent_class_paths();\n+  bool validate_code_source();\n@@ -504,6 +385,0 @@\n-  static void set_shared_path_table(FileMapInfo* info) {\n-    _shared_path_table = info->header()->shared_path_table();\n-  }\n-  static void update_jar_manifest(ClassPathEntry *cpe, SharedClassPathEntry* ent, TRAPS);\n-  static int num_non_existent_class_paths();\n-  static void record_non_existent_class_path_entry(const char* path);\n@@ -520,15 +395,0 @@\n-  static SharedClassPathEntry* shared_path(int index) {\n-    return _shared_path_table.path_at(index);\n-  }\n-\n-  static const char* shared_path_name(int index) {\n-    assert(index >= 0, \"Sanity\");\n-    return shared_path(index)->name();\n-  }\n-\n-  static int get_number_of_shared_paths() {\n-    return _shared_path_table.size();\n-  }\n-\n-  static int get_module_shared_path_index(Symbol* location) NOT_CDS_RETURN_(-1);\n-\n@@ -567,16 +427,0 @@\n-  char* skip_first_path_entry(const char* path) NOT_CDS_RETURN_(nullptr);\n-  int   num_paths(const char* path) NOT_CDS_RETURN_(0);\n-  bool  check_paths_existence(const char* paths) NOT_CDS_RETURN_(false);\n-  GrowableArray<const char*>* create_dumptime_app_classpath_array() NOT_CDS_RETURN_(nullptr);\n-  GrowableArray<const char*>* create_path_array(const char* path) NOT_CDS_RETURN_(nullptr);\n-  bool  classpath_failure(const char* msg, const char* name) NOT_CDS_RETURN_(false);\n-  unsigned int longest_common_app_classpath_prefix_len(int num_paths,\n-                                                       GrowableArray<const char*>* rp_array)\n-                                                       NOT_CDS_RETURN_(0);\n-  bool  check_paths(int shared_path_start_idx, int num_paths,\n-                    GrowableArray<const char*>* rp_array,\n-                    unsigned int dumptime_prefix_len,\n-                    unsigned int runtime_prefix_len) NOT_CDS_RETURN_(false);\n-  void  extract_module_paths(const char* runtime_path, GrowableArray<const char*>* module_paths);\n-  bool  validate_boot_class_paths() NOT_CDS_RETURN_(false);\n-  bool  validate_app_class_paths(int shared_app_paths_len) NOT_CDS_RETURN_(false);\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":21,"deletions":177,"binary":false,"changes":198,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -1178,1 +1179,1 @@\n-      ClassLoaderExt::num_module_paths() > 0) {\n+      AOTCodeSourceConfig::runtime()->num_module_paths() > 0) {\n@@ -1182,1 +1183,2 @@\n-                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()), ClassLoaderExt::num_module_paths());\n+                        BOOL_TO_STR(CDSConfig::is_using_optimized_module_handling()),\n+                        AOTCodeSourceConfig::runtime()->num_module_paths());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -333,1 +334,1 @@\n-    int size = FileMapInfo::get_number_of_shared_paths();\n+    int size = AOTCodeSourceConfig::runtime()->length();\n@@ -336,11 +337,0 @@\n-      if (!CDSConfig::is_dumping_dynamic_archive()) {\n-        FileMapInfo* info;\n-        if (FileMapInfo::dynamic_info() == nullptr) {\n-          info = FileMapInfo::current_info();\n-        } else {\n-          info = FileMapInfo::dynamic_info();\n-        }\n-        ClassLoaderExt::init_paths_start_index(info->app_class_paths_start_index());\n-        ClassLoaderExt::init_app_module_paths_start_index(info->app_module_paths_start_index());\n-        ClassLoaderExt::init_num_module_paths(info->header()->num_module_paths());\n-      }\n@@ -561,1 +551,1 @@\n-  char* dump_read_only_tables();\n+  char* dump_read_only_tables(AOTCodeSourceConfig*& cs_config);\n@@ -582,1 +572,0 @@\n-    FileMapInfo::metaspace_pointers_do(it);\n@@ -617,1 +606,1 @@\n-char* VM_PopulateDumpSharedSpace::dump_read_only_tables() {\n+char* VM_PopulateDumpSharedSpace::dump_read_only_tables(AOTCodeSourceConfig*& cs_config) {\n@@ -621,0 +610,1 @@\n+  cs_config = AOTCodeSourceConfig::dumptime()->write_to_archive();\n@@ -648,1 +638,1 @@\n-  FileMapInfo::check_nonempty_dir_in_shared_path_table();\n+  AOTCodeSourceConfig::dumptime_check_nonempty_dirs();\n@@ -682,1 +672,2 @@\n-  char* serialized_data = dump_read_only_tables();\n+  AOTCodeSourceConfig* cs_config;\n+  char* serialized_data = dump_read_only_tables(cs_config);\n@@ -698,0 +689,1 @@\n+  _map_info->header()->set_code_source_config(cs_config);\n@@ -794,1 +786,0 @@\n-  ClassLoader::initialize_shared_path(JavaThread::current());\n@@ -949,0 +940,1 @@\n+      ClassLoaderDataShared::ensure_module_entry_tables_exist();\n@@ -1143,1 +1135,0 @@\n-      FileMapInfo::set_shared_path_table(dynamic_mapinfo);\n@@ -1146,2 +1137,0 @@\n-    } else {\n-      FileMapInfo::set_shared_path_table(static_mapinfo);\n@@ -1650,1 +1639,1 @@\n-  if (!mapinfo->validate_shared_path_table()) {\n+  if (!mapinfo->validate_code_source()) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":11,"deletions":22,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/cdsConfig.hpp\"\n","filename":"src\/hotspot\/share\/cds\/unregisteredClasses.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -27,1 +28,0 @@\n-#include \"cds\/filemap.hpp\"\n@@ -161,6 +161,0 @@\n-#if INCLUDE_CDS\n-ClassPathEntry* ClassLoader::_app_classpath_entries = nullptr;\n-ClassPathEntry* ClassLoader::_last_app_classpath_entry = nullptr;\n-ClassPathEntry* ClassLoader::_module_path_entries = nullptr;\n-ClassPathEntry* ClassLoader::_last_module_path_entry = nullptr;\n-#endif\n@@ -304,2 +298,1 @@\n-ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name,\n-                                     bool is_boot_append, bool from_class_path_attr, bool multi_release) : ClassPathEntry() {\n+ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name) : ClassPathEntry() {\n@@ -308,2 +301,0 @@\n-  _from_class_path_attr = from_class_path_attr;\n-  _multi_release = multi_release;\n@@ -466,8 +457,0 @@\n-#if INCLUDE_CDS\n-void ClassLoader::exit_with_path_failure(const char* error, const char* message) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  tty->print_cr(\"Hint: enable -Xlog:class+path=info to diagnose the failure\");\n-  vm_exit_during_cds_dumping(error, message);\n-}\n-#endif\n-\n@@ -536,51 +519,0 @@\n-#if INCLUDE_CDS\n-void ClassLoader::setup_app_search_path(JavaThread* current, const char *class_path) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  ResourceMark rm(current);\n-  ClasspathStream cp_stream(class_path);\n-\n-  while (cp_stream.has_next()) {\n-    const char* path = cp_stream.get_next();\n-    update_class_path_entry_list(current, path, \/* check_for_duplicates *\/ true,\n-                                 \/* is_boot_append *\/ false, \/* from_class_path_attr *\/ false);\n-  }\n-}\n-\n-void ClassLoader::add_to_module_path_entries(const char* path,\n-                                             ClassPathEntry* entry) {\n-  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  \/\/ The entry does not exist, add to the list\n-  if (_module_path_entries == nullptr) {\n-    assert(_last_module_path_entry == nullptr, \"Sanity\");\n-    _module_path_entries = _last_module_path_entry = entry;\n-  } else {\n-    _last_module_path_entry->set_next(entry);\n-    _last_module_path_entry = entry;\n-  }\n-}\n-\n-\/\/ Add a module path to the _module_path_entries list.\n-void ClassLoader::setup_module_search_path(JavaThread* current, const char* path) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  struct stat st;\n-  if (os::stat(path, &st) != 0) {\n-    tty->print_cr(\"os::stat error %d (%s). CDS dump aborted (path was \\\"%s\\\").\",\n-      errno, os::errno_name(errno), path);\n-    vm_exit_during_initialization();\n-  }\n-  \/\/ File or directory found\n-  ClassPathEntry* new_entry = nullptr;\n-  new_entry = create_class_path_entry(current, path, &st,\n-                                      false \/*is_boot_append *\/, false \/* from_class_path_attr *\/);\n-  if (new_entry != nullptr) {\n-    \/\/ ClassLoaderExt::process_module_table() filters out non-jar entries before calling this function.\n-    assert(new_entry->is_jar_file(), \"module path entry %s is not a jar file\", new_entry->name());\n-    add_to_module_path_entries(path, new_entry);\n-  }\n-}\n-\n-#endif \/\/ INCLUDE_CDS\n-\n@@ -619,1 +551,1 @@\n-        ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n+        ClassPathEntry* new_entry = create_class_path_entry(current, path, &st);\n@@ -693,2 +625,1 @@\n-      update_class_path_entry_list(current, path, \/* check_for_duplicates *\/ false,\n-                                    \/* is_boot_append *\/ true, \/* from_class_path_attr *\/ false);\n+      update_class_path_entry_list(current, path);\n@@ -725,1 +656,1 @@\n-    ClassPathEntry* new_entry = create_class_path_entry(current, path, &st, false, false);\n+    ClassPathEntry* new_entry = create_class_path_entry(current, path, &st);\n@@ -751,4 +682,1 @@\n-                                                     const char *path, const struct stat* st,\n-                                                     bool is_boot_append,\n-                                                     bool from_class_path_attr,\n-                                                     bool is_multi_release) {\n+                                                     const char *path, const struct stat* st) {\n@@ -767,1 +695,1 @@\n-      new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr, is_multi_release);\n+      new_entry = new ClassPathZipEntry(zip, path);\n@@ -769,3 +697,0 @@\n-#if INCLUDE_CDS\n-      ClassLoaderExt::set_has_non_jar_in_classpath();\n-#endif\n@@ -787,1 +712,1 @@\n-ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {\n+ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path) {\n@@ -800,1 +725,1 @@\n-          return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false, false);\n+          return new ClassPathZipEntry(zip, canonical_path);\n@@ -823,39 +748,0 @@\n-\/\/ Record the path entries specified in -cp during dump time. The recorded\n-\/\/ information will be used at runtime for loading the archived app classes.\n-\/\/\n-\/\/ Note that at dump time, ClassLoader::_app_classpath_entries are NOT used for\n-\/\/ loading app classes. Instead, the app class are loaded by the\n-\/\/ jdk\/internal\/loader\/ClassLoaders$AppClassLoader instance.\n-bool ClassLoader::add_to_app_classpath_entries(JavaThread* current,\n-                                               ClassPathEntry* entry,\n-                                               bool check_for_duplicates) {\n-#if INCLUDE_CDS\n-  assert(entry != nullptr, \"ClassPathEntry should not be nullptr\");\n-  ClassPathEntry* e = _app_classpath_entries;\n-  if (check_for_duplicates) {\n-    while (e != nullptr) {\n-      if (strcmp(e->name(), entry->name()) == 0 &&\n-          e->from_class_path_attr() == entry->from_class_path_attr()) {\n-        \/\/ entry already exists\n-        return false;\n-      }\n-      e = e->next();\n-    }\n-  }\n-\n-  \/\/ The entry does not exist, add to the list\n-  if (_app_classpath_entries == nullptr) {\n-    assert(_last_app_classpath_entry == nullptr, \"Sanity\");\n-    _app_classpath_entries = _last_app_classpath_entry = entry;\n-  } else {\n-    _last_app_classpath_entry->set_next(entry);\n-    _last_app_classpath_entry = entry;\n-  }\n-\n-  if (entry->is_jar_file()) {\n-    ClassLoaderExt::process_jar_manifest(current, entry);\n-  }\n-#endif\n-  return true;\n-}\n-\n@@ -863,5 +749,1 @@\n-bool ClassLoader::update_class_path_entry_list(JavaThread* current,\n-                                               const char *path,\n-                                               bool check_for_duplicates,\n-                                               bool is_boot_append,\n-                                               bool from_class_path_attr) {\n+bool ClassLoader::update_class_path_entry_list(JavaThread* current, const char *path) {\n@@ -872,1 +754,1 @@\n-    new_entry = create_class_path_entry(current, path, &st, is_boot_append, from_class_path_attr);\n+    new_entry = create_class_path_entry(current, path, &st);\n@@ -879,8 +761,1 @@\n-    if (is_boot_append) {\n-      add_to_boot_append_entries(new_entry);\n-    } else {\n-      if (!add_to_app_classpath_entries(current, new_entry, check_for_duplicates)) {\n-        \/\/ new_entry is not saved, free it now\n-        delete new_entry;\n-      }\n-    }\n+    add_to_boot_append_entries(new_entry);\n@@ -1321,1 +1196,7 @@\n-  if (FileMapInfo::get_number_of_shared_paths() > 0) {\n+  if (!AOTCodeSourceConfig::dumptime_is_ready()) {\n+    \/\/ The shared path table is set up after module system initialization.\n+    \/\/ The path table contains no entry before that. Any classes loaded prior\n+    \/\/ to the setup of the shared path table must be from the modules image.\n+    assert(stream->from_boot_loader_modules_image(), \"stream must be loaded by boot loader from modules image\");\n+    classpath_index = 0;\n+  } else {\n@@ -1327,11 +1208,13 @@\n-    for (int i = 0; i < FileMapInfo::get_number_of_shared_paths(); i++) {\n-      SharedClassPathEntry* ent = FileMapInfo::shared_path(i);\n-      \/\/ A shared path has been validated during its creation in ClassLoader::create_class_path_entry(),\n-      \/\/ it must be valid here.\n-      assert(ent->name() != nullptr, \"sanity\");\n-      \/\/ If the path (from the class stream source) is the same as the shared\n-      \/\/ class or module path, then we have a match.\n-      \/\/ src may come from the App\/Platform class loaders, which would canonicalize\n-      \/\/ the file name. We cannot use strcmp to check for equality against ent->name().\n-      \/\/ We must use os::same_files (which is faster than canonicalizing ent->name()).\n-      if (os::same_files(ent->name(), path)) {\n+    AOTCodeSourceConfig::dumptime_iterate([&] (AOTCodeSource* cs) {\n+      int i = cs->index();\n+      \/\/ for index 0 and the stream->source() is the modules image or has the jrt: protocol.\n+      \/\/ The class must be from the runtime modules image.\n+      if (cs->is_modules_image() && (stream->from_boot_loader_modules_image() || string_starts_with(src, \"jrt:\"))) {\n+        classpath_index = i;\n+      } else if (os::same_files(cs->path(), path)) {\n+        \/\/ If the path (from the class stream source) is the same as the shared\n+        \/\/ class or module path, then we have a match.\n+        \/\/ src may come from the App\/Platform class loaders, which would canonicalize\n+        \/\/ the file name. We cannot use strcmp to check for equality against cs->path().\n+        \/\/ We must use os::same_files (which is faster than canonicalizing cs->path()).\n+\n@@ -1344,3 +1227,1 @@\n-          if (SystemDictionary::is_system_class_loader(loader) &&\n-              (i >= ClassLoaderExt::app_class_paths_start_index()) &&\n-              (i < ClassLoaderExt::app_module_paths_start_index())) {\n+          if (SystemDictionary::is_system_class_loader(loader) && cs->from_app_classpath()) {\n@@ -1348,1 +1229,0 @@\n-            break;\n@@ -1350,2 +1230,1 @@\n-            if ((i >= 1) &&\n-                (i < ClassLoaderExt::app_class_paths_start_index())) {\n+            if (cs->from_boot_classpath()) {\n@@ -1356,1 +1235,0 @@\n-              break;\n@@ -1362,6 +1240,2 @@\n-          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && (i > 0)) {\n-            if (i >= ClassLoaderExt::app_module_paths_start_index() &&\n-                i < FileMapInfo::get_number_of_shared_paths()) {\n-              classpath_index = i;\n-              break;\n-            }\n+          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && cs->from_module_path()) {\n+            classpath_index = i;\n@@ -1371,5 +1245,4 @@\n-      \/\/ for index 0 and the stream->source() is the modules image or has the jrt: protocol.\n-      \/\/ The class must be from the runtime modules image.\n-      if (i == 0 && (stream->from_boot_loader_modules_image() || string_starts_with(src, \"jrt:\"))) {\n-        classpath_index = i;\n-        break;\n+      if (classpath_index >= 0) {\n+        return false; \/\/ quit iterating\n+      } else {\n+        return true; \/\/ Keep iterating\n@@ -1377,1 +1250,1 @@\n-    }\n+    });\n@@ -1387,7 +1260,0 @@\n-  } else {\n-    \/\/ The shared path table is set up after module system initialization.\n-    \/\/ The path table contains no entry before that. Any classes loaded prior\n-    \/\/ to the setup of the shared path table must be from the modules image.\n-    assert(stream->from_boot_loader_modules_image(), \"stream must be loaded by boot loader from modules image\");\n-    assert(FileMapInfo::get_number_of_shared_paths() == 0, \"shared path table must not have been setup\");\n-    classpath_index = 0;\n@@ -1434,1 +1300,1 @@\n-      ik->set_shared_classpath_index(ClassLoaderExt::app_class_paths_start_index());\n+      ik->set_shared_classpath_index(AOTCodeSourceConfig::dumptime()->app_start());\n@@ -1543,28 +1409,0 @@\n-#if INCLUDE_CDS\n-void ClassLoader::initialize_shared_path(JavaThread* current) {\n-  if (CDSConfig::is_dumping_archive()) {\n-    ClassLoaderExt::setup_search_paths(current);\n-  }\n-}\n-\n-void ClassLoader::initialize_module_path(TRAPS) {\n-  if (CDSConfig::is_dumping_archive()) {\n-    ClassLoaderExt::setup_module_paths(THREAD);\n-    FileMapInfo::allocate_shared_path_table(CHECK);\n-  }\n-}\n-\n-\/\/ Helper function used by CDS code to get the number of module path\n-\/\/ entries during shared classpath setup time.\n-int ClassLoader::num_module_path_entries() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  int num_entries = 0;\n-  ClassPathEntry* e= ClassLoader::_module_path_entries;\n-  while (e != nullptr) {\n-    num_entries ++;\n-    e = e->next();\n-  }\n-  return num_entries;\n-}\n-#endif\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":42,"deletions":204,"binary":false,"changes":246,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,4 +61,0 @@\n-  virtual bool is_multi_release_jar() const { return false; }\n-  virtual void set_multi_release_jar() {}\n-  \/\/ Is this entry created from the \"Class-path\" attribute from a JAR Manifest?\n-  virtual bool from_class_path_attr() const { return false; }\n@@ -95,2 +91,0 @@\n-  bool _from_class_path_attr; \/\/ From the \"Class-path\" attribute of a jar file\n-  bool _multi_release;       \/\/ multi-release jar\n@@ -99,3 +93,0 @@\n-  bool is_multi_release_jar() const { return _multi_release; }\n-  void set_multi_release_jar() { _multi_release = true; }\n-  bool from_class_path_attr() const { return _from_class_path_attr; }\n@@ -103,1 +94,1 @@\n-  ClassPathZipEntry(jzfile* zip, const char* zip_name, bool is_boot_append, bool from_class_path_attr, bool multi_release);\n+  ClassPathZipEntry(jzfile* zip, const char* zip_name);\n@@ -229,13 +220,0 @@\n-  \/\/ Info used by CDS\n-  CDS_ONLY(static ClassPathEntry* _app_classpath_entries;)\n-  CDS_ONLY(static ClassPathEntry* _last_app_classpath_entry;)\n-  CDS_ONLY(static ClassPathEntry* _module_path_entries;)\n-  CDS_ONLY(static ClassPathEntry* _last_module_path_entry;)\n-  CDS_ONLY(static void setup_app_search_path(JavaThread* current, const char* class_path);)\n-  CDS_ONLY(static void setup_module_search_path(JavaThread* current, const char* path);)\n-  static bool add_to_app_classpath_entries(JavaThread* current,\n-                                           ClassPathEntry* entry,\n-                                           bool check_for_duplicates);\n-  CDS_ONLY(static void add_to_module_path_entries(const char* path,\n-                                           ClassPathEntry* entry);)\n-\n@@ -243,2 +221,0 @@\n-  CDS_ONLY(static ClassPathEntry* app_classpath_entries() {return _app_classpath_entries;})\n-  CDS_ONLY(static ClassPathEntry* module_path_entries() {return _module_path_entries;})\n@@ -266,4 +242,1 @@\n-                                                 const char *path, const struct stat* st,\n-                                                 bool is_boot_append,\n-                                                 bool from_class_path_attr,\n-                                                 bool is_multi_release = false);\n+                                                 const char *path, const struct stat* st);\n@@ -279,4 +252,1 @@\n-                                           const char *path,\n-                                           bool check_for_duplicates,\n-                                           bool is_boot_append,\n-                                           bool from_class_path_attr);\n+                                           const char *path);\n@@ -366,2 +336,0 @@\n-  CDS_ONLY(static void initialize_shared_path(JavaThread* current);)\n-  CDS_ONLY(static void initialize_module_path(TRAPS);)\n@@ -376,16 +344,0 @@\n-  \/\/ Sharing dump and restore\n-\n-  \/\/ Helper function used by CDS code to get the number of boot classpath\n-  \/\/ entries during shared classpath setup time.\n-  static int num_boot_classpath_entries();\n-\n-  static ClassPathEntry* get_next_boot_classpath_entry(ClassPathEntry* e);\n-\n-  \/\/ Helper function used by CDS code to get the number of app classpath\n-  \/\/ entries during shared classpath setup time.\n-  static int num_app_classpath_entries();\n-\n-  \/\/ Helper function used by CDS code to get the number of module path\n-  \/\/ entries during shared classpath setup time.\n-  static int num_module_path_entries();\n-  static void  exit_with_path_failure(const char* error, const char* message);\n@@ -422,1 +374,1 @@\n-  static ClassPathZipEntry* create_class_path_zip_entry(const char *apath, bool is_boot_append);\n+  static ClassPathZipEntry* create_class_path_zip_entry(const char *path);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":5,"deletions":53,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-#include \"cds\/cdsConfig.hpp\"\n@@ -61,40 +60,0 @@\n-#if INCLUDE_CDS\n-\n-\/\/ Helper function used by CDS code to get the number of boot classpath\n-\/\/ entries during shared classpath setup time.\n-\n-inline int ClassLoader::num_boot_classpath_entries() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  assert(has_jrt_entry(), \"must have a java runtime image\");\n-  int num_entries = 1; \/\/ count the runtime image\n-  ClassPathEntry* e = first_append_entry();\n-  while (e != nullptr) {\n-    num_entries ++;\n-    e = e->next();\n-  }\n-  return num_entries;\n-}\n-\n-inline ClassPathEntry* ClassLoader::get_next_boot_classpath_entry(ClassPathEntry* e) {\n-  if (e == ClassLoader::_jrt_entry) {\n-    return first_append_entry();\n-  } else {\n-    return e->next();\n-  }\n-}\n-\n-\/\/ Helper function used by CDS code to get the number of app classpath\n-\/\/ entries during shared classpath setup time.\n-inline int ClassLoader::num_app_classpath_entries() {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  int num_entries = 0;\n-  ClassPathEntry* e= ClassLoader::_app_classpath_entries;\n-  while (e != nullptr) {\n-    num_entries ++;\n-    e = e->next();\n-  }\n-  return num_entries;\n-}\n-\n-#endif \/\/ INCLUDE_CDS\n-\n","filename":"src\/hotspot\/share\/classfile\/classLoader.inline.hpp","additions":1,"deletions":42,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"classfile\/modules.hpp\"\n@@ -34,0 +35,1 @@\n+#include \"runtime\/safepoint.hpp\"\n@@ -146,0 +148,15 @@\n+\/\/ ModuleEntryTables (even if empty) are required for iterate_symbols() to scan the\n+\/\/ platform\/system loaders inside the CDS safepoint, but the tables can be created only\n+\/\/ when outside of safepoints. Let's do that now.\n+void ClassLoaderDataShared::ensure_module_entry_tables_exist() {\n+  assert(!SafepointSynchronize::is_at_safepoint(), \"sanity\");\n+  ensure_module_entry_table_exist(SystemDictionary::java_platform_loader());\n+  ensure_module_entry_table_exist(SystemDictionary::java_system_loader());\n+}\n+\n+void ClassLoaderDataShared::ensure_module_entry_table_exist(oop class_loader) {\n+  Handle h_loader(JavaThread::current(), class_loader);\n+  ModuleEntryTable* met = Modules::get_module_entry_table(h_loader);\n+  assert(met != nullptr, \"sanity\");\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+  static void ensure_module_entry_table_exist(oop class_loader);\n@@ -38,0 +39,1 @@\n+  static void ensure_module_entry_tables_exist();\n","filename":"src\/hotspot\/share\/classfile\/classLoaderDataShared.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -54,8 +55,0 @@\n-jshort ClassLoaderExt::_app_class_paths_start_index = ClassLoaderExt::max_classpath_index;\n-jshort ClassLoaderExt::_app_module_paths_start_index = ClassLoaderExt::max_classpath_index;\n-jshort ClassLoaderExt::_max_used_path_index = 0;\n-int ClassLoaderExt::_num_module_paths = 0;\n-bool ClassLoaderExt::_has_app_classes = false;\n-bool ClassLoaderExt::_has_platform_classes = false;\n-bool ClassLoaderExt::_has_non_jar_in_classpath = false;\n-\n@@ -73,19 +66,0 @@\n-void ClassLoaderExt::setup_app_search_path(JavaThread* current) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  int start_index = ClassLoader::num_boot_classpath_entries();\n-  _app_class_paths_start_index = checked_cast<jshort>(start_index);\n-  char* app_class_path = os::strdup_check_oom(Arguments::get_appclasspath(), mtClass);\n-\n-  if (strcmp(app_class_path, \".\") == 0) {\n-    \/\/ This doesn't make any sense, even for AppCDS, so let's skip it. We\n-    \/\/ don't want to throw an error here because -cp \".\" is usually assigned\n-    \/\/ by the launcher when classpath is not specified.\n-    trace_class_path(\"app loader class path (skipped)=\", app_class_path);\n-  } else {\n-    trace_class_path(\"app loader class path=\", app_class_path);\n-    ClassLoader::setup_app_search_path(current, app_class_path);\n-  }\n-\n-  os::free(app_class_path);\n-}\n-\n@@ -96,216 +70,0 @@\n-void ClassLoaderExt::process_module_table(JavaThread* current, ModuleEntryTable* met) {\n-  ResourceMark rm(current);\n-  GrowableArray<const char*>* module_paths = new GrowableArray<const char*>(5);\n-\n-  class ModulePathsGatherer : public ModuleClosure {\n-    JavaThread* _current;\n-    GrowableArray<const char*>* _module_paths;\n-   public:\n-    ModulePathsGatherer(JavaThread* current, GrowableArray<const char*>* module_paths) :\n-      _current(current), _module_paths(module_paths) {}\n-    void do_module(ModuleEntry* m) {\n-      char* uri = m->location()->as_C_string();\n-      if (strncmp(uri, \"file:\", 5) == 0) {\n-        char* path = ClassLoader::uri_to_path(uri);\n-        extract_jar_files_from_path(path, _module_paths);\n-      }\n-    }\n-  };\n-\n-  ModulePathsGatherer gatherer(current, module_paths);\n-  {\n-    MutexLocker ml(Module_lock);\n-    met->modules_do(&gatherer);\n-  }\n-\n-  \/\/ Sort the module paths before storing into CDS archive for simpler\n-  \/\/ checking at runtime.\n-  module_paths->sort(compare_module_names);\n-\n-  for (int i = 0; i < module_paths->length(); i++) {\n-    ClassLoader::setup_module_search_path(current, module_paths->at(i));\n-  }\n-}\n-\n-void ClassLoaderExt::setup_module_paths(JavaThread* current) {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-  int start_index = ClassLoader::num_boot_classpath_entries() +\n-                    ClassLoader::num_app_classpath_entries();\n-  _app_module_paths_start_index = checked_cast<jshort>(start_index);\n-  Handle system_class_loader (current, SystemDictionary::java_system_loader());\n-  ModuleEntryTable* met = Modules::get_module_entry_table(system_class_loader);\n-  process_module_table(current, met);\n-}\n-\n-bool ClassLoaderExt::has_jar_suffix(const char* filename) {\n-  \/\/ In jdk.internal.module.ModulePath.readModule(), it checks for the \".jar\" suffix.\n-  \/\/ Performing the same check here.\n-  const char* dot = strrchr(filename, '.');\n-  if (dot != nullptr && strcmp(dot + 1, \"jar\") == 0) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-void ClassLoaderExt::extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths) {\n-  DIR* dirp = os::opendir(path);\n-  if (dirp == nullptr && errno == ENOTDIR && has_jar_suffix(path)) {\n-    module_paths->append(path);\n-  } else {\n-    if (dirp != nullptr) {\n-      struct dirent* dentry;\n-      while ((dentry = os::readdir(dirp)) != nullptr) {\n-        const char* file_name = dentry->d_name;\n-        if (has_jar_suffix(file_name)) {\n-          size_t full_name_len = strlen(path) + strlen(file_name) + strlen(os::file_separator()) + 1;\n-          char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n-          int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", path, os::file_separator(), file_name);\n-          assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n-          module_paths->append(full_name);\n-        }\n-      }\n-      os::closedir(dirp);\n-    }\n-  }\n-}\n-\n-char* ClassLoaderExt::read_manifest(JavaThread* current, ClassPathEntry* entry,\n-                                    jint *manifest_size, bool clean_text) {\n-  const char* name = \"META-INF\/MANIFEST.MF\";\n-  char* manifest;\n-  jint size;\n-\n-  assert(entry->is_jar_file(), \"must be\");\n-  manifest = (char*) ((ClassPathZipEntry*)entry )->open_entry(current, name, &size, true);\n-\n-  if (manifest == nullptr) { \/\/ No Manifest\n-    *manifest_size = 0;\n-    return nullptr;\n-  }\n-\n-\n-  if (clean_text) {\n-    \/\/ See http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/jar\/jar.html#JAR%20Manifest\n-    \/\/ (1): replace all CR\/LF and CR with LF\n-    StringUtils::replace_no_expand(manifest, \"\\r\\n\", \"\\n\");\n-\n-    \/\/ (2) remove all new-line continuation (remove all \"\\n \" substrings)\n-    StringUtils::replace_no_expand(manifest, \"\\n \", \"\");\n-  }\n-\n-  *manifest_size = (jint)strlen(manifest);\n-  return manifest;\n-}\n-\n-char* ClassLoaderExt::get_class_path_attr(const char* jar_path, char* manifest, jint manifest_size) {\n-  const char* tag = \"Class-Path: \";\n-  const int tag_len = (int)strlen(tag);\n-  char* found = nullptr;\n-  char* line_start = manifest;\n-  char* end = manifest + manifest_size;\n-\n-  assert(*end == 0, \"must be nul-terminated\");\n-\n-  while (line_start < end) {\n-    char* line_end = strchr(line_start, '\\n');\n-    if (line_end == nullptr) {\n-      \/\/ JAR spec require the manifest file to be terminated by a new line.\n-      break;\n-    }\n-    if (strncmp(tag, line_start, tag_len) == 0) {\n-      if (found != nullptr) {\n-        \/\/ Same behavior as jdk\/src\/share\/classes\/java\/util\/jar\/Attributes.java\n-        \/\/ If duplicated entries are found, the last one is used.\n-        log_warning(cds)(\"Warning: Duplicate name in Manifest: %s.\\n\"\n-                      \"Ensure that the manifest does not have duplicate entries, and\\n\"\n-                      \"that blank lines separate individual sections in both your\\n\"\n-                      \"manifest and in the META-INF\/MANIFEST.MF entry in the jar file:\\n%s\\n\", tag, jar_path);\n-      }\n-      found = line_start + tag_len;\n-      assert(found <= line_end, \"sanity\");\n-      *line_end = '\\0';\n-    }\n-    line_start = line_end + 1;\n-  }\n-  return found;\n-}\n-\n-void ClassLoaderExt::process_jar_manifest(JavaThread* current, ClassPathEntry* entry) {\n-  ResourceMark rm(current);\n-  jint manifest_size;\n-  char* manifest = read_manifest(current, entry, &manifest_size);\n-\n-  if (manifest == nullptr) {\n-    return;\n-  }\n-\n-  if (strstr(manifest, \"Extension-List:\") != nullptr) {\n-    vm_exit_during_cds_dumping(err_msg(\"-Xshare:dump does not support Extension-List in JAR manifest: %s\", entry->name()));\n-  }\n-\n-  if (strstr(manifest, \"Multi-Release: true\") != nullptr) {\n-    entry->set_multi_release_jar();\n-  }\n-\n-  char* cp_attr = get_class_path_attr(entry->name(), manifest, manifest_size);\n-\n-  if (cp_attr != nullptr && strlen(cp_attr) > 0) {\n-    trace_class_path(\"found Class-Path: \", cp_attr);\n-\n-    char sep = os::file_separator()[0];\n-    const char* dir_name = entry->name();\n-    const char* dir_tail = strrchr(dir_name, sep);\n-#ifdef _WINDOWS\n-    \/\/ On Windows, we also support forward slash as the file separator when locating entries in the classpath entry.\n-    const char* dir_tail2 = strrchr(dir_name, '\/');\n-    if (dir_tail == nullptr) {\n-      dir_tail = dir_tail2;\n-    } else if (dir_tail2 != nullptr && dir_tail2 > dir_tail) {\n-      dir_tail = dir_tail2;\n-    }\n-#endif\n-    int dir_len;\n-    if (dir_tail == nullptr) {\n-      dir_len = 0;\n-    } else {\n-      dir_len = pointer_delta_as_int(dir_tail, dir_name) + 1;\n-    }\n-\n-    \/\/ Split the cp_attr by spaces, and add each file\n-    char* file_start = cp_attr;\n-    char* end = file_start + strlen(file_start);\n-\n-    while (file_start < end) {\n-      char* file_end = strchr(file_start, ' ');\n-      if (file_end != nullptr) {\n-        *file_end = 0;\n-        file_end += 1;\n-      } else {\n-        file_end = end;\n-      }\n-\n-      size_t name_len = strlen(file_start);\n-      if (name_len > 0) {\n-        ResourceMark rm(current);\n-        size_t libname_len = dir_len + name_len;\n-        char* libname = NEW_RESOURCE_ARRAY(char, libname_len + 1);\n-        int n = os::snprintf(libname, libname_len + 1, \"%.*s%s\", dir_len, dir_name, file_start);\n-        assert((size_t)n == libname_len, \"Unexpected number of characters in string\");\n-        if (ClassLoader::update_class_path_entry_list(current, libname, true, false, true \/* from_class_path_attr *\/)) {\n-          trace_class_path(\"library = \", libname);\n-        } else {\n-          trace_class_path(\"library (non-existent) = \", libname);\n-          FileMapInfo::record_non_existent_class_path_entry(libname);\n-        }\n-      }\n-\n-      file_start = file_end;\n-    }\n-  }\n-  return;\n-}\n-\n-void ClassLoaderExt::setup_search_paths(JavaThread* current) {\n-  ClassLoaderExt::setup_app_search_path(current);\n-}\n-\n@@ -320,1 +78,1 @@\n-    ClassLoaderExt::set_has_app_classes();\n+    AOTCodeSourceConfig::dumptime_set_has_app_classes();\n@@ -323,4 +81,1 @@\n-    ClassLoaderExt::set_has_platform_classes();\n-  }\n-  if (classpath_index > ClassLoaderExt::max_used_path_index()) {\n-    ClassLoaderExt::set_max_used_path_index(classpath_index);\n+    AOTCodeSourceConfig::dumptime_set_has_platform_classes();\n@@ -328,0 +83,1 @@\n+  AOTCodeSourceConfig::dumptime_update_max_used_index(classpath_index);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":4,"deletions":248,"binary":false,"changes":252,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,24 +37,0 @@\n-private:\n-  enum SomeConstants {\n-    max_classpath_index = 0x7fff\n-  };\n-\n-  static char* get_class_path_attr(const char* jar_path, char* manifest, jint manifest_size);\n-  static void setup_app_search_path(JavaThread* current); \/\/ Only when -Xshare:dump\n-  static void process_module_table(JavaThread* current, ModuleEntryTable* met);\n-  \/\/ index of first app JAR in shared classpath entry table\n-  static jshort _app_class_paths_start_index;\n-  \/\/ index of first modular JAR in shared modulepath entry table\n-  static jshort _app_module_paths_start_index;\n-  \/\/ the largest path index being used during CDS dump time\n-  static jshort _max_used_path_index;\n-  \/\/ number of module paths\n-  static int _num_module_paths;\n-\n-  static bool _has_app_classes;\n-  static bool _has_platform_classes;\n-  static bool _has_non_jar_in_classpath;\n-\n-  static char* read_manifest(JavaThread* current, ClassPathEntry* entry, jint *manifest_size, bool clean_text);\n-  static bool has_jar_suffix(const char* filename);\n-\n@@ -62,2 +38,0 @@\n-  static void process_jar_manifest(JavaThread* current, ClassPathEntry* entry);\n-\n@@ -65,0 +39,1 @@\n+\n@@ -67,3 +42,0 @@\n-  static void setup_search_paths(JavaThread* current);\n-  static void setup_module_paths(JavaThread* current);\n-  static void extract_jar_files_from_path(const char* path, GrowableArray<const char*>* module_paths);\n@@ -71,49 +43,0 @@\n-\n-  static char* read_manifest(JavaThread* current, ClassPathEntry* entry, jint *manifest_size) {\n-    \/\/ Remove all the new-line continuations (which wrap long lines at 72 characters, see\n-    \/\/ http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/jar\/jar.html#JAR%20Manifest), so\n-    \/\/ that the manifest is easier to parse.\n-    return read_manifest(current, entry, manifest_size, true);\n-  }\n-  static char* read_raw_manifest(JavaThread* current, ClassPathEntry* entry, jint *manifest_size) {\n-    \/\/ Do not remove new-line continuations, so we can easily pass it as an argument to\n-    \/\/ java.util.jar.Manifest.getManifest() at run-time.\n-    return read_manifest(current, entry, manifest_size, false);\n-  }\n-\n-  static jshort app_class_paths_start_index() { return _app_class_paths_start_index; }\n-\n-  static jshort app_module_paths_start_index() { return _app_module_paths_start_index; }\n-\n-  static jshort max_used_path_index() { return _max_used_path_index; }\n-\n-  static int num_module_paths() { return _num_module_paths; }\n-\n-  static void set_max_used_path_index(jshort used_index) {\n-    _max_used_path_index = used_index;\n-  }\n-\n-  static void init_paths_start_index(jshort app_start) {\n-    _app_class_paths_start_index = app_start;\n-  }\n-\n-  static void init_app_module_paths_start_index(jshort module_start) {\n-    _app_module_paths_start_index = module_start;\n-  }\n-\n-  static void init_num_module_paths(int num_module_paths) {\n-    _num_module_paths = num_module_paths;\n-  }\n-\n-  static bool is_boot_classpath(int classpath_index) {\n-    return classpath_index < _app_class_paths_start_index;\n-  }\n-\n-  static bool has_platform_or_app_classes() {\n-    return _has_app_classes || _has_platform_classes;\n-  }\n-\n-  static bool has_non_jar_in_classpath() {\n-    return _has_non_jar_in_classpath;\n-  }\n-\n@@ -121,9 +44,0 @@\n-  static void set_has_app_classes() {\n-    _has_app_classes = true;\n-  }\n-  static void set_has_platform_classes() {\n-    _has_platform_classes = true;\n-  }\n-  static void set_has_non_jar_in_classpath() {\n-    _has_non_jar_in_classpath = true;\n-  }\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.hpp","additions":2,"deletions":88,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -28,1 +29,0 @@\n-#include \"cds\/filemap.hpp\"\n@@ -64,1 +64,1 @@\n-        _shared_path_index = FileMapInfo::get_module_shared_path_index(location);\n+        _shared_path_index = AOTCodeSourceConfig::runtime()->get_module_shared_path_index(_location);\n@@ -486,1 +486,1 @@\n-  _shared_path_index = FileMapInfo::get_module_shared_path_index(_location);\n+  _shared_path_index = AOTCodeSourceConfig::dumptime()->get_module_shared_path_index(_location);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-#include \"cds\/filemap.hpp\"\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -25,0 +25,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -965,1 +966,1 @@\n-  SharedClassPathEntry* scp_entry = FileMapInfo::shared_path(scp_index);\n+  const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(scp_index);\n@@ -967,1 +968,1 @@\n-    assert(scp_entry != nullptr, \"must be\");\n+    assert(cs != nullptr, \"must be\");\n@@ -970,1 +971,1 @@\n-    \/\/ [1] scp_entry->is_modules_image(): classes in java.base, or,\n+    \/\/ [1] cs->is_modules_image(): classes in java.base, or,\n@@ -972,1 +973,1 @@\n-    assert(scp_entry->is_modules_image() || HeapShared::is_a_test_class_in_unnamed_module(ik),\n+    assert(cs->is_modules_image() || HeapShared::is_a_test_class_in_unnamed_module(ik),\n@@ -989,1 +990,1 @@\n-  bool was_archived_from_named_module = scp_entry->in_named_module();\n+  bool was_archived_from_named_module = !cs->has_unnamed_module();\n@@ -1590,0 +1591,3 @@\n+  if (CDSConfig::is_dumping_archive()) {\n+    AOTCodeSourceConfig::dumptime_init(CHECK);\n+  }\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -317,1 +317,0 @@\n-  f(SharedClassPathEntry) \\\n","filename":"src\/hotspot\/share\/memory\/allocation.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -172,3 +172,3 @@\n-  \/\/ This is an index into FileMapHeader::_shared_path_table[], to\n-  \/\/ associate this class with the JAR file where it's loaded from during\n-  \/\/ dump time. If a class is not loaded from the shared archive, this field is\n+  \/\/ This is an index into AOTCodeSourceConfig::code_sources(), to\n+  \/\/ indicate the AOTCodeSource where this class is loaded from during\n+  \/\/ dump time. If a class is not loaded from the AOT cache, this field is\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -670,1 +670,1 @@\n-    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, true);\n+    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment);\n@@ -712,1 +712,1 @@\n-    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment, false);\n+    ClassPathZipEntry* zip_entry = ClassLoader::create_class_path_zip_entry(segment);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-#include \"cds\/filemap.hpp\"\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"cds\/aotCodeSource.hpp\"\n@@ -802,9 +803,0 @@\n-#if INCLUDE_CDS\n-  \/\/ capture the module path info from the ModuleEntryTable\n-  ClassLoader::initialize_module_path(THREAD);\n-  if (HAS_PENDING_EXCEPTION) {\n-    java_lang_Throwable::print(PENDING_EXCEPTION, tty);\n-    vm_exit_during_initialization(\"ClassLoader::initialize_module_path() failed unexpectedly\");\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+        test.testBootClassPathAppend();\n@@ -238,0 +239,16 @@\n+    \/* Arcchive contains Hello class with only hello.jar in bootclasspath at dump time.\n+     *\n+     * No error - bootclasspath can be appended during runtime if no -cp is specified.\n+     *\/\n+    public void testBootClassPathAppend() throws Exception {\n+        String appJar = JarBuilder.getOrCreateHelloJar();\n+        String jar2 = ClassFileInstaller.writeJar(\"jar2.jar\", \"pkg\/C2\");\n+        String jars = appJar + File.pathSeparator + jar2;\n+        String appClasses[] = {\"Hello\", \"pkg\/C2\"};\n+        TestCommon.dump(\n+            null, appClasses, \"-Xbootclasspath\/a:\" + appJar);\n+        TestCommon.run(\n+                \"-Xbootclasspath\/a:\" + jars, \"Hello\")\n+            .assertNormalExit();\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/BootClassPathMismatch.java","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,6 +74,0 @@\n-      TestCommon.run(\n-          \"-cp\", cp,\n-          \"CpAttr1\")\n-        .assertNormalExit();\n-\n-      \/\/ Logging test for class+path.\n@@ -85,2 +79,2 @@\n-            output.shouldMatch(\"checking shared classpath entry: .*cpattr2.jar\");\n-            output.shouldMatch(\"checking shared classpath entry: .*cpattr3.jar\");\n+            output.shouldMatch(\"Checking .*cpattr2.jar.*from JAR manifest ClassPath attribute\");\n+            output.shouldMatch(\"Checking .*cpattr3.jar.*from JAR manifest ClassPath attribute\");\n@@ -120,2 +114,2 @@\n-                output.shouldMatch(\"checking shared classpath entry: .*cpattr2.jar\");\n-                output.shouldMatch(\"checking shared classpath entry: .*cpattr3.jar\");\n+                output.shouldMatch(\"Checking .*cpattr2.jar.*from JAR manifest ClassPath attribute\");\n+                output.shouldMatch(\"Checking .*cpattr3.jar.*from JAR manifest ClassPath attribute\");\n@@ -153,2 +147,2 @@\n-                    output.shouldMatch(\"checking shared classpath entry: .*cpattr2.jar\");\n-                    output.shouldMatch(\"checking shared classpath entry: .*cpattr3.jar\");\n+                    output.shouldMatch(\"Checking .*cpattr2.jar.*from JAR manifest ClassPath attribute\");\n+                    output.shouldMatch(\"Checking .*cpattr3.jar.*from JAR manifest ClassPath attribute\");\n@@ -166,0 +160,1 @@\n+        \"-Xlog:class+path\",\n@@ -186,1 +181,1 @@\n-          output.shouldMatch(\"should be non-existent: .*cpattrX.jar\");\n+          output.shouldMatch(\"Checking .*cpattrX.jar.* not-exist\");\n@@ -201,1 +196,0 @@\n-\n@@ -203,3 +197,3 @@\n-        result.assertNormalExit(output -> {\n-                output.shouldMatch(\"Archived non-system classes are disabled because the file .*cpattrX.jar exists\");\n-            });\n+        result.assertAbnormalExit(output -> {\n+                output.shouldMatch(\"cpattrX.jar.* must not exist\");\n+        });\n@@ -236,2 +230,2 @@\n-                  output.shouldMatch(\".*APP classpath mismatch, actual: -Djava.class.path=.*cpattr1.jar.*cpattr2.jar.*hello.jar\")\n-              .shouldContain(\"Unable to use shared archive.\");\n+                  output.shouldMatch(\"app classpath .* does not match: expected .*hello.jar.* got .*cpattr2.jar\")\n+                        .shouldContain(\"Unable to use shared archive.\");\n@@ -246,2 +240,2 @@\n-                  output.shouldMatch(\".*APP classpath mismatch, actual: -Djava.class.path=.*cpattr2.jar.*hello.jar\")\n-              .shouldContain(\"Unable to use shared archive.\");\n+                  output.shouldMatch(\"app classpath .* does not match: expected .*cpattr1.jar.* got .*cpattr2.jar\")\n+                        .shouldContain(\"Unable to use shared archive.\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/ClassPathAttr.java","additions":16,"deletions":22,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    private static final String failedMessage = \"APP classpath mismatch\";\n+    private static final String failedMessage = \"Archived app classpath validation: failed\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/CommonAppClasspath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-        final String errorMessage3 = (bootcp ? \"BOOT\" : \"APP\") + \" classpath mismatch\";\n+        final String errorMessage3 = (bootcp ? \"boot\" : \"app\") + \" classpath validation: failed\";\n@@ -70,24 +70,0 @@\n-        \/\/ Replace nonExistPath with another non-existent file in the CP, it should still work\n-        TestCommon.run(make_args(bootcp,\n-                                 nonExistPath + \".duh\"  + File.pathSeparator + appJar,\n-                                 \"-Xlog:class+path=trace\",\n-                                 \"Hello\"))\n-            .assertNormalExit();\n-\n-        \/\/ Add a few more non-existent files in the CP, it should still work\n-        TestCommon.run(make_args(bootcp,\n-                                 nonExistPath + \".duh\"  + File.pathSeparator +\n-                                 nonExistPath + \".daa\"  + File.pathSeparator +\n-                                 nonExistPath + \".boo\"  + File.pathSeparator +\n-                                 appJar,\n-                                 \"-Xlog:class+path=trace\",\n-                                 \"Hello\"))\n-            .assertNormalExit();\n-\n-        \/\/ Or, remove all non-existent paths from the CP, it should still work\n-        TestCommon.run(make_args(bootcp,\n-                                 appJar,\n-                                 \"-Xlog:class+path=trace\",\n-                                 \"Hello\"))\n-            .assertNormalExit();\n-\n@@ -164,9 +140,1 @@\n-        \/\/ Run with non-existent boot class path, test should pass.\n-        TestCommon.run(make_args(true,\n-                                 nonExistPath,\n-                                 \"-cp\", appJar,\n-                                 \"-Xlog:class+path=trace\",\n-                                 \"Hello\"))\n-            .assertNormalExit();\n-\n-        \/\/ Run with existent boot class path, test should fail.\n+        \/\/ Run with a different boot class path, test should fail.\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/NonExistClasspath.java","additions":3,"deletions":35,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,1 +61,0 @@\n-\n@@ -63,1 +62,3 @@\n-    String lastCheckMsg = \"checking shared classpath entry: \" + appJar2; \/\/ the last JAR to check\n+    String firstCheckShortMsg = \"Checking 'hello.jar' file\"; \/\/ the first JAR to check (without directory prefix)\n+    String firstCheckMsg = \"Checking '\" + appJar + \"' file\"; \/\/ the first JAR to check\n+    String lastCheckMsg = \"Checking '\" + appJar2 + \"' file\"; \/\/ the last JAR to check\n@@ -102,1 +103,1 @@\n-      .ifNoMappingFailure(output -> check(output, 1, true, lastCheckMsg, \"Run time APP classpath is shorter than the one at dump time: .\"));\n+      .ifNoMappingFailure(output -> check(output, 1, true, firstCheckShortMsg, \"app classpath has fewer elements than expected\"));\n@@ -110,1 +111,1 @@\n-      .ifNoMappingFailure(output -> check(output, 0, true, lastCheckMsg));\n+      .ifNoMappingFailure(output -> check(output, 1, true, firstCheckShortMsg));\n@@ -117,1 +118,1 @@\n-      .ifNoMappingFailure(output -> check(output, 1, true, lastCheckMsg, \"Timestamp mismatch\"));\n+      .ifNoMappingFailure(output -> check(output, 1, true, firstCheckMsg, \"timestamp has changed\"));\n@@ -123,2 +124,1 @@\n-      .ifNoMappingFailure(output -> check(output, 1, true, lastCheckMsg, \"java.lang.Object\"));\n-\n+      .ifNoMappingFailure(output -> check(output, 1, true, firstCheckMsg, \"java.lang.Object\"));\n@@ -131,1 +131,1 @@\n-      .ifNoMappingFailure(output -> check(output, 1, true, lastCheckMsg, \"Required classpath entry does not exist: \" + appJar));\n+      .ifNoMappingFailure(output -> check(output, 1, true, firstCheckMsg, \"Required classpath entry does not exist: \" + appJar));\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/PrintSharedArchiveAndExit.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -271,10 +271,0 @@\n-\n-        \/\/ modify _common_app_classpath_size\n-        String wrongCommonAppClasspathOffset = startNewArchive(\"wrongCommonAppClasspathOffset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(orgJsaFile, wrongCommonAppClasspathOffset);\n-        int commonAppClasspathPrefixSize = CDSArchiveUtils.commonAppClasspathPrefixSize(copiedJsa);\n-        System.out.println(\"    commonAppClasspathPrefixSize = \" + commonAppClasspathPrefixSize);\n-        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetCommonAppClasspathPrefixSize(), commonAppClasspathPrefixSize * 2);\n-        commonAppClasspathPrefixSize = CDSArchiveUtils.commonAppClasspathPrefixSize(copiedJsa);\n-        System.out.println(\"new commonAppClasspathPrefixSize = \" + commonAppClasspathPrefixSize);\n-        testAndCheck(verifyExecArgs);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/SharedArchiveConsistency.java","additions":1,"deletions":11,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,3 +91,6 @@\n-        \/\/ Then try to execute the archive with a different classpath and with -Xlog:class+path.\n-        \/\/ The diagnostic \"expecting\" app classpath trace should show the entire classpath (excluding any non-existent dump-time paths).\n-        String recordedCP = dummyJar + ps + appJar;\n+        TestCommon.run(\n+            \"-Xlog:class+path\", \"-Xlog:cds\",\n+            \"-cp\", dumpCP,\n+            \"Hello\")\n+            .assertNormalExit();\n+\n@@ -101,3 +104,0 @@\n-                \/\/ the \"expecting\" app classpath from -Xlog:class+path should not\n-                \/\/ be truncated\n-                output.shouldContain(recordedCP);\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TraceLongClasspath.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-          .shouldMatch(\".warning..cds.*jar2.jar timestamp has changed.\");\n+          .shouldMatch(\".warning..cds.*jar2.jar.*timestamp has changed\");\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/WrongClasspath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -153,16 +153,0 @@\n-        startTest(\"5a. Modify common app classpath size\");\n-        String wrongCommonAppClasspathOffset = getNewArchiveName(\"wrongCommonAppClasspathOffset\");\n-        copiedJsa = CDSArchiveUtils.copyArchiveFile(jsa, wrongCommonAppClasspathOffset);\n-        int commonAppClasspathPrefixSize = CDSArchiveUtils.commonAppClasspathPrefixSize(copiedJsa);\n-        CDSArchiveUtils.writeData(copiedJsa, CDSArchiveUtils.offsetCommonAppClasspathPrefixSize(), -1);\n-        runTwo(baseArchiveName, wrongCommonAppClasspathOffset,\n-               appJar, mainClass, isAuto ? 0 : 1,\n-               \"common app classpath prefix len < 0\");\n-\n-        startTest(\"5b. Modify common app classpath size, run with -XX:-VerifySharedSpaces\");\n-        VERIFY_CRC = true;\n-        runTwo(baseArchiveName, modTop,\n-               appJar, mainClass, isAuto ? 0 : 1,\n-               \"Header checksum verification failed\");\n-        VERIFY_CRC = false;\n-\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/ArchiveConsistency.java","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -115,1 +115,1 @@\n-              output.shouldMatch(\".warning..cds.*GenericTestApp.jar timestamp has changed.\");});\n+              output.shouldMatch(\".warning..cds.*GenericTestApp.jar.*timestamp has changed\");});\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/dynamicArchive\/WrongTopClasspath.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,1 +229,1 @@\n-        tty(\"5. run with CDS on, without the extra module specified in dump time, should pass\");\n+        tty(\"5. run with CDS on, without the extra module specified in dump time, should fail\");\n@@ -235,4 +235,4 @@\n-                out.shouldNotContain(OPTIMIZE_DISABLED)\n-                   .shouldContain(OPTIMIZE_ENABLED)\n-                   .shouldNotContain(FMG_DISABLED)\n-                   .shouldContain(FMG_ENABLED)\n+                out.shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n@@ -242,0 +242,1 @@\n+\n@@ -248,4 +249,4 @@\n-                out.shouldNotContain(OPTIMIZE_ENABLED)\n-                   .shouldContain(OPTIMIZE_DISABLED)\n-                   .shouldNotContain(FMG_ENABLED)\n-                   .shouldContain(FMG_DISABLED)\n+                out.shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n@@ -265,1 +266,1 @@\n-        tty(\"7. run with CDS on, without the extra module specified in dump time, should pass\");\n+        tty(\"7. run with CDS on, without the extra module specified in dump time, should fail\");\n@@ -271,4 +272,4 @@\n-                out.shouldNotContain(OPTIMIZE_DISABLED)\n-                   .shouldContain(OPTIMIZE_ENABLED)\n-                   .shouldNotContain(FMG_DISABLED)\n-                   .shouldContain(FMG_ENABLED)\n+                out.shouldContain(OPTIMIZE_DISABLED)\n+                   .shouldNotContain(OPTIMIZE_ENABLED)\n+                   .shouldContain(FMG_DISABLED)\n+                   .shouldNotContain(FMG_ENABLED)\n@@ -285,4 +286,4 @@\n-                out.shouldNotContain(OPTIMIZE_ENABLED)\n-                   .shouldContain(OPTIMIZE_DISABLED)\n-                   .shouldNotContain(FMG_ENABLED)\n-                   .shouldContain(FMG_DISABLED)\n+                out.shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n@@ -298,4 +299,4 @@\n-                out.shouldNotContain(OPTIMIZE_ENABLED)\n-                   .shouldContain(OPTIMIZE_DISABLED)\n-                   .shouldNotContain(FMG_ENABLED)\n-                   .shouldContain(FMG_DISABLED)\n+                out.shouldContain(OPTIMIZE_ENABLED)\n+                   .shouldNotContain(OPTIMIZE_DISABLED)\n+                   .shouldContain(FMG_ENABLED)\n+                   .shouldNotContain(FMG_DISABLED)\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/jigsaw\/modulepath\/ModulePathAndFMG.java","additions":24,"deletions":23,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,0 @@\n-    private static int offsetCommonAppClasspathPrefixSize;\/\/ offset of GenericCDSFileMapHeader::_common_app_classpath_size\n@@ -94,1 +93,0 @@\n-            offsetCommonAppClasspathPrefixSize = wb.getCDSOffsetForName(\"FileMapHeader::_common_app_classpath_prefix_size\");\n@@ -133,1 +131,0 @@\n-    public static int offsetCommonAppClasspathPrefixSize() { return offsetCommonAppClasspathPrefixSize; }\n@@ -162,4 +159,0 @@\n-    public static int commonAppClasspathPrefixSize(File jsaFile) throws Exception {\n-        return (int)readInt(jsaFile, offsetCommonAppClasspathPrefixSize, 4);\n-    }\n-\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSArchiveUtils.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"}]}