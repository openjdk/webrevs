{"files":[{"patch":"@@ -0,0 +1,999 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"cds\/aotClassLocation.hpp\"\n+#include \"cds\/archiveBuilder.hpp\"\n+#include \"cds\/cdsConfig.hpp\"\n+#include \"cds\/dynamicArchive.hpp\"\n+#include \"cds\/filemap.hpp\"\n+#include \"cds\/metaspaceShared.hpp\"\n+#include \"cds\/serializeClosure.hpp\"\n+#include \"classfile\/classLoader.hpp\"\n+#include \"classfile\/classLoaderData.hpp\"\n+#include \"classfile\/javaClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"logging\/logStream.hpp\"\n+#include \"memory\/metadataFactory.hpp\"\n+#include \"memory\/metaspaceClosure.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n+#include \"runtime\/arguments.hpp\"\n+#include \"utilities\/classpathStream.hpp\"\n+#include \"utilities\/formatBuffer.hpp\"\n+#include \"utilities\/stringUtils.hpp\"\n+\n+#include <sys\/stat.h>\n+#include <errno.h>\n+\n+AOTClassLocationConfig* AOTClassLocationConfig::_dumptime_instance = nullptr;\n+const AOTClassLocationConfig* AOTClassLocationConfig::_runtime_instance = nullptr;\n+\n+\/\/ A ClassLocationStream represents a list of code sources, which can be iterated using\n+\/\/ start() and has_next().\n+class ClassLocationStream {\n+protected:\n+  GrowableArray<const char*> _array;\n+  int _current;\n+\n+  \/\/ Add one path to this stream.\n+  void add_one_path(const char* path) {\n+    _array.append(path);\n+  }\n+\n+  \/\/ Add all paths specified in cp; cp must be from -classpath or -Xbootclasspath\/a.\n+  void add_paths_in_classpath(const char* cp) {\n+    ClasspathStream cp_stream(cp);\n+    while (cp_stream.has_next()) {\n+      add_one_path(cp_stream.get_next());\n+    }\n+  }\n+\n+public:\n+  ClassLocationStream() : _array(), _current(0) {}\n+\n+  void print(outputStream* st) const {\n+    const char* sep = \"\";\n+    for (int i = 0; i < _array.length(); i++) {\n+      st->print(\"%s%s\", sep, _array.at(i));\n+      sep = os::path_separator();\n+    }\n+  }\n+\n+  void add(ClassLocationStream& css) {\n+    for (css.start(); css.has_next();) {\n+      add_one_path(css.get_next());\n+    }\n+  }\n+\n+  \/\/ Iteration\n+  void start() { _current = 0; }\n+  bool has_next() const { return _current < _array.length(); }\n+  const char* get_next() {\n+    return _array.at(_current++);\n+  }\n+\n+  int current() const { return _current; }\n+  bool is_empty() const { return _array.length() == 0; }\n+};\n+\n+class BootCpClassLocationStream : public ClassLocationStream {\n+public:\n+  BootCpClassLocationStream() : ClassLocationStream() {\n+    \/\/ Arguments::get_boot_class_path() contains $JAVA_HOME\/lib\/modules, but we treat that separately\n+    for (const char* bootcp = Arguments::get_boot_class_path(); *bootcp != '\\0'; ++bootcp) {\n+      if (*bootcp == *os::path_separator()) {\n+        ++bootcp;\n+        add_paths_in_classpath(bootcp);\n+        break;\n+      }\n+    }\n+  }\n+};\n+\n+class AppCpClassLocationStream : public ClassLocationStream {\n+public:\n+  AppCpClassLocationStream() : ClassLocationStream() {\n+    const char* appcp = Arguments::get_appclasspath();\n+    if (strcmp(appcp, \".\") == 0) {\n+      appcp = \"\";\n+    }\n+    add_paths_in_classpath(appcp);\n+  }\n+};\n+\n+class ModulePathClassLocationStream : public ClassLocationStream {\n+  bool _has_non_jar_modules;\n+public:\n+  ModulePathClassLocationStream();\n+  bool has_non_jar_modules() { return _has_non_jar_modules; }\n+};\n+\n+\/\/ AllClassLocationStreams is used to iterate over all the code sources that\n+\/\/ are available to the application from -Xbootclasspath, -classpath and --module-path.\n+\/\/ When creating an AOT cache, we store the contents from AllClassLocationStreams\n+\/\/ into an array of AOTClassLocations. See AOTClassLocationConfig::dumptime_init_helper().\n+\/\/ When loading the AOT cache in a production run, we compare the contents of the\n+\/\/ stored AOTClassLocations against the current AllClassLocationStreams to determine whether\n+\/\/ the AOT cache is compatible with the current JVM. See AOTClassLocationConfig::validate().\n+class AllClassLocationStreams {\n+  BootCpClassLocationStream _boot_cp;          \/\/ Specified by -Xbootclasspath\/a\n+  AppCpClassLocationStream _app_cp;            \/\/ Specified by -classpath\n+  ModulePathClassLocationStream _module_path;  \/\/ Specified by --module-path\n+  ClassLocationStream _boot_and_app_cp;        \/\/ Convenience for iterating over both _boot and _app\n+public:\n+  BootCpClassLocationStream& boot_cp()             { return _boot_cp; }\n+  AppCpClassLocationStream& app_cp()               { return _app_cp; }\n+  ModulePathClassLocationStream& module_path()     { return _module_path; }\n+  ClassLocationStream& boot_and_app_cp()           { return _boot_and_app_cp; }\n+\n+  AllClassLocationStreams() : _boot_cp(), _app_cp(), _module_path(), _boot_and_app_cp() {\n+    _boot_and_app_cp.add(_boot_cp);\n+    _boot_and_app_cp.add(_app_cp);\n+  }\n+};\n+\n+static bool has_jar_suffix(const char* filename) {\n+  \/\/ In jdk.internal.module.ModulePath.readModule(), it checks for the \".jar\" suffix.\n+  \/\/ Performing the same check here.\n+  const char* dot = strrchr(filename, '.');\n+  if (dot != nullptr && strcmp(dot + 1, \"jar\") == 0) {\n+    return true;\n+  }\n+  return false;\n+}\n+\n+static int compare_module_path_by_name(const char** p1, const char** p2) {\n+  return strcmp(*p1, *p2);\n+}\n+\n+ModulePathClassLocationStream::ModulePathClassLocationStream() : ClassLocationStream(), _has_non_jar_modules(false) {\n+  \/\/ Note: for handling of --module-path, see\n+  \/\/   https:\/\/openjdk.org\/jeps\/261#Module-paths\n+  \/\/   https:\/\/docs.oracle.com\/en\/java\/javase\/23\/docs\/api\/java.base\/java\/lang\/module\/ModuleFinder.html#of(java.nio.file.Path...)\n+\n+  const char* jdk_module_path = Arguments::get_property(\"jdk.module.path\");\n+  if (jdk_module_path == nullptr) {\n+    return;\n+  }\n+\n+  ClasspathStream cp_stream(jdk_module_path);\n+  while (cp_stream.has_next()) {\n+    const char* path = cp_stream.get_next();\n+    DIR* dirp = os::opendir(path);\n+    if (dirp == nullptr && errno == ENOTDIR && has_jar_suffix(path)) {\n+      add_one_path(path);\n+    } else if (dirp != nullptr) {\n+      struct dirent* dentry;\n+      bool found_jar = false;\n+      while ((dentry = os::readdir(dirp)) != nullptr) {\n+        const char* file_name = dentry->d_name;\n+        if (has_jar_suffix(file_name)) {\n+          size_t full_name_len = strlen(path) + strlen(file_name) + strlen(os::file_separator()) + 1;\n+          char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n+          int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", path, os::file_separator(), file_name);\n+          assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n+          add_one_path(full_name);\n+          found_jar = true;\n+        } else if (strcmp(file_name, \".\") != 0 && strcmp(file_name, \"..\") != 0) {\n+          \/\/ Found some non jar entries\n+          _has_non_jar_modules = true;\n+          log_info(class, path)(\"Found non-jar path: '%s%s%s'\", path, os::file_separator(), file_name);\n+        }\n+      }\n+      if (!found_jar) {\n+        log_info(class, path)(\"Found exploded module path: '%s'\", path);\n+        _has_non_jar_modules = true;\n+      }\n+      os::closedir(dirp);\n+    } else {\n+      _has_non_jar_modules = true;\n+    }\n+  }\n+\n+  _array.sort(compare_module_path_by_name);\n+}\n+\n+AOTClassLocation* AOTClassLocation::allocate(JavaThread* current, const char* path, int index,\n+                                             Group group, bool from_cpattr, bool is_jrt) {\n+  size_t path_length = 0;\n+  size_t manifest_length = 0;\n+  bool check_time = false;\n+  time_t timestamp = 0;\n+  int64_t filesize = 0;\n+  FileType type = FileType::NORMAL;\n+  \/\/ Do not record the actual path of the jrt, as the entire JDK can be moved to a different\n+  \/\/ directory.\n+  const char* recorded_path = is_jrt ? \"\" : path;\n+  path_length = strlen(recorded_path);\n+\n+  struct stat st;\n+  if (os::stat(path, &st) == 0) {\n+    if ((st.st_mode & S_IFMT) == S_IFDIR) {\n+      type = FileType::DIR;\n+    } else {\n+      timestamp = st.st_mtime;\n+      filesize = st.st_size;\n+\n+      \/\/ The timestamp of $JAVA_HOME\/lib\/modules is not checked at runtime.\n+      check_time = !is_jrt;\n+    }\n+#ifdef _WINDOWS\n+  } else if (errno == ERROR_FILE_NOT_FOUND || errno == ERROR_PATH_NOT_FOUND) {\n+    \/\/ On Windows, the errno could be ERROR_PATH_NOT_FOUND (3) in case the directory\n+    \/\/ path doesn't exist.\n+    type = FileType::NOT_EXIST;\n+#endif\n+  } else if (errno == ENOENT) {\n+    \/\/ We allow the file to not exist, as long as it also doesn't exist during runtime.\n+    type = FileType::NOT_EXIST;\n+  } else {\n+    log_error(cds)(\"Unable to open file %s.\", path);\n+    MetaspaceShared::unrecoverable_loading_error();\n+  }\n+\n+  ResourceMark rm(current);\n+  char* manifest = nullptr;\n+\n+  if (!is_jrt && type == FileType::NORMAL) {\n+    manifest = read_manifest(current, path, manifest_length); \/\/ resource allocated\n+  }\n+\n+  size_t cs_size = header_size() +\n+    + path_length + 1 \/* nul-terminated *\/\n+    + manifest_length + 1; \/* nul-terminated *\/\n+\n+  AOTClassLocation* cs = (AOTClassLocation*)os::malloc(cs_size, mtClassShared);\n+  memset(cs, 0, cs_size);\n+  cs->_path_length = path_length;\n+  cs->_manifest_length = manifest_length;\n+  cs->_check_time = check_time;\n+  cs->_from_cpattr = from_cpattr;\n+  cs->_timestamp = timestamp;\n+  cs->_filesize = filesize;\n+  cs->_file_type = type;\n+  cs->_group = group;\n+  cs->_index = index;\n+\n+  strcpy(((char*)cs) + cs->path_offset(), recorded_path);\n+  if (manifest_length > 0) {\n+    memcpy(((char*)cs) + cs->manifest_offset(), manifest, manifest_length);\n+  }\n+  assert(*(cs->manifest() + cs->manifest_length()) == '\\0', \"should be nul-terminated\");\n+\n+  if (strstr(cs->manifest(), \"Multi-Release: true\") != nullptr) {\n+    cs->_is_multi_release_jar = true;\n+  }\n+\n+  if (strstr(cs->manifest(), \"Extension-List:\") != nullptr) {\n+    vm_exit_during_cds_dumping(err_msg(\"-Xshare:dump does not support Extension-List in JAR manifest: %s\", path));\n+  }\n+\n+  return cs;\n+}\n+\n+char* AOTClassLocation::read_manifest(JavaThread* current, const char* path, size_t& manifest_length) {\n+  manifest_length = 0;\n+\n+  struct stat st;\n+  if (os::stat(path, &st) != 0) {\n+    return nullptr;\n+  }\n+\n+  ClassPathEntry* cpe = ClassLoader::create_class_path_entry(current, path, &st);\n+  if (cpe == nullptr) {\n+    \/\/ <path> is a file, but not a JAR file\n+    return nullptr;\n+  }\n+  assert(cpe->is_jar_file(), \"should not be called with a directory\");\n+\n+  const char* name = \"META-INF\/MANIFEST.MF\";\n+  char* manifest;\n+  jint size;\n+  manifest = (char*) ((ClassPathZipEntry*)cpe)->open_entry(current, name, &size, true);\n+\n+  if (manifest == nullptr || size <= 0) { \/\/ No Manifest\n+    manifest_length = 0;\n+  } else {\n+    manifest_length = (size_t)size;\n+  }\n+\n+  delete cpe;\n+  return manifest;\n+}\n+\n+\/\/ The result is resource allocated.\n+char* AOTClassLocation::get_cpattr() const {\n+  if (_manifest_length == 0) {\n+    return nullptr;\n+  }\n+\n+  size_t buf_size = _manifest_length + 1;\n+  char* buf = NEW_RESOURCE_ARRAY(char, buf_size);\n+  memcpy(buf, manifest(), _manifest_length);\n+  buf[_manifest_length] = 0; \/\/ make sure it's 0-terminated\n+\n+  \/\/ See http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/jar\/jar.html#JAR%20Manifest\n+  \/\/ Replace all CR\/LF and CR with LF\n+  StringUtils::replace_no_expand(buf, \"\\r\\n\", \"\\n\");\n+  \/\/ Remove all new-line continuation (remove all \"\\n \" substrings)\n+  StringUtils::replace_no_expand(buf, \"\\n \", \"\");\n+\n+  const char* tag = \"Class-Path: \";\n+  size_t tag_len = strlen(tag);\n+  char* found = nullptr;\n+  char* line_start = buf;\n+  char* end = buf + _manifest_length;\n+\n+  assert(*end == 0, \"must be nul-terminated\");\n+\n+  while (line_start < end) {\n+    char* line_end = strchr(line_start, '\\n');\n+    if (line_end == nullptr) {\n+      \/\/ JAR spec require the manifest file to be terminated by a new line.\n+      break;\n+    }\n+    if (strncmp(tag, line_start, tag_len) == 0) {\n+      if (found != nullptr) {\n+        \/\/ Same behavior as jdk\/src\/share\/classes\/java\/util\/jar\/Attributes.java\n+        \/\/ If duplicated entries are found, the last one is used.\n+        log_warning(cds)(\"Warning: Duplicate name in Manifest: %s.\\n\"\n+                         \"Ensure that the manifest does not have duplicate entries, and\\n\"\n+                         \"that blank lines separate individual sections in both your\\n\"\n+                         \"manifest and in the META-INF\/MANIFEST.MF entry in the jar file:\\n%s\\n\", tag, path());\n+      }\n+      found = line_start + tag_len;\n+      assert(found <= line_end, \"sanity\");\n+      *line_end = '\\0';\n+    }\n+    line_start = line_end + 1;\n+  }\n+\n+  return found;\n+}\n+\n+AOTClassLocation* AOTClassLocation::write_to_archive() const {\n+  AOTClassLocation* archived_copy = (AOTClassLocation*)ArchiveBuilder::ro_region_alloc(total_size());\n+  memcpy((char*)archived_copy, (char*)this, total_size());\n+  return archived_copy;\n+}\n+\n+const char* AOTClassLocation::file_type_string() const {\n+  switch (_file_type) {\n+  case FileType::NORMAL: return \"file\";\n+  case FileType::DIR: return \"dir\";\n+  case FileType::NOT_EXIST: default: return \"not-exist\";\n+  }\n+}\n+\n+bool AOTClassLocation::check(const char* runtime_path, bool has_aot_linked_classes) const {\n+  struct stat st;\n+  if (os::stat(runtime_path, &st) != 0) {\n+    if (_file_type != FileType::NOT_EXIST) {\n+      log_warning(cds)(\"Required classpath entry does not exist: %s\", runtime_path);\n+      return false;\n+    }\n+  } else if ((st.st_mode & S_IFMT) == S_IFDIR) {\n+    if (_file_type == FileType::NOT_EXIST) {\n+      log_warning(cds)(\"'%s' must not exist\", runtime_path);\n+      return false;\n+    }\n+    if (_file_type == FileType::NORMAL) {\n+      log_warning(cds)(\"'%s' must be a file\", runtime_path);\n+      return false;\n+    }\n+    if (!os::dir_is_empty(runtime_path)) {\n+      log_warning(cds)(\"directory is not empty: '%s'\", runtime_path);\n+      return false;\n+    }\n+  } else {\n+    if (_file_type == FileType::NOT_EXIST) {\n+      log_warning(cds)(\"'%s' must not exist\", runtime_path);\n+      if (has_aot_linked_classes) {\n+        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n+                       \"file %s exists\", runtime_path);\n+        return false;\n+      } else {\n+        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n+                         \"file %s exists\", runtime_path);\n+        FileMapInfo::current_info()->set_has_platform_or_app_classes(false);\n+        if (DynamicArchive::is_mapped()) {\n+          FileMapInfo::dynamic_info()->set_has_platform_or_app_classes(false);\n+        }\n+      }\n+    }\n+    if (_file_type == FileType::DIR) {\n+      log_warning(cds)(\"'%s' must be a directory\", runtime_path);\n+      return false;\n+    }\n+    bool size_differs = _filesize != st.st_size;\n+    bool time_differs = _check_time && (_timestamp != st.st_mtime);\n+    if (size_differs || time_differs) {\n+      log_warning(cds)(\"This file is not the one used while building the shared archive file: '%s'%s%s\",\n+                       runtime_path,\n+                       time_differs ? \", timestamp has changed\" : \"\",\n+                       size_differs ? \", size has changed\" : \"\");\n+      return false;\n+    }\n+  }\n+\n+  log_info(class, path)(\"ok\");\n+  return true;\n+}\n+\n+void AOTClassLocationConfig::dumptime_init(JavaThread* current) {\n+  assert(CDSConfig::is_dumping_archive(), \"\");\n+  _dumptime_instance = NEW_C_HEAP_OBJ(AOTClassLocationConfig, mtClassShared);\n+  _dumptime_instance->dumptime_init_helper(current);\n+  if (current->has_pending_exception()) {\n+    \/\/ we can get an exception only when we run out of metaspace, but that\n+    \/\/ shouldn't happen this early in bootstrap.\n+    java_lang_Throwable::print(current->pending_exception(), tty);\n+    vm_exit_during_initialization(\"AOTClassLocationConfig::dumptime_init_helper() failed unexpectedly\");\n+  }\n+}\n+\n+void AOTClassLocationConfig::dumptime_init_helper(TRAPS) {\n+  ResourceMark rm;\n+  GrowableClassLocationArray tmp_array;\n+  AllClassLocationStreams all_css;\n+\n+  AOTClassLocation* jrt = AOTClassLocation::allocate(THREAD, ClassLoader::get_jrt_entry()->name(),\n+                                               0, Group::MODULES_IMAGE,\n+                                               \/*from_cpattr*\/false, \/*is_jrt*\/true);\n+  tmp_array.append(jrt);\n+\n+  parse(THREAD, tmp_array, all_css.boot_cp(), Group::BOOT_CLASSPATH, \/*parse_manifest*\/true);\n+  _boot_classpath_end = tmp_array.length();\n+\n+  parse(THREAD, tmp_array, all_css.app_cp(), Group::APP_CLASSPATH, \/*parse_manifest*\/true);\n+  _app_classpath_end = tmp_array.length();\n+\n+  parse(THREAD, tmp_array, all_css.module_path(), Group::MODULE_PATH, \/*parse_manifest*\/false);\n+  _module_end = tmp_array.length();\n+\n+  _class_locations =  MetadataFactory::new_array<AOTClassLocation*>(ClassLoaderData::the_null_class_loader_data(),\n+                                                               tmp_array.length(), CHECK);\n+  for (int i = 0; i < tmp_array.length(); i++) {\n+    _class_locations->at_put(i, tmp_array.at(i));\n+  }\n+\n+  const char* lcp = find_lcp(all_css.boot_and_app_cp(), _dumptime_lcp_len);\n+  if (_dumptime_lcp_len > 0) {\n+    os::free((void*)lcp);\n+    log_info(class, path)(\"Longest common prefix = %s (%zu chars)\", lcp, _dumptime_lcp_len);\n+  } else {\n+    assert(_dumptime_lcp_len == 0, \"sanity\");\n+    log_info(class, path)(\"Longest common prefix = <none> (0 chars)\");\n+  }\n+\n+  _has_non_jar_modules = all_css.module_path().has_non_jar_modules();\n+  _has_platform_classes = false;\n+  _has_app_classes = false;\n+  _max_used_index = 0;\n+}\n+\n+\/\/ Find the longest common prefix of two paths, up to max_lcp_len.\n+\/\/ E.g.   p1 = \"\/a\/b\/foo\"\n+\/\/        p2 = \"\/a\/b\/bar\"\n+\/\/        max_lcp_len = 3\n+\/\/ -> returns 3\n+static size_t find_lcp_of_two_paths(const char* p1, const char* p2, size_t max_lcp_len) {\n+  size_t lcp_len = 0;\n+  char sep = os::file_separator()[0];\n+  for (size_t i = 0; ; i++) {\n+    char c1 = *p1++;\n+    char c2 = *p2++;\n+    if (c1 == 0 || c2 == 0 || c1 != c2) {\n+      break;\n+    }\n+    if (c1 == sep) {\n+      lcp_len = i + 1;\n+      assert(lcp_len <= max_lcp_len, \"sanity\");\n+      if (lcp_len == max_lcp_len) {\n+        break;\n+      }\n+    }\n+  }\n+  return lcp_len;\n+}\n+\n+\/\/ cheap-allocated if lcp_len > 0\n+const char* AOTClassLocationConfig::find_lcp(ClassLocationStream& css, size_t& lcp_len) {\n+  const char* first_path = nullptr;\n+  char sep = os::file_separator()[0];\n+\n+  for (css.start(); css.has_next(); ) {\n+    const char* path = css.get_next();\n+    if (first_path == nullptr) {\n+      first_path = path;\n+      const char* p = strrchr(first_path, sep);\n+      if (p == nullptr) {\n+        lcp_len = 0;\n+        return \"\";\n+      } else {\n+        lcp_len = p - first_path + 1;\n+      }\n+    } else {\n+      lcp_len = find_lcp_of_two_paths(first_path, path, lcp_len);\n+      if (lcp_len == 0) {\n+        return \"\";\n+      }\n+    }\n+  }\n+\n+  if (first_path != nullptr && lcp_len > 0) {\n+    char* lcp = NEW_C_HEAP_ARRAY(char, lcp_len + 1, mtClassShared);\n+    lcp[0] = 0;\n+    strncat(lcp, first_path, lcp_len);\n+    return lcp;\n+  } else {\n+    lcp_len = 0;\n+    return \"\";\n+  }\n+}\n+\n+void AOTClassLocationConfig::parse(JavaThread* current, GrowableClassLocationArray& tmp_array,\n+                                   ClassLocationStream& css, Group group, bool parse_manifest) {\n+  for (css.start(); css.has_next(); ) {\n+    add_class_location(current, tmp_array, css.get_next(), group, parse_manifest, \/*from_cpattr*\/false);\n+  }\n+}\n+\n+void AOTClassLocationConfig::add_class_location(JavaThread* current, GrowableClassLocationArray& tmp_array,\n+                                                const char* path, Group group, bool parse_manifest, bool from_cpattr) {\n+  AOTClassLocation* cs = AOTClassLocation::allocate(current, path, tmp_array.length(), group, from_cpattr);\n+  tmp_array.append(cs);\n+\n+  if (!parse_manifest) {\n+    \/\/ parse_manifest is true for -classpath and -Xbootclasspath\/a, and false for --module-path.\n+    return;\n+  }\n+\n+  ResourceMark rm;\n+  char* cp_attr = cs->get_cpattr(); \/\/ resource allocated\n+  if (cp_attr != nullptr && strlen(cp_attr) > 0) {\n+    \/\/trace_class_path(\"found Class-Path: \", cp_attr); FIXME\n+\n+    char sep = os::file_separator()[0];\n+    const char* dir_name = cs->path();\n+    const char* dir_tail = strrchr(dir_name, sep);\n+#ifdef _WINDOWS\n+    \/\/ On Windows, we also support forward slash as the file separator when locating entries in the classpath entry.\n+    const char* dir_tail2 = strrchr(dir_name, '\/');\n+    if (dir_tail == nullptr) {\n+      dir_tail = dir_tail2;\n+    } else if (dir_tail2 != nullptr && dir_tail2 > dir_tail) {\n+      dir_tail = dir_tail2;\n+    }\n+#endif\n+    int dir_len;\n+    if (dir_tail == nullptr) {\n+      dir_len = 0;\n+    } else {\n+      dir_len = pointer_delta_as_int(dir_tail, dir_name) + 1;\n+    }\n+\n+    \/\/ Split the cp_attr by spaces, and add each file\n+    char* file_start = cp_attr;\n+    char* end = file_start + strlen(file_start);\n+\n+    while (file_start < end) {\n+      char* file_end = strchr(file_start, ' ');\n+      if (file_end != nullptr) {\n+        *file_end = 0;\n+        file_end += 1;\n+      } else {\n+        file_end = end;\n+      }\n+\n+      size_t name_len = strlen(file_start);\n+      if (name_len > 0) {\n+        ResourceMark rm(current);\n+        size_t libname_len = dir_len + name_len;\n+        char* libname = NEW_RESOURCE_ARRAY(char, libname_len + 1);\n+        int n = os::snprintf(libname, libname_len + 1, \"%.*s%s\", dir_len, dir_name, file_start);\n+        assert((size_t)n == libname_len, \"Unexpected number of characters in string\");\n+\n+        \/\/ Avoid infinite recursion when two JAR files refer to each\n+        \/\/ other via cpattr.\n+        bool found_duplicate = false;\n+        for (int i = boot_cp_start_index(); i < tmp_array.length(); i++) {\n+          if (strcmp(tmp_array.at(i)->path(), libname) == 0) {\n+            found_duplicate = true;\n+            break;\n+          }\n+        }\n+        if (!found_duplicate) {\n+          add_class_location(current, tmp_array, libname, group, parse_manifest, \/*from_cpattr*\/true);\n+        }\n+      }\n+\n+      file_start = file_end;\n+    }\n+  }\n+}\n+\n+AOTClassLocation const* AOTClassLocationConfig::class_location_at(int index) const {\n+  return _class_locations->at(index);\n+}\n+\n+int AOTClassLocationConfig::get_module_shared_path_index(Symbol* location) const {\n+  if (location->starts_with(\"jrt:\", 4)) {\n+    assert(class_location_at(0)->is_modules_image(), \"sanity\");\n+    return 0;\n+  }\n+\n+  if (num_module_paths() == 0) {\n+    \/\/ The archive(s) were created without --module-path option\n+    return -1;\n+  }\n+\n+  if (!location->starts_with(\"file:\", 5)) {\n+    return -1;\n+  }\n+\n+  \/\/ skip_uri_protocol was also called during dump time -- see ClassLoaderExt::process_module_table()\n+  ResourceMark rm;\n+  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n+  for (int i = module_path_start_index(); i < module_path_end_index(); i++) {\n+    const AOTClassLocation* cs = class_location_at(i);\n+    assert(!cs->has_unnamed_module(), \"must be\");\n+    bool same = os::same_files(file, cs->path());\n+    log_debug(class, path)(\"get_module_shared_path_index (%d) %s : %s = %s\", i,\n+                           location->as_C_string(), cs->path(), same ? \"same\" : \"different\");\n+    if (same) {\n+      return i;\n+    }\n+  }\n+  return -1;\n+}\n+\n+\/\/ We allow non-empty dirs as long as no classes have been loaded from them.\n+void AOTClassLocationConfig::check_nonempty_dirs() const {\n+  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n+\n+  bool has_nonempty_dir = false;\n+  dumptime_iterate([&](AOTClassLocation* cs) {\n+    if (cs->index() > _max_used_index) {\n+      return false; \/\/ stop iterating\n+    }\n+    if (cs->is_dir()) {\n+      if (!os::dir_is_empty(cs->path())) {\n+        log_error(cds)(\"Error: non-empty directory '%s'\", cs->path());\n+        has_nonempty_dir = true;\n+      }\n+    }\n+    return true; \/\/ keep iterating\n+  });\n+\n+  if (has_nonempty_dir) {\n+    vm_exit_during_cds_dumping(\"Cannot have non-empty directory in paths\", nullptr);\n+  }\n+}\n+\n+AOTClassLocationConfig* AOTClassLocationConfig::write_to_archive() const {\n+  Array<AOTClassLocation*>* archived_copy = ArchiveBuilder::new_ro_array<AOTClassLocation*>(_class_locations->length());\n+  for (int i = 0; i < _class_locations->length(); i++) {\n+    archived_copy->at_put(i, _class_locations->at(i)->write_to_archive());\n+    ArchivePtrMarker::mark_pointer((address*)archived_copy->adr_at(i));\n+  }\n+\n+  AOTClassLocationConfig* dumped = (AOTClassLocationConfig*)ArchiveBuilder::ro_region_alloc(sizeof(AOTClassLocationConfig));\n+  memcpy(dumped, this, sizeof(AOTClassLocationConfig));\n+  dumped->_class_locations = archived_copy;\n+  ArchivePtrMarker::mark_pointer(&dumped->_class_locations);\n+\n+  return dumped;\n+}\n+\n+bool AOTClassLocationConfig::check_classpaths(bool is_boot_classpath, bool has_aot_linked_classes,\n+                                              int index_start, int index_end,\n+                                              ClassLocationStream& runtime_css,\n+                                              bool use_lcp_match, const char* runtime_lcp,\n+                                              size_t runtime_lcp_len) const {\n+  if (index_start >= index_end && runtime_css.is_empty()) { \/\/ nothing to check\n+    return true;\n+  }\n+\n+  ResourceMark rm;\n+  const char* which = is_boot_classpath ? \"boot\" : \"app\";\n+  LogTarget(Info, class, path) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print(\"Checking %s classpath\", which);\n+    ls.print_cr(\"%s\", use_lcp_match ? \" (with longest common prefix substitution)\" : \"\");\n+    ls.print(\"- expected : '\");\n+    print_dumptime_classpath(ls, index_start, index_end, use_lcp_match, _dumptime_lcp_len, runtime_lcp, runtime_lcp_len);\n+    ls.print_cr(\"'\");\n+    ls.print(\"- actual   : '\");\n+    runtime_css.print(&ls);\n+    ls.print_cr(\"'\");\n+  }\n+\n+  runtime_css.start();\n+  for (int i = index_start; i < index_end; i++) {\n+    ResourceMark rm;\n+    const AOTClassLocation* cs = class_location_at(i);\n+    const char* effective_dumptime_path = cs->path();\n+    if (use_lcp_match && _dumptime_lcp_len > 0) {\n+      effective_dumptime_path = substitute(effective_dumptime_path, _dumptime_lcp_len, runtime_lcp, runtime_lcp_len);\n+    }\n+\n+    log_info(class, path)(\"Checking '%s' %s%s\", effective_dumptime_path, cs->file_type_string(),\n+                          cs->from_cpattr() ? \" (from JAR manifest ClassPath attribute)\" : \"\");\n+    if (!cs->from_cpattr() && file_exists(effective_dumptime_path)) {\n+      if (!runtime_css.has_next()) {\n+        log_warning(cds)(\"%s classpath has fewer elements than expected\", which);\n+        return false;\n+      }\n+      const char* runtime_path = runtime_css.get_next();\n+      while (!file_exists(runtime_path) && runtime_css.has_next()) {\n+        runtime_path = runtime_css.get_next();\n+      }\n+      if (!os::same_files(effective_dumptime_path, runtime_path)) {\n+        log_warning(cds)(\"The name of %s classpath [%d] does not match: expected '%s', got '%s'\",\n+                         which, runtime_css.current(), effective_dumptime_path, runtime_path);\n+        return false;\n+      }\n+    }\n+\n+    if (!cs->check(effective_dumptime_path, has_aot_linked_classes)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ Check if the runtime boot classpath has more entries than the one stored in the archive and if the app classpath\n+  \/\/ or the module path requires validation.\n+  if (is_boot_classpath && runtime_css.has_next() && (need_to_check_app_classpath() || num_module_paths() > 0)) {\n+    \/\/ the check passes if all the extra runtime boot classpath entries are non-existent\n+    if (check_paths_existence(runtime_css)) {\n+      log_warning(cds)(\"boot classpath is longer than expected\");\n+      return false;\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+bool AOTClassLocationConfig::file_exists(const char* filename) const{\n+  struct stat st;\n+  return (os::stat(filename, &st) == 0 && st.st_size > 0);\n+}\n+\n+bool AOTClassLocationConfig::check_paths_existence(ClassLocationStream& runtime_css) const {\n+  bool exist = false;\n+  while (runtime_css.has_next()) {\n+    const char* path = runtime_css.get_next();\n+    if (file_exists(path)) {\n+      exist = true;\n+      break;\n+    }\n+  }\n+  return exist;\n+}\n+\n+bool AOTClassLocationConfig::check_module_paths(bool has_aot_linked_classes, int index_start, int index_end,\n+                                                ClassLocationStream& runtime_css,\n+                                                bool* has_extra_module_paths) const {\n+  if (index_start >= index_end && runtime_css.is_empty()) { \/\/ nothing to check\n+    return true;\n+  }\n+\n+  ResourceMark rm;\n+\n+  LogTarget(Info, class, path) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    ls.print_cr(\"Checking module paths\");\n+    ls.print(\"- expected : '\");\n+    print_dumptime_classpath(ls, index_start, index_end, false, 0, nullptr, 0);\n+    ls.print_cr(\"'\");\n+    ls.print(\"- actual   : '\");\n+    runtime_css.print(&ls);\n+    ls.print_cr(\"'\");\n+  }\n+\n+  \/\/ Make sure all the dumptime module paths exist and are unchanged\n+  for (int i = index_start; i < index_end; i++) {\n+    const AOTClassLocation* cs = class_location_at(i);\n+    const char* dumptime_path = cs->path();\n+\n+    assert(!cs->from_cpattr(), \"not applicable for module path\");\n+    log_info(class, path)(\"Checking '%s' %s\", dumptime_path, cs->file_type_string());\n+\n+    if (!cs->check(dumptime_path, has_aot_linked_classes)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ We allow runtime_css to be a superset of the module paths specified in dumptime. E.g.,\n+  \/\/ Dumptime:    A:C\n+  \/\/ Runtime:     A:B:C\n+  runtime_css.start();\n+  for (int i = index_start; i < index_end; i++) {\n+    const AOTClassLocation* cs = class_location_at(i);\n+    const char* dumptime_path = cs->path();\n+\n+    while (true) {\n+      if (!runtime_css.has_next()) {\n+        log_warning(cds)(\"module path has fewer elements than expected\");\n+        *has_extra_module_paths = true;\n+        return true;\n+      }\n+      \/\/ Both this->class_locations() and runtime_css are alphabetically sorted. Skip\n+      \/\/ items in runtime_css until we see dumptime_path.\n+      const char* runtime_path = runtime_css.get_next();\n+      if (!os::same_files(dumptime_path, runtime_path)) {\n+        *has_extra_module_paths = true;\n+        return true;\n+      } else {\n+        break;\n+      }\n+    }\n+  }\n+\n+  if (runtime_css.has_next()) {\n+    *has_extra_module_paths = true;\n+  }\n+\n+  return true;\n+}\n+\n+void AOTClassLocationConfig::print_dumptime_classpath(LogStream& ls, int index_start, int index_end,\n+                                                      bool do_substitute, size_t remove_prefix_len,\n+                                                      const char* prepend, size_t prepend_len) const {\n+  const char* sep = \"\";\n+  for (int i = index_start; i < index_end; i++) {\n+    ResourceMark rm;\n+    const AOTClassLocation* cs = class_location_at(i);\n+    const char* path = cs->path();\n+    if (!cs->from_cpattr()) {\n+      ls.print(\"%s\", sep);\n+      if (do_substitute) {\n+        path = substitute(path, remove_prefix_len, prepend, prepend_len);\n+      }\n+      ls.print(\"%s\", path);\n+      sep = os::path_separator();\n+    }\n+  }\n+}\n+\n+\/\/ Returned path is resource-allocated\n+const char* AOTClassLocationConfig::substitute(const char* path,         \/\/ start with this path (which was recorded from dump time)\n+                                               size_t remove_prefix_len, \/\/ remove this number of chars from the beginning\n+                                               const char* prepend,      \/\/ prepend this string\n+                                               size_t prepend_len) {     \/\/ length of the prepended string\n+  size_t len = strlen(path);\n+  assert(len > remove_prefix_len, \"sanity\");\n+  assert(prepend_len == strlen(prepend), \"sanity\");\n+  len -= remove_prefix_len;\n+  len += prepend_len;\n+\n+  char* buf = NEW_RESOURCE_ARRAY(char, len + 1);\n+  int n = os::snprintf(buf, len + 1, \"%s%s\", prepend, path + remove_prefix_len);\n+  assert(size_t(n) == len, \"sanity\");\n+\n+  return buf;\n+}\n+\n+\/\/ For performance, we avoid using LCP match if there's at least one\n+\/\/ AOTClassLocation can be matched exactly: this means all other AOTClassLocations must be\n+\/\/ matched exactly.\n+bool AOTClassLocationConfig::need_lcp_match(AllClassLocationStreams& all_css) const {\n+  if (app_cp_end_index() == boot_cp_start_index()) {\n+    \/\/ No need to use lcp-match when there are no boot\/app paths.\n+    \/\/ TODO: LCP-match not yet supported for modules.\n+    return false;\n+  }\n+\n+  if (need_lcp_match_helper(boot_cp_start_index(), boot_cp_end_index(), all_css.boot_cp()) &&\n+      need_lcp_match_helper(app_cp_start_index(), app_cp_end_index(), all_css.app_cp())) {\n+    return true;\n+  } else {\n+    return false;\n+  }\n+}\n+\n+bool AOTClassLocationConfig::need_lcp_match_helper(int start, int end, ClassLocationStream& css) const {\n+  int i = start;\n+  for (css.start(); i < end && css.has_next(); ) {\n+    const AOTClassLocation* cs = class_location_at(i++);\n+    const char* runtime_path = css.get_next();\n+    if (cs->must_exist() && os::same_files(cs->path(), runtime_path)) {\n+      \/\/ Most likely, we will come to here at the first iteration.\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+bool AOTClassLocationConfig::validate(bool has_aot_linked_classes, bool* has_extra_module_paths) const {\n+  ResourceMark rm;\n+  AllClassLocationStreams all_css;\n+\n+  const char* jrt = ClassLoader::get_jrt_entry()->name();\n+  bool success = class_location_at(0)->check(jrt, has_aot_linked_classes);\n+  log_info(class, path)(\"Modules image %s validation: %s\", jrt, success ? \"passed\" : \"failed\");\n+  if (!success) {\n+    return false;\n+  }\n+  if (class_locations()->length() == 1) {\n+    if ((module_path_start_index() >= module_path_end_index()) && Arguments::get_property(\"jdk.module.path\") != nullptr) {\n+      *has_extra_module_paths = true;\n+    } else {\n+      *has_extra_module_paths = false;\n+    }\n+  } else {\n+    bool use_lcp_match = need_lcp_match(all_css);\n+    const char* runtime_lcp;\n+    size_t runtime_lcp_len;\n+\n+    log_info(class, path)(\"Longest common prefix substitution in boot\/app classpath matching: %s\",\n+                          use_lcp_match ? \"yes\" : \"no\");\n+    if (use_lcp_match) {\n+      runtime_lcp = find_lcp(all_css.boot_and_app_cp(), runtime_lcp_len);\n+      log_info(class, path)(\"Longest common prefix: %s (%zu chars)\", runtime_lcp, runtime_lcp_len);\n+    } else {\n+      runtime_lcp = nullptr;\n+      runtime_lcp_len = 0;\n+    }\n+\n+    success = check_classpaths(true, has_aot_linked_classes, boot_cp_start_index(), boot_cp_end_index(), all_css.boot_cp(),\n+                               use_lcp_match, runtime_lcp, runtime_lcp_len);\n+    log_info(class, path)(\"Archived boot classpath validation: %s\", success ? \"passed\" : \"failed\");\n+\n+    if (success && need_to_check_app_classpath()) {\n+      success = check_classpaths(false, has_aot_linked_classes, app_cp_start_index(), app_cp_end_index(), all_css.app_cp(),\n+                                 use_lcp_match, runtime_lcp, runtime_lcp_len);\n+      log_info(class, path)(\"Archived app classpath validation: %s\", success ? \"passed\" : \"failed\");\n+    }\n+\n+    if (success) {\n+      success = check_module_paths(has_aot_linked_classes, module_path_start_index(), module_path_end_index(),\n+                                   all_css.module_path(), has_extra_module_paths);\n+      log_info(class, path)(\"Archived module path validation: %s%s\", success ? \"passed\" : \"failed\",\n+                            (*has_extra_module_paths) ? \" (extra module paths found)\" : \"\");\n+    }\n+\n+    if (runtime_lcp_len > 0) {\n+      os::free((void*)runtime_lcp);\n+    }\n+  }\n+\n+  if (success) {\n+    _runtime_instance = this;\n+  } else {\n+    const char* mismatch_msg = \"shared class paths mismatch\";\n+    const char* hint_msg = log_is_enabled(Info, class, path) ?\n+        \"\" : \" (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n+    if (RequireSharedSpaces && !PrintSharedArchiveAndExit) {\n+      log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n+      MetaspaceShared::unrecoverable_loading_error();\n+    } else {\n+      log_warning(cds)(\"%s%s\", mismatch_msg, hint_msg);\n+    }\n+  }\n+  return success;\n+}\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.cpp","additions":999,"deletions":0,"binary":false,"changes":999,"status":"added"},{"patch":"@@ -0,0 +1,269 @@\n+\/*\n+ * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_CDS_AOTCLASSLOCATION_HPP\n+#define SHARE_CDS_AOTCLASSLOCATION_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/array.hpp\"\n+#include \"utilities\/exceptions.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class AllClassLocationStreams;\n+class ClassLocationStream;\n+class LogStream;\n+\n+\/\/ An AOTClassLocation is a location where the application is configured to load Java classes\n+\/\/ from. It can be:\n+\/\/ - the location of $JAVA_HOME\/lib\/modules\n+\/\/ - an entry in -Xbootclasspath\/a\n+\/\/ - an entry in -classpath\n+\/\/ - a JAR file specified using --module-path.\n+\/\/\n+\/\/ AOTClassLocation is similar to java.security.CodeSource, except:\n+\/\/ - Only local files\/dirs are allowed. Directories must be empty. Network locations are not allowed.\n+\/\/ - No code signing information is recorded.\n+\/\/\n+\/\/ We avoid using pointers in AOTClassLocation to avoid runtime pointer relocation. Each AOTClassLocation\n+\/\/ is a variable-size structure:\n+\/\/    [ all fields specified below (sizeof(AOTClassLocation) bytes)          ]\n+\/\/    [ path (_path_length bytes, including the terminating zero)         ]\n+\/\/    [ manifest (_manifest_length bytes, including the terminating zero) ]\n+class AOTClassLocation {\n+public:\n+  enum class Group : int {\n+    MODULES_IMAGE,\n+    BOOT_CLASSPATH,\n+    APP_CLASSPATH,\n+    MODULE_PATH\n+  };\n+private:\n+  enum class FileType : int {\n+    NORMAL,\n+    DIR,\n+    NOT_EXIST\n+  };\n+  size_t   _path_length;     \/\/ does NOT include terminating zero\n+  size_t   _manifest_length; \/\/ does NOT include terminating zero\n+  bool     _check_time;\n+  bool     _from_cpattr;\n+  bool     _is_multi_release_jar; \/\/ is this a JAR file that has multi-release classes?\n+  FileType _file_type;\n+  Group    _group;\n+  int      _index; \/\/ index of this AOTClassLocation inside AOTClassLocationConfig::_class_locations\n+  time_t   _timestamp;\n+  int64_t  _filesize;\n+\n+  static size_t header_size()      { return sizeof(AOTClassLocation); } \/\/ bytes\n+  size_t path_offset()       const { return header_size(); }\n+  size_t manifest_offset()   const { return path_offset() + _path_length + 1; }\n+  static char* read_manifest(JavaThread* current, const char* path, size_t& manifest_length);\n+\n+public:\n+  static AOTClassLocation* allocate(JavaThread* current, const char* path, int index, Group group,\n+                                    bool from_cpattr = false, bool is_jrt = false);\n+\n+  size_t total_size()                const { return manifest_offset() + _manifest_length + 1; }\n+  const char* path()                 const { return ((const char*)this) + path_offset();  }\n+  size_t manifest_length()           const { return _manifest_length; }\n+  const char* manifest()             const { return ((const char*)this) + manifest_offset(); }\n+  bool must_exist()                  const { return _file_type != FileType::NOT_EXIST; }\n+  bool must_not_exist()              const { return _file_type == FileType::NOT_EXIST; }\n+  bool is_dir()                      const { return _file_type == FileType::DIR; }\n+  int index()                        const { return _index; }\n+  bool is_modules_image()            const { return _group == Group::MODULES_IMAGE; }\n+  bool from_boot_classpath()         const { return _group == Group::BOOT_CLASSPATH; }\n+  bool from_app_classpath()          const { return _group == Group::APP_CLASSPATH; }\n+  bool from_module_path()            const { return _group == Group::MODULE_PATH; }\n+  bool is_multi_release_jar()        const { return _is_multi_release_jar; }\n+\n+  \/\/ Only boot\/app classpaths can contain unnamed module\n+  bool has_unnamed_module()          const { return from_boot_classpath() || from_app_classpath(); }\n+\n+  char* get_cpattr() const;\n+  AOTClassLocation* write_to_archive() const;\n+\n+  \/\/ Returns true IFF this AOTClassLocation is discovered from the -classpath or -Xbootclasspath\/a by parsing the\n+  \/\/ \"Class-Path\" attribute of a JAR file.\n+  bool from_cpattr() const { return _from_cpattr; }\n+  const char* file_type_string() const;\n+  bool check(const char* runtime_path, bool has_aot_linked_classes) const;\n+};\n+\n+\/\/ AOTClassLocationConfig\n+\/\/\n+\/\/ Keep track of the set of AOTClassLocations used when an AOTCache is created.\n+\/\/ To load the AOTCache in a production run, the JVM must be using a compatible set of\n+\/\/ AOTClassLocations (subjected to AOTClassLocationConfig::validate()).\n+\/\/\n+\/\/ In general, validation is performed on the AOTClassLocations to ensure the code sources used\n+\/\/ during AOTCache creation are the same as when the AOTCache is used during runtime.\n+\/\/ Non-existent entries are recorded during AOTCache creation. Those non-existent entries,\n+\/\/ if they are specified at runtime, must not exist.\n+\/\/\n+\/\/ Some details on validation:\n+\/\/ - the boot classpath can be appended to at runtime if there's no app classpath and no\n+\/\/   module path specified when an AOTCache is created;\n+\/\/ - the app classpath can be appended to at runtime;\n+\/\/ - the module path at runtime can be a superset of the one specified during AOTCache creation.\n+\n+class AOTClassLocationConfig : public CHeapObj<mtClassShared> {\n+  using Group = AOTClassLocation::Group;\n+  using GrowableClassLocationArray = GrowableArrayCHeap<AOTClassLocation*, mtClassShared>;\n+\n+  \/\/ Note: both of the following are non-null if we are dumping a dynamic archive.\n+  static AOTClassLocationConfig* _dumptime_instance;\n+  static const AOTClassLocationConfig* _runtime_instance;\n+\n+  Array<AOTClassLocation*>* _class_locations; \/\/ jrt -> -Xbootclasspath\/a -> -classpath -> --module_path\n+  int _boot_classpath_end;\n+  int _app_classpath_end;\n+  int _module_end;\n+  bool _has_non_jar_modules;\n+  bool _has_platform_classes;\n+  bool _has_app_classes;\n+  int  _max_used_index;\n+  size_t _dumptime_lcp_len;\n+\n+  \/\/ accessors\n+  Array<AOTClassLocation*>* class_locations() const { return _class_locations; }\n+\n+  void parse(JavaThread* current, GrowableClassLocationArray& tmp_array, ClassLocationStream& css,\n+             Group group, bool parse_manifest);\n+  void add_class_location(JavaThread* current, GrowableClassLocationArray& tmp_array, const char* path,\n+                       Group group, bool parse_manifest, bool from_cpattr);\n+  void dumptime_init_helper(TRAPS);\n+\n+  bool check_classpaths(bool is_boot_classpath, bool has_aot_linked_classes,\n+                        int index_start, int index_end, ClassLocationStream& runtime_css,\n+                        bool use_lcp_match, const char* runtime_lcp, size_t runtime_lcp_len) const;\n+  bool check_module_paths(bool has_aot_linked_classes, int index_start, int index_end, ClassLocationStream& runtime_css,\n+                          bool* has_extra_module_paths) const;\n+  bool file_exists(const char* filename) const;\n+  bool check_paths_existence(ClassLocationStream& runtime_css) const;\n+\n+  static const char* substitute(const char* path, size_t remove_prefix_len,\n+                                const char* prepend, size_t prepend_len);\n+  static const char* find_lcp(ClassLocationStream& css, size_t& lcp_len);\n+  bool need_lcp_match(AllClassLocationStreams& all_css) const;\n+  bool need_lcp_match_helper(int start, int end, ClassLocationStream& css) const;\n+\n+  template <typename FUNC> void dumptime_iterate_helper(FUNC func) const {\n+    assert(_class_locations != nullptr, \"sanity\");\n+    int n = _class_locations->length();\n+    for (int i = 0; i < n; i++) {\n+      if (!func(_class_locations->at(i))) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  template <typename FUNC> void iterate(FUNC func) const {\n+    int n = class_locations()->length();\n+    for (int i = 0; i < n; i++) {\n+      if (!func(class_locations()->at(i))) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  void check_nonempty_dirs() const;\n+  bool need_to_check_app_classpath() const {\n+    return (num_app_classpaths() > 0) && (_max_used_index >= app_cp_start_index()) && has_platform_or_app_classes();\n+  }\n+\n+  void print_dumptime_classpath(LogStream& ls, int index_start, int index_limit,\n+                                bool do_substitute, size_t remove_prefix_len,\n+                                const char* prepend, size_t prepend_len) const;\n+public:\n+  static AOTClassLocationConfig* dumptime() {\n+    assert(_dumptime_instance != nullptr, \"can only be called when dumping an AOT cache\");\n+    return _dumptime_instance;\n+  }\n+\n+  static const AOTClassLocationConfig* runtime() {\n+    assert(_runtime_instance != nullptr, \"can only be called when using an AOT cache\");\n+    return _runtime_instance;\n+  }\n+\n+  \/\/ Common accessors\n+  int boot_cp_start_index()          const { return 1; }\n+  int boot_cp_end_index()            const { return _boot_classpath_end; }\n+  int app_cp_start_index()           const { return boot_cp_end_index(); }\n+  int app_cp_end_index()             const { return _app_classpath_end; }\n+  int module_path_start_index()      const { return app_cp_end_index(); }\n+  int module_path_end_index()        const { return _module_end; }\n+  bool has_platform_or_app_classes() const { return _has_app_classes || _has_platform_classes; }\n+  bool has_non_jar_modules()         const { return _has_non_jar_modules; }\n+  int num_boot_classpaths()          const { return boot_cp_end_index() - boot_cp_start_index(); }\n+  int num_app_classpaths()           const { return app_cp_end_index() - app_cp_start_index(); }\n+  int num_module_paths()             const { return module_path_end_index() - module_path_start_index(); }\n+\n+  int length() const {\n+    return _class_locations->length();\n+  }\n+\n+  const AOTClassLocation* class_location_at(int index) const;\n+  int get_module_shared_path_index(Symbol* location) const;\n+\n+  \/\/ Functions used only during dumptime\n+  static void dumptime_init(JavaThread* current);\n+\n+  static void dumptime_set_has_app_classes() {\n+    _dumptime_instance->_has_app_classes = true;\n+  }\n+\n+  static void dumptime_set_has_platform_classes() {\n+    _dumptime_instance->_has_platform_classes = true;\n+  }\n+\n+  static void dumptime_update_max_used_index(int index) {\n+    if (_dumptime_instance == nullptr) {\n+      assert(index == 0, \"sanity\");\n+    } else if (_dumptime_instance->_max_used_index < index) {\n+      _dumptime_instance->_max_used_index = index;\n+    }\n+  }\n+\n+  static void dumptime_check_nonempty_dirs() {\n+    _dumptime_instance->check_nonempty_dirs();\n+  }\n+\n+  static bool dumptime_is_ready() {\n+    return _dumptime_instance != nullptr;\n+  }\n+  template <typename FUNC> static void dumptime_iterate(FUNC func) {\n+    _dumptime_instance->dumptime_iterate_helper(func);\n+  }\n+\n+  AOTClassLocationConfig* write_to_archive() const;\n+\n+  \/\/ Functions used only during runtime\n+  bool validate(bool has_aot_linked_classes, bool* has_extra_module_paths) const;\n+};\n+\n+\n+#endif \/\/ SHARE_CDS_AOTCLASSLOCATION_HPP\n","filename":"src\/hotspot\/share\/cds\/aotClassLocation.hpp","additions":269,"deletions":0,"binary":false,"changes":269,"status":"added"},{"patch":"@@ -1,992 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#include \"cds\/aotCodeSource.hpp\"\n-#include \"cds\/archiveBuilder.hpp\"\n-#include \"cds\/cdsConfig.hpp\"\n-#include \"cds\/dynamicArchive.hpp\"\n-#include \"cds\/filemap.hpp\"\n-#include \"cds\/metaspaceShared.hpp\"\n-#include \"cds\/serializeClosure.hpp\"\n-#include \"classfile\/classLoader.hpp\"\n-#include \"classfile\/classLoaderData.hpp\"\n-#include \"logging\/log.hpp\"\n-#include \"logging\/logStream.hpp\"\n-#include \"memory\/metadataFactory.hpp\"\n-#include \"memory\/metaspaceClosure.hpp\"\n-#include \"memory\/resourceArea.hpp\"\n-#include \"oops\/array.hpp\"\n-#include \"oops\/objArrayKlass.hpp\"\n-#include \"runtime\/arguments.hpp\"\n-#include \"utilities\/classpathStream.hpp\"\n-#include \"utilities\/formatBuffer.hpp\"\n-#include \"utilities\/stringUtils.hpp\"\n-\n-#include <sys\/stat.h>\n-#include <errno.h>\n-\n-AOTCodeSourceConfig* AOTCodeSourceConfig::_dumptime_instance = nullptr;\n-const AOTCodeSourceConfig* AOTCodeSourceConfig::_runtime_instance = nullptr;\n-\n-\/\/ A CodeSourceStream represents a list of code sources, which can be iterated using\n-\/\/ start() and has_next().\n-class CodeSourceStream {\n-protected:\n-  GrowableArray<const char*> _array;\n-  int _current;\n-\n-  \/\/ Add one path to this stream.\n-  void add_one_path(const char* path) {\n-    _array.append(path);\n-  }\n-\n-  \/\/ Add all paths specified in cp; cp must be from -classpath or -Xbootclasspath\/a.\n-  void add_paths_in_classpath(const char* cp) {\n-    ClasspathStream cp_stream(cp);\n-    while (cp_stream.has_next()) {\n-      add_one_path(cp_stream.get_next());\n-    }\n-  }\n-\n-public:\n-  CodeSourceStream() : _array(), _current(0) {}\n-\n-  void print(outputStream* st) const {\n-    const char* sep = \"\";\n-    for (int i = 0; i < _array.length(); i++) {\n-      st->print(\"%s%s\", sep, _array.at(i));\n-      sep = os::path_separator();\n-    }\n-  }\n-\n-  void add(CodeSourceStream& css) {\n-    for (css.start(); css.has_next();) {\n-      add_one_path(css.get_next());\n-    }\n-  }\n-\n-  \/\/ Iteration\n-  void start() { _current = 0; }\n-  bool has_next() const { return _current < _array.length(); }\n-  const char* get_next() {\n-    return _array.at(_current++);\n-  }\n-\n-  int current() const { return _current; }\n-  bool is_empty() const { return _array.length() == 0; }\n-};\n-\n-class BootCpCodeSourceStream : public CodeSourceStream {\n-public:\n-  BootCpCodeSourceStream() : CodeSourceStream() {\n-    \/\/ Arguments::get_boot_class_path() contains $JAVA_HOME\/lib\/modules, but we treat that separately\n-    for (const char* bootcp = Arguments::get_boot_class_path(); *bootcp != '\\0'; ++bootcp) {\n-      if (*bootcp == *os::path_separator()) {\n-        ++bootcp;\n-        add_paths_in_classpath(bootcp);\n-        break;\n-      }\n-    }\n-  }\n-};\n-\n-class AppCpCodeSourceStream : public CodeSourceStream {\n-public:\n-  AppCpCodeSourceStream() : CodeSourceStream() {\n-    const char* appcp = Arguments::get_appclasspath();\n-    if (strcmp(appcp, \".\") == 0) {\n-      appcp = \"\";\n-    }\n-    add_paths_in_classpath(appcp);\n-  }\n-};\n-\n-class ModulePathCodeSourceStream : public CodeSourceStream {\n-  bool _has_non_jar_modules;\n-public:\n-  ModulePathCodeSourceStream();\n-  bool has_non_jar_modules() { return _has_non_jar_modules; }\n-};\n-\n-\/\/ AllCodeSourceStreams is used to iterate over all the code sources that\n-\/\/ are available to the application from -Xbootclasspath, -classpath and --module-path.\n-\/\/ When creating an AOT cache, we store the contents from AllCodeSourceStreams\n-\/\/ into an array of AOTCodeSources. See AOTCodeSourceConfig::dumptime_init_helper().\n-\/\/ When loading the AOT cache in a production run, we compare the contents of the\n-\/\/ stored AOTCodeSources against the current AllCodeSourceStreams to determine whether\n-\/\/ the AOT cache is compatible with the current JVM. See AOTCodeSourceConfig::validate().\n-class AllCodeSourceStreams {\n-  BootCpCodeSourceStream _boot_cp;          \/\/ Specified by -Xbootclasspath\/a\n-  AppCpCodeSourceStream _app_cp;            \/\/ Specified by -classpath\n-  ModulePathCodeSourceStream _module_path;  \/\/ Specified by --module-path\n-  CodeSourceStream _boot_and_app_cp;        \/\/ Convenience for iterating over both _boot and _app\n-public:\n-  BootCpCodeSourceStream& boot_cp()             { return _boot_cp; }\n-  AppCpCodeSourceStream& app_cp()               { return _app_cp; }\n-  ModulePathCodeSourceStream& module_path()     { return _module_path; }\n-  CodeSourceStream& boot_and_app_cp()           { return _boot_and_app_cp; }\n-\n-  AllCodeSourceStreams() : _boot_cp(), _app_cp(), _module_path(), _boot_and_app_cp() {\n-    _boot_and_app_cp.add(_boot_cp);\n-    _boot_and_app_cp.add(_app_cp);\n-  }\n-};\n-\n-static bool has_jar_suffix(const char* filename) {\n-  \/\/ In jdk.internal.module.ModulePath.readModule(), it checks for the \".jar\" suffix.\n-  \/\/ Performing the same check here.\n-  const char* dot = strrchr(filename, '.');\n-  if (dot != nullptr && strcmp(dot + 1, \"jar\") == 0) {\n-    return true;\n-  }\n-  return false;\n-}\n-\n-static int compare_module_path_by_name(const char** p1, const char** p2) {\n-  return strcmp(*p1, *p2);\n-}\n-\n-ModulePathCodeSourceStream::ModulePathCodeSourceStream() : CodeSourceStream(), _has_non_jar_modules(false) {\n-  \/\/ Note: for handling of --module-path, see\n-  \/\/   https:\/\/openjdk.org\/jeps\/261#Module-paths\n-  \/\/   https:\/\/docs.oracle.com\/en\/java\/javase\/23\/docs\/api\/java.base\/java\/lang\/module\/ModuleFinder.html#of(java.nio.file.Path...)\n-\n-  const char* jdk_module_path = Arguments::get_property(\"jdk.module.path\");\n-  if (jdk_module_path == nullptr) {\n-    return;\n-  }\n-\n-  ClasspathStream cp_stream(jdk_module_path);\n-  while (cp_stream.has_next()) {\n-    const char* path = cp_stream.get_next();\n-    DIR* dirp = os::opendir(path);\n-    if (dirp == nullptr && errno == ENOTDIR && has_jar_suffix(path)) {\n-      add_one_path(path);\n-    } else if (dirp != nullptr) {\n-      struct dirent* dentry;\n-      bool found_jar = false;\n-      while ((dentry = os::readdir(dirp)) != nullptr) {\n-        const char* file_name = dentry->d_name;\n-        if (has_jar_suffix(file_name)) {\n-          size_t full_name_len = strlen(path) + strlen(file_name) + strlen(os::file_separator()) + 1;\n-          char* full_name = NEW_RESOURCE_ARRAY(char, full_name_len);\n-          int n = os::snprintf(full_name, full_name_len, \"%s%s%s\", path, os::file_separator(), file_name);\n-          assert((size_t)n == full_name_len - 1, \"Unexpected number of characters in string\");\n-          add_one_path(full_name);\n-          found_jar = true;\n-        } else if (strcmp(file_name, \".\") != 0 && strcmp(file_name, \"..\") != 0) {\n-          \/\/ Found some non jar entries\n-          _has_non_jar_modules = true;\n-          log_info(class, path)(\"Found non-jar path: '%s%s%s'\", path, os::file_separator(), file_name);\n-        }\n-      }\n-      if (!found_jar) {\n-        log_info(class, path)(\"Found exploded module path: '%s'\", path);\n-        _has_non_jar_modules = true;\n-      }\n-      os::closedir(dirp);\n-    } else {\n-      _has_non_jar_modules = true;\n-    }\n-  }\n-\n-  _array.sort(compare_module_path_by_name);\n-}\n-\n-AOTCodeSource* AOTCodeSource::allocate(JavaThread* current, const char* path, int index,\n-                                       Group group, bool from_cpattr, bool is_jrt) {\n-  size_t path_length = 0;\n-  size_t manifest_length = 0;\n-  bool check_time = false;\n-  time_t timestamp = 0;\n-  int64_t filesize = 0;\n-  FileType type = FileType::NORMAL;\n-  \/\/ Do not record the actual path of the jrt, as the entire JDK can be moved to a different\n-  \/\/ directory.\n-  const char* recorded_path = is_jrt ? \"\" : path;\n-  path_length = strlen(recorded_path);\n-\n-  struct stat st;\n-  if (os::stat(path, &st) == 0) {\n-    if ((st.st_mode & S_IFMT) == S_IFDIR) {\n-      type = FileType::DIR;\n-    } else {\n-      timestamp = st.st_mtime;\n-      filesize = st.st_size;\n-\n-      \/\/ The timestamp of $JAVA_HOME\/lib\/modules is not checked at runtime.\n-      check_time = !is_jrt;\n-    }\n-#ifdef _WINDOWS\n-  } else if (errno == ERROR_FILE_NOT_FOUND || errno == ERROR_PATH_NOT_FOUND) {\n-    \/\/ On Windows, the errno could be ERROR_PATH_NOT_FOUND (3) in case the directory\n-    \/\/ path doesn't exist.\n-    type = FileType::NOT_EXIST;\n-#endif\n-  } else if (errno == ENOENT) {\n-    \/\/ We allow the file to not exist, as long as it also doesn't exist during runtime.\n-    type = FileType::NOT_EXIST;\n-  } else {\n-    log_error(cds)(\"Unable to open file %s.\", path);\n-    MetaspaceShared::unrecoverable_loading_error();\n-  }\n-\n-  ResourceMark rm(current);\n-  char* manifest = nullptr;\n-\n-  if (!is_jrt && type == FileType::NORMAL) {\n-    manifest = read_manifest(current, path, manifest_length); \/\/ resource allocated\n-  }\n-\n-  size_t cs_size = header_size() +\n-    + path_length + 1 \/* nul-terminated *\/\n-    + manifest_length + 1; \/* nul-terminated *\/\n-\n-  AOTCodeSource* cs = (AOTCodeSource*)os::malloc(cs_size, mtClassShared);\n-  memset(cs, 0, cs_size);\n-  cs->_path_length = path_length;\n-  cs->_manifest_length = manifest_length;\n-  cs->_check_time = check_time;\n-  cs->_from_cpattr = from_cpattr;\n-  cs->_timestamp = timestamp;\n-  cs->_filesize = filesize;\n-  cs->_file_type = type;\n-  cs->_group = group;\n-  cs->_index = index;\n-\n-  strcpy(((char*)cs) + cs->path_offset(), recorded_path);\n-  if (manifest_length > 0) {\n-    memcpy(((char*)cs) + cs->manifest_offset(), manifest, manifest_length);\n-  }\n-  assert(*(cs->manifest() + cs->manifest_length()) == '\\0', \"should be nul-terminated\");\n-\n-  if (strstr(cs->manifest(), \"Multi-Release: true\") != nullptr) {\n-    cs->_is_multi_release_jar = true;\n-  }\n-\n-  if (strstr(cs->manifest(), \"Extension-List:\") != nullptr) {\n-    vm_exit_during_cds_dumping(err_msg(\"-Xshare:dump does not support Extension-List in JAR manifest: %s\", path));\n-  }\n-\n-  return cs;\n-}\n-\n-char* AOTCodeSource::read_manifest(JavaThread* current, const char* path, size_t& manifest_length) {\n-  manifest_length = 0;\n-\n-  struct stat st;\n-  if (os::stat(path, &st) != 0) {\n-    return nullptr;\n-  }\n-\n-  ClassPathEntry* cpe = ClassLoader::create_class_path_entry(current, path, &st);\n-  if (cpe == nullptr) {\n-    \/\/ <path> is a file, but not a JAR file\n-    return nullptr;\n-  }\n-  assert(cpe->is_jar_file(), \"should not be called with a directory\");\n-\n-  const char* name = \"META-INF\/MANIFEST.MF\";\n-  char* manifest;\n-  jint size;\n-  manifest = (char*) ((ClassPathZipEntry*)cpe)->open_entry(current, name, &size, true);\n-\n-  if (manifest == nullptr || size <= 0) { \/\/ No Manifest\n-    manifest_length = 0;\n-  } else {\n-    manifest_length = (size_t)size;\n-  }\n-\n-  delete cpe;\n-  return manifest;\n-}\n-\n-\/\/ The result is resource allocated.\n-char* AOTCodeSource::get_cpattr() const {\n-  if (_manifest_length == 0) {\n-    return nullptr;\n-  }\n-\n-  size_t buf_size = _manifest_length + 1;\n-  char* buf = NEW_RESOURCE_ARRAY(char, buf_size);\n-  memcpy(buf, manifest(), _manifest_length);\n-  buf[_manifest_length] = 0; \/\/ make sure it's 0-terminated\n-\n-  \/\/ See http:\/\/docs.oracle.com\/javase\/6\/docs\/technotes\/guides\/jar\/jar.html#JAR%20Manifest\n-  \/\/ Replace all CR\/LF and CR with LF\n-  StringUtils::replace_no_expand(buf, \"\\r\\n\", \"\\n\");\n-  \/\/ Remove all new-line continuation (remove all \"\\n \" substrings)\n-  StringUtils::replace_no_expand(buf, \"\\n \", \"\");\n-\n-  const char* tag = \"Class-Path: \";\n-  size_t tag_len = strlen(tag);\n-  char* found = nullptr;\n-  char* line_start = buf;\n-  char* end = buf + _manifest_length;\n-\n-  assert(*end == 0, \"must be nul-terminated\");\n-\n-  while (line_start < end) {\n-    char* line_end = strchr(line_start, '\\n');\n-    if (line_end == nullptr) {\n-      \/\/ JAR spec require the manifest file to be terminated by a new line.\n-      break;\n-    }\n-    if (strncmp(tag, line_start, tag_len) == 0) {\n-      if (found != nullptr) {\n-        \/\/ Same behavior as jdk\/src\/share\/classes\/java\/util\/jar\/Attributes.java\n-        \/\/ If duplicated entries are found, the last one is used.\n-        log_warning(cds)(\"Warning: Duplicate name in Manifest: %s.\\n\"\n-                         \"Ensure that the manifest does not have duplicate entries, and\\n\"\n-                         \"that blank lines separate individual sections in both your\\n\"\n-                         \"manifest and in the META-INF\/MANIFEST.MF entry in the jar file:\\n%s\\n\", tag, path());\n-      }\n-      found = line_start + tag_len;\n-      assert(found <= line_end, \"sanity\");\n-      *line_end = '\\0';\n-    }\n-    line_start = line_end + 1;\n-  }\n-\n-  return found;\n-}\n-\n-AOTCodeSource* AOTCodeSource::write_to_archive() const {\n-  AOTCodeSource* archived_copy = (AOTCodeSource*)ArchiveBuilder::ro_region_alloc(total_size());\n-  memcpy((char*)archived_copy, (char*)this, total_size());\n-  return archived_copy;\n-}\n-\n-const char* AOTCodeSource::file_type_string() const {\n-  switch (_file_type) {\n-  case FileType::NORMAL: return \"file\";\n-  case FileType::DIR: return \"dir\";\n-  case FileType::NOT_EXIST: default: return \"not-exist\";\n-  }\n-}\n-\n-bool AOTCodeSource::check(const char* runtime_path, bool has_aot_linked_classes) const {\n-  struct stat st;\n-  if (os::stat(runtime_path, &st) != 0) {\n-    if (_file_type != FileType::NOT_EXIST) {\n-      log_warning(cds)(\"Required classpath entry does not exist: %s\", runtime_path);\n-      return false;\n-    }\n-  } else if ((st.st_mode & S_IFMT) == S_IFDIR) {\n-    if (_file_type == FileType::NOT_EXIST) {\n-      log_warning(cds)(\"'%s' must not exist\", runtime_path);\n-      return false;\n-    }\n-    if (_file_type == FileType::NORMAL) {\n-      log_warning(cds)(\"'%s' must be a file\", runtime_path);\n-      return false;\n-    }\n-    if (!os::dir_is_empty(runtime_path)) {\n-      log_warning(cds)(\"directory is not empty: '%s'\", runtime_path);\n-      return false;\n-    }\n-  } else {\n-    if (_file_type == FileType::NOT_EXIST) {\n-      log_warning(cds)(\"'%s' must not exist\", runtime_path);\n-      if (has_aot_linked_classes) {\n-        log_error(cds)(\"CDS archive has aot-linked classes. It cannot be used because the \"\n-                       \"file %s exists\", runtime_path);\n-        return false;\n-      } else {\n-        log_warning(cds)(\"Archived non-system classes are disabled because the \"\n-                         \"file %s exists\", runtime_path);\n-        FileMapInfo::current_info()->set_has_platform_or_app_classes(false);\n-        if (DynamicArchive::is_mapped()) {\n-          FileMapInfo::dynamic_info()->set_has_platform_or_app_classes(false);\n-        }\n-      }\n-    }\n-    if (_file_type == FileType::DIR) {\n-      log_warning(cds)(\"'%s' must be a directory\", runtime_path);\n-      return false;\n-    }\n-    bool size_differs = _filesize != st.st_size;\n-    bool time_differs = _check_time && (_timestamp != st.st_mtime);\n-    if (size_differs || time_differs) {\n-      log_warning(cds)(\"This file is not the one used while building the shared archive file: '%s'%s%s\",\n-                       runtime_path,\n-                       time_differs ? \", timestamp has changed\" : \"\",\n-                       size_differs ? \", size has changed\" : \"\");\n-      return false;\n-    }\n-  }\n-\n-  log_info(class, path)(\"ok\");\n-  return true;\n-}\n-\n-void AOTCodeSourceConfig::dumptime_init(TRAPS) {\n-  assert(CDSConfig::is_dumping_archive(), \"\");\n-  _dumptime_instance = NEW_C_HEAP_OBJ(AOTCodeSourceConfig, mtClassShared);\n-  _dumptime_instance->dumptime_init_helper(CHECK);\n-}\n-\n-void AOTCodeSourceConfig::dumptime_init_helper(TRAPS) {\n-  ResourceMark rm;\n-  GrowableCodeSourceArray tmp_array;\n-  AllCodeSourceStreams all_css;\n-\n-  AOTCodeSource* jrt = AOTCodeSource::allocate(THREAD, ClassLoader::get_jrt_entry()->name(),\n-                                               0, Group::MODULES_IMAGE,\n-                                               \/*from_cpattr*\/false, \/*is_jrt*\/true);\n-  tmp_array.append(jrt);\n-\n-  parse(THREAD, tmp_array, all_css.boot_cp(), Group::BOOT_CLASSPATH, \/*parse_manifest*\/true);\n-  _boot_classpath_end = tmp_array.length();\n-\n-  parse(THREAD, tmp_array, all_css.app_cp(), Group::APP_CLASSPATH, \/*parse_manifest*\/true);\n-  _app_classpath_end = tmp_array.length();\n-\n-  parse(THREAD, tmp_array, all_css.module_path(), Group::MODULE_PATH, \/*parse_manifest*\/false);\n-  _module_end = tmp_array.length();\n-\n-  _code_sources =  MetadataFactory::new_array<AOTCodeSource*>(ClassLoaderData::the_null_class_loader_data(),\n-                                                               tmp_array.length(), CHECK);\n-  for (int i = 0; i < tmp_array.length(); i++) {\n-    _code_sources->at_put(i, tmp_array.at(i));\n-  }\n-\n-  const char* lcp = find_lcp(all_css.boot_and_app_cp(), _dumptime_lcp_len);\n-  if (_dumptime_lcp_len > 0) {\n-    os::free((void*)lcp);\n-    log_info(class, path)(\"Longest common prefix = %s (%zu chars)\", lcp, _dumptime_lcp_len);\n-  } else {\n-    assert(_dumptime_lcp_len == 0, \"sanity\");\n-    log_info(class, path)(\"Longest common prefix = <none> (0 chars)\");\n-  }\n-\n-  _has_non_jar_modules = all_css.module_path().has_non_jar_modules();\n-  _has_platform_classes = false;\n-  _has_app_classes = false;\n-  _max_used_index = 0;\n-}\n-\n-\/\/ Find the longest common prefix of two paths, up to max_lcp_len.\n-\/\/ E.g.   p1 = \"\/a\/b\/foo\"\n-\/\/        p2 = \"\/a\/b\/bar\"\n-\/\/        max_lcp_len = 3\n-\/\/ -> returns 3\n-static size_t find_lcp_of_two_paths(const char* p1, const char* p2, size_t max_lcp_len) {\n-  size_t lcp_len = 0;\n-  char sep = os::file_separator()[0];\n-  for (size_t i = 0; ; i++) {\n-    char c1 = *p1++;\n-    char c2 = *p2++;\n-    if (c1 == 0 || c2 == 0 || c1 != c2) {\n-      break;\n-    }\n-    if (c1 == sep) {\n-      lcp_len = i + 1;\n-      assert(lcp_len <= max_lcp_len, \"sanity\");\n-      if (lcp_len == max_lcp_len) {\n-        break;\n-      }\n-    }\n-  }\n-  return lcp_len;\n-}\n-\n-\/\/ cheap-allocated if lcp_len > 0\n-const char* AOTCodeSourceConfig::find_lcp(CodeSourceStream& css, size_t& lcp_len) {\n-  const char* first_path = nullptr;\n-  char sep = os::file_separator()[0];\n-\n-  for (css.start(); css.has_next(); ) {\n-    const char* path = css.get_next();\n-    if (first_path == nullptr) {\n-      first_path = path;\n-      const char* p = strrchr(first_path, sep);\n-      if (p == nullptr) {\n-        lcp_len = 0;\n-        return \"\";\n-      } else {\n-        lcp_len = p - first_path + 1;\n-      }\n-    } else {\n-      lcp_len = find_lcp_of_two_paths(first_path, path, lcp_len);\n-      if (lcp_len == 0) {\n-        return \"\";\n-      }\n-    }\n-  }\n-\n-  if (first_path != nullptr && lcp_len > 0) {\n-    char* lcp = NEW_C_HEAP_ARRAY(char, lcp_len + 1, mtClassShared);\n-    lcp[0] = 0;\n-    strncat(lcp, first_path, lcp_len);\n-    return lcp;\n-  } else {\n-    lcp_len = 0;\n-    return \"\";\n-  }\n-}\n-\n-void AOTCodeSourceConfig::parse(JavaThread* current, GrowableCodeSourceArray& tmp_array,\n-                                CodeSourceStream& css, Group group, bool parse_manifest) {\n-  for (css.start(); css.has_next(); ) {\n-    add_code_source(current, tmp_array, css.get_next(), group, parse_manifest, \/*from_cpattr*\/false);\n-  }\n-}\n-\n-void AOTCodeSourceConfig::add_code_source(JavaThread* current, GrowableCodeSourceArray& tmp_array,\n-                                          const char* path, Group group, bool parse_manifest, bool from_cpattr) {\n-  AOTCodeSource* cs = AOTCodeSource::allocate(current, path, tmp_array.length(), group, from_cpattr);\n-  tmp_array.append(cs);\n-\n-  if (!parse_manifest) {\n-    \/\/ parse_manifest is true for -classpath and -Xbootclasspath\/a, and false for --module-path.\n-    return;\n-  }\n-\n-  ResourceMark rm;\n-  char* cp_attr = cs->get_cpattr(); \/\/ resource allocated\n-  if (cp_attr != nullptr && strlen(cp_attr) > 0) {\n-    \/\/trace_class_path(\"found Class-Path: \", cp_attr); FIXME\n-\n-    char sep = os::file_separator()[0];\n-    const char* dir_name = cs->path();\n-    const char* dir_tail = strrchr(dir_name, sep);\n-#ifdef _WINDOWS\n-    \/\/ On Windows, we also support forward slash as the file separator when locating entries in the classpath entry.\n-    const char* dir_tail2 = strrchr(dir_name, '\/');\n-    if (dir_tail == nullptr) {\n-      dir_tail = dir_tail2;\n-    } else if (dir_tail2 != nullptr && dir_tail2 > dir_tail) {\n-      dir_tail = dir_tail2;\n-    }\n-#endif\n-    int dir_len;\n-    if (dir_tail == nullptr) {\n-      dir_len = 0;\n-    } else {\n-      dir_len = pointer_delta_as_int(dir_tail, dir_name) + 1;\n-    }\n-\n-    \/\/ Split the cp_attr by spaces, and add each file\n-    char* file_start = cp_attr;\n-    char* end = file_start + strlen(file_start);\n-\n-    while (file_start < end) {\n-      char* file_end = strchr(file_start, ' ');\n-      if (file_end != nullptr) {\n-        *file_end = 0;\n-        file_end += 1;\n-      } else {\n-        file_end = end;\n-      }\n-\n-      size_t name_len = strlen(file_start);\n-      if (name_len > 0) {\n-        ResourceMark rm(current);\n-        size_t libname_len = dir_len + name_len;\n-        char* libname = NEW_RESOURCE_ARRAY(char, libname_len + 1);\n-        int n = os::snprintf(libname, libname_len + 1, \"%.*s%s\", dir_len, dir_name, file_start);\n-        assert((size_t)n == libname_len, \"Unexpected number of characters in string\");\n-\n-        \/\/ Avoid infinite recursion when two JAR files refer to each\n-        \/\/ other via cpattr.\n-        bool found_duplicate = false;\n-        for (int i = boot_cp_start_index(); i < tmp_array.length(); i++) {\n-          if (strcmp(tmp_array.at(i)->path(), libname) == 0) {\n-            found_duplicate = true;\n-            break;\n-          }\n-        }\n-        if (!found_duplicate) {\n-          add_code_source(current, tmp_array, libname, group, parse_manifest, \/*from_cpattr*\/true);\n-        }\n-      }\n-\n-      file_start = file_end;\n-    }\n-  }\n-}\n-\n-AOTCodeSource const* AOTCodeSourceConfig::code_source_at(int index) const {\n-  return _code_sources->at(index);\n-}\n-\n-int AOTCodeSourceConfig::get_module_shared_path_index(Symbol* location) const {\n-  if (location->starts_with(\"jrt:\", 4)) {\n-    assert(code_source_at(0)->is_modules_image(), \"sanity\");\n-    return 0;\n-  }\n-\n-  if (num_module_paths() == 0) {\n-    \/\/ The archive(s) were created without --module-path option\n-    return -1;\n-  }\n-\n-  if (!location->starts_with(\"file:\", 5)) {\n-    return -1;\n-  }\n-\n-  \/\/ skip_uri_protocol was also called during dump time -- see ClassLoaderExt::process_module_table()\n-  ResourceMark rm;\n-  const char* file = ClassLoader::uri_to_path(location->as_C_string());\n-  for (int i = module_path_start_index(); i < module_path_end_index(); i++) {\n-    const AOTCodeSource* cs = code_source_at(i);\n-    assert(!cs->has_unnamed_module(), \"must be\");\n-    bool same = os::same_files(file, cs->path());\n-    log_debug(class, path)(\"get_module_shared_path_index (%d) %s : %s = %s\", i,\n-                           location->as_C_string(), cs->path(), same ? \"same\" : \"different\");\n-    if (same) {\n-      return i;\n-    }\n-  }\n-  return -1;\n-}\n-\n-\/\/ We allow non-empty dirs as long as no classes have been loaded from them.\n-void AOTCodeSourceConfig::check_nonempty_dirs() const {\n-  assert(CDSConfig::is_dumping_archive(), \"sanity\");\n-\n-  bool has_nonempty_dir = false;\n-  dumptime_iterate([&](AOTCodeSource* cs) {\n-    if (cs->index() > _max_used_index) {\n-      return false; \/\/ stop iterating\n-    }\n-    if (cs->is_dir()) {\n-      if (!os::dir_is_empty(cs->path())) {\n-        log_error(cds)(\"Error: non-empty directory '%s'\", cs->path());\n-        has_nonempty_dir = true;\n-      }\n-    }\n-    return true; \/\/ keep iterating\n-  });\n-\n-  if (has_nonempty_dir) {\n-    vm_exit_during_cds_dumping(\"Cannot have non-empty directory in paths\", nullptr);\n-  }\n-}\n-\n-AOTCodeSourceConfig* AOTCodeSourceConfig::write_to_archive() const {\n-  Array<AOTCodeSource*>* archived_copy = ArchiveBuilder::new_ro_array<AOTCodeSource*>(_code_sources->length());\n-  for (int i = 0; i < _code_sources->length(); i++) {\n-    archived_copy->at_put(i, _code_sources->at(i)->write_to_archive());\n-    ArchivePtrMarker::mark_pointer((address*)archived_copy->adr_at(i));\n-  }\n-\n-  AOTCodeSourceConfig* dumped = (AOTCodeSourceConfig*)ArchiveBuilder::ro_region_alloc(sizeof(AOTCodeSourceConfig));\n-  memcpy(dumped, this, sizeof(AOTCodeSourceConfig));\n-  dumped->_code_sources = archived_copy;\n-  ArchivePtrMarker::mark_pointer(&dumped->_code_sources);\n-\n-  return dumped;\n-}\n-\n-bool AOTCodeSourceConfig::check_classpaths(bool is_boot_classpath, bool has_aot_linked_classes,\n-                                           int index_start, int index_end,\n-                                           CodeSourceStream& runtime_css,\n-                                           bool use_lcp_match, const char* runtime_lcp,\n-                                           size_t runtime_lcp_len) const {\n-  if (index_start >= index_end && runtime_css.is_empty()) { \/\/ nothing to check\n-    return true;\n-  }\n-\n-  ResourceMark rm;\n-  const char* which = is_boot_classpath ? \"boot\" : \"app\";\n-  LogTarget(Info, class, path) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print(\"Checking %s classpath\", which);\n-    ls.print_cr(\"%s\", use_lcp_match ? \" (with longest common prefix substitution)\" : \"\");\n-    ls.print(\"- expected : '\");\n-    print_dumptime_classpath(ls, index_start, index_end, use_lcp_match, _dumptime_lcp_len, runtime_lcp, runtime_lcp_len);\n-    ls.print_cr(\"'\");\n-    ls.print(\"- actual   : '\");\n-    runtime_css.print(&ls);\n-    ls.print_cr(\"'\");\n-  }\n-\n-  runtime_css.start();\n-  for (int i = index_start; i < index_end; i++) {\n-    ResourceMark rm;\n-    const AOTCodeSource* cs = code_source_at(i);\n-    const char* effective_dumptime_path = cs->path();\n-    if (use_lcp_match && _dumptime_lcp_len > 0) {\n-      effective_dumptime_path = substitute(effective_dumptime_path, _dumptime_lcp_len, runtime_lcp, runtime_lcp_len);\n-    }\n-\n-    log_info(class, path)(\"Checking '%s' %s%s\", effective_dumptime_path, cs->file_type_string(),\n-                          cs->from_cpattr() ? \" (from JAR manifest ClassPath attribute)\" : \"\");\n-    if (!cs->from_cpattr() && file_exists(effective_dumptime_path)) {\n-      if (!runtime_css.has_next()) {\n-        log_warning(cds)(\"%s classpath has fewer elements than expected\", which);\n-        return false;\n-      }\n-      const char* runtime_path = runtime_css.get_next();\n-      while (!file_exists(runtime_path) && runtime_css.has_next()) {\n-        runtime_path = runtime_css.get_next();\n-      }\n-      if (!os::same_files(effective_dumptime_path, runtime_path)) {\n-        log_warning(cds)(\"The name of %s classpath [%d] does not match: expected '%s', got '%s'\",\n-                         which, runtime_css.current(), effective_dumptime_path, runtime_path);\n-        return false;\n-      }\n-    }\n-\n-    if (!cs->check(effective_dumptime_path, has_aot_linked_classes)) {\n-      return false;\n-    }\n-  }\n-\n-  \/\/ Check if the runtime boot classpath has more entries than the one stored in the archive and if the app classpath\n-  \/\/ or the module path requires validation.\n-  if (is_boot_classpath && runtime_css.has_next() && (need_to_check_app_classpath() || num_module_paths() > 0)) {\n-    \/\/ the check passes if all the extra runtime boot classpath entries are non-existent\n-    if (check_paths_existence(runtime_css)) {\n-      log_warning(cds)(\"boot classpath is longer than expected\");\n-      return false;\n-    }\n-  }\n-\n-  return true;\n-}\n-\n-bool AOTCodeSourceConfig::file_exists(const char* filename) const{\n-  struct stat st;\n-  return (os::stat(filename, &st) == 0 && st.st_size > 0);\n-}\n-\n-bool AOTCodeSourceConfig::check_paths_existence(CodeSourceStream& runtime_css) const {\n-  bool exist = false;\n-  while (runtime_css.has_next()) {\n-    const char* path = runtime_css.get_next();\n-    if (file_exists(path)) {\n-      exist = true;\n-      break;\n-    }\n-  }\n-  return exist;\n-}\n-\n-bool AOTCodeSourceConfig::check_module_paths(bool has_aot_linked_classes, int index_start, int index_end,\n-                                             CodeSourceStream& runtime_css,\n-                                             bool* has_extra_module_paths) const {\n-  if (index_start >= index_end && runtime_css.is_empty()) { \/\/ nothing to check\n-    return true;\n-  }\n-\n-  ResourceMark rm;\n-\n-  LogTarget(Info, class, path) lt;\n-  if (lt.is_enabled()) {\n-    LogStream ls(lt);\n-    ls.print_cr(\"Checking module paths\");\n-    ls.print(\"- expected : '\");\n-    print_dumptime_classpath(ls, index_start, index_end, false, 0, nullptr, 0);\n-    ls.print_cr(\"'\");\n-    ls.print(\"- actual   : '\");\n-    runtime_css.print(&ls);\n-    ls.print_cr(\"'\");\n-  }\n-\n-  \/\/ Make sure all the dumptime module paths exist and are unchanged\n-  for (int i = index_start; i < index_end; i++) {\n-    const AOTCodeSource* cs = code_source_at(i);\n-    const char* dumptime_path = cs->path();\n-\n-    assert(!cs->from_cpattr(), \"not applicable for module path\");\n-    log_info(class, path)(\"Checking '%s' %s\", dumptime_path, cs->file_type_string());\n-\n-    if (!cs->check(dumptime_path, has_aot_linked_classes)) {\n-      return false;\n-    }\n-  }\n-\n-  \/\/ We allow runtime_css to be a superset of the module paths specified in dumptime. E.g.,\n-  \/\/ Dumptime:    A:C\n-  \/\/ Runtime:     A:B:C\n-  runtime_css.start();\n-  for (int i = index_start; i < index_end; i++) {\n-    const AOTCodeSource* cs = code_source_at(i);\n-    const char* dumptime_path = cs->path();\n-\n-    while (true) {\n-      if (!runtime_css.has_next()) {\n-        log_warning(cds)(\"module path has fewer elements than expected\");\n-        *has_extra_module_paths = true;\n-        return true;\n-      }\n-      \/\/ Both this->code_sources() and runtime_css are alphabetically sorted. Skip\n-      \/\/ items in runtime_css until we see dumptime_path.\n-      const char* runtime_path = runtime_css.get_next();\n-      if (!os::same_files(dumptime_path, runtime_path)) {\n-        *has_extra_module_paths = true;\n-        return true;\n-      } else {\n-        break;\n-      }\n-    }\n-  }\n-\n-  if (runtime_css.has_next()) {\n-    *has_extra_module_paths = true;\n-  }\n-\n-  return true;\n-}\n-\n-void AOTCodeSourceConfig::print_dumptime_classpath(LogStream& ls, int index_start, int index_end,\n-                                                   bool do_substitute, size_t remove_prefix_len,\n-                                                   const char* prepend, size_t prepend_len) const {\n-  const char* sep = \"\";\n-  for (int i = index_start; i < index_end; i++) {\n-    ResourceMark rm;\n-    const AOTCodeSource* cs = code_source_at(i);\n-    const char* path = cs->path();\n-    if (!cs->from_cpattr()) {\n-      ls.print(\"%s\", sep);\n-      if (do_substitute) {\n-        path = substitute(path, remove_prefix_len, prepend, prepend_len);\n-      }\n-      ls.print(\"%s\", path);\n-      sep = os::path_separator();\n-    }\n-  }\n-}\n-\n-\/\/ Returned path is resource-allocated\n-const char* AOTCodeSourceConfig::substitute(const char* path,         \/\/ start with this path (which was recorded from dump time)\n-                                            size_t remove_prefix_len, \/\/ remove this number of chars from the beginning\n-                                            const char* prepend,      \/\/ prepend this string\n-                                            size_t prepend_len) {     \/\/ length of the prepended string\n-  size_t len = strlen(path);\n-  assert(len > remove_prefix_len, \"sanity\");\n-  assert(prepend_len == strlen(prepend), \"sanity\");\n-  len -= remove_prefix_len;\n-  len += prepend_len;\n-\n-  char* buf = NEW_RESOURCE_ARRAY(char, len + 1);\n-  int n = os::snprintf(buf, len + 1, \"%s%s\", prepend, path + remove_prefix_len);\n-  assert(size_t(n) == len, \"sanity\");\n-\n-  return buf;\n-}\n-\n-\/\/ For performance, we avoid using LCP match if there's at least one\n-\/\/ CodeSource can be matched exactly: this means all other CodeSources must be\n-\/\/ matched exactly.\n-bool AOTCodeSourceConfig::need_lcp_match(AllCodeSourceStreams& all_css) const {\n-  if (app_cp_end_index() == boot_cp_start_index()) {\n-    \/\/ No need to use lcp-match when there are no boot\/app paths.\n-    \/\/ TODO: LCP-match not yet supported for modules.\n-    return false;\n-  }\n-\n-  if (need_lcp_match_helper(boot_cp_start_index(), boot_cp_end_index(), all_css.boot_cp()) &&\n-      need_lcp_match_helper(app_cp_start_index(), app_cp_end_index(), all_css.app_cp())) {\n-    return true;\n-  } else {\n-    return false;\n-  }\n-}\n-\n-bool AOTCodeSourceConfig::need_lcp_match_helper(int start, int end, CodeSourceStream& css) const {\n-  int i = start;\n-  for (css.start(); i < end && css.has_next(); ) {\n-    const AOTCodeSource* cs = code_source_at(i++);\n-    const char* runtime_path = css.get_next();\n-    if (cs->must_exist() && os::same_files(cs->path(), runtime_path)) {\n-      \/\/ Most likely, we will come to here at the first iteration.\n-      return false;\n-    }\n-  }\n-  return true;\n-}\n-\n-bool AOTCodeSourceConfig::validate(bool has_aot_linked_classes, bool* has_extra_module_paths) const {\n-  ResourceMark rm;\n-  AllCodeSourceStreams all_css;\n-\n-  const char* jrt = ClassLoader::get_jrt_entry()->name();\n-  bool success = code_source_at(0)->check(jrt, has_aot_linked_classes);\n-  log_info(class, path)(\"Modules image %s validation: %s\", jrt, success ? \"passed\" : \"failed\");\n-  if (!success) {\n-    return false;\n-  }\n-  if (code_sources()->length() == 1) {\n-    if ((module_path_start_index() >= module_path_end_index()) && Arguments::get_property(\"jdk.module.path\") != nullptr) {\n-      *has_extra_module_paths = true;\n-    } else {\n-      *has_extra_module_paths = false;\n-    }\n-  } else {\n-    bool use_lcp_match = need_lcp_match(all_css);\n-    const char* runtime_lcp;\n-    size_t runtime_lcp_len;\n-\n-    log_info(class, path)(\"Longest common prefix substitution in boot\/app classpath matching: %s\",\n-                          use_lcp_match ? \"yes\" : \"no\");\n-    if (use_lcp_match) {\n-      runtime_lcp = find_lcp(all_css.boot_and_app_cp(), runtime_lcp_len);\n-      log_info(class, path)(\"Longest common prefix: %s (%zu chars)\", runtime_lcp, runtime_lcp_len);\n-    } else {\n-      runtime_lcp = nullptr;\n-      runtime_lcp_len = 0;\n-    }\n-\n-    success = check_classpaths(true, has_aot_linked_classes, boot_cp_start_index(), boot_cp_end_index(), all_css.boot_cp(),\n-                               use_lcp_match, runtime_lcp, runtime_lcp_len);\n-    log_info(class, path)(\"Archived boot classpath validation: %s\", success ? \"passed\" : \"failed\");\n-\n-    if (success && need_to_check_app_classpath()) {\n-      success = check_classpaths(false, has_aot_linked_classes, app_cp_start_index(), app_cp_end_index(), all_css.app_cp(),\n-                                 use_lcp_match, runtime_lcp, runtime_lcp_len);\n-      log_info(class, path)(\"Archived app classpath validation: %s\", success ? \"passed\" : \"failed\");\n-    }\n-\n-    if (success) {\n-      success = check_module_paths(has_aot_linked_classes, module_path_start_index(), module_path_end_index(),\n-                                   all_css.module_path(), has_extra_module_paths);\n-      log_info(class, path)(\"Archived module path validation: %s%s\", success ? \"passed\" : \"failed\",\n-                            (*has_extra_module_paths) ? \" (extra module paths found)\" : \"\");\n-    }\n-\n-    if (runtime_lcp_len > 0) {\n-      os::free((void*)runtime_lcp);\n-    }\n-  }\n-\n-  if (success) {\n-    _runtime_instance = this;\n-  } else {\n-    const char* mismatch_msg = \"shared class paths mismatch\";\n-    const char* hint_msg = log_is_enabled(Info, class, path) ?\n-        \"\" : \" (hint: enable -Xlog:class+path=info to diagnose the failure)\";\n-    if (RequireSharedSpaces && !PrintSharedArchiveAndExit) {\n-      log_error(cds)(\"%s%s\", mismatch_msg, hint_msg);\n-      MetaspaceShared::unrecoverable_loading_error();\n-    } else {\n-      log_warning(cds)(\"%s%s\", mismatch_msg, hint_msg);\n-    }\n-  }\n-  return success;\n-}\n","filename":"src\/hotspot\/share\/cds\/aotCodeSource.cpp","additions":0,"deletions":992,"binary":false,"changes":992,"status":"deleted"},{"patch":"@@ -1,269 +0,0 @@\n-\/*\n- * Copyright (c) 2003, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-#ifndef SHARE_CDS_AOTCODESOURCE_HPP\n-#define SHARE_CDS_AOTCODESOURCE_HPP\n-\n-#include \"memory\/allocation.hpp\"\n-#include \"oops\/array.hpp\"\n-#include \"utilities\/exceptions.hpp\"\n-#include \"utilities\/growableArray.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-#include \"utilities\/macros.hpp\"\n-\n-class AllCodeSourceStreams;\n-class CodeSourceStream;\n-class LogStream;\n-\n-\/\/ An AOTCodeSource is a location where the application is configured to load Java classes\n-\/\/ from. It can be:\n-\/\/ - the location of $JAVA_HOME\/lib\/modules\n-\/\/ - an entry in -Xbootclasspath\/a\n-\/\/ - an entry in -classpath\n-\/\/ - a JAR file specified using --module-path.\n-\/\/\n-\/\/ AOTCodeSource is similar to java.security.CodeSource, except:\n-\/\/ - Only local files\/dirs are allowed. Directories must be empty. Network locations are not allowed.\n-\/\/ - No code signing information is recorded.\n-\/\/\n-\/\/ We avoid using pointers in AOTCodeSource to avoid runtime pointer relocation. Each AOTCodeSource\n-\/\/ is a variable-size structure:\n-\/\/    [ all fields specified below (sizeof(AOTCodeSource) bytes)          ]\n-\/\/    [ path (_path_length bytes, including the terminating zero)         ]\n-\/\/    [ manifest (_manifest_length bytes, including the terminating zero) ]\n-class AOTCodeSource {\n-public:\n-  enum class Group : int {\n-    MODULES_IMAGE,\n-    BOOT_CLASSPATH,\n-    APP_CLASSPATH,\n-    MODULE_PATH\n-  };\n-private:\n-  enum class FileType : int {\n-    NORMAL,\n-    DIR,\n-    NOT_EXIST\n-  };\n-  size_t   _path_length;     \/\/ does NOT include terminating zero\n-  size_t   _manifest_length; \/\/ does NOT include terminating zero\n-  bool     _check_time;\n-  bool     _from_cpattr;\n-  bool     _is_multi_release_jar; \/\/ is this a JAR file that has multi-release classes?\n-  FileType _file_type;\n-  Group    _group;\n-  int      _index; \/\/ index of this AOTCodeSource inside AOTCodeSourceConfig::_code_sources\n-  time_t   _timestamp;\n-  int64_t  _filesize;\n-\n-  static size_t header_size()      { return sizeof(AOTCodeSource); } \/\/ bytes\n-  size_t path_offset()       const { return header_size(); }\n-  size_t manifest_offset()   const { return path_offset() + _path_length + 1; }\n-  static char* read_manifest(JavaThread* current, const char* path, size_t& manifest_length);\n-\n-public:\n-  static AOTCodeSource* allocate(JavaThread* current, const char* path, int index, Group group,\n-                                 bool from_cpattr = false, bool is_jrt = false);\n-\n-  size_t total_size()                const { return manifest_offset() + _manifest_length + 1; }\n-  const char* path()                 const { return ((const char*)this) + path_offset();  }\n-  size_t manifest_length()           const { return _manifest_length; }\n-  const char* manifest()             const { return ((const char*)this) + manifest_offset(); }\n-  bool must_exist()                  const { return _file_type != FileType::NOT_EXIST; }\n-  bool must_not_exist()              const { return _file_type == FileType::NOT_EXIST; }\n-  bool is_dir()                      const { return _file_type == FileType::DIR; }\n-  int index()                        const { return _index; }\n-  bool is_modules_image()            const { return _group == Group::MODULES_IMAGE; }\n-  bool from_boot_classpath()         const { return _group == Group::BOOT_CLASSPATH; }\n-  bool from_app_classpath()          const { return _group == Group::APP_CLASSPATH; }\n-  bool from_module_path()            const { return _group == Group::MODULE_PATH; }\n-  bool is_multi_release_jar()        const { return _is_multi_release_jar; }\n-\n-  \/\/ Only boot\/app classpaths can contain unnamed module\n-  bool has_unnamed_module()          const { return from_boot_classpath() || from_app_classpath(); }\n-\n-  char* get_cpattr() const;\n-  AOTCodeSource* write_to_archive() const;\n-\n-  \/\/ Returns true IFF this AOTCodeSource is discovered from the -classpath or -Xbootclasspath\/a by parsing the\n-  \/\/ \"Class-Path\" attribute of a JAR file.\n-  bool from_cpattr() const { return _from_cpattr; }\n-  const char* file_type_string() const;\n-  bool check(const char* runtime_path, bool has_aot_linked_classes) const;\n-};\n-\n-\/\/ AOTCodeSourceConfig\n-\/\/\n-\/\/ Keep track of the set of AOTCodeSources used when an AOTCache is created.\n-\/\/ To load the AOTCache in a production run, the JVM must be using a compatible set of\n-\/\/ AOTCodeSources (subjected to AOTCodeSourceConfig::validate()).\n-\/\/\n-\/\/ In general, validation is performed on the AOTCodeSources to ensure the code sources used\n-\/\/ during AOTCache creation are the same as when the AOTCache is used during runtime.\n-\/\/ Non-existent entries are recorded during AOTCache creation. Those non-existent entries,\n-\/\/ if they are specified at runtime, must not exist.\n-\/\/\n-\/\/ Some details on validation:\n-\/\/ - the boot classpath can be appended to at runtime if there's no app classpath and no\n-\/\/   module path specified when an AOTCache is created;\n-\/\/ - the app classpath can be appended to at runtime;\n-\/\/ - the module path at runtime can be a superset of the one specified during AOTCache creation.\n-\n-class AOTCodeSourceConfig : public CHeapObj<mtClassShared> {\n-  using Group = AOTCodeSource::Group;\n-  using GrowableCodeSourceArray = GrowableArrayCHeap<AOTCodeSource*, mtClassShared>;\n-\n-  \/\/ Note: both of the following are non-null if we are dumping a dynamic archive.\n-  static AOTCodeSourceConfig* _dumptime_instance;\n-  static const AOTCodeSourceConfig* _runtime_instance;\n-\n-  Array<AOTCodeSource*>* _code_sources; \/\/ jrt -> -Xbootclasspath\/a -> -classpath -> --module_path\n-  int _boot_classpath_end;\n-  int _app_classpath_end;\n-  int _module_end;\n-  bool _has_non_jar_modules;\n-  bool _has_platform_classes;\n-  bool _has_app_classes;\n-  int  _max_used_index;\n-  size_t _dumptime_lcp_len;\n-\n-  \/\/ accessors\n-  Array<AOTCodeSource*>* code_sources() const { return _code_sources; }\n-\n-  void parse(JavaThread* current, GrowableCodeSourceArray& tmp_array, CodeSourceStream& css,\n-             Group group, bool parse_manifest);\n-  void add_code_source(JavaThread* current, GrowableCodeSourceArray& tmp_array, const char* path,\n-                       Group group, bool parse_manifest, bool from_cpattr);\n-  void dumptime_init_helper(TRAPS);\n-\n-  bool check_classpaths(bool is_boot_classpath, bool has_aot_linked_classes,\n-                        int index_start, int index_end, CodeSourceStream& runtime_css,\n-                        bool use_lcp_match, const char* runtime_lcp, size_t runtime_lcp_len) const;\n-  bool check_module_paths(bool has_aot_linked_classes, int index_start, int index_end, CodeSourceStream& runtime_css,\n-                          bool* has_extra_module_paths) const;\n-  bool file_exists(const char* filename) const;\n-  bool check_paths_existence(CodeSourceStream& runtime_css) const;\n-\n-  static const char* substitute(const char* path, size_t remove_prefix_len,\n-                                const char* prepend, size_t prepend_len);\n-  static const char* find_lcp(CodeSourceStream& css, size_t& lcp_len);\n-  bool need_lcp_match(AllCodeSourceStreams& all_css) const;\n-  bool need_lcp_match_helper(int start, int end, CodeSourceStream& css) const;\n-\n-  template <typename FUNC> void dumptime_iterate_helper(FUNC func) const {\n-    assert(_code_sources != nullptr, \"sanity\");\n-    int n = _code_sources->length();\n-    for (int i = 0; i < n; i++) {\n-      if (!func(_code_sources->at(i))) {\n-        break;\n-      }\n-    }\n-  }\n-\n-  template <typename FUNC> void iterate(FUNC func) const {\n-    int n = code_sources()->length();\n-    for (int i = 0; i < n; i++) {\n-      if (!func(code_sources()->at(i))) {\n-        break;\n-      }\n-    }\n-  }\n-\n-  void check_nonempty_dirs() const;\n-  bool need_to_check_app_classpath() const {\n-    return (num_app_classpaths() > 0) && (_max_used_index >= app_cp_start_index()) && has_platform_or_app_classes();\n-  }\n-\n-  void print_dumptime_classpath(LogStream& ls, int index_start, int index_limit,\n-                                bool do_substitute, size_t remove_prefix_len,\n-                                const char* prepend, size_t prepend_len) const;\n-public:\n-  static AOTCodeSourceConfig* dumptime() {\n-    assert(_dumptime_instance != nullptr, \"can only be called when dumping an AOT cache\");\n-    return _dumptime_instance;\n-  }\n-\n-  static const AOTCodeSourceConfig* runtime() {\n-    assert(_runtime_instance != nullptr, \"can only be called when using an AOT cache\");\n-    return _runtime_instance;\n-  }\n-\n-  \/\/ Common accessors\n-  int boot_cp_start_index()          const { return 1; }\n-  int boot_cp_end_index()            const { return _boot_classpath_end; }\n-  int app_cp_start_index()           const { return boot_cp_end_index(); }\n-  int app_cp_end_index()             const { return _app_classpath_end; }\n-  int module_path_start_index()      const { return app_cp_end_index(); }\n-  int module_path_end_index()        const { return _module_end; }\n-  bool has_platform_or_app_classes() const { return _has_app_classes || _has_platform_classes; }\n-  bool has_non_jar_modules()         const { return _has_non_jar_modules; }\n-  int num_boot_classpaths()          const { return boot_cp_end_index() - boot_cp_start_index(); }\n-  int num_app_classpaths()           const { return app_cp_end_index() - app_cp_start_index(); }\n-  int num_module_paths()             const { return module_path_end_index() - module_path_start_index(); }\n-\n-  int length() const {\n-    return _code_sources->length();\n-  }\n-\n-  const AOTCodeSource* code_source_at(int index) const;\n-  int get_module_shared_path_index(Symbol* location) const;\n-\n-  \/\/ Functions used only during dumptime\n-  static void dumptime_init(TRAPS);\n-\n-  static void dumptime_set_has_app_classes() {\n-    _dumptime_instance->_has_app_classes = true;\n-  }\n-\n-  static void dumptime_set_has_platform_classes() {\n-    _dumptime_instance->_has_platform_classes = true;\n-  }\n-\n-  static void dumptime_update_max_used_index(int index) {\n-    if (_dumptime_instance == nullptr) {\n-      assert(index == 0, \"sanity\");\n-    } else if (_dumptime_instance->_max_used_index < index) {\n-      _dumptime_instance->_max_used_index = index;\n-    }\n-  }\n-\n-  static void dumptime_check_nonempty_dirs() {\n-    _dumptime_instance->check_nonempty_dirs();\n-  }\n-\n-  static bool dumptime_is_ready() {\n-    return _dumptime_instance != nullptr;\n-  }\n-  template <typename FUNC> static void dumptime_iterate(FUNC func) {\n-    _dumptime_instance->dumptime_iterate_helper(func);\n-  }\n-\n-  AOTCodeSourceConfig* write_to_archive() const;\n-\n-  \/\/ Functions used only during runtime\n-  bool validate(bool has_aot_linked_classes, bool* has_extra_module_paths) const;\n-};\n-\n-\n-#endif \/\/ SHARE_CDS_AOTCODESOURCE_HPP\n","filename":"src\/hotspot\/share\/cds\/aotCodeSource.hpp","additions":0,"deletions":269,"binary":false,"changes":269,"status":"deleted"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -53,1 +53,1 @@\n-  const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(index);\n+  const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(index);\n@@ -56,1 +56,1 @@\n-  if (cs->is_modules_image()) {\n+  if (cl->is_modules_image()) {\n@@ -74,1 +74,1 @@\n-    \/\/   AOTCodeSourceConfig::_runtime_instance->_array->at(index) identifies the JAR file that contains k.\n+    \/\/   AOTClassLocationConfig::_runtime_instance->_array->at(index) identifies the JAR file that contains k.\n@@ -90,1 +90,1 @@\n-    int index_offset = index - AOTCodeSourceConfig::runtime()->app_cp_start_index();\n+    int index_offset = index - AOTClassLocationConfig::runtime()->app_cp_start_index();\n@@ -181,2 +181,2 @@\n-    const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(shared_path_index);\n-    size_t size = cs->manifest_length();\n+    const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(shared_path_index);\n+    size_t size = cl->manifest_length();\n@@ -188,1 +188,1 @@\n-    const char* src = cs->manifest();\n+    const char* src = cl->manifest();\n@@ -201,1 +201,1 @@\n-    const char* path = AOTCodeSourceConfig::runtime()->code_source_at(shared_path_index)->path();\n+    const char* path = AOTClassLocationConfig::runtime()->class_location_at(shared_path_index)->path();\n","filename":"src\/hotspot\/share\/cds\/cdsProtectionDomain.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -93,1 +93,1 @@\n-  void write_archive(char* serialized_data, AOTCodeSourceConfig* cs_config);\n+  void write_archive(char* serialized_data, AOTClassLocationConfig* cl_config);\n@@ -142,1 +142,1 @@\n-    AOTCodeSourceConfig* cs_config;\n+    AOTClassLocationConfig* cl_config;\n@@ -153,1 +153,1 @@\n-      cs_config = AOTCodeSourceConfig::dumptime()->write_to_archive();\n+      cl_config = AOTClassLocationConfig::dumptime()->write_to_archive();\n@@ -167,1 +167,1 @@\n-    write_archive(serialized_data, cs_config);\n+    write_archive(serialized_data, cl_config);\n@@ -340,2 +340,2 @@\n-void DynamicArchiveBuilder::write_archive(char* serialized_data, AOTCodeSourceConfig* cs_config) {\n-  _header->set_code_source_config(cs_config);\n+void DynamicArchiveBuilder::write_archive(char* serialized_data, AOTClassLocationConfig* cl_config) {\n+  _header->set_class_location_config(cl_config);\n@@ -394,1 +394,1 @@\n-    AOTCodeSourceConfig::dumptime_check_nonempty_dirs();\n+    AOTClassLocationConfig::dumptime_check_nonempty_dirs();\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -235,1 +235,1 @@\n-  _has_platform_or_app_classes = AOTCodeSourceConfig::dumptime()->has_platform_or_app_classes();\n+  _has_platform_or_app_classes = AOTClassLocationConfig::dumptime()->has_platform_or_app_classes();\n@@ -280,1 +280,1 @@\n-  st->print_cr(\"- code_source_config_offset:      0x%zx\", _code_source_config_offset);\n+  st->print_cr(\"- class_location_config_offset:   0x%zx\", _class_location_config_offset);\n@@ -302,1 +302,1 @@\n-bool FileMapInfo::validate_code_source() {\n+bool FileMapInfo::validate_class_location() {\n@@ -305,1 +305,1 @@\n-  AOTCodeSourceConfig* config = header()->code_source_config();\n+  AOTClassLocationConfig* config = header()->class_location_config();\n@@ -344,1 +344,1 @@\n-  size_t sz = sizeof(ClassPathEntry*) * AOTCodeSourceConfig::runtime()->length();\n+  size_t sz = sizeof(ClassPathEntry*) * AOTClassLocationConfig::runtime()->length();\n@@ -1919,2 +1919,2 @@\n-    const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(i);\n-    const char* path = cs->path();\n+    const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(i);\n+    const char* path = cl->path();\n@@ -1951,1 +1951,1 @@\n-  assert(path_index < AOTCodeSourceConfig::runtime()->length(), \"sanity\");\n+  assert(path_index < AOTClassLocationConfig::runtime()->length(), \"sanity\");\n@@ -1961,1 +1961,1 @@\n-  const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(path_index);\n+  const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(path_index);\n@@ -1963,1 +1963,1 @@\n-  if (class_loader() != nullptr && cs->is_multi_release_jar()) {\n+  if (class_loader() != nullptr && cl->is_multi_release_jar()) {\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-class AOTCodeSourceConfig;\n+class AOTClassLocationConfig;\n@@ -130,1 +130,1 @@\n-  size_t _code_source_config_offset;\n+  size_t _class_location_config_offset;\n@@ -213,2 +213,2 @@\n-  void set_code_source_config(AOTCodeSourceConfig* table) {\n-    set_as_offset(table, &_code_source_config_offset);\n+  void set_class_location_config(AOTClassLocationConfig* table) {\n+    set_as_offset(table, &_class_location_config_offset);\n@@ -217,2 +217,2 @@\n-  AOTCodeSourceConfig* code_source_config() {\n-    return from_mapped_offset<AOTCodeSourceConfig*>(_code_source_config_offset);\n+  AOTClassLocationConfig* class_location_config() {\n+    return from_mapped_offset<AOTClassLocationConfig*>(_class_location_config_offset);\n@@ -383,1 +383,1 @@\n-  bool validate_code_source();\n+  bool validate_class_location();\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -1179,1 +1179,1 @@\n-      AOTCodeSourceConfig::runtime()->num_module_paths() > 0) {\n+      AOTClassLocationConfig::runtime()->num_module_paths() > 0) {\n@@ -1184,1 +1184,1 @@\n-                        AOTCodeSourceConfig::runtime()->num_module_paths());\n+                        AOTClassLocationConfig::runtime()->num_module_paths());\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -334,1 +334,1 @@\n-    int size = AOTCodeSourceConfig::runtime()->length();\n+    int size = AOTClassLocationConfig::runtime()->length();\n@@ -551,1 +551,1 @@\n-  char* dump_read_only_tables(AOTCodeSourceConfig*& cs_config);\n+  char* dump_read_only_tables(AOTClassLocationConfig*& cl_config);\n@@ -606,1 +606,1 @@\n-char* VM_PopulateDumpSharedSpace::dump_read_only_tables(AOTCodeSourceConfig*& cs_config) {\n+char* VM_PopulateDumpSharedSpace::dump_read_only_tables(AOTClassLocationConfig*& cl_config) {\n@@ -610,1 +610,1 @@\n-  cs_config = AOTCodeSourceConfig::dumptime()->write_to_archive();\n+  cl_config = AOTClassLocationConfig::dumptime()->write_to_archive();\n@@ -638,1 +638,1 @@\n-  AOTCodeSourceConfig::dumptime_check_nonempty_dirs();\n+  AOTClassLocationConfig::dumptime_check_nonempty_dirs();\n@@ -672,2 +672,2 @@\n-  AOTCodeSourceConfig* cs_config;\n-  char* serialized_data = dump_read_only_tables(cs_config);\n+  AOTClassLocationConfig* cl_config;\n+  char* serialized_data = dump_read_only_tables(cl_config);\n@@ -689,1 +689,1 @@\n-  _map_info->header()->set_code_source_config(cs_config);\n+  _map_info->header()->set_class_location_config(cl_config);\n@@ -1639,1 +1639,1 @@\n-  if (!mapinfo->validate_code_source()) {\n+  if (!mapinfo->validate_class_location()) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -1196,1 +1196,1 @@\n-  if (!AOTCodeSourceConfig::dumptime_is_ready()) {\n+  if (!AOTClassLocationConfig::dumptime_is_ready()) {\n@@ -1208,2 +1208,2 @@\n-    AOTCodeSourceConfig::dumptime_iterate([&] (AOTCodeSource* cs) {\n-      int i = cs->index();\n+    AOTClassLocationConfig::dumptime_iterate([&] (AOTClassLocation* cl) {\n+      int i = cl->index();\n@@ -1212,1 +1212,1 @@\n-      if (cs->is_modules_image() && (stream->from_boot_loader_modules_image() || string_starts_with(src, \"jrt:\"))) {\n+      if (cl->is_modules_image() && (stream->from_boot_loader_modules_image() || string_starts_with(src, \"jrt:\"))) {\n@@ -1214,1 +1214,1 @@\n-      } else if (os::same_files(cs->path(), path)) {\n+      } else if (os::same_files(cl->path(), path)) {\n@@ -1227,1 +1227,1 @@\n-          if (SystemDictionary::is_system_class_loader(loader) && cs->from_app_classpath()) {\n+          if (SystemDictionary::is_system_class_loader(loader) && cl->from_app_classpath()) {\n@@ -1230,1 +1230,1 @@\n-            if (cs->from_boot_classpath()) {\n+            if (cl->from_boot_classpath()) {\n@@ -1240,1 +1240,1 @@\n-          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && cs->from_module_path()) {\n+          if ((pkg_entry != nullptr) && !(pkg_entry->in_unnamed_module()) && cl->from_module_path()) {\n@@ -1300,1 +1300,1 @@\n-      ik->set_shared_classpath_index(AOTCodeSourceConfig::dumptime()->app_cp_start_index());\n+      ik->set_shared_classpath_index(AOTClassLocationConfig::dumptime()->app_cp_start_index());\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -78,1 +78,1 @@\n-    AOTCodeSourceConfig::dumptime_set_has_app_classes();\n+    AOTClassLocationConfig::dumptime_set_has_app_classes();\n@@ -81,1 +81,1 @@\n-    AOTCodeSourceConfig::dumptime_set_has_platform_classes();\n+    AOTClassLocationConfig::dumptime_set_has_platform_classes();\n@@ -83,1 +83,1 @@\n-  AOTCodeSourceConfig::dumptime_update_max_used_index(classpath_index);\n+  AOTClassLocationConfig::dumptime_update_max_used_index(classpath_index);\n@@ -93,1 +93,1 @@\n-    \/\/ purposes only). If a class is transformed by the agent, the CodeSource of\n+    \/\/ purposes only). If a class is transformed by the agent, the AOTClassLocation of\n","filename":"src\/hotspot\/share\/classfile\/classLoaderExt.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -64,1 +64,1 @@\n-        _shared_path_index = AOTCodeSourceConfig::runtime()->get_module_shared_path_index(_location);\n+        _shared_path_index = AOTClassLocationConfig::runtime()->get_module_shared_path_index(_location);\n@@ -486,1 +486,1 @@\n-  _shared_path_index = AOTCodeSourceConfig::dumptime()->get_module_shared_path_index(_location);\n+  _shared_path_index = AOTClassLocationConfig::dumptime()->get_module_shared_path_index(_location);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-#include \"cds\/aotCodeSource.hpp\"\n+#include \"cds\/aotClassLocation.hpp\"\n@@ -966,1 +966,1 @@\n-  const AOTCodeSource* cs = AOTCodeSourceConfig::runtime()->code_source_at(scp_index);\n+  const AOTClassLocation* cl = AOTClassLocationConfig::runtime()->class_location_at(scp_index);\n@@ -968,1 +968,1 @@\n-    assert(cs != nullptr, \"must be\");\n+    assert(cl != nullptr, \"must be\");\n@@ -973,1 +973,1 @@\n-    assert(cs->is_modules_image() || HeapShared::is_a_test_class_in_unnamed_module(ik),\n+    assert(cl->is_modules_image() || HeapShared::is_a_test_class_in_unnamed_module(ik),\n@@ -990,1 +990,1 @@\n-  bool was_archived_from_named_module = !cs->has_unnamed_module();\n+  bool was_archived_from_named_module = !cl->has_unnamed_module();\n@@ -1592,1 +1592,1 @@\n-    AOTCodeSourceConfig::dumptime_init(CHECK);\n+    AOTClassLocationConfig::dumptime_init(THREAD);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -172,2 +172,2 @@\n-  \/\/ This is an index into AOTCodeSourceConfig::code_sources(), to\n-  \/\/ indicate the AOTCodeSource where this class is loaded from during\n+  \/\/ This is an index into AOTClassLocationConfig::class_locations(), to\n+  \/\/ indicate the AOTClassLocation where this class is loaded from during\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}