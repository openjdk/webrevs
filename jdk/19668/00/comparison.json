{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,4 @@\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.Launcher;\n@@ -30,1 +34,0 @@\n-import java.nio.file.Files;\n@@ -41,1 +44,0 @@\n-import java.util.stream.Collectors;\n@@ -46,11 +48,3 @@\n-import jdk.jpackage.internal.Arguments.CLIOptions;\n-import static jdk.jpackage.internal.LinuxAppImageBuilder.DEFAULT_ICON;\n-import static jdk.jpackage.internal.LinuxAppImageBuilder.ICON_PNG;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n+import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.util.CompositeProxy;\n@@ -59,0 +53,1 @@\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -73,3 +68,1 @@\n-    private DesktopIntegration(PlatformPackage thePackage,\n-            Map<String, ? super Object> params,\n-            Map<String, ? super Object> mainParams) throws IOException {\n+    private DesktopIntegration(BuildEnv env, LinuxPackage pkg, LinuxLauncher launcher) throws IOException {\n@@ -77,4 +70,2 @@\n-        associations = FileAssociation.fetchFrom(params).stream()\n-                .filter(fa -> !fa.mimeTypes.isEmpty())\n-                .map(LinuxFileAssociation::new)\n-                .collect(Collectors.toUnmodifiableList());\n+        associations = launcher.fileAssociations().stream().map(\n+                LinuxFileAssociation::create).toList();\n@@ -82,3 +73,3 @@\n-        launchers = ADD_LAUNCHERS.fetchFrom(params);\n-\n-        this.thePackage = thePackage;\n+        this.env = env;\n+        this.pkg = pkg;\n+        this.launcher = launcher;\n@@ -89,1 +80,4 @@\n-        boolean withDesktopFile = !associations.isEmpty() || LINUX_SHORTCUT_HINT.fetchFrom(params);\n+        boolean withDesktopFile = !associations.isEmpty() || launcher.shortcut().orElse(false);\n+\n+        var curIconResource = createLauncherIconResource(pkg.app(), launcher,\n+                env::createResource);\n@@ -91,3 +85,1 @@\n-        var curIconResource = LinuxAppImageBuilder.createIconResource(DEFAULT_ICON,\n-                ICON_PNG, params, mainParams);\n-        if (curIconResource == null) {\n+        if (curIconResource.isEmpty()) {\n@@ -98,2 +90,1 @@\n-            if (curIconResource.saveToFile(nullPath)\n-                    != OverridableResource.Source.DefaultResource) {\n+            if (curIconResource.get().saveToFile(nullPath) != OverridableResource.Source.DefaultResource) {\n@@ -105,1 +96,1 @@\n-        desktopFileResource = createResource(\"template.desktop\", params)\n+        desktopFileResource = env.createResource(\"template.desktop\")\n@@ -107,1 +98,1 @@\n-                .setPublicName(APP_NAME.fetchFrom(params) + \".desktop\");\n+                .setPublicName(launcher.name() + \".desktop\");\n@@ -109,1 +100,1 @@\n-        final String escapedAppFileName = APP_NAME.fetchFrom(params).replaceAll(\"\\\\s+\", \"_\");\n+        final String escapedAppFileName = launcher.name().replaceAll(\"\\\\s+\", \"_\");\n@@ -115,1 +106,1 @@\n-                    thePackage.name(), escapedAppFileName);\n+                    pkg.packageName(), escapedAppFileName);\n@@ -117,1 +108,1 @@\n-                    thePackage.name(), escapedAppFileName);\n+                    pkg.packageName(), escapedAppFileName);\n@@ -119,1 +110,1 @@\n-        mimeInfoFile = new DesktopFile(mimeInfoFileName);\n+        mimeInfoFile = createDesktopFile(mimeInfoFileName);\n@@ -122,3 +113,2 @@\n-            desktopFile = new DesktopFile(desktopFileName);\n-            iconFile = new DesktopFile(escapedAppFileName\n-                    + PathUtils.getSuffix(Path.of(DEFAULT_ICON)));\n+            desktopFile = Optional.of(createDesktopFile(desktopFileName));\n+            iconFile = Optional.of(createDesktopFile(escapedAppFileName + \".png\"));\n@@ -126,1 +116,1 @@\n-            if (curIconResource == null) {\n+            if (curIconResource.isEmpty()) {\n@@ -128,2 +118,1 @@\n-                curIconResource = LinuxAppImageBuilder.createIconResource(\n-                        DEFAULT_ICON, ICON_PNG, mainParams, null);\n+                curIconResource = createLauncherIconResource(pkg.app(), pkg.app().mainLauncher().orElseThrow(), env::createResource);\n@@ -132,2 +121,2 @@\n-            desktopFile = null;\n-            iconFile = null;\n+            desktopFile = Optional.empty();\n+            iconFile = Optional.empty();\n@@ -138,26 +127,4 @@\n-        desktopFileData = Collections.unmodifiableMap(\n-                createDataForDesktopFile(params));\n-\n-        nestedIntegrations = new ArrayList<>();\n-        \/\/ Read launchers information from predefine app image\n-        if (launchers.isEmpty() &&\n-                PREDEFINED_APP_IMAGE.fetchFrom(params) != null) {\n-            List<AppImageFile.LauncherInfo> launcherInfos =\n-                    AppImageFile.getLaunchers(\n-                    PREDEFINED_APP_IMAGE.fetchFrom(params), params);\n-            if (!launcherInfos.isEmpty()) {\n-                launcherInfos.remove(0); \/\/ Remove main launcher\n-            }\n-            for (var launcherInfo : launcherInfos) {\n-                Map<String, ? super Object> launcherParams = new HashMap<>();\n-                Arguments.putUnlessNull(launcherParams, CLIOptions.NAME.getId(),\n-                        launcherInfo.getName());\n-                launcherParams = AddLauncherArguments.merge(params,\n-                        launcherParams, ICON.getID(), ICON_PNG.getID(),\n-                        ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID(),\n-                        PREDEFINED_APP_IMAGE.getID());\n-                if (launcherInfo.isShortcut()) {\n-                    nestedIntegrations.add(new DesktopIntegration(thePackage,\n-                            launcherParams, params));\n-                }\n-            }\n+        desktopFileData = createDataForDesktopFile();\n+\n+        if (launcher != pkg.app().mainLauncher().orElseThrow()) {\n+            nestedIntegrations = List.of();\n@@ -165,9 +132,7 @@\n-            for (var launcherParams : launchers) {\n-                launcherParams = AddLauncherArguments.merge(params,\n-                        launcherParams, ICON.getID(), ICON_PNG.getID(),\n-                        ADD_LAUNCHERS.getID(), FILE_ASSOCIATIONS.getID());\n-                if (SHORTCUT_HINT.fetchFrom(launcherParams)) {\n-                    nestedIntegrations.add(new DesktopIntegration(thePackage,\n-                            launcherParams, params));\n-                }\n-            }\n+            nestedIntegrations = pkg.app().additionalLaunchers().stream().map(v -> {\n+                return (LinuxLauncher)v;\n+            }).filter(l -> {\n+                return l.shortcut().orElse(true);\n+            }).map(toFunction(l -> {\n+                return new DesktopIntegration(env, pkg, l);\n+            })).toList();\n@@ -177,3 +142,2 @@\n-    static ShellCustomAction create(PlatformPackage thePackage,\n-            Map<String, ? super Object> params) throws IOException {\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+        if (pkg.isRuntimeInstaller()) {\n@@ -182,1 +146,2 @@\n-        return new DesktopIntegration(thePackage, params, null);\n+        return new DesktopIntegration(env, (LinuxPackage) pkg,\n+                (LinuxLauncher) pkg.app().mainLauncher().orElseThrow());\n@@ -199,3 +164,1 @@\n-        associations.forEach(assoc -> assoc.data.verify());\n-\n-        if (iconFile != null) {\n+        if (iconFile.isPresent()) {\n@@ -203,1 +166,1 @@\n-            iconResource.saveToFile(iconFile.srcPath());\n+            iconResource.orElseThrow().saveToFile(iconFile.orElseThrow().srcPath());\n@@ -209,1 +172,1 @@\n-        if (desktopFile != null) {\n+        if (desktopFile.isPresent()) {\n@@ -211,1 +174,1 @@\n-            createDesktopFile(data);\n+            saveDesktopFile(data);\n@@ -261,4 +224,1 @@\n-        if (desktopFile != null) {\n-            return List.of(\"xdg-utils\");\n-        }\n-        return Collections.emptyList();\n+        return desktopFile.map(file -> List.of(\"xdg-utils\")).orElseGet(Collections::emptyList);\n@@ -267,2 +227,1 @@\n-    private Map<String, String> createDataForDesktopFile(\n-            Map<String, ? super Object> params) {\n+    private Map<String, String> createDataForDesktopFile() {\n@@ -270,3 +229,3 @@\n-        data.put(\"APPLICATION_NAME\", APP_NAME.fetchFrom(params));\n-        data.put(\"APPLICATION_DESCRIPTION\", DESCRIPTION.fetchFrom(params));\n-        data.put(\"APPLICATION_ICON\", Optional.ofNullable(iconFile).map(\n+        data.put(\"APPLICATION_NAME\", launcher.name());\n+        data.put(\"APPLICATION_DESCRIPTION\", launcher.description());\n+        data.put(\"APPLICATION_ICON\", iconFile.map(\n@@ -274,1 +233,1 @@\n-        data.put(\"DEPLOY_BUNDLE_CATEGORY\", MENU_GROUP.fetchFrom(params));\n+        data.put(\"DEPLOY_BUNDLE_CATEGORY\", pkg.menuGroupName());\n@@ -276,2 +235,2 @@\n-                thePackage.installedApplicationLayout().launchersDirectory().resolve(\n-                        LinuxAppImageBuilder.getLauncherName(params)).toString()));\n+                pkg.asInstalledPackageApplicationLayout().orElseThrow().launchersDirectory().resolve(\n+                        launcher.executableNameWithSuffix()).toString()));\n@@ -291,2 +250,4 @@\n-            registerDesktopFileCmd = String.join(\" \", \"xdg-desktop-menu\",\n-                    \"install\", desktopFile.installPath().toString());\n+            final var desktopFileInstallPath = desktopFile.orElseThrow().installPath().toString();\n+\n+            registerDesktopFileCmd = String.join(\" \",\n+                    \"xdg-desktop-menu\", \"install\", desktopFileInstallPath);\n@@ -294,3 +255,2 @@\n-                    \"do_if_file_belongs_to_single_package\", desktopFile.\n-                            installPath().toString(), \"xdg-desktop-menu\",\n-                    \"uninstall\", desktopFile.installPath().toString());\n+                    \"do_if_file_belongs_to_single_package\", desktopFileInstallPath,\n+                    \"xdg-desktop-menu\", \"uninstall\", desktopFileInstallPath);\n@@ -308,0 +268,2 @@\n+            final var desktopFileInstallPath = desktopFile.orElseThrow().installPath();\n+\n@@ -322,5 +284,3 @@\n-                    \"do_if_file_belongs_to_single_package\", desktopFile.\n-                            installPath().toString(),\n-                    \"desktop_uninstall_default_mime_handler\", desktopFile.\n-                            installPath().getFileName().toString(), String.join(\n-                            \" \", getMimeTypeNamesFromFileAssociations()));\n+                    \"do_if_file_belongs_to_single_package\", desktopFileInstallPath.toString(),\n+                    \"desktop_uninstall_default_mime_handler\", desktopFileInstallPath.getFileName().toString(),\n+                    String.join(\" \", getMimeTypeNamesFromFileAssociations()));\n@@ -370,5 +330,5 @@\n-     * Desktop integration file. xml, icon, etc.\n-     * Resides somewhere in application installation tree.\n-     * Has two paths:\n-     *  - path where it should be placed at package build time;\n-     *  - path where it should be installed by package manager;\n+     * Creates desktop integration file. xml, icon, etc.\n+     *\n+     * Returned instance:\n+     *  - srcPath(): path where it should be placed at package build time;\n+     *  - installPath(): path where it should be installed by package manager;\n@@ -376,22 +336,4 @@\n-    private class DesktopFile {\n-\n-        DesktopFile(String fileName) {\n-            var installPath = thePackage\n-                    .installedApplicationLayout()\n-                    .destktopIntegrationDirectory().resolve(fileName);\n-            var srcPath = thePackage\n-                    .sourceApplicationLayout()\n-                    .destktopIntegrationDirectory().resolve(fileName);\n-\n-            impl = new InstallableFile(srcPath, installPath);\n-        }\n-\n-        Path installPath() {\n-            return impl.installPath();\n-        }\n-\n-        Path srcPath() {\n-            return impl.srcPath();\n-        }\n-\n-        private final InstallableFile impl;\n+    private InstallableFile createDesktopFile(String fileName) {\n+        var srcPath = pkg.asPackageApplicationLayout().orElseThrow().resolveAt(env.appImageDir()).destktopIntegrationDirectory().resolve(fileName);\n+        var installPath = pkg.asInstalledPackageApplicationLayout().orElseThrow().destktopIntegrationDirectory().resolve(fileName);\n+        return new InstallableFile(srcPath, installPath);\n@@ -401,1 +343,1 @@\n-            FileAssociation assoc) throws XMLStreamException {\n+            LinuxFileAssociation fa) throws XMLStreamException {\n@@ -403,1 +345,0 @@\n-        for (var mimeType : assoc.mimeTypes) {\n@@ -405,1 +346,1 @@\n-            xml.writeAttribute(\"type\", mimeType);\n+            xml.writeAttribute(\"type\", fa.mimeType());\n@@ -407,2 +348,2 @@\n-            final String description = assoc.description;\n-            if (description != null && !description.isEmpty()) {\n+            final var description = fa.description().orElse(null);\n+            if (description != null) {\n@@ -414,5 +355,3 @@\n-            for (String ext : assoc.extensions) {\n-                xml.writeStartElement(\"glob\");\n-                xml.writeAttribute(\"pattern\", \"*.\" + ext);\n-                xml.writeEndElement();\n-            }\n+            xml.writeStartElement(\"glob\");\n+            xml.writeAttribute(\"pattern\", \"*.\" + fa.extension());\n+            xml.writeEndElement();\n@@ -421,1 +360,0 @@\n-        }\n@@ -430,2 +368,2 @@\n-            for (var assoc : associations) {\n-                appendFileAssociation(xml, assoc.data);\n+            for (var fa : associations) {\n+                appendFileAssociation(xml, fa);\n@@ -441,2 +379,2 @@\n-        for (var assoc : associations) {\n-            if (assoc.iconSize <= 0) {\n+        for (var fa : associations) {\n+            if (!fa.hasIcon()) {\n@@ -447,4 +385,6 @@\n-            for (var mimeType : assoc.data.mimeTypes) {\n-                if (processedMimeTypes.contains(mimeType)) {\n-                    continue;\n-                }\n+            var mimeType = fa.mimeType();\n+            if (processedMimeTypes.contains(mimeType)) {\n+                continue;\n+            }\n+\n+            processedMimeTypes.add(mimeType);\n@@ -452,1 +392,1 @@\n-                processedMimeTypes.add(mimeType);\n+            final var faIcon = fa.icon().orElseThrow();\n@@ -454,4 +394,3 @@\n-                \/\/ Create icon name for mime type from mime type.\n-                DesktopFile faIconFile = new DesktopFile(mimeType.replace(\n-                        File.separatorChar, '-') + PathUtils.getSuffix(\n-                                assoc.data.iconPath));\n+            \/\/ Create icon name for mime type from mime type.\n+            var faIconFile = createDesktopFile(mimeType.replace(File.separatorChar,\n+                    '-') + PathUtils.getSuffix(faIcon));\n@@ -459,2 +398,1 @@\n-                IOUtils.copyFile(assoc.data.iconPath,\n-                        faIconFile.srcPath());\n+            IOUtils.copyFile(faIcon, faIconFile.srcPath());\n@@ -462,3 +400,1 @@\n-                shellCommands.addIcon(mimeType, faIconFile.installPath(),\n-                        assoc.iconSize);\n-            }\n+            shellCommands.addIcon(mimeType, faIconFile.installPath(), fa.iconSize());\n@@ -468,1 +404,1 @@\n-    private void createDesktopFile(Map<String, String> data) throws IOException {\n+    private void saveDesktopFile(Map<String, String> data) throws IOException {\n@@ -475,1 +411,1 @@\n-                .saveToFile(desktopFile.srcPath());\n+                .saveToFile(desktopFile.orElseThrow().srcPath());\n@@ -479,4 +415,1 @@\n-        return associations.stream()\n-                .map(fa -> fa.data.mimeTypes)\n-                .flatMap(List::stream)\n-                .collect(Collectors.toUnmodifiableList());\n+        return associations.stream().map(FileAssociation::mimeType).toList();\n@@ -485,1 +418,1 @@\n-    private static int getSquareSizeOfImage(File f) {\n+    private static int getSquareSizeOfImage(Path path) {\n@@ -487,1 +420,1 @@\n-            BufferedImage bi = ImageIO.read(f);\n+            BufferedImage bi = ImageIO.read(path.toFile());\n@@ -521,7 +454,13 @@\n-    private static class LinuxFileAssociation {\n-        LinuxFileAssociation(FileAssociation fa) {\n-            this.data = fa;\n-            if (fa.iconPath != null && Files.isReadable(fa.iconPath)) {\n-                iconSize = getSquareSizeOfImage(fa.iconPath.toFile());\n-            } else {\n-                iconSize = -1;\n+    private interface LinuxFileAssociationMixin {\n+        int iconSize();\n+\n+        record Stub(int iconSize) implements LinuxFileAssociationMixin {}\n+    }\n+\n+    private static interface LinuxFileAssociation extends FileAssociation, LinuxFileAssociationMixin {\n+        static LinuxFileAssociation create(FileAssociation fa) {\n+            var iconSize = getIconSize(fa);\n+            if (iconSize <= 0) {\n+                \/\/ nullify the icon\n+                fa = new FileAssociation.Stub(fa.description(), Optional.empty(),\n+                        fa.mimeType(), fa.extension());\n@@ -529,0 +468,4 @@\n+            return CompositeProxy.build()\n+                    .invokeTunnel(CompositeProxyTunnel.INSTANCE)\n+                    .create(LinuxFileAssociation.class, fa,\n+                            new LinuxFileAssociationMixin.Stub(iconSize));\n@@ -531,2 +474,6 @@\n-        final FileAssociation data;\n-        final int iconSize;\n+        private static int getIconSize(FileAssociation fa) {\n+            return Optional.of(fa)\n+                    .flatMap(FileAssociation::icon)\n+                    .map(DesktopIntegration::getSquareSizeOfImage)\n+                    .orElse(-1);\n+        }\n@@ -535,1 +482,3 @@\n-    private final PlatformPackage thePackage;\n+    private final BuildEnv env;\n+    private final LinuxPackage pkg;\n+    private final Launcher launcher;\n@@ -539,3 +488,1 @@\n-    private final List<Map<String, ? super Object>> launchers;\n-\n-    private final OverridableResource iconResource;\n+    private final Optional<OverridableResource> iconResource;\n@@ -544,3 +491,3 @@\n-    private final DesktopFile mimeInfoFile;\n-    private final DesktopFile desktopFile;\n-    private final DesktopFile iconFile;\n+    private final InstallableFile mimeInfoFile;\n+    private final Optional<InstallableFile> desktopFile;\n+    private final Optional<InstallableFile> iconFile;\n@@ -551,17 +498,0 @@\n-\n-    private static final BundlerParamInfo<String> MENU_GROUP =\n-        new StandardBundlerParam<>(\n-                Arguments.CLIOptions.LINUX_MENU_GROUP.getId(),\n-                String.class,\n-                params -> I18N.getString(\"param.menu-group.default\"),\n-                (s, p) -> s\n-        );\n-\n-    private static final StandardBundlerParam<Boolean> LINUX_SHORTCUT_HINT =\n-        new StandardBundlerParam<>(\n-                Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n-                Boolean.class,\n-                params -> false,\n-                (s, p) -> (s == null || \"null\".equalsIgnoreCase(s))\n-                        ? false : Boolean.valueOf(s)\n-        );\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":138,"deletions":208,"binary":false,"changes":346,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,8 @@\n-        setAppImageSupplier(LinuxAppImageBuilder::new);\n+        setAppImageSupplier((params, output) -> {\n+            \/\/ Order is important!\n+            var app = LinuxFromParams.APPLICATION.fetchFrom(params);\n+            var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+            LinuxPackagingPipeline.build()\n+                    .excludeDirFromCopying(output.getParent())\n+                    .create().execute(BuildEnv.withAppImageDir(env, output), app);\n+        });\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppBundler.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -1,138 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.List;\n-import java.util.Map;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n-\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.util.PathUtils;\n-\n-public class LinuxAppImageBuilder extends AbstractAppImageBuilder {\n-\n-    static final BundlerParamInfo<Path> ICON_PNG =\n-            new StandardBundlerParam<>(\n-            \"icon.png\",\n-            Path.class,\n-            params -> {\n-                Path f = ICON.fetchFrom(params);\n-                if (f != null && f.getFileName() != null && !f.getFileName()\n-                        .toString().toLowerCase().endsWith(\".png\")) {\n-                    Log.error(MessageFormat.format(\n-                            I18N.getString(\"message.icon-not-png\"), f));\n-                    return null;\n-                }\n-                return f;\n-            },\n-            (s, p) -> Path.of(s));\n-\n-    static final String DEFAULT_ICON = \"JavaApp.png\";\n-\n-    LinuxAppImageBuilder(Path imageOutDir) {\n-        super(imageOutDir);\n-    }\n-\n-    private void writeEntry(InputStream in, Path dstFile) throws IOException {\n-        Files.createDirectories(dstFile.getParent());\n-        Files.copy(in, dstFile);\n-    }\n-\n-    public static String getLauncherName(Map<String, ? super Object> params) {\n-        return APP_NAME.fetchFrom(params);\n-    }\n-\n-    @Override\n-    public void prepareApplicationFiles(Map<String, ? super Object> params)\n-            throws IOException {\n-        appLayout.roots().stream().forEach(dir -> {\n-            try {\n-                IOUtils.writableOutputDir(dir);\n-            } catch (PackagerException pe) {\n-                throw new RuntimeException(pe);\n-            }\n-        });\n-\n-        \/\/ create the primary launcher\n-        createLauncherForEntryPoint(params, null);\n-\n-        \/\/ create app launcher shared library\n-        createLauncherLib();\n-\n-        \/\/ create the additional launchers, if any\n-        List<Map<String, ? super Object>> entryPoints\n-                = ADD_LAUNCHERS.fetchFrom(params);\n-        for (Map<String, ? super Object> entryPoint : entryPoints) {\n-            createLauncherForEntryPoint(AddLauncherArguments.merge(params,\n-                    entryPoint, ICON.getID(), ICON_PNG.getID()), params);\n-        }\n-\n-        \/\/ Copy class path entries to Java folder\n-        copyApplication(params);\n-    }\n-\n-    private void createLauncherLib() throws IOException {\n-        Path path = appLayout.pathGroup().getPath(\n-                ApplicationLayout.PathRole.LINUX_APPLAUNCHER_LIB);\n-        try (InputStream resource = getResourceAsStream(\"libjpackageapplauncheraux.so\")) {\n-            writeEntry(resource, path);\n-        }\n-\n-        path.toFile().setExecutable(true, false);\n-        path.toFile().setWritable(true, true);\n-    }\n-\n-    private void createLauncherForEntryPoint(Map<String, ? super Object> params,\n-            Map<String, ? super Object> mainParams) throws IOException {\n-        \/\/ Copy executable to launchers folder\n-        Path executableFile = appLayout.launchersDirectory().resolve(getLauncherName(params));\n-        try (InputStream is_launcher =\n-                getResourceAsStream(\"jpackageapplauncher\")) {\n-            writeEntry(is_launcher, executableFile);\n-        }\n-\n-        executableFile.toFile().setExecutable(true, false);\n-        executableFile.toFile().setWritable(true, true);\n-\n-        writeCfgFile(params);\n-\n-        var iconResource = createIconResource(DEFAULT_ICON, ICON_PNG, params,\n-                mainParams);\n-        if (iconResource != null) {\n-            Path iconTarget = appLayout.destktopIntegrationDirectory().resolve(\n-                    APP_NAME.fetchFrom(params) + PathUtils.getSuffix(Path.of(\n-                    DEFAULT_ICON)));\n-            iconResource.saveToFile(iconTarget);\n-        }\n-    }\n-}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppImageBuilder.java","additions":0,"deletions":138,"binary":false,"changes":138,"status":"deleted"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+interface LinuxApplicationLayout extends ApplicationLayout, LinuxApplicationLayoutMixin {\n+\n+    static LinuxApplicationLayout create(ApplicationLayout layout, Path libAppLauncher) {\n+        return CompositeProxy.build()\n+                .invokeTunnel(CompositeProxyTunnel.INSTANCE)\n+                .create(LinuxApplicationLayout.class, layout, new LinuxApplicationLayoutMixin.Stub(libAppLauncher));\n+    }\n+\n+    @Override\n+    default LinuxApplicationLayout resolveAt(Path root) {\n+        return create(ApplicationLayout.super.resolveAt(root),\n+                resolveNullablePath(root, libAppLauncher()));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayout.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+\n+\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+public interface LinuxApplicationLayoutMixin {\n+\n+    \/**\n+     * Path to \"libapplauncher.so\".\n+     *\/\n+    Path libAppLauncher();\n+\n+    record Stub(Path libAppLauncher) implements LinuxApplicationLayoutMixin {}\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxApplicationLayoutMixin.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -28,0 +28,4 @@\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n@@ -37,1 +41,0 @@\n-import java.text.MessageFormat;\n@@ -43,1 +46,0 @@\n-import java.util.Optional;\n@@ -45,0 +47,1 @@\n+import java.util.function.Function;\n@@ -50,11 +53,3 @@\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALLER_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.RELEASE;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.COPYRIGHT;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n@@ -64,39 +59,0 @@\n-    \/\/ Debian rules for package naming are used here\n-    \/\/ https:\/\/www.debian.org\/doc\/debian-policy\/ch-controlfields.html#s-f-Source\n-    \/\/\n-    \/\/ Package names must consist only of lower case letters (a-z),\n-    \/\/ digits (0-9), plus (+) and minus (-) signs, and periods (.).\n-    \/\/ They must be at least two characters long and\n-    \/\/ must start with an alphanumeric character.\n-    \/\/\n-    private static final Pattern DEB_PACKAGE_NAME_PATTERN =\n-            Pattern.compile(\"^[a-z][a-z\\\\d\\\\+\\\\-\\\\.]+\");\n-\n-    private static final BundlerParamInfo<String> PACKAGE_NAME =\n-            new StandardBundlerParam<> (\n-            Arguments.CLIOptions.LINUX_BUNDLE_NAME.getId(),\n-            String.class,\n-            params -> {\n-                String nm = INSTALLER_NAME.fetchFrom(params);\n-                if (nm == null) return null;\n-\n-                \/\/ make sure to lower case and spaces\/underscores become dashes\n-                nm = nm.toLowerCase().replaceAll(\"[ _]\", \"-\");\n-                return nm;\n-            },\n-            (s, p) -> {\n-                if (!DEB_PACKAGE_NAME_PATTERN.matcher(s).matches()) {\n-                    try {\n-                        throw new ConfigException(\n-                            MessageFormat.format(I18N.getString(\n-                            \"error.deb-invalid-value-for-package-name\"), s),\n-                            I18N.getString(\n-                            \"error.deb-invalid-value-for-package-name.advice\"));\n-                    } catch (ConfigException ex) {\n-                        throw new IllegalArgumentException(ex);\n-                    }\n-                }\n-\n-                return s;\n-            });\n-\n@@ -107,65 +63,0 @@\n-    private static final String DEB_ARCH;\n-    static {\n-        String debArch;\n-        try {\n-            debArch = Executor.of(TOOL_DPKG, \"--print-architecture\").saveOutput(\n-                    true).executeExpectSuccess().getOutput().get(0);\n-        } catch (IOException ex) {\n-            debArch = null;\n-        }\n-        DEB_ARCH = debArch;\n-    }\n-\n-    private static final String releaseSuffix(Map<String, ? super Object> params) {\n-        return Optional.ofNullable(RELEASE.fetchFrom(params, false)).map(\n-                rel -> \"-\" + rel).orElse(\"\");\n-    }\n-\n-    private static final BundlerParamInfo<String> FULL_PACKAGE_NAME =\n-            new StandardBundlerParam<>(\n-                    \"linux.deb.fullPackageName\", String.class, params -> {\n-                        return PACKAGE_NAME.fetchFrom(params)\n-                            + \"_\" + VERSION.fetchFrom(params)\n-                            + releaseSuffix(params)\n-                            + \"_\" + DEB_ARCH;\n-                    }, (s, p) -> s);\n-\n-    private static final BundlerParamInfo<String> EMAIL =\n-            new StandardBundlerParam<> (\n-            Arguments.CLIOptions.LINUX_DEB_MAINTAINER.getId(),\n-            String.class,\n-            params -> \"Unknown\",\n-            (s, p) -> s);\n-\n-    private static final BundlerParamInfo<String> MAINTAINER =\n-            new StandardBundlerParam<> (\n-            Arguments.CLIOptions.LINUX_DEB_MAINTAINER.getId() + \".internal\",\n-            String.class,\n-            params -> VENDOR.fetchFrom(params) + \" <\"\n-                    + EMAIL.fetchFrom(params) + \">\",\n-            (s, p) -> s);\n-\n-    private static final BundlerParamInfo<String> SECTION =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.LINUX_CATEGORY.getId(),\n-            String.class,\n-            params -> \"misc\",\n-            (s, p) -> s);\n-\n-    private static final BundlerParamInfo<String> LICENSE_TEXT =\n-            new StandardBundlerParam<> (\n-            \"linux.deb.licenseText\",\n-            String.class,\n-            params -> {\n-                try {\n-                    String licenseFile = LICENSE_FILE.fetchFrom(params);\n-                    if (licenseFile != null) {\n-                        return Files.readString(Path.of(licenseFile));\n-                    }\n-                } catch (IOException e) {\n-                    Log.verbose(e);\n-                }\n-                return \"Unknown\";\n-            },\n-            (s, p) -> s);\n-\n@@ -173,1 +64,1 @@\n-        super(PACKAGE_NAME);\n+        super(LinuxFromParams.DEB_PACKAGE);\n@@ -177,2 +68,1 @@\n-    public void doValidate(Map<String, ? super Object> params)\n-            throws ConfigException {\n+    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n@@ -181,1 +71,1 @@\n-        if (LICENSE_FILE.fetchFrom(params) == null) {\n+        if (pkg.licenseFile().isEmpty()) {\n@@ -187,2 +77,1 @@\n-    protected List<ToolValidator> getToolValidators(\n-            Map<String, ? super Object> params) {\n+    protected List<ToolValidator> getToolValidators() {\n@@ -194,8 +83,10 @@\n-    protected Path buildPackageBundle(\n-            Map<String, String> replacementData,\n-            Map<String, ? super Object> params, Path outputParentDir) throws\n-            PackagerException, IOException {\n-\n-        prepareProjectConfig(replacementData, params);\n-        adjustPermissionsRecursive(createMetaPackage(params).sourceRoot());\n-        return buildDeb(params, outputParentDir);\n+    protected void createConfigFiles(Map<String, String> replacementData,\n+            BuildEnv env, LinuxPackage pkg) throws IOException {\n+        prepareProjectConfig(replacementData, env, pkg);\n+        adjustPermissionsRecursive(env.appImageDir());\n+    }\n+\n+    @Override\n+    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n+            Path outputParentDir) throws PackagerException, IOException {\n+        return buildDeb(env, pkg, outputParentDir);\n@@ -207,3 +98,1 @@\n-    protected void initLibProvidersLookup(\n-            Map<String, ? super Object> params,\n-            LibProvidersLookup libProvidersLookup) {\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n@@ -274,0 +163,2 @@\n+        var debArch = LinuxPackageArch.getValue(LINUX_DEB);\n+\n@@ -280,1 +171,1 @@\n-                        if (name.endsWith(\":\" + DEB_ARCH)) {\n+                        if (name.endsWith(\":\" + debArch)) {\n@@ -283,1 +174,1 @@\n-                                    name.length() - (DEB_ARCH.length() + 1));\n+                                    name.length() - (debArch.length() + 1));\n@@ -298,2 +189,2 @@\n-    protected List<ConfigException> verifyOutputBundle(\n-            Map<String, ? super Object> params, Path packageBundle) {\n+    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n+            Path packageBundle) {\n@@ -305,1 +196,1 @@\n-                new PackageProperty(\"Package\", PACKAGE_NAME.fetchFrom(params),\n+                new PackageProperty(\"Package\", pkg.packageName(),\n@@ -307,2 +198,1 @@\n-                new PackageProperty(\"Version\", String.format(\"%s%s\",\n-                        VERSION.fetchFrom(params), releaseSuffix(params)),\n+                new PackageProperty(\"Version\", ((LinuxDebPackage)pkg).versionWithRelease(),\n@@ -311,2 +201,1 @@\n-                new PackageProperty(\"Architecture\", DEB_ARCH, \"APPLICATION_ARCH\",\n-                        controlFileName));\n+                new PackageProperty(\"Architecture\", pkg.arch(), \"APPLICATION_ARCH\", controlFileName));\n@@ -407,1 +296,1 @@\n-        void create(Map<String, String> data, Map<String, ? super Object> params)\n+        void create(Map<String, String> data, Function<String, OverridableResource> resourceFactory)\n@@ -409,2 +298,1 @@\n-            createResource(\"template.\" + dstFilePath.getFileName().toString(),\n-                    params)\n+            resourceFactory.apply(\"template.\" + dstFilePath.getFileName().toString())\n@@ -424,2 +312,1 @@\n-    private void prepareProjectConfig(Map<String, String> data,\n-            Map<String, ? super Object> params) throws IOException {\n+    private void prepareProjectConfig(Map<String, String> data, BuildEnv env, LinuxPackage pkg) throws IOException {\n@@ -427,1 +314,1 @@\n-        Path configDir = createMetaPackage(params).sourceRoot().resolve(\"DEBIAN\");\n+        Path configDir = env.appImageDir().resolve(\"DEBIAN\");\n@@ -445,6 +332,2 @@\n-        final String installDir = LINUX_INSTALL_DIR.fetchFrom(params);\n-\n-        if (!StandardBundlerParam.isRuntimeInstaller(params)\n-                || (isInstallDirInUsrTree(installDir) || installDir.startsWith(\"\/usr\/\"))) {\n-            debianFiles.add(new DebianFile(\n-                    getConfig_CopyrightFile(params),\n+        ((LinuxDebPackage)pkg).relativeCopyrightFilePath().ifPresent(copyrightFile -> {\n+            debianFiles.add(new DebianFile(env.appImageDir().resolve(copyrightFile),\n@@ -452,1 +335,1 @@\n-        }\n+        });\n@@ -455,1 +338,1 @@\n-            debianFile.create(data, params);\n+            debianFile.create(data, env::createResource);\n@@ -460,2 +343,1 @@\n-    protected Map<String, String> createReplacementData(\n-            Map<String, ? super Object> params) throws IOException {\n+    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n@@ -464,5 +346,7 @@\n-        data.put(\"APPLICATION_MAINTAINER\", MAINTAINER.fetchFrom(params));\n-        data.put(\"APPLICATION_SECTION\", SECTION.fetchFrom(params));\n-        data.put(\"APPLICATION_COPYRIGHT\", COPYRIGHT.fetchFrom(params));\n-        data.put(\"APPLICATION_LICENSE_TEXT\", LICENSE_TEXT.fetchFrom(params));\n-        data.put(\"APPLICATION_ARCH\", DEB_ARCH);\n+        String licenseText = pkg.licenseFile().map(toFunction(Files::readString)).orElse(\"Unknown\");\n+\n+        data.put(\"APPLICATION_MAINTAINER\", ((LinuxDebPackage) pkg).maintainer());\n+        data.put(\"APPLICATION_SECTION\", pkg.category().orElseThrow());\n+        data.put(\"APPLICATION_COPYRIGHT\", pkg.app().copyright());\n+        data.put(\"APPLICATION_LICENSE_TEXT\", licenseText);\n+        data.put(\"APPLICATION_ARCH\", pkg.arch());\n@@ -470,6 +354,5 @@\n-                createMetaPackage(params).sourceApplicationLayout().sizeInBytes() >> 10));\n-        data.put(\"APPLICATION_HOMEPAGE\", Optional.ofNullable(\n-                ABOUT_URL.fetchFrom(params)).map(value -> \"Homepage: \" + value).orElse(\n-                \"\"));\n-        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", String.format(\"%s%s\",\n-                VERSION.fetchFrom(params), releaseSuffix(params)));\n+                AppImageLayout.toPathGroup(pkg.packageLayout().resolveAt(\n+                        env.appImageDir())).sizeInBytes() >> 10));\n+        data.put(\"APPLICATION_HOMEPAGE\", pkg.aboutURL().map(\n+                value -> \"Homepage: \" + value).orElse(\"\"));\n+        data.put(\"APPLICATION_VERSION_WITH_RELEASE\", ((LinuxDebPackage) pkg).versionWithRelease());\n@@ -480,31 +363,3 @@\n-    private Path getConfig_CopyrightFile(Map<String, ? super Object> params) {\n-        final String installDir = LINUX_INSTALL_DIR.fetchFrom(params);\n-        final String packageName = PACKAGE_NAME.fetchFrom(params);\n-\n-        final Path installPath;\n-        if (isInstallDirInUsrTree(installDir) || installDir.startsWith(\"\/usr\/\")) {\n-            installPath = Path.of(\"\/usr\/share\/doc\/\", packageName, \"copyright\");\n-        } else {\n-            installPath = Path.of(installDir, packageName, \"share\/doc\/copyright\");\n-        }\n-\n-        return createMetaPackage(params).sourceRoot().resolve(\n-                Path.of(\"\/\").relativize(installPath));\n-    }\n-\n-    private Path buildDeb(Map<String, ? super Object> params,\n-            Path outdir) throws IOException {\n-\n-        PlatformPackage thePackage = createMetaPackage(params);\n-\n-        new ScriptRunner()\n-              .setDirectory(thePackage.sourceRoot())\n-              .setResourceCategoryId(\"resource.post-app-image-script\")\n-              .setScriptNameSuffix(\"post-image\")\n-              .setEnvironmentVariable(\"JpAppImageDir\", thePackage.sourceRoot().toAbsolutePath().toString())\n-              .run(params);\n-\n-        Path outFile = outdir.resolve(\n-                FULL_PACKAGE_NAME.fetchFrom(params)+\".deb\");\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.outputting-to-location\"), outFile.toAbsolutePath().toString()));\n+    private Path buildDeb(BuildEnv env, LinuxPackage pkg, Path outdir) throws IOException {\n+        Path outFile = outdir.resolve(pkg.packageFileNameWithSuffix());\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", outFile.toAbsolutePath()));\n@@ -517,1 +372,1 @@\n-        cmdline.addAll(List.of(\"-b\", thePackage.sourceRoot().toString(),\n+        cmdline.addAll(List.of(\"-b\", env.appImageDir().toString(),\n@@ -525,2 +380,1 @@\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.output-to-location\"), outFile.toAbsolutePath().toString()));\n+        Log.verbose(I18N.format(\"message.output-to-location\", outFile.toAbsolutePath()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":58,"deletions":204,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+import jdk.jpackage.internal.model.LinuxDebPackageMixin;\n+\n+final class LinuxDebPackageBuilder {\n+\n+    LinuxDebPackageBuilder(LinuxPackageBuilder pkgBuilder) {\n+        this.pkgBuilder = Objects.requireNonNull(pkgBuilder);\n+    }\n+\n+    LinuxDebPackage create() throws ConfigException {\n+        if (pkgBuilder.category().isEmpty()) {\n+            pkgBuilder.category(DEFAULTS.category());\n+        }\n+        var pkg = pkgBuilder.create();\n+        return LinuxDebPackage.create(pkg, new LinuxDebPackageMixin.Stub(\n+                Optional.ofNullable(maintainerEmail).orElseGet(\n+                        DEFAULTS::maintainerEmail)));\n+    }\n+\n+    LinuxDebPackageBuilder maintainerEmail(String v) {\n+        maintainerEmail = v;\n+        return this;\n+    }\n+\n+    private record Defaults(String maintainerEmail, String category) {\n+    }\n+\n+    private String maintainerEmail;\n+\n+    private final LinuxPackageBuilder pkgBuilder;\n+\n+    private static final Defaults DEFAULTS = new Defaults(\"Unknown\", \"misc\");\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebPackageBuilder.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,142 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n+import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n+import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n+import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n+import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n+import static jdk.jpackage.internal.LinuxPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_DEB;\n+import static jdk.jpackage.internal.model.StandardPackageType.LINUX_RPM;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxApplication;\n+import jdk.jpackage.internal.model.LinuxLauncher;\n+import jdk.jpackage.internal.model.LinuxLauncherMixin;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+\n+final class LinuxFromParams {\n+\n+    private static LinuxApplication createLinuxApplication(\n+            Map<String, ? super Object> params) throws ConfigException, IOException {\n+        final var launcherFromParams = new LauncherFromParams();\n+        final var app = createApplicationBuilder(params, toFunction(launcherParams -> {\n+            final var launcher = launcherFromParams.create(launcherParams);\n+            final var shortcut = Stream.of(SHORTCUT_HINT, LINUX_SHORTCUT_HINT).map(param -> {\n+                return param.findIn(launcherParams);\n+            }).filter(Optional::isPresent).map(Optional::get).findFirst();\n+            return LinuxLauncher.create(launcher, new LinuxLauncherMixin.Stub(shortcut));\n+        }), APPLICATION_LAYOUT).create();\n+        return LinuxApplication.create(app);\n+    }\n+\n+    private static LinuxPackageBuilder createLinuxPackageBuilder(\n+            Map<String, ? super Object> params, StandardPackageType type) throws ConfigException, IOException {\n+\n+        final var app = APPLICATION.fetchFrom(params);\n+\n+        final var superPkgBuilder = createPackageBuilder(params, app, type);\n+\n+        final var pkgBuilder = new LinuxPackageBuilder(superPkgBuilder);\n+\n+        LINUX_PACKAGE_DEPENDENCIES.copyInto(params, pkgBuilder::additionalDependencies);\n+        LINUX_CATEGORY.copyInto(params, pkgBuilder::category);\n+        LINUX_MENU_GROUP.copyInto(params, pkgBuilder::menuGroupName);\n+        RELEASE.copyInto(params, pkgBuilder::release);\n+        LINUX_PACKAGE_NAME.copyInto(params, pkgBuilder::literalName);\n+\n+        return pkgBuilder;\n+    }\n+\n+    private static LinuxPackage createLinuxRpmPackage(\n+            Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var superPkgBuilder = createLinuxPackageBuilder(params, LINUX_RPM);\n+\n+        final var pkgBuilder = new LinuxRpmPackageBuilder(superPkgBuilder);\n+\n+        LICENSE_TYPE.copyInto(params, pkgBuilder::licenseType);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    private static LinuxPackage createLinuxDebPackage(\n+            Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var superPkgBuilder = createLinuxPackageBuilder(params, LINUX_DEB);\n+\n+        final var pkgBuilder = new LinuxDebPackageBuilder(superPkgBuilder);\n+\n+        MAINTAINER_EMAIL.copyInto(params, pkgBuilder::maintainerEmail);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static final BundlerParamInfo<LinuxApplication> APPLICATION = createApplicationBundlerParam(\n+            LinuxFromParams::createLinuxApplication);\n+\n+    static final BundlerParamInfo<LinuxPackage> RPM_PACKAGE = createPackageBundlerParam(\n+            LinuxFromParams::createLinuxRpmPackage);\n+\n+    static final BundlerParamInfo<LinuxPackage> DEB_PACKAGE = createPackageBundlerParam(\n+            LinuxFromParams::createLinuxDebPackage);\n+\n+    private static final BundlerParamInfo<Boolean> LINUX_SHORTCUT_HINT = new BundlerParamInfo<>(\n+            Arguments.CLIOptions.LINUX_SHORTCUT_HINT.getId(),\n+            Boolean.class,\n+            params -> false,\n+            (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ? false : Boolean.valueOf(s)\n+    );\n+\n+    private static final BundlerParamInfo<String> LINUX_CATEGORY = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_CATEGORY.getId());\n+\n+    private static final BundlerParamInfo<String> LINUX_PACKAGE_DEPENDENCIES = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_PACKAGE_DEPENDENCIES.getId());\n+\n+    private static final BundlerParamInfo<String> LINUX_MENU_GROUP = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_MENU_GROUP.getId());\n+\n+    private static final BundlerParamInfo<String> RELEASE = createStringBundlerParam(\n+            Arguments.CLIOptions.RELEASE.getId());\n+\n+    private static final BundlerParamInfo<String> LINUX_PACKAGE_NAME = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_BUNDLE_NAME.getId());\n+\n+    private static final BundlerParamInfo<String> LICENSE_TYPE = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_RPM_LICENSE_TYPE.getId());\n+\n+    private static final BundlerParamInfo<String> MAINTAINER_EMAIL = createStringBundlerParam(\n+            Arguments.CLIOptions.LINUX_DEB_MAINTAINER.getId());\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":142,"deletions":0,"binary":false,"changes":142,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,2 @@\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.Package;\n@@ -40,4 +41,3 @@\n-    private LinuxLaunchersAsServices(PlatformPackage thePackage,\n-            Map<String, Object> params) throws IOException {\n-        super(thePackage, REQUIRED_PACKAGES, params, li -> {\n-            return new Launcher(thePackage, li.getName(), params);\n+    private LinuxLaunchersAsServices(BuildEnv env, Package pkg) throws IOException {\n+        super(env.appImageDir(), pkg.app(), REQUIRED_PACKAGES, launcher -> {\n+            return new LauncherImpl(env, pkg, launcher);\n@@ -61,3 +61,2 @@\n-    static ShellCustomAction create(PlatformPackage thePackage,\n-            Map<String, Object> params) throws IOException {\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+    static ShellCustomAction create(BuildEnv env, Package pkg) throws IOException {\n+        if (pkg.isRuntimeInstaller()) {\n@@ -66,1 +65,1 @@\n-        return new LinuxLaunchersAsServices(thePackage, params);\n+        return new LinuxLaunchersAsServices(env, pkg);\n@@ -69,2 +68,1 @@\n-    public static Path getServiceUnitFileName(String packageName,\n-            String launcherName) {\n+    public static Path getServiceUnitFileName(String packageName, String launcherName) {\n@@ -75,1 +73,1 @@\n-    private static class Launcher extends UnixLauncherAsService {\n+    private static final class LauncherImpl extends UnixLauncherAsService {\n@@ -77,5 +75,3 @@\n-        Launcher(PlatformPackage thePackage, String name,\n-                Map<String, Object> mainParams) {\n-            super(name, mainParams, createResource(\"unit-template.service\",\n-                    mainParams).setCategory(I18N.getString(\n-                            \"resource.systemd-unit-file\")));\n+        LauncherImpl(BuildEnv env, Package pkg, Launcher launcher) {\n+            super(pkg.app(), launcher, env.createResource(\"unit-template.service\").setCategory(\n+                    I18N.getString(\"resource.systemd-unit-file\")));\n@@ -83,1 +79,1 @@\n-            unitFilename = getServiceUnitFileName(thePackage.name(), getName());\n+            unitFilename = getServiceUnitFileName(pkg.packageName(), launcher.executableName());\n@@ -85,6 +81,4 @@\n-            getResource()\n-                    .setPublicName(unitFilename)\n-                    .addSubstitutionDataEntry(\"APPLICATION_LAUNCHER\",\n-                            Enquoter.forPropertyValues().applyTo(\n-                                    thePackage.installedApplicationLayout().launchersDirectory().resolve(\n-                                            getName()).toString()));\n+            getResource().setPublicName(unitFilename).addSubstitutionDataEntry(\n+                    \"APPLICATION_LAUNCHER\",\n+                    Enquoter.forPropertyValues().applyTo(\n+                            pkg.asInstalledPackageApplicationLayout().orElseThrow().launchersDirectory().resolve(getName()).toString()));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxLaunchersAsServices.java","additions":19,"deletions":25,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+\n+final class LinuxPackageArch {\n+\n+    static String getValue(StandardPackageType pkgType) {\n+        switch (pkgType) {\n+            case LINUX_RPM -> {\n+                return RpmPackageArch.VALUE;\n+            }\n+            case LINUX_DEB -> {\n+                return DebPackageArch.VALUE;\n+            }\n+            default -> {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private static class DebPackageArch {\n+\n+        static final String VALUE = toSupplier(DebPackageArch::getValue).get();\n+\n+        private static String getValue() throws IOException {\n+            return Executor.of(\"dpkg\", \"--print-architecture\").saveOutput(true)\n+                    .executeExpectSuccess().getOutput().get(0);\n+        }\n+    }\n+\n+    private static class RpmPackageArch {\n+\n+        \/*\n+         * Various ways to get rpm arch. Needed to address JDK-8233143. rpmbuild is mandatory for\n+         * rpm packaging, try it first. rpm is optional and may not be available, use as the last\n+         * resort.\n+         *\/\n+        private static enum RpmArchReader {\n+            Rpmbuild(\"rpmbuild\", \"--eval=%{_target_cpu}\"),\n+            Rpm(\"rpm\", \"--eval=%{_target_cpu}\");\n+\n+            RpmArchReader(String... cmdline) {\n+                this.cmdline = cmdline;\n+            }\n+\n+            String getRpmArch() throws IOException {\n+                Executor exec = Executor.of(cmdline).saveOutput(true);\n+                switch (this) {\n+                    case Rpm -> {\n+                        exec.executeExpectSuccess();\n+                    }\n+                    case Rpmbuild -> {\n+                        if (exec.execute() != 0) {\n+                            return null;\n+                        }\n+                    }\n+                    default -> {\n+                        throw new UnsupportedOperationException();\n+                    }\n+                }\n+                return exec.getOutput().get(0);\n+            }\n+\n+            private final String[] cmdline;\n+        }\n+\n+        static final String VALUE = toSupplier(RpmPackageArch::getValue).get();\n+\n+        private static String getValue() throws IOException {\n+            for (var rpmArchReader : RpmArchReader.values()) {\n+                var rpmArchStr = rpmArchReader.getRpmArch();\n+                if (rpmArchStr != null) {\n+                    return rpmArchStr;\n+                }\n+            }\n+            throw new RuntimeException(\"error.rpm-arch-not-detected\");\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageArch.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.LinuxPackageMixin;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+\n+final class LinuxPackageBuilder {\n+\n+    LinuxPackageBuilder(PackageBuilder pkgBuilder) {\n+        this.pkgBuilder = Objects.requireNonNull(pkgBuilder);\n+    }\n+\n+    LinuxPackage create() throws ConfigException {\n+        if (literalName != null) {\n+            pkgBuilder.name(literalName);\n+        } else {\n+            \/\/ Lower case and turn spaces\/underscores into dashes\n+            pkgBuilder.name(pkgBuilder.create().packageName().toLowerCase().replaceAll(\"[ _]\", \"-\"));\n+        }\n+\n+        final var pkg = pkgBuilder.create();\n+\n+        final var stdPkgType = pkg.asStandardPackageType();\n+        if (stdPkgType.isPresent()) {\n+            validatePackageName(pkg.packageName(), stdPkgType.orElseThrow());\n+        }\n+\n+        var reply = create(pkg, pkg.packageLayout());\n+        if (reply.isInstallDirInUsrTree()) {\n+            reply = create(pkg, usrTreePackageLayout(pkg.relativeInstallDir(), pkg.packageName()));\n+        }\n+\n+        return reply;\n+    }\n+\n+    private LinuxPackage create(Package pkg, AppImageLayout pkgLayout) throws ConfigException {\n+        return LinuxPackage.create(pkg, new LinuxPackageMixin.Stub(\n+                pkgLayout,\n+                Optional.ofNullable(menuGroupName).orElseGet(DEFAULTS::menuGroupName),\n+                Optional.ofNullable(category),\n+                Optional.ofNullable(additionalDependencies),\n+                Optional.ofNullable(release),\n+                pkg.asStandardPackageType().map(LinuxPackageArch::getValue).orElseThrow()));\n+    }\n+\n+    LinuxPackageBuilder literalName(String v) {\n+        literalName = v;\n+        return this;\n+    }\n+\n+    LinuxPackageBuilder menuGroupName(String v) {\n+        menuGroupName = v;\n+        return this;\n+    }\n+\n+    LinuxPackageBuilder category(String v) {\n+        category = v;\n+        return this;\n+    }\n+\n+    Optional<String> category() {\n+        return Optional.ofNullable(category);\n+    }\n+\n+    LinuxPackageBuilder additionalDependencies(String v) {\n+        additionalDependencies = v;\n+        return this;\n+    }\n+\n+    LinuxPackageBuilder release(String v) {\n+        release = v;\n+        return this;\n+    }\n+\n+    Optional<String> release() {\n+        return Optional.ofNullable(release);\n+    }\n+\n+    private static LinuxApplicationLayout usrTreePackageLayout(Path prefix, String packageName) {\n+        final var lib = prefix.resolve(Path.of(\"lib\", packageName));\n+        return LinuxApplicationLayout.create(\n+                ApplicationLayout.build()\n+                        .launchersDirectory(prefix.resolve(\"bin\"))\n+                        .appDirectory(lib.resolve(\"app\"))\n+                        .runtimeDirectory(lib.resolve(\"runtime\"))\n+                        .destktopIntegrationDirectory(lib)\n+                        .appModsDirectory(lib.resolve(\"app\/mods\"))\n+                        .contentDirectory(lib)\n+                        .create(),\n+                lib.resolve(\"lib\/libapplauncher.so\"));\n+    }\n+\n+    private static void validatePackageName(String packageName,\n+            StandardPackageType pkgType) throws ConfigException {\n+        switch (pkgType) {\n+            case LINUX_DEB -> {\n+                \/\/\n+                \/\/ Debian rules for package naming are used here\n+                \/\/ https:\/\/www.debian.org\/doc\/debian-policy\/ch-controlfields.html#s-f-Source\n+                \/\/\n+                \/\/ Package names must consist only of lower case letters (a-z),\n+                \/\/ digits (0-9), plus (+) and minus (-) signs, and periods (.).\n+                \/\/ They must be at least two characters long and\n+                \/\/ must start with an alphanumeric character.\n+                \/\/\n+                var regexp = Pattern.compile(\"^[a-z][a-z\\\\d\\\\+\\\\-\\\\.]+\");\n+                if (!regexp.matcher(packageName).matches()) {\n+                    throw buildConfigException()\n+                            .message(\"error.deb-invalid-value-for-package-name\", packageName)\n+                            .advice(\"error.deb-invalid-value-for-package-name.advice\")\n+                            .create();\n+                }\n+            }\n+            case LINUX_RPM -> {\n+                \/\/\n+                \/\/ Fedora rules for package naming are used here\n+                \/\/ https:\/\/fedoraproject.org\/wiki\/Packaging:NamingGuidelines?rd=Packaging\/NamingGuidelines\n+                \/\/\n+                \/\/ all Fedora packages must be named using only the following ASCII\n+                \/\/ characters. These characters are displayed here:\n+                \/\/\n+                \/\/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._+\n+                \/\/\n+                var regexp = Pattern.compile(\"[a-z\\\\d\\\\+\\\\-\\\\.\\\\_]+\", Pattern.CASE_INSENSITIVE);\n+                if (!regexp.matcher(packageName).matches()) {\n+                    throw buildConfigException()\n+                            .message(\"error.rpm-invalid-value-for-package-name\", packageName)\n+                            .advice(\"error.rpm-invalid-value-for-package-name.advice\")\n+                            .create();\n+                }\n+            }\n+            default -> {\n+            }\n+        }\n+    }\n+\n+    private record Defaults(String menuGroupName) {\n+    }\n+\n+    private String literalName;\n+    private String menuGroupName;\n+    private String category;\n+    private String additionalDependencies;\n+    private String release;\n+\n+    private final PackageBuilder pkgBuilder;\n+\n+    private static final Defaults DEFAULTS = new Defaults(I18N.getString(\n+            \"param.menu-group.default\"));\n+\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBuilder.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -28,1 +28,0 @@\n-import java.nio.file.InvalidPathException;\n@@ -30,1 +29,0 @@\n-import java.nio.file.Files;\n@@ -37,2 +35,0 @@\n-import java.util.Set;\n-import java.util.function.Function;\n@@ -40,1 +36,0 @@\n-import java.util.function.Supplier;\n@@ -42,6 +37,4 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n-\n+import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n@@ -49,0 +42,3 @@\n+import jdk.jpackage.internal.model.LinuxDebPackage;\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.Package;\n@@ -50,1 +46,0 @@\n-import jdk.jpackage.internal.util.FileUtils;\n@@ -54,3 +49,2 @@\n-    LinuxPackageBundler(BundlerParamInfo<String> packageName) {\n-        this.packageName = packageName;\n-        appImageBundler = new LinuxAppBundler().setDependentTask(true);\n+    LinuxPackageBundler(BundlerParamInfo<? extends LinuxPackage> pkgParam) {\n+        this.pkgParam = pkgParam;\n@@ -66,12 +60,3 @@\n-        \/\/ run basic validation to ensure requirements are met\n-        \/\/ we are not interested in return code, only possible exception\n-        appImageBundler.validate(params);\n-\n-        validateInstallDir(LINUX_INSTALL_DIR.fetchFrom(params));\n-\n-        FileAssociation.verify(FileAssociation.fetchFrom(params));\n-\n-        \/\/ If package name has some restrictions, the string converter will\n-        \/\/ throw an exception if invalid\n-        packageName.getStringConverter().apply(packageName.fetchFrom(params),\n-            params);\n+        \/\/ Order is important!\n+        LinuxPackage pkg = pkgParam.fetchFrom(params);\n+        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -79,1 +64,1 @@\n-        for (var validator: getToolValidators(params)) {\n+        for (var validator: getToolValidators()) {\n@@ -107,1 +92,1 @@\n-        doValidate(params);\n+        doValidate(env, pkg);\n@@ -122,32 +107,3 @@\n-        PlatformPackage thePackage = createMetaPackage(params);\n-\n-        Function<Path, ApplicationLayout> initAppImageLayout = imageRoot -> {\n-            ApplicationLayout layout = appImageLayout(params);\n-            layout.pathGroup().setPath(new Object(),\n-                    AppImageFile.getPathInAppImage(Path.of(\"\")));\n-            return layout.resolveAt(imageRoot);\n-        };\n-\n-        try {\n-            Path appImage = StandardBundlerParam.getPredefinedAppImage(params);\n-\n-            \/\/ we either have an application image or need to build one\n-            if (appImage != null) {\n-                initAppImageLayout.apply(appImage).copy(\n-                        thePackage.sourceApplicationLayout());\n-            } else {\n-                final Path srcAppImageRoot = thePackage.sourceRoot().resolve(\"src\");\n-                appImage = appImageBundler.execute(params, srcAppImageRoot);\n-                ApplicationLayout srcAppLayout = initAppImageLayout.apply(\n-                        appImage);\n-                if (appImage.equals(PREDEFINED_RUNTIME_IMAGE.fetchFrom(params))) {\n-                    \/\/ Application image points to run-time image.\n-                    \/\/ Copy it.\n-                    srcAppLayout.copy(thePackage.sourceApplicationLayout());\n-                } else {\n-                    \/\/ Application image is a newly created directory tree.\n-                    \/\/ Move it.\n-                    srcAppLayout.move(thePackage.sourceApplicationLayout());\n-                    FileUtils.deleteRecursive(srcAppImageRoot);\n-                }\n-            }\n+        \/\/ Order is important!\n+        final LinuxPackage pkg = pkgParam.fetchFrom(params);\n+        final var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -155,3 +111,5 @@\n-            for (var ca : customActions) {\n-                ca.init(thePackage, params);\n-            }\n+        final var pipelineBuilder = LinuxPackagingPipeline.build()\n+                .excludeDirFromCopying(outputParentDir)\n+                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .packageAction(this::buildPackage)\n+                        .add();\n@@ -159,1 +117,3 @@\n-            Map<String, String> data = createDefaultReplacementData(params);\n+        final var createConfigFilesTaskBuilder = pipelineBuilder\n+                .task(PackageTaskID.CREATE_CONFIG_FILES)\n+                .packageAction(this::buildConfigFiles);\n@@ -161,4 +121,7 @@\n-            for (var ca : customActions) {\n-                ShellCustomAction.mergeReplacementData(data, ca.instance.\n-                        create());\n-            }\n+        if (pkg instanceof LinuxDebPackage) {\n+            \/\/ Build deb config files after app image contents are ready because\n+            \/\/ it calculates the size of the image and saves the value in one of the config files.\n+            createConfigFilesTaskBuilder.addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE);\n+        }\n+\n+        createConfigFilesTaskBuilder.add();\n@@ -166,1 +129,1 @@\n-            data.putAll(createReplacementData(params));\n+        pipelineBuilder.create().execute(env, pkg, outputParentDir);\n@@ -168,2 +131,7 @@\n-            Path packageBundle = buildPackageBundle(Collections.unmodifiableMap(\n-                    data), params, outputParentDir);\n+        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n+    }\n+\n+    private void buildConfigFiles(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n+        for (var ca : customActions) {\n+            ca.init(env.env(), env.pkg());\n+        }\n@@ -171,6 +139,1 @@\n-            verifyOutputBundle(params, packageBundle).stream()\n-                    .filter(Objects::nonNull)\n-                    .forEachOrdered(ex -> {\n-                Log.verbose(ex.getLocalizedMessage());\n-                Log.verbose(ex.getAdvice());\n-            });\n+        Map<String, String> data = createDefaultReplacementData(env.env(), env.pkg());\n@@ -178,4 +141,2 @@\n-            return packageBundle;\n-        } catch (IOException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n+        for (var ca : customActions) {\n+            ShellCustomAction.mergeReplacementData(data, ca.instance.create());\n@@ -183,0 +144,4 @@\n+\n+        data.putAll(createReplacementData(env.env(), env.pkg()));\n+\n+        createConfigFiles(Collections.unmodifiableMap(data), env.env(), env.pkg());\n@@ -185,2 +150,10 @@\n-    private List<String> getListOfNeededPackages(\n-            Map<String, ? super Object> params) throws IOException {\n+    private void buildPackage(PackageBuildEnv<LinuxPackage, AppImageLayout> env) throws PackagerException, IOException {\n+        Path packageBundle = buildPackageBundle(env.env(), env.pkg(), env.outputDir());\n+\n+        verifyOutputBundle(env.env(), env.pkg(), packageBundle).stream()\n+                .filter(Objects::nonNull)\n+                .forEachOrdered(ex -> {\n+            Log.verbose(ex.getLocalizedMessage());\n+            Log.verbose(ex.getAdvice());\n+        });\n+    }\n@@ -188,1 +161,1 @@\n-        PlatformPackage thePackage = createMetaPackage(params);\n+    private List<String> getListOfNeededPackages(BuildEnv env) throws IOException {\n@@ -196,1 +169,1 @@\n-        if (withFindNeededPackages && Files.exists(thePackage.sourceRoot())) {\n+        if (withFindNeededPackages) {\n@@ -198,1 +171,1 @@\n-            initLibProvidersLookup(params, lookup);\n+            initLibProvidersLookup(lookup);\n@@ -200,1 +173,1 @@\n-            neededLibPackages = lookup.execute(thePackage.sourceRoot());\n+            neededLibPackages = lookup.execute(env.appImageDir());\n@@ -203,3 +176,1 @@\n-            if (!Files.exists(thePackage.sourceRoot())) {\n-                Log.info(I18N.getString(\"warning.foreign-app-image\"));\n-            }\n+            Log.info(I18N.getString(\"warning.foreign-app-image\"));\n@@ -218,2 +189,1 @@\n-    private Map<String, String> createDefaultReplacementData(\n-            Map<String, ? super Object> params) throws IOException {\n+    private Map<String, String> createDefaultReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n@@ -222,4 +192,4 @@\n-        data.put(\"APPLICATION_PACKAGE\", createMetaPackage(params).name());\n-        data.put(\"APPLICATION_VENDOR\", VENDOR.fetchFrom(params));\n-        data.put(\"APPLICATION_VERSION\", VERSION.fetchFrom(params));\n-        data.put(\"APPLICATION_DESCRIPTION\", DESCRIPTION.fetchFrom(params));\n+        data.put(\"APPLICATION_PACKAGE\", pkg.packageName());\n+        data.put(\"APPLICATION_VENDOR\", pkg.app().vendor());\n+        data.put(\"APPLICATION_VERSION\", pkg.version());\n+        data.put(\"APPLICATION_DESCRIPTION\", pkg.description());\n@@ -227,2 +197,2 @@\n-        String defaultDeps = String.join(\", \", getListOfNeededPackages(params));\n-        String customDeps = LINUX_PACKAGE_DEPENDENCIES.fetchFrom(params).strip();\n+        String defaultDeps = String.join(\", \", getListOfNeededPackages(env));\n+        String customDeps = pkg.additionalDependencies().orElse(\"\");\n@@ -239,1 +209,1 @@\n-            Map<String, ? super Object> params, Path packageBundle);\n+            BuildEnv env, LinuxPackage pkg, Path packageBundle);\n@@ -241,3 +211,1 @@\n-    protected abstract void initLibProvidersLookup(\n-            Map<String, ? super Object> params,\n-            LibProvidersLookup libProvidersLookup);\n+    protected abstract void initLibProvidersLookup(LibProvidersLookup libProvidersLookup);\n@@ -245,2 +213,1 @@\n-    protected abstract List<ToolValidator> getToolValidators(\n-            Map<String, ? super Object> params);\n+    protected abstract List<ToolValidator> getToolValidators();\n@@ -248,1 +215,1 @@\n-    protected abstract void doValidate(Map<String, ? super Object> params)\n+    protected abstract void doValidate(BuildEnv env, LinuxPackage pkg)\n@@ -252,1 +219,1 @@\n-            Map<String, ? super Object> params) throws IOException;\n+            BuildEnv env, LinuxPackage pkg) throws IOException;\n@@ -254,1 +221,1 @@\n-    protected abstract Path buildPackageBundle(\n+    protected abstract void createConfigFiles(\n@@ -256,61 +223,1 @@\n-            Map<String, ? super Object> params, Path outputParentDir) throws\n-            PackagerException, IOException;\n-\n-    protected final PlatformPackage createMetaPackage(\n-            Map<String, ? super Object> params) {\n-\n-        Supplier<ApplicationLayout> packageLayout = () -> {\n-            String installDir = LINUX_INSTALL_DIR.fetchFrom(params);\n-            if (isInstallDirInUsrTree(installDir)) {\n-                return ApplicationLayout.linuxUsrTreePackageImage(\n-                        Path.of(\"\/\").relativize(Path.of(installDir)),\n-                        packageName.fetchFrom(params));\n-            }\n-            return appImageLayout(params);\n-        };\n-\n-        return new PlatformPackage() {\n-            @Override\n-            public String name() {\n-                return packageName.fetchFrom(params);\n-            }\n-\n-            @Override\n-            public Path sourceRoot() {\n-                return IMAGES_ROOT.fetchFrom(params).toAbsolutePath();\n-            }\n-\n-            @Override\n-            public ApplicationLayout sourceApplicationLayout() {\n-                return packageLayout.get().resolveAt(\n-                        applicationInstallDir(sourceRoot()));\n-            }\n-\n-            @Override\n-            public ApplicationLayout installedApplicationLayout() {\n-                return packageLayout.get().resolveAt(\n-                        applicationInstallDir(Path.of(\"\/\")));\n-            }\n-\n-            private Path applicationInstallDir(Path root) {\n-                String installRoot = LINUX_INSTALL_DIR.fetchFrom(params);\n-                if (isInstallDirInUsrTree(installRoot)) {\n-                    return root;\n-                }\n-\n-                Path installDir = Path.of(installRoot, name());\n-                if (installDir.isAbsolute()) {\n-                    installDir = Path.of(\".\" + installDir.toString()).normalize();\n-                }\n-                return root.resolve(installDir);\n-            }\n-        };\n-    }\n-\n-    private ApplicationLayout appImageLayout(\n-            Map<String, ? super Object> params) {\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            return ApplicationLayout.javaRuntime();\n-        }\n-        return ApplicationLayout.linuxAppImage();\n-    }\n+            BuildEnv env, LinuxPackage pkg) throws IOException;\n@@ -318,29 +225,3 @@\n-    private static void validateInstallDir(String installDir) throws\n-            ConfigException {\n-\n-        if (installDir.isEmpty()) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.invalid-install-dir\"), \"\/\"), null);\n-        }\n-\n-        boolean valid = false;\n-        try {\n-            final Path installDirPath = Path.of(installDir);\n-            valid = installDirPath.isAbsolute();\n-            if (valid && !installDirPath.normalize().toString().equals(\n-                    installDirPath.toString())) {\n-                \/\/ Don't allow '\/opt\/foo\/..' or \/opt\/.\n-                valid = false;\n-            }\n-        } catch (InvalidPathException ex) {\n-        }\n-\n-        if (!valid) {\n-            throw new ConfigException(MessageFormat.format(I18N.getString(\n-                    \"error.invalid-install-dir\"), installDir), null);\n-        }\n-    }\n-\n-    protected static boolean isInstallDirInUsrTree(String installDir) {\n-        return Set.of(\"\/usr\/local\", \"\/usr\").contains(installDir);\n-    }\n+    protected abstract Path buildPackageBundle(\n+            BuildEnv env, LinuxPackage pkg, Path outputParentDir) throws\n+            PackagerException, IOException;\n@@ -348,2 +229,1 @@\n-    private final BundlerParamInfo<String> packageName;\n-    private final Bundler appImageBundler;\n+    private final BundlerParamInfo<? extends LinuxPackage> pkgParam;\n@@ -359,3 +239,2 @@\n-        void init(PlatformPackage thePackage, Map<String, ? super Object> params)\n-                throws IOException {\n-            instance = factory.create(thePackage, params);\n+        void init(BuildEnv env, Package pkg) throws IOException {\n+            instance = factory.create(env, pkg);\n@@ -368,25 +247,0 @@\n-\n-    private static final BundlerParamInfo<String> LINUX_PACKAGE_DEPENDENCIES =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.LINUX_PACKAGE_DEPENDENCIES.getId(),\n-            String.class,\n-            params -> \"\",\n-            (s, p) -> s\n-    );\n-\n-    static final BundlerParamInfo<String> LINUX_INSTALL_DIR =\n-            new StandardBundlerParam<>(\n-            \"linux-install-dir\",\n-            String.class,\n-            params -> {\n-                 String dir = INSTALL_DIR.fetchFrom(params);\n-                 if (dir != null) {\n-                     if (dir.endsWith(\"\/\")) {\n-                         dir = dir.substring(0, dir.length()-1);\n-                     }\n-                     return dir;\n-                 }\n-                 return \"\/opt\";\n-             },\n-            (s, p) -> s\n-    );\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackageBundler.java","additions":82,"deletions":228,"binary":false,"changes":310,"status":"modified"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n+import jdk.jpackage.internal.PackagingPipeline.AppImageBuildEnv;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+\n+final class LinuxPackagingPipeline {\n+\n+    enum LinuxAppImageTaskID implements TaskID {\n+        LAUNCHER_LIB,\n+        LAUNCHER_ICONS\n+    }\n+\n+    static PackagingPipeline.Builder build() {\n+        return PackagingPipeline.buildStandard()\n+                .task(LinuxAppImageTaskID.LAUNCHER_LIB)\n+                        .addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE)\n+                        .applicationAction(LinuxPackagingPipeline::writeLauncherLib).add()\n+                .task(LinuxAppImageTaskID.LAUNCHER_ICONS)\n+                        .addDependent(BuildApplicationTaskID.CONTENT)\n+                        .applicationAction(LinuxPackagingPipeline::writeLauncherIcons).add();\n+    }\n+\n+    private static void writeLauncherLib(\n+            AppImageBuildEnv<Application, LinuxApplicationLayout> env) throws IOException {\n+\n+        final var launcherLib = env.resolvedLayout().libAppLauncher();\n+        try (var in = ResourceLocator.class.getResourceAsStream(\"libjpackageapplauncheraux.so\")) {\n+            Files.createDirectories(launcherLib.getParent());\n+            Files.copy(in, launcherLib);\n+        }\n+    }\n+\n+    private static void writeLauncherIcons(\n+            AppImageBuildEnv<Application, ApplicationLayout> env) throws IOException {\n+\n+        for (var launcher : env.app().launchers()) {\n+            createLauncherIconResource(env.app(), launcher, env.env()::createResource).ifPresent(iconResource -> {\n+                String iconFileName = launcher.executableName() + \".png\";\n+                Path iconTarget = env.resolvedLayout().destktopIntegrationDirectory().resolve(iconFileName);\n+                try {\n+                    iconResource.saveToFile(iconTarget);\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+        }\n+    }\n+\n+    static final LinuxApplicationLayout APPLICATION_LAYOUT = LinuxApplicationLayout.create(\n+            ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT, Path.of(\"lib\/libapplauncher.so\"));\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackagingPipeline.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import java.text.MessageFormat;\n@@ -36,1 +35,0 @@\n-import java.util.Optional;\n@@ -43,0 +41,3 @@\n+import jdk.jpackage.internal.model.LinuxPackage;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+import jdk.jpackage.internal.model.Package;\n@@ -45,8 +46,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALLER_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.RELEASE;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n@@ -67,56 +60,0 @@\n-    \/\/ Fedora rules for package naming are used here\n-    \/\/ https:\/\/fedoraproject.org\/wiki\/Packaging:NamingGuidelines?rd=Packaging\/NamingGuidelines\n-    \/\/\n-    \/\/ all Fedora packages must be named using only the following ASCII\n-    \/\/ characters. These characters are displayed here:\n-    \/\/\n-    \/\/ abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-._+\n-    \/\/\n-    private static final Pattern RPM_PACKAGE_NAME_PATTERN =\n-            Pattern.compile(\"[a-z\\\\d\\\\+\\\\-\\\\.\\\\_]+\", Pattern.CASE_INSENSITIVE);\n-\n-    public static final BundlerParamInfo<String> PACKAGE_NAME =\n-            new StandardBundlerParam<> (\n-            Arguments.CLIOptions.LINUX_BUNDLE_NAME.getId(),\n-            String.class,\n-            params -> {\n-                String nm = INSTALLER_NAME.fetchFrom(params);\n-                if (nm == null) return null;\n-\n-                \/\/ make sure to lower case and spaces become dashes\n-                nm = nm.toLowerCase().replaceAll(\"[ ]\", \"-\");\n-\n-                return nm;\n-            },\n-            (s, p) -> {\n-                if (!RPM_PACKAGE_NAME_PATTERN.matcher(s).matches()) {\n-                    try {\n-                        throw new ConfigException(\n-                            MessageFormat.format(I18N.getString(\n-                            \"error.rpm-invalid-value-for-package-name\"), s),\n-                            I18N.getString(\n-                            \"error.rpm-invalid-value-for-package-name.advice\"));\n-                    } catch (ConfigException ex) {\n-                        throw new IllegalArgumentException(ex);\n-                    }\n-                }\n-\n-                return s;\n-            }\n-        );\n-\n-    public static final BundlerParamInfo<String> LICENSE_TYPE =\n-        new StandardBundlerParam<>(\n-                Arguments.CLIOptions.LINUX_RPM_LICENSE_TYPE.getId(),\n-                String.class,\n-                params -> I18N.getString(\"param.license-type.default\"),\n-                (s, p) -> s\n-        );\n-\n-    public static final BundlerParamInfo<String> GROUP =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.LINUX_CATEGORY.getId(),\n-            String.class,\n-            params -> null,\n-            (s, p) -> s);\n-\n@@ -131,1 +68,1 @@\n-        super(PACKAGE_NAME);\n+        super(LinuxFromParams.RPM_PACKAGE);\n@@ -135,2 +72,1 @@\n-    public void doValidate(Map<String, ? super Object> params)\n-            throws ConfigException {\n+    protected void doValidate(BuildEnv env, LinuxPackage pkg) throws ConfigException {\n@@ -154,2 +90,1 @@\n-    protected List<ToolValidator> getToolValidators(\n-            Map<String, ? super Object> params) {\n+    protected List<ToolValidator> getToolValidators() {\n@@ -159,7 +94,3 @@\n-    @Override\n-    protected Path buildPackageBundle(\n-            Map<String, String> replacementData,\n-            Map<String, ? super Object> params, Path outputParentDir) throws\n-            PackagerException, IOException {\n-\n-        Path specFile = specFile(params);\n+    protected void createConfigFiles(Map<String, String> replacementData,\n+            BuildEnv env, LinuxPackage pkg) throws IOException {\n+        Path specFile = specFile(env, pkg);\n@@ -168,1 +99,1 @@\n-        createResource(DEFAULT_SPEC_TEMPLATE, params)\n+        env.createResource(DEFAULT_SPEC_TEMPLATE)\n@@ -172,2 +103,0 @@\n-\n-        return buildRPM(params, outputParentDir);\n@@ -177,5 +106,4 @@\n-    protected Map<String, String> createReplacementData(\n-            Map<String, ? super Object> params) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        final Path prefix = Path.of(LINUX_INSTALL_DIR.fetchFrom(params));\n+    protected Path buildPackageBundle(BuildEnv env, LinuxPackage pkg,\n+            Path outputParentDir) throws PackagerException, IOException {\n+        return buildRPM(env, pkg, outputParentDir);\n+    }\n@@ -183,3 +111,4 @@\n-        Path appDirectory = prefix;\n-        if (!isInstallDirInUsrTree(prefix.toString())) {\n-            appDirectory = appDirectory.resolve(PACKAGE_NAME.fetchFrom(params));\n+    private static Path installPrefix(LinuxPackage pkg) {\n+        Path path = pkg.relativeInstallDir();\n+        if (!pkg.isInstallDirInUsrTree()) {\n+            path = path.getParent();\n@@ -187,0 +116,6 @@\n+        return Path.of(\"\/\").resolve(path);\n+    }\n+\n+    @Override\n+    protected Map<String, String> createReplacementData(BuildEnv env, LinuxPackage pkg) throws IOException {\n+        Map<String, String> data = new HashMap<>();\n@@ -188,5 +123,5 @@\n-        data.put(\"APPLICATION_RELEASE\", RELEASE.fetchFrom(params));\n-        data.put(\"APPLICATION_PREFIX\", prefix.toString());\n-        data.put(\"APPLICATION_DIRECTORY\", appDirectory.toString());\n-        data.put(\"APPLICATION_SUMMARY\", APP_NAME.fetchFrom(params));\n-        data.put(\"APPLICATION_LICENSE_TYPE\", LICENSE_TYPE.fetchFrom(params));\n+        data.put(\"APPLICATION_RELEASE\", pkg.release().orElseThrow());\n+        data.put(\"APPLICATION_PREFIX\", installPrefix(pkg).toString());\n+        data.put(\"APPLICATION_DIRECTORY\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n+        data.put(\"APPLICATION_SUMMARY\", pkg.app().name());\n+        data.put(\"APPLICATION_LICENSE_TYPE\", ((LinuxRpmPackage)pkg).licenseType());\n@@ -194,4 +129,3 @@\n-        String licenseFile = LICENSE_FILE.fetchFrom(params);\n-        if (licenseFile != null) {\n-            licenseFile = Path.of(licenseFile).toAbsolutePath().normalize().toString();\n-        }\n+        String licenseFile = pkg.licenseFile().map(v -> {\n+            return v.toAbsolutePath().normalize().toString();\n+        }).orElse(null);\n@@ -199,1 +133,1 @@\n-        data.put(\"APPLICATION_GROUP\", GROUP.fetchFrom(params));\n+        data.put(\"APPLICATION_GROUP\", pkg.category().orElse(\"\"));\n@@ -201,2 +135,1 @@\n-        data.put(\"APPLICATION_URL\", Optional.ofNullable(ABOUT_URL.fetchFrom(\n-                params)).orElse(\"\"));\n+        data.put(\"APPLICATION_URL\", pkg.aboutURL().orElse(\"\"));\n@@ -208,3 +141,1 @@\n-    protected void initLibProvidersLookup(\n-            Map<String, ? super Object> params,\n-            LibProvidersLookup libProvidersLookup) {\n+    protected void initLibProvidersLookup(LibProvidersLookup libProvidersLookup) {\n@@ -220,2 +151,2 @@\n-    protected List<ConfigException> verifyOutputBundle(\n-            Map<String, ? super Object> params, Path packageBundle) {\n+    protected List<ConfigException> verifyOutputBundle(BuildEnv env, LinuxPackage pkg,\n+            Path packageBundle) {\n@@ -224,1 +155,1 @@\n-        String specFileName = specFile(params).getFileName().toString();\n+        String specFileName = specFile(env, pkg).getFileName().toString();\n@@ -228,1 +159,1 @@\n-                    new PackageProperty(\"Name\", PACKAGE_NAME.fetchFrom(params),\n+                    new PackageProperty(\"Name\", pkg.packageName(),\n@@ -230,1 +161,1 @@\n-                    new PackageProperty(\"Version\", VERSION.fetchFrom(params),\n+                    new PackageProperty(\"Version\", pkg.version(),\n@@ -232,1 +163,1 @@\n-                    new PackageProperty(\"Release\", RELEASE.fetchFrom(params),\n+                    new PackageProperty(\"Release\", pkg.release().orElseThrow(),\n@@ -234,1 +165,1 @@\n-                    new PackageProperty(\"Arch\", rpmArch(), null, specFileName));\n+                    new PackageProperty(\"Arch\", pkg.arch(), null, specFileName));\n@@ -252,25 +183,2 @@\n-    \/**\n-     * Various ways to get rpm arch. Needed to address JDK-8233143. rpmbuild is\n-     * mandatory for rpm packaging, try it first. rpm is optional and may not be\n-     * available, use as the last resort.\n-     *\/\n-    private enum RpmArchReader {\n-        Rpmbuild(TOOL_RPMBUILD, \"--eval=%{_target_cpu}\"),\n-        Rpm(TOOL_RPM, \"--eval=%{_target_cpu}\");\n-\n-        RpmArchReader(String... cmdline) {\n-            this.cmdline = cmdline;\n-        }\n-\n-        String getRpmArch() throws IOException {\n-            Executor exec = Executor.of(cmdline).saveOutput(true);\n-            if (this == values()[values().length - 1]) {\n-                exec.executeExpectSuccess();\n-            } else if (exec.execute() != 0) {\n-                return null;\n-            }\n-\n-            return exec.getOutput().get(0);\n-        }\n-\n-        private final String[] cmdline;\n+    private Path specFile(BuildEnv env, Package pkg) {\n+        return env.buildRoot().resolve(Path.of(\"SPECS\", pkg.packageName() + \".spec\"));\n@@ -279,11 +187,1 @@\n-    private String rpmArch() throws IOException {\n-        if (rpmArch == null) {\n-            for (var rpmArchReader : RpmArchReader.values()) {\n-                rpmArch = rpmArchReader.getRpmArch();\n-                if (rpmArch != null) {\n-                    break;\n-                }\n-            }\n-        }\n-        return rpmArch;\n-    }\n+    private Path buildRPM(BuildEnv env, Package pkg, Path outdir) throws IOException {\n@@ -291,9 +189,1 @@\n-    private Path specFile(Map<String, ? super Object> params) {\n-        return TEMP_ROOT.fetchFrom(params).resolve(Path.of(\"SPECS\",\n-                PACKAGE_NAME.fetchFrom(params) + \".spec\"));\n-    }\n-\n-    private Path buildRPM(Map<String, ? super Object> params,\n-            Path outdir) throws IOException {\n-\n-        PlatformPackage thePackage = createMetaPackage(params);\n+        Path rpmFile = outdir.toAbsolutePath().resolve(pkg.packageFileNameWithSuffix());\n@@ -301,14 +191,1 @@\n-        new ScriptRunner()\n-                .setDirectory(thePackage.sourceRoot())\n-                .setResourceCategoryId(\"resource.post-app-image-script\")\n-                .setScriptNameSuffix(\"post-image\")\n-                .setEnvironmentVariable(\"JpAppImageDir\", thePackage.sourceRoot().toAbsolutePath().toString())\n-                .run(params);\n-\n-        Path rpmFile = outdir.toAbsolutePath().resolve(String.format(\n-                \"%s-%s-%s.%s.rpm\", PACKAGE_NAME.fetchFrom(params),\n-                VERSION.fetchFrom(params), RELEASE.fetchFrom(params), rpmArch()));\n-\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.outputting-bundle-location\"),\n-                rpmFile.getParent()));\n+        Log.verbose(I18N.format(\"message.outputting-bundle-location\", rpmFile.getParent()));\n@@ -317,3 +194,2 @@\n-        Executor.of(\n-                TOOL_RPMBUILD,\n-                \"-bb\", specFile(params).toAbsolutePath().toString(),\n+        Executor.of(TOOL_RPMBUILD,\n+                \"-bb\", specFile(env, pkg).toAbsolutePath().toString(),\n@@ -321,1 +197,1 @@\n-                        thePackage.sourceRoot()),\n+                        env.appImageDir().toAbsolutePath()),\n@@ -326,1 +202,1 @@\n-                        TEMP_ROOT.fetchFrom(params).toAbsolutePath()),\n+                        env.buildRoot().toAbsolutePath()),\n@@ -330,3 +206,1 @@\n-        Log.verbose(MessageFormat.format(\n-                I18N.getString(\"message.output-bundle-location\"),\n-                rpmFile.getParent()));\n+        Log.verbose(I18N.format(\"message.output-bundle-location\", rpmFile.getParent()));\n@@ -356,2 +230,0 @@\n-\n-    private String rpmArch;\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":52,"deletions":180,"binary":false,"changes":232,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LinuxRpmPackage;\n+import jdk.jpackage.internal.model.LinuxRpmPackageMixin;\n+\n+final class LinuxRpmPackageBuilder {\n+\n+    LinuxRpmPackageBuilder(LinuxPackageBuilder pkgBuilder) {\n+        this.pkgBuilder = Objects.requireNonNull(pkgBuilder);\n+    }\n+\n+    LinuxRpmPackage create() throws ConfigException {\n+        if (pkgBuilder.release().isEmpty()) {\n+            pkgBuilder.release(\"1\");\n+        }\n+        var pkg = pkgBuilder.create();\n+        return LinuxRpmPackage.create(pkg, new LinuxRpmPackageMixin.Stub(\n+                Optional.ofNullable(licenseType).orElseGet(DEFAULTS::licenseType)));\n+    }\n+\n+    LinuxRpmPackageBuilder licenseType(String v) {\n+        licenseType = v;\n+        return this;\n+    }\n+\n+    private record Defaults(String licenseType) {\n+    }\n+\n+    private String licenseType;\n+\n+    private final LinuxPackageBuilder pkgBuilder;\n+\n+    private static final Defaults DEFAULTS = new Defaults(I18N.getString(\n+            \"param.license-type.default\"));\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmPackageBuilder.java","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Linux application.\n+ * <p>\n+ * Use {@link #create} method to create objects implementing this interface.\n+ *\/\n+public interface LinuxApplication extends Application {\n+\n+    \/**\n+     * Creates {@link LinuxApplication} instance from the given {@link Application}\n+     * instance.\n+     *\n+     * @param app the generic application\n+     * @return the proxy dispatching calls to the given {@link Application} instance\n+     *\/\n+    public static LinuxApplication create(Application app) {\n+        return CompositeProxy.create(LinuxApplication.class, app);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxApplication.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Linux DEB package.\n+ * <p>\n+ * Use {@link #create} method to create objects implementing this interface.\n+ *\n+ * @see <a href=\"https:\/\/www.debian.org\/doc\/debian-policy\/ch-binary.html#\">https:\/\/www.debian.org\/doc\/debian-policy\/ch-binary.html#<\/a>\n+ * @see <a href=\"https:\/\/linux.die.net\/man\/5\/deb-control\">https:\/\/linux.die.net\/man\/5\/deb-control<\/a>\n+ *\/\n+public interface LinuxDebPackage extends LinuxPackage, LinuxDebPackageMixin {\n+\n+    \/**\n+     * Gets the value of the maintainer property of this DEB package.\n+     *\n+     * @see <a href=\n+     *      \"https:\/\/www.debian.org\/doc\/debian-policy\/ch-controlfields.html#s-f-maintainer\">https:\/\/www.debian.org\/doc\/debian-policy\/ch-controlfields.html#s-f-maintainer<\/a>\n+     * @return the maintainer property of this DEB package\n+     *\/\n+    default String maintainer() {\n+        return String.format(\"%s <%s>\", app().vendor(), maintainerEmail());\n+    }\n+\n+    \/**\n+     * Gets the relative path to this DEB package's copyright file. Returns empty\n+     * {@link Optional} instance if this DEB package has no copyright file.\n+     *\n+     * @return the relative path to the copyright file of this DEB package\n+     *\/\n+    default Optional<Path> relativeCopyrightFilePath() {\n+        if (isInstallDirInUsrTree() || Path.of(\"\/\").resolve(relativeInstallDir()).startsWith(\"\/usr\/\")) {\n+            return Optional.of(Path.of(\"usr\/share\/doc\/\", packageName(), \"copyright\"));\n+        } else if (!isRuntimeInstaller()) {\n+            return Optional.of(relativeInstallDir().resolve(\"share\/doc\/copyright\"));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Constructs {@link LinuxDebPackage} instance from the given\n+     * {@link LinuxPackage} and {@link LinuxDebPackageMixin} instances.\n+     *\n+     * @param pkg the Linux package\n+     * @param mixin DEB-specific details supplementing the Linux package\n+     * @return the proxy dispatching calls to the given objects\n+     *\/\n+    public static LinuxDebPackage create(LinuxPackage pkg, LinuxDebPackageMixin mixin) {\n+        return CompositeProxy.create(LinuxDebPackage.class, pkg, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxDebPackage.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,44 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+\/**\n+ * Details of Linux DEB package.\n+ *\/\n+public interface LinuxDebPackageMixin {\n+\n+    \/**\n+     * Gets the email of the maintainer of this DEB package.\n+     *\n+     * @return the email of the maintainer of this DEB package\n+     *\/\n+    String maintainerEmail();\n+\n+    \/**\n+     * Default implementation of {@link LinuxDebPackageMixin} interface.\n+     *\/\n+    record Stub(String maintainerEmail) implements LinuxDebPackageMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxDebPackageMixin.java","additions":44,"deletions":0,"binary":false,"changes":44,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Map;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Linux application launcher.\n+ * <p>\n+ * Use {@link #create} method to create objects implementing this interface.\n+ *\/\n+public interface LinuxLauncher extends Launcher, LinuxLauncherMixin {\n+\n+    @Override\n+    default Map<String, String> extraAppImageFileData() {\n+        return shortcut().map(v -> {\n+            return Map.of(\"shortcut\", Boolean.toString(v));\n+        }).orElseGet(Map::of);\n+    }\n+\n+    \/**\n+     * Constructs {@link LinuxLauncher} instance from the given\n+     * {@link Launcher} and {@link LinuxLauncherMixin} instances.\n+     *\n+     * @param launcher the generic application launcher\n+     * @param mixin Linux-specific details supplementing the generic application launcher\n+     * @return the proxy dispatching calls to the given objects\n+     *\/\n+    public static LinuxLauncher create(Launcher launcher, LinuxLauncherMixin mixin) {\n+        return CompositeProxy.create(LinuxLauncher.class, launcher, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncher.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Optional;\n+\n+\/**\n+ * Details of Linux application launcher.\n+ *\/\n+public interface LinuxLauncherMixin {\n+\n+    \/**\n+     * Gets the start menu shortcut setting of this application launcher.\n+     * <p>\n+     * Returns <code>true<\/code> if this application launcher was requested to have\n+     * the start menu shortcut.\n+     * <p>\n+     * Returns <code>false<\/code> if this application launcher was requested not to\n+     * have the start menu shortcut.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if there was no request about the\n+     * start menu shortcut for this application launcher.\n+     *\n+     * @return the start menu shortcut setting of this application launcher\n+     *\/\n+    Optional<Boolean> shortcut();\n+\n+    \/**\n+     * Default implementation of {@link LinuxLauncherMixin} interface.\n+     *\/\n+    record Stub(Optional<Boolean> shortcut) implements LinuxLauncherMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxLauncherMixin.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Linux package.\n+ * <p>\n+ * Use {@link #create} method to create objects implementing this interface.\n+ *\/\n+public interface LinuxPackage extends Package, LinuxPackageMixin {\n+\n+    LinuxApplication app();\n+\n+    @Override\n+    AppImageLayout packageLayout();\n+\n+    @Override\n+    default String packageFileName() {\n+        String packageFileNameTemlate = asStandardPackageType().map(stdType -> {\n+            switch (stdType) {\n+                case LINUX_DEB -> {\n+                    return \"%s_%s_%s\";\n+                }\n+                case LINUX_RPM -> {\n+                    return \"%s-%s.%s\";\n+                }\n+                default -> {\n+                    throw new IllegalStateException();\n+                }\n+            }\n+        }).orElseThrow(UnsupportedOperationException::new);\n+\n+        return String.format(packageFileNameTemlate, packageName(), versionWithRelease(), arch());\n+    }\n+\n+    \/**\n+     * Gets the version with the release component of this Linux package.\n+     *\n+     * @return the version with the release component of this Linux package\n+     *\/\n+    default String versionWithRelease() {\n+        return String.format(\"%s%s\", version(), release().map(r -> \"-\" + r).orElse(\"\"));\n+    }\n+\n+    \/**\n+     * Returns <code>true<\/code> in this Linux package installs in \"\/usr\" tree.\n+     *\n+     * @return <code>true<\/code> in this Linux package installs in \"\/usr\" tree\n+     *\/\n+    default boolean isInstallDirInUsrTree() {\n+        return !relativeInstallDir().getFileName().equals(Path.of(packageName()));\n+    }\n+\n+    \/**\n+     * Constructs {@link LinuxPackage} instance from the given\n+     * {@link Package} and {@link LinuxPackageMixin} instances.\n+     *\n+     * @param pkg the generic package\n+     * @param mixin Linux-specific details supplementing the Linux package\n+     * @return the proxy dispatching calls to the given objects\n+     *\/\n+    public static LinuxPackage create(Package pkg, LinuxPackageMixin mixin) {\n+        return CompositeProxy.create(LinuxPackage.class, pkg, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackage.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Optional;\n+\n+\/**\n+ * Details of Linux package.\n+ *\/\n+public interface LinuxPackageMixin {\n+\n+    \/**\n+     * Overrides {@link Package#packageLayout()}.\n+     *\/\n+    AppImageLayout packageLayout();\n+\n+    \/**\n+     * Gets the name of the start menu group where to create shortcuts for\n+     * application launchers of this package.\n+     *\n+     * @return the name of the start menu group where to create shortcuts for\n+     *         application launchers of this package\n+     *\n+     * @see LinuxLauncherMixin#shortcut()\n+     *\/\n+    String menuGroupName();\n+\n+    \/**\n+     * Gets the category of this package.\n+     *\n+     * @return the category of this package\n+     *\/\n+    Optional<String> category();\n+\n+    \/**\n+     * Gets a string with the additional dependencies of this package. Returns an\n+     * empty {@link Optional} instance if this package has no additional\n+     * dependencies.\n+     *\n+     * @return a string with the additional dependencies of this package\n+     *\/\n+    Optional<String> additionalDependencies();\n+\n+    \/**\n+     * Gets the release of this package. Returns an empty {@link Optional} instance\n+     * if this package doesn't have a release.\n+     * <p>\n+     * For RPM packages, this is the value of a \"Release\" property in spec file. RPM\n+     * packages always have a release.\n+     * <p>\n+     * For DEB packages, this is an optional {@code debian_revision} component of a\n+     * package version. See <a href=\n+     * \"https:\/\/www.debian.org\/doc\/debian-policy\/ch-controlfields.html#s-f-version#\">https:\/\/www.debian.org\/doc\/debian-policy\/ch-controlfields.html#s-f-version#<\/a>.\n+     *\n+     * @return the release of this package\n+     *\/\n+    Optional<String> release();\n+\n+    \/**\n+     * Gets the platform architecture of this package.\n+     *\n+     * @return the platform architecture of this package\n+     *\/\n+    String arch();\n+\n+    \/**\n+     * Default implementation of {@link LinuxPackageMixin} interface.\n+     *\/\n+    record Stub(AppImageLayout packageLayout, String menuGroupName,\n+            Optional<String> category, Optional<String> additionalDependencies,\n+            Optional<String> release, String arch) implements LinuxPackageMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxPackageMixin.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Linux RPM package.\n+ *\/\n+public interface LinuxRpmPackage extends LinuxPackage, LinuxRpmPackageMixin {\n+\n+    \/**\n+     * Constructs {@link LinuxRpmPackage} instance from the given\n+     * {@link LinuxPackage} and {@link LinuxRpmPackageMixin} instances.\n+     *\n+     * @param pkg the Linux package\n+     * @param mixin RPM-specific details supplementing the generic package\n+     * @return the proxy dispatching calls to the given objects\n+     *\/\n+    public static LinuxRpmPackage create(LinuxPackage pkg, LinuxRpmPackageMixin mixin) {\n+        return CompositeProxy.create(LinuxRpmPackage.class, pkg, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxRpmPackage.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+\/**\n+ * Details of Linux RPM package.\n+ *\/\n+public interface LinuxRpmPackageMixin {\n+\n+    \/**\n+     * Gets type of the license of this RPM package.\n+     * @return type of the license of this RPM package\n+     *\/\n+    String licenseType();\n+\n+    \/**\n+     * Default implementation of {@link LinuxRpmPackageMixin} interface.\n+     *\/\n+    record Stub(String licenseType) implements LinuxRpmPackageMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/model\/LinuxRpmPackageMixin.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -47,2 +47,0 @@\n-error.invalid-install-dir=Invalid installation directory \"{0}\"\n-\n@@ -55,0 +53,2 @@\n+error.rpm-arch-not-detected=\"Failed to detect RPM arch\"\n+\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/resources\/LinuxResources.properties","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,67 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.XmlUtils.initDocumentBuilder;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.util.PListReader;\n+import org.xml.sax.SAXException;\n+\n+\/**\n+ * Mandatory elements of Info.plist file of app image.\n+ *\/\n+record AppImageInfoPListFile(String bundleIdentifier, String bundleName, String copyright,\n+        DottedVersion shortVersion, DottedVersion bundleVersion, String category) {\n+\n+    static final class InvalidPlistFileException extends Exception {\n+        InvalidPlistFileException(Throwable cause) {\n+            super(cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    static AppImageInfoPListFile loadFromInfoPList(Path infoPListFile)\n+            throws IOException, InvalidPlistFileException, SAXException {\n+\n+        final var plistReader = new PListReader(initDocumentBuilder().parse(Files.newInputStream(infoPListFile)));\n+\n+        try {\n+            return new AppImageInfoPListFile(\n+                    plistReader.queryValue(\"CFBundleIdentifier\"),\n+                    plistReader.queryValue(\"CFBundleName\"),\n+                    plistReader.queryValue(\"NSHumanReadableCopyright\"),\n+                    DottedVersion.greedy(plistReader.queryValue(\"CFBundleShortVersionString\")),\n+                    DottedVersion.greedy(plistReader.queryValue(\"CFBundleVersion\")),\n+                    plistReader.queryValue(\"LSApplicationCategoryType\"));\n+        } catch (Exception ex) {\n+            throw new InvalidPlistFileException(ex);\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageInfoPListFile.java","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,239 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.joining;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.EnumSet;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.Codesign.CodesignException;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.MacApplication;\n+import jdk.jpackage.internal.util.PathUtils;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\n+final class AppImageSigner {\n+\n+    static Consumer<Path> createSigner(MacApplication app, CodesignConfig signingCfg) {\n+        return toConsumer(appImage -> {\n+            try {\n+                new AppImageSigner(Codesigners.create(signingCfg)).sign(app, appImage);\n+            } catch (CodesignException ex) {\n+                throw handleCodesignException(app, ex);\n+            } catch (ExceptionBox ex) {\n+                if (ex.getCause() instanceof CodesignException codesignEx) {\n+                    handleCodesignException(app, codesignEx);\n+                }\n+                throw ex;\n+            }\n+        });\n+    }\n+\n+    private static final class SignFilter implements Predicate<Path> {\n+\n+        SignFilter(Application app, Path appImage) {\n+            Objects.requireNonNull(appImage);\n+\n+            \/\/ Don't explicitly sign main launcher. It will be implicitly signed when the bundle is signed.\n+            otherExcludePaths = app.asApplicationLayout().map(appLayout -> {\n+                return appLayout.resolveAt(appImage);\n+            }).map(ApplicationLayout::launchersDirectory).flatMap(launchersDir -> {\n+                return app.mainLauncher().map(Launcher::executableNameWithSuffix).map(launchersDir::resolve);\n+            }).map(Set::of).orElseGet(Set::of);\n+        }\n+\n+        @Override\n+        public boolean test(Path path) {\n+            if (!Files.isRegularFile(path) || otherExcludePaths.contains(path)) {\n+                return false;\n+            }\n+\n+            if (Files.isExecutable(path) || path.getFileName().toString().endsWith(\".dylib\")) {\n+                if (path.toString().contains(\"dylib.dSYM\/Contents\")) {\n+                    return false;\n+                }\n+\n+                return true;\n+            }\n+\n+            return false;\n+        }\n+\n+        private final Set<Path> otherExcludePaths;\n+    }\n+\n+    private void sign(MacApplication app, Path appImage) throws CodesignException, IOException {\n+\n+        final var fileFilter = new SignFilter(app, appImage);\n+\n+        try (var content = Files.walk(appImage)) {\n+            content.filter(fileFilter).forEach(toConsumer(path -> {\n+                final var origPerms = ensureCanWrite(path);\n+                try {\n+                    unsign(path);\n+                    sign(path);\n+                } finally {\n+                    if (!origPerms.isEmpty()) {\n+                        Files.setPosixFilePermissions(path, origPerms);\n+                    }\n+                }\n+            }));\n+        }\n+\n+        \/\/ Sign runtime root directory if present\n+        app.asApplicationLayout().map(appLayout -> {\n+            return appLayout.resolveAt(appImage);\n+        }).map(MacApplicationLayout.class::cast).map(MacApplicationLayout::runtimeRootDirectory).ifPresent(codesigners);\n+\n+        final var frameworkPath = appImage.resolve(\"Contents\/Frameworks\");\n+        if (Files.isDirectory(frameworkPath)) {\n+            try (var content = Files.list(frameworkPath)) {\n+                content.forEach(toConsumer(path -> {\n+                    codesigners.codesignDir().accept(path);\n+                }));\n+            }\n+        }\n+\n+        \/\/ Sign the app image itself\n+        codesigners.accept(appImage);\n+    }\n+\n+    private static Set<PosixFilePermission> ensureCanWrite(Path path) {\n+        try {\n+            final var origPerms = Files.getPosixFilePermissions(path);\n+            if (origPerms.contains(PosixFilePermission.OWNER_WRITE)) {\n+                return Set.of();\n+            } else {\n+                final var newPerms = EnumSet.copyOf(origPerms);\n+                newPerms.add(PosixFilePermission.OWNER_WRITE);\n+                Files.setPosixFilePermissions(path, newPerms);\n+                return origPerms;\n+            }\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n+    }\n+\n+    private static CodesignException handleCodesignException(MacApplication app, CodesignException ex) {\n+        \/\/ Log output of \"codesign\" in case of error. It should help\n+        \/\/ user to diagnose issues when using --mac-app-image-sign-identity.\n+        \/\/ In addition add possible reason for failure. For example\n+        \/\/ \"--app-content\" can fail \"codesign\".\n+\n+        if (!app.contentDirs().isEmpty()) {\n+            Log.info(I18N.getString(\"message.codesign.failed.reason.app.content\"));\n+        }\n+\n+        \/\/ Signing might not work without Xcode with command line\n+        \/\/ developer tools. Show user if Xcode is missing as possible\n+        \/\/ reason.\n+        if (!isXcodeDevToolsInstalled()) {\n+            Log.info(I18N.getString(\"message.codesign.failed.reason.xcode.tools\"));\n+        }\n+\n+        \/\/ Log \"codesign\" output\n+        Log.info(I18N.format(\"error.tool.failed.with.output\", \"codesign\"));\n+        Log.info(Stream.of(ex.getOutput()).collect(joining(\"\\n\")).strip());\n+\n+        return ex;\n+    }\n+\n+    private static boolean isXcodeDevToolsInstalled() {\n+        try {\n+            return Executor.of(\"\/usr\/bin\/xcrun\", \"--help\").setQuiet(true).execute() == 0;\n+        } catch (IOException ex) {\n+            return false;\n+        }\n+    }\n+\n+    private static void unsign(Path path) throws IOException {\n+        \/\/ run quietly\n+        Executor.of(\"\/usr\/bin\/codesign\", \"--remove-signature\", path.toString())\n+                .setQuiet(true)\n+                .executeExpectSuccess();\n+    }\n+\n+    private void sign(Path path) {\n+        codesigners.accept(path);\n+    }\n+\n+    private AppImageSigner(Codesigners codesigners) {\n+        this.codesigners = Objects.requireNonNull(codesigners);\n+    }\n+\n+    private record Codesigners(Consumer<Path> codesignFile, Consumer<Path> codesignExecutableFile, Consumer<Path> codesignDir) implements Consumer<Path> {\n+        Codesigners {\n+            Objects.requireNonNull(codesignFile);\n+            Objects.requireNonNull(codesignExecutableFile);\n+            Objects.requireNonNull(codesignDir);\n+        }\n+\n+        @Override\n+        public void accept(Path path) {\n+            findCodesigner(path).orElseThrow(() -> {\n+                return new IllegalArgumentException(String.format(\"No codesigner for %s path\", PathUtils.normalizedAbsolutePathString(path)));\n+            }).accept(path);\n+        }\n+\n+        private Optional<Consumer<Path>> findCodesigner(Path path) {\n+            if (Files.isDirectory(path)) {\n+                return Optional.of(codesignDir);\n+            } else if (Files.isRegularFile(path)) {\n+                if (Files.isExecutable(path)) {\n+                    return Optional.of(codesignExecutableFile);\n+                } else {\n+                    return Optional.of(codesignFile);\n+                }\n+            }\n+            return Optional.empty();\n+        }\n+\n+        static Codesigners create(CodesignConfig signingCfg) {\n+            final var signingCfgWithoutEntitlements = CodesignConfig.build().from(signingCfg).entitlements(null).create();\n+\n+            final var codesignExecutableFile = Codesign.build(signingCfg::toCodesignArgs).quiet(true).create().asConsumer();\n+            final var codesignFile = Codesign.build(signingCfgWithoutEntitlements::toCodesignArgs).quiet(true).create().asConsumer();\n+            final var codesignDir = Codesign.build(signingCfgWithoutEntitlements::toCodesignArgs).force(true).create().asConsumer();\n+\n+            return new Codesigners(codesignFile, codesignExecutableFile, codesignDir);\n+        }\n+    }\n+\n+    private final Codesigners codesigners;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigner.java","additions":239,"deletions":0,"binary":false,"changes":239,"status":"added"},{"patch":"@@ -0,0 +1,87 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageSigningConfig;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+\n+final class AppImageSigningConfigBuilder {\n+\n+    AppImageSigningConfigBuilder(SigningIdentityBuilder signingIdentityBuilder) {\n+        this.signingIdentityBuilder = Objects.requireNonNull(signingIdentityBuilder);\n+    }\n+\n+    AppImageSigningConfigBuilder entitlements(Path v) {\n+        entitlements = v;\n+        return this;\n+    }\n+\n+    AppImageSigningConfigBuilder entitlementsResourceName(String v) {\n+        entitlementsResourceName = v;\n+        return this;\n+    }\n+\n+    AppImageSigningConfigBuilder signingIdentifierPrefix(LauncherStartupInfo mainLauncherStartupInfo) {\n+        final var pkgName = mainLauncherStartupInfo.packageName();\n+        if (!pkgName.isEmpty()) {\n+            signingIdentifierPrefix(pkgName + \".\");\n+        } else {\n+            signingIdentifierPrefix(mainLauncherStartupInfo.simpleClassName() + \".\");\n+        }\n+        return this;\n+    }\n+\n+    AppImageSigningConfigBuilder signingIdentifierPrefix(String v) {\n+        signingIdentifierPrefix = v;\n+        return this;\n+    }\n+\n+    Optional<AppImageSigningConfig> create() throws ConfigException {\n+        final var identityCfg = signingIdentityBuilder.create();\n+        if (identityCfg.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            final var validatedEntitlements = validatedEntitlements();\n+            return identityCfg.map(cfg -> {\n+                return new AppImageSigningConfig.Stub(cfg.identity(), signingIdentifierPrefix,\n+                        validatedEntitlements, cfg.keychain().map(Keychain::name),\n+                        Optional.ofNullable(entitlementsResourceName).orElse(\"entitlements.plist\"));\n+            });\n+        }\n+    }\n+\n+    private Optional<Path> validatedEntitlements() throws ConfigException {\n+        return Optional.ofNullable(entitlements);\n+    }\n+\n+    private SigningIdentityBuilder signingIdentityBuilder;\n+    private Path entitlements;\n+    private String entitlementsResourceName;\n+    private String signingIdentifierPrefix;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/AppImageSigningConfigBuilder.java","additions":87,"deletions":0,"binary":false,"changes":87,"status":"added"},{"patch":"@@ -0,0 +1,119 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+\n+\n+public final class Codesign {\n+\n+    public static final class CodesignException extends Exception {\n+\n+        CodesignException(String[] output) {\n+            this.output = output;\n+        }\n+\n+        String[] getOutput() {\n+            return output;\n+        }\n+\n+        private final String[] output;\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    public static final class Builder {\n+\n+        private Builder(Supplier<List<String>> args) {\n+            this.args = Objects.requireNonNull(args);\n+        }\n+\n+        Codesign create() {\n+            List<String> cmdline = new ArrayList<>();\n+            cmdline.add(\"\/usr\/bin\/codesign\");\n+            cmdline.addAll(args.get());\n+            if (force) {\n+                cmdline.add(\"--force\");\n+            }\n+\n+            return new Codesign(cmdline, quiet ? exec -> {\n+                exec.setQuiet(true);\n+            } : null);\n+        }\n+\n+        public Builder force(boolean v) {\n+            force = v;\n+            return this;\n+        }\n+\n+        public Builder quiet(boolean v) {\n+            quiet = v;\n+            return this;\n+        }\n+\n+        private final Supplier<List<String>> args;\n+        private boolean force;\n+        private boolean quiet;\n+    }\n+\n+    public static Builder build(Supplier<List<String>> args) {\n+        return new Builder(args);\n+    }\n+\n+    public void applyTo(Path path) throws IOException, CodesignException {\n+\n+        var exec = Executor.of(Stream.concat(\n+                cmdline.stream(),\n+                Stream.of(path.toString())).toArray(String[]::new)\n+        ).saveOutput(true);\n+        configureExecutor.ifPresent(configure -> configure.accept(exec));\n+\n+        if (exec.execute() != 0) {\n+            throw new CodesignException(exec.getOutput().toArray(String[]::new));\n+        }\n+    }\n+\n+    public Consumer<Path> asConsumer() {\n+        return toConsumer(this::applyTo);\n+    }\n+\n+    private Codesign(List<String> cmdline, Consumer<Executor> configureExecutor) {\n+        this.cmdline = Objects.requireNonNull(cmdline);\n+        this.configureExecutor = Optional.ofNullable(configureExecutor);\n+    }\n+\n+    private final List<String> cmdline;\n+    private final Optional<Consumer<Executor>> configureExecutor;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/Codesign.java","additions":119,"deletions":0,"binary":false,"changes":119,"status":"added"},{"patch":"@@ -0,0 +1,131 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageSigningConfig;\n+import jdk.jpackage.internal.model.SigningIdentity;\n+import jdk.jpackage.internal.util.PathUtils;\n+\n+\n+record CodesignConfig(Optional<SigningIdentity> identity, Optional<String> identifierPrefix,\n+        Optional<Path> entitlements, Optional<Keychain> keychain) {\n+\n+    CodesignConfig {\n+        Objects.requireNonNull(identity);\n+        Objects.requireNonNull(identifierPrefix);\n+        Objects.requireNonNull(entitlements);\n+        Objects.requireNonNull(keychain);\n+\n+        if (identity.isPresent() != identifierPrefix.isPresent()) {\n+            throw new IllegalArgumentException(\"Signing identity and identifier prefix mismatch\");\n+        }\n+\n+        identifierPrefix.ifPresent(v -> {\n+            if (!v.endsWith(\".\")) {\n+                throw new IllegalArgumentException(\"Invalid identifier prefix\");\n+            }\n+        });\n+    }\n+\n+    static final class Builder {\n+\n+        private Builder() {\n+        }\n+\n+        CodesignConfig create() {\n+            return new CodesignConfig(Optional.ofNullable(identity), Optional.ofNullable(identifierPrefix),\n+                    Optional.ofNullable(entitlements), Optional.ofNullable(keychain));\n+        }\n+\n+        Builder entitlements(Path v) {\n+            entitlements = v;\n+            return this;\n+        }\n+\n+        Builder identity(SigningIdentity v) {\n+            identity = v;\n+            return this;\n+        }\n+\n+        Builder identifierPrefix(String v) {\n+            identifierPrefix = v;\n+            return this;\n+        }\n+\n+        Builder keychain(String v) {\n+            return keychain(Optional.ofNullable(v).map(Keychain::new).orElse(null));\n+        }\n+\n+        Builder keychain(Keychain v) {\n+            keychain = v;\n+            return this;\n+        }\n+\n+        Builder from(AppImageSigningConfig v) {\n+            return identity(v.identity())\n+                    .identifierPrefix(v.identifierPrefix())\n+                    .entitlements(v.entitlements().orElse(null))\n+                    .keychain(v.keychain().orElse(null));\n+        }\n+\n+        Builder from(CodesignConfig v) {\n+            return identity(v.identity().orElse(null))\n+                    .identifierPrefix(v.identifierPrefix().orElse(null))\n+                    .entitlements(v.entitlements().orElse(null))\n+                    .keychain(v.keychain().orElse(null));\n+        }\n+\n+        private SigningIdentity identity;\n+        private String identifierPrefix;\n+        private Path entitlements;\n+        private Keychain keychain;\n+    }\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    List<String> toCodesignArgs() {\n+        List<String> args = new ArrayList<>(List.of(\"-s\", identity.map(SigningIdentity::id).orElse(ADHOC_SIGNING_IDENTITY), \"-vvvv\"));\n+\n+        if (identity.isPresent()) {\n+            args.addAll(List.of(\"--timestamp\", \"--options\", \"runtime\"));\n+            identifierPrefix.ifPresent(v -> {\n+                args.addAll(List.of(\"--prefix\", v));\n+            });\n+            keychain.map(Keychain::asCliArg).ifPresent(k -> args.addAll(List.of(\"--keychain\", k)));\n+            entitlements.map(PathUtils::normalizedAbsolutePathString).ifPresent(e -> args.addAll(List.of(\"--entitlements\", e)));\n+        }\n+\n+        return args;\n+    }\n+\n+    static final String ADHOC_SIGNING_IDENTITY = \"-\";\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/CodesignConfig.java","additions":131,"deletions":0,"binary":false,"changes":131,"status":"added"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.PathUtils;\n+\n+record Keychain(String name) {\n+    Keychain {\n+        Objects.requireNonNull(name);\n+    }\n+\n+    Path path() {\n+        final var path = Path.of(name);\n+        if (path.isAbsolute()) {\n+            return path;\n+        } else {\n+            final var dir = Path.of(System.getProperty(\"user.home\")).resolve(\"Library\/Keychains\");\n+            final var files = filenames(name).map(dir::resolve).toList();\n+            return files.stream().filter(Files::exists).findFirst().orElseGet(() -> {\n+                \/\/ Can't find keychain file in \"$HOME\/Library\/Keychains\" folder.\n+                \/\/ Detect keychain file name from the name of the login keychain file.\n+                return files.stream().filter(f -> {\n+                    final var loginKeycahinFile = f.getParent().resolve(\"login.keychain\" + f.getFileName().toString().substring(name.length()));\n+                    return Files.exists(loginKeycahinFile);\n+                }).findFirst().orElseGet(() -> {\n+                    \/\/ login keychain file doesn't exist, fallback to \"$HOME\/Library\/Keychains\/<name>-db\" keychain file.\n+                    return files.getFirst();\n+                });\n+            });\n+        }\n+    }\n+\n+    String asCliArg() {\n+        final var path = Path.of(name);\n+        if (path.isAbsolute()) {\n+            return PathUtils.normalizedAbsolutePathString(path);\n+        } else {\n+            return name;\n+        }\n+    }\n+\n+    static List<Keychain> listKeychains() {\n+        \/\/ Get the current keychain list\n+        final List<String> cmdOutput;\n+        try {\n+            cmdOutput = Executor.of(\"\/usr\/bin\/security\", \"list-keychains\").saveOutput(true).executeExpectSuccess().getOutput();\n+        } catch (IOException ex) {\n+            throw I18N.buildException().message(\"message.keychain.error\").cause(ex).create(KeychainException::new);\n+        }\n+\n+        \/\/ Typical output of \/usr\/bin\/security command is:\n+        \/\/        \"\/Users\/foo\/Library\/Keychains\/login.keychain-db\"\n+        \/\/        \"\/Library\/Keychains\/System.keychain\"\n+        return cmdOutput.stream().map(String::trim).map(str -> {\n+            \/\/ Strip enclosing double quotes\n+            return str.substring(1, str.length() - 1);\n+        }).map(Keychain::new).toList();\n+    }\n+\n+    static final class KeychainException extends RuntimeException {\n+\n+        KeychainException(String msg) {\n+            super(msg);\n+        }\n+\n+        KeychainException(String msg, Throwable cause) {\n+            super(msg, cause);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    private static Stream<String> filenames(String name) {\n+        return Stream.of(name + \"-db\", name);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/Keychain.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -28,1 +28,3 @@\n-import java.text.MessageFormat;\n+import static jdk.jpackage.internal.StandardBundlerParam.OUTPUT_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n+\n@@ -32,7 +34,1 @@\n-\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEYCHAIN;\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEY_USER;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_STORE;\n-import static jdk.jpackage.internal.StandardBundlerParam.MAIN_CLASS;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n@@ -42,70 +38,19 @@\n-        setAppImageSupplier(imageOutDir -> {\n-            return new MacAppImageBuilder(imageOutDir, isDependentTask());\n-        });\n-        setParamsValidator(MacAppBundler::doValidate);\n-    }\n-\n-    private static final String TEMPLATE_BUNDLE_ICON = \"JavaApp.icns\";\n-\n-    public static final BundlerParamInfo<String> DEFAULT_ICNS_ICON =\n-            new StandardBundlerParam<>(\n-            \".mac.default.icns\",\n-            String.class,\n-            params -> TEMPLATE_BUNDLE_ICON,\n-            (s, p) -> s);\n-\n-    public static final BundlerParamInfo<String> DEVELOPER_ID_APP_SIGNING_KEY =\n-            new StandardBundlerParam<>(\n-            \"mac.signing-key-developer-id-app\",\n-            String.class,\n-            params -> {\n-                    String user = SIGNING_KEY_USER.fetchFrom(params);\n-                    String keychain = SIGNING_KEYCHAIN.fetchFrom(params);\n-                    String result = null;\n-                    if (APP_STORE.fetchFrom(params)) {\n-                        result = MacCertificate.findCertificateKey(\n-                            \"3rd Party Mac Developer Application: \",\n-                            user, keychain);\n-                    }\n-                    \/\/ if either not signing for app store or couldn't find\n-                    if (result == null) {\n-                        result = MacCertificate.findCertificateKey(\n-                            \"Developer ID Application: \", user, keychain);\n-                    }\n-\n-                    if (result != null) {\n-                        MacCertificate certificate = new MacCertificate(result, keychain);\n-\n-                        if (!certificate.isValid()) {\n-                            Log.error(MessageFormat.format(I18N.getString(\n-                                    \"error.certificate.expired\"), result));\n-                        }\n-                    }\n-\n-                    return result;\n-                },\n-            (s, p) -> s);\n-\n-    public static final BundlerParamInfo<String> APP_IMAGE_SIGN_IDENTITY =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId(),\n-            String.class,\n-            params -> \"\",\n-            null);\n-\n-    public static final BundlerParamInfo<String> BUNDLE_ID_SIGNING_PREFIX =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.MAC_BUNDLE_SIGNING_PREFIX.getId(),\n-            String.class,\n-            params -> getIdentifier(params) + \".\",\n-            (s, p) -> s);\n-\n-    static String getIdentifier(Map<String, ? super Object> params) {\n-        String s = MAIN_CLASS.fetchFrom(params);\n-        if (s == null) return null;\n-\n-        int idx = s.lastIndexOf(\".\");\n-        if (idx >= 1) {\n-            return s.substring(0, idx);\n-        }\n-        return s;\n+         setAppImageSupplier((params, output) -> {\n+\n+             \/\/ Order is important!\n+             final var app = MacFromParams.APPLICATION.fetchFrom(params);\n+             final BuildEnv env;\n+\n+             if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n+                 env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+                 final var pkg = MacPackagingPipeline.createSignAppImagePackage(app, env);\n+                 MacPackagingPipeline.build(Optional.of(pkg)).create().execute(env, pkg, output);\n+             } else {\n+                 env = BuildEnv.withAppImageDir(BuildEnvFromParams.BUILD_ENV.fetchFrom(params), output);\n+                 MacPackagingPipeline.build(Optional.empty())\n+                         .excludeDirFromCopying(output.getParent())\n+                         .excludeDirFromCopying(OUTPUT_DIR.fetchFrom(params)).create().execute(env, app);\n+             }\n+\n+         });\n+         setParamsValidator(MacAppBundler::doValidate);\n@@ -117,0 +62,10 @@\n+        try {\n+            MacFromParams.APPLICATION.fetchFrom(params);\n+        } catch (ExceptionBox ex) {\n+            if (ex.getCause() instanceof ConfigException cfgEx) {\n+                throw cfgEx;\n+            } else {\n+                throw ex;\n+            }\n+        }\n+\n@@ -124,28 +79,0 @@\n-        } else {\n-            \/\/ validate short version\n-            try {\n-                String version = VERSION.fetchFrom(params);\n-                CFBundleVersion.of(version);\n-            } catch (IllegalArgumentException ex) {\n-                throw new ConfigException(ex.getMessage(), I18N.getString(\n-                        \"error.invalid-cfbundle-version.advice\"), ex);\n-            }\n-        }\n-\n-        \/\/ reject explicitly set sign to true and no valid signature key\n-        if (Optional.ofNullable(\n-                    SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n-            \/\/ Validate DEVELOPER_ID_APP_SIGNING_KEY only if user provided\n-            \/\/ SIGNING_KEY_USER.\n-            if (!SIGNING_KEY_USER.getIsDefaultValue(params)) { \/\/ --mac-signing-key-user-name\n-                String signingIdentity =\n-                        DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);\n-                if (signingIdentity == null) {\n-                    throw new ConfigException(\n-                            I18N.getString(\"error.explicit-sign-no-cert\"),\n-                            I18N.getString(\"error.explicit-sign-no-cert.advice\"));\n-                }\n-            }\n-\n-            \/\/ No need to validate --mac-app-image-sign-identity, since it is\n-            \/\/ pass through option.\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppBundler.java","additions":33,"deletions":106,"binary":false,"changes":139,"status":"modified"},{"patch":"@@ -1,942 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.io.PrintStream;\n-import java.io.Writer;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.nio.file.attribute.PosixFilePermission;\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.EnumSet;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.ResourceBundle;\n-import java.util.Set;\n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.function.Consumer;\n-import java.util.stream.Stream;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.xpath.XPath;\n-import javax.xml.xpath.XPathConstants;\n-import javax.xml.xpath.XPathFactory;\n-import jdk.internal.util.OSVersion;\n-import static jdk.jpackage.internal.MacAppBundler.BUNDLE_ID_SIGNING_PREFIX;\n-import static jdk.jpackage.internal.MacAppBundler.DEVELOPER_ID_APP_SIGNING_KEY;\n-import static jdk.jpackage.internal.MacAppBundler.APP_IMAGE_SIGN_IDENTITY;\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.SIGNING_KEYCHAIN;\n-import static jdk.jpackage.internal.MacBaseInstallerBundler.INSTALLER_SIGN_IDENTITY;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.COPYRIGHT;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_CONTENT_TYPE;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_EXTENSIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.MAIN_CLASS;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_STORE;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_CONTENT;\n-\n-public class MacAppImageBuilder extends AbstractAppImageBuilder {\n-\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MacResources\");\n-\n-    private static final String TEMPLATE_BUNDLE_ICON = \"JavaApp.icns\";\n-    private static final String OS_TYPE_CODE = \"APPL\";\n-    private static final String TEMPLATE_INFO_PLIST_LITE =\n-            \"Info-lite.plist.template\";\n-    private static final String TEMPLATE_RUNTIME_INFO_PLIST =\n-            \"Runtime-Info.plist.template\";\n-\n-    private final Path root;\n-    private final Path contentsDir;\n-    private final Path resourcesDir;\n-    private final Path macOSDir;\n-    private final Path runtimeDir;\n-    private final Path runtimeRoot;\n-\n-    private final boolean withPackageFile;\n-\n-    private static List<String> keyChains;\n-\n-    public static final BundlerParamInfo<Boolean>\n-            MAC_CONFIGURE_LAUNCHER_IN_PLIST = new StandardBundlerParam<>(\n-                    \"mac.configure-launcher-in-plist\",\n-                    Boolean.class,\n-                    params -> Boolean.FALSE,\n-                    (s, p) -> Boolean.valueOf(s));\n-\n-    public static final BundlerParamInfo<String> MAC_CF_BUNDLE_NAME =\n-            new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.MAC_BUNDLE_NAME.getId(),\n-                    String.class,\n-                    params -> null,\n-                    (s, p) -> s);\n-\n-    public static final BundlerParamInfo<String> APP_CATEGORY =\n-            new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.MAC_CATEGORY.getId(),\n-                    String.class,\n-                    params -> \"utilities\",\n-                    (s, p) -> s);\n-\n-    public static final BundlerParamInfo<String> MAC_CF_BUNDLE_IDENTIFIER =\n-            new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(),\n-                    String.class,\n-                    params -> {\n-                        \/\/ Get identifier from app image if user provided\n-                        \/\/ app image and did not provide the identifier via CLI.\n-                        String identifier = extractBundleIdentifier(params);\n-                        if (identifier == null) {\n-                            identifier =  MacAppBundler.getIdentifier(params);\n-                        }\n-                        if (identifier == null) {\n-                            identifier = APP_NAME.fetchFrom(params);\n-                        }\n-                        return identifier;\n-                    },\n-                    (s, p) -> s);\n-\n-    public static final BundlerParamInfo<Path> ICON_ICNS =\n-            new StandardBundlerParam<>(\n-            \"icon.icns\",\n-            Path.class,\n-            params -> {\n-                Path f = ICON.fetchFrom(params);\n-                if (f != null && f.getFileName() != null && !f.getFileName()\n-                        .toString().toLowerCase().endsWith(\".icns\")) {\n-                    Log.error(MessageFormat.format(\n-                            I18N.getString(\"message.icon-not-icns\"), f));\n-                    return null;\n-                }\n-                return f;\n-            },\n-            (s, p) -> Path.of(s));\n-\n-    public static final BundlerParamInfo<Path> ENTITLEMENTS =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.MAC_ENTITLEMENTS.getId(),\n-            Path.class,\n-            params -> {\n-                try {\n-                    Path path = CONFIG_ROOT.fetchFrom(params).resolve(\n-                        getLauncherName(params) + \".entitlements\");\n-                    String defPath = (APP_STORE.fetchFrom(params) ?\n-                        \"sandbox.plist\" : \"entitlements.plist\");\n-                    createResource(defPath, params)\n-                        .setCategory(I18N.getString(\"resource.entitlements\"))\n-                        .saveToFile(path);\n-                    return path;\n-                } catch (IOException ioe) {\n-                   Log.verbose(ioe);\n-                }\n-                return null;\n-            },\n-            (s, p) -> Path.of(s)\n-        );\n-\n-    private static final StandardBundlerParam<String> FA_MAC_CFBUNDLETYPEROLE =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_CFBUNDLETYPEROLE,\n-                     String.class,\n-                     params -> \"Editor\",\n-                     (s, p) -> s\n-     );\n-\n-     private static final StandardBundlerParam<String> FA_MAC_LSHANDLERRANK =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_LSHANDLERRANK,\n-                     String.class,\n-                     params -> \"Owner\",\n-                     (s, p) -> s\n-     );\n-\n-     private static final StandardBundlerParam<String> FA_MAC_NSSTORETYPEKEY =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_NSSTORETYPEKEY,\n-                     String.class,\n-                     params -> null,\n-                     (s, p) -> s\n-     );\n-\n-     private static final StandardBundlerParam<String> FA_MAC_NSDOCUMENTCLASS =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_NSDOCUMENTCLASS,\n-                     String.class,\n-                     params -> null,\n-                     (s, p) -> s\n-     );\n-\n-     private static final StandardBundlerParam<String> FA_MAC_LSTYPEISPACKAGE =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_LSTYPEISPACKAGE,\n-                     String.class,\n-                     params -> null,\n-                     (s, p) -> s\n-     );\n-\n-     private static final StandardBundlerParam<String> FA_MAC_LSDOCINPLACE =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_LSDOCINPLACE,\n-                     String.class,\n-                     params -> null,\n-                     (s, p) -> s\n-     );\n-\n-     private static final StandardBundlerParam<String> FA_MAC_UIDOCBROWSER =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_UIDOCBROWSER,\n-                     String.class,\n-                     params -> null,\n-                     (s, p) -> s\n-     );\n-\n-     @SuppressWarnings(\"unchecked\")\n-     private static final StandardBundlerParam<List<String>> FA_MAC_NSEXPORTABLETYPES =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_NSEXPORTABLETYPES,\n-                     (Class<List<String>>) (Object) List.class,\n-                     params -> null,\n-                     (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-             );\n-\n-     @SuppressWarnings(\"unchecked\")\n-     private static final StandardBundlerParam<List<String>> FA_MAC_UTTYPECONFORMSTO =\n-             new StandardBundlerParam<>(\n-                     Arguments.MAC_UTTYPECONFORMSTO,\n-                     (Class<List<String>>) (Object) List.class,\n-                     params -> Arrays.asList(\"public.data\"),\n-                     (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n-             );\n-\n-    public MacAppImageBuilder(Path imageOutDir, boolean withPackageFile) {\n-        super(imageOutDir);\n-\n-        this.root = imageOutDir;\n-        this.withPackageFile = withPackageFile;\n-        this.contentsDir = root.resolve(\"Contents\");\n-        this.resourcesDir = appLayout.destktopIntegrationDirectory();\n-        this.macOSDir = appLayout.launchersDirectory();\n-        this.runtimeDir = appLayout.runtimeDirectory();\n-        this.runtimeRoot = appLayout.runtimeHomeDirectory();\n-    }\n-\n-    private void writeEntry(InputStream in, Path dstFile) throws IOException {\n-        Files.createDirectories(dstFile.getParent());\n-        Files.copy(in, dstFile);\n-    }\n-\n-    @Override\n-    protected boolean withAppImageFile(Map<String, ? super Object> params) {\n-        return !withPackageFile;\n-    }\n-\n-    @Override\n-    public void prepareApplicationFiles(Map<String, ? super Object> params)\n-            throws IOException {\n-        \/\/ If predefined app image is provided, then just sign it and return.\n-        Path predefinedAppImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n-        if (predefinedAppImage != null) {\n-            \/\/ Mark app image as signed, before we signing it.\n-            AppImageFile appImageFile =\n-                AppImageFile.load(predefinedAppImage);\n-            if (!appImageFile.isSigned()) {\n-                appImageFile.copyAsSigned().save(predefinedAppImage);\n-            } else {\n-                appImageFile = null;\n-            }\n-\n-            try {\n-                doSigning(params);\n-            } catch (Exception ex) {\n-                \/\/ Restore original app image file if signing failed\n-                if (appImageFile != null) {\n-                    appImageFile.save(predefinedAppImage);\n-                }\n-\n-                throw ex;\n-            }\n-\n-            return;\n-        }\n-\n-        Files.createDirectories(macOSDir);\n-\n-        Map<String, ? super Object> originalParams = new HashMap<>(params);\n-        \/\/ Generate PkgInfo\n-        Path pkgInfoFile = contentsDir.resolve(\"PkgInfo\");\n-        Files.createFile(pkgInfoFile);\n-        writePkgInfo(pkgInfoFile);\n-\n-        Path executable = macOSDir.resolve(getLauncherName(params));\n-\n-        \/\/ create the main app launcher\n-        try (InputStream is_launcher =\n-                getResourceAsStream(\"jpackageapplauncher\")) {\n-            \/\/ Copy executable and library to MacOS folder\n-            writeEntry(is_launcher, executable);\n-        }\n-        executable.toFile().setExecutable(true, false);\n-        \/\/ generate main app launcher config file\n-        writeCfgFile(params);\n-\n-        \/\/ create additional app launcher(s) and config file(s)\n-        List<Map<String, ? super Object>> entryPoints =\n-                ADD_LAUNCHERS.fetchFrom(params);\n-        for (Map<String, ? super Object> entryPoint : entryPoints) {\n-            Map<String, ? super Object> tmp =\n-                    AddLauncherArguments.merge(originalParams, entryPoint);\n-\n-            \/\/ add executable for add launcher\n-            Path addExecutable = macOSDir.resolve(getLauncherName(tmp));\n-            try (InputStream is = getResourceAsStream(\"jpackageapplauncher\");) {\n-                writeEntry(is, addExecutable);\n-            }\n-            addExecutable.toFile().setExecutable(true, false);\n-\n-            \/\/ add config file for add launcher\n-            writeCfgFile(tmp);\n-        }\n-\n-        \/\/ Copy class path entries to Java folder\n-        copyApplication(params);\n-\n-        if (withPackageFile) {\n-            new PackageFile(APP_NAME.fetchFrom(params)).save(\n-                    ApplicationLayout.macAppImage().resolveAt(root));\n-        }\n-\n-        \/*********** Take care of \"config\" files *******\/\n-\n-        createResource(TEMPLATE_BUNDLE_ICON, params)\n-                .setCategory(\"icon\")\n-                .setExternal(ICON_ICNS.fetchFrom(params))\n-                .saveToFile(resourcesDir.resolve(APP_NAME.fetchFrom(params)\n-                        + \".icns\"));\n-\n-        \/\/ copy file association icons\n-        for (Map<String, ?\n-                super Object> fa : FILE_ASSOCIATIONS.fetchFrom(params)) {\n-            Path f = FA_ICON.fetchFrom(fa);\n-            if (IOUtils.exists(f)) {\n-                IOUtils.copyFile(f, resourcesDir.resolve(f.getFileName()));\n-\n-            }\n-        }\n-\n-        copyRuntimeFiles(params);\n-\n-        doSigning(params);\n-    }\n-\n-    private void copyRuntimeFiles(Map<String, ? super Object> params)\n-            throws IOException {\n-        \/\/ Generate Info.plist\n-        writeInfoPlist(contentsDir.resolve(\"Info.plist\"), params);\n-\n-        \/\/ generate java runtime info.plist\n-        writeRuntimeInfoPlist(\n-                runtimeDir.resolve(\"Contents\/Info.plist\"), params);\n-\n-        \/\/ copy library\n-        Path runtimeMacOSDir = Files.createDirectories(\n-                runtimeDir.resolve(\"Contents\/MacOS\"));\n-\n-        final Path jliName = Path.of(\"libjli.dylib\");\n-        try (Stream<Path> walk = Files.walk(runtimeRoot.resolve(\"lib\"))) {\n-            final Path jli = walk\n-                    .filter(file -> file.getFileName().equals(jliName))\n-                    .findFirst()\n-                    .get();\n-            Files.copy(jli, runtimeMacOSDir.resolve(jliName));\n-        }\n-    }\n-\n-    private void doSigning(Map<String, ? super Object> params)\n-            throws IOException {\n-\n-        if (Optional.ofNullable(\n-                SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {\n-            try {\n-                addNewKeychain(params);\n-            } catch (InterruptedException e) {\n-                Log.error(e.getMessage());\n-            }\n-            String signingIdentity = null;\n-            \/\/ Try --mac-app-image-sign-identity first if set\n-            if (!APP_IMAGE_SIGN_IDENTITY.getIsDefaultValue(params)) {\n-                signingIdentity = APP_IMAGE_SIGN_IDENTITY.fetchFrom(params);\n-            } else {\n-                \/\/ Check if INSTALLER_SIGN_IDENTITY is set and if it is set\n-                \/\/ then do not sign app image, otherwise use --mac-signing-key-user-name\n-                if (INSTALLER_SIGN_IDENTITY.getIsDefaultValue(params)) {\n-                    \/\/ --mac-sign and\/or --mac-signing-key-user-name case\n-                    signingIdentity = DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);\n-                }\n-            }\n-            if (signingIdentity != null) {\n-                signAppBundle(params, root, signingIdentity,\n-                        BUNDLE_ID_SIGNING_PREFIX.fetchFrom(params),\n-                        ENTITLEMENTS.fetchFrom(params));\n-            } else {\n-                \/\/ Case when user requested to sign installer only\n-                signAppBundle(params, root, \"-\", null, null);\n-            }\n-            restoreKeychainList(params);\n-        } else {\n-            signAppBundle(params, root, \"-\", null, null);\n-        }\n-    }\n-\n-    private static String getLauncherName(Map<String, ? super Object> params) {\n-        return APP_NAME.fetchFrom(params);\n-    }\n-\n-    private String getBundleName(Map<String, ? super Object> params) {\n-        if (MAC_CF_BUNDLE_NAME.fetchFrom(params) != null) {\n-            String bn = MAC_CF_BUNDLE_NAME.fetchFrom(params);\n-            if (bn.length() > 16) {\n-                Log.error(MessageFormat.format(I18N.getString(\n-                        \"message.bundle-name-too-long-warning\"),\n-                        MAC_CF_BUNDLE_NAME.getID(), bn));\n-            }\n-            return MAC_CF_BUNDLE_NAME.fetchFrom(params);\n-        } else if (APP_NAME.fetchFrom(params) != null) {\n-            return APP_NAME.fetchFrom(params);\n-        } else {\n-            String nm = MAIN_CLASS.fetchFrom(params);\n-            if (nm.length() > 16) {\n-                nm = nm.substring(0, 16);\n-            }\n-            return nm;\n-        }\n-    }\n-\n-    private void writeRuntimeInfoPlist(Path file,\n-            Map<String, ? super Object> params) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-        String identifier = StandardBundlerParam.isRuntimeInstaller(params) ?\n-                MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) :\n-                \"com.oracle.java.\" + MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);\n-        data.put(\"CF_BUNDLE_IDENTIFIER\", identifier);\n-        String name = StandardBundlerParam.isRuntimeInstaller(params) ?\n-                getBundleName(params): \"Java Runtime Image\";\n-        data.put(\"CF_BUNDLE_NAME\", name);\n-        String ver = VERSION.fetchFrom(params);\n-        String sver = ver;\n-        int index = ver.indexOf(\".\");\n-        if (index > 0 && ((index + 1) < ver.length())) {\n-            index = ver.indexOf(\".\", index + 1);\n-            if (index > 0 ) {\n-                sver = ver.substring(0, index);\n-            }\n-        }\n-        data.put(\"CF_BUNDLE_VERSION\", ver);\n-        data.put(\"CF_BUNDLE_SHORT_VERSION_STRING\", sver);\n-\n-        createResource(TEMPLATE_RUNTIME_INFO_PLIST, params)\n-                .setPublicName(\"Runtime-Info.plist\")\n-                .setCategory(I18N.getString(\"resource.runtime-info-plist\"))\n-                .setSubstitutionData(data)\n-                .saveToFile(file);\n-    }\n-\n-    private void writeStringArrayPlist(StringBuilder sb, String key,\n-            List<String> values) {\n-        if (values != null && !values.isEmpty()) {\n-            sb.append(\"  <key>\").append(key).append(\"<\/key>\\n\").append(\"   <array>\\n\");\n-            values.forEach((value) -> {\n-                sb.append(\"    <string>\").append(value).append(\"<\/string>\\n\");\n-            });\n-            sb.append(\"   <\/array>\\n\");\n-        }\n-    }\n-\n-    private void writeStringPlist(StringBuilder sb, String key, String value) {\n-        if (value != null && !value.isEmpty()) {\n-            sb.append(\"  <key>\").append(key).append(\"<\/key>\\n\").append(\"  <string>\")\n-                    .append(value).append(\"<\/string>\\n\").append(\"\\n\");\n-         }\n-    }\n-\n-    private void writeBoolPlist(StringBuilder sb, String key, String value) {\n-        if (value != null && !value.isEmpty()) {\n-            sb.append(\"  <key>\").append(key).append(\"<\/key>\\n\").append(\"  <\")\n-                    .append(value).append(\"\/>\\n\").append(\"\\n\");\n-         }\n-    }\n-\n-    private void writeInfoPlist(Path file, Map<String, ? super Object> params)\n-            throws IOException {\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.preparing-info-plist\"), file.toAbsolutePath()));\n-\n-        \/\/prepare config for exe\n-        \/\/Note: do not need CFBundleDisplayName if we don't support localization\n-        Map<String, String> data = new HashMap<>();\n-        data.put(\"DEPLOY_ICON_FILE\", APP_NAME.fetchFrom(params) + \".icns\");\n-        data.put(\"DEPLOY_BUNDLE_IDENTIFIER\",\n-                MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));\n-        data.put(\"DEPLOY_BUNDLE_NAME\",\n-                getBundleName(params));\n-        data.put(\"DEPLOY_BUNDLE_COPYRIGHT\", COPYRIGHT.fetchFrom(params));\n-        data.put(\"DEPLOY_LAUNCHER_NAME\", getLauncherName(params));\n-        data.put(\"DEPLOY_BUNDLE_SHORT_VERSION\", VERSION.fetchFrom(params));\n-        data.put(\"DEPLOY_BUNDLE_CFBUNDLE_VERSION\", VERSION.fetchFrom(params));\n-        data.put(\"DEPLOY_APP_CATEGORY\", \"public.app-category.\" +\n-                APP_CATEGORY.fetchFrom(params));\n-\n-        StringBuilder bundleDocumentTypes = new StringBuilder();\n-        StringBuilder exportedTypes = new StringBuilder();\n-        for (Map<String, ? super Object>\n-                fileAssociation : FILE_ASSOCIATIONS.fetchFrom(params)) {\n-\n-            List<String> extensions = FA_EXTENSIONS.fetchFrom(fileAssociation);\n-            if (extensions == null) {\n-                Log.verbose(I18N.getString(\n-                        \"message.creating-association-with-null-extension\"));\n-            }\n-\n-            String itemContentType = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params)\n-                    + \".\" + ((extensions == null || extensions.isEmpty())\n-                    ? \"mime\" : extensions.get(0));\n-            String description = FA_DESCRIPTION.fetchFrom(fileAssociation);\n-            Path icon = FA_ICON.fetchFrom(fileAssociation);\n-\n-            bundleDocumentTypes.append(\" <dict>\\n\");\n-            writeStringArrayPlist(bundleDocumentTypes, \"LSItemContentTypes\",\n-                    Arrays.asList(itemContentType));\n-            writeStringPlist(bundleDocumentTypes, \"CFBundleTypeName\", description);\n-            writeStringPlist(bundleDocumentTypes, \"LSHandlerRank\",\n-                    FA_MAC_LSHANDLERRANK.fetchFrom(fileAssociation));\n-            writeStringPlist(bundleDocumentTypes, \"CFBundleTypeRole\",\n-                    FA_MAC_CFBUNDLETYPEROLE.fetchFrom(fileAssociation));\n-            writeStringPlist(bundleDocumentTypes, \"NSPersistentStoreTypeKey\",\n-                    FA_MAC_NSSTORETYPEKEY.fetchFrom(fileAssociation));\n-            writeStringPlist(bundleDocumentTypes, \"NSDocumentClass\",\n-                    FA_MAC_NSDOCUMENTCLASS.fetchFrom(fileAssociation));\n-            writeBoolPlist(bundleDocumentTypes, \"LSIsAppleDefaultForType\",\n-                    \"true\");\n-            writeBoolPlist(bundleDocumentTypes, \"LSTypeIsPackage\",\n-                    FA_MAC_LSTYPEISPACKAGE.fetchFrom(fileAssociation));\n-            writeBoolPlist(bundleDocumentTypes, \"LSSupportsOpeningDocumentsInPlace\",\n-                    FA_MAC_LSDOCINPLACE.fetchFrom(fileAssociation));\n-            writeBoolPlist(bundleDocumentTypes, \"UISupportsDocumentBrowser\",\n-                    FA_MAC_UIDOCBROWSER.fetchFrom(fileAssociation));\n-            if (IOUtils.exists(icon)) {\n-                writeStringPlist(bundleDocumentTypes, \"CFBundleTypeIconFile\",\n-                        icon.getFileName().toString());\n-            }\n-            bundleDocumentTypes.append(\"  <\/dict>\\n\");\n-\n-            exportedTypes.append(\"  <dict>\\n\");\n-            writeStringPlist(exportedTypes, \"UTTypeIdentifier\",\n-                    itemContentType);\n-            writeStringPlist(exportedTypes, \"UTTypeDescription\",\n-                    description);\n-            writeStringArrayPlist(exportedTypes, \"UTTypeConformsTo\",\n-                    FA_MAC_UTTYPECONFORMSTO.fetchFrom(fileAssociation));\n-\n-            if (IOUtils.exists(icon)) {\n-                writeStringPlist(exportedTypes, \"UTTypeIconFile\",\n-                        icon.getFileName().toString());\n-            }\n-            exportedTypes.append(\"\\n\")\n-                    .append(\"  <key>UTTypeTagSpecification<\/key>\\n\")\n-                    .append(\"  <dict>\\n\")\n-                    .append(\"\\n\");\n-            writeStringArrayPlist(exportedTypes, \"public.filename-extension\",\n-                    extensions);\n-            writeStringArrayPlist(exportedTypes, \"public.mime-type\",\n-                    FA_CONTENT_TYPE.fetchFrom(fileAssociation));\n-            writeStringArrayPlist(exportedTypes, \"NSExportableTypes\",\n-                    FA_MAC_NSEXPORTABLETYPES.fetchFrom(fileAssociation));\n-            exportedTypes.append(\"  <\/dict>\\n\").append(\" <\/dict>\\n\");\n-        }\n-        String associationData;\n-        if (bundleDocumentTypes.length() > 0) {\n-            associationData =\n-                    \"\\n  <key>CFBundleDocumentTypes<\/key>\\n  <array>\\n\"\n-                    + bundleDocumentTypes.toString()\n-                    + \"  <\/array>\\n\\n\"\n-                    + \"  <key>UTExportedTypeDeclarations<\/key>\\n  <array>\\n\"\n-                    + exportedTypes.toString()\n-                    + \"  <\/array>\\n\";\n-        } else {\n-            associationData = \"\";\n-        }\n-        data.put(\"DEPLOY_FILE_ASSOCIATIONS\", associationData);\n-\n-        createResource(TEMPLATE_INFO_PLIST_LITE, params)\n-                .setCategory(I18N.getString(\"resource.app-info-plist\"))\n-                .setSubstitutionData(data)\n-                .setPublicName(\"Info.plist\")\n-                .saveToFile(file);\n-    }\n-\n-    private void writePkgInfo(Path file) throws IOException {\n-        \/\/hardcoded as it does not seem we need to change it ever\n-        String signature = \"????\";\n-\n-        try (Writer out = Files.newBufferedWriter(file)) {\n-            out.write(OS_TYPE_CODE + signature);\n-            out.flush();\n-        }\n-    }\n-\n-    public static void addNewKeychain(Map<String, ? super Object> params)\n-                                    throws IOException, InterruptedException {\n-        if (OSVersion.current().compareTo(new OSVersion(10, 12)) < 0) {\n-            \/\/ we need this for OS X 10.12+\n-            return;\n-        }\n-\n-        String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);\n-        if (keyChain == null || keyChain.isEmpty()) {\n-            return;\n-        }\n-\n-        \/\/ get current keychain list\n-        String keyChainPath = Path.of(keyChain).toAbsolutePath().toString();\n-        List<String> keychainList = new ArrayList<>();\n-        int ret = IOUtils.getProcessOutput(\n-                keychainList, \"security\", \"list-keychains\");\n-        if (ret != 0) {\n-            Log.error(I18N.getString(\"message.keychain.error\"));\n-            return;\n-        }\n-        boolean contains = keychainList.stream().anyMatch(\n-                    str -> str.trim().equals(\"\\\"\"+keyChainPath.trim()+\"\\\"\"));\n-        if (contains) {\n-            \/\/ keychain is already added in the search list\n-            return;\n-        }\n-\n-        keyChains = new ArrayList<>();\n-        \/\/ remove \"\n-        keychainList.forEach((String s) -> {\n-            String path = s.trim();\n-            if (path.startsWith(\"\\\"\") && path.endsWith(\"\\\"\")) {\n-                path = path.substring(1, path.length()-1);\n-            }\n-            if (!keyChains.contains(path)) {\n-                keyChains.add(path);\n-            }\n-        });\n-\n-        List<String> args = new ArrayList<>();\n-        args.add(\"\/usr\/bin\/security\");\n-        args.add(\"list-keychains\");\n-        args.add(\"-s\");\n-\n-        args.addAll(keyChains);\n-        args.add(keyChain);\n-\n-        ProcessBuilder  pb = new ProcessBuilder(args);\n-        IOUtils.exec(pb);\n-    }\n-\n-    public static void restoreKeychainList(Map<String, ? super Object> params)\n-            throws IOException{\n-        if (OSVersion.current().compareTo(new OSVersion(10, 12)) < 0) {\n-            \/\/ we need this for OS X 10.12+\n-            return;\n-        }\n-\n-        if (keyChains == null || keyChains.isEmpty()) {\n-            return;\n-        }\n-\n-        List<String> args = new ArrayList<>();\n-        args.add(\"\/usr\/bin\/security\");\n-        args.add(\"list-keychains\");\n-        args.add(\"-s\");\n-\n-        args.addAll(keyChains);\n-\n-        ProcessBuilder  pb = new ProcessBuilder(args);\n-        IOUtils.exec(pb);\n-    }\n-\n-    private static List<String> getCodesignArgs(\n-            boolean force, Path path, String signingIdentity,\n-            String identifierPrefix, Path entitlements, String keyChain) {\n-        List<String> args = new ArrayList<>();\n-        args.addAll(Arrays.asList(\"\/usr\/bin\/codesign\",\n-                    \"-s\", signingIdentity,\n-                    \"-vvvv\"));\n-\n-        if (!signingIdentity.equals(\"-\")) {\n-            args.addAll(Arrays.asList(\"--timestamp\",\n-                    \"--options\", \"runtime\",\n-                    \"--prefix\", identifierPrefix));\n-            if (keyChain != null && !keyChain.isEmpty()) {\n-                args.add(\"--keychain\");\n-                args.add(keyChain);\n-            }\n-            if (Files.isExecutable(path)) {\n-                if (entitlements != null) {\n-                    args.add(\"--entitlements\");\n-                    args.add(entitlements.toString());\n-                }\n-            }\n-        }\n-\n-        if (force) {\n-            args.add(\"--force\");\n-        }\n-\n-        args.add(path.toString());\n-\n-        return args;\n-    }\n-\n-    private static void runCodesign(\n-            ProcessBuilder pb, boolean quiet, Map<String, ? super Object> params)\n-            throws IOException {\n-        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-             PrintStream ps = new PrintStream(baos)) {\n-            try {\n-            IOUtils.exec(pb, false, ps, false,\n-                         Executor.INFINITE_TIMEOUT, quiet);\n-            } catch (IOException ioe) {\n-                \/\/ Log output of \"codesign\" in case of error. It should help\n-                \/\/ user to diagnose issues when using --mac-app-image-sign-identity.\n-                \/\/ In addition add possible reason for failure. For example\n-                \/\/ \"--app-content\" can fail \"codesign\".\n-\n-                \/\/ APP_CONTENT is never null.\n-                if (!APP_CONTENT.fetchFrom(params).isEmpty()) {\n-                    Log.info(I18N.getString(\n-                        \"message.codesign.failed.reason.app.content\"));\n-                }\n-\n-                \/\/ Signing might not work without Xcode with command line\n-                \/\/ developer tools. Show user if Xcode is missing as possible\n-                \/\/ reason.\n-                if (!isXcodeDevToolsInstalled()) {\n-                    Log.info(I18N.getString(\n-                        \"message.codesign.failed.reason.xcode.tools\"));\n-                }\n-\n-                \/\/ Log \"codesign\" output\n-                Log.info(MessageFormat.format(I18N.getString(\n-                         \"error.tool.failed.with.output\"), \"codesign\"));\n-                Log.info(baos.toString().strip());\n-\n-                throw ioe;\n-            }\n-        }\n-    }\n-\n-    private static boolean isXcodeDevToolsInstalled() {\n-        try {\n-            Executor.of(\"\/usr\/bin\/xcrun\", \"--help\").executeExpectSuccess();\n-        } catch (IOException e) {\n-            return false;\n-        }\n-\n-        return true;\n-    }\n-\n-    static void signAppBundle(\n-            Map<String, ? super Object> params, Path appLocation,\n-            String signingIdentity, String identifierPrefix, Path entitlements)\n-            throws IOException {\n-        AtomicReference<IOException> toThrow = new AtomicReference<>();\n-        String appExecutable = \"\/Contents\/MacOS\/\" + APP_NAME.fetchFrom(params);\n-        String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);\n-\n-        \/\/ sign all dylibs and executables\n-        try (Stream<Path> stream = Files.walk(appLocation)) {\n-            stream.peek(path -> { \/\/ fix permissions\n-                try {\n-                    Set<PosixFilePermission> pfp\n-                            = Files.getPosixFilePermissions(path);\n-                    if (!pfp.contains(PosixFilePermission.OWNER_WRITE)) {\n-                        pfp = EnumSet.copyOf(pfp);\n-                        pfp.add(PosixFilePermission.OWNER_WRITE);\n-                        Files.setPosixFilePermissions(path, pfp);\n-                    }\n-                } catch (IOException e) {\n-                    Log.verbose(e);\n-                }\n-            }).filter(p -> Files.isRegularFile(p)\n-                    && (Files.isExecutable(p) || p.toString().endsWith(\".dylib\"))\n-                    && !(p.toString().contains(\"dylib.dSYM\/Contents\"))\n-                    && !(p.toString().endsWith(appExecutable))\n-            ).forEach(p -> {\n-                \/\/ noinspection ThrowableResultOfMethodCallIgnored\n-                if (toThrow.get() != null) {\n-                    return;\n-                }\n-\n-                \/\/ If p is a symlink then skip the signing process.\n-                if (Files.isSymbolicLink(p)) {\n-                    Log.verbose(MessageFormat.format(I18N.getString(\n-                            \"message.ignoring.symlink\"), p.toString()));\n-                } else {\n-                    \/\/ unsign everything before signing\n-                    List<String> args = new ArrayList<>();\n-                    args.addAll(Arrays.asList(\"\/usr\/bin\/codesign\",\n-                            \"--remove-signature\", p.toString()));\n-                    try {\n-                        Set<PosixFilePermission> oldPermissions =\n-                                Files.getPosixFilePermissions(p);\n-                        p.toFile().setWritable(true, true);\n-                        ProcessBuilder pb = new ProcessBuilder(args);\n-                        \/\/ run quietly\n-                        IOUtils.exec(pb, false, null, false,\n-                                Executor.INFINITE_TIMEOUT, true);\n-                        Files.setPosixFilePermissions(p, oldPermissions);\n-                    } catch (IOException ioe) {\n-                        Log.verbose(ioe);\n-                        toThrow.set(ioe);\n-                        return;\n-                    }\n-\n-                    \/\/ Sign only if we have identity\n-                    if (signingIdentity != null) {\n-                        args = getCodesignArgs(false, p, signingIdentity,\n-                                identifierPrefix, entitlements, keyChain);\n-                        try {\n-                            Set<PosixFilePermission> oldPermissions\n-                                    = Files.getPosixFilePermissions(p);\n-                            p.toFile().setWritable(true, true);\n-                            ProcessBuilder pb = new ProcessBuilder(args);\n-                            \/\/ run quietly\n-                            runCodesign(pb, true, params);\n-                            Files.setPosixFilePermissions(p, oldPermissions);\n-                        } catch (IOException ioe) {\n-                            toThrow.set(ioe);\n-                        }\n-                    }\n-                }\n-            });\n-        }\n-        IOException ioe = toThrow.get();\n-        if (ioe != null) {\n-            throw ioe;\n-        }\n-\n-        \/\/ We cannot continue signing without identity\n-        if (signingIdentity == null) {\n-            return;\n-        }\n-\n-        \/\/ sign all runtime and frameworks\n-        Consumer<? super Path> signIdentifiedByPList = path -> {\n-            \/\/noinspection ThrowableResultOfMethodCallIgnored\n-            if (toThrow.get() != null) return;\n-\n-            try {\n-                List<String> args = getCodesignArgs(true, path, signingIdentity,\n-                            identifierPrefix, entitlements, keyChain);\n-                ProcessBuilder pb = new ProcessBuilder(args);\n-                runCodesign(pb, false, params);\n-            } catch (IOException e) {\n-                toThrow.set(e);\n-            }\n-        };\n-\n-        Path javaPath = appLocation.resolve(\"Contents\/runtime\");\n-        if (Files.isDirectory(javaPath)) {\n-            signIdentifiedByPList.accept(javaPath);\n-\n-            ioe = toThrow.get();\n-            if (ioe != null) {\n-                throw ioe;\n-            }\n-        }\n-        Path frameworkPath = appLocation.resolve(\"Contents\/Frameworks\");\n-        if (Files.isDirectory(frameworkPath)) {\n-            try (var fileList = Files.list(frameworkPath)) {\n-                fileList.forEach(signIdentifiedByPList);\n-            }\n-\n-            ioe = toThrow.get();\n-            if (ioe != null) {\n-                throw ioe;\n-            }\n-        }\n-\n-        \/\/ sign the app itself\n-        List<String> args = getCodesignArgs(true, appLocation, signingIdentity,\n-                identifierPrefix, entitlements, keyChain);\n-        ProcessBuilder pb = new ProcessBuilder(args);\n-        runCodesign(pb, false, params);\n-    }\n-\n-    private static String extractBundleIdentifier(Map<String, Object> params) {\n-        if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {\n-            return null;\n-        }\n-\n-        try {\n-            Path infoPList = PREDEFINED_APP_IMAGE.fetchFrom(params).resolve(\"Contents\").\n-                    resolve(\"Info.plist\");\n-\n-            DocumentBuilderFactory dbf\n-                    = DocumentBuilderFactory.newDefaultInstance();\n-            dbf.setFeature(\"http:\/\/apache.org\/xml\/features\/\" +\n-                           \"nonvalidating\/load-external-dtd\", false);\n-            DocumentBuilder b = dbf.newDocumentBuilder();\n-            org.w3c.dom.Document doc = b.parse(Files.newInputStream(infoPList));\n-\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-            \/\/ Query for the value of <string> element preceding <key>\n-            \/\/ element with value equal to CFBundleIdentifier\n-            String v = (String) xPath.evaluate(\n-                    \"\/\/string[preceding-sibling::key = \\\"CFBundleIdentifier\\\"][1]\",\n-                    doc, XPathConstants.STRING);\n-\n-            if (v != null && !v.isEmpty()) {\n-                return v;\n-            }\n-        } catch (Exception ex) {\n-            Log.verbose(ex);\n-        }\n-\n-        return null;\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageBuilder.java","additions":0,"deletions":942,"binary":false,"changes":942,"status":"deleted"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.AppImageFile.getBooleanExtraFieldValue;\n+\n+import jdk.jpackage.internal.model.MacApplication.ExtraAppImageFileField;\n+\n+record MacAppImageFileExtras(boolean signed, boolean appStore) {\n+\n+    MacAppImageFileExtras(AppImageFile appImageFile) {\n+        this(getBooleanExtraFieldValue(ExtraAppImageFileField.SIGNED.fieldName(), appImageFile),\n+                getBooleanExtraFieldValue(ExtraAppImageFileField.APP_STORE.fieldName(), appImageFile));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacAppImageFileExtras.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,236 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.MacApplication;\n+import jdk.jpackage.internal.model.MacApplicationMixin;\n+import jdk.jpackage.internal.model.AppImageSigningConfig;\n+\n+final class MacApplicationBuilder {\n+\n+    MacApplicationBuilder(Application app) {\n+        this.app = Objects.requireNonNull(app);\n+    }\n+\n+    private MacApplicationBuilder(MacApplicationBuilder other) {\n+        this(other.app);\n+        icon = other.icon;\n+        bundleName = other.bundleName;\n+        bundleIdentifier = other.bundleIdentifier;\n+        category = other.category;\n+        appStore = other.appStore;\n+        externalInfoPlistFile = other.externalInfoPlistFile;\n+        signingBuilder = other.signingBuilder;\n+    }\n+\n+    MacApplicationBuilder icon(Path v) {\n+        icon = v;\n+        return this;\n+    }\n+\n+    MacApplicationBuilder bundleName(String v) {\n+        bundleName = v;\n+        return this;\n+    }\n+\n+    MacApplicationBuilder bundleIdentifier(String v) {\n+        bundleIdentifier = v;\n+        return this;\n+    }\n+\n+    MacApplicationBuilder category(String v) {\n+        category = v;\n+        return this;\n+    }\n+\n+    MacApplicationBuilder appStore(boolean v) {\n+        appStore = v;\n+        return this;\n+    }\n+\n+    MacApplicationBuilder externalInfoPlistFile(Path v) {\n+        externalInfoPlistFile = v;\n+        return this;\n+    }\n+\n+    MacApplicationBuilder signingBuilder(AppImageSigningConfigBuilder v) {\n+        signingBuilder = v;\n+        return this;\n+    }\n+\n+    MacApplication create() throws ConfigException {\n+        if (externalInfoPlistFile != null) {\n+            return createCopyForExternalInfoPlistFile().create();\n+        }\n+\n+        validateAppVersion(app);\n+\n+        final var mixin = new MacApplicationMixin.Stub(validatedIcon(), validatedBundleName(),\n+                validatedBundleIdentifier(), validatedCategory(), appStore, createSigningConfig());\n+\n+        return MacApplication.create(app, mixin);\n+    }\n+\n+    static boolean isValidBundleIdentifier(String id) {\n+        for (int i = 0; i < id.length(); i++) {\n+            char a = id.charAt(i);\n+            \/\/ We check for ASCII codes first which we accept. If check fails,\n+            \/\/ check if it is acceptable extended ASCII or unicode character.\n+            if ((a >= 'A' && a <= 'Z') || (a >= 'a' && a <= 'z')\n+                    || (a >= '0' && a <= '9') || (a == '-' || a == '.')) {\n+                continue;\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    private static void validateAppVersion(Application app) throws ConfigException {\n+        try {\n+            CFBundleVersion.of(app.version());\n+        } catch (IllegalArgumentException ex) {\n+            throw I18N.buildConfigException(ex).advice(\"error.invalid-cfbundle-version.advice\").create();\n+        }\n+    }\n+\n+    private MacApplicationBuilder createCopyForExternalInfoPlistFile() throws ConfigException {\n+        try {\n+            final var plistFile = AppImageInfoPListFile.loadFromInfoPList(externalInfoPlistFile);\n+\n+            final var builder = new MacApplicationBuilder(this);\n+\n+            builder.externalInfoPlistFile(null);\n+\n+            if (builder.bundleName == null) {\n+                builder.bundleName(plistFile.bundleName());\n+            }\n+\n+            if (builder.bundleIdentifier == null) {\n+                builder.bundleIdentifier(plistFile.bundleIdentifier());\n+            }\n+\n+            if (builder.category == null) {\n+                builder.category(plistFile.category());\n+            }\n+\n+            return builder;\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        } catch (Exception ex) {\n+            throw I18N.buildConfigException(\"message.app-image-requires-identifier\")\n+                    .advice(\"message.app-image-requires-identifier.advice\")\n+                    .cause(ex)\n+                    .create();\n+        }\n+    }\n+\n+    private Optional<AppImageSigningConfig> createSigningConfig() throws ConfigException {\n+        if (signingBuilder != null) {\n+            return signingBuilder.create();\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private String validatedBundleName() throws ConfigException {\n+        final var value = Optional.ofNullable(bundleName).orElseGet(() -> {\n+            final var appName = app.name();\n+\/\/ Commented out for backward compatibility\n+\/\/            if (appName.length() > MAX_BUNDLE_NAME_LENGTH) {\n+\/\/                return appName.substring(0, MAX_BUNDLE_NAME_LENGTH);\n+\/\/            } else {\n+\/\/                return appName;\n+\/\/            }\n+            return appName;\n+        });\n+\n+        if (value.length() > MAX_BUNDLE_NAME_LENGTH && (bundleName != null)) {\n+            Log.error(I18N.format(\"message.bundle-name-too-long-warning\", \"--mac-package-name\", value));\n+        }\n+\n+        return value;\n+    }\n+\n+    private String validatedBundleIdentifier() throws ConfigException {\n+        final var value = Optional.ofNullable(bundleIdentifier).orElseGet(() -> {\n+            return app.mainLauncher()\n+                    .flatMap(Launcher::startupInfo)\n+                    .map(li -> {\n+                        final var packageName = li.packageName();\n+                        if (packageName.isEmpty()) {\n+                            return li.simpleClassName();\n+                        } else {\n+                            return packageName;\n+                        }\n+                    })\n+                    .orElseGet(app::name);\n+        });\n+\n+        if (!isValidBundleIdentifier(value)) {\n+            throw I18N.buildConfigException(\"message.invalid-identifier\", value)\n+                    .advice(\"message.invalid-identifier.advice\")\n+                    .create();\n+        }\n+\n+        return value;\n+    }\n+\n+    private String validatedCategory() throws ConfigException {\n+        return \"public.app-category.\" + Optional.ofNullable(category).orElseGet(DEFAULTS::category);\n+    }\n+\n+    private Optional<Path> validatedIcon() throws ConfigException {\n+        if (icon != null) {\n+            LauncherBuilder.validateIcon(icon);\n+        }\n+\n+        return Optional.ofNullable(icon);\n+    }\n+\n+    private record Defaults(String category) {\n+    }\n+\n+    private Path icon;\n+    private String bundleName;\n+    private String bundleIdentifier;\n+    private String category;\n+    private boolean appStore;\n+    private Path externalInfoPlistFile;\n+    private AppImageSigningConfigBuilder signingBuilder;\n+\n+    private final Application app;\n+\n+    private static final Defaults DEFAULTS = new Defaults(\"utilities\");\n+\n+    private static final int MAX_BUNDLE_NAME_LENGTH = 16;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationBuilder.java","additions":236,"deletions":0,"binary":false,"changes":236,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+interface MacApplicationLayout extends ApplicationLayout, MacApplicationLayoutMixin {\n+\n+    static MacApplicationLayout create(ApplicationLayout layout, Path runtimeRootDir) {\n+        return CompositeProxy.build()\n+                .invokeTunnel(CompositeProxyTunnel.INSTANCE)\n+                .create(MacApplicationLayout.class, layout, new MacApplicationLayoutMixin.Stub(runtimeRootDir));\n+    }\n+\n+    @Override\n+    default MacApplicationLayout resolveAt(Path root) {\n+        return create(ApplicationLayout.super.resolveAt(root),\n+                resolveNullablePath(root, runtimeRootDirectory()));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayout.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+\n+\/\/ Must be publc to allow access from AppImageLayout.toPathGroup()\n+public interface MacApplicationLayoutMixin {\n+\n+    \/**\n+     * Path to the root Java runtime directory in the application image.\n+     * The root Java runtime directory should have \"Contents\/Home\" subdirectory.\n+     *\/\n+    Path runtimeRootDirectory();\n+\n+    record Stub(Path runtimeRootDirectory) implements MacApplicationLayoutMixin {}\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacApplicationLayoutMixin.java","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"},{"patch":"@@ -28,1 +28,4 @@\n-import java.io.IOException;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n+import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n+\n@@ -30,1 +33,0 @@\n-import java.nio.file.LinkOption;\n@@ -35,7 +37,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALLER_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-\n@@ -43,2 +38,0 @@\n-import jdk.jpackage.internal.model.PackagerException;\n-import jdk.jpackage.internal.util.FileUtils;\n@@ -48,90 +41,0 @@\n-    private final BundlerParamInfo<Path> APP_IMAGE_TEMP_ROOT =\n-            new StandardBundlerParam<>(\n-            \"mac.app.imageRoot\",\n-            Path.class,\n-            params -> {\n-                Path imageDir = IMAGES_ROOT.fetchFrom(params);\n-                try {\n-                    if (!IOUtils.exists(imageDir)) {\n-                        Files.createDirectories(imageDir);\n-                    }\n-                    return Files.createTempDirectory(\n-                            imageDir, \"image-\");\n-                } catch (IOException e) {\n-                    return imageDir.resolve(getID()+ \".image\");\n-                }\n-            },\n-            (s, p) -> Path.of(s));\n-\n-    public static final BundlerParamInfo<String> SIGNING_KEY_USER =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.MAC_SIGNING_KEY_NAME.getId(),\n-            String.class,\n-            params -> \"\",\n-            null);\n-\n-    public static final BundlerParamInfo<String> SIGNING_KEYCHAIN =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.MAC_SIGNING_KEYCHAIN.getId(),\n-            String.class,\n-            params -> \"\",\n-            null);\n-\n-    public static final BundlerParamInfo<String> INSTALLER_SIGN_IDENTITY =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId(),\n-            String.class,\n-            params -> \"\",\n-            null);\n-\n-    public static final BundlerParamInfo<String> MAC_INSTALLER_NAME =\n-            new StandardBundlerParam<> (\n-            \"mac.installerName\",\n-            String.class,\n-            params -> {\n-                String nm = INSTALLER_NAME.fetchFrom(params);\n-                if (nm == null) return null;\n-\n-                String version = VERSION.fetchFrom(params);\n-                if (version == null) {\n-                    return nm;\n-                } else {\n-                    return nm + \"-\" + version;\n-                }\n-            },\n-            (s, p) -> s);\n-\n-     \/\/ Returns full path to installation directory\n-     static String getInstallDir(\n-            Map<String, ? super Object>  params, boolean defaultOnly) {\n-        String returnValue = INSTALL_DIR.fetchFrom(params);\n-\n-        final String defaultInstallDir;\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            defaultInstallDir = \"\/Library\/Java\/JavaVirtualMachines\";\n-        } else {\n-            defaultInstallDir = \"\/Applications\";\n-        }\n-\n-        if (defaultOnly && returnValue != null && !Path.of(returnValue).equals(Path.of(defaultInstallDir))) {\n-            Log.info(MessageFormat.format(I18N.getString(\"message.install-dir-ignored\"), defaultInstallDir));\n-            returnValue = null;\n-        }\n-        if (returnValue == null) {\n-            returnValue = defaultInstallDir;\n-        }\n-        return returnValue;\n-    }\n-\n-    \/\/ Returns display name of installation directory. Display name is used to\n-    \/\/ show user installation location and for well known (default only) we will\n-    \/\/ use \"Applications\" or \"JavaVirtualMachines\".\n-    static String getInstallDirDisplayName(\n-            Map<String, ? super Object>  params) {\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            return \"JavaVirtualMachines\";\n-        } else {\n-            return \"Applications\";\n-        }\n-    }\n-\n@@ -139,2 +42,1 @@\n-        appImageBundler = new MacAppBundler()\n-                .setDependentTask(true);\n+        appImageBundler = new MacAppBundler();\n@@ -147,1 +49,2 @@\n-            if (AppImageFile.load(applicationImage).isSigned()) {\n+            if (new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params)).signed()) {\n+                var appLayout = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT.resolveAt(applicationImage);\n@@ -149,1 +52,1 @@\n-                        PackageFile.getPathInAppImage(applicationImage))) {\n+                        PackageFile.getPathInAppImage(appLayout))) {\n@@ -152,1 +55,1 @@\n-                            PackageFile.getPathInAppImage(applicationImage)));\n+                            PackageFile.getPathInAppImage(appLayout)));\n@@ -168,30 +71,0 @@\n-    protected Path prepareAppBundle(Map<String, ? super Object> params)\n-            throws PackagerException, IOException {\n-        Path appDir;\n-        Path appImageRoot = APP_IMAGE_TEMP_ROOT.fetchFrom(params);\n-        Path predefinedImage =\n-                StandardBundlerParam.getPredefinedAppImage(params);\n-        if (predefinedImage != null) {\n-            appDir = appImageRoot.resolve(APP_NAME.fetchFrom(params) + \".app\");\n-            FileUtils.copyRecursive(predefinedImage, appDir,\n-                    LinkOption.NOFOLLOW_LINKS);\n-\n-            \/\/ Alter app image if predefined app image is not signed\n-            if (!AppImageFile.load(predefinedImage).isSigned()) {\n-                new PackageFile(APP_NAME.fetchFrom(params)).save(\n-                        ApplicationLayout.macAppImage().resolveAt(appDir));\n-                Files.deleteIfExists(AppImageFile.getPathInAppImage(appDir));\n-                \/\/ We need to re-sign app image after adding \".package\" to it.\n-                \/\/ We only do this if app image was not signed which means it is\n-                \/\/ signed with ad-hoc signature. App bundles with ad-hoc\n-                \/\/ signature are sealed, but without a signing identity, so we\n-                \/\/ need to re-sign it after modification.\n-                MacAppImageBuilder.signAppBundle(params, appDir, \"-\", null, null);\n-            }\n-        } else {\n-            appDir = appImageBundler.execute(params, appImageRoot);\n-        }\n-\n-        return appDir;\n-    }\n-\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacBaseInstallerBundler.java","additions":9,"deletions":136,"binary":false,"changes":145,"status":"modified"},{"patch":"@@ -1,335 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.nio.file.StandardCopyOption;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.DateFormat;\n-import java.text.MessageFormat;\n-import java.text.ParseException;\n-import java.text.SimpleDateFormat;\n-import java.util.ArrayList;\n-import java.util.Calendar;\n-import java.util.Date;\n-import java.util.HexFormat;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-public final class MacCertificate {\n-    private final String certificate;\n-    private final Optional<String> keychainName;\n-\n-    public MacCertificate(String certificate, String keychainName) {\n-        this.certificate = Objects.requireNonNull(certificate);\n-        this.keychainName = Optional.ofNullable(keychainName);\n-    }\n-\n-    public boolean isValid() {\n-        return verifyCertificate();\n-    }\n-\n-    public static String findCertificateKey(String keyPrefix, String teamName,\n-                                            String keychainName) {\n-\n-        String matchedKey = null;\n-        boolean useAsIs = (keyPrefix == null)\n-                || teamName.startsWith(keyPrefix)\n-                || teamName.startsWith(\"Developer ID\")\n-                || teamName.startsWith(\"3rd Party Mac\");\n-\n-        String name = (useAsIs) ? teamName : (keyPrefix + teamName);\n-\n-        String output = getFindCertificateOutput(name, keychainName);\n-        if (output == null) {\n-            Log.error(MessageFormat.format(I18N.getString(\n-                        \"error.cert.not.found\"), name, keychainName));\n-            return null;\n-        }\n-\n-        \/\/ Check and warn user if multiple certificates found\n-        \/\/ We will use different regex to count certificates.\n-        \/\/ ASCII case: \"alis\"<blob>=\"NAME\"\n-        \/\/ UNICODE case: \"alis\"<blob>=0xSOMEHEXDIGITS  \"NAME (\\SOMEDIGITS)\"\n-        \/\/ In UNICODE case name will contain octal sequence representing UTF-8\n-        \/\/ characters.\n-        \/\/ Just look for at least two '\"alis\"<blob>'.\n-        Pattern p = Pattern.compile(\"\\\"alis\\\"<blob>\");\n-        Matcher m = p.matcher(output);\n-        if (m.find() && m.find()) {\n-            Log.error(MessageFormat.format(I18N.getString(\n-                        \"error.multiple.certs.found\"), name, keychainName));\n-        }\n-\n-        \/\/ Try to get ASCII only certificate first. This aproach only works\n-        \/\/ if certificate name has ASCII only characters in name. For certificates\n-        \/\/ with UNICODE characters in name we will use combination of \"security\"\n-        \/\/ and \"openssl\". We keeping ASCII only aproach to avoid regressions and\n-        \/\/ it works for many use cases.\n-        p = Pattern.compile(\"\\\"alis\\\"<blob>=\\\"([^\\\"]+)\\\"\");\n-        m = p.matcher(output);\n-        if (m.find()) {\n-            matchedKey = m.group(1);;\n-        }\n-\n-        \/\/ Maybe it has UNICODE characters in name. In this case use \"security\"\n-        \/\/ and \"openssl\" to exctract name. We cannot use just \"security\", since\n-        \/\/ name can be truncated.\n-        if (matchedKey == null) {\n-            Path  file = null;\n-            try {\n-                file = getFindCertificateOutputPEM(name, keychainName);\n-                if (file != null) {\n-                    matchedKey = findCertificateSubject(\n-                                    file.toFile().getCanonicalPath());\n-                }\n-            } catch (IOException ioe) {\n-                Log.verbose(ioe);\n-            } finally {\n-                try {\n-                    Files.deleteIfExists(file);\n-                } catch (IOException ignored) {}\n-            }\n-        }\n-\n-        if (matchedKey == null) {\n-            Log.error(MessageFormat.format(I18N.getString(\n-                \"error.cert.not.found\"), name, keychainName));\n-        }\n-\n-        return matchedKey;\n-    }\n-\n-    private static String getFindCertificateOutput(String name,\n-                                                   String keychainName) {\n-        try (ByteArrayOutputStream baos = getFindCertificateOutput(name,\n-                                                                   keychainName,\n-                                                                   false)) {\n-            if (baos != null) {\n-                return baos.toString();\n-            }\n-        } catch (IOException ioe) {\n-            Log.verbose(ioe);\n-        }\n-\n-        return null;\n-    }\n-\n-    private static Path getFindCertificateOutputPEM(String name,\n-                                                    String keychainName) {\n-        Path output = null;\n-        try (ByteArrayOutputStream baos = getFindCertificateOutput(name,\n-                                                                   keychainName,\n-                                                                   true)) {\n-            if (baos != null) {\n-                output = Files.createTempFile(\"tempfile\", \".tmp\");\n-                Files.copy(new ByteArrayInputStream(baos.toByteArray()),\n-                        output, StandardCopyOption.REPLACE_EXISTING);\n-                return output;\n-            }\n-        } catch (IOException ioe) {\n-            Log.verbose(ioe);\n-            try {\n-                Files.deleteIfExists(output);\n-            } catch (IOException ignored) {}\n-        }\n-\n-        return null;\n-    }\n-\n-    private static ByteArrayOutputStream getFindCertificateOutput(String name,\n-                                                                  String keychainName,\n-                                                                  boolean isPEMFormat) {\n-        List<String> args = new ArrayList<>();\n-        args.add(\"\/usr\/bin\/security\");\n-        args.add(\"find-certificate\");\n-        args.add(\"-c\");\n-        args.add(name);\n-        args.add(\"-a\");\n-        if (isPEMFormat) {\n-            args.add(\"-p\");\n-        }\n-        if (keychainName != null && !keychainName.isEmpty()) {\n-            args.add(keychainName);\n-        }\n-\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        try (PrintStream ps = new PrintStream(baos)) {\n-            ProcessBuilder pb = new ProcessBuilder(args);\n-            IOUtils.exec(pb, false, ps);\n-            return baos;\n-        } catch (IOException ioe) {\n-            Log.verbose(ioe);\n-            return null;\n-        }\n-    }\n-\n-    private static String findCertificateSubject(String filename) {\n-        String result = null;\n-\n-        List<String> args = new ArrayList<>();\n-        args.add(\"\/usr\/bin\/openssl\");\n-        args.add(\"x509\");\n-        args.add(\"-noout\");\n-        args.add(\"-subject\");\n-        args.add(\"-in\");\n-        args.add(filename);\n-\n-        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-                PrintStream ps = new PrintStream(baos)) {\n-            ProcessBuilder security = new ProcessBuilder(args);\n-            IOUtils.exec(security, false, ps);\n-            String output = baos.toString().strip();\n-            \/\/ Example output:\n-            \/\/ subject= \/UID=ABCDABCD\/CN=jpackage.openjdk.java.net (\\xC3\\xB6) (ABCDABCD)\/C=US\n-            \/\/ We need 'CN' value\n-            String [] pairs = output.split(\"\/\");\n-            for (String pair : pairs) {\n-                if (pair.startsWith(\"CN=\")) {\n-                    result = pair.substring(3);\n-                    \/\/ Convert escaped UTF-8 code points to characters\n-                    result = convertHexToChar(result);\n-                    break;\n-                }\n-            }\n-        } catch (IOException ex) {\n-            Log.verbose(ex);\n-        }\n-\n-        return result;\n-    }\n-\n-    \/\/ Certificate name with Unicode will be:\n-    \/\/ Developer ID Application: jpackage.openjdk.java.net (\\xHH\\xHH)\n-    \/\/ Convert UTF-8 code points '\\xHH\\xHH' to character.\n-    private static String convertHexToChar(String input) {\n-        if (input == null || input.isEmpty()) {\n-            return input;\n-        }\n-\n-        if (!input.contains(\"\\\\x\")) {\n-            return input;\n-        }\n-\n-        StringBuilder output = new StringBuilder();\n-        try {\n-            int len = input.length();\n-            for (int i = 0; i < len; i++) {\n-                if (input.codePointAt(i) == '\\\\' &&\n-                    (i + 8) <= len &&\n-                    input.codePointAt(i + 1) == 'x' &&\n-                    input.codePointAt(i + 4) == '\\\\' &&\n-                    input.codePointAt(i + 5) == 'x') {\n-                        \/\/ We found '\\xHH\\xHH'\n-                        \/\/ HEX code points to byte array\n-                        byte [] bytes = HexFormat.of().parseHex(\n-                            input.substring(i + 2, i + 4) + input.substring(i + 6, i + 8));\n-                        \/\/ Byte array with UTF-8 code points to character\n-                        output.append(new String(bytes, \"UTF-8\"));\n-                        i += 7; \/\/ Skip '\\xHH\\xHH'\n-                } else {\n-                    output.appendCodePoint(input.codePointAt(i));\n-                }\n-            }\n-        } catch (Exception ex) {\n-            Log.verbose(ex);\n-            \/\/ We will consider any excpetions during conversion as\n-            \/\/ certificate not found.\n-            return null;\n-        }\n-\n-        return output.toString();\n-    }\n-\n-    private Date findCertificateDate(String filename) {\n-        Date result = null;\n-\n-        List<String> args = new ArrayList<>();\n-        args.add(\"\/usr\/bin\/openssl\");\n-        args.add(\"x509\");\n-        args.add(\"-noout\");\n-        args.add(\"-enddate\");\n-        args.add(\"-in\");\n-        args.add(filename);\n-\n-        try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-                PrintStream ps = new PrintStream(baos)) {\n-            ProcessBuilder security = new ProcessBuilder(args);\n-            IOUtils.exec(security, false, ps);\n-            String output = baos.toString();\n-            output = output.substring(output.indexOf(\"=\") + 1);\n-            DateFormat df = new SimpleDateFormat(\n-                    \"MMM dd kk:mm:ss yyyy z\", Locale.ENGLISH);\n-            result = df.parse(output);\n-        } catch (IOException | ParseException ex) {\n-            Log.verbose(ex);\n-        }\n-\n-        return result;\n-    }\n-\n-    private boolean verifyCertificate() {\n-        boolean result = false;\n-\n-        try {\n-            Path file = null;\n-            Date certificateDate = null;\n-\n-            try {\n-                file = getFindCertificateOutputPEM(certificate, keychainName.orElse(null));\n-\n-                if (file != null) {\n-                    certificateDate = findCertificateDate(\n-                            file.toFile().getCanonicalPath());\n-                }\n-            } finally {\n-                if (file != null) {\n-                    Files.deleteIfExists(file);\n-                }\n-            }\n-\n-            if (certificateDate != null) {\n-                Calendar c = Calendar.getInstance();\n-                Date today = c.getTime();\n-\n-                if (certificateDate.after(today)) {\n-                    result = true;\n-                }\n-            }\n-        }\n-        catch (IOException ignored) {}\n-\n-        return result;\n-    }\n-}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacCertificate.java","additions":0,"deletions":335,"binary":false,"changes":335,"status":"deleted"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.io.BufferedInputStream;\n+import java.io.ByteArrayInputStream;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateFactory;\n+import java.security.cert.X509Certificate;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+public final class MacCertificateUtils {\n+\n+    public static Collection<X509Certificate> findCertificates(Optional<Keychain> keychain, Optional<String> certificateNameFilter) {\n+        List<String> args = new ArrayList<>();\n+        args.add(\"\/usr\/bin\/security\");\n+        args.add(\"find-certificate\");\n+        args.add(\"-a\");\n+        certificateNameFilter.ifPresent(filter -> args.addAll(List.of(\"-c\", filter)));\n+        args.add(\"-p\"); \/\/ PEM format\n+        keychain.map(Keychain::asCliArg).ifPresent(args::add);\n+\n+        return toSupplier(() -> {\n+            final var output = Executor.of(args.toArray(String[]::new))\n+                    .setQuiet(true).saveOutput(true).executeExpectSuccess()\n+                    .getOutput();\n+\n+            final byte[] pemCertificatesBuffer = output.stream()\n+                    .reduce(new StringBuilder(),\n+                            MacCertificateUtils::append,\n+                            MacCertificateUtils::append).toString().getBytes(StandardCharsets.US_ASCII);\n+\n+            final var cf = CertificateFactory.getInstance(\"X.509\");\n+\n+            Collection<X509Certificate> certs = new ArrayList<>();\n+\n+            try (var in = new BufferedInputStream(new ByteArrayInputStream(pemCertificatesBuffer))) {\n+                while (in.available() > 0) {\n+                    final X509Certificate cert;\n+                    try {\n+                        cert = (X509Certificate)cf.generateCertificate(in);\n+                    } catch (CertificateException ex) {\n+                        \/\/ Not a valid X505 certificate, silently ignore.\n+                        continue;\n+                    }\n+                    certs.add(cert);\n+                }\n+            }\n+            return certs;\n+        }).get();\n+    }\n+\n+    record CertificateHash(byte[] value) {\n+        CertificateHash {\n+            Objects.requireNonNull(value);\n+            if (value.length != 20) {\n+                throw new IllegalArgumentException(\"Invalid SHA-1 hash\");\n+            }\n+        }\n+\n+        static CertificateHash of(X509Certificate cert) {\n+            return new CertificateHash(toSupplier(() -> {\n+                final MessageDigest md = MessageDigest.getInstance(\"SHA-1\");\n+                md.update(cert.getEncoded());\n+                return md.digest();\n+            }).get());\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return FORMAT.formatHex(value);\n+        }\n+\n+        static CertificateHash fromHexString(String hash) {\n+            return new CertificateHash(FORMAT.parseHex(hash));\n+        }\n+\n+        private static final HexFormat FORMAT = HexFormat.of().withUpperCase();\n+    }\n+\n+    private static StringBuilder append(StringBuilder sb, Object v) {\n+        return sb.append(v).append('\\n');\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacCertificateUtils.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -28,4 +28,0 @@\n-import java.io.BufferedReader;\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.InputStreamReader;\n@@ -34,4 +30,0 @@\n-import java.text.MessageFormat;\n-import java.util.Base64;\n-import java.util.HashMap;\n-import java.util.List;\n@@ -40,12 +32,0 @@\n-import java.util.ResourceBundle;\n-import static jdk.jpackage.internal.MacAppImageBuilder.ICON_ICNS;\n-import static jdk.jpackage.internal.MacAppImageBuilder.MAC_CF_BUNDLE_IDENTIFIER;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERBOSE;\n-import static jdk.jpackage.internal.StandardBundlerParam.DMG_CONTENT;\n-\n@@ -54,2 +34,0 @@\n-import jdk.jpackage.internal.util.FileUtils;\n-import jdk.jpackage.internal.util.PathGroup;\n@@ -59,477 +37,0 @@\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MacResources\");\n-\n-    \/\/ Background image name in resources\n-    static final String DEFAULT_BACKGROUND_IMAGE = \"background_dmg.tiff\";\n-    \/\/ Background image name and folder under which it will be stored in DMG\n-    static final String BACKGROUND_IMAGE_FOLDER =\".background\";\n-    static final String BACKGROUND_IMAGE = \"background.tiff\";\n-    static final String DEFAULT_DMG_SETUP_SCRIPT = \"DMGsetup.scpt\";\n-    static final String TEMPLATE_BUNDLE_ICON = \"JavaApp.icns\";\n-\n-    static final String DEFAULT_LICENSE_PLIST=\"lic_template.plist\";\n-\n-    public Path bundle(Map<String, ? super Object> params,\n-            Path outdir) throws PackagerException {\n-        Log.verbose(MessageFormat.format(I18N.getString(\"message.building-dmg\"),\n-                APP_NAME.fetchFrom(params)));\n-\n-        IOUtils.writableOutputDir(outdir);\n-\n-        try {\n-            Path appLocation = prepareAppBundle(params);\n-\n-            if (appLocation != null && prepareConfigFiles(appLocation,params)) {\n-                new ScriptRunner()\n-                        .setDirectory(appLocation)\n-                        .setResourceCategoryId(\"resource.post-app-image-script\")\n-                        .setScriptNameSuffix(\"post-image\")\n-                        .setEnvironmentVariable(\"JpAppImageDir\", appLocation.toAbsolutePath().toString())\n-                        .run(params);\n-\n-                return buildDMG(params, appLocation, outdir);\n-            }\n-            return null;\n-        } catch (IOException | PackagerException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n-    }\n-\n-    private static final String hdiutil = \"\/usr\/bin\/hdiutil\";\n-\n-    private void prepareDMGSetupScript(Path appLocation,\n-            Map<String, ? super Object> params) throws IOException {\n-        Path dmgSetup = getConfig_VolumeScript(params);\n-        Log.verbose(MessageFormat.format(\n-                I18N.getString(\"message.preparing-dmg-setup\"),\n-                dmgSetup.toAbsolutePath().toString()));\n-\n-        \/\/ We need to use URL for DMG to find it. We cannot use volume name, since\n-        \/\/ user might have open DMG with same volume name already. Url should end with\n-        \/\/ '\/' and it should be real path (no symbolic links).\n-        Path imageDir = IMAGES_ROOT.fetchFrom(params);\n-        if (!Files.exists(imageDir)) {\n-             \/\/ Create it, since it does not exist\n-             Files.createDirectories(imageDir);\n-        }\n-        Path rootPath = Path.of(imageDir.toString()).toRealPath();\n-        Path volumePath = rootPath.resolve(APP_NAME.fetchFrom(params));\n-        String volumeUrl = volumePath.toUri().toString() + File.separator;\n-\n-        \/\/ Provide full path to background image, so we can find it.\n-        Path bgFile = Path.of(rootPath.toString(), APP_NAME.fetchFrom(params),\n-                              BACKGROUND_IMAGE_FOLDER, BACKGROUND_IMAGE);\n-\n-        \/\/ Prepare DMG setup script\n-        Map<String, String> data = new HashMap<>();\n-        data.put(\"DEPLOY_VOLUME_URL\", volumeUrl);\n-        data.put(\"DEPLOY_BG_FILE\", bgFile.toString());\n-        data.put(\"DEPLOY_VOLUME_PATH\", volumePath.toString());\n-        data.put(\"DEPLOY_APPLICATION_NAME\", APP_NAME.fetchFrom(params));\n-        String targetItem = (StandardBundlerParam.isRuntimeInstaller(params)) ?\n-              APP_NAME.fetchFrom(params) : appLocation.getFileName().toString();\n-        data.put(\"DEPLOY_TARGET\", targetItem);\n-        data.put(\"DEPLOY_INSTALL_LOCATION\", getInstallDir(params, true));\n-        data.put(\"DEPLOY_INSTALL_LOCATION_DISPLAY_NAME\",\n-                getInstallDirDisplayName(params));\n-\n-        createResource(DEFAULT_DMG_SETUP_SCRIPT, params)\n-                .setCategory(I18N.getString(\"resource.dmg-setup-script\"))\n-                .setSubstitutionData(data)\n-                .saveToFile(dmgSetup);\n-    }\n-\n-    private Path getConfig_VolumeScript(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-dmg-setup.scpt\");\n-    }\n-\n-    private Path getConfig_VolumeBackground(\n-            Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-background.tiff\");\n-    }\n-\n-    private Path getConfig_VolumeIcon(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-volume.icns\");\n-    }\n-\n-    private Path getConfig_LicenseFile(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-license.plist\");\n-    }\n-\n-    private void prepareLicense(Map<String, ? super Object> params) {\n-        try {\n-            String licFileStr = LICENSE_FILE.fetchFrom(params);\n-            if (licFileStr == null) {\n-                return;\n-            }\n-\n-            Path licFile = Path.of(licFileStr);\n-            byte[] licenseContentOriginal =\n-                    Files.readAllBytes(licFile);\n-            String licenseInBase64 =\n-                    Base64.getEncoder().encodeToString(licenseContentOriginal);\n-\n-            Map<String, String> data = new HashMap<>();\n-            data.put(\"APPLICATION_LICENSE_TEXT\", licenseInBase64);\n-\n-            createResource(DEFAULT_LICENSE_PLIST, params)\n-                    .setCategory(I18N.getString(\"resource.license-setup\"))\n-                    .setSubstitutionData(data)\n-                    .saveToFile(getConfig_LicenseFile(params));\n-\n-        } catch (IOException ex) {\n-            Log.verbose(ex);\n-        }\n-    }\n-\n-    private boolean prepareConfigFiles(Path appLocation,\n-            Map<String, ? super Object> params) throws IOException {\n-\n-        createResource(DEFAULT_BACKGROUND_IMAGE, params)\n-                    .setCategory(I18N.getString(\"resource.dmg-background\"))\n-                    .saveToFile(getConfig_VolumeBackground(params));\n-\n-        createResource(TEMPLATE_BUNDLE_ICON, params)\n-                .setCategory(I18N.getString(\"resource.volume-icon\"))\n-                .setExternal(ICON_ICNS.fetchFrom(params))\n-                .saveToFile(getConfig_VolumeIcon(params));\n-\n-        prepareLicense(params);\n-\n-        prepareDMGSetupScript(appLocation, params);\n-\n-        return true;\n-    }\n-\n-    \/\/ Location of SetFile utility may be different depending on MacOS version\n-    \/\/ We look for several known places and if none of them work will\n-    \/\/ try ot find it\n-    private String findSetFileUtility() {\n-        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n-                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n-\n-        String setFilePath = null;\n-        for (String path : typicalPaths) {\n-            Path f = Path.of(path);\n-            if (Files.exists(f) && Files.isExecutable(f)) {\n-                setFilePath = path;\n-                break;\n-            }\n-        }\n-\n-        \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n-        \/\/ code\n-        if (setFilePath != null) {\n-            try {\n-                ProcessBuilder pb = new ProcessBuilder(setFilePath, \"-h\");\n-                Process p = pb.start();\n-                int code = p.waitFor();\n-                if (code == 0) {\n-                    return setFilePath;\n-                }\n-            } catch (Exception ignored) {}\n-\n-            \/\/ No need for generic find attempt. We found it, but it does not work.\n-            \/\/ Probably due to missing xcode.\n-            return null;\n-        }\n-\n-        \/\/ generic find attempt\n-        try {\n-            ProcessBuilder pb = new ProcessBuilder(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n-            Process p = pb.start();\n-            InputStreamReader isr = new InputStreamReader(p.getInputStream());\n-            BufferedReader br = new BufferedReader(isr);\n-            String lineRead = br.readLine();\n-            if (lineRead != null) {\n-                Path f = Path.of(lineRead);\n-                if (Files.exists(f) && Files.isExecutable(f)) {\n-                    return f.toAbsolutePath().toString();\n-                }\n-            }\n-        } catch (IOException ignored) {}\n-\n-        return null;\n-    }\n-\n-    private Path buildDMG( Map<String, ? super Object> params,\n-            Path appLocation, Path outdir) throws IOException {\n-        boolean copyAppImage = false;\n-        Path imagesRoot = IMAGES_ROOT.fetchFrom(params);\n-        if (!Files.exists(imagesRoot)) {\n-            Files.createDirectories(imagesRoot);\n-        }\n-\n-        Path protoDMG = imagesRoot.resolve(APP_NAME.fetchFrom(params)\n-                + \"-tmp.dmg\");\n-        Path finalDMG = outdir.resolve(MAC_INSTALLER_NAME.fetchFrom(params)\n-                + \".dmg\");\n-\n-        Path srcFolder = appLocation.getParent();\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            Path newRoot = Files.createTempDirectory(TEMP_ROOT.fetchFrom(params),\n-                    \"root-\");\n-\n-            \/\/ first, is this already a runtime with\n-            \/\/ <runtime>\/Contents\/Home - if so we need the Home dir\n-            Path home = appLocation.resolve(\"Contents\/Home\");\n-            Path source = (Files.exists(home)) ? home : appLocation;\n-\n-            \/\/ Then we need to put back the <NAME>\/Content\/Home\n-            Path root = newRoot.resolve(\n-                    MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));\n-            Path dest = root.resolve(\"Contents\/Home\");\n-\n-            FileUtils.copyRecursive(source, dest);\n-\n-            srcFolder = newRoot;\n-        }\n-\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.creating-dmg-file\"), finalDMG.toAbsolutePath()));\n-\n-        Files.deleteIfExists(protoDMG);\n-        try {\n-            Files.deleteIfExists(finalDMG);\n-        } catch (IOException ex) {\n-            throw new IOException(MessageFormat.format(I18N.getString(\n-                    \"message.dmg-cannot-be-overwritten\"),\n-                    finalDMG.toAbsolutePath()));\n-        }\n-\n-        Files.createDirectories(protoDMG.getParent());\n-        Files.createDirectories(finalDMG.getParent());\n-\n-        String hdiUtilVerbosityFlag = VERBOSE.fetchFrom(params) ?\n-                \"-verbose\" : \"-quiet\";\n-        List <String> dmgContent = DMG_CONTENT.fetchFrom(params);\n-        for (String content : dmgContent) {\n-            Path path = Path.of(content);\n-            FileUtils.copyRecursive(path, srcFolder.resolve(path.getFileName()));\n-        }\n-        \/\/ create temp image\n-        ProcessBuilder pb = new ProcessBuilder(\n-                hdiutil,\n-                \"create\",\n-                hdiUtilVerbosityFlag,\n-                \"-srcfolder\", srcFolder.toAbsolutePath().toString(),\n-                \"-volname\", APP_NAME.fetchFrom(params),\n-                \"-ov\", protoDMG.toAbsolutePath().toString(),\n-                \"-fs\", \"HFS+\",\n-                \"-format\", \"UDRW\");\n-        try {\n-            IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-        } catch (IOException ex) {\n-            Log.verbose(ex); \/\/ Log exception\n-\n-            \/\/ Creating DMG from entire app image failed, so lets try to create empty\n-            \/\/ DMG and copy files manually. See JDK-8248059.\n-            copyAppImage = true;\n-\n-            long size = new PathGroup(Map.of(new Object(), srcFolder)).sizeInBytes();\n-            size += 50 * 1024 * 1024; \/\/ Add extra 50 megabytes. Actually DMG size will\n-            \/\/ not be bigger, but it will able to hold additional 50 megabytes of data.\n-            \/\/ We need extra room for icons and background image. When we providing\n-            \/\/ actual files to hdiutil, it will create DMG with ~50 megabytes extra room.\n-            pb = new ProcessBuilder(\n-                hdiutil,\n-                \"create\",\n-                hdiUtilVerbosityFlag,\n-                \"-size\", String.valueOf(size),\n-                \"-volname\", APP_NAME.fetchFrom(params),\n-                \"-ov\", protoDMG.toAbsolutePath().toString(),\n-                \"-fs\", \"HFS+\");\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .setWriteOutputToFile(true)\n-                .execute(pb);\n-        }\n-\n-        \/\/ mount temp image\n-        pb = new ProcessBuilder(\n-                hdiutil,\n-                \"attach\",\n-                protoDMG.toAbsolutePath().toString(),\n-                hdiUtilVerbosityFlag,\n-                \"-mountroot\", imagesRoot.toAbsolutePath().toString());\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-\n-        Path mountedRoot = imagesRoot.resolve(APP_NAME.fetchFrom(params));\n-\n-        \/\/ Copy app image, since we did not create DMG with it, but instead we created\n-        \/\/ empty one.\n-        if (copyAppImage) {\n-            \/\/ In case of predefine app image srcFolder will point to app bundle, so if\n-            \/\/ we use it as is we will copy content of app bundle, but we need app bundle\n-            \/\/ folder as well.\n-            if (srcFolder.toString().toLowerCase().endsWith(\".app\")) {\n-                Path destPath = mountedRoot\n-                        .resolve(srcFolder.getFileName());\n-                Files.createDirectory(destPath);\n-                FileUtils.copyRecursive(srcFolder, destPath);\n-            } else {\n-                FileUtils.copyRecursive(srcFolder, mountedRoot);\n-            }\n-        }\n-\n-        try {\n-            \/\/ background image\n-            Path bgdir = mountedRoot.resolve(BACKGROUND_IMAGE_FOLDER);\n-            Files.createDirectories(bgdir);\n-            IOUtils.copyFile(getConfig_VolumeBackground(params),\n-                    bgdir.resolve(BACKGROUND_IMAGE));\n-\n-            \/\/ We will not consider setting background image and creating link\n-            \/\/ to install-dir in DMG as critical error, since it can fail in\n-            \/\/ headless environment.\n-            try {\n-                pb = new ProcessBuilder(\"\/usr\/bin\/osascript\",\n-                        getConfig_VolumeScript(params).toAbsolutePath().toString());\n-                IOUtils.exec(pb, 180); \/\/ Wait 3 minutes. See JDK-8248248.\n-            } catch (IOException ex) {\n-                Log.verbose(ex);\n-            }\n-\n-            \/\/ volume icon\n-            Path volumeIconFile = mountedRoot.resolve(\".VolumeIcon.icns\");\n-            IOUtils.copyFile(getConfig_VolumeIcon(params),\n-                    volumeIconFile);\n-\n-            \/\/ Indicate that we want a custom icon\n-            \/\/ NB: attributes of the root directory are ignored\n-            \/\/ when creating the volume\n-            \/\/ Therefore we have to do this after we mount image\n-            String setFileUtility = findSetFileUtility();\n-            if (setFileUtility != null) {\n-                \/\/can not find utility => keep going without icon\n-                try {\n-                    volumeIconFile.toFile().setWritable(true);\n-                    \/\/ The \"creator\" attribute on a file is a legacy attribute\n-                    \/\/ but it seems Finder excepts these bytes to be\n-                    \/\/ \"icnC\" for the volume icon\n-                    \/\/ (might not work on Mac 10.13 with old XCode)\n-                    pb = new ProcessBuilder(\n-                            setFileUtility,\n-                            \"-c\", \"icnC\",\n-                            volumeIconFile.toAbsolutePath().toString());\n-                    IOUtils.exec(pb);\n-                    volumeIconFile.toFile().setReadOnly();\n-\n-                    pb = new ProcessBuilder(\n-                            setFileUtility,\n-                            \"-a\", \"C\",\n-                            mountedRoot.toAbsolutePath().toString());\n-                    IOUtils.exec(pb);\n-                } catch (IOException ex) {\n-                    Log.error(ex.getMessage());\n-                    Log.verbose(\"Cannot enable custom icon using SetFile utility\");\n-                }\n-            } else {\n-                Log.verbose(I18N.getString(\"message.setfile.dmg\"));\n-            }\n-\n-        } finally {\n-            \/\/ Detach the temporary image\n-            pb = new ProcessBuilder(\n-                    hdiutil,\n-                    \"detach\",\n-                    hdiUtilVerbosityFlag,\n-                    mountedRoot.toAbsolutePath().toString());\n-            \/\/ \"hdiutil detach\" might not work right away due to resource busy error, so\n-            \/\/ repeat detach several times.\n-            RetryExecutor retryExecutor = new RetryExecutor();\n-            \/\/ Image can get detach even if we got resource busy error, so stop\n-            \/\/ trying to detach it if it is no longer attached.\n-            retryExecutor.setExecutorInitializer(exec -> {\n-                if (!Files.exists(mountedRoot)) {\n-                    retryExecutor.abort();\n-                }\n-            });\n-            try {\n-                \/\/ 10 times with 6 second delays.\n-                retryExecutor.setMaxAttemptsCount(10).setAttemptTimeoutMillis(6000)\n-                        .execute(pb);\n-            } catch (IOException ex) {\n-                if (!retryExecutor.isAborted()) {\n-                    \/\/ Now force to detach if it still attached\n-                    if (Files.exists(mountedRoot)) {\n-                        pb = new ProcessBuilder(\n-                                hdiutil,\n-                                \"detach\",\n-                                \"-force\",\n-                                hdiUtilVerbosityFlag,\n-                                mountedRoot.toAbsolutePath().toString());\n-                        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Compress it to a new image\n-        pb = new ProcessBuilder(\n-                hdiutil,\n-                \"convert\",\n-                protoDMG.toAbsolutePath().toString(),\n-                hdiUtilVerbosityFlag,\n-                \"-format\", \"UDZO\",\n-                \"-o\", finalDMG.toAbsolutePath().toString());\n-        try {\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .execute(pb);\n-        } catch (Exception ex) {\n-            \/\/ Convert might failed if something holds file. Try to convert copy.\n-            Path protoDMG2 = imagesRoot\n-                    .resolve(APP_NAME.fetchFrom(params) + \"-tmp2.dmg\");\n-            Files.copy(protoDMG, protoDMG2);\n-            try {\n-                pb = new ProcessBuilder(\n-                        hdiutil,\n-                        \"convert\",\n-                        protoDMG2.toAbsolutePath().toString(),\n-                        hdiUtilVerbosityFlag,\n-                        \"-format\", \"UDZO\",\n-                        \"-o\", finalDMG.toAbsolutePath().toString());\n-                IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-            } finally {\n-                Files.deleteIfExists(protoDMG2);\n-            }\n-        }\n-\n-        \/\/add license if needed\n-        if (Files.exists(getConfig_LicenseFile(params))) {\n-            pb = new ProcessBuilder(\n-                    hdiutil,\n-                    \"udifrez\",\n-                    finalDMG.toAbsolutePath().toString(),\n-                    \"-xml\",\n-                    getConfig_LicenseFile(params).toAbsolutePath().toString()\n-            );\n-            new RetryExecutor()\n-                .setMaxAttemptsCount(10)\n-                .setAttemptTimeoutMillis(3000)\n-                .execute(pb);\n-        }\n-\n-        \/\/Delete the temporary image\n-        Files.deleteIfExists(protoDMG);\n-\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.output-to-location\"),\n-                APP_NAME.fetchFrom(params), finalDMG.toAbsolutePath().toString()));\n-\n-        return finalDMG;\n-    }\n-\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/ Implement Bundler\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -552,0 +53,2 @@\n+            MacFromParams.DMG_PACKAGE.fetchFrom(params);\n+\n@@ -569,1 +72,9 @@\n-        return bundle(params, outputParentDir);\n+\n+        final var pkg = MacFromParams.DMG_PACKAGE.fetchFrom(params);\n+        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+\n+        final var packager = MacDmgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+\n+        MacDmgPackager.findSetFileUtility().ifPresent(packager::setFileUtility);\n+\n+        return packager.execute();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgBundler.java","additions":11,"deletions":500,"binary":false,"changes":511,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.MacDmgPackage;\n+import jdk.jpackage.internal.model.MacDmgPackageMixin;\n+\n+final class MacDmgPackageBuilder {\n+\n+    MacDmgPackageBuilder(MacPackageBuilder pkgBuilder) {\n+        this.pkgBuilder = Objects.requireNonNull(pkgBuilder);\n+    }\n+\n+    MacDmgPackageBuilder dmgContent(List<Path> v) {\n+        dmgContent = v;\n+        return this;\n+    }\n+\n+    MacDmgPackageBuilder icon(Path v) {\n+        icon = v;\n+        return this;\n+    }\n+\n+    List<Path> validatedDmgContent() {\n+        return Optional.ofNullable(dmgContent).orElseGet(List::of);\n+    }\n+\n+    MacDmgPackage create() throws ConfigException {\n+        final var superPkgBuilder = pkgBuilder.pkgBuilder();\n+        superPkgBuilder.installDir().ifPresent(installDir -> {\n+            final var defaultInstallDirLocation = superPkgBuilder.defaultInstallDir().map(Path::getParent).orElseThrow();\n+            if (!defaultInstallDirLocation.equals(installDir)) {\n+                Log.info(I18N.format(\"message.install-dir-ignored\", defaultInstallDirLocation));\n+                superPkgBuilder.installDir(defaultInstallDirLocation);\n+            }\n+        });\n+\n+        final var pkg = pkgBuilder.create();\n+\n+        return MacDmgPackage.create(pkg, new MacDmgPackageMixin.Stub(\n+                Optional.ofNullable(icon).or((pkg.app())::icon),\n+                validatedDmgContent()));\n+    }\n+\n+    private Path icon;\n+    private List<Path> dmgContent;\n+    private final MacPackageBuilder pkgBuilder;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackageBuilder.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,530 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.PathUtils.normalizedAbsolutePathString;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.MacDmgPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.util.FileUtils;\n+import jdk.jpackage.internal.util.PathGroup;\n+\n+record MacDmgPackager(MacDmgPackage pkg, BuildEnv env, Path hdiutil, Path outputDir, Optional<Path> setFileUtility) {\n+\n+    MacDmgPackager {\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(hdiutil);\n+        Objects.requireNonNull(outputDir);\n+        Objects.requireNonNull(setFileUtility);\n+    }\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    static final class Builder extends PackagerBuilder<MacDmgPackage, Builder> {\n+\n+        Builder hdiutil(Path v) {\n+            hdiutil = v;\n+            return this;\n+        }\n+\n+        Builder setFileUtility(Path v) {\n+            setFileUtility = v;\n+            return this;\n+        }\n+\n+        Path execute() throws PackagerException {\n+            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-dmg\"),\n+                    pkg.app().name()));\n+\n+            IOUtils.writableOutputDir(outputDir);\n+\n+            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n+        }\n+\n+        @Override\n+        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n+                StartupParameters startupParameters) {\n+            final var packager = new MacDmgPackager(pkg, startupParameters.packagingEnv(),\n+                    validatedHdiutil(), outputDir, Optional.ofNullable(setFileUtility));\n+            packager.applyToPipeline(pipelineBuilder);\n+        }\n+\n+        private Path validatedHdiutil() {\n+            return Optional.ofNullable(hdiutil).orElse(HDIUTIL);\n+        }\n+\n+        private Path hdiutil;\n+        private Path setFileUtility;\n+    }\n+\n+    \/\/ Location of SetFile utility may be different depending on MacOS version\n+    \/\/ We look for several known places and if none of them work will\n+    \/\/ try to find it\n+    static Optional<Path> findSetFileUtility() {\n+        String typicalPaths[] = {\"\/Developer\/Tools\/SetFile\",\n+                \"\/usr\/bin\/SetFile\", \"\/Developer\/usr\/bin\/SetFile\"};\n+\n+        final var setFilePath = Stream.of(typicalPaths).map(Path::of).filter(Files::isExecutable).findFirst();\n+        if (setFilePath.isPresent()) {\n+            \/\/ Validate SetFile, if Xcode is not installed it will run, but exit with error\n+            \/\/ code\n+            try {\n+                if (Executor.of(setFilePath.orElseThrow().toString(), \"-h\").setQuiet(true).execute() == 0) {\n+                    return setFilePath;\n+                }\n+            } catch (Exception ignored) {\n+                \/\/ No need for generic find attempt. We found it, but it does not work.\n+                \/\/ Probably due to missing xcode.\n+                return Optional.empty();\n+            }\n+        }\n+\n+        \/\/ generic find attempt\n+        try {\n+            final var executor = Executor.of(\"\/usr\/bin\/xcrun\", \"-find\", \"SetFile\");\n+            final var code = executor.setQuiet(true).saveOutput(true).execute();\n+            if (code == 0 && executor.getOutput().isEmpty()) {\n+                final var firstLine = executor.getOutput().getFirst();\n+                Path f = Path.of(firstLine);\n+                if (Files.exists(f) && Files.isExecutable(f)) {\n+                    return Optional.of(f.toAbsolutePath());\n+                }\n+            }\n+        } catch (IOException ignored) {}\n+\n+        return Optional.empty();\n+    }\n+\n+    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder\n+                .excludeDirFromCopying(outputDir)\n+                .task(DmgPackageTaskID.COPY_DMG_CONTENT)\n+                        .action(this::copyDmgContent)\n+                        .addDependent(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .add()\n+                .task(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::prepareConfigFiles)\n+                        .add()\n+                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::buildDMG)\n+                        .add();\n+    }\n+\n+    enum DmgPackageTaskID implements TaskID {\n+        COPY_DMG_CONTENT\n+    }\n+\n+    Path volumePath() {\n+        return dmgWorkdir().resolve(volumeName());\n+    }\n+\n+    String volumeName() {\n+        return pkg.app().name();\n+    }\n+\n+    String createVolumeUrlLocation() throws IOException {\n+        final var volumeParentDir = volumePath().getParent();\n+        Files.createDirectories(volumeParentDir);\n+        \/\/ The URL should end with '\/' and it should be real path (no symbolic links).\n+        return volumeParentDir.toRealPath().resolve(volumePath().getFileName()).toUri().toString() + File.separator;\n+    }\n+\n+    Path volumeScript() {\n+        return env.configDir().resolve(pkg.app().name() + \"-dmg-setup.scpt\");\n+    }\n+\n+    Path volumeBackground() {\n+        return env.configDir().resolve(pkg.app().name() + \"-background.tiff\");\n+    }\n+\n+    Path volumeIcon() {\n+        return env.configDir().resolve(pkg.app().name() + \"-volume.icns\");\n+    }\n+\n+    Path licenseFile() {\n+        return env.configDir().resolve(pkg.app().name() + \"-license.plist\");\n+    }\n+\n+    Path protoDmg() {\n+        return dmgWorkdir().resolve(\"proto.dmg\");\n+    }\n+\n+    Path protoCopyDmg() {\n+        return dmgWorkdir().resolve(\"proto-copy.dmg\");\n+    }\n+\n+    Path bgImageFileInMountedDmg() {\n+        return volumePath().resolve(\".background\/background.tiff\");\n+    }\n+\n+    private Path dmgWorkdir() {\n+        return env.buildRoot().resolve(\"dmg-workdir\");\n+    }\n+\n+    private void copyDmgContent() throws IOException {\n+        final var srcFolder = env.appImageDir();\n+        for (Path path : pkg.content()) {\n+            FileUtils.copyRecursive(path, srcFolder.resolve(path.getFileName()));\n+        }\n+    }\n+\n+    private void prepareDMGSetupScript() throws IOException {\n+        Path dmgSetup = volumeScript();\n+        Log.verbose(MessageFormat.format(\n+                I18N.getString(\"message.preparing-dmg-setup\"),\n+                dmgSetup.toAbsolutePath().toString()));\n+\n+        \/\/ Prepare DMG setup script\n+        Map<String, String> data = new HashMap<>();\n+\n+        \/\/ We need to use URL for DMG to find it. We cannot use volume name, since\n+        \/\/ user might have open DMG with same volume name already.\n+        data.put(\"DEPLOY_VOLUME_URL\", createVolumeUrlLocation());\n+\n+        \/\/ Full path to background image, so we can find it.\n+        data.put(\"DEPLOY_BG_FILE\", bgImageFileInMountedDmg().toAbsolutePath().toString());\n+\n+        data.put(\"DEPLOY_VOLUME_PATH\", volumePath().toAbsolutePath().toString());\n+        data.put(\"DEPLOY_APPLICATION_NAME\", pkg.app().name());\n+\n+        String targetItem = pkg.relativeInstallDir().getFileName().toString();\n+        data.put(\"DEPLOY_TARGET\", targetItem);\n+\n+        data.put(\"DEPLOY_INSTALL_LOCATION\", pkg.installDir().getParent().toString());\n+\n+        \/\/ \"DEPLOY_INSTALL_LOCATION_DISPLAY_NAME\" is the label for the default destination directory\n+        \/\/ for DMG bundle on the right side from the \"copy\" arrow in the dialog\n+        \/\/ that pops up when user clicks on a .dmg file.\n+        data.put(\"DEPLOY_INSTALL_LOCATION_DISPLAY_NAME\", getInstallDirDisplayName());\n+\n+        env.createResource(DEFAULT_DMG_SETUP_SCRIPT)\n+                .setCategory(I18N.getString(\"resource.dmg-setup-script\"))\n+                .setSubstitutionData(data)\n+                .saveToFile(dmgSetup);\n+    }\n+\n+    private void prepareLicense() throws IOException {\n+        final var licFile = pkg.licenseFile();\n+        if (licFile.isEmpty()) {\n+            return;\n+        }\n+\n+        byte[] licenseContentOriginal =\n+                Files.readAllBytes(licFile.orElseThrow());\n+        String licenseInBase64 =\n+                Base64.getEncoder().encodeToString(licenseContentOriginal);\n+\n+        Map<String, String> data = new HashMap<>();\n+        data.put(\"APPLICATION_LICENSE_TEXT\", licenseInBase64);\n+\n+        env.createResource(DEFAULT_LICENSE_PLIST)\n+                .setCategory(I18N.getString(\"resource.license-setup\"))\n+                .setSubstitutionData(data)\n+                .saveToFile(licenseFile());\n+    }\n+\n+    private void prepareConfigFiles() throws IOException {\n+\n+        env.createResource(DEFAULT_BACKGROUND_IMAGE)\n+                    .setCategory(I18N.getString(\"resource.dmg-background\"))\n+                    .saveToFile(volumeBackground());\n+\n+        env.createResource(TEMPLATE_BUNDLE_ICON)\n+                .setCategory(I18N.getString(\"resource.volume-icon\"))\n+                .setExternal(pkg.icon().orElse(null))\n+                .saveToFile(volumeIcon());\n+\n+        prepareLicense();\n+\n+        prepareDMGSetupScript();\n+    }\n+\n+    private String getInstallDirDisplayName() {\n+        final var defaultInstallDir = new PackageBuilder(pkg.app(), pkg.type()).defaultInstallDir().orElseThrow();\n+        if (defaultInstallDir.equals(pkg.installDir())) {\n+            \/\/ Return \"Applications\" for \"\/Applications\/foo.app\"\n+            return defaultInstallDir.getParent().getFileName().toString();\n+        } else {\n+            return pkg.installDir().getParent().toString();\n+        }\n+    }\n+\n+    private void buildDMG() throws IOException {\n+        boolean copyAppImage = false;\n+\n+        Path protoDMG = protoDmg();\n+        Path finalDMG = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+\n+        Path srcFolder = env.appImageDir();\n+\n+        Log.verbose(MessageFormat.format(I18N.getString(\n+                \"message.creating-dmg-file\"), finalDMG.toAbsolutePath()));\n+\n+        try {\n+            Files.deleteIfExists(finalDMG);\n+        } catch (IOException ex) {\n+            throw new IOException(MessageFormat.format(I18N.getString(\n+                    \"message.dmg-cannot-be-overwritten\"),\n+                    finalDMG.toAbsolutePath()));\n+        }\n+\n+        Files.createDirectories(protoDMG.getParent());\n+        Files.createDirectories(finalDMG.getParent());\n+\n+        String hdiUtilVerbosityFlag = env.verbose() ?\n+                \"-verbose\" : \"-quiet\";\n+\n+        \/\/ create temp image\n+        ProcessBuilder pb = new ProcessBuilder(\n+                hdiutil.toString(),\n+                \"create\",\n+                hdiUtilVerbosityFlag,\n+                \"-srcfolder\", normalizedAbsolutePathString(srcFolder),\n+                \"-volname\", volumeName(),\n+                \"-ov\", normalizedAbsolutePathString(protoDMG),\n+                \"-fs\", \"HFS+\",\n+                \"-format\", \"UDRW\");\n+        try {\n+            IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+        } catch (IOException ex) {\n+            Log.verbose(ex); \/\/ Log exception\n+\n+            \/\/ Creating DMG from entire app image failed, so lets try to create empty\n+            \/\/ DMG and copy files manually. See JDK-8248059.\n+            copyAppImage = true;\n+\n+            long size = new PathGroup(Map.of(new Object(), srcFolder)).sizeInBytes();\n+            size += 50 * 1024 * 1024; \/\/ Add extra 50 megabytes. Actually DMG size will\n+            \/\/ not be bigger, but it will able to hold additional 50 megabytes of data.\n+            \/\/ We need extra room for icons and background image. When we providing\n+            \/\/ actual files to hdiutil, it will create DMG with ~50 megabytes extra room.\n+            pb = new ProcessBuilder(\n+                hdiutil.toString(),\n+                \"create\",\n+                hdiUtilVerbosityFlag,\n+                \"-size\", String.valueOf(size),\n+                \"-volname\", volumeName(),\n+                \"-ov\", normalizedAbsolutePathString(protoDMG),\n+                \"-fs\", \"HFS+\");\n+            new RetryExecutor()\n+                .setMaxAttemptsCount(10)\n+                .setAttemptTimeoutMillis(3000)\n+                .setWriteOutputToFile(true)\n+                .execute(pb);\n+        }\n+\n+        \/\/ mount temp image\n+        pb = new ProcessBuilder(\n+                hdiutil.toString(),\n+                \"attach\",\n+                normalizedAbsolutePathString(protoDMG),\n+                hdiUtilVerbosityFlag,\n+                \"-mountroot\", protoDMG.getParent().toString());\n+        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+\n+        final Path mountedVolume = volumePath();\n+\n+        \/\/ Copy app image, since we did not create DMG with it, but instead we created\n+        \/\/ empty one.\n+        if (copyAppImage) {\n+            FileUtils.copyRecursive(srcFolder, mountedVolume);\n+        }\n+\n+        try {\n+            \/\/ background image\n+            final var bgImageFile = bgImageFileInMountedDmg();\n+            Files.createDirectories(bgImageFile.getParent());\n+            IOUtils.copyFile(volumeBackground(), bgImageFile);\n+\n+            \/\/ We will not consider setting background image and creating link\n+            \/\/ to install-dir in DMG as critical error, since it can fail in\n+            \/\/ headless environment.\n+            try {\n+                pb = new ProcessBuilder(\"\/usr\/bin\/osascript\",\n+                        normalizedAbsolutePathString(volumeScript()));\n+                IOUtils.exec(pb, 180); \/\/ Wait 3 minutes. See JDK-8248248.\n+            } catch (IOException ex) {\n+                Log.verbose(ex);\n+            }\n+\n+            \/\/ volume icon\n+            Path volumeIconFile = mountedVolume.resolve(\".VolumeIcon.icns\");\n+            IOUtils.copyFile(volumeIcon(), volumeIconFile);\n+\n+            \/\/ Indicate that we want a custom icon\n+            \/\/ NB: attributes of the root directory are ignored\n+            \/\/ when creating the volume\n+            \/\/ Therefore we have to do this after we mount image\n+            if (setFileUtility.isPresent()) {\n+                \/\/can not find utility => keep going without icon\n+                try {\n+                    volumeIconFile.toFile().setWritable(true);\n+                    \/\/ The \"creator\" attribute on a file is a legacy attribute\n+                    \/\/ but it seems Finder excepts these bytes to be\n+                    \/\/ \"icnC\" for the volume icon\n+                    \/\/ (might not work on Mac 10.13 with old XCode)\n+                    pb = new ProcessBuilder(\n+                            setFileUtility.orElseThrow().toString(),\n+                            \"-c\", \"icnC\",\n+                            normalizedAbsolutePathString(volumeIconFile));\n+                    IOUtils.exec(pb);\n+                    volumeIconFile.toFile().setReadOnly();\n+\n+                    pb = new ProcessBuilder(\n+                            setFileUtility.orElseThrow().toString(),\n+                            \"-a\", \"C\",\n+                            normalizedAbsolutePathString(mountedVolume));\n+                    IOUtils.exec(pb);\n+                } catch (IOException ex) {\n+                    Log.error(ex.getMessage());\n+                    Log.verbose(\"Cannot enable custom icon using SetFile utility\");\n+                }\n+            } else {\n+                Log.verbose(I18N.getString(\"message.setfile.dmg\"));\n+            }\n+\n+        } finally {\n+            \/\/ Detach the temporary image\n+            pb = new ProcessBuilder(\n+                    hdiutil.toString(),\n+                    \"detach\",\n+                    hdiUtilVerbosityFlag,\n+                    normalizedAbsolutePathString(mountedVolume));\n+            \/\/ \"hdiutil detach\" might not work right away due to resource busy error, so\n+            \/\/ repeat detach several times.\n+            RetryExecutor retryExecutor = new RetryExecutor();\n+            \/\/ Image can get detach even if we got resource busy error, so stop\n+            \/\/ trying to detach it if it is no longer attached.\n+            retryExecutor.setExecutorInitializer(exec -> {\n+                if (!Files.exists(mountedVolume)) {\n+                    retryExecutor.abort();\n+                }\n+            });\n+            try {\n+                \/\/ 10 times with 6 second delays.\n+                retryExecutor.setMaxAttemptsCount(10).setAttemptTimeoutMillis(6000)\n+                        .execute(pb);\n+            } catch (IOException ex) {\n+                if (!retryExecutor.isAborted()) {\n+                    \/\/ Now force to detach if it still attached\n+                    if (Files.exists(mountedVolume)) {\n+                        pb = new ProcessBuilder(\n+                                hdiutil.toString(),\n+                                \"detach\",\n+                                \"-force\",\n+                                hdiUtilVerbosityFlag,\n+                                normalizedAbsolutePathString(mountedVolume));\n+                        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ Compress it to a new image\n+        pb = new ProcessBuilder(\n+                hdiutil.toString(),\n+                \"convert\",\n+                normalizedAbsolutePathString(protoDMG),\n+                hdiUtilVerbosityFlag,\n+                \"-format\", \"UDZO\",\n+                \"-o\", normalizedAbsolutePathString(finalDMG));\n+        try {\n+            new RetryExecutor()\n+                .setMaxAttemptsCount(10)\n+                .setAttemptTimeoutMillis(3000)\n+                .execute(pb);\n+        } catch (Exception ex) {\n+            \/\/ Convert might failed if something holds file. Try to convert copy.\n+            Path protoCopyDMG = protoCopyDmg();\n+            Files.copy(protoDMG, protoCopyDMG);\n+            try {\n+                pb = new ProcessBuilder(\n+                        hdiutil.toString(),\n+                        \"convert\",\n+                        normalizedAbsolutePathString(protoCopyDMG),\n+                        hdiUtilVerbosityFlag,\n+                        \"-format\", \"UDZO\",\n+                        \"-o\", normalizedAbsolutePathString(finalDMG));\n+                IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+            } finally {\n+                Files.deleteIfExists(protoCopyDMG);\n+            }\n+        }\n+\n+        \/\/add license if needed\n+        if (pkg.licenseFile().isPresent()) {\n+            pb = new ProcessBuilder(\n+                    hdiutil.toString(),\n+                    \"udifrez\",\n+                    normalizedAbsolutePathString(finalDMG),\n+                    \"-xml\",\n+                    normalizedAbsolutePathString(licenseFile())\n+            );\n+            new RetryExecutor()\n+                .setMaxAttemptsCount(10)\n+                .setAttemptTimeoutMillis(3000)\n+                .execute(pb);\n+        }\n+\n+        try {\n+            \/\/Delete the temporary image\n+            Files.deleteIfExists(protoDMG);\n+        } catch (IOException ex) {\n+            \/\/ Don't care if fails\n+        }\n+\n+        Log.verbose(MessageFormat.format(I18N.getString(\n+                \"message.output-to-location\"),\n+                pkg.app().name(), normalizedAbsolutePathString(finalDMG)));\n+\n+    }\n+\n+    \/\/ Background image name in resources\n+    private static final String DEFAULT_BACKGROUND_IMAGE = \"background_dmg.tiff\";\n+    private static final String DEFAULT_DMG_SETUP_SCRIPT = \"DMGsetup.scpt\";\n+    private static final String TEMPLATE_BUNDLE_ICON = \"JavaApp.icns\";\n+\n+    private static final String DEFAULT_LICENSE_PLIST=\"lic_template.plist\";\n+\n+    private static final Path HDIUTIL = Path.of(\"\/usr\/bin\/hdiutil\");\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacDmgPackager.java","additions":530,"deletions":0,"binary":false,"changes":530,"status":"added"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.MacFileAssociation;\n+import jdk.jpackage.internal.model.MacFileAssociationMixin;\n+\n+final class MacFileAssociationBuilder {\n+\n+    MacFileAssociation create(FileAssociation fa) throws ConfigException {\n+        Objects.requireNonNull(fa);\n+\n+        final var mixin = new MacFileAssociationMixin.Stub(\n+                Optional.ofNullable(cfBundleTypeName).orElse(DEFAULTS.cfBundleTypeName),\n+                Optional.ofNullable(cfBundleTypeRole).orElse(DEFAULTS.cfBundleTypeRole),\n+                Optional.ofNullable(lsHandlerRank).orElse(DEFAULTS.lsHandlerRank),\n+                Optional.ofNullable(lsTypeIsPackage),\n+                Optional.ofNullable(nsDocumentClass),\n+                Optional.ofNullable(nsPersistentStoreTypeKey),\n+                Optional.ofNullable(lsSupportsOpeningDocumentsInPlace),\n+                Optional.ofNullable(uiSupportsDocumentBrowser),\n+                Optional.ofNullable(utTypeConformsTo).orElse(DEFAULTS.utTypeConformsTo),\n+                Optional.ofNullable(nsExportableTypes).orElse(DEFAULTS.nsExportableTypes));\n+\n+        return MacFileAssociation.create(fa, mixin);\n+    }\n+\n+    MacFileAssociationBuilder cfBundleTypeName(String v) {\n+        cfBundleTypeName = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder cfBundleTypeRole(String v) {\n+        cfBundleTypeRole = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder lsHandlerRank(String v) {\n+        lsHandlerRank = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder lsTypeIsPackage(boolean v) {\n+        lsTypeIsPackage = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder nsDocumentClass(String v) {\n+        nsDocumentClass = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder nsPersistentStoreTypeKey(String v) {\n+        nsPersistentStoreTypeKey = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder lsSupportsOpeningDocumentsInPlace(boolean v) {\n+        lsSupportsOpeningDocumentsInPlace = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder uiSupportsDocumentBrowser(boolean v) {\n+        uiSupportsDocumentBrowser = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder utTypeConformsTo(List<String> v) {\n+        utTypeConformsTo = v;\n+        return this;\n+    }\n+\n+    MacFileAssociationBuilder nsExportableTypes(List<String> v) {\n+        nsExportableTypes = v;\n+        return this;\n+    }\n+\n+    private String cfBundleTypeName;\n+    private String cfBundleTypeRole;\n+    private String lsHandlerRank;\n+    private String nsDocumentClass;\n+    private String nsPersistentStoreTypeKey;\n+    private Boolean lsTypeIsPackage;\n+    private Boolean lsSupportsOpeningDocumentsInPlace;\n+    private Boolean uiSupportsDocumentBrowser;\n+    private List<String> utTypeConformsTo;\n+    private List<String> nsExportableTypes;\n+\n+    private static final MacFileAssociationBuilder DEFAULTS = new MacFileAssociationBuilder()\n+            .lsHandlerRank(\"Owner\")\n+            .cfBundleTypeRole(\"Editor\")\n+            .cfBundleTypeName(\"\")\n+            .utTypeConformsTo(List.of(\"public.data\"))\n+            .nsExportableTypes(List.of());\n+\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFileAssociationBuilder.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -0,0 +1,364 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.BundlerParamInfo.createBooleanBundlerParam;\n+import static jdk.jpackage.internal.BundlerParamInfo.createPathBundlerParam;\n+import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n+import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n+import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n+import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n+import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n+import static jdk.jpackage.internal.MacPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.StandardBundlerParam.DMG_CONTENT;\n+import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n+import static jdk.jpackage.internal.StandardBundlerParam.hasPredefinedAppImage;\n+import static jdk.jpackage.internal.model.MacPackage.RUNTIME_PACKAGE_LAYOUT;\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_DMG;\n+import static jdk.jpackage.internal.model.StandardPackageType.MAC_PKG;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.function.Predicate;\n+import jdk.jpackage.internal.ApplicationBuilder.MainLauncherStartupInfo;\n+import jdk.jpackage.internal.SigningIdentityBuilder.ExpiredCertificateException;\n+import jdk.jpackage.internal.SigningIdentityBuilder.StandardCertificateSelector;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.MacApplication;\n+import jdk.jpackage.internal.model.MacDmgPackage;\n+import jdk.jpackage.internal.model.MacFileAssociation;\n+import jdk.jpackage.internal.model.MacLauncher;\n+import jdk.jpackage.internal.model.MacPkgPackage;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\n+final class MacFromParams {\n+\n+    private static MacApplication createMacApplication(\n+            Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var predefinedRuntimeLayout = PREDEFINED_RUNTIME_IMAGE.findIn(params).map(predefinedRuntimeImage -> {\n+            if (Files.isDirectory(RUNTIME_PACKAGE_LAYOUT.resolveAt(predefinedRuntimeImage).runtimeDirectory())) {\n+                return RUNTIME_PACKAGE_LAYOUT;\n+            } else {\n+                return RuntimeLayout.DEFAULT;\n+            }\n+        });\n+\n+        final var launcherFromParams = new LauncherFromParams(Optional.of(MacFromParams::createMacFa));\n+\n+        final var superAppBuilder = createApplicationBuilder(params, toFunction(launcherParams -> {\n+            var launcher = launcherFromParams.create(launcherParams);\n+            return MacLauncher.create(launcher);\n+        }), APPLICATION_LAYOUT, predefinedRuntimeLayout);\n+\n+        if (hasPredefinedAppImage(params)) {\n+            \/\/ Set the main launcher start up info.\n+            \/\/ AppImageFile assumes the main launcher start up info is available when\n+            \/\/ it is constructed from Application instance.\n+            \/\/ This happens when jpackage signs predefined app image.\n+            final var mainLauncherStartupInfo = new MainLauncherStartupInfo(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass());\n+            final var launchers = superAppBuilder.launchers().orElseThrow();\n+            final var mainLauncher = ApplicationBuilder.overrideLauncherStartupInfo(launchers.mainLauncher(), mainLauncherStartupInfo);\n+            superAppBuilder.launchers(new ApplicationLaunchers(MacLauncher.create(mainLauncher), launchers.additionalLaunchers()));\n+        }\n+\n+        final var app = superAppBuilder.create();\n+\n+        final var appBuilder = new MacApplicationBuilder(app);\n+\n+        if (hasPredefinedAppImage(params)) {\n+            appBuilder.externalInfoPlistFile(PREDEFINED_APP_IMAGE.findIn(params).orElseThrow().resolve(\"Contents\/Info.plist\"));\n+        }\n+\n+        ICON.copyInto(params, appBuilder::icon);\n+        MAC_CF_BUNDLE_NAME.copyInto(params, appBuilder::bundleName);\n+        MAC_CF_BUNDLE_IDENTIFIER.copyInto(params, appBuilder::bundleIdentifier);\n+        APP_CATEGORY.copyInto(params, appBuilder::category);\n+\n+        final boolean sign;\n+        final boolean appStore;\n+\n+        if (hasPredefinedAppImage(params) && PACKAGE_TYPE.findIn(params).filter(Predicate.isEqual(\"app-image\")).isEmpty()) {\n+            final var appImageFileExtras = new MacAppImageFileExtras(PREDEFINED_APP_IMAGE_FILE.fetchFrom(params));\n+            sign = appImageFileExtras.signed();\n+            appStore = appImageFileExtras.appStore();\n+        } else {\n+            sign = SIGN_BUNDLE.findIn(params).orElse(false);\n+            appStore = APP_STORE.findIn(params).orElse(false);\n+        }\n+\n+        appBuilder.appStore(appStore);\n+\n+        if (sign) {\n+            final var signingIdentityBuilder = createSigningIdentityBuilder(params);\n+            APP_IMAGE_SIGN_IDENTITY.copyInto(params, signingIdentityBuilder::signingIdentity);\n+            SIGNING_KEY_USER.findIn(params).ifPresent(userName -> {\n+                final StandardCertificateSelector domain;\n+                if (appStore) {\n+                    domain = StandardCertificateSelector.APP_STORE_APP_IMAGE;\n+                } else {\n+                    domain = StandardCertificateSelector.APP_IMAGE;\n+                }\n+\n+                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n+            });\n+\n+            final var signingBuilder = new AppImageSigningConfigBuilder(signingIdentityBuilder);\n+            if (appStore) {\n+                signingBuilder.entitlementsResourceName(\"sandbox.plist\");\n+            }\n+\n+            app.mainLauncher().flatMap(Launcher::startupInfo).ifPresent(signingBuilder::signingIdentifierPrefix);\n+            SIGN_IDENTIFIER_PREFIX.copyInto(params, signingBuilder::signingIdentifierPrefix);\n+\n+            ENTITLEMENTS.copyInto(params, signingBuilder::entitlements);\n+\n+            appBuilder.signingBuilder(signingBuilder);\n+        }\n+\n+        return appBuilder.create();\n+    }\n+\n+    private static MacPackageBuilder createMacPackageBuilder(\n+            Map<String, ? super Object> params, MacApplication app,\n+            PackageType type) throws ConfigException {\n+        final var builder = new MacPackageBuilder(createPackageBuilder(params, app, type));\n+\n+        PREDEFINED_APP_IMAGE_FILE.findIn(params)\n+                .map(MacAppImageFileExtras::new)\n+                .map(MacAppImageFileExtras::signed)\n+                .ifPresent(builder::predefinedAppImageSigned);\n+\n+        return builder;\n+    }\n+\n+    private static MacDmgPackage createMacDmgPackage(\n+            Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var app = APPLICATION.fetchFrom(params);\n+\n+        final var superPkgBuilder = createMacPackageBuilder(params, app, MAC_DMG);\n+\n+        final var pkgBuilder = new MacDmgPackageBuilder(superPkgBuilder);\n+\n+        DMG_CONTENT.copyInto(params, pkgBuilder::dmgContent);\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    private record WithExpiredCertificateException<T>(Optional<T> obj, Optional<ExpiredCertificateException> certEx) {\n+        WithExpiredCertificateException {\n+            if (obj.isEmpty() == certEx.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        static <U> WithExpiredCertificateException<U> of(Callable<U> callable) {\n+            try {\n+                return new WithExpiredCertificateException<>(Optional.of(callable.call()), Optional.empty());\n+            } catch (ExpiredCertificateException ex) {\n+                return new WithExpiredCertificateException<>(Optional.empty(), Optional.of(ex));\n+            } catch (ExceptionBox ex) {\n+                if (ex.getCause() instanceof ExpiredCertificateException certEx) {\n+                    return new WithExpiredCertificateException<>(Optional.empty(), Optional.of(certEx));\n+                }\n+                throw ex;\n+            } catch (RuntimeException ex) {\n+                throw ex;\n+            } catch (Throwable t) {\n+                throw ExceptionBox.rethrowUnchecked(t);\n+            }\n+        }\n+    }\n+\n+    private static MacPkgPackage createMacPkgPackage(\n+            Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        \/\/ This is over complicated to make \"MacSignTest.testExpiredCertificate\" test pass.\n+\n+        final boolean sign = SIGN_BUNDLE.findIn(params).orElse(false);\n+        final boolean appStore = APP_STORE.findIn(params).orElse(false);\n+\n+        final var appOrExpiredCertEx = WithExpiredCertificateException.of(() -> {\n+            return APPLICATION.fetchFrom(params);\n+        });\n+\n+        final Optional<MacPkgPackageBuilder> pkgBuilder;\n+        if (appOrExpiredCertEx.obj().isPresent()) {\n+            final var superPkgBuilder = createMacPackageBuilder(params, appOrExpiredCertEx.obj().orElseThrow(), MAC_PKG);\n+            pkgBuilder = Optional.of(new MacPkgPackageBuilder(superPkgBuilder));\n+        } else {\n+            pkgBuilder = Optional.empty();\n+        }\n+\n+        if (sign) {\n+            final var signingIdentityBuilder = createSigningIdentityBuilder(params);\n+            INSTALLER_SIGN_IDENTITY.copyInto(params, signingIdentityBuilder::signingIdentity);\n+            SIGNING_KEY_USER.findIn(params).ifPresent(userName -> {\n+                final StandardCertificateSelector domain;\n+                if (appStore) {\n+                    domain = StandardCertificateSelector.APP_STORE_PKG_INSTALLER;\n+                } else {\n+                    domain = StandardCertificateSelector.PKG_INSTALLER;\n+                }\n+\n+                signingIdentityBuilder.certificateSelector(StandardCertificateSelector.create(userName, domain));\n+            });\n+\n+            if (pkgBuilder.isPresent()) {\n+                pkgBuilder.orElseThrow().signingBuilder(signingIdentityBuilder);\n+            } else {\n+                final var expiredPkgCert = WithExpiredCertificateException.of(() -> {\n+                    return signingIdentityBuilder.create();\n+                }).certEx();\n+                expiredPkgCert.map(ConfigException::getMessage).ifPresent(Log::error);\n+                throw appOrExpiredCertEx.certEx().orElseThrow();\n+            }\n+        }\n+\n+        return pkgBuilder.orElseThrow().create();\n+    }\n+\n+    private static SigningIdentityBuilder createSigningIdentityBuilder(Map<String, ? super Object> params) {\n+        final var builder = new SigningIdentityBuilder();\n+        SIGNING_KEYCHAIN.copyInto(params, builder::keychain);\n+        return builder;\n+    }\n+\n+    private static MacFileAssociation createMacFa(FileAssociation fa, Map<String, ? super Object> params) {\n+\n+        final var builder = new MacFileAssociationBuilder();\n+\n+        FA_MAC_CFBUNDLETYPEROLE.copyInto(params, builder::cfBundleTypeRole);\n+        FA_MAC_LSHANDLERRANK.copyInto(params, builder::lsHandlerRank);\n+        FA_MAC_NSSTORETYPEKEY.copyInto(params, builder::nsPersistentStoreTypeKey);\n+        FA_MAC_NSDOCUMENTCLASS.copyInto(params, builder::nsDocumentClass);\n+        FA_MAC_LSTYPEISPACKAGE.copyInto(params, builder::lsTypeIsPackage);\n+        FA_MAC_LSDOCINPLACE.copyInto(params, builder::lsSupportsOpeningDocumentsInPlace);\n+        FA_MAC_UIDOCBROWSER.copyInto(params, builder::uiSupportsDocumentBrowser);\n+        FA_MAC_NSEXPORTABLETYPES.copyInto(params, builder::nsExportableTypes);\n+        FA_MAC_UTTYPECONFORMSTO.copyInto(params, builder::utTypeConformsTo);\n+\n+        return toFunction(builder::create).apply(fa);\n+    }\n+\n+    static final BundlerParamInfo<MacApplication> APPLICATION = createApplicationBundlerParam(\n+            MacFromParams::createMacApplication);\n+\n+    static final BundlerParamInfo<MacDmgPackage> DMG_PACKAGE = createPackageBundlerParam(\n+            MacFromParams::createMacDmgPackage);\n+\n+    static final BundlerParamInfo<MacPkgPackage> PKG_PACKAGE = createPackageBundlerParam(\n+            MacFromParams::createMacPkgPackage);\n+\n+    private static final BundlerParamInfo<String> MAC_CF_BUNDLE_NAME = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_BUNDLE_NAME.getId());\n+\n+    private static final BundlerParamInfo<String> APP_CATEGORY = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_CATEGORY.getId());\n+\n+    private static final BundlerParamInfo<Path> ENTITLEMENTS = createPathBundlerParam(\n+            Arguments.CLIOptions.MAC_ENTITLEMENTS.getId());\n+\n+    private static final BundlerParamInfo<String> MAC_CF_BUNDLE_IDENTIFIER = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId());\n+\n+    private static final BundlerParamInfo<String> SIGN_IDENTIFIER_PREFIX = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_BUNDLE_SIGNING_PREFIX.getId());\n+\n+    private static final BundlerParamInfo<String> APP_IMAGE_SIGN_IDENTITY = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_APP_IMAGE_SIGN_IDENTITY.getId());\n+\n+    private static final BundlerParamInfo<String> INSTALLER_SIGN_IDENTITY = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_INSTALLER_SIGN_IDENTITY.getId());\n+\n+    private static final BundlerParamInfo<String> SIGNING_KEY_USER = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_SIGNING_KEY_NAME.getId());\n+\n+    private static final BundlerParamInfo<String> SIGNING_KEYCHAIN = createStringBundlerParam(\n+            Arguments.CLIOptions.MAC_SIGNING_KEYCHAIN.getId());\n+\n+    private static final BundlerParamInfo<String> PACKAGE_TYPE = createStringBundlerParam(\n+            Arguments.CLIOptions.PACKAGE_TYPE.getId());\n+\n+    private static final BundlerParamInfo<Boolean> APP_STORE = createBooleanBundlerParam(\n+            Arguments.CLIOptions.MAC_APP_STORE.getId());\n+\n+    private static final BundlerParamInfo<String> FA_MAC_CFBUNDLETYPEROLE = createStringBundlerParam(\n+            Arguments.MAC_CFBUNDLETYPEROLE);\n+\n+    private static final BundlerParamInfo<String> FA_MAC_LSHANDLERRANK = createStringBundlerParam(\n+            Arguments.MAC_LSHANDLERRANK);\n+\n+    private static final BundlerParamInfo<String> FA_MAC_NSSTORETYPEKEY = createStringBundlerParam(\n+            Arguments.MAC_NSSTORETYPEKEY);\n+\n+    private static final BundlerParamInfo<String> FA_MAC_NSDOCUMENTCLASS = createStringBundlerParam(\n+            Arguments.MAC_NSDOCUMENTCLASS);\n+\n+    private static final BundlerParamInfo<Boolean> FA_MAC_LSTYPEISPACKAGE = createBooleanBundlerParam(\n+            Arguments.MAC_LSTYPEISPACKAGE);\n+\n+    private static final BundlerParamInfo<Boolean> FA_MAC_LSDOCINPLACE = createBooleanBundlerParam(\n+            Arguments.MAC_LSDOCINPLACE);\n+\n+    private static final BundlerParamInfo<Boolean> FA_MAC_UIDOCBROWSER = createBooleanBundlerParam(\n+            Arguments.MAC_UIDOCBROWSER);\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final BundlerParamInfo<List<String>> FA_MAC_NSEXPORTABLETYPES =\n+            new BundlerParamInfo<>(\n+                    Arguments.MAC_NSEXPORTABLETYPES,\n+                    (Class<List<String>>) (Object) List.class,\n+                    null,\n+                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n+            );\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final BundlerParamInfo<List<String>> FA_MAC_UTTYPECONFORMSTO =\n+            new BundlerParamInfo<>(\n+                    Arguments.MAC_UTTYPECONFORMSTO,\n+                    (Class<List<String>>) (Object) List.class,\n+                    null,\n+                    (s, p) -> Arrays.asList(s.split(\"(,|\\\\s)+\"))\n+            );\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":364,"deletions":0,"binary":false,"changes":364,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.io.IOException;\n@@ -30,6 +29,2 @@\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.function.Predicate;\n-import static jdk.jpackage.internal.MacAppImageBuilder.MAC_CF_BUNDLE_IDENTIFIER;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.MacPackage;\n@@ -43,4 +38,3 @@\n-    private MacLaunchersAsServices(PlatformPackage thePackage,\n-            Map<String, Object> params) throws IOException {\n-        super(thePackage, List.of(), params, li -> {\n-            return new Launcher(thePackage, li.getName(), params);\n+    MacLaunchersAsServices(BuildEnv env, MacPackage pkg) {\n+        super(env.appImageDir(), pkg.app(), List.of(), launcher -> {\n+            return new MacLauncherAsService(env, pkg, launcher);\n@@ -50,32 +44,1 @@\n-    static ShellCustomAction create(Map<String, Object> params,\n-            Path outputDir) throws IOException {\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            return null;\n-        }\n-        return Optional.of(new MacLaunchersAsServices(new PlatformPackage() {\n-            @Override\n-            public String name() {\n-                return MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);\n-            }\n-\n-            @Override\n-            public Path sourceRoot() {\n-                return outputDir;\n-            }\n-\n-            @Override\n-            public ApplicationLayout sourceApplicationLayout() {\n-                throw new UnsupportedOperationException();\n-            }\n-\n-            @Override\n-            public ApplicationLayout installedApplicationLayout() {\n-                return ApplicationLayout.macAppImage().resolveAt(Path.of(\n-                        MacBaseInstallerBundler.getInstallDir(params, false),\n-                        APP_NAME.fetchFrom(params) + \".app\"));\n-            }\n-        }, params)).filter(Predicate.not(MacLaunchersAsServices::isEmpty)).orElse(\n-                null);\n-    }\n-\n-    public static Path getServicePListFileName(String packageName,\n+    public static Path getServicePListFileName(String bundleIdentifier,\n@@ -84,1 +47,1 @@\n-        return Path.of(packageName + \"-\" + baseName + \".plist\");\n+        return Path.of(bundleIdentifier + \"-\" + baseName + \".plist\");\n@@ -87,1 +50,1 @@\n-    private static class Launcher extends UnixLauncherAsService {\n+    private static class MacLauncherAsService extends UnixLauncherAsService {\n@@ -89,5 +52,3 @@\n-        Launcher(PlatformPackage thePackage, String name,\n-                Map<String, Object> mainParams) {\n-            super(name, mainParams, createResource(\"launchd.plist.template\",\n-                    mainParams).setCategory(I18N.getString(\n-                            \"resource.launchd-plist-file\")));\n+        MacLauncherAsService(BuildEnv env, MacPackage pkg, Launcher launcher) {\n+            super(pkg.app(), launcher, env.createResource(\"launchd.plist.template\").setCategory(I18N\n+                    .getString(\"resource.launchd-plist-file\")));\n@@ -95,1 +56,1 @@\n-            plistFilename = getServicePListFileName(thePackage.name(), getName());\n+            plistFilename = getServicePListFileName(pkg.app().bundleIdentifier(), getName());\n@@ -105,2 +66,1 @@\n-                            thePackage.installedApplicationLayout().launchersDirectory().resolve(\n-                                    getName()).toString());\n+                            pkg.asInstalledPackageApplicationLayout().orElseThrow().launchersDirectory().resolve(getName()).toString());\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacLaunchersAsServices.java","additions":14,"deletions":54,"binary":false,"changes":68,"status":"modified"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.Objects;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.MacPackage;\n+import jdk.jpackage.internal.model.MacPackageMixin;\n+\n+final class MacPackageBuilder {\n+\n+    MacPackageBuilder(PackageBuilder pkgBuilder) {\n+        this.pkgBuilder = Objects.requireNonNull(pkgBuilder);\n+    }\n+\n+    MacPackageBuilder predefinedAppImageSigned(boolean  v) {\n+        predefinedAppImageSigned = v;\n+        return this;\n+    }\n+\n+    PackageBuilder pkgBuilder() {\n+        return pkgBuilder;\n+    }\n+\n+    MacPackage create() throws ConfigException {\n+        final var pkg = pkgBuilder.create();\n+        return MacPackage.create(pkg, new MacPackageMixin.Stub(pkg.predefinedAppImage().map(v -> predefinedAppImageSigned)));\n+    }\n+\n+    private final PackageBuilder pkgBuilder;\n+    private boolean predefinedAppImageSigned;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackageBuilder.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -0,0 +1,460 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.ApplicationImageUtils.createWriteAppImageFileAction;\n+import static jdk.jpackage.internal.util.PListWriter.writeArray;\n+import static jdk.jpackage.internal.util.PListWriter.writeBoolean;\n+import static jdk.jpackage.internal.util.PListWriter.writeBooleanOptional;\n+import static jdk.jpackage.internal.util.PListWriter.writeDict;\n+import static jdk.jpackage.internal.util.PListWriter.writeKey;\n+import static jdk.jpackage.internal.util.PListWriter.writeString;\n+import static jdk.jpackage.internal.util.PListWriter.writeStringArray;\n+import static jdk.jpackage.internal.util.PListWriter.writeStringOptional;\n+import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingBiConsumer.toBiConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.io.IOException;\n+import java.io.StringWriter;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import javax.xml.stream.XMLOutputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import jdk.jpackage.internal.PackagingPipeline.AppImageBuildEnv;\n+import jdk.jpackage.internal.PackagingPipeline.ApplicationImageTaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.CopyAppImageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskAction;\n+import jdk.jpackage.internal.PackagingPipeline.TaskContext;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.AppImageSigningConfig;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.MacApplication;\n+import jdk.jpackage.internal.model.MacFileAssociation;\n+import jdk.jpackage.internal.model.MacPackage;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.util.PathUtils;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+\n+final class MacPackagingPipeline {\n+\n+    enum MacBuildApplicationTaskID implements TaskID {\n+        RUNTIME_INFO_PLIST,\n+        COPY_JLILIB,\n+        APP_ICON,\n+        PKG_INFO_FILE,\n+        FA_ICONS,\n+        APP_INFO_PLIST,\n+        PACKAGE_FILE,\n+        SIGN\n+    }\n+\n+    enum MacCopyAppImageTaskID implements TaskID {\n+        COPY_PACKAGE_FILE,\n+        COPY_RUNTIME_INFO_PLIST,\n+        REPLACE_APP_IMAGE_FILE,\n+        COPY_SIGN\n+    }\n+\n+    static AppImageLayout packagingLayout(Package pkg) {\n+        return pkg.appImageLayout().resolveAt(pkg.relativeInstallDir().getFileName());\n+    }\n+\n+    static PackagingPipeline.Builder build(Optional<Package> pkg) {\n+        final var builder = PackagingPipeline.buildStandard()\n+                .appContextMapper(appContext -> {\n+                    return new TaskContextProxy(appContext, true, false);\n+                })\n+                .pkgContextMapper(appContext -> {\n+                    final var isRuntimeInstaller = pkg.map(Package::isRuntimeInstaller).orElse(false);\n+                    final var withPredefinedAppImage = pkg.flatMap(Package::predefinedAppImage).isPresent();\n+                    return new TaskContextProxy(appContext, false, isRuntimeInstaller || withPredefinedAppImage);\n+                })\n+                .appImageLayoutForPackaging(MacPackagingPipeline::packagingLayout)\n+                .task(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .packageAction(MacPackagingPipeline::runPostAppImageUserScript).add()\n+                .task(CopyAppImageTaskID.COPY)\n+                        .copyAction(MacPackagingPipeline::copyAppImage).add()\n+                .task(MacBuildApplicationTaskID.RUNTIME_INFO_PLIST)\n+                        .applicationAction(MacPackagingPipeline::writeApplicationRuntimeInfoPlist)\n+                        .addDependent(BuildApplicationTaskID.CONTENT).add()\n+                .task(MacBuildApplicationTaskID.COPY_JLILIB)\n+                        .applicationAction(MacPackagingPipeline::copyJliLib)\n+                        .addDependency(BuildApplicationTaskID.RUNTIME)\n+                        .addDependent(BuildApplicationTaskID.CONTENT).add()\n+                .task(MacBuildApplicationTaskID.APP_ICON)\n+                        .applicationAction(new ApplicationIcon())\n+                        .addDependent(BuildApplicationTaskID.CONTENT).add()\n+                .task(MacBuildApplicationTaskID.PKG_INFO_FILE)\n+                        .applicationAction(MacPackagingPipeline::writePkgInfoFile)\n+                        .addDependent(BuildApplicationTaskID.CONTENT).add()\n+                .task(MacBuildApplicationTaskID.PACKAGE_FILE)\n+                        .packageAction(MacPackagingPipeline::writePackageFile)\n+                        .addDependents(BuildApplicationTaskID.CONTENT).add()\n+                .task(MacCopyAppImageTaskID.REPLACE_APP_IMAGE_FILE)\n+                        .addDependent(PrimaryTaskID.COPY_APP_IMAGE)\n+                        .noaction().add()\n+                .task(MacCopyAppImageTaskID.COPY_PACKAGE_FILE)\n+                        .packageAction(MacPackagingPipeline::writePackageFile)\n+                        .addDependencies(CopyAppImageTaskID.COPY)\n+                        .addDependents(PrimaryTaskID.COPY_APP_IMAGE).add()\n+                .task(MacCopyAppImageTaskID.COPY_RUNTIME_INFO_PLIST)\n+                        .addDependencies(CopyAppImageTaskID.COPY)\n+                        .addDependents(PrimaryTaskID.COPY_APP_IMAGE).add()\n+                .task(MacBuildApplicationTaskID.FA_ICONS)\n+                        .applicationAction(MacPackagingPipeline::writeFileAssociationIcons)\n+                        .addDependent(BuildApplicationTaskID.CONTENT).add()\n+                .task(MacBuildApplicationTaskID.APP_INFO_PLIST)\n+                        .applicationAction(MacPackagingPipeline::writeAppInfoPlist)\n+                        .addDependent(BuildApplicationTaskID.CONTENT).add();\n+\n+        builder.task(MacBuildApplicationTaskID.SIGN)\n+                .appImageAction(MacPackagingPipeline::sign)\n+                .addDependencies(builder.taskGraphSnapshot().getAllTailsOf(PrimaryTaskID.BUILD_APPLICATION_IMAGE))\n+                .addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE)\n+                .add();\n+\n+        builder.task(MacCopyAppImageTaskID.COPY_SIGN)\n+                .appImageAction(MacPackagingPipeline::sign)\n+                .addDependencies(builder.taskGraphSnapshot().getAllTailsOf(PrimaryTaskID.COPY_APP_IMAGE))\n+                .addDependent(PrimaryTaskID.COPY_APP_IMAGE)\n+                .add();\n+\n+        pkg.ifPresent(p -> {\n+            final List<TaskID> disabledTasks = new ArrayList<>();\n+\n+            if (p.type() instanceof SignAppImagePackageType) {\n+                \/\/ This is a phony package signing predefined app image.\n+                \/\/ Don't create \".package\" file.\n+                \/\/ Don't copy predefined app image, update it in place.\n+                \/\/ Disable running user script after app image ready.\n+                \/\/ Replace \".jpackage.xml\" file.\n+                \/\/ Use app image layout.\n+                disabledTasks.add(MacCopyAppImageTaskID.COPY_PACKAGE_FILE);\n+                disabledTasks.add(CopyAppImageTaskID.COPY);\n+                disabledTasks.add(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT);\n+                builder.task(MacCopyAppImageTaskID.REPLACE_APP_IMAGE_FILE).applicationAction(createWriteAppImageFileAction()).add();\n+                builder.appImageLayoutForPackaging(Package::appImageLayout);\n+            } else if (p.isRuntimeInstaller() || ((MacPackage)p).predefinedAppImageSigned().orElse(false)) {\n+                \/\/ If this is a runtime package or a signed predefined app image,\n+                \/\/ don't create \".package\" file and don't sign it.\n+                disabledTasks.add(MacCopyAppImageTaskID.COPY_PACKAGE_FILE);\n+                disabledTasks.add(MacCopyAppImageTaskID.COPY_SIGN);\n+\/\/                if (p.isRuntimeInstaller()) {\n+\/\/                    builder.task(MacCopyAppImageTaskID.COPY_RUNTIME_INFO_PLIST).packageAction(MacPackagingPipeline::writeRuntimeRuntimeInfoPlist).add();\n+\/\/                }\n+            }\n+\n+            for (final var taskId : disabledTasks) {\n+                builder.task(taskId).noaction().add();\n+            }\n+        });\n+\n+        return builder;\n+    }\n+\n+    enum SignAppImagePackageType implements PackageType {\n+        VALUE;\n+    }\n+\n+    static Package createSignAppImagePackage(MacApplication app, BuildEnv env) {\n+        if (!app.sign()) {\n+            throw new IllegalArgumentException();\n+        }\n+        return toSupplier(() -> {\n+            return new PackageBuilder(app, SignAppImagePackageType.VALUE).predefinedAppImage(\n+                    Objects.requireNonNull(env.appImageDir())).installDir(Path.of(\"\/foo\")).create();\n+        }).get();\n+    }\n+\n+    private static void copyAppImage(MacPackage pkg, AppImageDesc srcAppImage,\n+            AppImageDesc dstAppImage) throws IOException {\n+        PackagingPipeline.copyAppImage(srcAppImage, dstAppImage, !pkg.predefinedAppImageSigned().orElse(false));\n+    }\n+\n+    private static void copyJliLib(\n+            AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+\n+        final var runtimeMacOSDir = env.resolvedLayout().runtimeRootDirectory().resolve(\"Contents\/MacOS\");\n+\n+        final var jliName = Path.of(\"libjli.dylib\");\n+\n+        try (var walk = Files.walk(env.resolvedLayout().runtimeDirectory().resolve(\"lib\"))) {\n+            final var jli = walk\n+                    .filter(file -> file.getFileName().equals(jliName))\n+                    .findFirst()\n+                    .orElseThrow();\n+            Files.createDirectories(runtimeMacOSDir);\n+            Files.copy(jli, runtimeMacOSDir.resolve(jliName));\n+        }\n+    }\n+\n+    private static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n+        PackagingPipeline.runPostAppImageUserScript(new PackageBuildEnv<>(\n+                BuildEnv.withAppImageDir(env.env(), env.env().appImageDir().resolve(env.envLayout().rootDirectory())),\n+                env.pkg(), env.pkg().appImageLayout(), env.outputDir()));\n+    }\n+\n+    private static void writePackageFile(PackageBuildEnv<Package, ApplicationLayout> env) throws IOException {\n+        new PackageFile(env.pkg().packageName()).save(env.resolvedLayout());\n+    }\n+\n+    private static void writePkgInfoFile(\n+            AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+\n+        final var dir = env.resolvedLayout().contentDirectory();\n+        Files.createDirectories(dir);\n+        Files.write(dir.resolve(\"PkgInfo\"),\n+                \"APPL????\".getBytes(StandardCharsets.ISO_8859_1));\n+    }\n+\n+    private static void writeRuntimeRuntimeInfoPlist(PackageBuildEnv<MacPackage, AppImageLayout> env) throws IOException {\n+        writeRuntimeInfoPlist(env.pkg().app(), env.env(), env.resolvedLayout().rootDirectory());\n+    }\n+\n+    private static void writeApplicationRuntimeInfoPlist(\n+            AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+        writeRuntimeInfoPlist(env.app(), env.env(), env.resolvedLayout().runtimeRootDirectory());\n+    }\n+\n+    private static void writeRuntimeInfoPlist(MacApplication app, BuildEnv env, Path runtimeRootDirectory) throws IOException {\n+\n+        Map<String, String> data = new HashMap<>();\n+        data.put(\"CF_BUNDLE_IDENTIFIER\", app.bundleIdentifier());\n+        data.put(\"CF_BUNDLE_NAME\", app.bundleName());\n+        data.put(\"CF_BUNDLE_VERSION\", app.version());\n+        data.put(\"CF_BUNDLE_SHORT_VERSION_STRING\", app.shortVersion().toString());\n+\n+        env.createResource(\"Runtime-Info.plist.template\")\n+                .setPublicName(\"Runtime-Info.plist\")\n+                .setCategory(I18N.getString(\"resource.runtime-info-plist\"))\n+                .setSubstitutionData(data)\n+                .saveToFile(runtimeRootDirectory.resolve(\"Contents\/Info.plist\"));\n+    }\n+\n+    private static void writeAppInfoPlist(\n+            AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+\n+        final var app = env.app();\n+\n+        final var infoPlistFile = env.resolvedLayout().contentDirectory().resolve(\"Info.plist\");\n+\n+        Log.verbose(I18N.format(\"message.preparing-info-plist\", PathUtils.normalizedAbsolutePathString(infoPlistFile)));\n+\n+        final String faXml = toSupplier(() -> {\n+            var buf = new StringWriter();\n+            var xml = XMLOutputFactory.newInstance().createXMLStreamWriter(buf);\n+            writeCFBundleDocumentTypes(xml, app);\n+            writeUTExportedTypeDeclarations(xml, app);\n+            xml.flush();\n+            xml.close();\n+            return buf.toString();\n+        }).get();\n+\n+        Map<String, String> data = new HashMap<>();\n+        data.put(\"DEPLOY_ICON_FILE\", ApplicationIcon.getPath(app, env.resolvedLayout()).getFileName().toString());\n+        data.put(\"DEPLOY_BUNDLE_COPYRIGHT\", app.copyright());\n+        data.put(\"DEPLOY_LAUNCHER_NAME\", app.mainLauncher().orElseThrow().executableNameWithSuffix());\n+        data.put(\"DEPLOY_BUNDLE_SHORT_VERSION\", app.shortVersion().toString());\n+        data.put(\"DEPLOY_BUNDLE_CFBUNDLE_VERSION\", app.version());\n+        data.put(\"DEPLOY_BUNDLE_NAME\", app.bundleName());\n+        data.put(\"DEPLOY_BUNDLE_IDENTIFIER\", app.bundleIdentifier());\n+        data.put(\"DEPLOY_APP_CATEGORY\", app.category());\n+        data.put(\"DEPLOY_FILE_ASSOCIATIONS\", faXml);\n+\n+        env.env().createResource(\"Info-lite.plist.template\")\n+                .setCategory(I18N.getString(\"resource.app-info-plist\"))\n+                .setSubstitutionData(data)\n+                .setPublicName(\"Info.plist\")\n+                .saveToFile(infoPlistFile);\n+    }\n+\n+    private static void sign(AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+\n+        final var app = env.app();\n+\n+        final var codesignConfigBuilder = CodesignConfig.build();\n+        app.signingConfig().ifPresent(codesignConfigBuilder::from);\n+\n+        if (app.sign() && app.signingConfig().flatMap(AppImageSigningConfig::entitlements).isEmpty()) {\n+            final var entitlementsDefaultResource = app.signingConfig().map(\n+                    AppImageSigningConfig::entitlementsResourceName).orElseThrow();\n+\n+            final var entitlementsFile = env.env().configDir().resolve(app.name() + \".entitlements\");\n+\n+            env.env().createResource(entitlementsDefaultResource)\n+                    .setCategory(I18N.getString(\"resource.entitlements\"))\n+                    .saveToFile(entitlementsFile);\n+\n+            codesignConfigBuilder.entitlements(entitlementsFile);\n+        }\n+\n+        final Runnable signAction = () -> {\n+            final var appImageDir = env.resolvedLayout().rootDirectory();\n+            AppImageSigner.createSigner(app, codesignConfigBuilder.create()).accept(appImageDir);\n+        };\n+\n+        app.signingConfig().flatMap(AppImageSigningConfig::keychain).map(Keychain::new).ifPresentOrElse(keychain -> {\n+            toBiConsumer(TempKeychain::withKeychain).accept(unused -> signAction.run(), keychain);\n+        }, signAction);\n+    }\n+\n+    private static void writeCFBundleDocumentTypes(XMLStreamWriter xml,\n+            MacApplication app) throws XMLStreamException, IOException {\n+        final var fas = app.fileAssociations().toList();\n+        if (!fas.isEmpty()) {\n+            writeKey(xml, \"CFBundleDocumentTypes\");\n+            writeArray(xml, toXmlConsumer(() -> {\n+                for (var fa : fas) {\n+                    writeDict(xml, toXmlConsumer(() -> {\n+                        addFaToCFBundleDocumentTypes(xml, app, (MacFileAssociation) fa);\n+                    }));\n+                }\n+            }));\n+        }\n+    }\n+\n+    private static void writeUTExportedTypeDeclarations(XMLStreamWriter xml,\n+            MacApplication app) throws XMLStreamException, IOException {\n+        final var fas = app.fileAssociations().toList();\n+        if (!fas.isEmpty()) {\n+            writeKey(xml, \"UTExportedTypeDeclarations\");\n+            writeArray(xml, toXmlConsumer(() -> {\n+                for (var fa : fas) {\n+                    writeDict(xml, toXmlConsumer(() -> {\n+                        addFaToUTExportedTypeDeclarations(xml, app, (MacFileAssociation) fa);\n+                    }));\n+                }\n+            }));\n+        }\n+    }\n+\n+    private static String faContentType(MacApplication app, MacFileAssociation fa) {\n+        return String.format(\"%s.%s\", app.bundleIdentifier(), fa.extension());\n+    }\n+\n+    private static void faWriteIcon(XMLStreamWriter xml, String key, FileAssociation fa)\n+            throws XMLStreamException {\n+        fa.icon().ifPresent(ThrowingConsumer.toConsumer(icon -> {\n+            writeString(xml, key, icon.getFileName());\n+        }));\n+    }\n+\n+    private static void addFaToCFBundleDocumentTypes(XMLStreamWriter xml,\n+            MacApplication app, MacFileAssociation fa) throws XMLStreamException, IOException {\n+\n+        writeStringArray(xml, \"LSItemContentTypes\", List.of(faContentType(app, fa)));\n+        writeStringOptional(xml, \"CFBundleTypeName\", fa.description());\n+        writeString(xml, \"LSHandlerRank\", fa.lsHandlerRank());\n+        writeString(xml, \"CFBundleTypeRole\", fa.cfBundleTypeRole());\n+        writeStringOptional(xml, \"NSPersistentStoreTypeKey\", fa.nsPersistentStoreTypeKey());\n+        writeStringOptional(xml, \"NSDocumentClass\", fa.nsDocumentClass());\n+        writeBoolean(xml, \"LSIsAppleDefaultForType\", true);\n+        writeBooleanOptional(xml, \"LSTypeIsPackage\", fa.lsTypeIsPackage());\n+        writeBooleanOptional(xml, \"LSSupportsOpeningDocumentsInPlace\", fa.lsSupportsOpeningDocumentsInPlace());\n+        writeBooleanOptional(xml, \"UISupportsDocumentBrowser\", fa.uiSupportsDocumentBrowser());\n+        faWriteIcon(xml, \"CFBundleTypeIconFile\", fa);\n+    }\n+\n+    private static void addFaToUTExportedTypeDeclarations(XMLStreamWriter xml,\n+            MacApplication app, MacFileAssociation fa) throws XMLStreamException, IOException {\n+        writeString(xml, \"UTTypeIdentifier\", faContentType(app, fa));\n+        writeStringOptional(xml, \"UTTypeDescription\", fa.description());\n+        writeStringArray(xml, \"UTTypeConformsTo\", fa.utTypeConformsTo());\n+        faWriteIcon(xml, \"UTTypeIconFile\", fa);\n+\n+        writeKey(xml, \"UTTypeTagSpecification\");\n+        writeDict(xml, toXmlConsumer(() -> {\n+            writeStringArray(xml, \"public.filename-extension\", List.of(fa.extension()));\n+            writeStringArray(xml, \"public.mime-type\", List.of(fa.mimeType()));\n+            writeStringArray(xml, \"NSExportableTypes\", fa.nsExportableTypes());\n+        }));\n+    }\n+\n+    private static class ApplicationIcon implements ApplicationImageTaskAction<MacApplication, MacApplicationLayout> {\n+        static Path getPath(Application app, ApplicationLayout appLayout) {\n+            return appLayout.destktopIntegrationDirectory().resolve(app.name() + \".icns\");\n+        }\n+\n+        @Override\n+        public void execute(AppImageBuildEnv<MacApplication, MacApplicationLayout> env)\n+                throws IOException {\n+            final var resource = env.env().createResource(\"JavaApp.icns\").setCategory(\"icon\");\n+\n+            env.app().icon().ifPresent(resource::setExternal);\n+\n+            resource.saveToFile(getPath(env.app(), env.resolvedLayout()));\n+        }\n+    }\n+\n+    private static void writeFileAssociationIcons(AppImageBuildEnv<MacApplication, MacApplicationLayout> env) throws IOException {\n+        for (var faIcon : env.app().fileAssociations()\n+                .filter(FileAssociation::hasIcon)\n+                .map(FileAssociation::icon)\n+                .map(Optional::get).toList()) {\n+            Files.copy(faIcon, env.resolvedLayout().destktopIntegrationDirectory().resolve(faIcon.getFileName()));\n+        }\n+    }\n+\n+    private record TaskContextProxy(TaskContext delegate, boolean forApp, boolean copyAppImage) implements TaskContext {\n+\n+        @Override\n+        public boolean test(TaskID taskID) {\n+            if (!delegate.test(taskID)) {\n+                return false;\n+            } else if (taskID == MacBuildApplicationTaskID.PACKAGE_FILE) {\n+                \/\/ Don't create files relevant for package bundling when bundling app image\n+                return !forApp;\n+            } else {\n+                return true;\n+            }\n+        }\n+\n+        @Override\n+        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+            delegate.execute(taskAction);\n+        }\n+    }\n+\n+    static final MacApplicationLayout APPLICATION_LAYOUT = MacApplicationLayout.create(\n+            ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT, Path.of(\"Contents\/runtime\"));\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPackagingPipeline.java","additions":460,"deletions":0,"binary":false,"changes":460,"status":"added"},{"patch":"@@ -28,10 +28,0 @@\n-import jdk.internal.util.Architecture;\n-import jdk.internal.util.OSVersion;\n-\n-import java.io.ByteArrayOutputStream;\n-import java.io.IOException;\n-import java.io.PrintStream;\n-import java.io.PrintWriter;\n-import java.net.URI;\n-import java.net.URISyntaxException;\n-import java.nio.file.Files;\n@@ -39,5 +29,0 @@\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n-import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n@@ -46,17 +31,0 @@\n-import java.util.Optional;\n-import java.util.ResourceBundle;\n-import javax.xml.stream.XMLStreamException;\n-import javax.xml.stream.XMLStreamWriter;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-import static jdk.jpackage.internal.MacAppBundler.APP_IMAGE_SIGN_IDENTITY;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_STORE;\n-import static jdk.jpackage.internal.MacAppImageBuilder.MAC_CF_BUNDLE_IDENTIFIER;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-\n@@ -65,2 +33,0 @@\n-import jdk.jpackage.internal.util.FileUtils;\n-import jdk.jpackage.internal.util.XmlUtils;\n@@ -70,630 +36,0 @@\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MacResources\");\n-\n-    private static final String DEFAULT_BACKGROUND_IMAGE = \"background_pkg.png\";\n-    private static final String DEFAULT_PDF = \"product-def.plist\";\n-\n-    private static final BundlerParamInfo<Path> PACKAGES_ROOT =\n-            new StandardBundlerParam<>(\n-            \"mac.pkg.packagesRoot\",\n-            Path.class,\n-            params -> {\n-                Path packagesRoot =\n-                        TEMP_ROOT.fetchFrom(params).resolve(\"packages\");\n-                try {\n-                    Files.createDirectories(packagesRoot);\n-                } catch (IOException ioe) {\n-                    return null;\n-                }\n-                return packagesRoot;\n-            },\n-            (s, p) -> Path.of(s));\n-\n-\n-    protected final BundlerParamInfo<Path> SCRIPTS_DIR =\n-            new StandardBundlerParam<>(\n-            \"mac.pkg.scriptsDir\",\n-            Path.class,\n-            params -> {\n-                Path scriptsDir =\n-                        CONFIG_ROOT.fetchFrom(params).resolve(\"scripts\");\n-                try {\n-                    Files.createDirectories(scriptsDir);\n-                } catch (IOException ioe) {\n-                    return null;\n-                }\n-                return scriptsDir;\n-            },\n-            (s, p) -> Path.of(s));\n-\n-    public static final\n-            BundlerParamInfo<String> DEVELOPER_ID_INSTALLER_SIGNING_KEY =\n-            new StandardBundlerParam<>(\n-            \"mac.signing-key-developer-id-installer\",\n-            String.class,\n-            params -> {\n-                    String user = SIGNING_KEY_USER.fetchFrom(params);\n-                    String keychain = SIGNING_KEYCHAIN.fetchFrom(params);\n-                    String result = null;\n-                    if (APP_STORE.fetchFrom(params)) {\n-                        result = MacCertificate.findCertificateKey(\n-                            \"3rd Party Mac Developer Installer: \",\n-                            user, keychain);\n-                    }\n-                    \/\/ if either not signing for app store or couldn't find\n-                    if (result == null) {\n-                        result = MacCertificate.findCertificateKey(\n-                            \"Developer ID Installer: \", user, keychain);\n-                    }\n-\n-                    if (result != null) {\n-                        MacCertificate certificate = new MacCertificate(result, keychain);\n-\n-                        if (!certificate.isValid()) {\n-                            Log.error(MessageFormat.format(\n-                                    I18N.getString(\"error.certificate.expired\"),\n-                                    result));\n-                        }\n-                    }\n-\n-                    return result;\n-                },\n-            (s, p) -> s);\n-\n-    public Path bundle(Map<String, ? super Object> params,\n-            Path outdir) throws PackagerException {\n-        Log.verbose(MessageFormat.format(I18N.getString(\"message.building-pkg\"),\n-                APP_NAME.fetchFrom(params)));\n-\n-        IOUtils.writableOutputDir(outdir);\n-\n-        try {\n-            Path appImageDir = prepareAppBundle(params);\n-\n-            if (appImageDir != null && prepareConfigFiles(params)) {\n-                prepareCPLFile(params, appImageDir);\n-\n-                if (withServicesPkg(params)) {\n-                    prepareServicesPkg(params);\n-                }\n-\n-                if (!APP_STORE.fetchFrom(params)) {\n-                    preparePackageScripts(params);\n-                }\n-\n-                new ScriptRunner()\n-                        .setDirectory(appImageDir)\n-                        .setResourceCategoryId(\"resource.post-app-image-script\")\n-                        .setScriptNameSuffix(\"post-image\")\n-                        .setEnvironmentVariable(\"JpAppImageDir\", appImageDir.toAbsolutePath().toString())\n-                        .run(params);\n-\n-                return createPKG(params, outdir, appImageDir);\n-            }\n-            return null;\n-        } catch (IOException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n-    }\n-\n-    private Path getPackages_AppPackage(Map<String, ? super Object> params) {\n-        return PACKAGES_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-app.pkg\");\n-    }\n-\n-    private Path getPackages_ServicesPackage(Map<String, ? super Object> params) {\n-        return PACKAGES_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-services.pkg\");\n-    }\n-\n-    private Path getPackages_SupportPackage(Map<String, ? super Object> params) {\n-        return PACKAGES_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-support.pkg\");\n-    }\n-\n-    private Path getConfig_DistributionXMLFile(\n-            Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\"distribution.dist\");\n-    }\n-\n-    private Path getConfig_PDF(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\"product-def.plist\");\n-    }\n-\n-    private Path getConfig_BackgroundImage(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-background.png\");\n-    }\n-\n-    private Path getConfig_BackgroundImageDarkAqua(Map<String, ? super Object> params) {\n-        return CONFIG_ROOT.fetchFrom(params).resolve(\n-                APP_NAME.fetchFrom(params) + \"-background-darkAqua.png\");\n-    }\n-\n-    private String getAppIdentifier(Map<String, ? super Object> params) {\n-        return MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);\n-    }\n-\n-    private String getServicesIdentifier(Map<String, ? super Object> params) {\n-        return MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) + \".services\";\n-    }\n-\n-    private String getSupportIdentifier(Map<String, ? super Object> params) {\n-        return MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) + \".support\";\n-    }\n-\n-    private void preparePackageScripts(Map<String, ? super Object> params)\n-            throws IOException {\n-        Log.verbose(I18N.getString(\"message.preparing-scripts\"));\n-\n-        Map<String, String> data = new HashMap<>();\n-\n-        Path appLocation = Path.of(getInstallDir(params, false),\n-                         APP_NAME.fetchFrom(params) + \".app\", \"Contents\", \"app\");\n-\n-        data.put(\"INSTALL_LOCATION\", getInstallDir(params, false));\n-        data.put(\"APP_LOCATION\", appLocation.toString());\n-\n-        MacPkgInstallerScripts.createAppScripts()\n-                .setResourceDir(RESOURCE_DIR.fetchFrom(params))\n-                .setSubstitutionData(data)\n-                .saveInFolder(SCRIPTS_DIR.fetchFrom(params));\n-    }\n-\n-    private void addPackageToInstallerGuiScript(XMLStreamWriter xml,\n-            String pkgId, String pkgName, String pkgVersion) throws IOException,\n-            XMLStreamException {\n-        xml.writeStartElement(\"pkg-ref\");\n-        xml.writeAttribute(\"id\", pkgId);\n-        xml.writeEndElement(); \/\/ <\/pkg-ref>\n-        xml.writeStartElement(\"choice\");\n-        xml.writeAttribute(\"id\", pkgId);\n-        xml.writeAttribute(\"visible\", \"false\");\n-        xml.writeStartElement(\"pkg-ref\");\n-        xml.writeAttribute(\"id\", pkgId);\n-        xml.writeEndElement(); \/\/ <\/pkg-ref>\n-        xml.writeEndElement(); \/\/ <\/choice>\n-        xml.writeStartElement(\"pkg-ref\");\n-        xml.writeAttribute(\"id\", pkgId);\n-        xml.writeAttribute(\"version\", pkgVersion);\n-        xml.writeAttribute(\"onConclusion\", \"none\");\n-        try {\n-            xml.writeCharacters(new URI(null, null, pkgName, null).toASCIIString());\n-        } catch (URISyntaxException ex) {\n-            throw new RuntimeException(ex);\n-        }\n-        xml.writeEndElement(); \/\/ <\/pkg-ref>\n-    }\n-\n-    private void prepareDistributionXMLFile(Map<String, ? super Object> params)\n-            throws IOException {\n-        Path f = getConfig_DistributionXMLFile(params);\n-\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.preparing-distribution-dist\"), f.toAbsolutePath().toString()));\n-\n-        XmlUtils.createXml(f, xml -> {\n-            xml.writeStartElement(\"installer-gui-script\");\n-            xml.writeAttribute(\"minSpecVersion\", \"1\");\n-\n-            xml.writeStartElement(\"title\");\n-            xml.writeCharacters(APP_NAME.fetchFrom(params));\n-            xml.writeEndElement();\n-\n-            xml.writeStartElement(\"background\");\n-            xml.writeAttribute(\"file\",\n-                    getConfig_BackgroundImage(params).getFileName().toString());\n-            xml.writeAttribute(\"mime-type\", \"image\/png\");\n-            xml.writeAttribute(\"alignment\", \"bottomleft\");\n-            xml.writeAttribute(\"scaling\", \"none\");\n-            xml.writeEndElement();\n-\n-            xml.writeStartElement(\"background-darkAqua\");\n-            xml.writeAttribute(\"file\",\n-                    getConfig_BackgroundImageDarkAqua(params).getFileName().toString());\n-            xml.writeAttribute(\"mime-type\", \"image\/png\");\n-            xml.writeAttribute(\"alignment\", \"bottomleft\");\n-            xml.writeAttribute(\"scaling\", \"none\");\n-            xml.writeEndElement();\n-\n-            String licFileStr = LICENSE_FILE.fetchFrom(params);\n-            if (licFileStr != null) {\n-                Path licFile = Path.of(licFileStr);\n-                xml.writeStartElement(\"license\");\n-                xml.writeAttribute(\"file\", licFile.toAbsolutePath().toString());\n-                xml.writeAttribute(\"mime-type\", \"text\/rtf\");\n-                xml.writeEndElement();\n-            }\n-\n-            \/*\n-             * Note that the content of the distribution file\n-             * below is generated by productbuild --synthesize\n-             *\/\n-\n-            Map<String, Path> pkgs = new LinkedHashMap<>();\n-\n-            pkgs.put(getAppIdentifier(params), getPackages_AppPackage(params));\n-            if (withServicesPkg(params)) {\n-                pkgs.put(getServicesIdentifier(params),\n-                        getPackages_ServicesPackage(params));\n-                pkgs.put(getSupportIdentifier(params),\n-                        getPackages_SupportPackage(params));\n-            }\n-\n-            for (var pkg : pkgs.entrySet()) {\n-                addPackageToInstallerGuiScript(xml, pkg.getKey(),\n-                        pkg.getValue().getFileName().toString(),\n-                        VERSION.fetchFrom(params));\n-            }\n-\n-            xml.writeStartElement(\"options\");\n-            xml.writeAttribute(\"customize\", \"never\");\n-            xml.writeAttribute(\"require-scripts\", \"false\");\n-            xml.writeAttribute(\"hostArchitectures\",\n-                    Architecture.isAARCH64() ? \"arm64\" : \"x86_64\");\n-            xml.writeEndElement(); \/\/ <\/options>\n-            xml.writeStartElement(\"choices-outline\");\n-            xml.writeStartElement(\"line\");\n-            xml.writeAttribute(\"choice\", \"default\");\n-            for (var pkgId : pkgs.keySet()) {\n-                xml.writeStartElement(\"line\");\n-                xml.writeAttribute(\"choice\", pkgId);\n-                xml.writeEndElement(); \/\/ <\/line>\n-            }\n-            xml.writeEndElement(); \/\/ <\/line>\n-            xml.writeEndElement(); \/\/ <\/choices-outline>\n-            xml.writeStartElement(\"choice\");\n-            xml.writeAttribute(\"id\", \"default\");\n-            xml.writeEndElement(); \/\/ <\/choice>\n-\n-            xml.writeEndElement(); \/\/ <\/installer-gui-script>\n-        });\n-    }\n-\n-    private boolean prepareConfigFiles(Map<String, ? super Object> params)\n-            throws IOException {\n-\n-        createResource(DEFAULT_BACKGROUND_IMAGE, params)\n-                .setCategory(I18N.getString(\"resource.pkg-background-image\"))\n-                .saveToFile(getConfig_BackgroundImage(params));\n-\n-        createResource(DEFAULT_BACKGROUND_IMAGE, params)\n-                .setCategory(I18N.getString(\"resource.pkg-background-image\"))\n-                .saveToFile(getConfig_BackgroundImageDarkAqua(params));\n-\n-        createResource(DEFAULT_PDF, params)\n-                .setCategory(I18N.getString(\"resource.pkg-pdf\"))\n-                .saveToFile(getConfig_PDF(params));\n-\n-        prepareDistributionXMLFile(params);\n-\n-        return true;\n-    }\n-\n-    private void patchCPLFile(Path cpl) throws IOException {\n-        String cplData = Files.readString(cpl);\n-        String[] lines = cplData.split(\"\\n\");\n-        try (PrintWriter out = new PrintWriter(Files.newBufferedWriter(cpl))) {\n-            int skip = 0;\n-            \/\/ Used to skip Java.runtime bundle, since\n-            \/\/ pkgbuild with --root will find two bundles app and Java runtime.\n-            \/\/ We cannot generate component proprty list when using\n-            \/\/ --component argument.\n-            for (int i = 0; i < lines.length; i++) {\n-                if (lines[i].trim().equals(\"<key>BundleIsRelocatable<\/key>\")) {\n-                    out.println(lines[i]);\n-                    out.println(\"<false\/>\");\n-                    i++;\n-                } else if (lines[i].trim().equals(\"<key>ChildBundles<\/key>\")) {\n-                    ++skip;\n-                } else if ((skip > 0) && lines[i].trim().equals(\"<\/array>\")) {\n-                    --skip;\n-                } else {\n-                    if (skip == 0) {\n-                        out.println(lines[i]);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    \/\/ pkgbuild includes all components from \"--root\" and subfolders,\n-    \/\/ so if we have app image in folder which contains other images, then they\n-    \/\/ will be included as well. It does have \"--filter\" option which use regex\n-    \/\/ to exclude files\/folder, but it will overwrite default one which excludes\n-    \/\/ based on doc \"any .svn or CVS directories, and any .DS_Store files\".\n-    \/\/ So easy approach will be to copy user provided app-image into temp folder\n-    \/\/ if root path contains other files.\n-    private String getRoot(Map<String, ? super Object> params,\n-            Path appLocation) throws IOException {\n-        Path rootDir = appLocation.getParent() == null ?\n-                Path.of(\".\") : appLocation.getParent();\n-\n-        \/\/ Not needed for runtime installer and it might break runtime installer\n-        \/\/ if parent does not have any other files\n-        if (!StandardBundlerParam.isRuntimeInstaller(params)) {\n-            try (var fileList = Files.list(rootDir)) {\n-                Path[] list = fileList.toArray(Path[]::new);\n-                \/\/ We should only have app image and\/or .DS_Store\n-                if (list.length == 1) {\n-                    return rootDir.toString();\n-                } else if (list.length == 2) {\n-                    \/\/ Check case with app image and .DS_Store\n-                    if (list[0].toString().toLowerCase().endsWith(\".ds_store\") ||\n-                        list[1].toString().toLowerCase().endsWith(\".ds_store\")) {\n-                        return rootDir.toString(); \/\/ Only app image and .DS_Store\n-                    }\n-                }\n-            }\n-        }\n-\n-        \/\/ Copy to new root\n-        Path newRoot = Files.createTempDirectory(\n-                TEMP_ROOT.fetchFrom(params), \"root-\");\n-\n-        Path source, dest;\n-\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            \/\/ firs, is this already a runtime with\n-            \/\/ <runtime>\/Contents\/Home - if so we need the Home dir\n-            Path original = appLocation;\n-            Path home = original.resolve(\"Contents\/Home\");\n-            source = (Files.exists(home)) ? home : original;\n-\n-            \/\/ Then we need to put back the <NAME>\/Content\/Home\n-            dest = newRoot.resolve(\n-                MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) + \"\/Contents\/Home\");\n-        } else {\n-            source = appLocation;\n-            dest = newRoot.resolve(appLocation.getFileName());\n-        }\n-        FileUtils.copyRecursive(source, dest);\n-\n-        return newRoot.toString();\n-    }\n-\n-    private boolean withServicesPkg(Map<String, Object> params) {\n-        try {\n-            return !APP_STORE.fetchFrom(params)\n-                    && MacLaunchersAsServices.create(params, null) != null;\n-        } catch (IOException ex) {\n-            throw new RuntimeException(ex);\n-        }\n-    }\n-\n-    private void prepareServicesPkg(Map<String, Object> params) throws IOException {\n-        Path root = TEMP_ROOT.fetchFrom(params).resolve(\"services\");\n-\n-        Path srcRoot = root.resolve(\"src\");\n-\n-        var services = MacLaunchersAsServices.create(params, srcRoot);\n-\n-        Path scriptsDir = root.resolve(\"scripts\");\n-\n-        var data = services.create();\n-        data.put(\"SERVICES_PACKAGE_ID\", getServicesIdentifier(params));\n-\n-        MacPkgInstallerScripts.createServicesScripts()\n-                .setResourceDir(RESOURCE_DIR.fetchFrom(params))\n-                .setSubstitutionData(data)\n-                .saveInFolder(scriptsDir);\n-\n-        prepareSupportPkg(params, data);\n-    }\n-\n-    private void prepareSupportPkg(Map<String, Object> params,\n-            Map<String, String> servicesSubstitutionData) throws IOException {\n-        Path root = TEMP_ROOT.fetchFrom(params).resolve(\"support\");\n-\n-        Path srcRoot = root.resolve(\"src\");\n-\n-        var enqouter = Enquoter.forShellLiterals().setEnquotePredicate(str -> true);\n-\n-        Map<String, String> data = new HashMap<>(servicesSubstitutionData);\n-        data.put(\"APP_INSTALLATION_FOLDER\", enqouter.applyTo(Path.of(\n-                getInstallDir(params, false), APP_NAME.fetchFrom(params)\n-                + \".app\").toString()));\n-        data.put(\"SUPPORT_INSTALLATION_FOLDER\", enqouter.applyTo(Path.of(\n-                \"\/Library\/Application Support\", APP_NAME.fetchFrom(params)).toString()));\n-\n-        new ShellScriptResource(\"uninstall.command\")\n-                .setResource(createResource(\"uninstall.command.template\", params)\n-                        .setCategory(I18N.getString(\"resource.pkg-uninstall-script\"))\n-                        .setPublicName(\"uninstaller\")\n-                        .setSubstitutionData(data))\n-                .saveInFolder(srcRoot.resolve(APP_NAME.fetchFrom(params)));\n-    }\n-\n-    private void createServicesPkg(Map<String, Object> params) throws\n-            IOException {\n-        Path root = TEMP_ROOT.fetchFrom(params).resolve(\"services\");\n-\n-        Path srcRoot = root.resolve(\"src\");\n-\n-        Path scriptsDir = root.resolve(\"scripts\");\n-\n-        var pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n-                \"--root\",\n-                srcRoot.toString(),\n-                \"--install-location\",\n-                \"\/\",\n-                \"--scripts\",\n-                scriptsDir.toString(),\n-                \"--identifier\",\n-                getServicesIdentifier(params),\n-                getPackages_ServicesPackage(params).toAbsolutePath().toString());\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-\n-        createSupportPkg(params);\n-    }\n-\n-    private void createSupportPkg(Map<String, Object> params) throws IOException {\n-        Path root = TEMP_ROOT.fetchFrom(params).resolve(\"support\");\n-\n-        Path srcRoot = root.resolve(\"src\");\n-\n-        var pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n-                \"--root\",\n-                srcRoot.toString(),\n-                \"--install-location\",\n-                \"\/Library\/Application Support\",\n-                \"--identifier\",\n-                getSupportIdentifier(params),\n-                getPackages_SupportPackage(params).toAbsolutePath().toString());\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-    }\n-\n-    private void prepareCPLFile(Map<String, ? super Object> params, Path appLocation) throws IOException {\n-        String root = getRoot(params, appLocation);\n-        \/\/ Generate default CPL file\n-        Path cpl = CONFIG_ROOT.fetchFrom(params).resolve(\"cpl.plist\");\n-        ProcessBuilder pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n-                \"--root\",\n-                root,\n-                \"--install-location\",\n-                getInstallDir(params, false),\n-                \"--analyze\",\n-                cpl.toAbsolutePath().toString());\n-\n-        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-\n-        patchCPLFile(cpl);\n-    }\n-\n-    private Path createPKG(Map<String, ? super Object> params,\n-            Path outdir, Path appLocation) {\n-        \/\/ generic find attempt\n-        try {\n-            Path appPKG = getPackages_AppPackage(params);\n-\n-            String root = getRoot(params, appLocation);\n-\n-            if (withServicesPkg(params)) {\n-                createServicesPkg(params);\n-            }\n-\n-            ProcessBuilder pb;\n-\n-            Path cpl = CONFIG_ROOT.fetchFrom(params).resolve(\"cpl.plist\");\n-\n-            \/\/ build application package\n-            if (APP_STORE.fetchFrom(params)) {\n-                pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n-                        \"--root\",\n-                        root,\n-                        \"--install-location\",\n-                        getInstallDir(params, false),\n-                        \"--component-plist\",\n-                        cpl.toAbsolutePath().toString(),\n-                        \"--identifier\",\n-                         MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params),\n-                        appPKG.toAbsolutePath().toString());\n-                IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-            } else {\n-                pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n-                        \"--root\",\n-                        root,\n-                        \"--install-location\",\n-                        getInstallDir(params, false),\n-                        \"--component-plist\",\n-                        cpl.toAbsolutePath().toString(),\n-                        \"--scripts\",\n-                        SCRIPTS_DIR.fetchFrom(params)\n-                        .toAbsolutePath().toString(),\n-                        \"--identifier\",\n-                         MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params),\n-                        appPKG.toAbsolutePath().toString());\n-                IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n-            }\n-\n-            \/\/ build final package\n-            Path finalPKG = outdir.resolve(MAC_INSTALLER_NAME.fetchFrom(params)\n-                    + \".pkg\");\n-            Files.createDirectories(outdir);\n-\n-            List<String> commandLine = new ArrayList<>();\n-            commandLine.add(\"\/usr\/bin\/productbuild\");\n-\n-            commandLine.add(\"--resources\");\n-            commandLine.add(CONFIG_ROOT.fetchFrom(params).toAbsolutePath().toString());\n-\n-            \/\/ maybe sign\n-            if (Optional.ofNullable(\n-                    SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {\n-                if (OSVersion.current().compareTo(new OSVersion(10, 12)) >= 0) {\n-                    \/\/ we need this for OS X 10.12+\n-                    Log.verbose(I18N.getString(\"message.signing.pkg\"));\n-                }\n-\n-                String signingIdentity = null;\n-                \/\/ --mac-installer-sign-identity\n-                if (!INSTALLER_SIGN_IDENTITY.getIsDefaultValue(params)) {\n-                    signingIdentity = INSTALLER_SIGN_IDENTITY.fetchFrom(params);\n-                } else {\n-                    \/\/ Use --mac-signing-key-user-name if user did not request\n-                    \/\/ to sign just app image using --mac-app-image-sign-identity\n-                    if (APP_IMAGE_SIGN_IDENTITY.getIsDefaultValue(params)) {\n-                        \/\/ --mac-signing-key-user-name\n-                        signingIdentity = DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);\n-                    }\n-                }\n-\n-                if (signingIdentity != null) {\n-                    commandLine.add(\"--sign\");\n-                    commandLine.add(signingIdentity);\n-                }\n-\n-                String keychainName = SIGNING_KEYCHAIN.fetchFrom(params);\n-                if (keychainName != null && !keychainName.isEmpty()) {\n-                    commandLine.add(\"--keychain\");\n-                    commandLine.add(keychainName);\n-                }\n-            }\n-\n-            if (APP_STORE.fetchFrom(params)) {\n-                commandLine.add(\"--product\");\n-                commandLine.add(getConfig_PDF(params)\n-                        .toAbsolutePath().toString());\n-                commandLine.add(\"--component\");\n-                Path p = Path.of(root, APP_NAME.fetchFrom(params) + \".app\");\n-                commandLine.add(p.toAbsolutePath().toString());\n-                commandLine.add(getInstallDir(params, false));\n-            } else {\n-                commandLine.add(\"--distribution\");\n-                commandLine.add(getConfig_DistributionXMLFile(params)\n-                        .toAbsolutePath().toString());\n-                commandLine.add(\"--package-path\");\n-                commandLine.add(PACKAGES_ROOT.fetchFrom(params)\n-                        .toAbsolutePath().toString());\n-            }\n-            commandLine.add(finalPKG.toAbsolutePath().toString());\n-\n-            pb = new ProcessBuilder(commandLine);\n-\n-            try (ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-                 PrintStream ps = new PrintStream(baos)) {\n-                try {\n-                    IOUtils.exec(pb, false, ps, true, Executor.INFINITE_TIMEOUT);\n-                } catch (IOException ioe) {\n-                    \/\/ Log output of \"productbuild\" in case of\n-                    \/\/ error. It should help user to diagnose\n-                    \/\/ issue when using --mac-installer-sign-identity\n-                    Log.info(MessageFormat.format(I18N.getString(\n-                             \"error.tool.failed.with.output\"), \"productbuild\"));\n-                    Log.info(baos.toString().strip());\n-                    throw ioe;\n-                }\n-            }\n-\n-            return finalPKG;\n-        } catch (Exception ignored) {\n-            Log.verbose(ignored);\n-            return null;\n-        }\n-    }\n-\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-    \/\/ Implement Bundler\n-    \/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n-\n@@ -710,15 +46,0 @@\n-    private static boolean isValidBundleIdentifier(String id) {\n-        Objects.requireNonNull(id);\n-        for (int i = 0; i < id.length(); i++) {\n-            char a = id.charAt(i);\n-            \/\/ We check for ASCII codes first which we accept. If check fails,\n-            \/\/ check if it is acceptable extended ASCII or unicode character.\n-            if ((a >= 'A' && a <= 'Z') || (a >= 'a' && a <= 'z')\n-                    || (a >= '0' && a <= '9') || (a == '-' || a == '.')) {\n-                continue;\n-            }\n-            return false;\n-        }\n-        return true;\n-    }\n-\n@@ -731,0 +52,2 @@\n+            final var pkgPkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n+\n@@ -735,26 +58,0 @@\n-            String identifier = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);\n-            if (!isValidBundleIdentifier(identifier)) {\n-                throw new ConfigException(\n-                        MessageFormat.format(I18N.getString(\n-                        \"message.invalid-identifier\"), identifier),\n-                        I18N.getString(\"message.invalid-identifier.advice\"));\n-            }\n-\n-            \/\/ reject explicitly set sign to true and no valid signature key\n-            if (Optional.ofNullable(\n-                    SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.FALSE)) {\n-                if (!SIGNING_KEY_USER.getIsDefaultValue(params)) {\n-                    String signingIdentity =\n-                            DEVELOPER_ID_INSTALLER_SIGNING_KEY.fetchFrom(params);\n-                    if (signingIdentity == null) {\n-                        throw new ConfigException(\n-                                I18N.getString(\"error.explicit-sign-no-cert\"),\n-                                I18N.getString(\n-                                \"error.explicit-sign-no-cert.advice\"));\n-                    }\n-                }\n-\n-                \/\/ No need to validate --mac-installer-sign-identity, since it is\n-                \/\/ pass through option.\n-            }\n-\n@@ -777,1 +74,7 @@\n-        return bundle(params, outputParentDir);\n+\n+        final var pkg = MacFromParams.PKG_PACKAGE.fetchFrom(params);\n+        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+\n+        final var packager = MacPkgPackager.build().outputDir(outputParentDir).pkg(pkg).env(env);\n+\n+        return packager.execute();\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgBundler.java","additions":9,"deletions":706,"binary":false,"changes":715,"status":"modified"},{"patch":"@@ -0,0 +1,61 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.MacPkgPackage;\n+import jdk.jpackage.internal.model.MacPkgPackageMixin;\n+import jdk.jpackage.internal.model.PkgSigningConfig;\n+\n+final class MacPkgPackageBuilder {\n+\n+    MacPkgPackageBuilder(MacPackageBuilder pkgBuilder) {\n+        this.pkgBuilder = Objects.requireNonNull(pkgBuilder);\n+    }\n+\n+    MacPkgPackageBuilder signingBuilder(SigningIdentityBuilder v) {\n+        signingBuilder = v;\n+        return this;\n+    }\n+\n+    MacPkgPackage create() throws ConfigException {\n+        return MacPkgPackage.create(pkgBuilder.create(), new MacPkgPackageMixin.Stub(createSigningConfig()));\n+    }\n+\n+    private Optional<PkgSigningConfig> createSigningConfig() throws ConfigException {\n+        if (signingBuilder != null) {\n+            return signingBuilder.create().map(cfg -> {\n+                return new PkgSigningConfig.Stub(cfg.identity(), cfg.keychain().map(Keychain::name));\n+            });\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private final MacPackageBuilder pkgBuilder;\n+    private SigningIdentityBuilder signingBuilder;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackageBuilder.java","additions":61,"deletions":0,"binary":false,"changes":61,"status":"added"},{"patch":"@@ -0,0 +1,564 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.PathUtils.normalizedAbsolutePathString;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import jdk.internal.util.Architecture;\n+import jdk.internal.util.OSVersion;\n+import jdk.jpackage.internal.PackagingPipeline.PackageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.MacPkgPackage;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+import jdk.jpackage.internal.util.XmlUtils;\n+import org.xml.sax.SAXException;\n+\n+record MacPkgPackager(MacPkgPackage pkg, BuildEnv env, Optional<Services> services, Path outputDir) {\n+\n+    enum PkgPackageTaskID implements TaskID {\n+        PREPARE_MAIN_SCRIPTS,\n+        CREATE_DISTRIBUTION_XML_FILE,\n+        CREATE_COMPONENT_PLIST_FILE,\n+        PREPARE_SERVICES\n+    }\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    static final class Builder extends PackagerBuilder<MacPkgPackage, Builder> {\n+\n+        Path execute() throws PackagerException {\n+            Log.verbose(MessageFormat.format(I18N.getString(\"message.building-pkg\"),\n+                    pkg.app().name()));\n+\n+            IOUtils.writableOutputDir(outputDir);\n+\n+            return execute(MacPackagingPipeline.build(Optional.of(pkg)));\n+        }\n+\n+        @Override\n+        protected void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n+                StartupParameters startupParameters) {\n+            final var packager = new MacPkgPackager(pkg, startupParameters.packagingEnv(), createServices(), outputDir);\n+            packager.applyToPipeline(pipelineBuilder);\n+        }\n+\n+        private Optional<Services> createServices() {\n+            if (pkg.app().isService()) {\n+                return Optional.of(Services.create(pkg, env));\n+            } else {\n+                return Optional.empty();\n+            }\n+        }\n+    }\n+\n+    record InternalPackage(Path srcRoot, String identifier, Path path, List<String> otherPkgbuildArgs) {\n+\n+        InternalPackage {\n+            Objects.requireNonNull(srcRoot);\n+            Objects.requireNonNull(identifier);\n+            Objects.requireNonNull(path);\n+            Objects.requireNonNull(otherPkgbuildArgs);\n+        }\n+\n+        private List<String> allPkgbuildArgs() {\n+            final List<String> args = new ArrayList<>();\n+            args.add(\"--root\");\n+            args.add(normalizedAbsolutePathString(srcRoot));\n+            args.addAll(otherPkgbuildArgs);\n+            args.add(\"--identifier\");\n+            args.add(identifier);\n+            args.add(normalizedAbsolutePathString(path));\n+            return args;\n+        }\n+\n+        void build() {\n+            final List<String> cmdline = new ArrayList<>();\n+            cmdline.add(\"\/usr\/bin\/pkgbuild\");\n+            cmdline.addAll(allPkgbuildArgs());\n+            try {\n+                Files.createDirectories(path.getParent());\n+                IOUtils.exec(new ProcessBuilder(cmdline), false, null, true, Executor.INFINITE_TIMEOUT);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        }\n+    }\n+\n+    record Services(InternalPackage servicesPkg, Path servicesScriptsDir, InternalPackage supportPkg) {\n+\n+        Services {\n+            Objects.requireNonNull(servicesPkg);\n+            Objects.requireNonNull(servicesScriptsDir);\n+            Objects.requireNonNull(supportPkg);\n+        }\n+\n+        static Services create(MacPkgPackage pkg, BuildEnv env) {\n+            final var servicesRoot = env.buildRoot().resolve(\"services\");\n+            final var supportRoot = env.buildRoot().resolve(\"support\");\n+\n+            final var servicesScriptsDir = servicesRoot.resolve(\"scripts\");\n+\n+            final var servicesPkg = InternalPackageType.SERVICES.createInternalPackage(\n+                    servicesRoot.resolve(\"src\"), pkg, env, List.of(\n+                            \"--install-location\", \"\/\",\n+                            \"--scripts\", normalizedAbsolutePathString(servicesScriptsDir)));\n+\n+            final var supportPkg = InternalPackageType.SUPPORT.createInternalPackage(\n+                    supportRoot.resolve(\"src\"), pkg, env, List.of(\n+                            \"--install-location\", \"\/Library\/Application Support\"));\n+\n+            return new Services(servicesPkg, servicesScriptsDir, supportPkg);\n+        }\n+\n+        Stream<InternalPackage> asStream() {\n+            return Stream.of(servicesPkg, supportPkg);\n+        }\n+\n+        void prepareForPkgbuild(MacPkgPackage pkg, BuildEnv env) throws IOException {\n+            prepareSupportForPkgbuild(pkg, env, prepareServicesForPkgbuild(pkg, env));\n+        }\n+\n+        private Map<String, String> prepareServicesForPkgbuild(MacPkgPackage pkg, BuildEnv env) throws IOException {\n+            final var services = new MacLaunchersAsServices(BuildEnv.withAppImageDir(env, servicesPkg.srcRoot()), pkg);\n+\n+            final var data = services.create();\n+            data.put(\"SERVICES_PACKAGE_ID\", servicesPkg.identifier());\n+\n+            MacPkgInstallerScripts.createServicesScripts()\n+                    .setResourceDir(env.resourceDir().orElse(null))\n+                    .setSubstitutionData(data)\n+                    .saveInFolder(servicesScriptsDir);\n+\n+            return data;\n+        }\n+\n+        private void prepareSupportForPkgbuild(MacPkgPackage pkg, BuildEnv env,\n+                Map<String, String> servicesSubstitutionData) throws IOException {\n+            final var enqouter = Enquoter.forShellLiterals().setEnquotePredicate(str -> true);\n+\n+            final var mainInstallDir = Path.of(\"\/\").resolve(pkg.relativeInstallDir());\n+            final var supportInstallDir = Path.of(\"\/Library\/Application Support\").resolve(pkg.packageName());\n+\n+            Map<String, String> data = new HashMap<>(servicesSubstitutionData);\n+            data.put(\"APP_INSTALLATION_FOLDER\", enqouter.applyTo(mainInstallDir.toString()));\n+            data.put(\"SUPPORT_INSTALLATION_FOLDER\", enqouter.applyTo(supportInstallDir.toString()));\n+\n+            new ShellScriptResource(\"uninstall.command\")\n+                    .setResource(env.createResource(\"uninstall.command.template\")\n+                            .setCategory(I18N.getString(\"resource.pkg-uninstall-script\"))\n+                            .setPublicName(\"uninstaller\")\n+                            .setSubstitutionData(data))\n+                    .saveInFolder(supportPkg.srcRoot().resolve(pkg.app().name()));\n+        }\n+    }\n+\n+    private enum InternalPackageType implements TaskID {\n+        MAIN,\n+        SERVICES(\"services\"),\n+        SUPPORT(\"support\");\n+\n+        InternalPackage createInternalPackage(Path srcRoot, MacPkgPackage pkg, BuildEnv env, List<String> otherPkgbuildArgs) {\n+            return new InternalPackage(srcRoot, identifier(pkg), env.buildRoot().resolve(\"packages\").resolve(filename(pkg)), otherPkgbuildArgs);\n+        }\n+\n+        private InternalPackageType(String nameSuffix) {\n+            this.nameSuffix = Optional.of(nameSuffix);\n+        }\n+\n+        private InternalPackageType() {\n+            this.nameSuffix = Optional.empty();\n+        }\n+\n+        private String identifier(MacPkgPackage pkg) {\n+            final var baseIdentifier = pkg.app().bundleIdentifier();\n+            return nameSuffix.map(v -> baseIdentifier + \".\" + v).orElse(baseIdentifier);\n+        }\n+\n+        private String filename(MacPkgPackage pkg) {\n+            return String.format(\"%s-%s.pkg\", pkg.app().name(), nameSuffix.orElse(\"app\"));\n+        }\n+\n+        private final Optional<String> nameSuffix;\n+    }\n+\n+    private void applyToPipeline(PackagingPipeline.Builder pipelineBuilder) {\n+        pipelineBuilder\n+                .excludeDirFromCopying(outputDir)\n+                .task(PkgPackageTaskID.PREPARE_MAIN_SCRIPTS)\n+                        .action(this::prepareMainScripts)\n+                        .addDependent(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add()\n+                .task(PkgPackageTaskID.CREATE_DISTRIBUTION_XML_FILE)\n+                        .action(this::prepareDistributionXMLFile)\n+                        .addDependent(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add()\n+                .task(PkgPackageTaskID.CREATE_COMPONENT_PLIST_FILE)\n+                        .action(this::createComponentPlistFile)\n+                        .addDependent(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add()\n+                .task(PackageTaskID.CREATE_CONFIG_FILES)\n+                        .action(this::prepareConfigFiles)\n+                        .add()\n+                .task(PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .action(this::productbuild)\n+                        .addDependencies(InternalPackageType.values())\n+                        .addDependencies(PkgPackageTaskID.CREATE_DISTRIBUTION_XML_FILE, PkgPackageTaskID.CREATE_COMPONENT_PLIST_FILE)\n+                        .add()\n+                .task(PkgPackageTaskID.PREPARE_SERVICES)\n+                        .action(this::prepareServicesForBkgbuild)\n+                        .addDependent(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add()\n+                .task(InternalPackageType.SERVICES)\n+                        .action(this::buildServicesPKG)\n+                        .addDependencies(PkgPackageTaskID.PREPARE_SERVICES, PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add()\n+                .task(InternalPackageType.SUPPORT)\n+                        .action(this::buildSupportPKG)\n+                        .addDependencies(PkgPackageTaskID.PREPARE_SERVICES, PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add()\n+                .task(InternalPackageType.MAIN)\n+                        .action(this::buildMainPKG)\n+                        .addDependencies(PkgPackageTaskID.PREPARE_MAIN_SCRIPTS, PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                        .add();\n+\n+        final List<TaskID> disabledTasks = new ArrayList<>();\n+\n+        if (services.isEmpty()) {\n+            disabledTasks.addAll(List.of(PkgPackageTaskID.PREPARE_SERVICES, InternalPackageType.SERVICES, InternalPackageType.SUPPORT));\n+        }\n+\n+        if (scriptsRoot().isEmpty()) {\n+            disabledTasks.add(PkgPackageTaskID.PREPARE_MAIN_SCRIPTS);\n+        }\n+\n+        for (final var taskID : disabledTasks) {\n+            pipelineBuilder.task(taskID).noaction().add();\n+        }\n+    }\n+\n+    List<InternalPackage> internalPackages() {\n+        return Stream.concat(Stream.of(mainPkg()),\n+                services.map(Services::asStream).orElseGet(Stream::of)).toList();\n+    }\n+\n+    InternalPackage mainPkg() {\n+        final List<String> args = new ArrayList<>();\n+        args.add(\"--install-location\");\n+        args.add(normalizedAbsolutePathString(installLocation()));\n+        args.add(\"--component-plist\");\n+        args.add(normalizedAbsolutePathString(componentPlistFile()));\n+\n+        scriptsRoot().ifPresent(scriptsRoot -> {\n+            args.add(\"--scripts\");\n+            args.add(normalizedAbsolutePathString(scriptsRoot));\n+        });\n+\n+        return InternalPackageType.MAIN.createInternalPackage(env.appImageDir(), pkg, env, args);\n+    }\n+\n+    Optional<Path> scriptsRoot() {\n+        if (pkg.app().appStore() || pkg.isRuntimeInstaller()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(env.configDir().resolve(\"scripts\"));\n+        }\n+    }\n+\n+    Path componentPlistFile() {\n+        return env.configDir().resolve(\"cpl.plist\");\n+    }\n+\n+    Path installLocation() {\n+        return Path.of(\"\/\").resolve(pkg.relativeInstallDir()).getParent();\n+    }\n+\n+    Path distributionXmlFile() {\n+        return env.configDir().resolve(\"distribution.dist\");\n+    }\n+\n+    Path appStoreProductFile() {\n+        return env.configDir().resolve(\"product-def.plist\");\n+    }\n+\n+    Path backgroundImage() {\n+        return env.configDir().resolve(pkg.app().name() + \"-background.png\");\n+    }\n+\n+    Path backgroundImageDarkAqua() {\n+        return env.configDir().resolve(pkg.app().name() + \"-background-darkAqua.png\");\n+    }\n+\n+    private void addInternalPackageToInstallerGuiScript(InternalPackage internalPkg,\n+            XMLStreamWriter xml) throws IOException, XMLStreamException {\n+        xml.writeStartElement(\"pkg-ref\");\n+        xml.writeAttribute(\"id\", internalPkg.identifier());\n+        xml.writeEndElement(); \/\/ <\/pkg-ref>\n+        xml.writeStartElement(\"choice\");\n+        xml.writeAttribute(\"id\", internalPkg.identifier());\n+        xml.writeAttribute(\"visible\", \"false\");\n+        xml.writeStartElement(\"pkg-ref\");\n+        xml.writeAttribute(\"id\", internalPkg.identifier());\n+        xml.writeEndElement(); \/\/ <\/pkg-ref>\n+        xml.writeEndElement(); \/\/ <\/choice>\n+        xml.writeStartElement(\"pkg-ref\");\n+        xml.writeAttribute(\"id\", internalPkg.identifier());\n+        xml.writeAttribute(\"version\", pkg.version());\n+        xml.writeAttribute(\"onConclusion\", \"none\");\n+        try {\n+            xml.writeCharacters(new URI(null, null, internalPkg.path().getFileName().toString(), null).toASCIIString());\n+        } catch (URISyntaxException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+        xml.writeEndElement(); \/\/ <\/pkg-ref>\n+    }\n+\n+    private void prepareMainScripts() throws IOException {\n+        Log.verbose(I18N.getString(\"message.preparing-scripts\"));\n+\n+        final var scriptsRoot = scriptsRoot().orElseThrow();\n+\n+        Files.createDirectories(scriptsRoot);\n+\n+        final Map<String, String> data = new HashMap<>();\n+\n+        final var appLocation = pkg.asInstalledPackageApplicationLayout().orElseThrow().appDirectory();\n+\n+        data.put(\"INSTALL_LOCATION\", Path.of(\"\/\").resolve(pkg.relativeInstallDir()).toString());\n+        data.put(\"APP_LOCATION\", appLocation.toString());\n+\n+        MacPkgInstallerScripts.createAppScripts()\n+                .setResourceDir(env.resourceDir().orElse(null))\n+                .setSubstitutionData(data)\n+                .saveInFolder(scriptsRoot);\n+    }\n+\n+    private void prepareDistributionXMLFile() throws IOException {\n+        final var f = distributionXmlFile();\n+\n+        Log.verbose(MessageFormat.format(I18N.getString(\n+                \"message.preparing-distribution-dist\"), f.toAbsolutePath().toString()));\n+\n+        XmlUtils.createXml(f, xml -> {\n+            xml.writeStartElement(\"installer-gui-script\");\n+            xml.writeAttribute(\"minSpecVersion\", \"1\");\n+\n+            xml.writeStartElement(\"title\");\n+            xml.writeCharacters(pkg.app().name());\n+            xml.writeEndElement();\n+\n+            xml.writeStartElement(\"background\");\n+            xml.writeAttribute(\"file\", backgroundImage().getFileName().toString());\n+            xml.writeAttribute(\"mime-type\", \"image\/png\");\n+            xml.writeAttribute(\"alignment\", \"bottomleft\");\n+            xml.writeAttribute(\"scaling\", \"none\");\n+            xml.writeEndElement();\n+\n+            xml.writeStartElement(\"background-darkAqua\");\n+            xml.writeAttribute(\"file\", backgroundImageDarkAqua().getFileName().toString());\n+            xml.writeAttribute(\"mime-type\", \"image\/png\");\n+            xml.writeAttribute(\"alignment\", \"bottomleft\");\n+            xml.writeAttribute(\"scaling\", \"none\");\n+            xml.writeEndElement();\n+\n+            final var licFile = pkg.licenseFile();\n+            if (licFile.isPresent()) {\n+                xml.writeStartElement(\"license\");\n+                xml.writeAttribute(\"file\", licFile.orElseThrow().toAbsolutePath().toString());\n+                xml.writeAttribute(\"mime-type\", \"text\/rtf\");\n+                xml.writeEndElement();\n+            }\n+\n+            \/*\n+             * Note that the content of the distribution file\n+             * below is generated by productbuild --synthesize\n+             *\/\n+\n+            for (final var p : internalPackages()) {\n+                addInternalPackageToInstallerGuiScript(p, xml);\n+            }\n+\n+            xml.writeStartElement(\"options\");\n+            xml.writeAttribute(\"customize\", \"never\");\n+            xml.writeAttribute(\"require-scripts\", \"false\");\n+            xml.writeAttribute(\"hostArchitectures\", Architecture.isAARCH64() ? \"arm64\" : \"x86_64\");\n+            xml.writeEndElement(); \/\/ <\/options>\n+            xml.writeStartElement(\"choices-outline\");\n+            xml.writeStartElement(\"line\");\n+            xml.writeAttribute(\"choice\", \"default\");\n+            for (final var p : internalPackages()) {\n+                xml.writeStartElement(\"line\");\n+                xml.writeAttribute(\"choice\", p.identifier());\n+                xml.writeEndElement(); \/\/ <\/line>\n+            }\n+            xml.writeEndElement(); \/\/ <\/line>\n+            xml.writeEndElement(); \/\/ <\/choices-outline>\n+            xml.writeStartElement(\"choice\");\n+            xml.writeAttribute(\"id\", \"default\");\n+            xml.writeEndElement(); \/\/ <\/choice>\n+\n+            xml.writeEndElement(); \/\/ <\/installer-gui-script>\n+        });\n+    }\n+\n+    private void prepareConfigFiles() throws IOException {\n+        env.createResource(DEFAULT_BACKGROUND_IMAGE)\n+                .setCategory(I18N.getString(\"resource.pkg-background-image\"))\n+                .saveToFile(backgroundImage());\n+\n+        env.createResource(DEFAULT_BACKGROUND_IMAGE)\n+                .setCategory(I18N.getString(\"resource.pkg-background-image\"))\n+                .saveToFile(backgroundImageDarkAqua());\n+\n+        if (pkg.app().appStore()) {\n+            env.createResource(DEFAULT_PDF)\n+                    .setCategory(I18N.getString(\"resource.pkg-pdf\"))\n+                    .saveToFile(appStoreProductFile());\n+        }\n+    }\n+\n+    private void patchCPLFile(Path cpl) throws IOException {\n+        try (final var xsltResource = ResourceLocator.class.getResourceAsStream(\"adjust-component-plist.xsl\")) {\n+            final var srcXml =  new DOMSource(XmlUtils.initDocumentBuilder().parse(\n+                    new ByteArrayInputStream(Files.readAllBytes(cpl))));\n+            final var dstXml = new StreamResult(cpl.toFile());\n+            final var xslt = TransformerFactory.newInstance().newTransformer(new StreamSource(xsltResource));\n+            xslt.transform(srcXml, dstXml);\n+        } catch (TransformerException|SAXException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private void prepareServicesForBkgbuild() throws IOException {\n+        services.orElseThrow().prepareForPkgbuild(pkg, env);\n+    }\n+\n+    private void buildServicesPKG() {\n+        services.orElseThrow().servicesPkg().build();\n+    }\n+\n+    private void buildSupportPKG() {\n+        services.orElseThrow().supportPkg().build();\n+    }\n+\n+    private void buildMainPKG() throws IOException {\n+        mainPkg().build();\n+    }\n+\n+    private void createComponentPlistFile() throws IOException {\n+        final var cpl = componentPlistFile();\n+\n+        Files.createDirectories(cpl.getParent());\n+\n+        final var pb = new ProcessBuilder(\"\/usr\/bin\/pkgbuild\",\n+                \"--root\",\n+                normalizedAbsolutePathString(env.appImageDir()),\n+                \"--install-location\",\n+                normalizedAbsolutePathString(installLocation()),\n+                \"--analyze\",\n+                normalizedAbsolutePathString(cpl));\n+\n+        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+\n+        patchCPLFile(cpl);\n+    }\n+\n+    private void productbuild() throws IOException {\n+        final var finalPkg = outputDir.resolve(pkg.packageFileNameWithSuffix());\n+        Files.createDirectories(finalPkg.getParent());\n+\n+        List<String> commandLine = new ArrayList<>();\n+        commandLine.add(\"\/usr\/bin\/productbuild\");\n+\n+        commandLine.add(\"--resources\");\n+        commandLine.add(normalizedAbsolutePathString(env.configDir()));\n+\n+        \/\/ maybe sign\n+        if (pkg.sign()) {\n+            if (OSVersion.current().compareTo(new OSVersion(10, 12)) >= 0) {\n+                \/\/ we need this for OS X 10.12+\n+                Log.verbose(I18N.getString(\"message.signing.pkg\"));\n+            }\n+\n+            final var pkgSigningConfig = pkg.signingConfig().orElseThrow();\n+\n+            commandLine.add(\"--sign\");\n+            commandLine.add(pkgSigningConfig.identity().id());\n+\n+            pkgSigningConfig.keychain().map(Keychain::new).ifPresent(keychain -> {\n+                commandLine.add(\"--keychain\");\n+                commandLine.add(keychain.asCliArg());\n+            });\n+        }\n+\n+        if (pkg.app().appStore()) {\n+            commandLine.add(\"--product\");\n+            commandLine.add(normalizedAbsolutePathString(appStoreProductFile()));\n+            commandLine.add(\"--component\");\n+            Path p = env.appImageDir().resolve(pkg.app().appImageDirName());\n+            commandLine.add(p.toAbsolutePath().toString());\n+            commandLine.add(normalizedAbsolutePathString(installLocation()));\n+        } else {\n+            commandLine.add(\"--distribution\");\n+            commandLine.add(normalizedAbsolutePathString(distributionXmlFile()));\n+            commandLine.add(\"--package-path\");\n+            \/\/ Assume all internal .pkg files reside in the same directory.\n+            commandLine.add(normalizedAbsolutePathString(mainPkg().path().getParent()));\n+        }\n+        commandLine.add(normalizedAbsolutePathString(finalPkg));\n+\n+        final var pb = new ProcessBuilder(commandLine);\n+        IOUtils.exec(pb, false, null, true, Executor.INFINITE_TIMEOUT);\n+    }\n+\n+    private static final String DEFAULT_BACKGROUND_IMAGE = \"background_pkg.png\";\n+    private static final String DEFAULT_PDF = \"product-def.plist\";\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacPkgPackager.java","additions":564,"deletions":0,"binary":false,"changes":564,"status":"added"},{"patch":"@@ -0,0 +1,245 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.MacCertificateUtils.findCertificates;\n+\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.X509Certificate;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import javax.naming.InvalidNameException;\n+import javax.naming.ldap.LdapName;\n+import javax.naming.ldap.Rdn;\n+import javax.security.auth.x500.X500Principal;\n+import jdk.jpackage.internal.MacCertificateUtils.CertificateHash;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.SigningIdentity;\n+\n+final class SigningIdentityBuilder {\n+\n+    static class SigningConfigException extends ConfigException {\n+        SigningConfigException(ConfigException ex) {\n+            super(ex.getMessage(), ex.getAdvice(), ex.getCause());\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    static class ExpiredCertificateException extends SigningConfigException {\n+        ExpiredCertificateException(ConfigException ex) {\n+            super(ex);\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    record SigningConfig(SigningIdentity identity, Optional<Keychain> keychain) {\n+        SigningConfig {\n+            Objects.requireNonNull(identity);\n+            Objects.requireNonNull(keychain);\n+        }\n+    }\n+\n+    SigningIdentityBuilder signingIdentity(String v) {\n+        signingIdentity = v;\n+        return this;\n+    }\n+\n+    SigningIdentityBuilder certificateSelector(CertificateSelector v) {\n+        certificateSelector = v;\n+        return this;\n+    }\n+\n+    SigningIdentityBuilder keychain(String v) {\n+        keychain = v;\n+        return this;\n+    }\n+\n+    Optional<SigningConfig> create() throws ConfigException {\n+        if (signingIdentity == null && certificateSelector == null) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(new SigningConfig(validatedSigningIdentity(), validatedKeychain()));\n+        }\n+    }\n+\n+    private Optional<Keychain> validatedKeychain() throws ConfigException {\n+        return Optional.ofNullable(keychain).map(Keychain::new);\n+    }\n+\n+    private SigningIdentity validatedSigningIdentity() throws ConfigException {\n+        if (signingIdentity != null) {\n+            return new SigningIdentityImpl(signingIdentity);\n+        }\n+\n+        Objects.requireNonNull(certificateSelector);\n+\n+        final var validatedKeychain = validatedKeychain();\n+\n+        final var allCertificates = findCertificates(validatedKeychain, Optional.empty());\n+\n+        final var mappedCertficates = allCertificates.stream().<Map.Entry<String, X509Certificate>>mapMulti((cert, acc) -> {\n+            findSubjectCNs(cert).stream().map(cn -> {\n+                return Map.entry(cn, cert);\n+            }).forEach(acc::accept);\n+        }).toList();\n+\n+        final var signingIdentityNames = certificateSelector.signingIdentities();\n+\n+        var matchingCertificates = mappedCertficates.stream().filter(e -> {\n+            return signingIdentityNames.contains(e.getKey());\n+        }).map(Map.Entry::getValue).toList();\n+\n+        if (matchingCertificates.isEmpty()) {\n+            matchingCertificates = mappedCertficates.stream().filter(e -> {\n+                return signingIdentityNames.stream().anyMatch(filter -> {\n+                    return filter.startsWith(e.getKey());\n+                });\n+            }).map(Map.Entry::getValue).toList();\n+        }\n+\n+        final var cert = selectSigningIdentity(matchingCertificates,\n+                certificateSelector, validatedKeychain);\n+\n+        try {\n+            cert.checkValidity();\n+        } catch (CertificateExpiredException|CertificateNotYetValidException ex) {\n+            throw new ExpiredCertificateException(I18N.buildConfigException(\"error.certificate.expired\", findSubjectCNs(cert).getFirst()).create());\n+        }\n+\n+        final var signingIdentityHash = CertificateHash.of(cert);\n+\n+        return new SigningIdentityImpl(signingIdentityHash.toString());\n+    }\n+\n+    private static X509Certificate selectSigningIdentity(List<X509Certificate> certs,\n+            CertificateSelector certificateSelector, Optional<Keychain> keychain) throws ConfigException {\n+        Objects.requireNonNull(certificateSelector);\n+        Objects.requireNonNull(keychain);\n+        switch (certs.size()) {\n+            case 0 -> {\n+                Log.error(I18N.format(\"error.cert.not.found\", certificateSelector.signingIdentities().getFirst(),\n+                        keychain.map(Keychain::name).orElse(\"\")));\n+                throw I18N.buildConfigException(\"error.explicit-sign-no-cert\")\n+                        .advice(\"error.explicit-sign-no-cert.advice\").create();\n+            }\n+            case 1 -> {\n+                return certs.getFirst();\n+            }\n+            default -> {\n+                Log.error(I18N.format(\"error.multiple.certs.found\", certificateSelector.signingIdentities().getFirst(),\n+                        keychain.map(Keychain::name).orElse(\"\")));\n+                return certs.getFirst();\n+            }\n+        }\n+    }\n+\n+    private static List<String> findSubjectCNs(X509Certificate cert) {\n+        final LdapName ldapName;\n+        try {\n+            ldapName = new LdapName(cert.getSubjectX500Principal().getName(X500Principal.RFC2253));\n+        } catch (InvalidNameException e) {\n+            return List.of();\n+        }\n+\n+        return ldapName.getRdns().stream().filter(rdn -> {\n+            return rdn.getType().equalsIgnoreCase(\"CN\");\n+        }).map(Rdn::getValue).map(Object::toString).distinct().toList();\n+    }\n+\n+    record CertificateSelector(String name, List<StandardCertificatePrefix> prefixes) {\n+        CertificateSelector {\n+            Objects.requireNonNull(prefixes);\n+            prefixes.forEach(Objects::requireNonNull);\n+            Objects.requireNonNull(name);\n+        }\n+\n+        List<String> signingIdentities() {\n+            if (prefixes().isEmpty()) {\n+                return List.of(name);\n+            } else {\n+                return prefixes.stream().map(StandardCertificatePrefix::value).map(prefix -> {\n+                    return prefix + name;\n+                }).toList();\n+            }\n+        }\n+    }\n+\n+    enum StandardCertificatePrefix {\n+        APP_SIGN_APP_STORE(\"3rd Party Mac Developer Application\"),\n+        INSTALLER_SIGN_APP_STORE(\"3rd Party Mac Developer Installer\"),\n+        APP_SIGN_PERSONAL(\"Developer ID Application\"),\n+        INSTALLER_SIGN_PERSONAL(\"Developer ID Installer\");\n+\n+        StandardCertificatePrefix(String value) {\n+            this.value = value + \": \";\n+        }\n+\n+        String value() {\n+            return value;\n+        }\n+\n+        static Optional<StandardCertificatePrefix> findStandardCertificatePrefix(String certificateLocator) {\n+            Objects.requireNonNull(certificateLocator);\n+            return Stream.of(StandardCertificatePrefix.values()).filter(prefix -> {\n+                return certificateLocator.startsWith(prefix.value);\n+            }).reduce((x, y) -> {\n+                throw new UnsupportedOperationException();\n+            });\n+        }\n+\n+        private final String value;\n+    }\n+\n+    enum StandardCertificateSelector {\n+        APP_IMAGE(StandardCertificatePrefix.APP_SIGN_PERSONAL),\n+        PKG_INSTALLER(StandardCertificatePrefix.INSTALLER_SIGN_PERSONAL),\n+        APP_STORE_APP_IMAGE(StandardCertificatePrefix.APP_SIGN_PERSONAL, StandardCertificatePrefix.APP_SIGN_APP_STORE),\n+        APP_STORE_PKG_INSTALLER(StandardCertificatePrefix.INSTALLER_SIGN_PERSONAL, StandardCertificatePrefix.INSTALLER_SIGN_APP_STORE);\n+\n+        StandardCertificateSelector(StandardCertificatePrefix ... prefixes) {\n+            this.prefixes = List.of(prefixes);\n+        }\n+\n+        static CertificateSelector create(String certificateLocator, StandardCertificateSelector defaultSelector) {\n+            return StandardCertificatePrefix.findStandardCertificatePrefix(certificateLocator).map(prefix -> {\n+                return new CertificateSelector(certificateLocator, List.of());\n+            }).orElseGet(() -> {\n+                return new CertificateSelector(certificateLocator, defaultSelector.prefixes);\n+            });\n+        }\n+\n+        private final List<StandardCertificatePrefix> prefixes;\n+    }\n+\n+    private String signingIdentity;\n+    private CertificateSelector certificateSelector;\n+    private String keychain;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/SigningIdentityBuilder.java","additions":245,"deletions":0,"binary":false,"changes":245,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.CodesignConfig.ADHOC_SIGNING_IDENTITY;\n+\n+import java.util.Objects;\n+import jdk.jpackage.internal.model.SigningIdentity;\n+\n+record SigningIdentityImpl(String id) implements SigningIdentity {\n+\n+    SigningIdentityImpl {\n+        Objects.requireNonNull(id);\n+\n+        if (ADHOC_SIGNING_IDENTITY.equals(id)) {\n+            throw new IllegalArgumentException(\"Adhoc signing identity not allowed\");\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/SigningIdentityImpl.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import jdk.internal.util.OSVersion;\n+import jdk.jpackage.internal.util.function.ThrowingConsumer;\n+\n+final class TempKeychain implements Closeable {\n+\n+    static void withKeychains(ThrowingConsumer<List<Keychain>> keychainConsumer, List<Keychain> keychains) throws Throwable {\n+        keychains.forEach(Objects::requireNonNull);\n+        if (keychains.isEmpty() || OSVersion.current().compareTo(new OSVersion(10, 12)) < 0) {\n+            keychainConsumer.accept(keychains);\n+        } else {\n+            \/\/ we need this for OS X 10.12+\n+            try (var tempKeychain = new TempKeychain(keychains)) {\n+                keychainConsumer.accept(tempKeychain.keychains);\n+            }\n+        }\n+    }\n+\n+    static void withKeychain(ThrowingConsumer<Keychain> keychainConsumer, Keychain keychain) throws Throwable {\n+        Objects.requireNonNull(keychainConsumer);\n+        withKeychains(keychains -> {\n+            keychainConsumer.accept(keychains.getFirst());\n+        }, List.of(keychain));\n+    }\n+\n+    TempKeychain(List<Keychain> keychains) throws IOException {\n+        this.keychains = Objects.requireNonNull(keychains);\n+\n+        final var currentKeychains = Keychain.listKeychains();\n+\n+        final var currentKeychainPaths = currentKeychains.stream().map(Keychain::path).toList();\n+\n+        final var missingKeychains = keychains.stream().filter(k -> {\n+            return !currentKeychainPaths.contains(k.path());\n+        }).toList();\n+\n+        if (missingKeychains.isEmpty()) {\n+            restoreKeychainsCmd = List.of();\n+        } else {\n+            List<String> args = new ArrayList<>();\n+            args.add(\"\/usr\/bin\/security\");\n+            args.add(\"list-keychains\");\n+            args.add(\"-s\");\n+            args.addAll(currentKeychains.stream().map(Keychain::asCliArg).toList());\n+\n+            restoreKeychainsCmd = List.copyOf(args);\n+\n+            args.addAll(missingKeychains.stream().map(Keychain::asCliArg).toList());\n+\n+            Executor.of(args.toArray(String[]::new)).executeExpectSuccess();\n+        }\n+    }\n+\n+    List<Keychain> keychains() {\n+        return keychains;\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        if (!restoreKeychainsCmd.isEmpty()) {\n+            Executor.of(restoreKeychainsCmd.toArray(String[]::new)).executeExpectSuccess();\n+        }\n+    }\n+\n+    private final List<Keychain> keychains;\n+    private final List<String> restoreKeychainsCmd;\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/TempKeychain.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+public interface AppImageSigningConfig {\n+\n+    SigningIdentity identity();\n+\n+    String identifierPrefix();\n+\n+    Optional<Path> entitlements();\n+\n+    String entitlementsResourceName();\n+\n+    Optional<String> keychain();\n+\n+    record Stub(SigningIdentity identity, String identifierPrefix, Optional<Path> entitlements,\n+            Optional<String> keychain, String entitlementsResourceName) implements AppImageSigningConfig {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/AppImageSigningConfig.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,104 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.nio.file.Path;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface MacApplication extends Application, MacApplicationMixin {\n+\n+    default DottedVersion shortVersion() {\n+        final var verComponents = DottedVersion.lazy(version()).getComponents();\n+        \/\/ Short version should have exactly three components according to\n+        \/\/ https:\/\/developer.apple.com\/documentation\/bundleresources\/information-property-list\/cfbundleshortversionstring\n+        int maxComponentCount = 3;\n+        \/\/ However, if the number of components is less than three, historically, jpackage will not add missing components.\n+        maxComponentCount = Integer.min(maxComponentCount, verComponents.length);\n+        return DottedVersion.greedy(IntStream.range(0, maxComponentCount).mapToObj(idx -> {\n+            if (idx < verComponents.length) {\n+                return verComponents[idx].toString();\n+            } else {\n+                return \"0\";\n+            }\n+        }).collect(joining(\".\")));\n+    }\n+\n+    @Override\n+    default Path appImageDirName() {\n+        if (isRuntime()) {\n+            return Application.super.appImageDirName();\n+        } else {\n+            return Path.of(Application.super.appImageDirName().toString() + \".app\");\n+        }\n+    }\n+\n+    \/**\n+     * Returns {@code true} if the application image of this application should be\n+     * signed.\n+     *\n+     * @return {@code true} if the application image of this application should be\n+     *         signed\n+     *\/\n+    default boolean sign() {\n+        return signingConfig().isPresent();\n+    }\n+\n+    @Override\n+    default Map<String, String> extraAppImageFileData() {\n+        return Stream.of(ExtraAppImageFileField.values()).collect(toMap(ExtraAppImageFileField::fieldName, x -> x.asString(this)));\n+    }\n+\n+    public static MacApplication create(Application app, MacApplicationMixin mixin) {\n+        return CompositeProxy.create(MacApplication.class, app, mixin);\n+    }\n+\n+    public enum ExtraAppImageFileField {\n+        SIGNED(\"signed\", app -> Boolean.toString(app.sign())),\n+        APP_STORE(\"app-store\", app -> Boolean.toString(app.appStore()));\n+\n+        ExtraAppImageFileField(String fieldName, Function<MacApplication, String> getter) {\n+            this.fieldName = fieldName;\n+            this.getter = getter;\n+        }\n+\n+        public String fieldName() {\n+            return fieldName;\n+        }\n+\n+        String asString(MacApplication app) {\n+            return getter.apply(app);\n+        }\n+\n+        private final String fieldName;\n+        private final Function<MacApplication, String> getter;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacApplication.java","additions":104,"deletions":0,"binary":false,"changes":104,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+public interface MacApplicationMixin {\n+\n+    Optional<Path> icon();\n+\n+    String bundleName();\n+\n+    String bundleIdentifier();\n+\n+    String category();\n+\n+    boolean appStore();\n+\n+    Optional<AppImageSigningConfig> signingConfig();\n+\n+    record Stub(Optional<Path> icon, String bundleName, String bundleIdentifier, String category,\n+            boolean appStore, Optional<AppImageSigningConfig> signingConfig) implements MacApplicationMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacApplicationMixin.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface MacDmgPackage extends MacPackage, MacDmgPackageMixin {\n+\n+    public static MacDmgPackage create(MacPackage pkg, MacDmgPackageMixin mixin) {\n+        return CompositeProxy.create(MacDmgPackage.class, pkg, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacDmgPackage.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface MacDmgPackageMixin {\n+\n+    Optional<Path> icon();\n+\n+    \/**\n+     * Returns additional top=level content for DMG package.\n+     * <p>\n+     * Each item in the list can be a directory or a file.\n+     *\n+     * @return the additional top=level content for DMG package\n+     *\/\n+    List<Path> content();\n+\n+    record Stub(Optional<Path> icon, List<Path> content) implements MacDmgPackageMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacDmgPackageMixin.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface MacFileAssociation extends FileAssociation, MacFileAssociationMixin {\n+\n+    public static MacFileAssociation create(FileAssociation fa, MacFileAssociationMixin mixin) {\n+        return CompositeProxy.create(MacFileAssociation.class, fa, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacFileAssociation.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,60 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.List;\n+import java.util.Optional;\n+\n+public interface MacFileAssociationMixin {\n+\n+    String cfBundleTypeName();\n+\n+    String cfBundleTypeRole();\n+\n+    String lsHandlerRank();\n+\n+    Optional<Boolean> lsTypeIsPackage();\n+\n+    Optional<String> nsDocumentClass();\n+\n+    Optional<String> nsPersistentStoreTypeKey();\n+\n+    Optional<Boolean> lsSupportsOpeningDocumentsInPlace();\n+\n+    Optional<Boolean> uiSupportsDocumentBrowser();\n+\n+    List<String> utTypeConformsTo();\n+\n+    List<String> nsExportableTypes();\n+\n+    record Stub(String cfBundleTypeName, String cfBundleTypeRole,\n+            String lsHandlerRank, Optional<Boolean> lsTypeIsPackage, Optional<String> nsDocumentClass,\n+            Optional<String> nsPersistentStoreTypeKey,\n+            Optional<Boolean> lsSupportsOpeningDocumentsInPlace,\n+            Optional<Boolean> uiSupportsDocumentBrowser, List<String> utTypeConformsTo,\n+            List<String> nsExportableTypes) implements MacFileAssociationMixin {\n+\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacFileAssociationMixin.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface MacLauncher extends Launcher {\n+\n+    public static MacLauncher create(Launcher launcher) {\n+        return CompositeProxy.create(MacLauncher.class, launcher);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacLauncher.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface MacPackage extends Package, MacPackageMixin {\n+\n+    MacApplication app();\n+\n+    @Override\n+    default AppImageLayout appImageLayout() {\n+        if (isRuntimeInstaller()) {\n+            return RUNTIME_PACKAGE_LAYOUT;\n+        } else {\n+            return Package.super.appImageLayout();\n+        }\n+    }\n+\n+    default Path installDir() {\n+        return Path.of(\"\/\").resolve(relativeInstallDir());\n+    }\n+\n+    public static MacPackage create(Package pkg, MacPackageMixin mixin) {\n+        return CompositeProxy.create(MacPackage.class, pkg, mixin);\n+    }\n+\n+    public static final RuntimeLayout RUNTIME_PACKAGE_LAYOUT = RuntimeLayout.create(Path.of(\"Contents\/Home\"));\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPackage.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Optional;\n+\n+public interface MacPackageMixin {\n+\n+    \/**\n+     * Gets sign status of the predefined app image.\n+     * <p>\n+     * Returns {@code Optional.of(Boolean.TRUE)} if the predefined app image is\n+     * available and is signed.\n+     * <p>\n+     * Returns {@code Optional.of(Boolean.FALSE)} if the predefined app image is\n+     * available and is unsigned.\n+     * <p>\n+     * Returns any empty {@link Optional} instance if the predefined app image is\n+     * unavailable.\n+     *\n+     * @return sign status of the predefined app image if any\n+     *\/\n+    Optional<Boolean> predefinedAppImageSigned();\n+\n+    record Stub(Optional<Boolean> predefinedAppImageSigned) implements MacPackageMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPackageMixin.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,43 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface MacPkgPackage extends MacPackage, MacPkgPackageMixin {\n+\n+    \/**\n+     * Returns {@code true} if this PKG installer should be signed.\n+     *\n+     * @return {@code true} if this PKG installer should be signed\n+     *\/\n+    default boolean sign() {\n+        return signingConfig().isPresent();\n+    }\n+\n+    public static MacPkgPackage create(MacPackage pkg, MacPkgPackageMixin mixin) {\n+        return CompositeProxy.create(MacPkgPackage.class, pkg, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPkgPackage.java","additions":43,"deletions":0,"binary":false,"changes":43,"status":"added"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Optional;\n+\n+public interface MacPkgPackageMixin {\n+\n+    Optional<PkgSigningConfig> signingConfig();\n+\n+    record Stub(Optional<PkgSigningConfig> signingConfig) implements MacPkgPackageMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/MacPkgPackageMixin.java","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Optional;\n+\n+public interface PkgSigningConfig {\n+\n+    SigningIdentity identity();\n+\n+    Optional<String> keychain();\n+\n+    record Stub(SigningIdentity identity, Optional<String> keychain) implements PkgSigningConfig {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/PkgSigningConfig.java","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+public interface SigningIdentity {\n+\n+    String id();\n+\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/model\/SigningIdentity.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n+<!--\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+-->\n+\n+<!--\n+  This stylesheet adjusts .plist file produced by `\/usr\/bin\/pkgbuild &#45;&#45;analyze`.\n+-->\n+<xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http:\/\/www.w3.org\/1999\/XSL\/Transform\">\n+\n+  <!--\n+    Make bundle NOT-relocatable\n+  -->\n+  <xsl:template match=\"true[preceding-sibling::key[1] = 'BundleIsRelocatable']\">\n+    <false\/>\n+  <\/xsl:template>\n+\n+  <!--\n+    Remove `ChildBundles` key with value\n+  -->\n+  <xsl:template match=\"key[. = 'ChildBundles']|array[preceding-sibling::key[1] = 'ChildBundles']\"\/>\n+\n+  <!--\n+    Identity transform\n+  -->\n+  <xsl:template match=\"@*|node()\">\n+    <xsl:copy>\n+      <xsl:apply-templates select=\"@*|node()\"\/>\n+    <\/xsl:copy>\n+  <\/xsl:template>\n+\n+<\/xsl:stylesheet>\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/resources\/adjust-component-plist.xsl","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,123 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static jdk.jpackage.internal.util.XmlUtils.toXmlConsumer;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamWriter;\n+\n+public final class PListWriter {\n+\n+    public static void writeBoolean(XMLStreamWriter xml, String key, boolean value)\n+            throws XMLStreamException {\n+        writeKey(xml, key);\n+        xml.writeEmptyElement(Boolean.toString(value));\n+    }\n+\n+    public static void writeBooleanOptional(XMLStreamWriter xml, String key, Optional<Boolean> value)\n+            throws XMLStreamException {\n+        if (value.isPresent()) {\n+            writeBoolean(xml, key, value.orElseThrow());\n+        }\n+    }\n+\n+    public static void writeString(XMLStreamWriter xml, String key, Object value)\n+            throws XMLStreamException {\n+        writeKey(xml, key);\n+        writeString(xml, value);\n+    }\n+\n+    public static void writeStringOptional(XMLStreamWriter xml, String key, Optional<?> value)\n+            throws XMLStreamException {\n+        if (value.isPresent()) {\n+            writeString(xml, key, value.orElseThrow());\n+        }\n+    }\n+\n+    public static void writeStringArray(XMLStreamWriter xml, String key, Collection<?> values)\n+            throws XMLStreamException, IOException {\n+        if (!values.isEmpty()) {\n+            writeKey(xml, key);\n+            writeArray(xml, toXmlConsumer(() -> {\n+                for (var v : values) {\n+                    writeString(xml, v);\n+                }\n+            }));\n+        }\n+    }\n+\n+    public static void writeStringArray(XMLStreamWriter xml, String key, Object... values)\n+            throws XMLStreamException, IOException {\n+        writeStringArray(xml, key, List.of(values));\n+    }\n+\n+    public static void writeDict(XMLStreamWriter xml, XmlConsumer content)\n+            throws XMLStreamException, IOException {\n+        writeElement(xml, \"dict\", content);\n+    }\n+\n+    public static void writeArray(XMLStreamWriter xml, XmlConsumer content)\n+            throws XMLStreamException, IOException {\n+        writeElement(xml, \"array\", content);\n+    }\n+\n+    public static void writePList(XMLStreamWriter xml, XmlConsumer content)\n+            throws XMLStreamException, IOException {\n+        xml.writeDTD(\"plist PUBLIC \\\"-\/\/Apple\/\/DTD PLIST 1.0\/\/EN\\\" \\\"https:\/\/www.apple.com\/DTDs\/PropertyList-1.0.dtd\\\"\");\n+        xml.writeStartElement(\"plist\");\n+        xml.writeAttribute(\"version\", \"1.0\");\n+        content.accept(xml);\n+        xml.writeEndElement();\n+    }\n+\n+    public static void writeKey(XMLStreamWriter xml, String key)\n+            throws XMLStreamException {\n+        writeElement(xml, \"key\", key);\n+    }\n+\n+    private static void writeString(XMLStreamWriter xml, Object value)\n+            throws XMLStreamException {\n+        writeElement(xml, \"string\", value.toString());\n+    }\n+\n+    private static void writeElement(XMLStreamWriter xml, String name, String value)\n+            throws XMLStreamException {\n+        xml.writeStartElement(name);\n+        xml.writeCharacters(value);\n+        xml.writeEndElement();\n+    }\n+\n+    private static void writeElement(XMLStreamWriter xml, String name, XmlConsumer content)\n+            throws XMLStreamException, IOException {\n+        xml.writeStartElement(name);\n+        content.accept(xml);\n+        xml.writeEndElement();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/util\/PListWriter.java","additions":123,"deletions":0,"binary":false,"changes":123,"status":"added"},{"patch":"@@ -1,166 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Map;\n-import java.util.List;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.SOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_CONTENT;\n-import static jdk.jpackage.internal.StandardBundlerParam.OUTPUT_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import jdk.jpackage.internal.resources.ResourceLocator;\n-import jdk.jpackage.internal.util.FileUtils;\n-import jdk.jpackage.internal.util.PathUtils;\n-\n-\/*\n- * AbstractAppImageBuilder\n- *     This is sub-classed by each of the platform dependent AppImageBuilder\n- * classes, and contains resource processing code common to all platforms.\n- *\/\n-\n-public abstract class AbstractAppImageBuilder {\n-\n-    private final Path root;\n-    protected final ApplicationLayout appLayout;\n-\n-    public AbstractAppImageBuilder(Path root) {\n-        this.root = root;\n-        appLayout = ApplicationLayout.platformAppImage().resolveAt(root);\n-    }\n-\n-    public InputStream getResourceAsStream(String name) {\n-        return ResourceLocator.class.getResourceAsStream(name);\n-    }\n-\n-    public abstract void prepareApplicationFiles(\n-            Map<String, ? super Object> params) throws IOException;\n-\n-    protected boolean withAppImageFile(Map<String, ? super Object> params) {\n-        return true;\n-    }\n-\n-    protected void writeCfgFile(Map<String, ? super Object> params) throws\n-            IOException {\n-        new CfgFile().initFromParams(params).create(root);\n-    }\n-\n-    ApplicationLayout getAppLayout() {\n-        return appLayout;\n-    }\n-\n-    protected void copyApplication(Map<String, ? super Object> params)\n-            throws IOException {\n-        Path inputPath = SOURCE_DIR.fetchFrom(params);\n-        if (inputPath != null) {\n-            inputPath = inputPath.toAbsolutePath();\n-\n-            List<Path> excludes = new ArrayList<>();\n-\n-            for (var path : List.of(TEMP_ROOT.fetchFrom(params), OUTPUT_DIR.fetchFrom(params), root)) {\n-                if (Files.isDirectory(path)) {\n-                    path = path.toAbsolutePath();\n-                    if (path.startsWith(inputPath) && !Files.isSameFile(path, inputPath)) {\n-                        excludes.add(path);\n-                    }\n-                }\n-            }\n-\n-            FileUtils.copyRecursive(inputPath,\n-                    appLayout.appDirectory().toAbsolutePath(), excludes);\n-        }\n-\n-        if (withAppImageFile(params)) {\n-            AppImageFile.save(root, params);\n-        }\n-\n-        List<String> items = APP_CONTENT.fetchFrom(params);\n-        for (String item : items) {\n-            FileUtils.copyRecursive(Path.of(item),\n-                appLayout.contentDirectory().resolve(Path.of(item).getFileName()));\n-        }\n-    }\n-\n-    public static OverridableResource createIconResource(String defaultIconName,\n-            BundlerParamInfo<Path> iconParam, Map<String, ? super Object> params,\n-            Map<String, ? super Object> mainParams) throws IOException {\n-\n-        if (mainParams != null) {\n-            params = AddLauncherArguments.merge(mainParams, params, ICON.getID(),\n-                    iconParam.getID());\n-        }\n-\n-        final String resourcePublicName = APP_NAME.fetchFrom(params)\n-                + PathUtils.getSuffix(Path.of(defaultIconName));\n-\n-        IconType iconType = getLauncherIconType(params);\n-        if (iconType == IconType.NoIcon) {\n-            return null;\n-        }\n-\n-        OverridableResource resource = createResource(defaultIconName, params)\n-                .setCategory(\"icon\")\n-                .setExternal(iconParam.fetchFrom(params))\n-                .setPublicName(resourcePublicName);\n-\n-        if (iconType == IconType.DefaultOrResourceDirIcon && mainParams != null) {\n-            \/\/ No icon explicitly configured for this launcher.\n-            \/\/ Dry-run resource creation to figure out its source.\n-            final Path nullPath = null;\n-            if (resource.saveToFile(nullPath)\n-                    != OverridableResource.Source.ResourceDir) {\n-                \/\/ No icon in resource dir for this launcher, inherit icon\n-                \/\/ configured for the main launcher.\n-                resource = createIconResource(defaultIconName, iconParam,\n-                        mainParams, null).setLogPublicName(resourcePublicName);\n-            }\n-        }\n-\n-        return resource;\n-    }\n-\n-    private enum IconType { DefaultOrResourceDirIcon, CustomIcon, NoIcon };\n-\n-    private static IconType getLauncherIconType(Map<String, ? super Object> params) {\n-        Path launcherIcon = ICON.fetchFrom(params);\n-        if (launcherIcon == null) {\n-            return IconType.DefaultOrResourceDirIcon;\n-        }\n-\n-        if (launcherIcon.toFile().getName().isEmpty()) {\n-            return IconType.NoIcon;\n-        }\n-\n-        return IconType.CustomIcon;\n-    }\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractAppImageBuilder.java","additions":0,"deletions":166,"binary":false,"changes":166,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,8 +43,0 @@\n-    static final BundlerParamInfo<Path> IMAGES_ROOT =\n-            new StandardBundlerParam<>(\n-            \"imagesRoot\",\n-            Path.class,\n-            params ->\n-                StandardBundlerParam.TEMP_ROOT.fetchFrom(params).resolve(\"images\"),\n-            (s, p) -> null);\n-\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AbstractBundler.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -28,3 +28,4 @@\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.model.ConfigException;\n-import jdk.jpackage.internal.model.PackagerException;\n+import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n+import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n+\n@@ -37,5 +38,3 @@\n-import java.util.function.Function;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.PackagerException;\n@@ -89,3 +88,2 @@\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            return PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-        }\n+\n+        final var predefinedAppImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n@@ -94,1 +92,8 @@\n-            return createAppBundle(params, outputParentDir);\n+            if (predefinedAppImage == null) {\n+                Path rootDirectory = createRoot(params, outputParentDir);\n+                appImageSupplier.prepareApplicationFiles(params, rootDirectory);\n+                return rootDirectory;\n+            } else {\n+                appImageSupplier.prepareApplicationFiles(params, predefinedAppImage);\n+                return predefinedAppImage;\n+            }\n@@ -97,1 +102,1 @@\n-        } catch (RuntimeException|IOException|ConfigException ex) {\n+        } catch (RuntimeException|IOException ex) {\n@@ -113,4 +118,2 @@\n-    final AppImageBundler setDependentTask(boolean v) {\n-        dependentTask = v;\n-        return this;\n-    }\n+    @FunctionalInterface\n+    static interface AppImageSupplier {\n@@ -118,2 +121,2 @@\n-    final boolean isDependentTask() {\n-        return dependentTask;\n+        void prepareApplicationFiles(Map<String, ? super Object> params,\n+                Path root) throws PackagerException, IOException;\n@@ -122,2 +125,1 @@\n-    final AppImageBundler setAppImageSupplier(\n-            Function<Path, AbstractAppImageBuilder> v) {\n+    final AppImageBundler setAppImageSupplier(AppImageSupplier v) {\n@@ -148,5 +150,3 @@\n-        if (!dependentTask) {\n-            Log.verbose(MessageFormat.format(\n-                    I18N.getString(\"message.creating-app-bundle\"),\n-                    imageName, outputDirectory.toAbsolutePath()));\n-        }\n+        Log.verbose(MessageFormat.format(\n+                I18N.getString(\"message.creating-app-bundle\"),\n+                imageName, outputDirectory.toAbsolutePath()));\n@@ -166,30 +166,0 @@\n-    private Path createAppBundle(Map<String, ? super Object> params,\n-            Path outputDirectory) throws PackagerException, IOException,\n-            ConfigException {\n-\n-        boolean hasAppImage =\n-                PREDEFINED_APP_IMAGE.fetchFrom(params) != null;\n-        boolean hasRuntimeImage =\n-                PREDEFINED_RUNTIME_IMAGE.fetchFrom(params) != null;\n-\n-        Path rootDirectory = hasAppImage ?\n-                PREDEFINED_APP_IMAGE.fetchFrom(params) :\n-                createRoot(params, outputDirectory);\n-\n-        AbstractAppImageBuilder appBuilder = appImageSupplier.apply(rootDirectory);\n-        if (!hasAppImage) {\n-            if (!hasRuntimeImage) {\n-                JLinkBundlerHelper.execute(params,\n-                        appBuilder.getAppLayout().runtimeHomeDirectory());\n-            } else {\n-                StandardBundlerParam.copyPredefinedRuntimeImage(\n-                        params, appBuilder.getAppLayout());\n-            }\n-        }\n-\n-        appBuilder.prepareApplicationFiles(params);\n-\n-        return rootDirectory;\n-    }\n-\n-    private boolean dependentTask;\n@@ -197,1 +167,1 @@\n-    private Function<Path, AbstractAppImageBuilder> appImageSupplier;\n+    private AppImageSupplier appImageSupplier;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageBundler.java","additions":27,"deletions":57,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+\n+record AppImageDesc(AppImageLayout appImageLyout, Path path) {\n+\n+    AppImageDesc {\n+        Objects.requireNonNull(appImageLyout);\n+        Objects.requireNonNull(path);\n+    }\n+\n+    AppImageLayout resolvedAppImagelayout() {\n+        return appImageLyout.resolveAt(path);\n+    }\n+\n+    Optional<ApplicationLayout> asResolvedApplicationLayout() {\n+        return asApplicationLayout().map(v -> v.resolveAt(path));\n+    }\n+\n+    Optional<ApplicationLayout> asApplicationLayout() {\n+        if (appImageLyout instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageDesc.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,5 @@\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n@@ -29,1 +34,0 @@\n-import java.nio.file.Path;\n@@ -31,2 +35,2 @@\n-import java.text.MessageFormat;\n-import java.util.ArrayList;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n@@ -36,5 +40,3 @@\n-import javax.xml.stream.XMLStreamException;\n-import javax.xml.stream.XMLStreamWriter;\n-import javax.xml.parsers.DocumentBuilder;\n-import javax.xml.parsers.DocumentBuilderFactory;\n-import javax.xml.parsers.ParserConfigurationException;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Stream;\n@@ -42,1 +44,0 @@\n-import javax.xml.xpath.XPathConstants;\n@@ -45,1 +46,0 @@\n-\n@@ -47,0 +47,5 @@\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.util.XmlUtils;\n@@ -48,0 +53,1 @@\n+import org.w3c.dom.Element;\n@@ -49,2 +55,0 @@\n-import org.w3c.dom.NodeList;\n-import org.w3c.dom.NamedNodeMap;\n@@ -53,10 +57,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.MAIN_CLASS;\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;\n-import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n-import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n-import static jdk.jpackage.internal.StandardBundlerParam.SIGN_BUNDLE;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_STORE;\n-import jdk.jpackage.internal.util.XmlUtils;\n@@ -66,58 +60,3 @@\n-    \/\/ These values will be loaded from AppImage xml file.\n-    private final String appVersion;\n-    private final String launcherName;\n-    private final String mainClass;\n-    private final List<LauncherInfo> addLauncherInfos;\n-    private final String creatorVersion;\n-    private final String creatorPlatform;\n-    private final boolean signed;\n-    private final boolean appStore;\n-\n-    private static final String FILENAME = \".jpackage.xml\";\n-\n-    private static final Map<OperatingSystem, String> PLATFORM_LABELS = Map.of(\n-            OperatingSystem.LINUX, \"linux\",\n-            OperatingSystem.WINDOWS, \"windows\",\n-            OperatingSystem.MACOS, \"macOS\");\n-\n-    private AppImageFile(Path appImageDir, String appVersion, String launcherName,\n-            String mainClass, List<LauncherInfo> launcherInfos,\n-            String creatorVersion, String creatorPlatform, String signedStr,\n-            String appStoreStr) {\n-        boolean isValid = true;\n-\n-        if (appVersion == null || appVersion.length() == 0) {\n-            isValid = false;\n-        }\n-\n-        if (launcherName == null || launcherName.length() == 0) {\n-            isValid = false;\n-        }\n-\n-        if (mainClass == null || mainClass.length() == 0) {\n-            isValid = false;\n-        }\n-\n-        for (var launcher : launcherInfos) {\n-            if (\"\".equals(launcher.getName())) {\n-                isValid = false;\n-            }\n-        }\n-\n-        if (!Objects.equals(getVersion(), creatorVersion)) {\n-            isValid = false;\n-        }\n-\n-        if (!Objects.equals(getPlatform(), creatorPlatform)) {\n-            isValid = false;\n-        }\n-\n-        if (signedStr == null ||\n-                !(\"true\".equals(signedStr) || \"false\".equals(signedStr))) {\n-            isValid = false;\n-        }\n-\n-        if (appStoreStr == null ||\n-                !(\"true\".equals(appStoreStr) || \"false\".equals(appStoreStr))) {\n-            isValid = false;\n-        }\n+    AppImageFile(Application app) {\n+        this(new ApplicationData(app));\n+    }\n@@ -125,5 +64,1 @@\n-        if (!isValid) {\n-            throw new RuntimeException(MessageFormat.format(I18N.getString(\n-                \"error.invalid-app-image\"), appImageDir,\n-                AppImageFile.getPathInAppImage(appImageDir)));\n-        }\n+    private AppImageFile(ApplicationData app) {\n@@ -131,8 +66,7 @@\n-        this.appVersion = appVersion;\n-        this.launcherName = launcherName;\n-        this.mainClass = mainClass;\n-        this.addLauncherInfos = launcherInfos;\n-        this.creatorVersion = creatorVersion;\n-        this.creatorPlatform = creatorPlatform;\n-        this.signed = \"true\".equals(signedStr);\n-        this.appStore = \"true\".equals(appStoreStr);\n+        appVersion = app.version();\n+        launcherName = app.mainLauncherName();\n+        mainClass = app.mainLauncherMainClassName();\n+        extra = app.extra;\n+        creatorVersion = getVersion();\n+        creatorPlatform = getPlatform();\n+        addLauncherInfos = app.additionalLaunchers;\n@@ -143,1 +77,1 @@\n-     * Each item in the list is not null or empty string.\n+     *\n@@ -157,0 +91,7 @@\n+    \/**\n+     * Returns application name. Never returns null or empty value.\n+     *\/\n+    String getAppName() {\n+        return launcherName;\n+    }\n+\n@@ -171,8 +112,0 @@\n-    public boolean isSigned() {\n-        return signed;\n-    }\n-\n-    public boolean isAppStore() {\n-        return appStore;\n-    }\n-\n@@ -180,2 +113,1 @@\n-     * Returns path to application image info file.\n-     * @param appImageDir - path to application image\n+     * Returns additional properties. Never returns null.\n@@ -183,5 +115,2 @@\n-    public static Path getPathInAppImage(Path appImageDir) {\n-        return ApplicationLayout.platformAppImage()\n-                .resolveAt(appImageDir)\n-                .appDirectory()\n-                .resolve(FILENAME);\n+    Map<String, String> getExtra() {\n+        return extra;\n@@ -192,13 +121,1 @@\n-     * from current instance.\n-     * @param appImageDir - path to application image\n-     * @throws IOException\n-     *\/\n-    void save(Path appImageDir) throws IOException {\n-        AppImageFile.save(appImageDir, null, this);\n-    }\n-\n-    \/**\n-     * Saves file with application image info in application image.\n-     * @param appImageDir - path to application image\n-     * @param params - parameters used to generate application image\n-     * @throws IOException\n+     * from this instance.\n@@ -206,46 +123,2 @@\n-    static void save(Path appImageDir, Map<String, Object> params)\n-            throws IOException {\n-        AppImageFile.save(appImageDir, params, null);\n-    }\n-\n-    \/**\n-     * Saves file with application image info in application image using params\n-     * or appImage. Both params or appImage cannot be valid.\n-     * @param appImageDir - path to application image\n-     * @param params - parameters used to generate application image\n-     * @param appImage - instance of already existing application image file\n-     * @throws IOException\n-     * @throws IllegalArgumentException - If both params and appImage are null or\n-     *                                    If both params and appImage are not null\n-     *\/\n-    private static void save(Path appImageDir,\n-            Map<String, Object> params,\n-            AppImageFile appImage) throws IOException {\n-        if ((params == null && appImage == null) ||\n-            (params != null && appImage != null)) {\n-                throw new IllegalArgumentException();\n-        }\n-\n-        final String appVersionSave;\n-        final String mainLauncherSave;\n-        final String mainClassSave;\n-        final String signedSave;\n-        final String appStoreSave;\n-        final List<LauncherInfo> addLauncherInfoSave;\n-        if (params != null) {\n-            appVersionSave = VERSION.fetchFrom(params);\n-            mainLauncherSave = APP_NAME.fetchFrom(params);\n-            mainClassSave = MAIN_CLASS.fetchFrom(params);\n-            signedSave = SIGN_BUNDLE.fetchFrom(params).toString();\n-            appStoreSave = APP_STORE.fetchFrom(params).toString();\n-            addLauncherInfoSave = null;\n-        } else {\n-            appVersionSave = appImage.getAppVersion();\n-            mainLauncherSave = appImage.getLauncherName();\n-            mainClassSave = appImage.getMainClass();\n-            signedSave = String.valueOf(appImage.isSigned());\n-            appStoreSave = String.valueOf(appImage.isAppStore());\n-            addLauncherInfoSave = appImage.getAddLaunchers();\n-        }\n-\n-        XmlUtils.createXml(getPathInAppImage(appImageDir), xml -> {\n+    void save(ApplicationLayout appLayout) throws IOException {\n+        XmlUtils.createXml(getPathInAppImage(appLayout), xml -> {\n@@ -253,2 +126,2 @@\n-            xml.writeAttribute(\"version\", getVersion());\n-            xml.writeAttribute(\"platform\", getPlatform());\n+            xml.writeAttribute(\"version\", creatorVersion);\n+            xml.writeAttribute(\"platform\", creatorPlatform);\n@@ -257,1 +130,1 @@\n-            xml.writeCharacters(appVersionSave);\n+            xml.writeCharacters(appVersion);\n@@ -261,1 +134,1 @@\n-            xml.writeCharacters(mainLauncherSave);\n+            xml.writeCharacters(launcherName);\n@@ -265,1 +138,1 @@\n-            xml.writeCharacters(mainClassSave);\n+            xml.writeCharacters(mainClass);\n@@ -268,15 +141,5 @@\n-            xml.writeStartElement(\"signed\");\n-            xml.writeCharacters(signedSave);\n-            xml.writeEndElement();\n-\n-            xml.writeStartElement(\"app-store\");\n-            xml.writeCharacters(appStoreSave);\n-            xml.writeEndElement();\n-\n-            if (addLauncherInfoSave != null) {\n-                for (var li : addLauncherInfoSave) {\n-                    addLauncherInfo(xml, li);\n-                }\n-            } else {\n-                List<Map<String, ? super Object>> addLaunchers =\n-                    ADD_LAUNCHERS.fetchFrom(params);\n+            for (var extraKey : extra.keySet().stream().sorted().toList()) {\n+                xml.writeStartElement(extraKey);\n+                xml.writeCharacters(extra.get(extraKey));\n+                xml.writeEndElement();\n+            }\n@@ -284,3 +147,8 @@\n-                for (var launcherParams : addLaunchers) {\n-                    var li = new LauncherInfo(launcherParams);\n-                    addLauncherInfo(xml, li);\n+            for (var li : addLauncherInfos) {\n+                xml.writeStartElement(\"add-launcher\");\n+                xml.writeAttribute(\"name\", li.name());\n+                xml.writeAttribute(\"service\", Boolean.toString(li.service()));\n+                for (var extraKey : li.extra().keySet().stream().sorted().toList()) {\n+                    xml.writeStartElement(extraKey);\n+                    xml.writeCharacters(li.extra().get(extraKey));\n+                    xml.writeEndElement();\n@@ -288,0 +156,1 @@\n+                xml.writeEndElement();\n@@ -292,8 +161,6 @@\n-    static void addLauncherInfo(XMLStreamWriter xml, LauncherInfo li)\n-            throws XMLStreamException {\n-        xml.writeStartElement(\"add-launcher\");\n-        xml.writeAttribute(\"name\", li.getName());\n-        xml.writeAttribute(\"shortcut\", Boolean.toString(li.isShortcut()));\n-        xml.writeAttribute(\"menu\", Boolean.toString(li.isMenu()));\n-        xml.writeAttribute(\"service\", Boolean.toString(li.isService()));\n-        xml.writeEndElement();\n+    \/**\n+     * Returns path to application image info file.\n+     * @param appLayout - application layout\n+     *\/\n+    static Path getPathInAppImage(ApplicationLayout appLayout) {\n+        return appLayout.appDirectory().resolve(FILENAME);\n@@ -304,3 +171,2 @@\n-     * @param appImageDir - path to application image\n-     * @return valid info about application image or null\n-     * @throws IOException\n+     * @param appImageDir - path at which to resolve the given application layout\n+     * @param appLayout - application layout\n@@ -308,1 +174,2 @@\n-    public static AppImageFile load(Path appImageDir) {\n+    static AppImageFile load(Path appImageDir, ApplicationLayout appLayout) throws ConfigException, IOException {\n+        var srcFilePath = getPathInAppImage(appLayout.resolveAt(appImageDir));\n@@ -310,12 +177,1 @@\n-            Document doc = readXml(appImageDir);\n-\n-            XPath xPath = XPathFactory.newInstance().newXPath();\n-\n-            String appVersion = xpathQueryNullable(xPath,\n-                    \"\/jpackage-state\/app-version\/text()\", doc);\n-\n-            String mainLauncher = xpathQueryNullable(xPath,\n-                    \"\/jpackage-state\/main-launcher\/text()\", doc);\n-\n-            String mainClass = xpathQueryNullable(xPath,\n-                    \"\/jpackage-state\/main-class\/text()\", doc);\n+            final Document doc = XmlUtils.initDocumentBuilder().parse(Files.newInputStream(srcFilePath));\n@@ -323,1 +179,1 @@\n-            List<LauncherInfo> launcherInfos = new ArrayList<>();\n+            final XPath xPath = XPathFactory.newInstance().newXPath();\n@@ -325,5 +181,5 @@\n-            String platform = xpathQueryNullable(xPath,\n-                    \"\/jpackage-state\/@platform\", doc);\n-\n-            String version = xpathQueryNullable(xPath,\n-                    \"\/jpackage-state\/@version\", doc);\n+            final var isPlatformValid = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/@platform\").findFirst().map(\n+                    Node::getNodeValue).map(getPlatform()::equals).orElse(false);\n+            if (!isPlatformValid) {\n+                throw new InvalidAppImageFileException();\n+            }\n@@ -331,2 +187,5 @@\n-            String signedStr = xpathQueryNullable(xPath,\n-                    \"\/jpackage-state\/signed\/text()\", doc);\n+            final var isVersionValid = XmlUtils.queryNodes(doc, xPath, \"\/jpackage-state\/@version\").findFirst().map(\n+                    Node::getNodeValue).map(getVersion()::equals).orElse(false);\n+            if (!isVersionValid) {\n+                throw new InvalidAppImageFileException();\n+            }\n@@ -334,2 +193,6 @@\n-            String appStoreStr = xpathQueryNullable(xPath,\n-                    \"\/jpackage-state\/app-store\/text()\", doc);\n+            final AppImageProperties props;\n+            try {\n+                props = AppImageProperties.main(doc, xPath);\n+            } catch (IllegalArgumentException ex) {\n+                throw new InvalidAppImageFileException(ex);\n+            }\n@@ -337,3 +200,8 @@\n-            NodeList launcherNodes = (NodeList) xPath.evaluate(\n-                    \"\/jpackage-state\/add-launcher\", doc,\n-                    XPathConstants.NODESET);\n+            final var additionalLaunchers = AppImageProperties.launchers(doc, xPath).stream().map(launcherProps -> {\n+                try {\n+                    return new LauncherInfo(launcherProps.get(\"name\"),\n+                            launcherProps.find(\"service\").map(Boolean::parseBoolean).orElse(false), launcherProps.getExtra());\n+                } catch (IllegalArgumentException ex) {\n+                    throw new InvalidAppImageFileException(ex);\n+                }\n+            }).toList();\n@@ -341,3 +209,2 @@\n-            for (int i = 0; i != launcherNodes.getLength(); i++) {\n-                 launcherInfos.add(new LauncherInfo(launcherNodes.item(i)));\n-            }\n+            return new AppImageFile(new ApplicationData(props.get(\"app-version\"), props.get(\"main-launcher\"),\n+                    props.get(\"main-class\"), props.getExtra(), additionalLaunchers));\n@@ -345,3 +212,0 @@\n-            return new AppImageFile(appImageDir, appVersion, mainLauncher,\n-                    mainClass, launcherInfos, version, platform, signedStr,\n-                    appStoreStr);\n@@ -351,6 +215,8 @@\n-        } catch (NoSuchFileException nsfe) {\n-            \/\/ non jpackage generated app-image (no app\/.jpackage.xml)\n-            throw new RuntimeException(MessageFormat.format(I18N.getString(\n-                    \"error.foreign-app-image\"), appImageDir));\n-        } catch (IOException ioe) {\n-            throw new RuntimeException(ioe);\n+        } catch (SAXException ex) {\n+            \/\/ Exception reading input XML (probably malformed XML)\n+            throw new IOException(ex);\n+        } catch (NoSuchFileException ex) {\n+            throw I18N.buildConfigException(\"error.foreign-app-image\", appImageDir).create();\n+        } catch (InvalidAppImageFileException ex) {\n+            \/\/ Invalid input XML\n+            throw I18N.buildConfigException(\"error.invalid-app-image\", appImageDir, srcFilePath).create();\n@@ -360,9 +226,5 @@\n-    \/**\n-     * Returns copy of AppImageFile, but with signed set to true if AppImageFile\n-     * is not marked as signed. If AppImageFile already signed it will return\n-     * instance to itself.\n-     *\/\n-    public AppImageFile copyAsSigned() {\n-        if (isSigned()) {\n-            return this;\n-        }\n+    static boolean getBooleanExtraFieldValue(String fieldId, AppImageFile appImageFile) {\n+        Objects.requireNonNull(fieldId);\n+        Objects.requireNonNull(appImageFile);\n+        return Optional.ofNullable(appImageFile.getExtra().get(fieldId)).map(Boolean::parseBoolean).orElse(false);\n+    }\n@@ -370,6 +232,2 @@\n-        \/\/ Pass null for appImageDir, it is used only to show location of\n-        \/\/ .jpackage.xml in case of error. copyAsSigned() should not produce\n-        \/\/ invalid app image file.\n-        return new AppImageFile(null, getAppVersion(),\n-                getLauncherName(), getMainClass(), getAddLaunchers(),\n-                getVersion(), getPlatform(), \"true\", String.valueOf(isAppStore()));\n+    static String getVersion() {\n+        return System.getProperty(\"java.version\");\n@@ -378,15 +236,2 @@\n-    public static Document readXml(Path appImageDir) throws IOException {\n-        try {\n-            Path path = getPathInAppImage(appImageDir);\n-\n-            DocumentBuilderFactory dbf =\n-                    DocumentBuilderFactory.newDefaultInstance();\n-            dbf.setFeature(\n-                   \"http:\/\/apache.org\/xml\/features\/nonvalidating\/load-external-dtd\",\n-                    false);\n-            DocumentBuilder b = dbf.newDocumentBuilder();\n-            return b.parse(Files.newInputStream(path));\n-        } catch (ParserConfigurationException | SAXException ex) {\n-            \/\/ Let caller sort this out\n-            throw new IOException(ex);\n-        }\n+    static String getPlatform() {\n+        return PLATFORM_LABELS.get(OperatingSystem.current());\n@@ -395,14 +240,4 @@\n-    \/**\n-     * Returns list of LauncherInfo objects configured for the application.\n-     * The first item in the returned list is main launcher.\n-     * Following items in the list are names of additional launchers.\n-     *\/\n-    static List<LauncherInfo> getLaunchers(Path appImageDir,\n-            Map<String, Object> params) {\n-        List<LauncherInfo> launchers = new ArrayList<>();\n-        if (appImageDir != null) {\n-            AppImageFile appImageInfo = AppImageFile.load(appImageDir);\n-            launchers.add(new LauncherInfo(\n-                    appImageInfo.getLauncherName(), params));\n-                    launchers.addAll(appImageInfo.getAddLaunchers());\n-            return launchers;\n+    private static final class AppImageProperties {\n+        private AppImageProperties(Map<String, String> data, Set<String> stdKeys) {\n+            this.data = data;\n+            this.stdKeys = stdKeys;\n@@ -411,6 +246,4 @@\n-        launchers.add(new LauncherInfo(params));\n-        ADD_LAUNCHERS.fetchFrom(params).stream()\n-                .map(launcherParams -> new LauncherInfo(launcherParams))\n-                .forEach(launchers::add);\n-        return launchers;\n-    }\n+        static AppImageProperties main(Document xml, XPath xPath) throws XPathExpressionException {\n+            final var data = queryProperties(xml.getDocumentElement(), xPath, MAIN_PROPERTIES_XPATH_QUERY);\n+            return new AppImageProperties(data, MAIN_ELEMENT_NAMES);\n+        }\n@@ -418,3 +251,3 @@\n-    public static String extractAppName(Path appImageDir) {\n-        return AppImageFile.load(appImageDir).getLauncherName();\n-    }\n+        static AppImageProperties launcher(Element addLauncherNode, XPath xPath) throws XPathExpressionException {\n+            final var attrData = XmlUtils.toStream(addLauncherNode.getAttributes())\n+                    .collect(toMap(Node::getNodeName, Node::getNodeValue));\n@@ -422,3 +255,1 @@\n-    public static String extractMainClass(Path appImageDir) {\n-        return AppImageFile.load(appImageDir).getMainClass();\n-    }\n+            final var extraData = queryProperties(addLauncherNode, xPath, LAUNCHER_PROPERTIES_XPATH_QUERY);\n@@ -426,6 +257,4 @@\n-    private static String xpathQueryNullable(XPath xPath, String xpathExpr,\n-            Document xml) throws XPathExpressionException {\n-        NodeList nodes = (NodeList) xPath.evaluate(xpathExpr, xml,\n-                XPathConstants.NODESET);\n-        if (nodes != null && nodes.getLength() > 0) {\n-            return nodes.item(0).getNodeValue();\n+            final Map<String, String> data = new HashMap<>(attrData);\n+            data.putAll(extraData);\n+\n+            return new AppImageProperties(data, LAUNCHER_ATTR_NAMES);\n@@ -433,2 +262,0 @@\n-        return null;\n-    }\n@@ -436,3 +263,6 @@\n-    public static String getVersion() {\n-        return System.getProperty(\"java.version\");\n-    }\n+        static List<AppImageProperties> launchers(Document xml, XPath xPath) throws XPathExpressionException {\n+            return XmlUtils.queryNodes(xml, xPath, \"\/jpackage-state\/add-launcher\")\n+                    .map(Element.class::cast).map(toFunction(e -> {\n+                        return launcher(e, xPath);\n+                    })).toList();\n+        }\n@@ -440,3 +270,3 @@\n-    public static String getPlatform() {\n-        return PLATFORM_LABELS.get(OperatingSystem.current());\n-    }\n+        String get(String name) {\n+            return find(name).orElseThrow(InvalidAppImageFileException::new);\n+        }\n@@ -444,5 +274,3 @@\n-    static class LauncherInfo {\n-        private final String name;\n-        private final boolean shortcut;\n-        private final boolean menu;\n-        private final boolean service;\n+        Optional<String> find(String name) {\n+            return Optional.ofNullable(data.get(name));\n+        }\n@@ -450,2 +278,4 @@\n-        private LauncherInfo(Map<String, Object> params) {\n-            this(APP_NAME.fetchFrom(params), params);\n+        Map<String, String> getExtra() {\n+            Map<String, String> extra = new HashMap<>(data);\n+            stdKeys.forEach(extra::remove);\n+            return extra;\n@@ -454,5 +284,7 @@\n-        private LauncherInfo(String name, Map<String, Object> params) {\n-            this.name = name;\n-            this.shortcut = SHORTCUT_HINT.fetchFrom(params);\n-            this.menu = MENU_HINT.fetchFrom(params);\n-            this.service = LAUNCHER_AS_SERVICE.fetchFrom(params);\n+        private static  Map<String, String> queryProperties(Element e, XPath xPath, String xpathExpr)\n+                throws XPathExpressionException {\n+            return XmlUtils.queryNodes(e, xPath, xpathExpr)\n+                    .map(Element.class::cast)\n+                    .collect(toMap(Node::getNodeName, selectedElement -> {\n+                        return selectedElement.getTextContent();\n+                    }, (a, b) -> b));\n@@ -461,5 +293,6 @@\n-        private LauncherInfo(Node node) {\n-            this.name = getAttribute(node, \"name\");\n-            this.shortcut = !\"false\".equals(getAttribute(node, \"shortcut\"));\n-            this.menu = !\"false\".equals(getAttribute(node, \"menu\"));\n-            this.service = !\"false\".equals(getAttribute(node, \"service\"));\n+        private static String xpathQueryForExtraProperties(Set<String> excludeNames) {\n+            final String otherElementNames = excludeNames.stream().map(name -> {\n+                return String.format(\"name() != '%s'\", name);\n+            }).collect(joining(\" and \"));\n+\n+            return String.format(\"*[(%s) and not(*)]\", otherElementNames);\n@@ -468,4 +301,45 @@\n-        private String getAttribute(Node item, String attr) {\n-            NamedNodeMap attrs = item.getAttributes();\n-            Node attrNode = attrs.getNamedItem(attr);\n-            return ((attrNode == null) ? null : attrNode.getNodeValue());\n+        private final Map<String, String> data;\n+        private final Set<String> stdKeys;\n+\n+        private static final Set<String> LAUNCHER_ATTR_NAMES = Set.of(\"name\", \"service\");\n+        private static final String LAUNCHER_PROPERTIES_XPATH_QUERY = xpathQueryForExtraProperties(LAUNCHER_ATTR_NAMES);\n+\n+        private static final Set<String> MAIN_ELEMENT_NAMES = Set.of(\"app-version\", \"main-launcher\", \"main-class\");\n+        private static final String MAIN_PROPERTIES_XPATH_QUERY;\n+\n+        static {\n+            final String nonEmptyMainElements = MAIN_ELEMENT_NAMES.stream().map(name -> {\n+                return String.format(\"\/jpackage-state\/%s[text()]\", name);\n+            }).collect(joining(\"|\"));\n+\n+            MAIN_PROPERTIES_XPATH_QUERY = String.format(\"%s|\/jpackage-state\/%s\", nonEmptyMainElements,\n+                    xpathQueryForExtraProperties(Stream.concat(MAIN_ELEMENT_NAMES.stream(),\n+                            Stream.of(\"add-launcher\")).collect(toSet())));\n+        }\n+    }\n+\n+    record LauncherInfo(String name, boolean service, Map<String, String> extra) {\n+        LauncherInfo {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(extra);\n+            if (name.isBlank()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+    }\n+\n+    private record ApplicationData(String version, String mainLauncherName, String mainLauncherMainClassName,\n+            Map<String, String> extra, List<LauncherInfo> additionalLaunchers) {\n+\n+        ApplicationData {\n+            Objects.requireNonNull(version);\n+            Objects.requireNonNull(mainLauncherName);\n+            Objects.requireNonNull(mainLauncherMainClassName);\n+            Objects.requireNonNull(extra);\n+            Objects.requireNonNull(additionalLaunchers);\n+\n+            for (final var property : List.of(version, mainLauncherName, mainLauncherMainClassName)) {\n+                if (property.isBlank()) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n@@ -474,2 +348,2 @@\n-        public String getName() {\n-            return name;\n+        ApplicationData(Application app) {\n+            this(app, app.mainLauncher().orElseThrow());\n@@ -478,2 +352,6 @@\n-        public boolean isShortcut() {\n-            return shortcut;\n+        private ApplicationData(Application app, Launcher mainLauncher) {\n+            this(app.version(), mainLauncher.name(), mainLauncher.startupInfo().orElseThrow().qualifiedClassName(),\n+                    app.extraAppImageFileData(), app.additionalLaunchers().stream().map(launcher -> {\n+                        return new LauncherInfo(launcher.name(), launcher.isService(),\n+                                launcher.extraAppImageFileData());\n+                    }).toList());\n@@ -481,0 +359,3 @@\n+    }\n+\n+    private static class InvalidAppImageFileException extends RuntimeException {\n@@ -482,2 +363,1 @@\n-        public boolean isMenu() {\n-            return menu;\n+        InvalidAppImageFileException() {\n@@ -486,2 +366,2 @@\n-        public boolean isService() {\n-            return service;\n+        InvalidAppImageFileException(Throwable t) {\n+            super(t);\n@@ -489,0 +369,2 @@\n+\n+        private static final long serialVersionUID = 1L;\n@@ -491,0 +373,14 @@\n+    private final String appVersion;\n+    private final String launcherName;\n+    private final String mainClass;\n+    private final Map<String, String> extra;\n+    private final List<LauncherInfo> addLauncherInfos;\n+    private final String creatorVersion;\n+    private final String creatorPlatform;\n+\n+    private static final String FILENAME = \".jpackage.xml\";\n+\n+    private static final Map<OperatingSystem, String> PLATFORM_LABELS = Map.of(\n+            OperatingSystem.LINUX, \"linux\",\n+            OperatingSystem.WINDOWS, \"windows\",\n+            OperatingSystem.MACOS, \"macOS\");\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/AppImageFile.java","additions":236,"deletions":340,"binary":false,"changes":576,"status":"modified"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+\n+import java.nio.file.Path;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.AppImageFile.LauncherInfo;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+\n+final class ApplicationBuilder {\n+\n+    Application create() throws ConfigException {\n+        Objects.requireNonNull(appImageLayout);\n+\n+        final var launchersAsList = Optional.ofNullable(launchers).map(\n+                ApplicationLaunchers::asList).orElseGet(List::of);\n+\n+        final var launcherCount = launchersAsList.size();\n+\n+        if (launcherCount != launchersAsList.stream().map(Launcher::name).distinct().count()) {\n+            throw buildConfigException(\"ERR_NoUniqueName\").create();\n+        }\n+\n+        final String effectiveName;\n+        if (name != null) {\n+            effectiveName = name;\n+        } else if (!launchersAsList.isEmpty()) {\n+            effectiveName = launchers.mainLauncher().name();\n+        } else {\n+            throw buildConfigException(\"error.no.name\").advice(\"error.no.name.advice\").create();\n+        }\n+\n+        Objects.requireNonNull(launchersAsList);\n+\n+        return new Application.Stub(\n+                effectiveName,\n+                Optional.ofNullable(description).orElse(effectiveName),\n+                Optional.ofNullable(version).orElseGet(DEFAULTS::version),\n+                Optional.ofNullable(vendor).orElseGet(DEFAULTS::vendor),\n+                Optional.ofNullable(copyright).orElseGet(DEFAULTS::copyright),\n+                Optional.ofNullable(srcDir),\n+                Optional.ofNullable(contentDirs).orElseGet(List::of),\n+                appImageLayout, Optional.ofNullable(runtimeBuilder), launchersAsList, Map.of());\n+    }\n+\n+    ApplicationBuilder runtimeBuilder(RuntimeBuilder v) {\n+        runtimeBuilder = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder initFromAppImage(AppImageFile appImageFile,\n+            Function<LauncherInfo, Launcher> mapper) {\n+        if (version == null) {\n+            version = appImageFile.getAppVersion();\n+        }\n+        if (name == null) {\n+            name = appImageFile.getAppName();\n+        }\n+        runtimeBuilder = null;\n+\n+        var mainLauncherInfo = new LauncherInfo(appImageFile.getLauncherName(), false, Map.of());\n+\n+        launchers = new ApplicationLaunchers(\n+                mapper.apply(mainLauncherInfo),\n+                appImageFile.getAddLaunchers().stream().map(mapper).toList());\n+\n+        return this;\n+    }\n+\n+    ApplicationBuilder launchers(ApplicationLaunchers v) {\n+        launchers = v;\n+        return this;\n+    }\n+\n+    Optional<ApplicationLaunchers> launchers() {\n+        return Optional.ofNullable(launchers);\n+    }\n+\n+    ApplicationBuilder appImageLayout(AppImageLayout v) {\n+        appImageLayout = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder name(String v) {\n+        name = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder description(String v) {\n+        description = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder version(String v) {\n+        version = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder vendor(String v) {\n+        vendor = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder copyright(String v) {\n+        copyright = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder srcDir(Path v) {\n+        srcDir = v;\n+        return this;\n+    }\n+\n+    ApplicationBuilder contentDirs(List<Path> v) {\n+        contentDirs = v;\n+        return this;\n+    }\n+\n+    static Launcher overrideLauncherStartupInfo(Launcher launcher, LauncherStartupInfo startupInfo) {\n+        return new Launcher.Stub(launcher.name(), Optional.of(startupInfo),\n+                launcher.fileAssociations(), launcher.isService(), launcher.description(),\n+                launcher.icon(), launcher.defaultIconResourceName(), launcher.extraAppImageFileData());\n+    }\n+\n+    record MainLauncherStartupInfo(String qualifiedClassName) implements LauncherStartupInfo {\n+        @Override\n+        public List<String> javaOptions() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public List<String> defaultParameters() {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public List<Path> classPath() {\n+            throw new UnsupportedOperationException();\n+        }\n+    }\n+\n+    private record Defaults(String version, String vendor) {\n+        String copyright() {\n+            return I18N.format(\"param.copyright.default\", new Date());\n+        }\n+    }\n+\n+    private String name;\n+    private String description;\n+    private String version;\n+    private String vendor;\n+    private String copyright;\n+    private Path srcDir;\n+    private List<Path> contentDirs;\n+    private AppImageLayout appImageLayout;\n+    private RuntimeBuilder runtimeBuilder;\n+    private ApplicationLaunchers launchers;\n+\n+    private static final Defaults DEFAULTS = new Defaults(\n+            \"1.0\",\n+            I18N.getString(\"param.vendor.default\"));\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.function.Supplier;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.PackagingPipeline.ApplicationImageTaskAction;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.CustomLauncherIcon;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.util.FileUtils;\n+import jdk.jpackage.internal.util.PathUtils;\n+\n+\n+final class ApplicationImageUtils {\n+\n+    static Optional<OverridableResource> createLauncherIconResource(Application app,\n+            Launcher launcher,\n+            Function<String, OverridableResource> resourceSupplier) {\n+        final String defaultIconName = launcher.defaultIconResourceName();\n+        final String resourcePublicName = launcher.executableName() + PathUtils.getSuffix(Path.of(defaultIconName));\n+\n+        if (!launcher.hasIcon()) {\n+            return Optional.empty();\n+        }\n+\n+        OverridableResource resource = resourceSupplier.apply(defaultIconName)\n+                .setCategory(\"icon\")\n+                .setPublicName(resourcePublicName);\n+\n+        launcher.icon().flatMap(CustomLauncherIcon::fromLauncherIcon).map(CustomLauncherIcon::path).ifPresent(resource::setExternal);\n+\n+        if (launcher.hasDefaultIcon() && app.mainLauncher().orElseThrow() != launcher) {\n+            \/\/ No icon explicitly configured for this launcher.\n+            \/\/ Dry-run resource creation to figure out its source.\n+            final Path nullPath = null;\n+            if (toSupplier(() -> resource.saveToFile(nullPath)).get() != OverridableResource.Source.ResourceDir) {\n+                \/\/ No icon in resource dir for this launcher, inherit icon\n+                \/\/ configured for the main launcher.\n+                return createLauncherIconResource(\n+                        app, app.mainLauncher().orElseThrow(),\n+                        resourceSupplier\n+                ).map(r -> r.setLogPublicName(resourcePublicName));\n+            }\n+        }\n+\n+        return Optional.of(resource);\n+    }\n+\n+    static ApplicationImageTaskAction<Application, ApplicationLayout> createWriteRuntimeAction() {\n+        return env -> {\n+            env.app().runtimeBuilder().orElseThrow().createRuntime(env.resolvedLayout());\n+        };\n+    }\n+\n+    static ApplicationImageTaskAction<Application, ApplicationLayout> createWriteAppImageFileAction() {\n+        return env -> {\n+            new AppImageFile(env.app()).save(env.resolvedLayout());\n+        };\n+    }\n+\n+    static ApplicationImageTaskAction<Application, ApplicationLayout> createCopyContentAction(Supplier<List<Path>> excludeCopyDirs) {\n+        return env -> {\n+            var excludeCandidates = Stream.concat(\n+                    excludeCopyDirs.get().stream(),\n+                    Stream.of(env.env().buildRoot(), env.env().appImageDir())\n+            ).map(Path::toAbsolutePath).toList();\n+\n+            env.app().srcDir().ifPresent(toConsumer(srcDir -> {\n+                copyRecursive(srcDir, env.resolvedLayout().appDirectory(), excludeCandidates);\n+            }));\n+\n+            for (var srcDir : env.app().contentDirs()) {\n+                copyRecursive(srcDir,\n+                        env.resolvedLayout().contentDirectory().resolve(srcDir.getFileName()),\n+                        excludeCandidates);\n+            }\n+        };\n+    }\n+\n+    static ApplicationImageTaskAction<Application, ApplicationLayout> createWriteLaunchersAction() {\n+        return env -> {\n+            for (var launcher : env.app().launchers()) {\n+                \/\/ Create corresponding .cfg file\n+                new CfgFile(env.app(), launcher).create(env.resolvedLayout());\n+\n+                \/\/ Copy executable to launchers folder\n+                Path executableFile = env.resolvedLayout().launchersDirectory().resolve(\n+                        launcher.executableNameWithSuffix());\n+                try (var in = launcher.executableResource()) {\n+                    Files.createDirectories(executableFile.getParent());\n+                    Files.copy(in, executableFile);\n+                }\n+\n+                \/\/ Make it executable for everyone. It is essential to make the launcher executable for others\n+                \/\/ on macOS. Otherwise, launchers in installed DMG or PKG packages will be\n+                \/\/ unavailable for anyone but the user who installed them.\n+                executableFile.toFile().setExecutable(true, false);\n+            }\n+        };\n+    }\n+\n+    private static void copyRecursive(Path srcDir, Path dstDir, List<Path> excludeDirs) throws IOException {\n+        srcDir = srcDir.toAbsolutePath();\n+\n+        List<Path> excludes = new ArrayList<>();\n+\n+        for (var path : excludeDirs) {\n+            if (Files.isDirectory(path)) {\n+                if (path.startsWith(srcDir) && !Files.isSameFile(path, srcDir)) {\n+                    excludes.add(path);\n+                }\n+            }\n+        }\n+\n+        FileUtils.copyRecursive(srcDir, dstDir.toAbsolutePath(), excludes);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -1,240 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import jdk.internal.util.OperatingSystem;\n-import jdk.jpackage.internal.util.PathGroup;\n-import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.List;\n-import java.util.Map;\n-\n-\n-\/**\n- * Application directory layout.\n- *\/\n-public final class ApplicationLayout {\n-    enum PathRole {\n-        \/**\n-         * Java run-time directory.\n-         *\/\n-        RUNTIME,\n-\n-        \/**\n-         * Java run-time home directory.\n-         *\/\n-        RUNTIME_HOME,\n-\n-        \/**\n-         * Application data directory.\n-         *\/\n-        APP,\n-\n-        \/**\n-         * Directory with application launchers.\n-         *\/\n-        LAUNCHERS,\n-\n-        \/**\n-         * Directory for files for desktop integration.\n-         *\/\n-        DESKTOP,\n-\n-        \/**\n-         * Directory with application Java modules.\n-         *\/\n-        MODULES,\n-\n-        \/**\n-         * Linux app launcher shared library.\n-         *\/\n-        LINUX_APPLAUNCHER_LIB,\n-\n-        \/**\n-         * Location of additional application content\n-         *\/\n-        CONTENT\n-    }\n-\n-    ApplicationLayout(Map<Object, Path> paths) {\n-        data = new PathGroup(paths);\n-    }\n-\n-    private ApplicationLayout(PathGroup data) {\n-        this.data = data;\n-    }\n-\n-    public PathGroup pathGroup() {\n-        return data;\n-    }\n-\n-    public ApplicationLayout resolveAt(Path root) {\n-        return new ApplicationLayout(pathGroup().resolveAt(root));\n-    }\n-\n-    public List<Path> roots() {\n-        return data.roots();\n-    }\n-\n-    public long sizeInBytes() throws IOException {\n-        return data.sizeInBytes();\n-    }\n-\n-    public void copy(ApplicationLayout other) throws IOException {\n-        data.copy(other.data);\n-    }\n-\n-    public void move(ApplicationLayout other) throws IOException {\n-        data.move(other.data);\n-    }\n-\n-    public void transform(ApplicationLayout other, PathGroup.TransformHandler handler) throws IOException {\n-        data.transform(other.data, handler);\n-    }\n-\n-    \/**\n-     * Path to launchers directory.\n-     *\/\n-    public Path launchersDirectory() {\n-        return pathGroup().getPath(PathRole.LAUNCHERS);\n-    }\n-\n-    \/**\n-     * Path to application data directory.\n-     *\/\n-    public Path appDirectory() {\n-        return pathGroup().getPath(PathRole.APP);\n-    }\n-\n-    \/**\n-     * Path to Java run-time directory.\n-     *\/\n-    public Path runtimeDirectory() {\n-        return pathGroup().getPath(PathRole.RUNTIME);\n-    }\n-\n-    \/**\n-     * Path to Java run-time home directory.\n-     *\/\n-    public Path runtimeHomeDirectory() {\n-        return pathGroup().getPath(PathRole.RUNTIME_HOME);\n-    }\n-\n-    \/**\n-     * Path to application mods directory.\n-     *\/\n-    public Path appModsDirectory() {\n-        return pathGroup().getPath(PathRole.MODULES);\n-    }\n-\n-    \/**\n-     * Path to directory with application's desktop integration files.\n-     *\/\n-    public Path destktopIntegrationDirectory() {\n-        return pathGroup().getPath(PathRole.DESKTOP);\n-    }\n-\n-    \/**\n-     * Path to directory with additional application content.\n-     *\/\n-    public Path contentDirectory() {\n-        return pathGroup().getPath(PathRole.CONTENT);\n-    }\n-\n-    static ApplicationLayout linuxAppImage() {\n-        return new ApplicationLayout(Map.of(\n-                PathRole.LAUNCHERS, Path.of(\"bin\"),\n-                PathRole.APP, Path.of(\"lib\/app\"),\n-                PathRole.RUNTIME, Path.of(\"lib\/runtime\"),\n-                PathRole.RUNTIME_HOME, Path.of(\"lib\/runtime\"),\n-                PathRole.DESKTOP, Path.of(\"lib\"),\n-                PathRole.MODULES, Path.of(\"lib\/app\/mods\"),\n-                PathRole.LINUX_APPLAUNCHER_LIB, Path.of(\"lib\/libapplauncher.so\"),\n-                PathRole.CONTENT, Path.of(\"lib\")\n-        ));\n-    }\n-\n-    static ApplicationLayout windowsAppImage() {\n-        return new ApplicationLayout(Map.of(\n-                PathRole.LAUNCHERS, Path.of(\"\"),\n-                PathRole.APP, Path.of(\"app\"),\n-                PathRole.RUNTIME, Path.of(\"runtime\"),\n-                PathRole.RUNTIME_HOME, Path.of(\"runtime\"),\n-                PathRole.DESKTOP, Path.of(\"\"),\n-                PathRole.MODULES, Path.of(\"app\/mods\"),\n-                PathRole.CONTENT, Path.of(\"\")\n-        ));\n-    }\n-\n-    static ApplicationLayout macAppImage() {\n-        return new ApplicationLayout(Map.of(\n-                PathRole.LAUNCHERS, Path.of(\"Contents\/MacOS\"),\n-                PathRole.APP, Path.of(\"Contents\/app\"),\n-                PathRole.RUNTIME, Path.of(\"Contents\/runtime\"),\n-                PathRole.RUNTIME_HOME, Path.of(\"Contents\/runtime\/Contents\/Home\"),\n-                PathRole.DESKTOP, Path.of(\"Contents\/Resources\"),\n-                PathRole.MODULES, Path.of(\"Contents\/app\/mods\"),\n-                PathRole.CONTENT, Path.of(\"Contents\")\n-        ));\n-    }\n-\n-    public static ApplicationLayout platformAppImage() {\n-        if (OperatingSystem.isWindows()) {\n-            return windowsAppImage();\n-        }\n-\n-        if (OperatingSystem.isLinux()) {\n-            return linuxAppImage();\n-        }\n-\n-        if (OperatingSystem.isMacOS()) {\n-            return macAppImage();\n-        }\n-\n-        throw new IllegalArgumentException(\"Unknown platform: \" + OperatingSystem.current());\n-    }\n-\n-    public static ApplicationLayout javaRuntime() {\n-        return new ApplicationLayout(Map.of(PathRole.RUNTIME, Path.of(\"\")));\n-    }\n-\n-    public static ApplicationLayout linuxUsrTreePackageImage(Path prefix,\n-            String packageName) {\n-        final Path lib = prefix.resolve(Path.of(\"lib\", packageName));\n-        return new ApplicationLayout(Map.of(\n-                PathRole.LAUNCHERS, prefix.resolve(\"bin\"),\n-                PathRole.APP, lib.resolve(\"app\"),\n-                PathRole.RUNTIME, lib.resolve(\"runtime\"),\n-                PathRole.RUNTIME_HOME, lib.resolve(\"runtime\"),\n-                PathRole.DESKTOP, lib,\n-                PathRole.MODULES, lib.resolve(\"app\/mods\"),\n-                PathRole.LINUX_APPLAUNCHER_LIB, lib.resolve(\n-                        \"lib\/libapplauncher.so\"),\n-                PathRole.CONTENT, lib\n-        ));\n-    }\n-\n-    private final PathGroup data;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayout.java","additions":0,"deletions":240,"binary":false,"changes":240,"status":"deleted"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+\n+\n+final class ApplicationLayoutUtils {\n+\n+    public static final ApplicationLayout PLATFORM_APPLICATION_LAYOUT;\n+\n+    private static final ApplicationLayout WIN_APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .setAll(\"\")\n+            .appDirectory(\"app\")\n+            .runtimeDirectory(\"runtime\")\n+            .appModsDirectory(Path.of(\"app\", \"mods\"))\n+            .create();\n+\n+    private static final ApplicationLayout MAC_APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .launchersDirectory(\"Contents\/MacOS\")\n+            .appDirectory(\"Contents\/app\")\n+            .runtimeDirectory(\"Contents\/runtime\/Contents\/Home\")\n+            .destktopIntegrationDirectory(\"Contents\/Resources\")\n+            .appModsDirectory(\"Contents\/app\/mods\")\n+            .contentDirectory(\"Contents\")\n+            .create();\n+\n+    private static final ApplicationLayout LINUX_APPLICATION_LAYOUT = ApplicationLayout.build()\n+            .launchersDirectory(\"bin\")\n+            .appDirectory(\"lib\/app\")\n+            .runtimeDirectory(\"lib\/runtime\")\n+            .destktopIntegrationDirectory(\"lib\")\n+            .appModsDirectory(\"lib\/app\/mods\")\n+            .contentDirectory(\"lib\")\n+            .create();\n+\n+    static {\n+        switch (OperatingSystem.current()) {\n+            case WINDOWS -> PLATFORM_APPLICATION_LAYOUT = WIN_APPLICATION_LAYOUT;\n+            case MACOS -> PLATFORM_APPLICATION_LAYOUT = MAC_APPLICATION_LAYOUT;\n+            case LINUX -> PLATFORM_APPLICATION_LAYOUT = LINUX_APPLICATION_LAYOUT;\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationLayoutUtils.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -34,1 +34,0 @@\n-import java.nio.file.Paths;\n@@ -141,1 +140,3 @@\n-            context().deployParams.setTargetFormat(popArg());\n+            var type = popArg();\n+            context().deployParams.setTargetFormat(type);\n+            setOptionValue(\"type\", type);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/Arguments.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+interface BuildEnv {\n+\n+    Path buildRoot();\n+\n+    boolean verbose();\n+\n+    Optional<Path> resourceDir();\n+\n+    \/**\n+     * Returns path to application image directory.\n+     *\n+     * The return value is supposed to be used as a parameter for\n+     * ApplicationLayout#resolveAt function.\n+     *\/\n+    default Path appImageDir() {\n+        return buildRoot().resolve(\"image\");\n+    }\n+\n+    default Path configDir() {\n+        return buildRoot().resolve(\"config\");\n+    }\n+\n+    OverridableResource createResource(String defaultName);\n+\n+    static BuildEnv withAppImageDir(BuildEnv env, Path appImageDir) {\n+        return ((Internal.DefaultBuildEnv)env).copyWithAppImageDir(appImageDir);\n+    }\n+\n+    static BuildEnv create(Path buildRoot, Optional<Path> resourceDir, boolean verbose, Class<?> resourceLocator) {\n+        return new Internal.DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.empty());\n+    }\n+\n+    static final class Internal {\n+        private static record DefaultBuildEnv(Path buildRoot, Optional<Path> resourceDir,\n+                boolean verbose, Class<?> resourceLocator, Optional<Path> optAppImageDir) implements BuildEnv {\n+\n+            DefaultBuildEnv {\n+                Objects.requireNonNull(buildRoot);\n+                Objects.requireNonNull(resourceDir);\n+                Objects.requireNonNull(resourceLocator);\n+                Objects.requireNonNull(optAppImageDir);\n+            }\n+\n+            DefaultBuildEnv copyWithAppImageDir(Path appImageDir) {\n+                return new DefaultBuildEnv(buildRoot, resourceDir, verbose, resourceLocator, Optional.of(appImageDir));\n+            }\n+\n+            @Override\n+            public Path appImageDir() {\n+                return optAppImageDir.orElseGet(BuildEnv.super::appImageDir);\n+            }\n+\n+            @Override\n+            public OverridableResource createResource(String defaultName) {\n+                final OverridableResource resource;\n+                if (defaultName != null) {\n+                    resource = new OverridableResource(defaultName, resourceLocator);\n+                } else {\n+                    resource = new OverridableResource();\n+                }\n+                return resourceDir.map(resource::setResourceDir).orElse(resource);\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnv.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -0,0 +1,99 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+\n+final class BuildEnvBuilder {\n+\n+    BuildEnvBuilder(Path root) {\n+        this.root = Objects.requireNonNull(root);\n+    }\n+\n+    BuildEnv create() throws ConfigException {\n+        Objects.requireNonNull(appImageDir);\n+\n+        var exceptionBuilder = buildConfigException(\"ERR_BuildRootInvalid\", root);\n+        if (!Files.exists(root)) {\n+        } else if (!Files.isDirectory(root)) {\n+            throw exceptionBuilder.create();\n+        } else {\n+            try (var rootDirContents = Files.list(root)) {\n+                if (rootDirContents.findAny().isPresent()) {\n+                    throw exceptionBuilder.create();\n+                }\n+            } catch (IOException ioe) {\n+                throw exceptionBuilder.cause(ioe).create();\n+            }\n+        }\n+\n+        return BuildEnv.withAppImageDir(BuildEnv.create(root, Optional.ofNullable(resourceDir),\n+                verbose, ResourceLocator.class), appImageDir);\n+    }\n+\n+    BuildEnvBuilder verbose(boolean v) {\n+        verbose = v;\n+        return this;\n+    }\n+\n+    BuildEnvBuilder resourceDir(Path v) {\n+        resourceDir = v;\n+        return this;\n+    }\n+\n+    BuildEnvBuilder appImageDir(Path v) {\n+        appImageDir = v;\n+        return this;\n+    }\n+\n+    BuildEnvBuilder appImageDirFor(Application app) {\n+        appImageDir = defaultAppImageDir(root).resolve(app.appImageDirName());\n+        return this;\n+    }\n+\n+    BuildEnvBuilder appImageDirForPackage() {\n+        appImageDir = defaultAppImageDir(root);\n+        return this;\n+    }\n+\n+    private static Path defaultAppImageDir(Path root) {\n+        return root.resolve(\"image\");\n+    }\n+\n+    private Path appImageDir;\n+    private Path resourceDir;\n+    private boolean verbose;\n+\n+    private final Path root;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvBuilder.java","additions":99,"deletions":0,"binary":false,"changes":99,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n+import static jdk.jpackage.internal.StandardBundlerParam.VERBOSE;\n+\n+import java.util.Map;\n+import jdk.jpackage.internal.model.ConfigException;\n+\n+final class BuildEnvFromParams {\n+\n+    static BuildEnv create(Map<String, ? super Object> params) throws ConfigException {\n+\n+        final var builder = new BuildEnvBuilder(TEMP_ROOT.fetchFrom(params));\n+\n+        RESOURCE_DIR.copyInto(params, builder::resourceDir);\n+        VERBOSE.copyInto(params, builder::verbose);\n+\n+        final var app = FromParams.APPLICATION.findIn(params).orElseThrow();\n+\n+        final var pkg = FromParams.getCurrentPackage(params);\n+\n+        if (app.isRuntime()) {\n+            builder.appImageDir(PREDEFINED_RUNTIME_IMAGE.fetchFrom(params));\n+        } else if (StandardBundlerParam.hasPredefinedAppImage(params)) {\n+            builder.appImageDir(StandardBundlerParam.getPredefinedAppImage(params));\n+        } else if (pkg.isPresent()) {\n+            builder.appImageDirForPackage();\n+        } else {\n+            builder.appImageDirFor(app);\n+        }\n+\n+        return builder.create();\n+    }\n+\n+    static final BundlerParamInfo<BuildEnv> BUILD_ENV = BundlerParamInfo.createBundlerParam(\n+            BuildEnv.class, BuildEnvFromParams::create);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BuildEnvFromParams.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.file.Path;\n@@ -29,0 +30,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -30,0 +33,1 @@\n+import java.util.function.Consumer;\n@@ -31,0 +35,1 @@\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n@@ -36,0 +41,9 @@\n+ *\n+ * @param id The command line and hashmap name of the parameter\n+ *\n+ * @param valueType Type of the parameter\n+ *\n+ * @param defaultValueFunction If the value is not set, and no fallback value is found, the\n+ * parameter uses the value returned by the producer.\n+ *\n+ * @param stringConverter An optional string converter for command line arguments.\n@@ -37,1 +51,3 @@\n-class BundlerParamInfo<T> {\n+record BundlerParamInfo<T>(String id, Class<T> valueType,\n+        Function<Map<String, ? super Object>, T> defaultValueFunction,\n+        BiFunction<String, Map<String, ? super Object>, T> stringConverter) {\n@@ -39,4 +55,4 @@\n-    \/**\n-     * The command line and hashmap name of the parameter\n-     *\/\n-    String id;\n+    BundlerParamInfo {\n+        Objects.requireNonNull(id);\n+        Objects.requireNonNull(valueType);\n+    }\n@@ -44,4 +60,3 @@\n-    \/**\n-     * Type of the parameter\n-     *\/\n-    Class<T> valueType;\n+    static BundlerParamInfo<String> createStringBundlerParam(String id) {\n+        return new BundlerParamInfo<>(id, String.class, null, null);\n+    }\n@@ -49,5 +64,3 @@\n-    \/**\n-     * If the value is not set, and no fallback value is found,\n-     * the parameter uses the value returned by the producer.\n-     *\/\n-    Function<Map<String, ? super Object>, T> defaultValueFunction;\n+    static BundlerParamInfo<Boolean> createBooleanBundlerParam(String id) {\n+        return new BundlerParamInfo<>(id, Boolean.class, null, BundlerParamInfo::toBoolean);\n+    }\n@@ -55,4 +68,26 @@\n-    \/**\n-     * An optional string converter for command line arguments.\n-     *\/\n-    BiFunction<String, Map<String, ? super Object>, T> stringConverter;\n+    static BundlerParamInfo<Path> createPathBundlerParam(String id) {\n+        return new BundlerParamInfo<>(id, Path.class, null, BundlerParamInfo::toPath);\n+    }\n+\n+    @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n+    static <U> BundlerParamInfo<U> createBundlerParam(String id, Class<? super U> valueType,\n+            ThrowingFunction<Map<String, ? super Object>, U> valueCtor) {\n+        return new BundlerParamInfo(id, valueType, ThrowingFunction.toFunction(valueCtor), null);\n+    }\n+\n+    static <U> BundlerParamInfo<U> createBundlerParam(Class<? super U> valueType,\n+            ThrowingFunction<Map<String, ? super Object>, U> valueCtor) {\n+        return createBundlerParam(valueType.getName(), valueType, valueCtor);\n+    }\n+\n+    static boolean toBoolean(String value, Map<String, ? super Object> params) {\n+        if (value == null || \"null\".equalsIgnoreCase(value)) {\n+            return false;\n+        } else {\n+            return Boolean.valueOf(value);\n+        }\n+    }\n+\n+    static Path toPath(String value, Map<String, ? super Object> params) {\n+        return Path.of(value);\n+    }\n@@ -69,2 +104,1 @@\n-     * Returns true if value was not provided on command line for this\n-     * parameter.\n+     * Returns true if value was not provided on command line for this parameter.\n@@ -92,2 +126,1 @@\n-    BiFunction<String, Map<String, ? super Object>,T>\n-            getStringConverter() {\n+    BiFunction<String, Map<String, ? super Object>, T> getStringConverter() {\n@@ -106,1 +139,1 @@\n-            return getStringConverter().apply((String)o, params);\n+            return getStringConverter().apply((String) o, params);\n@@ -124,1 +157,1 @@\n-            T result =  getDefaultValueFunction().apply(params);\n+            T result = getDefaultValueFunction().apply(params);\n@@ -134,0 +167,12 @@\n+\n+    Optional<T> findIn(Map<String, ? super Object> params) {\n+        if (params.containsKey(getID())) {\n+            return Optional.of(fetchFrom(params, true));\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    void copyInto(Map<String, ? super Object> params, Consumer<T> consumer) {\n+        findIn(params).ifPresent(consumer);\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/BundlerParamInfo.java","additions":69,"deletions":24,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.io.File;\n@@ -34,0 +33,1 @@\n+import java.util.Optional;\n@@ -35,5 +35,7 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.JAVA_OPTIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.ARGUMENTS;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherJarStartupInfo;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfo;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+\n@@ -45,11 +47,4 @@\n-    CfgFile() {\n-        appLayout = ApplicationLayout.platformAppImage();\n-    }\n-\n-    CfgFile initFromParams(Map<String, ? super Object> params) {\n-        launcherData = LAUNCHER_DATA.fetchFrom(params);\n-        launcherName = APP_NAME.fetchFrom(params);\n-        javaOptions = JAVA_OPTIONS.fetchFrom(params);\n-        arguments = ARGUMENTS.fetchFrom(params);\n-        version = VERSION.fetchFrom(params);\n-        return this;\n+    CfgFile(Application app, Launcher launcher) {\n+        startupInfo = launcher.startupInfo().orElseThrow();\n+        outputFileName = launcher.executableName() + \".cfg\";\n+        version = app.version();\n@@ -58,1 +53,1 @@\n-    void create(Path appImage) throws IOException {\n+    void create(ApplicationLayout appLayout) throws IOException {\n@@ -61,1 +56,1 @@\n-        ApplicationLayout appCfgLayout = createAppCfgLayout();\n+        final var refs = new Referencies(appLayout);\n@@ -65,13 +60,10 @@\n-        if (launcherData.isModular()) {\n-            content.add(Map.entry(\"app.mainmodule\", launcherData.moduleName()\n-                    + \"\/\" + launcherData.qualifiedClassName()));\n-        } else {\n-            if (launcherData.mainJarName() != null) {\n-                Path mainJarPath = appCfgLayout.appDirectory().resolve(\n-                        launcherData.mainJarName());\n-\n-                if (launcherData.isClassNameFromMainJar()) {\n-                    content.add(Map.entry(\"app.mainjar\", mainJarPath));\n-                } else {\n-                    content.add(Map.entry(\"app.classpath\", mainJarPath));\n-                }\n+        if (startupInfo instanceof LauncherModularStartupInfo modularStartupInfo) {\n+            content.add(Map.entry(\"app.mainmodule\", modularStartupInfo.moduleName()\n+                    + \"\/\" + startupInfo.qualifiedClassName()));\n+        } else if (startupInfo instanceof LauncherJarStartupInfo jarStartupInfo) {\n+            Path mainJarPath = refs.appDirectory().resolve(jarStartupInfo.jarPath());\n+\n+            if (jarStartupInfo.isJarWithMainClass()) {\n+                content.add(Map.entry(\"app.mainjar\", mainJarPath));\n+            } else {\n+                content.add(Map.entry(\"app.classpath\", mainJarPath));\n@@ -80,3 +72,2 @@\n-            if (!launcherData.isClassNameFromMainJar()) {\n-                content.add(Map.entry(\"app.mainclass\",\n-                        launcherData.qualifiedClassName()));\n+            if (!jarStartupInfo.isJarWithMainClass()) {\n+                content.add(Map.entry(\"app.mainclass\", startupInfo.qualifiedClassName()));\n@@ -84,0 +75,2 @@\n+        } else {\n+            throw new UnsupportedOperationException();\n@@ -86,1 +79,1 @@\n-        for (var value : launcherData.classPath()) {\n+        for (var value : Optional.ofNullable(startupInfo.classPath()).orElseGet(List::of)) {\n@@ -88,1 +81,1 @@\n-                    appCfgLayout.appDirectory().resolve(value).toString()));\n+                    refs.appDirectory().resolve(value).toString()));\n@@ -91,3 +84,0 @@\n-        ApplicationLayout appImagelayout = appLayout.resolveAt(appImage);\n-        Path modsDir = appImagelayout.appModsDirectory();\n-\n@@ -101,1 +91,1 @@\n-        for (var value : javaOptions) {\n+        for (var value : Optional.ofNullable(startupInfo.javaOptions()).orElseGet(List::of)) {\n@@ -106,1 +96,1 @@\n-        if (Files.isDirectory(modsDir)) {\n+        if (Files.isDirectory(appLayout.appModsDirectory())) {\n@@ -108,2 +98,1 @@\n-            content.add(Map.entry(\"java-options\",\n-                    appCfgLayout.appModsDirectory()));\n+            content.add(Map.entry(\"java-options\", refs.appModsDirectory()));\n@@ -112,0 +101,1 @@\n+        var arguments = Optional.ofNullable(startupInfo.defaultParameters()).orElseGet(List::of);\n@@ -119,2 +109,2 @@\n-        Path cfgFile = appImagelayout.appDirectory().resolve(launcherName + \".cfg\");\n-        Files.createDirectories(IOUtils.getParent(cfgFile));\n+        Path cfgFile = appLayout.appDirectory().resolve(outputFileName);\n+        Files.createDirectories(cfgFile.getParent());\n@@ -136,7 +126,15 @@\n-    private ApplicationLayout createAppCfgLayout() {\n-        ApplicationLayout appCfgLayout = appLayout.resolveAt(Path.of(\"$ROOTDIR\"));\n-        appCfgLayout.pathGroup().setPath(ApplicationLayout.PathRole.APP,\n-                Path.of(\"$APPDIR\"));\n-        appCfgLayout.pathGroup().setPath(ApplicationLayout.PathRole.MODULES,\n-                appCfgLayout.appDirectory().resolve(appCfgLayout.appModsDirectory().getFileName()));\n-        return appCfgLayout;\n+    private record Referencies(Path appModsDirectory) {\n+\n+        Referencies {\n+            if (!appModsDirectory.startsWith(appDirectory())) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        Referencies(ApplicationLayout appLayout) {\n+            this(Path.of(\"$APPDIR\").resolve(appLayout.appModsDirectory().getFileName()));\n+        }\n+\n+        Path appDirectory() {\n+            return Path.of(\"$APPDIR\");\n+        }\n@@ -145,6 +143,3 @@\n-    private String launcherName;\n-    private String version;\n-    private LauncherData launcherData;\n-    List<String> arguments;\n-    List<String> javaOptions;\n-    private final ApplicationLayout appLayout;\n+    private final LauncherStartupInfo startupInfo;\n+    private final String version;\n+    private final String outputFileName;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CfgFile.java","additions":55,"deletions":60,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+final class CompositeProxyTunnel implements CompositeProxy.InvokeTunnel {\n+\n+    @Override\n+    public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\n+        return method.invoke(obj, args);\n+    }\n+\n+    @Override\n+    public Object invokeDefault(Object proxy, Method method, Object[] args) throws Throwable {\n+        return InvocationHandler.invokeDefault(proxy, method, args);\n+    }\n+\n+    static final CompositeProxyTunnel INSTANCE = new CompositeProxyTunnel();\n+\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/CompositeProxyTunnel.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -1,108 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.Collections;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import jdk.jpackage.internal.model.ConfigException;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_EXTENSIONS;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_CONTENT_TYPE;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.FA_DESCRIPTION;\n-\n-final class FileAssociation {\n-    void verify() {\n-        if (extensions.isEmpty()) {\n-            Log.error(I18N.getString(\n-                    \"message.creating-association-with-null-extension\"));\n-        }\n-    }\n-\n-    static void verify(List<FileAssociation> associations) throws ConfigException {\n-        \/\/ only one mime type per association, at least one file extension\n-        int assocIdx = 0;\n-        for (var assoc : associations) {\n-            ++assocIdx;\n-            if (assoc.mimeTypes.isEmpty()) {\n-                String msgKey = \"error.no-content-types-for-file-association\";\n-                throw new ConfigException(\n-                        MessageFormat.format(I18N.getString(msgKey), assocIdx),\n-                        MessageFormat.format(I18N.getString(msgKey + \".advice\"), assocIdx));\n-            }\n-\n-            if (assoc.mimeTypes.size() > 1) {\n-                String msgKey = \"error.too-many-content-types-for-file-association\";\n-                throw new ConfigException(\n-                        MessageFormat.format(I18N.getString(msgKey), assocIdx),\n-                        MessageFormat.format(I18N.getString(msgKey + \".advice\"), assocIdx));\n-            }\n-\n-            assoc.verify();\n-        }\n-    }\n-\n-    static List<FileAssociation> fetchFrom(Map<String, ? super Object> params) {\n-        String launcherName = APP_NAME.fetchFrom(params);\n-\n-        return FILE_ASSOCIATIONS.fetchFrom(params).stream().filter(\n-                Objects::nonNull).map(fa -> {\n-                    FileAssociation assoc = new FileAssociation();\n-\n-                    assoc.launcherPath = Path.of(launcherName);\n-                    assoc.description = Optional.ofNullable(\n-                            FA_DESCRIPTION.fetchFrom(fa))\n-                            .orElse(launcherName + \" association\");\n-                    assoc.extensions = Optional.ofNullable(\n-                            FA_EXTENSIONS.fetchFrom(fa))\n-                            .orElse(Collections.emptyList());\n-                    assoc.mimeTypes = Optional.ofNullable(\n-                            FA_CONTENT_TYPE.fetchFrom(fa))\n-                            .orElse(Collections.emptyList());\n-\n-                    Path icon = FA_ICON.fetchFrom(fa);\n-                    if (icon != null) {\n-                        assoc.iconPath = icon;\n-                    }\n-\n-                    return assoc;\n-                }).toList();\n-    }\n-\n-    Path launcherPath;\n-    Path iconPath;\n-    List<String> mimeTypes;\n-    List<String> extensions;\n-    String description;\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FileAssociation.java","additions":0,"deletions":108,"binary":false,"changes":108,"status":"deleted"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.util.CollectionUtils;\n+\n+final record FileAssociationGroup(List<FileAssociation> items) {\n+\n+    FileAssociationGroup {\n+        Objects.requireNonNull(items);\n+    }\n+\n+    boolean isEmpty() {\n+        return items.isEmpty();\n+    }\n+\n+    static Stream<FileAssociation> flatMap(Stream<FileAssociationGroup> groups) {\n+        return groups.map(FileAssociationGroup::items).flatMap(List::stream);\n+    }\n+\n+    static UnaryOperator<FileAssociationGroup> map(UnaryOperator<FileAssociation> mapper) {\n+        return group -> {\n+            return new FileAssociationGroup(group.items.stream().map(mapper).filter(Objects::nonNull).toList());\n+        };\n+    }\n+\n+    static UnaryOperator<FileAssociationGroup> filter(Predicate<FileAssociation> filter) {\n+        return group -> {\n+            return new FileAssociationGroup(group.items.stream().filter(filter).toList());\n+        };\n+    }\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    static class FileAssociationException extends Exception {\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    static final class FileAssociationNoMimesException extends FileAssociationException {\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    static final class FileAssociationNoExtensionsException extends FileAssociationException {\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    static final class Builder {\n+\n+        private Builder() {\n+        }\n+\n+        FileAssociationGroup create() throws FileAssociationException {\n+            if (mimeTypes == null || mimeTypes.isEmpty()) {\n+                throw new FileAssociationNoMimesException();\n+            }\n+\n+            if (extensions == null || extensions.isEmpty()) {\n+                throw new FileAssociationNoExtensionsException();\n+            }\n+\n+            return new FileAssociationGroup(mimeTypes.stream().map(mimeType -> {\n+                return extensions.stream().map(ext -> {\n+                    return createFileAssociation(mimeType, ext);\n+                });\n+            }).flatMap(x -> x).toList());\n+        }\n+\n+        Builder icon(Path v) {\n+            icon = v;\n+            return this;\n+        }\n+\n+        Builder description(String v) {\n+            description = v;\n+            return this;\n+        }\n+\n+        Builder mimeTypes(Collection<String> v) {\n+            mimeTypes = CollectionUtils.toSet(v);\n+            return this;\n+        }\n+\n+        Builder extensions(Collection<String> v) {\n+            extensions = CollectionUtils.toSet(v);\n+            return this;\n+        }\n+\n+        private FileAssociation createFileAssociation(String mimeType, String ext) {\n+            Objects.requireNonNull(ext);\n+            Objects.requireNonNull(mimeType);\n+            return new FileAssociation.Stub(Optional.ofNullable(description), Optional.ofNullable(icon), mimeType, ext);\n+        }\n+\n+        private Path icon;\n+        private String description;\n+        private Set<String> mimeTypes;\n+        private Set<String> extensions;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FileAssociationGroup.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.collectingAndThen;\n+import static java.util.stream.Collectors.groupingBy;\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import jdk.jpackage.internal.model.FileAssociation;\n+\n+final class FileAssociationScaner {\n+\n+    record Result(Map<MimeType, List<FileAssociation>> mimeTypesWithMultipleExtensions,\n+            Map<Extension, List<FileAssociation>> extensionsWithMultipleMimeTypes,\n+            Map<MimeTypeWithExtension, List<FileAssociation>> duplicates) {\n+    }\n+\n+    Result scan(Collection<FileAssociation> fileAssociations) {\n+        if (fileAssociations.stream().map(Box::new).distinct().count() != fileAssociations.size()) {\n+            throw new IllegalArgumentException(\"Multiple occurrences of the same fa instance in the given container\");\n+        }\n+\n+        final var mimeTypesWithMultipleExtensions = fileAssociations.stream().collect(\n+                collectingAndThen(groupingBy(MimeType::new), FileAssociationScaner::filterDuplicates));\n+        final var extensionsWithMultipleMimeTypes = fileAssociations.stream().collect(\n+                collectingAndThen(groupingBy(Extension::new), FileAssociationScaner::filterDuplicates));\n+        final var duplicates = fileAssociations.stream().collect(\n+                collectingAndThen(groupingBy(MimeTypeWithExtension::new), FileAssociationScaner::filterDuplicates));\n+\n+        return new Result(mimeTypesWithMultipleExtensions, extensionsWithMultipleMimeTypes, duplicates);\n+    }\n+\n+    private static <T> Map<T, List<FileAssociation>> filterDuplicates(Map<T, List<FileAssociation>> v) {\n+        return v.entrySet().stream().filter(e -> {\n+            return e.getValue().size() > 1;\n+        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    record MimeTypeWithExtension(String mimeType, String extension) {\n+        MimeTypeWithExtension(FileAssociation fa) {\n+            this(fa.mimeType(), fa.extension());\n+        }\n+    }\n+\n+    record MimeType(String value) {\n+        MimeType(FileAssociation fa) {\n+            this(fa.mimeType());\n+        }\n+    }\n+\n+    record Extension(String value) {\n+        Extension(FileAssociation fa) {\n+            this(fa.extension());\n+        }\n+    }\n+\n+    private static class Box {\n+        Box(FileAssociation value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public boolean equals(Object other) {\n+            return value == ((Box)other).value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return value.hashCode();\n+        }\n+\n+        private final FileAssociation value;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FileAssociationScaner.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,202 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n+import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n+import static jdk.jpackage.internal.StandardBundlerParam.ADD_MODULES;\n+import static jdk.jpackage.internal.StandardBundlerParam.APP_CONTENT;\n+import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n+import static jdk.jpackage.internal.StandardBundlerParam.COPYRIGHT;\n+import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n+import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n+import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n+import static jdk.jpackage.internal.StandardBundlerParam.INSTALLER_NAME;\n+import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.JLINK_OPTIONS;\n+import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n+import static jdk.jpackage.internal.StandardBundlerParam.LIMIT_MODULES;\n+import static jdk.jpackage.internal.StandardBundlerParam.MODULE_PATH;\n+import static jdk.jpackage.internal.StandardBundlerParam.NAME;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE_FILE;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_RUNTIME_IMAGE;\n+import static jdk.jpackage.internal.StandardBundlerParam.SOURCE_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n+import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n+import static jdk.jpackage.internal.StandardBundlerParam.getPredefinedAppImage;\n+import static jdk.jpackage.internal.StandardBundlerParam.hasPredefinedAppImage;\n+import static jdk.jpackage.internal.StandardBundlerParam.isRuntimeInstaller;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import jdk.jpackage.internal.AppImageFile.LauncherInfo;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.util.function.ThrowingFunction;\n+\n+final class FromParams {\n+\n+    static ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n+            Function<Map<String, ? super Object>, Launcher> launcherMapper,\n+            ApplicationLayout appLayout) throws ConfigException, IOException {\n+        return createApplicationBuilder(params, launcherMapper, appLayout, Optional.of(RuntimeLayout.DEFAULT));\n+    }\n+\n+    static ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n+            Function<Map<String, ? super Object>, Launcher> launcherMapper,\n+            ApplicationLayout appLayout, Optional<RuntimeLayout> predefinedRuntimeLayout) throws ConfigException, IOException {\n+\n+        final var appBuilder = new ApplicationBuilder();\n+\n+        APP_NAME.copyInto(params, appBuilder::name);\n+        DESCRIPTION.copyInto(params, appBuilder::description);\n+        appBuilder.version(VERSION.fetchFrom(params));\n+        VENDOR.copyInto(params, appBuilder::vendor);\n+        COPYRIGHT.copyInto(params, appBuilder::copyright);\n+        SOURCE_DIR.copyInto(params, appBuilder::srcDir);\n+        APP_CONTENT.copyInto(params, appBuilder::contentDirs);\n+\n+        final var isRuntimeInstaller = isRuntimeInstaller(params);\n+\n+        final var predefinedRuntimeImage = PREDEFINED_RUNTIME_IMAGE.findIn(params);\n+\n+        final var predefinedRuntimeDirectory = predefinedRuntimeLayout.flatMap(\n+                layout -> predefinedRuntimeImage.map(layout::resolveAt)).map(RuntimeLayout::runtimeDirectory);\n+\n+        if (isRuntimeInstaller) {\n+            appBuilder.appImageLayout(predefinedRuntimeLayout.orElseThrow());\n+        } else {\n+            appBuilder.appImageLayout(appLayout);\n+\n+            if (hasPredefinedAppImage(params)) {\n+                final var appImageFile = PREDEFINED_APP_IMAGE_FILE.fetchFrom(params);\n+                appBuilder.initFromAppImage(appImageFile, launcherInfo -> {\n+                    var launcherParams = mapLauncherInfo(launcherInfo);\n+                    return launcherMapper.apply(mergeParams(params, launcherParams));\n+                });\n+            } else {\n+                final var launchers = createLaunchers(params, launcherMapper);\n+\n+                final var runtimeBuilderBuilder = new RuntimeBuilderBuilder();\n+\n+                MODULE_PATH.copyInto(params, runtimeBuilderBuilder::modulePath);\n+\n+                predefinedRuntimeDirectory.ifPresentOrElse(runtimeBuilderBuilder::forRuntime, () -> {\n+                    final var startupInfos = launchers.asList().stream()\n+                            .map(Launcher::startupInfo)\n+                            .map(Optional::orElseThrow).toList();\n+                    final var jlinkOptionsBuilder = runtimeBuilderBuilder.forNewRuntime(startupInfos);\n+                    ADD_MODULES.copyInto(params, jlinkOptionsBuilder::addModules);\n+                    LIMIT_MODULES.copyInto(params, jlinkOptionsBuilder::limitModules);\n+                    JLINK_OPTIONS.copyInto(params, jlinkOptionsBuilder::options);\n+                    jlinkOptionsBuilder.appy();\n+                });\n+\n+                appBuilder.launchers(launchers).runtimeBuilder(runtimeBuilderBuilder.create());\n+            }\n+        }\n+\n+        return appBuilder;\n+    }\n+\n+    static PackageBuilder createPackageBuilder(\n+            Map<String, ? super Object> params, Application app,\n+            PackageType type) throws ConfigException {\n+\n+        final var builder = new PackageBuilder(app, type);\n+\n+        builder.name(INSTALLER_NAME.fetchFrom(params));\n+        DESCRIPTION.copyInto(params, builder::description);\n+        VERSION.copyInto(params, builder::version);\n+        ABOUT_URL.copyInto(params, builder::aboutURL);\n+        LICENSE_FILE.findIn(params).map(Path::of).ifPresent(builder::licenseFile);\n+        builder.predefinedAppImage(getPredefinedAppImage(params));\n+        INSTALL_DIR.findIn(params).map(Path::of).ifPresent(builder::installDir);\n+\n+        return builder;\n+    }\n+\n+    static <T extends Application> BundlerParamInfo<T> createApplicationBundlerParam(\n+            ThrowingFunction<Map<String, ? super Object>, T> ctor) {\n+        return BundlerParamInfo.createBundlerParam(Application.class, ctor);\n+    }\n+\n+    static <T extends jdk.jpackage.internal.model.Package> BundlerParamInfo<T> createPackageBundlerParam(\n+            ThrowingFunction<Map<String, ? super Object>, T> ctor) {\n+        return BundlerParamInfo.createBundlerParam(jdk.jpackage.internal.model.Package.class, ctor);\n+    }\n+\n+    static Optional<jdk.jpackage.internal.model.Package> getCurrentPackage(Map<String, ? super Object> params) {\n+        return Optional.ofNullable((jdk.jpackage.internal.model.Package)params.get(\n+                jdk.jpackage.internal.model.Package.class.getName()));\n+    }\n+\n+    private static ApplicationLaunchers createLaunchers(\n+            Map<String, ? super Object> params,\n+            Function<Map<String, ? super Object>, Launcher> launcherMapper) {\n+        var launchers = ADD_LAUNCHERS.findIn(params).orElseGet(List::of);\n+\n+        var mainLauncher = launcherMapper.apply(params);\n+        var additionalLaunchers = launchers.stream().map(launcherParams -> {\n+            return launcherMapper.apply(mergeParams(params, launcherParams));\n+        }).toList();\n+\n+        return new ApplicationLaunchers(mainLauncher, additionalLaunchers);\n+    }\n+\n+    private static Map<String, ? super Object> mapLauncherInfo(LauncherInfo launcherInfo) {\n+        Map<String, ? super Object> launcherParams = new HashMap<>();\n+        launcherParams.put(NAME.getID(), launcherInfo.name());\n+        launcherParams.put(LAUNCHER_AS_SERVICE.getID(), Boolean.toString(launcherInfo.service()));\n+        launcherParams.putAll(launcherInfo.extra());\n+        return launcherParams;\n+    }\n+\n+    private static Map<String, ? super Object> mergeParams(Map<String, ? super Object> mainParams,\n+            Map<String, ? super Object> launcherParams) {\n+        if (!launcherParams.containsKey(DESCRIPTION.getID())) {\n+            launcherParams = new HashMap<>(launcherParams);\n+\/\/ FIXME: this is a good improvement but it fails existing tests\n+\/\/            launcherParams.put(DESCRIPTION.getID(), String.format(\"%s (%s)\", DESCRIPTION.fetchFrom(\n+\/\/                    mainParams), APP_NAME.fetchFrom(launcherParams)));\n+            launcherParams.put(DESCRIPTION.getID(), DESCRIPTION.fetchFrom(mainParams));\n+        }\n+        return AddLauncherArguments.merge(mainParams, launcherParams, ICON.getID(), ADD_LAUNCHERS\n+                .getID(), FILE_ASSOCIATIONS.getID());\n+    }\n+\n+    static final BundlerParamInfo<Application> APPLICATION = createApplicationBundlerParam(null);\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":202,"deletions":0,"binary":false,"changes":202,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import java.text.MessageFormat;\n@@ -30,1 +29,0 @@\n-import java.util.ResourceBundle;\n@@ -32,0 +30,2 @@\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.util.LocalizedExceptionBuilder;\n@@ -33,0 +33,1 @@\n+import jdk.jpackage.internal.util.StringBundle;\n@@ -34,1 +35,1 @@\n-class I18N {\n+final class I18N {\n@@ -41,6 +42,1 @@\n-        var str = getString(key);\n-        if (args.length != 0) {\n-            return MessageFormat.format(str, args);\n-        } else {\n-            return str;\n-        }\n+        return BUNDLE.format(key, args);\n@@ -49,1 +45,17 @@\n-    private static final ResourceBundle BUNDLE;\n+    static LocalizedExceptionBuilder<?> buildException() {\n+        return LocalizedExceptionBuilder.buildLocalizedException(BUNDLE);\n+    }\n+\n+    static ConfigException.Builder buildConfigException() {\n+        return ConfigException.build(BUNDLE);\n+    }\n+\n+    static ConfigException.Builder buildConfigException(String msgId, Object ... args) {\n+        return ConfigException.build(BUNDLE, msgId, args);\n+    }\n+\n+    static ConfigException.Builder buildConfigException(Throwable t) {\n+        return ConfigException.build(BUNDLE, t);\n+    }\n+\n+    private static final StringBundle BUNDLE;\n@@ -53,1 +65,1 @@\n-        BUNDLE = MultiResourceBundle.create(\n+        BUNDLE = StringBundle.fromResourceBundle(MultiResourceBundle.create(\n@@ -60,1 +72,1 @@\n-        );\n+        ));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/I18N.java","additions":24,"deletions":12,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Objects;\n@@ -30,32 +29,8 @@\n-final class InstallableFile {\n-\n-    InstallableFile(Path srcPath, Path installPath) {\n-        Objects.requireNonNull(srcPath);\n-\n-        this.srcPath = srcPath;\n-        this.installPath = installPath;\n-    }\n-\n-    Path installPath() {\n-        return installPath;\n-    }\n-\n-    Path srcPath() {\n-        return srcPath;\n-    }\n-\n-    void applyToApplicationLayouts(ApplicationLayout src,\n-            ApplicationLayout install) {\n-        var key = new Object();\n-        src.pathGroup().setPath(key, srcPath);\n-        if (installPath != null && install != null) {\n-            install.pathGroup().setPath(key, installPath);\n-        }\n-    }\n-\n-    void excludeFromApplicationLayout(ApplicationLayout layout) {\n-        applyToApplicationLayouts(layout, null);\n-    }\n-\n-    private final Path installPath;\n-    private final Path srcPath;\n+\/**\n+ * Source file that should be copied somewhere in application image tree.\n+ *\n+ * Has two paths:\n+ *  - path where it should be picked from;\n+ *  - path where it should be copied in application image;\n+ *\/\n+record InstallableFile(Path srcPath, Path installPath) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/InstallableFile.java","additions":9,"deletions":34,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -1,229 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.File;\n-import java.io.IOException;\n-import java.io.PrintWriter;\n-import java.io.StringWriter;\n-import java.lang.module.Configuration;\n-import java.lang.module.ModuleDescriptor;\n-import java.lang.module.ModuleFinder;\n-import java.lang.module.ModuleReference;\n-import java.lang.module.ResolvedModule;\n-import java.nio.file.Path;\n-import java.util.ArrayList;\n-import java.util.Collection;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.function.Supplier;\n-import java.util.jar.JarFile;\n-import java.util.regex.Matcher;\n-import java.util.spi.ToolProvider;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n-\n-import jdk.internal.module.ModulePath;\n-import jdk.jpackage.internal.model.PackagerException;\n-\n-\n-final class JLinkBundlerHelper {\n-\n-    static void execute(Map<String, ? super Object> params, Path outputDir)\n-            throws IOException, PackagerException {\n-\n-        List<Path> modulePath =\n-                StandardBundlerParam.MODULE_PATH.fetchFrom(params);\n-        Set<String> addModules =\n-                StandardBundlerParam.ADD_MODULES.fetchFrom(params);\n-        Set<String> limitModules =\n-                StandardBundlerParam.LIMIT_MODULES.fetchFrom(params);\n-        List<String> options =\n-                StandardBundlerParam.JLINK_OPTIONS.fetchFrom(params);\n-\n-        LauncherData launcherData = StandardBundlerParam.LAUNCHER_DATA.fetchFrom(\n-                params);\n-\n-        \/\/ Modules\n-        if (!launcherData.isModular() && addModules.isEmpty()) {\n-            addModules.add(ALL_DEFAULT);\n-        }\n-\n-        Set<String> modules = createModuleList(modulePath, addModules, limitModules);\n-\n-        if (launcherData.isModular()) {\n-            modules.add(launcherData.moduleName());\n-        }\n-\n-        runJLink(outputDir, modulePath, modules, limitModules, options);\n-    }\n-\n-    \/*\n-     * Returns the set of modules that would be visible by default for\n-     * a non-modular-aware application consisting of the given elements.\n-     *\/\n-    private static Set<String> getDefaultModules(\n-            Collection<Path> paths, Collection<String> addModules) {\n-\n-        \/\/ the modules in the run-time image that export an API\n-        Stream<String> systemRoots = ModuleFinder.ofSystem().findAll().stream()\n-                .map(ModuleReference::descriptor)\n-                .filter(JLinkBundlerHelper::exportsAPI)\n-                .map(ModuleDescriptor::name);\n-\n-        Set<String> roots = Stream.concat(systemRoots,\n-                 addModules.stream()).collect(Collectors.toSet());\n-\n-        ModuleFinder finder = createModuleFinder(paths);\n-\n-        \/\/ Don't perform service bindings by default as outlined by JEP 343\n-        \/\/ and JEP 392\n-        return Configuration.empty()\n-                .resolve(finder, ModuleFinder.of(), roots)\n-                .modules()\n-                .stream()\n-                .map(ResolvedModule::name)\n-                .collect(Collectors.toSet());\n-    }\n-\n-    \/*\n-     * Returns true if the given module exports an API to all module.\n-     *\/\n-    private static boolean exportsAPI(ModuleDescriptor descriptor) {\n-        return descriptor.exports()\n-                .stream()\n-                .anyMatch(e -> !e.isQualified());\n-    }\n-\n-    static ModuleFinder createModuleFinder(Collection<Path> modulePath) {\n-        return ModuleFinder.compose(\n-                ModulePath.of(JarFile.runtimeVersion(), true,\n-                        modulePath.toArray(Path[]::new)),\n-                ModuleFinder.ofSystem());\n-    }\n-\n-    private static Set<String> createModuleList(List<Path> paths,\n-            Set<String> addModules, Set<String> limitModules) {\n-\n-        final Set<String> modules = new HashSet<>();\n-\n-        final Map<String, Supplier<Collection<String>>> phonyModules = Map.of(\n-                ALL_MODULE_PATH,\n-                () -> createModuleFinder(paths)\n-                            .findAll()\n-                            .stream()\n-                            .map(ModuleReference::descriptor)\n-                            .map(ModuleDescriptor::name)\n-                            .collect(Collectors.toSet()),\n-                ALL_DEFAULT,\n-                () -> getDefaultModules(paths, modules));\n-\n-        Supplier<Collection<String>> phonyModule = null;\n-        for (var module : addModules) {\n-            phonyModule = phonyModules.get(module);\n-            if (phonyModule == null) {\n-                modules.add(module);\n-            }\n-        }\n-\n-        if (phonyModule != null) {\n-            modules.addAll(phonyModule.get());\n-        }\n-\n-        return modules;\n-    }\n-\n-    private static void runJLink(Path output, List<Path> modulePath,\n-            Set<String> modules, Set<String> limitModules,\n-            List<String> options)\n-            throws PackagerException, IOException {\n-\n-        ArrayList<String> args = new ArrayList<String>();\n-        args.add(\"--output\");\n-        args.add(output.toString());\n-        if (modulePath != null && !modulePath.isEmpty()) {\n-            args.add(\"--module-path\");\n-            args.add(getPathList(modulePath));\n-        }\n-        if (modules != null && !modules.isEmpty()) {\n-            args.add(\"--add-modules\");\n-            args.add(getStringList(modules));\n-        }\n-        if (limitModules != null && !limitModules.isEmpty()) {\n-            args.add(\"--limit-modules\");\n-            args.add(getStringList(limitModules));\n-        }\n-        if (options != null) {\n-            for (String option : options) {\n-                if (option.startsWith(\"--output\") ||\n-                        option.startsWith(\"--add-modules\") ||\n-                        option.startsWith(\"--module-path\")) {\n-                    throw new PackagerException(\"error.blocked.option\", option);\n-                }\n-                args.add(option);\n-            }\n-        }\n-\n-        StringWriter writer = new StringWriter();\n-        PrintWriter pw = new PrintWriter(writer);\n-\n-        int retVal = LazyLoad.JLINK_TOOL.run(pw, pw, args.toArray(new String[0]));\n-        String jlinkOut = writer.toString();\n-\n-        args.add(0, \"jlink\");\n-        Log.verbose(args, List.of(jlinkOut), retVal, -1);\n-\n-\n-        if (retVal != 0) {\n-            throw new PackagerException(\"error.jlink.failed\" , jlinkOut);\n-        }\n-    }\n-\n-    private static String getPathList(List<Path> pathList) {\n-        return pathList.stream()\n-                .map(Path::toString)\n-                .map(Matcher::quoteReplacement)\n-                .collect(Collectors.joining(File.pathSeparator));\n-    }\n-\n-    private static String getStringList(Set<String> strings) {\n-        return Matcher.quoteReplacement(strings.stream().collect(\n-                Collectors.joining(\",\")));\n-    }\n-\n-    \/\/ The token for \"all modules on the module path\".\n-    private static final String ALL_MODULE_PATH = \"ALL-MODULE-PATH\";\n-\n-    \/\/ The token for \"all valid runtime modules\".\n-    private static final String ALL_DEFAULT = \"ALL-DEFAULT\";\n-\n-    private static class LazyLoad {\n-        static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\n-                \"jlink\").orElseThrow();\n-    };\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkBundlerHelper.java","additions":0,"deletions":229,"binary":false,"changes":229,"status":"deleted"},{"patch":"@@ -0,0 +1,234 @@\n+\/*\n+ * Copyright (c) 2015, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.io.File;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.lang.module.Configuration;\n+import java.lang.module.ModuleDescriptor;\n+import java.lang.module.ModuleFinder;\n+import java.lang.module.ModuleReference;\n+import java.lang.module.ResolvedModule;\n+import java.nio.file.Path;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.jar.JarFile;\n+import java.util.spi.ToolProvider;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import jdk.internal.module.ModulePath;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfo;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+\n+final class JLinkRuntimeBuilder implements RuntimeBuilder {\n+\n+    private JLinkRuntimeBuilder(List<String> jlinkCmdLine) {\n+        this.jlinkCmdLine = jlinkCmdLine;\n+    }\n+\n+    @Override\n+    public void createRuntime(AppImageLayout appImageLayout) throws PackagerException {\n+        var args = new ArrayList<String>();\n+        args.add(\"--output\");\n+        args.add(appImageLayout.runtimeDirectory().toString());\n+        args.addAll(jlinkCmdLine);\n+\n+        StringWriter writer = new StringWriter();\n+        PrintWriter pw = new PrintWriter(writer);\n+\n+        int retVal = LazyLoad.JLINK_TOOL.run(pw, pw, args.toArray(String[]::new));\n+        String jlinkOut = writer.toString();\n+\n+        args.add(0, \"jlink\");\n+        Log.verbose(args, List.of(jlinkOut), retVal, -1);\n+        if (retVal != 0) {\n+            throw new PackagerException(\"error.jlink.failed\", jlinkOut);\n+        }\n+    }\n+\n+    static ModuleFinder createModuleFinder(Collection<Path> modulePath) {\n+        return ModuleFinder.compose(\n+                ModulePath.of(JarFile.runtimeVersion(), true,\n+                        modulePath.toArray(Path[]::new)),\n+                ModuleFinder.ofSystem());\n+    }\n+\n+    static RuntimeBuilder createJLinkRuntimeBuilder(List<Path> modulePath, Set<String> addModules,\n+            Set<String> limitModules, List<String> options, List<LauncherStartupInfo> startupInfos) throws ConfigException {\n+        return new JLinkRuntimeBuilder(createJLinkCmdline(modulePath, addModules, limitModules,\n+                options, startupInfos));\n+    }\n+\n+    private static List<String> createJLinkCmdline(List<Path> modulePath, Set<String> addModules,\n+            Set<String> limitModules, List<String> options, List<LauncherStartupInfo> startupInfos) throws ConfigException {\n+        List<String> launcherModules = startupInfos.stream().map(si -> {\n+            if (si instanceof LauncherModularStartupInfo siModular) {\n+                return siModular.moduleName();\n+            } else {\n+                return (String) null;\n+            }\n+        }).filter(Objects::nonNull).toList();\n+\n+        if (launcherModules.isEmpty() && addModules.isEmpty()) {\n+            addModules = Set.of(ALL_DEFAULT);\n+        }\n+\n+        var modules = createModuleList(modulePath, addModules, limitModules);\n+\n+        modules.addAll(launcherModules);\n+\n+        var args = new ArrayList<String>();\n+        if (!modulePath.isEmpty()) {\n+            args.add(\"--module-path\");\n+            args.add(getPathList(modulePath));\n+        }\n+        if (!modules.isEmpty()) {\n+            args.add(\"--add-modules\");\n+            args.add(getStringList(modules));\n+        }\n+        if (!limitModules.isEmpty()) {\n+            args.add(\"--limit-modules\");\n+            args.add(getStringList(limitModules));\n+        }\n+\n+        for (String option : options) {\n+            switch (option) {\n+                case \"--output\", \"--add-modules\", \"--module-path\" -> {\n+                    throw new ConfigException(MessageFormat.format(I18N.getString(\n+                            \"error.blocked.option\"), option), null);\n+                }\n+                default -> {\n+                    args.add(option);\n+                }\n+            }\n+        }\n+\n+        return args;\n+    }\n+\n+    \/*\n+     * Returns the set of modules that would be visible by default for\n+     * a non-modular-aware application consisting of the given elements.\n+     *\/\n+    private static Set<String> getDefaultModules(\n+            Collection<Path> paths, Collection<String> addModules) {\n+\n+        \/\/ the modules in the run-time image that export an API\n+        Stream<String> systemRoots = ModuleFinder.ofSystem().findAll().stream()\n+                .map(ModuleReference::descriptor)\n+                .filter(JLinkRuntimeBuilder::exportsAPI)\n+                .map(ModuleDescriptor::name);\n+\n+        Set<String> roots = Stream.concat(systemRoots,\n+                addModules.stream()).collect(Collectors.toSet());\n+\n+        ModuleFinder finder = createModuleFinder(paths);\n+\n+        \/\/ Don't perform service bindings by default as outlined by JEP 343\n+        \/\/ and JEP 392\n+        return Configuration.empty()\n+                .resolve(finder, ModuleFinder.of(), roots)\n+                .modules()\n+                .stream()\n+                .map(ResolvedModule::name)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    \/*\n+     * Returns true if the given module exports an API to all module.\n+     *\/\n+    private static boolean exportsAPI(ModuleDescriptor descriptor) {\n+        return descriptor.exports()\n+                .stream()\n+                .anyMatch(e -> !e.isQualified());\n+    }\n+\n+    private static Set<String> createModuleList(List<Path> paths,\n+            Set<String> addModules, Set<String> limitModules) {\n+\n+        final Set<String> modules = new HashSet<>();\n+\n+        final Map<String, Supplier<Collection<String>>> phonyModules = Map.of(\n+                ALL_MODULE_PATH,\n+                () -> createModuleFinder(paths)\n+                        .findAll()\n+                        .stream()\n+                        .map(ModuleReference::descriptor)\n+                        .map(ModuleDescriptor::name)\n+                        .collect(Collectors.toSet()),\n+                ALL_DEFAULT,\n+                () -> getDefaultModules(paths, modules));\n+\n+        Supplier<Collection<String>> phonyModule = null;\n+        for (var module : addModules) {\n+            phonyModule = phonyModules.get(module);\n+            if (phonyModule == null) {\n+                modules.add(module);\n+            }\n+        }\n+\n+        if (phonyModule != null) {\n+            modules.addAll(phonyModule.get());\n+        }\n+\n+        return modules;\n+    }\n+\n+    private static String getPathList(List<Path> pathList) {\n+        return pathList.stream()\n+                .map(Path::toString)\n+                .collect(Collectors.joining(File.pathSeparator));\n+    }\n+\n+    private static String getStringList(Set<String> strings) {\n+        return strings.stream().collect(Collectors.joining(\",\"));\n+    }\n+\n+    private final List<String> jlinkCmdLine;\n+\n+    \/\/ The token for \"all modules on the module path\".\n+    private static final String ALL_MODULE_PATH = \"ALL-MODULE-PATH\";\n+\n+    \/\/ The token for \"all valid runtime modules\".\n+    private static final String ALL_DEFAULT = \"ALL-DEFAULT\";\n+\n+    private static class LazyLoad {\n+\n+        static final ToolProvider JLINK_TOOL = ToolProvider.findFirst(\n+                \"jlink\").orElseThrow();\n+    };\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/JLinkRuntimeBuilder.java","additions":234,"deletions":0,"binary":false,"changes":234,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,3 +27,3 @@\n-import java.util.Map;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n+import java.util.Objects;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.Launcher;\n@@ -33,3 +33,4 @@\n-    LauncherAsService(String name, Map<String, Object> mainParams,\n-            OverridableResource resource) {\n-        if (name == null || APP_NAME.fetchFrom(mainParams).equals(name)) {\n+    LauncherAsService(Application app, Launcher launcher, OverridableResource resource) {\n+        this.name = launcher.name();\n+\n+        if (app.mainLauncher().orElseThrow() == launcher) {\n@@ -37,2 +38,1 @@\n-            name = APP_NAME.fetchFrom(mainParams);\n-            this.description = DESCRIPTION.fetchFrom(mainParams);\n+            this.description = launcher.description();\n@@ -41,2 +41,1 @@\n-            this.description = String.format(\"%s (%s)\", DESCRIPTION.fetchFrom(\n-                    mainParams), name);\n+            this.description = String.format(\"%s (%s)\", app.description(), name);\n@@ -45,2 +44,1 @@\n-        this.name = name;\n-        this.resource = resource;\n+        this.resource = Objects.requireNonNull(resource);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherAsService.java","additions":11,"deletions":13,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.CustomLauncherIcon;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.Launcher.Stub;\n+import jdk.jpackage.internal.model.LauncherIcon;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+\n+final class LauncherBuilder {\n+\n+    Launcher create() throws ConfigException {\n+        CustomLauncherIcon.fromLauncherIcon(icon)\n+                .map(CustomLauncherIcon::path)\n+                .ifPresent(toConsumer(LauncherBuilder::validateIcon));\n+\n+        final var fa = createFileAssociations(faSources, Optional.ofNullable(faTraits).orElse(DEFAULT_FA_TRAITS));\n+\n+        Objects.requireNonNull(defaultIconResourceName);\n+\n+        final var nonNullName = deriveNonNullName();\n+\n+        return new Stub(nonNullName, Optional.ofNullable(startupInfo), fa,\n+                isService, Optional.ofNullable(description).orElse(nonNullName),\n+                Optional.ofNullable(icon), defaultIconResourceName,\n+                Optional.ofNullable(extraAppImageFileData).orElseGet(Map::of));\n+    }\n+\n+    LauncherBuilder name(String v) {\n+        name = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder startupInfo(LauncherStartupInfo v) {\n+        startupInfo = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder faGroups(List<FileAssociationGroup> v) {\n+        v.forEach(Objects::requireNonNull);\n+        faSources = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder faTraits(FileAssociationTraits v) {\n+        faTraits = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder isService(boolean v) {\n+        isService = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder description(String v) {\n+        description = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder icon(LauncherIcon v) {\n+        icon = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder defaultIconResourceName(String v) {\n+        defaultIconResourceName = v;\n+        return this;\n+    }\n+\n+    LauncherBuilder extraAppImageFileData(Map<String, String> v) {\n+        extraAppImageFileData = v;\n+        return this;\n+    }\n+\n+    private String deriveNonNullName() {\n+        return Optional.ofNullable(name).orElseGet(() -> startupInfo.simpleClassName());\n+    }\n+\n+    static void validateIcon(Path icon) throws ConfigException {\n+        switch (OperatingSystem.current()) {\n+            case WINDOWS -> {\n+                if (!icon.getFileName().toString().toLowerCase().endsWith(\".ico\")) {\n+                    throw buildConfigException().message(\"message.icon-not-ico\", icon).create();\n+                }\n+            }\n+            case LINUX -> {\n+                if (!icon.getFileName().toString().endsWith(\".png\")) {\n+                    throw buildConfigException().message(\"message.icon-not-png\", icon).create();\n+                }\n+            }\n+            case MACOS -> {\n+                if (!icon.getFileName().toString().endsWith(\".icns\")) {\n+                    throw buildConfigException().message(\"message.icon-not-icns\", icon).create();\n+                }\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+    record FileAssociationTraits() {\n+    }\n+\n+    private static List<FileAssociation> createFileAssociations(\n+            List<FileAssociationGroup> groups, FileAssociationTraits faTraits) throws ConfigException {\n+\n+        Objects.requireNonNull(groups);\n+        Objects.requireNonNull(faTraits);\n+\n+        int faID = 1;\n+        for (var group : groups) {\n+            final var scanResult = new FileAssociationScaner().scan(group.items());\n+\n+            if (!scanResult.extensionsWithMultipleMimeTypes().isEmpty()) {\n+                throw buildConfigException()\n+                        .message(\"error.too-many-content-types-for-file-association\", faID)\n+                        .advice(\"error.too-many-content-types-for-file-association.advice\", faID)\n+                        .create();\n+            }\n+\n+            faID++;\n+        }\n+\n+        return FileAssociationGroup.flatMap(groups.stream()).toList();\n+    }\n+\n+    private String name;\n+    private LauncherStartupInfo startupInfo;\n+    private List<FileAssociationGroup> faSources = List.of();\n+    private FileAssociationTraits faTraits;\n+    private boolean isService;\n+    private String description;\n+    private LauncherIcon icon;\n+    private String defaultIconResourceName;\n+    private Map<String, String> extraAppImageFileData;\n+\n+    private static final FileAssociationTraits DEFAULT_FA_TRAITS = new FileAssociationTraits();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherBuilder.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -144,1 +144,1 @@\n-        ModuleReference moduleRef = JLinkBundlerHelper.createModuleFinder(\n+        ModuleReference moduleRef = JLinkRuntimeBuilder.createModuleFinder(\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,156 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+import static jdk.jpackage.internal.StandardBundlerParam.ARGUMENTS;\n+import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n+import static jdk.jpackage.internal.StandardBundlerParam.FA_CONTENT_TYPE;\n+import static jdk.jpackage.internal.StandardBundlerParam.FA_DESCRIPTION;\n+import static jdk.jpackage.internal.StandardBundlerParam.FA_EXTENSIONS;\n+import static jdk.jpackage.internal.StandardBundlerParam.FA_ICON;\n+import static jdk.jpackage.internal.StandardBundlerParam.FILE_ASSOCIATIONS;\n+import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n+import static jdk.jpackage.internal.StandardBundlerParam.JAVA_OPTIONS;\n+import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_AS_SERVICE;\n+import static jdk.jpackage.internal.StandardBundlerParam.LAUNCHER_DATA;\n+import static jdk.jpackage.internal.StandardBundlerParam.NAME;\n+import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.BiFunction;\n+import java.util.stream.IntStream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.CustomLauncherIcon;\n+import jdk.jpackage.internal.model.DefaultLauncherIcon;\n+import jdk.jpackage.internal.model.FileAssociation;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherIcon;\n+\n+record LauncherFromParams(Optional<BiFunction<FileAssociation, Map<String, ? super Object>, FileAssociation>> faExtension) {\n+\n+    LauncherFromParams {\n+        Objects.requireNonNull(faExtension);\n+    }\n+\n+    LauncherFromParams() {\n+        this(Optional.empty());\n+    }\n+\n+    Launcher create(Map<String, ? super Object> params) throws ConfigException {\n+        final var builder = new LauncherBuilder().defaultIconResourceName(defaultIconResourceName());\n+\n+        DESCRIPTION.copyInto(params, builder::description);\n+        builder.icon(toLauncherIcon(ICON.findIn(params).orElse(null)));\n+        LAUNCHER_AS_SERVICE.copyInto(params, builder::isService);\n+        NAME.copyInto(params, builder::name);\n+\n+        if (PREDEFINED_APP_IMAGE.findIn(params).isEmpty()) {\n+            final var startupInfoBuilder = new LauncherStartupInfoBuilder();\n+\n+            startupInfoBuilder.launcherData(LAUNCHER_DATA.fetchFrom(params));\n+            ARGUMENTS.copyInto(params, startupInfoBuilder::defaultParameters);\n+            JAVA_OPTIONS.copyInto(params, startupInfoBuilder::javaOptions);\n+\n+            builder.startupInfo(startupInfoBuilder.create());\n+        }\n+\n+        final var faParamsList = FILE_ASSOCIATIONS.findIn(params).orElseGet(List::of);\n+\n+        final var faGroups = IntStream.range(0, faParamsList.size()).mapToObj(idx -> {\n+            final var faParams = faParamsList.get(idx);\n+            return toSupplier(() -> {\n+                final var faGroupBuilder = FileAssociationGroup.build();\n+\n+                if (OperatingSystem.current() == OperatingSystem.MACOS) {\n+                    FA_DESCRIPTION.copyInto(faParams, faGroupBuilder::description);\n+                } else {\n+                    faGroupBuilder.description(FA_DESCRIPTION.findIn(faParams).orElseGet(() -> {\n+                        return String.format(\"%s association\", toSupplier(builder::create).get().name());\n+                    }));\n+                }\n+\n+                FA_ICON.copyInto(faParams, faGroupBuilder::icon);\n+                FA_EXTENSIONS.copyInto(faParams, faGroupBuilder::extensions);\n+                FA_CONTENT_TYPE.copyInto(faParams, faGroupBuilder::mimeTypes);\n+\n+                final var faID = idx + 1;\n+\n+                final FileAssociationGroup faGroup;\n+                try {\n+                    faGroup = faGroupBuilder.create();\n+                } catch (FileAssociationGroup.FileAssociationNoMimesException ex) {\n+                    throw buildConfigException()\n+                            .message(\"error.no-content-types-for-file-association\", faID)\n+                            .advice(\"error.no-content-types-for-file-association.advice\", faID)\n+                            .create();\n+                }\n+\n+                if (faExtension.isPresent()) {\n+                    return new FileAssociationGroup(faGroup.items().stream().map(fa -> {\n+                        return faExtension.get().apply(fa, faParams);\n+                    }).toList());\n+                } else {\n+                    return faGroup;\n+                }\n+            }).get();\n+        }).toList();\n+\n+        return builder.faGroups(faGroups).create();\n+    }\n+\n+    private static LauncherIcon toLauncherIcon(Path launcherIconPath) {\n+        if (launcherIconPath == null) {\n+            return DefaultLauncherIcon.INSTANCE;\n+        } else if (launcherIconPath.toString().isEmpty()) {\n+            return null;\n+        } else {\n+            return CustomLauncherIcon.create(launcherIconPath);\n+        }\n+    }\n+\n+    private static String defaultIconResourceName() {\n+        switch (OperatingSystem.current()) {\n+            case WINDOWS -> {\n+                return \"JavaApp.ico\";\n+            }\n+            case LINUX -> {\n+                return \"JavaApp.png\";\n+            }\n+            case MACOS -> {\n+                return \"JavaApp.icns\";\n+            }\n+            default -> {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherFromParams.java","additions":156,"deletions":0,"binary":false,"changes":156,"status":"added"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.internal.model.LauncherJarStartupInfo;\n+import jdk.jpackage.internal.model.LauncherJarStartupInfoMixin;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfo;\n+import jdk.jpackage.internal.model.LauncherModularStartupInfoMixin;\n+import jdk.jpackage.internal.model.LauncherStartupInfo.Stub;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+\n+final class LauncherStartupInfoBuilder {\n+\n+    LauncherStartupInfo create() {\n+        return decorator.apply(new Stub(qualifiedClassName, javaOptions,\n+                defaultParameters, classPath));\n+    }\n+\n+    LauncherStartupInfoBuilder launcherData(LauncherData launcherData) {\n+        if (launcherData.isModular()) {\n+            decorator = new ModuleStartupInfo(launcherData.moduleName(),\n+                    launcherData.modulePath());\n+        } else {\n+            decorator = new JarStartupInfo(launcherData.mainJarName(),\n+                    launcherData.isClassNameFromMainJar());\n+        }\n+        classPath = launcherData.classPath();\n+        qualifiedClassName = launcherData.qualifiedClassName();\n+        return this;\n+    }\n+\n+    LauncherStartupInfoBuilder javaOptions(List<String> v) {\n+        javaOptions = v;\n+        return this;\n+    }\n+\n+    LauncherStartupInfoBuilder defaultParameters(List<String> v) {\n+        defaultParameters = v;\n+        return this;\n+    }\n+\n+    private static record ModuleStartupInfo(String moduleName,\n+            List<Path> modulePath) implements UnaryOperator<LauncherStartupInfo> {\n+\n+        @Override\n+        public LauncherStartupInfo apply(LauncherStartupInfo base) {\n+            return LauncherModularStartupInfo.create(base,\n+                    new LauncherModularStartupInfoMixin.Stub(moduleName,\n+                            modulePath));\n+        }\n+    }\n+\n+    private static record JarStartupInfo(Path jarPath,\n+            boolean isClassNameFromMainJar) implements\n+            UnaryOperator<LauncherStartupInfo> {\n+\n+        @Override\n+        public LauncherStartupInfo apply(LauncherStartupInfo base) {\n+            return LauncherJarStartupInfo.create(base,\n+                    new LauncherJarStartupInfoMixin.Stub(jarPath,\n+                            isClassNameFromMainJar));\n+        }\n+    }\n+\n+    private String qualifiedClassName;\n+    private List<String> javaOptions;\n+    private List<String> defaultParameters;\n+    private List<Path> classPath;\n+    private UnaryOperator<LauncherStartupInfo> decorator;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherStartupInfoBuilder.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,0 @@\n-import java.text.MessageFormat;\n@@ -44,0 +43,1 @@\n+import java.util.Objects;\n@@ -45,0 +45,1 @@\n+import java.util.function.Supplier;\n@@ -47,2 +48,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import jdk.jpackage.internal.resources.ResourceLocator;\n@@ -74,2 +73,10 @@\n-    OverridableResource(String defaultName) {\n-        this.defaultName = defaultName;\n+    OverridableResource() {\n+        defaultName = \"\";\n+        defaultResourceSupplier = null;\n+        setSourceOrder(Source.External, Source.ResourceDir);\n+    }\n+\n+    OverridableResource(String defaultName,\n+            Supplier<InputStream> defaultResourceSupplier) {\n+        this.defaultName = Objects.requireNonNull(defaultName);\n+        this.defaultResourceSupplier = Objects.requireNonNull(defaultResourceSupplier);\n@@ -79,0 +86,6 @@\n+    OverridableResource(String defaultName, Class<?> resourceLocator) {\n+        this(defaultName, () -> {\n+            return resourceLocator.getResourceAsStream(defaultName);\n+        });\n+    }\n+\n@@ -205,1 +218,1 @@\n-                Files.createDirectories(IOUtils.getParent(dest));\n+                Files.createDirectories(dest.getParent());\n@@ -215,10 +228,0 @@\n-    static InputStream readDefault(String resourceName) {\n-        return ResourceLocator.class.getResourceAsStream(resourceName);\n-    }\n-\n-    static OverridableResource createResource(String defaultName,\n-            Map<String, ? super Object> params) {\n-        return new OverridableResource(defaultName).setResourceDir(\n-                RESOURCE_DIR.fetchFrom(params));\n-    }\n-\n@@ -244,2 +247,1 @@\n-            Log.verbose(MessageFormat.format(I18N.getString(\n-                    \"message.using-custom-resource-from-file\"),\n+            Log.verbose(I18N.format(\"message.using-custom-resource-from-file\",\n@@ -273,3 +275,2 @@\n-                Log.verbose(MessageFormat.format(I18N.getString(\n-                        \"message.using-custom-resource\"), getPrintableCategory(),\n-                        logResourceName));\n+                Log.verbose(I18N.format(\"message.using-custom-resource\",\n+                        getPrintableCategory(), logResourceName));\n@@ -294,2 +295,1 @@\n-            Log.verbose(MessageFormat.format(\n-                    I18N.getString(\"message.using-default-resource\"),\n+            Log.verbose(I18N.format(\"message.using-default-resource\",\n@@ -298,1 +298,1 @@\n-            try (InputStream in = readDefault(defaultName)) {\n+            try (InputStream in = defaultResourceSupplier.get()) {\n@@ -389,0 +389,1 @@\n+    private final Supplier<InputStream> defaultResourceSupplier;\n@@ -393,1 +394,1 @@\n-        public boolean apply(ResourceConsumer dest) throws IOException;\n+        boolean apply(ResourceConsumer dest) throws IOException;\n@@ -397,2 +398,2 @@\n-        public Path publicName();\n-        public void consume(InputStream in) throws IOException;\n+        Path publicName();\n+        void consume(InputStream in) throws IOException;\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/OverridableResource.java","additions":29,"deletions":28,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.Package.Stub;\n+import jdk.jpackage.internal.model.PackageType;\n+import jdk.jpackage.internal.model.StandardPackageType;\n+\n+final class PackageBuilder {\n+\n+    PackageBuilder(Application app, PackageType type) {\n+        this.app = Objects.requireNonNull(app);\n+        this.type = Objects.requireNonNull(type);\n+    }\n+\n+    Package create() throws ConfigException {\n+        final var validatedName = validatedName();\n+\n+        Path relativeInstallDir;\n+        if (installDir != null) {\n+            var normalizedInstallDir = mapInstallDir(installDir, type);\n+            if (type instanceof StandardPackageType stdType) {\n+                Optional<Path> installDirName = Optional.of(Path.of(validatedName));\n+                switch (stdType) {\n+                    case LINUX_DEB, LINUX_RPM -> {\n+                        switch (normalizedInstallDir.toString()) {\n+                            case \"\/usr\", \"\/usr\/local\" -> {\n+                                installDirName = Optional.empty();\n+                            }\n+                        }\n+                    }\n+                    case WIN_EXE, WIN_MSI -> {\n+                        installDirName = Optional.empty();\n+                    }\n+                    case MAC_DMG,MAC_PKG -> {\n+                        installDirName = Optional.of(app.appImageDirName());\n+                    }\n+                }\n+                normalizedInstallDir = installDirName.map(normalizedInstallDir::resolve).orElse(normalizedInstallDir);\n+            }\n+            relativeInstallDir = normalizedInstallDir;\n+        } else {\n+            relativeInstallDir = defaultInstallDir().orElseThrow(UnsupportedOperationException::new);\n+        }\n+\n+        if (relativeInstallDir.isAbsolute()) {\n+            relativeInstallDir = relativeInstallDir.getRoot().relativize(relativeInstallDir);\n+        }\n+\n+        return new Stub(\n+                app,\n+                type,\n+                validatedName,\n+                Optional.ofNullable(description).orElseGet(app::description),\n+                version = Optional.ofNullable(version).orElseGet(app::version),\n+                Optional.ofNullable(aboutURL),\n+                Optional.ofNullable(licenseFile),\n+                Optional.ofNullable(predefinedAppImage),\n+                relativeInstallDir);\n+    }\n+\n+    PackageBuilder name(String v) {\n+        name = v;\n+        return this;\n+    }\n+\n+    Optional<String> name() {\n+        return Optional.ofNullable(name);\n+    }\n+\n+    PackageBuilder fileName(Path v) {\n+        fileName = v;\n+        return this;\n+    }\n+\n+    Optional<Path> fileName() {\n+        return Optional.ofNullable(fileName);\n+    }\n+\n+    PackageBuilder description(String v) {\n+        description = v;\n+        return this;\n+    }\n+\n+    Optional<String> description() {\n+        return Optional.ofNullable(description);\n+    }\n+\n+    PackageBuilder version(String v) {\n+        version = v;\n+        return this;\n+    }\n+\n+    Optional<String> version() {\n+        return Optional.ofNullable(version);\n+    }\n+\n+    PackageBuilder aboutURL(String v) {\n+        aboutURL = v;\n+        return this;\n+    }\n+\n+    Optional<String> aboutURL() {\n+        return Optional.ofNullable(aboutURL);\n+    }\n+\n+    PackageBuilder licenseFile(Path v) {\n+        licenseFile = v;\n+        return this;\n+    }\n+\n+    Optional<Path> licenseFile() {\n+        return Optional.ofNullable(licenseFile);\n+    }\n+\n+    PackageBuilder predefinedAppImage(Path v) {\n+        predefinedAppImage = v;\n+        return this;\n+    }\n+\n+    Optional<Path> predefinedAppImage() {\n+        return Optional.ofNullable(predefinedAppImage);\n+    }\n+\n+    PackageBuilder installDir(Path v) {\n+        installDir = v;\n+        return this;\n+    }\n+\n+    Optional<Path> installDir() {\n+        return Optional.ofNullable(installDir);\n+    }\n+\n+    Optional<Path> defaultInstallDir() {\n+        if (type instanceof StandardPackageType stdType) {\n+            return defaultInstallDir(stdType, validatedName(), app);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private String validatedName() {\n+        return name().orElseGet(app::name);\n+    }\n+\n+    private static Path mapInstallDir(Path installDir, PackageType pkgType)\n+            throws ConfigException {\n+        var ex = buildConfigException(\"error.invalid-install-dir\", installDir).create();\n+\n+        if (installDir.getNameCount() == 0) {\n+            throw ex;\n+        }\n+\n+        if (installDir.getFileName().equals(Path.of(\"\"))) {\n+            \/\/ Trailing '\/' or '\\\\'. Strip them away.\n+            installDir = installDir.getParent();\n+        }\n+\n+        if (installDir.toString().isEmpty()) {\n+            throw ex;\n+        }\n+\n+        switch (pkgType) {\n+            case StandardPackageType.WIN_EXE, StandardPackageType.WIN_MSI -> {\n+                if (installDir.isAbsolute()) {\n+                    throw ex;\n+                }\n+            }\n+            default -> {\n+                if (!installDir.isAbsolute()) {\n+                    throw ex;\n+                }\n+            }\n+        }\n+\n+        if (!installDir.normalize().toString().equals(installDir.toString())) {\n+            \/\/ Don't allow '..' or '.' in path components\n+            throw ex;\n+        }\n+\n+        return installDir;\n+    }\n+\n+    private static Optional<Path> defaultInstallDir(StandardPackageType pkgType, String pkgName, Application app) {\n+        switch (pkgType) {\n+            case WIN_EXE, WIN_MSI -> {\n+                return Optional.of(app.appImageDirName());\n+            }\n+            case LINUX_DEB, LINUX_RPM -> {\n+                return Optional.of(Path.of(\"\/opt\").resolve(pkgName));\n+            }\n+            case MAC_DMG, MAC_PKG -> {\n+                final Path dirName = app.appImageDirName();\n+                final Path base;\n+                if (app.isRuntime()) {\n+                    base = Path.of(\"\/Library\/Java\/JavaVirtualMachines\");\n+                } else {\n+                    base = Path.of(\"\/Applications\");\n+                }\n+                return Optional.of(base.resolve(dirName));\n+            }\n+            default -> {\n+                return Optional.empty();\n+            }\n+        }\n+    }\n+\n+    private String name;\n+    private Path fileName;\n+    private String description;\n+    private String version;\n+    private String aboutURL;\n+    private Path licenseFile;\n+    private Path predefinedAppImage;\n+    private Path installDir;\n+\n+    private final PackageType type;\n+    private final Application app;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageBuilder.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -32,1 +33,0 @@\n-import java.util.Optional;\n@@ -38,1 +38,1 @@\n-     * @param appImageDir - path to application image\n+     * @param appLayout - application layout\n@@ -40,5 +40,2 @@\n-    public static Path getPathInAppImage(Path appImageDir) {\n-        return ApplicationLayout.platformAppImage()\n-                .resolveAt(appImageDir)\n-                .appDirectory()\n-                .resolve(FILENAME);\n+    static Path getPathInAppImage(ApplicationLayout appLayout) {\n+        return appLayout.appDirectory().resolve(FILENAME);\n@@ -48,2 +45,1 @@\n-        Objects.requireNonNull(packageName);\n-        this.packageName = packageName;\n+        this.packageName = Objects.requireNonNull(packageName);\n@@ -53,8 +49,3 @@\n-        Path dst = Optional.ofNullable(appLayout.appDirectory()).map(appDir -> {\n-            return appDir.resolve(FILENAME);\n-        }).orElse(null);\n-\n-        if (dst != null) {\n-            Files.createDirectories(dst.getParent());\n-            Files.writeString(dst, packageName);\n-        }\n+        final var dstDir = appLayout.appDirectory();\n+        Files.createDirectories(dstDir);\n+        Files.writeString(dstDir.resolve(FILENAME), packageName);\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackageFile.java","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import jdk.jpackage.internal.PackagingPipeline.StartupParameters;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackagerException;\n+\n+abstract class PackagerBuilder<T extends Package, U extends PackagerBuilder<T, U>> {\n+\n+    U pkg(T v) {\n+        pkg = v;\n+        return thiz();\n+    }\n+\n+    U env(BuildEnv v) {\n+        env = v;\n+        return thiz();\n+    }\n+\n+    U outputDir(Path v) {\n+        outputDir = v;\n+        return thiz();\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private U thiz() {\n+        return (U)this;\n+    }\n+\n+    protected abstract void configurePackagingPipeline(PackagingPipeline.Builder pipelineBuilder,\n+            StartupParameters startupParameters);\n+\n+    Path execute(PackagingPipeline.Builder pipelineBuilder) throws PackagerException {\n+        Objects.requireNonNull(pkg);\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(outputDir);\n+\n+        final var startupParameters = pipelineBuilder.createStartupParameters(env, pkg, outputDir);\n+\n+        configurePackagingPipeline(pipelineBuilder, startupParameters);\n+\n+        pipelineBuilder.create().execute(startupParameters);\n+\n+        return outputDir.resolve(pkg.packageFileNameWithSuffix());\n+    }\n+\n+    protected T pkg;\n+    protected BuildEnv env;\n+    protected Path outputDir;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagerBuilder.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,618 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.io.IOException;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.Callable;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.function.UnaryOperator;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.pipeline.DirectedEdge;\n+import jdk.jpackage.internal.pipeline.FixedDAG;\n+import jdk.jpackage.internal.pipeline.TaskPipelineBuilder;\n+import jdk.jpackage.internal.pipeline.TaskSpecBuilder;\n+import jdk.jpackage.internal.util.function.ExceptionBox;\n+\n+\n+final class PackagingPipeline {\n+\n+    void execute(BuildEnv env, Application app) throws PackagerException {\n+        execute(appContextMapper.apply(createTaskContext(env, app)));\n+    }\n+\n+    void execute(BuildEnv env, Package pkg, Path outputDir) throws PackagerException {\n+        execute((StartupParameters)createPackagingTaskContext(env, pkg, outputDir,\n+                taskConfig, appImageLayoutForPackaging.apply(pkg)));\n+    }\n+\n+    void execute(StartupParameters startupParameters) throws PackagerException {\n+        execute(pkgContextMapper.apply(createTaskContext((PackagingTaskContext)startupParameters)));\n+    }\n+\n+    interface StartupParameters {\n+        BuildEnv packagingEnv();\n+    }\n+\n+    interface TaskAction {\n+    }\n+\n+    interface TaskID {\n+    }\n+\n+    enum BuildApplicationTaskID implements TaskID {\n+        RUNTIME,\n+        CONTENT,\n+        LAUNCHERS,\n+        APP_IMAGE_FILE\n+    }\n+\n+    enum CopyAppImageTaskID implements TaskID {\n+        COPY\n+    }\n+\n+    enum PrimaryTaskID implements TaskID {\n+        BUILD_APPLICATION_IMAGE,\n+        COPY_APP_IMAGE,\n+        PACKAGE\n+    }\n+\n+    enum PackageTaskID implements TaskID {\n+        RUN_POST_IMAGE_USER_SCRIPT,\n+        CREATE_CONFIG_FILES,\n+        CREATE_PACKAGE_FILE\n+    }\n+\n+    interface TaskContext extends Predicate<TaskID> {\n+        void execute(TaskAction taskAction) throws IOException, PackagerException;\n+    }\n+\n+    record AppImageBuildEnv<T extends Application, U extends AppImageLayout>(BuildEnv env, T app, U envLayout) {\n+        @SuppressWarnings(\"unchecked\")\n+        U resolvedLayout() {\n+            return (U)envLayout.resolveAt(env.appImageDir());\n+        }\n+    }\n+\n+    record PackageBuildEnv<T extends Package, U extends AppImageLayout>(BuildEnv env, T pkg, U envLayout, Path outputDir) {\n+        @SuppressWarnings(\"unchecked\")\n+        U resolvedLayout() {\n+            return (U)envLayout.resolveAt(env.appImageDir());\n+        }\n+\n+        AppImageBuildEnv<Application, U> appImageBuildEnv() {\n+            return new AppImageBuildEnv<>(env, pkg.app(), envLayout);\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    interface ApplicationImageTaskAction<T extends Application, U extends ApplicationLayout> extends TaskAction {\n+        void execute(AppImageBuildEnv<T, U> env) throws IOException, PackagerException;\n+    }\n+\n+    @FunctionalInterface\n+    interface AppImageTaskAction<T extends Application, U extends AppImageLayout> extends TaskAction {\n+        void execute(AppImageBuildEnv<T, U> env) throws IOException, PackagerException;\n+    }\n+\n+    @FunctionalInterface\n+    interface CopyAppImageTaskAction<T extends Package> extends TaskAction {\n+        void execute(T pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException, PackagerException;\n+    }\n+\n+    @FunctionalInterface\n+    interface PackageTaskAction<T extends Package, U extends AppImageLayout> extends TaskAction {\n+        void execute(PackageBuildEnv<T, U> env) throws IOException, PackagerException;\n+    }\n+\n+    @FunctionalInterface\n+    interface NoArgTaskAction extends TaskAction {\n+        void execute() throws IOException, PackagerException;\n+    }\n+\n+    record TaskConfig(Optional<TaskAction> action) {\n+        TaskConfig {\n+            Objects.requireNonNull(action);\n+        }\n+    }\n+\n+    static final class Builder {\n+\n+        private Builder() {\n+        }\n+\n+        final class TaskBuilder extends TaskSpecBuilder<TaskID> {\n+\n+            private TaskBuilder(TaskID id) {\n+                super(id);\n+            }\n+\n+            private TaskBuilder setAction(TaskAction v) {\n+                action = v;\n+                return this;\n+            }\n+\n+            TaskBuilder noaction() {\n+                action = null;\n+                return this;\n+            }\n+\n+            <T extends Application, U extends ApplicationLayout> TaskBuilder applicationAction(ApplicationImageTaskAction<T, U> action) {\n+                return setAction(action);\n+            }\n+\n+            <T extends Application, U extends AppImageLayout> TaskBuilder appImageAction(AppImageTaskAction<T, U> action) {\n+                return setAction(action);\n+            }\n+\n+            <T extends Package> TaskBuilder copyAction(CopyAppImageTaskAction<T> action) {\n+                return setAction(action);\n+            }\n+\n+            <T extends Package, U extends AppImageLayout> TaskBuilder packageAction(PackageTaskAction<T, U> action) {\n+                return setAction(action);\n+            }\n+\n+            TaskBuilder action(NoArgTaskAction action) {\n+                return setAction(action);\n+            }\n+\n+            @Override\n+            public TaskBuilder addDependent(TaskID v) {\n+                super.addDependent(v);\n+                return this;\n+            }\n+\n+            @Override\n+            public TaskBuilder addDependency(TaskID v) {\n+                super.addDependency(v);\n+                return this;\n+            }\n+\n+            @Override\n+            public TaskBuilder addDependencies(Collection<? extends TaskID> tasks) {\n+                super.addDependencies(tasks);\n+                return this;\n+            }\n+\n+            @Override\n+            public TaskBuilder addDependents(Collection<? extends TaskID> tasks) {\n+                super.addDependents(tasks);\n+                return this;\n+            }\n+\n+            public TaskBuilder addDependencies(TaskID ... tasks) {\n+                return addDependencies(List.of(tasks));\n+            }\n+\n+            public TaskBuilder addDependents(TaskID ... tasks) {\n+                return addDependents(List.of(tasks));\n+            }\n+\n+            Builder add() {\n+                final var config = new TaskConfig(Optional.ofNullable(action));\n+                taskConfig.put(task(), config);\n+                createLinks().forEach(Builder.this::linkTasks);\n+                return Builder.this;\n+            }\n+\n+            private TaskAction action;\n+        }\n+\n+        Builder linkTasks(DirectedEdge<TaskID> edge) {\n+            taskGraphBuilder.addEdge(edge);\n+            if (taskGraphSnapshot != null) {\n+                taskGraphSnapshot = null;\n+            }\n+            return this;\n+        }\n+\n+        Builder linkTasks(TaskID tail, TaskID head) {\n+            return linkTasks(DirectedEdge.create(tail, head));\n+        }\n+\n+        TaskBuilder task(TaskID id) {\n+            return new TaskBuilder(id);\n+        }\n+\n+        Builder excludeDirFromCopying(Path path) {\n+            Objects.requireNonNull(path);\n+            excludeCopyDirs.add(path);\n+            return this;\n+        }\n+\n+        Builder contextMapper(UnaryOperator<TaskContext> v) {\n+            appContextMapper(v);\n+            pkgContextMapper(v);\n+            return this;\n+        }\n+\n+        Builder appContextMapper(UnaryOperator<TaskContext> v) {\n+            appContextMapper = v;\n+            return this;\n+        }\n+\n+        Builder pkgContextMapper(UnaryOperator<TaskContext> v) {\n+            pkgContextMapper = v;\n+            return this;\n+        }\n+\n+        Builder appImageLayoutForPackaging(Function<Package, AppImageLayout> v) {\n+            appImageLayoutForPackaging = v;\n+            return this;\n+        }\n+\n+        FixedDAG<TaskID> taskGraphSnapshot() {\n+            if (taskGraphSnapshot == null) {\n+                taskGraphSnapshot = taskGraphBuilder.create();\n+            }\n+            return taskGraphSnapshot;\n+        }\n+\n+        StartupParameters createStartupParameters(BuildEnv env, Package pkg, Path outputDir) {\n+            return createPackagingTaskContext(env, pkg, outputDir, taskConfig,\n+                    validatedAppImageLayoutForPackaging().apply(pkg));\n+        }\n+\n+        private Function<Package, AppImageLayout> validatedAppImageLayoutForPackaging() {\n+            return Optional.ofNullable(appImageLayoutForPackaging).orElse(Package::packageLayout);\n+        }\n+\n+        PackagingPipeline create() {\n+            return new PackagingPipeline(taskGraphSnapshot(), taskConfig,\n+                    Optional.ofNullable(appContextMapper).orElse(UnaryOperator.identity()),\n+                    Optional.ofNullable(pkgContextMapper).orElse(UnaryOperator.identity()),\n+                    validatedAppImageLayoutForPackaging());\n+        }\n+\n+        private final FixedDAG.Builder<TaskID> taskGraphBuilder = FixedDAG.build();\n+        private final List<Path> excludeCopyDirs = new ArrayList<>();\n+        private final Map<TaskID, TaskConfig> taskConfig = new HashMap<>();\n+        private UnaryOperator<TaskContext> appContextMapper;\n+        private UnaryOperator<TaskContext> pkgContextMapper;\n+        private Function<Package, AppImageLayout> appImageLayoutForPackaging;\n+        private FixedDAG<TaskID> taskGraphSnapshot;\n+    }\n+\n+    static Builder build() {\n+        return new Builder();\n+    }\n+\n+    static Builder buildStandard() {\n+        final var builder = build();\n+\n+        configureApplicationTasks(builder);\n+        configurePackageTasks(builder);\n+\n+        return builder;\n+    }\n+\n+    static Builder configureApplicationTasks(Builder builder) {\n+        builder.task(BuildApplicationTaskID.RUNTIME)\n+                .addDependent(BuildApplicationTaskID.CONTENT)\n+                .applicationAction(ApplicationImageUtils.createWriteRuntimeAction()).add();\n+\n+        builder.task(BuildApplicationTaskID.LAUNCHERS)\n+                .addDependent(BuildApplicationTaskID.CONTENT)\n+                .applicationAction(ApplicationImageUtils.createWriteLaunchersAction()).add();\n+\n+        builder.task(BuildApplicationTaskID.APP_IMAGE_FILE)\n+                .addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE)\n+                .applicationAction(ApplicationImageUtils.createWriteAppImageFileAction()).add();\n+\n+        builder.task(BuildApplicationTaskID.CONTENT)\n+                .addDependent(BuildApplicationTaskID.APP_IMAGE_FILE)\n+                .applicationAction(ApplicationImageUtils.createCopyContentAction(() -> builder.excludeCopyDirs)).add();\n+\n+        return builder;\n+    }\n+\n+    static Builder configurePackageTasks(Builder builder) {\n+        builder.task(CopyAppImageTaskID.COPY)\n+                .copyAction(PackagingPipeline::copyAppImage)\n+                .addDependent(PrimaryTaskID.COPY_APP_IMAGE)\n+                .add();\n+\n+        builder.task(PrimaryTaskID.COPY_APP_IMAGE).add();\n+\n+        builder.task(PrimaryTaskID.BUILD_APPLICATION_IMAGE).add();\n+\n+        builder.task(PackageTaskID.RUN_POST_IMAGE_USER_SCRIPT)\n+                .addDependencies(PrimaryTaskID.BUILD_APPLICATION_IMAGE, PrimaryTaskID.COPY_APP_IMAGE)\n+                .addDependency(PackageTaskID.CREATE_CONFIG_FILES)\n+                .addDependent(PackageTaskID.CREATE_PACKAGE_FILE)\n+                .packageAction(PackagingPipeline::runPostAppImageUserScript).add();\n+\n+        builder.task(PackageTaskID.CREATE_CONFIG_FILES)\n+                .addDependent(PackageTaskID.CREATE_PACKAGE_FILE)\n+                .add();\n+\n+        builder.task(PackageTaskID.CREATE_PACKAGE_FILE)\n+                .addDependent(PrimaryTaskID.PACKAGE)\n+                .add();\n+\n+        builder.task(PrimaryTaskID.PACKAGE).add();\n+\n+        return builder;\n+    }\n+\n+    static void copyAppImage(Package pkg, AppImageDesc srcAppImage, AppImageDesc dstAppImage) throws IOException {\n+        copyAppImage(srcAppImage, dstAppImage, true);\n+    }\n+\n+    static void copyAppImage(AppImageDesc srcAppImage, AppImageDesc dstAppImage,\n+            boolean removeAppImageFile) throws IOException {\n+        final var srcLayout = srcAppImage.resolvedAppImagelayout();\n+        final var srcLayoutPathGroup = AppImageLayout.toPathGroup(srcLayout);\n+\n+        if (removeAppImageFile && srcLayout instanceof ApplicationLayout appLayout) {\n+            \/\/ Copy app layout omitting application image info file.\n+            srcLayoutPathGroup.ghostPath(AppImageFile.getPathInAppImage(appLayout));\n+        }\n+\n+        srcLayoutPathGroup.copy(AppImageLayout.toPathGroup(dstAppImage.resolvedAppImagelayout()), LinkOption.NOFOLLOW_LINKS);\n+    }\n+\n+    static void runPostAppImageUserScript(PackageBuildEnv<Package, AppImageLayout> env) throws IOException {\n+        final var appImageDir = env.env().appImageDir();\n+        new ScriptRunner()\n+                .setDirectory(appImageDir)\n+                .setResourceCategoryId(\"resource.post-app-image-script\")\n+                .setScriptNameSuffix(\"post-image\")\n+                .setEnvironmentVariable(\"JpAppImageDir\", appImageDir.toAbsolutePath().toString())\n+                .run(env.env(), env.pkg().app().name());\n+    }\n+\n+    private PackagingPipeline(FixedDAG<TaskID> taskGraph, Map<TaskID, TaskConfig> taskConfig,\n+            UnaryOperator<TaskContext> appContextMapper, UnaryOperator<TaskContext> pkgContextMapper,\n+            Function<Package, AppImageLayout> appImageLayoutForPackaging) {\n+        this.taskGraph = Objects.requireNonNull(taskGraph);\n+        this.taskConfig = Objects.requireNonNull(taskConfig);\n+        this.appContextMapper = Objects.requireNonNull(appContextMapper);\n+        this.pkgContextMapper = Objects.requireNonNull(pkgContextMapper);\n+        this.appImageLayoutForPackaging = Objects.requireNonNull(appImageLayoutForPackaging);\n+    }\n+\n+    private TaskContext createTaskContext(BuildEnv env, Application app) {\n+        return new DefaultTaskContext(taskGraph, env, app, app.asApplicationLayout(), Optional.empty());\n+    }\n+\n+    private TaskContext createTaskContext(PackagingTaskContext packagingContext) {\n+        final var pkgEnv = BuildEnv.withAppImageDir(packagingContext.env.env(), packagingContext.srcAppImage.path());\n+        return new DefaultTaskContext(taskGraph, pkgEnv, packagingContext.env.pkg.app(),\n+                packagingContext.srcAppImage.asApplicationLayout(), Optional.of(packagingContext));\n+    }\n+\n+    private static PackagingTaskContext createPackagingTaskContext(BuildEnv env, Package pkg,\n+            Path outputDir, Map<TaskID, TaskConfig> taskConfig, AppImageLayout appImageLayoutForPackaging) {\n+\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(outputDir);\n+        Objects.requireNonNull(taskConfig);\n+        Objects.requireNonNull(appImageLayoutForPackaging);\n+\n+        final AppImageDesc srcAppImageDesc;\n+        final AppImageDesc dstAppImageDesc;\n+        if (pkg.app().runtimeBuilder().isPresent()) {\n+            \/\/ Runtime builder is present, will build application image.\n+            \/\/ appImageDir() should point to a directory where the application image will be created.\n+            srcAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.appImageDir());\n+            dstAppImageDesc = srcAppImageDesc;\n+        } else {\n+            srcAppImageDesc = new AppImageDesc(pkg.app().imageLayout(), pkg.predefinedAppImage().orElseGet(() -> {\n+                \/\/ No predefined app image and no runtime builder.\n+                \/\/ This should be runtime packaging.\n+                if (pkg.isRuntimeInstaller()) {\n+                    return env.appImageDir();\n+                } else {\n+                    \/\/ Can't create app image without runtime builder.\n+                    throw new UnsupportedOperationException();\n+                }\n+            }));\n+\n+            if (taskConfig.get(CopyAppImageTaskID.COPY).action().isEmpty()) {\n+                \/\/ \"copy app image\" task action is undefined indicating\n+                \/\/ the package will use provided app image as-is.\n+                dstAppImageDesc = srcAppImageDesc;\n+            } else {\n+                dstAppImageDesc = new AppImageDesc(appImageLayoutForPackaging, env.buildRoot().resolve(\"image\"));\n+            }\n+        }\n+\n+        final var pkgEnv = new PackageBuildEnv<>(\n+                BuildEnv.withAppImageDir(env, dstAppImageDesc.path()), pkg, dstAppImageDesc.appImageLyout(), outputDir);\n+\n+        return new PackagingTaskContext(pkgEnv, srcAppImageDesc);\n+    }\n+\n+    private void execute(TaskContext context) throws PackagerException {\n+        final Map<TaskID, Callable<Void>> tasks = taskConfig.entrySet().stream().collect(toMap(Map.Entry::getKey, task -> {\n+            return createTask(context, task.getKey(), task.getValue());\n+        }));\n+\n+        final var builder = new TaskPipelineBuilder();\n+\n+        for (final var tail : taskGraph.nodes()) {\n+            for (final var head : taskGraph.getHeadsOf(tail)) {\n+                builder.linkTasks(tasks.get(tail), tasks.get(head));\n+            }\n+        }\n+\n+        try {\n+            builder.create().call();\n+        } catch (Exception ex) {\n+            if (ex instanceof PackagerException pex) {\n+                throw pex;\n+            } else if (ex instanceof ExceptionBox bex) {\n+                throw new PackagerException(bex.getCause());\n+            } else {\n+                throw new PackagerException(ex);\n+            }\n+        }\n+    }\n+\n+    private record PackagingTaskContext(PackageBuildEnv<Package, AppImageLayout> env,\n+            AppImageDesc srcAppImage) implements TaskContext, StartupParameters {\n+\n+        PackagingTaskContext {\n+            Objects.requireNonNull(env);\n+            Objects.requireNonNull(srcAppImage);\n+        }\n+\n+        @Override\n+        public BuildEnv packagingEnv() {\n+            return env.env;\n+        }\n+\n+        @Override\n+        public boolean test(TaskID taskID) {\n+            if (taskID == BuildApplicationTaskID.APP_IMAGE_FILE) {\n+                \/\/ Application image for packaging, skip adding application image info file.\n+                return false;\n+            }\n+\n+            return true;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+            if (taskAction instanceof PackageTaskAction<?, ?>) {\n+                ((PackageTaskAction<Package, AppImageLayout>)taskAction).execute(env);\n+            } else if (taskAction instanceof CopyAppImageTaskAction<?>) {\n+                ((CopyAppImageTaskAction<Package>)taskAction).execute(env.pkg(),\n+                        srcAppImage, new AppImageDesc(env.envLayout(), env.env().appImageDir()));\n+            } else {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        AppImageBuildEnv<Application, AppImageLayout> appImageBuildEnv() {\n+            return env.appImageBuildEnv();\n+        }\n+    }\n+\n+    private record DefaultTaskContext(FixedDAG<TaskID> taskGraph, BuildEnv env, Application app,\n+            Optional<ApplicationLayout> appLayout, Optional<PackagingTaskContext> pkg) implements TaskContext {\n+\n+        DefaultTaskContext {\n+            Objects.requireNonNull(taskGraph);\n+            Objects.requireNonNull(env);\n+            Objects.requireNonNull(app);\n+            Objects.requireNonNull(appLayout);\n+            Objects.requireNonNull(pkg);\n+        }\n+\n+        @Override\n+        public boolean test(TaskID taskID) {\n+            final var isBuildApplicationImageTask = isBuildApplicationImageTask(taskID);\n+            final var isCopyAppImageTask = isCopyAppImageTask(taskID);\n+            final var isPackageTask = !isBuildApplicationImageTask && !isCopyAppImageTask;\n+\n+            if (pkg.isPresent() && !pkg.orElseThrow().test(taskID)) {\n+                return false;\n+            } else if (pkg.isEmpty() && isPackageTask) {\n+                \/\/ Building application image, skip packaging tasks.\n+                return false;\n+            } else if (app.runtimeBuilder().isEmpty() && isBuildApplicationImageTask && !isCopyAppImageTask) {\n+                \/\/ Runtime builder is not present, skip building application image tasks.\n+                return false;\n+            } else if (app.runtimeBuilder().isPresent() && isCopyAppImageTask && !isBuildApplicationImageTask) {\n+                \/\/ Runtime builder is present, skip copying app image tasks.\n+                return false;\n+            } else {\n+                return true;\n+            }\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void execute(TaskAction taskAction) throws IOException, PackagerException {\n+            if (taskAction instanceof AppImageTaskAction<?, ?>) {\n+                final var taskEnv = pkg.map(PackagingTaskContext::appImageBuildEnv).orElseGet(this::appBuildEnv);\n+                ((AppImageTaskAction<Application, AppImageLayout>)taskAction).execute(taskEnv);\n+            } else if (taskAction instanceof ApplicationImageTaskAction<?, ?>) {\n+                ((ApplicationImageTaskAction<Application, ApplicationLayout>)taskAction).execute(appBuildEnv());\n+            } else if (taskAction instanceof NoArgTaskAction noArgAction) {\n+                noArgAction.execute();\n+            } else {\n+                pkg.orElseThrow().execute(taskAction);\n+            }\n+        }\n+\n+        private boolean isBuildApplicationImageTask(TaskID taskID) {\n+            return (taskID == PrimaryTaskID.BUILD_APPLICATION_IMAGE\n+                    || taskGraph.getAllHeadsOf(taskID).contains(PrimaryTaskID.BUILD_APPLICATION_IMAGE));\n+        }\n+\n+        private boolean isCopyAppImageTask(TaskID taskID) {\n+            return (taskID == PrimaryTaskID.COPY_APP_IMAGE\n+                    || taskGraph.getAllHeadsOf(taskID).contains(PrimaryTaskID.COPY_APP_IMAGE));\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private <T extends AppImageLayout> AppImageBuildEnv<Application, T> appBuildEnv() {\n+            return new AppImageBuildEnv<>(env, app, (T)appLayout.orElseThrow());\n+        }\n+    }\n+\n+    private static Callable<Void> createTask(TaskContext context, TaskID id, TaskConfig config) {\n+        Objects.requireNonNull(context);\n+        Objects.requireNonNull(id);\n+        Objects.requireNonNull(config);\n+        return () -> {\n+            if (config.action.isPresent() && context.test(id)) {\n+                try {\n+                    context.execute(config.action.orElseThrow());\n+                } catch (ExceptionBox ex) {\n+                    throw ExceptionBox.rethrowUnchecked(ex);\n+                }\n+            }\n+            return null;\n+        };\n+    }\n+\n+    private final FixedDAG<TaskID> taskGraph;\n+    private final Map<TaskID, TaskConfig> taskConfig;\n+    private final Function<Package, AppImageLayout> appImageLayoutForPackaging;\n+    private final UnaryOperator<TaskContext> appContextMapper;\n+    private final UnaryOperator<TaskContext> pkgContextMapper;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PackagingPipeline.java","additions":618,"deletions":0,"binary":false,"changes":618,"status":"added"},{"patch":"@@ -1,55 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.jpackage.internal;\n-\n-import java.nio.file.Path;\n-\n-\/**\n- *\n- * Platform package of an application.\n- *\/\n-interface PlatformPackage {\n-\n-    \/**\n-     * Platform-specific package name.\n-     *\/\n-    String name();\n-\n-    \/**\n-     * Root directory where sources for packaging tool should be stored. On Unix\n-     * systems contents of this directory will be installed in \"\/\" directory.\n-     *\/\n-    Path sourceRoot();\n-\n-    \/**\n-     * Source application layout from which to build the package.\n-     *\/\n-    ApplicationLayout sourceApplicationLayout();\n-\n-    \/**\n-     * Application layout of the installed package.\n-     *\/\n-    ApplicationLayout installedApplicationLayout();\n-}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/PlatformPackage.java","additions":0,"deletions":55,"binary":false,"changes":55,"status":"deleted"},{"patch":"@@ -0,0 +1,186 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.LinkOption;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import jdk.jpackage.internal.model.RuntimeBuilder;\n+import jdk.jpackage.internal.util.FileUtils;\n+import jdk.jpackage.internal.util.PathGroup;\n+\n+final class RuntimeBuilderBuilder {\n+\n+    RuntimeBuilder create() {\n+        return impl.get();\n+    }\n+\n+    RuntimeBuilderBuilder modulePath(List<Path> v) {\n+        modulePath = v;\n+        return this;\n+    }\n+\n+    RuntimeBuilderBuilder forRuntime(Path predefinedRuntimeImage) {\n+        impl = new CopyingRuntime(this, predefinedRuntimeImage);\n+        return this;\n+    }\n+\n+    RuntimeBuilderConfigBuilder forNewRuntime(List<LauncherStartupInfo> startupInfos) {\n+        return new RuntimeBuilderConfigBuilder(startupInfos);\n+    }\n+\n+    final class RuntimeBuilderConfigBuilder {\n+\n+        RuntimeBuilderConfigBuilder(List<LauncherStartupInfo> startupInfos) {\n+            Objects.requireNonNull(startupInfos);\n+            if (startupInfos.isEmpty()) {\n+                throw new IllegalArgumentException();\n+            }\n+            this.startupInfos = startupInfos;\n+        }\n+\n+        RuntimeBuilderBuilder appy() {\n+            impl = new BuildingRuntime(RuntimeBuilderBuilder.this, addModules,\n+                    limitModules, validatedOptions(), startupInfos);\n+            return RuntimeBuilderBuilder.this;\n+        }\n+\n+        RuntimeBuilderConfigBuilder addModules(Set<String> v) {\n+            addModules = v;\n+            return this;\n+        }\n+\n+        RuntimeBuilderConfigBuilder limitModules(Set<String> v) {\n+            limitModules = v;\n+            return this;\n+        }\n+\n+        RuntimeBuilderConfigBuilder options(List<String> v) {\n+            options = v;\n+            return this;\n+        }\n+\n+        private List<String> validatedOptions() {\n+            return Optional.ofNullable(options).orElse(DEFAULT_JLINK_OPTIONS);\n+        }\n+\n+        private Set<String> addModules;\n+        private Set<String> limitModules;\n+        private List<String> options;\n+        private final List<LauncherStartupInfo> startupInfos;\n+\n+        private static final List<String> DEFAULT_JLINK_OPTIONS = List.of(\n+                \"--strip-native-commands\",\n+                \"--strip-debug\",\n+                \"--no-man-pages\",\n+                \"--no-header-files\"\n+        );\n+    }\n+\n+    private static RuntimeBuilder createCopyingRuntimeBuilder(Path runtimeDir,\n+            Path... modulePath) throws ConfigException {\n+        if (!Files.exists(runtimeDir)) {\n+            throw buildConfigException()\n+                    .message(\"message.runtime-image-dir-does-not-exist\",\n+                            \"--runtime-image\", runtimeDir)\n+                    .advice(\"message.runtime-image-dir-does-not-exist.advice\",\n+                            \"--runtime-image\")\n+                    .create();\n+        }\n+\n+        return appImageLayout -> {\n+            try {\n+                \/\/ copy whole runtime, skipping jmods and src.zip\n+                final var srcPathGroup = new PathGroup(Map.of(\"root\", runtimeDir));\n+                \/\/ JDK8\n+                srcPathGroup.ghostPath(runtimeDir.resolve(\"src.zip\"));\n+                \/\/ Newer JDKs\n+                srcPathGroup.ghostPath(runtimeDir.resolve(\"lib\/src.zip\"));\n+                srcPathGroup.ghostPath(runtimeDir.resolve(\"jmods\"));\n+\n+                srcPathGroup.copy(new PathGroup(Map.of(\"root\", appImageLayout.runtimeDirectory())),\n+                        LinkOption.NOFOLLOW_LINKS);\n+\n+                \/\/ if module-path given - copy modules to appDir\/mods\n+                List<Path> defaultModulePath = getDefaultModulePath();\n+                Path dest = ((ApplicationLayout)appImageLayout).appModsDirectory();\n+\n+                for (Path mp : modulePath) {\n+                    if (!defaultModulePath.contains(mp.toAbsolutePath())) {\n+                        FileUtils.copyRecursive(mp, dest);\n+                    }\n+                }\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n+        };\n+    }\n+\n+    private record CopyingRuntime(RuntimeBuilderBuilder thiz, Path predefinedRuntimeImage)\n+            implements Supplier<RuntimeBuilder> {\n+\n+        @Override\n+        public RuntimeBuilder get() {\n+            return toSupplier(() -> createCopyingRuntimeBuilder(\n+                    predefinedRuntimeImage,\n+                    Optional.ofNullable(thiz.modulePath).orElseGet(List::of).toArray(Path[]::new))\n+            ).get();\n+        }\n+    }\n+\n+    private record BuildingRuntime(RuntimeBuilderBuilder thiz, Set<String> addModules,\n+            Set<String> limitModules, List<String> options,\n+            List<LauncherStartupInfo> startupInfos) implements Supplier<RuntimeBuilder> {\n+\n+        @Override\n+        public RuntimeBuilder get() {\n+            return toSupplier(() -> JLinkRuntimeBuilder.createJLinkRuntimeBuilder(\n+                    Optional.ofNullable(thiz.modulePath).orElseGet(List::of),\n+                    Optional.ofNullable(addModules).orElseGet(Set::of),\n+                    Optional.ofNullable(limitModules).orElseGet(Set::of),\n+                    Optional.ofNullable(options).orElseGet(List::of),\n+                    startupInfos)\n+            ).get();\n+        }\n+    }\n+\n+    private List<Path> modulePath;\n+    private Supplier<RuntimeBuilder> impl;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/RuntimeBuilderBuilder.java","additions":186,"deletions":0,"binary":false,"changes":186,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,3 +36,0 @@\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;\n@@ -78,2 +75,2 @@\n-    public void run(Map<String, ? super Object> params) throws IOException {\n-        String scriptName = String.format(\"%s-%s%s\", APP_NAME.fetchFrom(params),\n+    public void run(BuildEnv env, String name) throws IOException {\n+        String scriptName = String.format(\"%s-%s%s\", name,\n@@ -81,3 +78,2 @@\n-        Path scriptPath = CONFIG_ROOT.fetchFrom(params).resolve(\n-                scriptName);\n-        createResource(null, params)\n+        Path scriptPath = env.configDir().resolve(scriptName);\n+        env.createResource(null)\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ScriptRunner.java","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.internal.util.OperatingSystem;\n@@ -33,1 +32,0 @@\n-import java.nio.file.LinkOption;\n@@ -44,2 +42,0 @@\n-import java.util.function.BiFunction;\n-import java.util.function.Function;\n@@ -48,1 +44,3 @@\n-import jdk.jpackage.internal.util.FileUtils;\n+import static jdk.jpackage.internal.ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+import static jdk.jpackage.internal.model.RuntimeBuilder.getDefaultModulePath;\n@@ -51,1 +49,1 @@\n- * StandardBundlerParam\n+ * Standard bundler parameters.\n@@ -53,3 +51,1 @@\n- * A parameter to a bundler.\n- *\n- * Also contains static definitions of all of the common bundler parameters.\n+ * Contains static definitions of all of the common bundler parameters.\n@@ -61,1 +57,1 @@\n-class StandardBundlerParam<T> extends BundlerParamInfo<T> {\n+final class StandardBundlerParam {\n@@ -72,23 +68,2 @@\n-    StandardBundlerParam(String id, Class<T> valueType,\n-            Function<Map<String, ? super Object>, T> defaultValueFunction,\n-            BiFunction<String, Map<String, ? super Object>, T> stringConverter)\n-    {\n-        this.id = id;\n-        this.valueType = valueType;\n-        this.defaultValueFunction = defaultValueFunction;\n-        this.stringConverter = stringConverter;\n-    }\n-\n-    static final StandardBundlerParam<LauncherData> LAUNCHER_DATA =\n-            new StandardBundlerParam<>(\n-                    \"launcherData\",\n-                    LauncherData.class,\n-                    params -> {\n-                        try {\n-                            return LauncherData.create(params);\n-                        } catch (ConfigException | IOException ex) {\n-                            throw new RuntimeException(ex);\n-                        }\n-                    },\n-                    null\n-            );\n+    static final BundlerParamInfo<LauncherData> LAUNCHER_DATA = BundlerParamInfo.createBundlerParam(\n+            LauncherData.class, LauncherData::create);\n@@ -96,2 +71,2 @@\n-    static final StandardBundlerParam<Path> SOURCE_DIR =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> SOURCE_DIR =\n+            new BundlerParamInfo<>(\n@@ -104,2 +79,2 @@\n-    static final StandardBundlerParam<Path> OUTPUT_DIR =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> OUTPUT_DIR =\n+            new BundlerParamInfo<>(\n@@ -114,2 +89,2 @@\n-    static final StandardBundlerParam<Path> MAIN_JAR =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> MAIN_JAR =\n+            new BundlerParamInfo<>(\n@@ -122,2 +97,12 @@\n-    static final StandardBundlerParam<String> MAIN_CLASS =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<AppImageFile> PREDEFINED_APP_IMAGE_FILE = BundlerParamInfo.createBundlerParam(\n+            AppImageFile.class, params -> {\n+                if (hasPredefinedAppImage(params)) {\n+                    var appImage = getPredefinedAppImage(params);\n+                    return AppImageFile.load(appImage, PLATFORM_APPLICATION_LAYOUT);\n+                } else {\n+                    return null;\n+                }\n+            });\n+\n+    static final BundlerParamInfo<String> MAIN_CLASS =\n+            new BundlerParamInfo<>(\n@@ -130,2 +115,1 @@\n-                            return AppImageFile.extractMainClass(\n-                                    getPredefinedAppImage(params));\n+                            PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getMainClass();\n@@ -138,2 +122,2 @@\n-    static final StandardBundlerParam<Path> PREDEFINED_RUNTIME_IMAGE =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> PREDEFINED_RUNTIME_IMAGE =\n+            new BundlerParamInfo<>(\n@@ -146,2 +130,2 @@\n-    static final StandardBundlerParam<Path> PREDEFINED_APP_IMAGE =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> PREDEFINED_APP_IMAGE =\n+            new BundlerParamInfo<>(\n@@ -154,2 +138,2 @@\n-    static final StandardBundlerParam<String> NAME =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> NAME =\n+            new BundlerParamInfo<>(\n@@ -164,2 +148,2 @@\n-    static final StandardBundlerParam<String> APP_NAME =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> APP_NAME =\n+            new BundlerParamInfo<>(\n@@ -169,1 +153,0 @@\n-                        Path appImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n@@ -171,3 +154,2 @@\n-                        if (appImage != null) {\n-                            String name = AppImageFile.extractAppName(appImage);\n-                            appName  = (name != null) ? name : appName;\n+                        if (hasPredefinedAppImage(params)) {\n+                            appName = PREDEFINED_APP_IMAGE_FILE.fetchFrom(params).getLauncherName();\n@@ -191,2 +173,2 @@\n-    static final StandardBundlerParam<String> INSTALLER_NAME =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> INSTALLER_NAME =\n+            new BundlerParamInfo<>(\n@@ -203,2 +185,2 @@\n-    static final StandardBundlerParam<Path> ICON =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> ICON =\n+            new BundlerParamInfo<>(\n@@ -211,2 +193,2 @@\n-    static final StandardBundlerParam<String> ABOUT_URL =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> ABOUT_URL =\n+            new BundlerParamInfo<>(\n@@ -219,2 +201,2 @@\n-    static final StandardBundlerParam<String> VENDOR =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> VENDOR =\n+            new BundlerParamInfo<>(\n@@ -227,2 +209,2 @@\n-    static final StandardBundlerParam<String> DESCRIPTION =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> DESCRIPTION =\n+            new BundlerParamInfo<>(\n@@ -237,2 +219,2 @@\n-    static final StandardBundlerParam<String> COPYRIGHT =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> COPYRIGHT =\n+            new BundlerParamInfo<>(\n@@ -247,2 +229,2 @@\n-    static final StandardBundlerParam<List<String>> ARGUMENTS =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<String>> ARGUMENTS =\n+            new BundlerParamInfo<>(\n@@ -256,2 +238,2 @@\n-    static final StandardBundlerParam<List<String>> JAVA_OPTIONS =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<String>> JAVA_OPTIONS =\n+            new BundlerParamInfo<>(\n@@ -264,2 +246,2 @@\n-    static final StandardBundlerParam<String> VERSION =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> VERSION =\n+            new BundlerParamInfo<>(\n@@ -272,2 +254,2 @@\n-    static final StandardBundlerParam<String> RELEASE =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> RELEASE =\n+            new BundlerParamInfo<>(\n@@ -280,2 +262,2 @@\n-    public static final StandardBundlerParam<String> LICENSE_FILE =\n-            new StandardBundlerParam<>(\n+    public static final BundlerParamInfo<String> LICENSE_FILE =\n+            new BundlerParamInfo<>(\n@@ -288,2 +270,2 @@\n-    static final StandardBundlerParam<Path> TEMP_ROOT =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> TEMP_ROOT =\n+            new BundlerParamInfo<>(\n@@ -302,2 +284,2 @@\n-    public static final StandardBundlerParam<Path> CONFIG_ROOT =\n-            new StandardBundlerParam<>(\n+    public static final BundlerParamInfo<Path> CONFIG_ROOT =\n+            new BundlerParamInfo<>(\n@@ -318,2 +300,2 @@\n-    static final StandardBundlerParam<Boolean> VERBOSE  =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Boolean> VERBOSE  =\n+            new BundlerParamInfo<>(\n@@ -328,2 +310,2 @@\n-    static final StandardBundlerParam<Boolean> SHORTCUT_HINT  =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Boolean> SHORTCUT_HINT  =\n+            new BundlerParamInfo<>(\n@@ -337,2 +319,2 @@\n-    static final StandardBundlerParam<Boolean> MENU_HINT  =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Boolean> MENU_HINT  =\n+            new BundlerParamInfo<>(\n@@ -346,2 +328,2 @@\n-    static final StandardBundlerParam<Path> RESOURCE_DIR =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> RESOURCE_DIR =\n+            new BundlerParamInfo<>(\n@@ -355,1 +337,1 @@\n-            new StandardBundlerParam<>(\n+            new BundlerParamInfo<>(\n@@ -362,2 +344,2 @@\n-    static final StandardBundlerParam<Boolean> LAUNCHER_AS_SERVICE =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Boolean> LAUNCHER_AS_SERVICE =\n+            new BundlerParamInfo<>(\n@@ -374,2 +356,2 @@\n-    static final StandardBundlerParam<List<Map<String, ? super Object>>> ADD_LAUNCHERS =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<Map<String, ? super Object>>> ADD_LAUNCHERS =\n+            new BundlerParamInfo<>(\n@@ -385,1 +367,1 @@\n-    static final StandardBundlerParam\n+    static final BundlerParamInfo\n@@ -387,1 +369,1 @@\n-            new StandardBundlerParam<>(\n+            new BundlerParamInfo<>(\n@@ -397,2 +379,2 @@\n-    static final StandardBundlerParam<List<String>> FA_EXTENSIONS =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<String>> FA_EXTENSIONS =\n+            new BundlerParamInfo<>(\n@@ -406,2 +388,2 @@\n-    static final StandardBundlerParam<List<String>> FA_CONTENT_TYPE =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<String>> FA_CONTENT_TYPE =\n+            new BundlerParamInfo<>(\n@@ -415,2 +397,2 @@\n-    static final StandardBundlerParam<String> FA_DESCRIPTION =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<String> FA_DESCRIPTION =\n+            new BundlerParamInfo<>(\n@@ -423,2 +405,2 @@\n-    static final StandardBundlerParam<Path> FA_ICON =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Path> FA_ICON =\n+            new BundlerParamInfo<>(\n@@ -432,2 +414,2 @@\n-    static final BundlerParamInfo<List<String>> DMG_CONTENT =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<Path>> DMG_CONTENT =\n+            new BundlerParamInfo<>(\n@@ -435,1 +417,1 @@\n-                    (Class<List<String>>) (Object)List.class,\n+                    (Class<List<Path>>) (Object)List.class,\n@@ -437,1 +419,1 @@\n-                    (s, p) -> Arrays.asList(s.split(\",\"))\n+                    (s, p) -> Stream.of(s.split(\",\")).map(Path::of).toList()\n@@ -441,2 +423,2 @@\n-    static final StandardBundlerParam<List<String>> APP_CONTENT =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<Path>> APP_CONTENT =\n+            new BundlerParamInfo<>(\n@@ -444,1 +426,1 @@\n-                    (Class<List<String>>) (Object)List.class,\n+                    (Class<List<Path>>) (Object)List.class,\n@@ -446,1 +428,1 @@\n-                    (s, p) -> Arrays.asList(s.split(\",\"))\n+                    (s, p) -> Stream.of(s.split(\",\")).map(Path::of).toList()\n@@ -451,1 +433,1 @@\n-            new StandardBundlerParam<>(\n+            new BundlerParamInfo<>(\n@@ -496,1 +478,1 @@\n-            new StandardBundlerParam<>(\n+            new BundlerParamInfo<>(\n@@ -506,1 +488,1 @@\n-            new StandardBundlerParam<>(\n+            new BundlerParamInfo<>(\n@@ -514,2 +496,2 @@\n-    static final StandardBundlerParam<List<String>> JLINK_OPTIONS =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<List<String>> JLINK_OPTIONS =\n+            new BundlerParamInfo<>(\n@@ -523,1 +505,1 @@\n-            new StandardBundlerParam<>(\n+            new BundlerParamInfo<>(\n@@ -530,2 +512,2 @@\n-    static final StandardBundlerParam<Boolean> SIGN_BUNDLE =\n-            new StandardBundlerParam<>(\n+    static final BundlerParamInfo<Boolean> SIGN_BUNDLE =\n+            new BundlerParamInfo<>(\n@@ -539,16 +521,0 @@\n-    static final StandardBundlerParam<Boolean> APP_STORE =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.MAC_APP_STORE.getId(),\n-            Boolean.class,\n-            params -> {\n-                if (hasPredefinedAppImage(params)) {\n-                    return AppImageFile.load(getPredefinedAppImage(params))\n-                            .isAppStore();\n-                }\n-                return false;\n-            },\n-            \/\/ valueOf(null) is false, we actually do want null in some cases\n-            (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ?\n-                    null : Boolean.valueOf(s)\n-        );\n-\n@@ -571,34 +537,7 @@\n-        return PREDEFINED_APP_IMAGE.fetchFrom(params);\n-    }\n-\n-    static void copyPredefinedRuntimeImage(Map<String, ? super Object> params,\n-            ApplicationLayout appLayout) throws IOException, ConfigException {\n-        Path topImage = PREDEFINED_RUNTIME_IMAGE.fetchFrom(params);\n-\n-        if (OperatingSystem.isMacOS()) {\n-            \/\/ On Mac topImage can be runtime root or runtime home.\n-            Path runtimeHome = topImage.resolve(\"Contents\/Home\");\n-            if (Files.isDirectory(runtimeHome)) {\n-                \/\/ topImage references runtime root, adjust it to pick data from\n-                \/\/ runtime home\n-                topImage = runtimeHome;\n-            }\n-        }\n-\n-        \/\/ copy whole runtime, need to skip jmods and src.zip\n-        final List<Path> excludes = Arrays.asList(Path.of(\"jmods\"), Path.of(\"src.zip\"));\n-        FileUtils.copyRecursive(topImage, appLayout.runtimeHomeDirectory(),\n-                        excludes, LinkOption.NOFOLLOW_LINKS);\n-\n-        \/\/ if module-path given - copy modules to appDir\/mods\n-        List<Path> modulePath = MODULE_PATH.fetchFrom(params);\n-        List<Path> defaultModulePath = getDefaultModulePath();\n-        Path dest = appLayout.appModsDirectory();\n-\n-        if (dest != null) {\n-            for (Path mp : modulePath) {\n-                if (!defaultModulePath.contains(mp)) {\n-                    Files.createDirectories(dest);\n-                    FileUtils.copyRecursive(mp, dest);\n-                }\n-            }\n+        Path applicationImage = PREDEFINED_APP_IMAGE.fetchFrom(params);\n+        if (applicationImage != null && !IOUtils.exists(applicationImage)) {\n+            throw new RuntimeException(\n+                    MessageFormat.format(I18N.getString(\n+                            \"message.app-image-dir-does-not-exist\"),\n+                            PREDEFINED_APP_IMAGE.getID(),\n+                            applicationImage.toString()));\n@@ -606,0 +545,1 @@\n+        return applicationImage;\n@@ -608,3 +548,9 @@\n-    private static List<Path> getDefaultModulePath() {\n-        return List.of(\n-                Path.of(System.getProperty(\"java.home\"), \"jmods\").toAbsolutePath());\n+    static OverridableResource createResource(String defaultName,\n+            Map<String, ? super Object> params) {\n+        final OverridableResource resource;\n+        if (defaultName == null) {\n+            resource = new OverridableResource();\n+        } else {\n+            resource = new OverridableResource(defaultName, ResourceLocator.class);\n+        }\n+        return resource.setResourceDir(RESOURCE_DIR.fetchFrom(params));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/StandardBundlerParam.java","additions":119,"deletions":173,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -0,0 +1,121 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+\n+import java.lang.reflect.Modifier;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+import jdk.jpackage.internal.util.PathGroup;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+\n+\n+\/**\n+ * Generic app image directory layout.\n+ *\n+ * App image layout is a collection of files and directories with specific roles\n+ * (executables, configuration files, etc.) sharing the same root directory.\n+ *\n+ * The layout is \"unresolved\" if the root directory is an empty string and\n+ * \"resolved\" otherwise.\n+ *\/\n+public interface AppImageLayout {\n+\n+    \/**\n+     * A path to Java runtime directory.\n+     * The directory should have standard JDK subdirectories like \"bin\", \"lib\", etc.\n+     *\n+     * @return Java runtime sub-directory within this app image\n+     *\/\n+    Path runtimeDirectory();\n+\n+    \/**\n+     * Root directory of this app image.\n+     * It should normally be equal to <code>Path.of(\"\")<\/code> for unresolved layout.\n+     *\n+     * @return the root directory of this app image\n+     *\/\n+    Path rootDirectory();\n+\n+    \/**\n+     * Creates a copy of this app image resolved at the given root directory.\n+     *\n+     * @param root path to a directory at which to resolve the layout\n+     * @return a copy of this app image resolved at the given root directory\n+     *\/\n+    AppImageLayout resolveAt(Path root);\n+\n+    \/**\n+     * Default implementation of {@link AppImageLayout} interface.\n+    *\/\n+    record Stub(Path rootDirectory, Path runtimeDirectory) implements AppImageLayout {\n+\n+        @Override\n+        public AppImageLayout resolveAt(Path base) {\n+            return new Stub(resolveNullablePath(base, rootDirectory), resolveNullablePath(base, runtimeDirectory));\n+        }\n+    }\n+\n+    \/**\n+     * Creates {@link PathGroup} object from the given {@link AppImageLayout}\n+     * instance.\n+     *\n+     * It will call every non-static accessible method without parameters and with\n+     * {@link Path} return type of the given {@link AppImageLayout} instance except\n+     * {@link #rootDirectory()} method.\n+     * <p>\n+     * For every call, it will save the return value in the output {@link PathGroup}\n+     * object under the key equals the name of a function used in the call.\n+     *\n+     * @param appImageLayout source layout object\n+     * @return {@link PathGroup} object constructed from the given source layout\n+     *         object\n+     *\/\n+    public static PathGroup toPathGroup(AppImageLayout appImageLayout) {\n+        return new PathGroup(Stream.of(appImageLayout.getClass().getInterfaces())\n+                \/\/ For all interfaces (it should be one, but multiple is OK)\n+                \/\/ extending AppImageLayout interface call all non-static methods\n+                \/\/ without parameters and with java.nio.file.Path return type.\n+                \/\/ Create a map from the names of methods called and return values.\n+                .filter(AppImageLayout.class::isAssignableFrom)\n+                .map(Class::getMethods)\n+                .flatMap(Stream::of)\n+                .filter(m -> !Modifier.isStatic(m.getModifiers()))\n+                .filter(m -> !\"rootDirectory\".equals(m.getName()))\n+                .filter(m -> {\n+                    return m.getReturnType().isAssignableFrom(Path.class) && m.getParameterCount() == 0;\n+                }).<Map.Entry<String, Path>>mapMulti((m, consumer) -> {\n+                    Optional.ofNullable(toFunction(m::invoke).apply(appImageLayout)).ifPresent(path -> {\n+                        consumer.accept(Map.entry(m.getName(), (Path)path));\n+                    });\n+                }).collect(HashMap::new, (ctnr, e) -> {\n+                    ctnr.put(e.getKey(), e.getValue());\n+                }, Map::putAll));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImageLayout.java","additions":121,"deletions":0,"binary":false,"changes":121,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+\/**\n+ * App image packaging type.\n+ *\n+ * @see StandardPackageType\n+ *\/\n+public final class AppImagePackageType implements PackageType {\n+\n+    private AppImagePackageType() {\n+    }\n+\n+    \/**\n+     * Singleton\n+     *\/\n+    public static final AppImagePackageType APP_IMAGE = new AppImagePackageType();\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/AppImagePackageType.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,251 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A generic application for packaging.\n+ *\n+ * @apiNote All paths of startup configurations of application launchers\n+ *          returned by {@link #launchers()} call must be relative to the path\n+ *          returned by {@link #srcDir()} call.\n+ *\n+ * @see Package\n+ *\/\n+public interface Application {\n+\n+    \/**\n+     * Gets the name of this application.\n+     *\n+     * @return the name of this application\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Gets the description of this application.\n+     *\n+     * @return the description of this application\n+     *\/\n+    String description();\n+\n+    \/**\n+     * Gets the version of this application.\n+     *\n+     * @return the version of this application\n+     *\/\n+    String version();\n+\n+    \/**\n+     * Gets the vendor of this application.\n+     *\n+     * @return the vendor of this application\n+     *\/\n+    String vendor();\n+\n+    \/**\n+     * Gets the copyright of this application.\n+     *\n+     * @return the copyright of this application\n+     *\/\n+    String copyright();\n+\n+    \/**\n+     * Gets the source directory of this application if available or an empty\n+     * {@link Optional} instance.\n+     * <p>\n+     * Source directory is a directory with the applications's classes and other\n+     * resources.\n+     *\n+     * @return the source directory of this application\n+     *\/\n+    Optional<Path> srcDir();\n+\n+    \/**\n+     * Gets the input content directories of this application.\n+     * <p>\n+     * Contents of the content directories will be copied as-is into the dedicated\n+     * location of the application image.\n+     *\n+     * @see ApplicationLayout#contentDirectory\n+     *\n+     * @return the input content directories of this application\n+     *\/\n+    List<Path> contentDirs();\n+\n+    \/**\n+     * Gets the unresolved app image layout of this application.\n+     *\n+     * @return the unresolved app image layout of this application\n+     *\/\n+    AppImageLayout imageLayout();\n+\n+    \/**\n+     * Gets the unresolved app image layout of this application as\n+     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n+     * return value of {@link #imageLayout()} call is not an instance of\n+     * {@link ApplicationLayout} type.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if {@link #isRuntime()} returns\n+     * <code>true<\/code>.\n+     *\n+     * @see #isRuntime\n+     *\n+     * @return the unresolved app image layout of this application as\n+     *         {@link ApplicationLayout}\n+     *\/\n+    default Optional<ApplicationLayout> asApplicationLayout() {\n+        if (imageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the runtime builder of this application if available or an empty\n+     * {@link Optional} instance.\n+     *\n+     * @return the runtime builder of this application\n+     *\/\n+    Optional<RuntimeBuilder> runtimeBuilder();\n+\n+    \/**\n+     * Gets the name of the root app image directory of this application.\n+     *\n+     * @return the name of the root app image directory of this application\n+     *\/\n+    default Path appImageDirName() {\n+        return Path.of(name());\n+    }\n+\n+    \/**\n+     * Gets the application launchers of this application.\n+     * <p>\n+     * If the returned list is not empty, the first element in the list is the main\n+     * launcher.\n+     * <p>\n+     * Returns an empty list if {@link #isRuntime()} returns <code>true<\/code>.\n+     *\n+     * @see #mainLauncher()\n+     * @see #additionalLaunchers()\n+     * @see #isRuntime()\n+     *\n+     * @return the application launchers of this application\n+     *\/\n+    List<Launcher> launchers();\n+\n+    \/**\n+     * Returns the main application launcher of this application or an empty\n+     * {@link Optional} instance if the application doesn't have launchers.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if {@link #isRuntime()} returns\n+     * <code>true<\/code>.\n+     *\n+     * @see #launchers()\n+     * @see #additionalLaunchers()\n+     * @see #isRuntime()\n+     *\n+     * @return the main application launcher of this application\n+     *\/\n+    default Optional<Launcher> mainLauncher() {\n+        return ApplicationLaunchers.fromList(launchers()).map(ApplicationLaunchers::mainLauncher);\n+    }\n+\n+    \/**\n+     * Gets the additional application launchers of this application.\n+     * <p>\n+     * Returns an empty list if this application doesn't have additional launchers.\n+     * <p>\n+     * Returns an empty list if {@link #isRuntime()} returns <code>true<\/code>.\n+     *\n+     * @see #launchers()\n+     * @see #mainLauncher()\n+     * @see #isRuntime()\n+     *\n+     * @return the additional application launchers of this application\n+     *\/\n+    default List<Launcher> additionalLaunchers() {\n+        return ApplicationLaunchers.fromList(launchers()).map(ApplicationLaunchers::additionalLaunchers)\n+                .orElseGet(Collections::emptyList);\n+    }\n+\n+    \/**\n+     * Returns <code>true<\/code> if this application is Java runtime.\n+     *\n+     * @return <code>true<\/code> if this application is Java runtime\n+     *\/\n+    default boolean isRuntime() {\n+        return imageLayout() instanceof RuntimeLayout;\n+    }\n+\n+    \/**\n+     * Returns <code>true<\/code> if any of application launchers of this application\n+     * are configured as services.\n+     *\n+     * @see Launcher#isService\n+     *\n+     * @return <code>true<\/code> if any of application launchers of this application\n+     *         are configured as services\n+     *\/\n+    default boolean isService() {\n+        return Optional.ofNullable(launchers()).orElseGet(List::of).stream()\n+                .filter(Launcher::isService).findAny().isPresent();\n+    }\n+\n+    \/**\n+     * Gets the additional properties of this application for the application entry\n+     * in the app image (\".jpackage\") file.\n+     *\n+     * @return the additional properties of this application for the application\n+     *         entry in \".jpackage\" file\n+     *\/\n+    Map<String, String> extraAppImageFileData();\n+\n+    \/**\n+     * Gets the file associations of all application launchers of this application.\n+     *\n+     * @return the file associations of all application launchers of this\n+     *         application\n+     *\n+     * @see Launcher#fileAssociations\n+     *\/\n+    default Stream<FileAssociation> fileAssociations() {\n+        return launchers().stream().map(Launcher::fileAssociations).flatMap(List::stream);\n+    }\n+\n+    \/**\n+     * Default implementation of {@link Application} interface.\n+     *\/\n+    record Stub(String name, String description, String version, String vendor, String copyright, Optional<Path> srcDir,\n+            List<Path> contentDirs, AppImageLayout imageLayout, Optional<RuntimeBuilder> runtimeBuilder,\n+            List<Launcher> launchers,  Map<String, String> extraAppImageFileData) implements Application {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Application.java","additions":251,"deletions":0,"binary":false,"changes":251,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Utility class to manage application launchers.\n+ * <p>\n+ * Use {@link #asList} to get application launchers as a list.\n+ * <p>\n+ * Use {@link #mainLauncher()} to get the main application launcher.\n+ * <p>\n+ * Use {@link #additionalLaunchers()} to get additional application launchers.\n+ * <p>\n+ * Use {@link #fromList} to convert the list of application launchers into {@link ApplicationLaunchers} instance.\n+ *\/\n+public record ApplicationLaunchers(Launcher mainLauncher, List<Launcher> additionalLaunchers) {\n+\n+    public ApplicationLaunchers {\n+        Objects.requireNonNull(mainLauncher);\n+        Objects.requireNonNull(additionalLaunchers);\n+    }\n+\n+    public ApplicationLaunchers(Launcher mainLauncher) {\n+        this(mainLauncher, List.of());\n+    }\n+\n+    public List<Launcher> asList() {\n+        return Optional.ofNullable(mainLauncher).map(v -> {\n+            return Stream.concat(Stream.of(v), additionalLaunchers.stream()).toList();\n+        }).orElseGet(List::of);\n+    }\n+\n+    public static Optional<ApplicationLaunchers> fromList(List<Launcher> launchers) {\n+        if (launchers == null || launchers.isEmpty()) {\n+            return Optional.empty();\n+        } else {\n+            return Optional.of(new ApplicationLaunchers(launchers.getFirst(),\n+                    launchers.subList(1, launchers.size())));\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLaunchers.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"},{"patch":"@@ -0,0 +1,198 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Application app image layout.\n+ * <p>\n+ * Application is comprised from application files and Java runtime.\n+ * <p>\n+ * Use {@link #build()} or {@link #buildFrom(ApplicationLayout)} methods to\n+ * configure and construct instances of this interface.\n+ *\/\n+public interface ApplicationLayout extends AppImageLayout, ApplicationLayoutMixin {\n+\n+    @Override\n+    default ApplicationLayout resolveAt(Path root) {\n+        return buildFrom(this).resolveAt(root).create();\n+    }\n+\n+    \/**\n+     * Creates an object implementing {@link ApplicationLayout} interface from\n+     * {@link AppImageLayout} and {@link ApplicationLayoutMixin} instances.\n+     *\n+     * @param appImage app image layout object\n+     * @param mixin application layout mixin for the app image layout\n+     * @return new object implementing {@link ApplicationLayout} interface\n+     *\/\n+    static ApplicationLayout create(AppImageLayout appImage, ApplicationLayoutMixin mixin) {\n+        return CompositeProxy.create(ApplicationLayout.class, appImage, mixin);\n+    }\n+\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    public static Builder buildFrom(ApplicationLayout appLayout) {\n+        return new Builder(appLayout);\n+    }\n+\n+    \/**\n+     * Builds {@link ApplicationLayout} instances.\n+     *\/\n+    final class Builder {\n+        private Builder() {\n+        }\n+\n+        private Builder(ApplicationLayout appLayout) {\n+            rootDirectory = appLayout.rootDirectory();\n+            launchersDirectory = appLayout.launchersDirectory();\n+            appDirectory = appLayout.appDirectory();\n+            runtimeDirectory = appLayout.runtimeDirectory();\n+            appModsDirectory = appLayout.appModsDirectory();\n+            destktopIntegrationDirectory = appLayout.destktopIntegrationDirectory();\n+            contentDirectory = appLayout.contentDirectory();\n+        }\n+\n+        public ApplicationLayout create() {\n+\n+            Objects.requireNonNull(rootDirectory);\n+            Objects.requireNonNull(runtimeDirectory);\n+            Objects.requireNonNull(launchersDirectory);\n+            Objects.requireNonNull(appDirectory);\n+            Objects.requireNonNull(appModsDirectory);\n+            Objects.requireNonNull(destktopIntegrationDirectory);\n+            Objects.requireNonNull(contentDirectory);\n+\n+            return ApplicationLayout.create(new AppImageLayout.Stub(\n+                    rootDirectory, runtimeDirectory), new ApplicationLayoutMixin.Stub(\n+                    launchersDirectory, appDirectory, appModsDirectory,\n+                    destktopIntegrationDirectory, contentDirectory));\n+        }\n+\n+        public Builder setAll(String path) {\n+            return setAll(Path.of(path));\n+        }\n+\n+        public Builder setAll(Path path) {\n+            rootDirectory(path);\n+            launchersDirectory(path);\n+            appDirectory(path);\n+            runtimeDirectory(path);\n+            appModsDirectory(path);\n+            destktopIntegrationDirectory(path);\n+            contentDirectory(path);\n+            return this;\n+        }\n+\n+        public Builder resolveAt(Path base) {\n+            rootDirectory(resolveNullablePath(base, rootDirectory));\n+            launchersDirectory(resolveNullablePath(base, launchersDirectory));\n+            appDirectory(resolveNullablePath(base, appDirectory));\n+            runtimeDirectory(resolveNullablePath(base, runtimeDirectory));\n+            appModsDirectory(resolveNullablePath(base, appModsDirectory));\n+            destktopIntegrationDirectory(resolveNullablePath(base, destktopIntegrationDirectory));\n+            contentDirectory(resolveNullablePath(base, contentDirectory));\n+            return this;\n+        }\n+\n+        public Builder rootDirectory(String v) {\n+            return rootDirectory(Path.of(v));\n+        }\n+\n+        public Builder rootDirectory(Path v) {\n+            rootDirectory = v;\n+            return this;\n+        }\n+\n+        public Builder launchersDirectory(String v) {\n+            return launchersDirectory(Path.of(v));\n+        }\n+\n+        public Builder launchersDirectory(Path v) {\n+            launchersDirectory = v;\n+            return this;\n+        }\n+\n+        public Builder appDirectory(String v) {\n+            return appDirectory(Path.of(v));\n+        }\n+\n+        public Builder appDirectory(Path v) {\n+            appDirectory = v;\n+            return this;\n+        }\n+\n+        public Builder runtimeDirectory(String v) {\n+            return runtimeDirectory(Path.of(v));\n+        }\n+\n+        public Builder runtimeDirectory(Path v) {\n+            runtimeDirectory = v;\n+            return this;\n+        }\n+\n+        public Builder appModsDirectory(String v) {\n+            return appModsDirectory(Path.of(v));\n+        }\n+\n+        public Builder appModsDirectory(Path v) {\n+            appModsDirectory = v;\n+            return this;\n+        }\n+\n+        public Builder destktopIntegrationDirectory(String v) {\n+            return destktopIntegrationDirectory(Path.of(v));\n+        }\n+\n+        public Builder destktopIntegrationDirectory(Path v) {\n+            destktopIntegrationDirectory = v;\n+            return this;\n+        }\n+\n+        public Builder contentDirectory(String v) {\n+            return contentDirectory(Path.of(v));\n+        }\n+\n+        public Builder contentDirectory(Path v) {\n+            contentDirectory = v;\n+            return this;\n+        }\n+\n+        private Path rootDirectory = Path.of(\"\");\n+        private Path launchersDirectory;\n+        private Path appDirectory;\n+        private Path runtimeDirectory;\n+        private Path appModsDirectory;\n+        private Path destktopIntegrationDirectory;\n+        private Path contentDirectory;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLayout.java","additions":198,"deletions":0,"binary":false,"changes":198,"status":"added"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * App image directory contents specific to application packaging.\n+ *\/\n+public interface ApplicationLayoutMixin {\n+\n+    \/**\n+     * Path to launchers directory.\n+     *\/\n+    Path launchersDirectory();\n+\n+    \/**\n+     * Path to application data directory.\n+     *\/\n+    Path appDirectory();\n+\n+    \/**\n+     * Path to directory with application's Java modules.\n+     *\/\n+    Path appModsDirectory();\n+\n+    \/**\n+     * Path to directory with application's desktop integration files.\n+     *\/\n+    Path destktopIntegrationDirectory();\n+\n+    \/**\n+     * Path to directory with additional application content.\n+     *\/\n+    Path contentDirectory();\n+\n+    \/**\n+     * Default implementation of {@link ApplicationLayoutMixin} interface.\n+     *\/\n+    record Stub(Path launchersDirectory, Path appDirectory, Path appModsDirectory, Path destktopIntegrationDirectory, Path contentDirectory) implements ApplicationLayoutMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationLayoutMixin.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+\n+\/**\n+ * Creates app image directory from the given {@link Application} object.\n+ *\n+ *  @ see PackageWriter\n+ *\/\n+@FunctionalInterface\n+public interface ApplicationWriter {\n+\n+    \/**\n+     * Creates app image directory from the given {@link Application} object in the given directory.\n+     *\n+     * @param app the source application\n+     * @param dst the directory where to create app image of the source application\n+     * @throws PackagerException if packaging error occurs\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    void write(Application app, Path dst) throws PackagerException, IOException;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ApplicationWriter.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -28,0 +28,21 @@\n+import jdk.jpackage.internal.util.LocalizedExceptionBuilder;\n+import jdk.jpackage.internal.util.StringBundle;\n+\n+\/**\n+ * Signals that error has occurred at configuration phase.\n+ * <p>\n+ * It contains an error message and an optional advice message on how to correct the error.\n+ * <p>\n+ * The preferred way to construct instances of this class is to use\n+ * {@link #build(StringBundle)}, or {@link #build(StringBundle, Throwable)},\n+ * or {@link #build(StringBundle, String, Object...)} methods.\n+ *\n+ * {@snippet :\n+ * StringBundle i18n = getStringBundle(); \/\/ Some way to obtain a string bundle with localized messages\n+ *\n+ * throw ConfigException.build(i18n)\n+ *         .message(\"error.no.name\")\n+ *         .advice(\"error.no.name.advice\")\n+ *         .create();\n+ * }\n+ *\/\n@@ -30,1 +51,1 @@\n-    final String advice;\n+    private final String advice;\n@@ -37,1 +58,1 @@\n-    public ConfigException(String msg, String advice, Exception cause) {\n+    public ConfigException(String msg, String advice, Throwable cause) {\n@@ -42,1 +63,1 @@\n-    public ConfigException(Exception cause) {\n+    public ConfigException(Throwable cause) {\n@@ -50,0 +71,56 @@\n+\n+    public static Builder build(StringBundle i18n) {\n+        return new Builder(i18n);\n+    }\n+\n+    public static Builder build(StringBundle i18n, String msgId, Object ... args) {\n+        return build(i18n).message(msgId, args);\n+    }\n+\n+    public static Builder build(StringBundle i18n, Throwable t) {\n+        return build(i18n).causeAndMessage(t);\n+    }\n+\n+    \/**\n+     * Builds {@link ConfigException} instances.\n+     *\/\n+    public static class Builder extends LocalizedExceptionBuilder<Builder> {\n+\n+        public Builder advice(String adviceId, Object ... args) {\n+            advice = formatString(adviceId, args);\n+            return this;\n+        }\n+\n+        private Builder(StringBundle i18n) {\n+            super(i18n);\n+        }\n+\n+        public ConfigException create() {\n+            return create(this::create);\n+        }\n+\n+        private ConfigException create(String msg, Throwable cause) {\n+            return new ConfigException(msg, advice, cause);\n+        }\n+\n+        private String advice;\n+    }\n+\n+    \/**\n+     * Throws the cause of the given {@link RuntimeException} exception\n+     * as {@link ConfigException} if the cause is of this type or re-throws the given\n+     * {@link RuntimeException} exception as-is otherwise.\n+     * <p>\n+     * Never return a value. It always throws some exception object.\n+     *\n+     * @param ex exception to re-throw\n+     * @return doesn't return value\n+     * @throws ConfigException\n+     *\/\n+    public static RuntimeException rethrowConfigException(RuntimeException ex) throws ConfigException {\n+        if (ex.getCause() instanceof ConfigException configEx) {\n+            throw configEx;\n+        } else {\n+            throw ex;\n+        }\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ConfigException.java","additions":80,"deletions":3,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * Custom application launcher icon.\n+ * <p>\n+ * Use {@link #create(Path)} method to create an instance of this type.\n+ *\/\n+public interface CustomLauncherIcon extends LauncherIcon {\n+\n+    \/**\n+     * Returns path to icon file.\n+     * @return path to icon file\n+     *\/\n+    Path path();\n+\n+    \/**\n+     * Returns the given icon as {@link CustomLauncherIcon} type or an empty {@link Optional} instance\n+     * if the given icon object is not an instance of {@link CustomLauncherIcon} type.\n+     *\n+     * @param icon application launcher icon object or <code>null<\/null>\n+     * @return the given icon as {@link CustomLauncherIcon} type or an empty {@link Optional} instance\n+     *\/\n+    public static Optional<CustomLauncherIcon> fromLauncherIcon(LauncherIcon icon) {\n+        if (icon instanceof CustomLauncherIcon customIcon) {\n+            return Optional.of(customIcon);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Creates object of type {@link CustomLauncherIcon} from the path to icon file.\n+     * @param path path to icon file\n+     * @return {@link CustomLauncherIcon} instance\n+     *\/\n+    public static CustomLauncherIcon create(Path path) {\n+        Objects.requireNonNull(path);\n+        return new Stub(path);\n+    }\n+\n+    \/**\n+     * Default implementation of {@link CustomLauncherIcon} type.\n+     *\/\n+    record Stub(Path path) implements CustomLauncherIcon {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/CustomLauncherIcon.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Optional;\n+\n+\/**\n+ * Default application launcher icon.\n+ * <p>\n+ * Default icon is either loaded from the resources of {@link jdk.jpackage\/} module or picked from the resource directory.\n+ * <p>\n+ * Use {@link #INSTANCE} field to get an instance of this type.\n+ *\/\n+public interface DefaultLauncherIcon extends LauncherIcon {\n+\n+    \/**\n+     * Returns the given icon as {@link DefaultLauncherIcon} type or an empty {@link Optional} instance\n+     * if the given icon object is not an instance of {@link DefaultLauncherIcon} type.\n+     *\n+     * @param icon application launcher icon object or <code>null<\/null>\n+     * @return the given icon as {@link DefaultLauncherIcon} type or an empty {@link Optional} instance\n+     *\/\n+    public static Optional<DefaultLauncherIcon> fromLauncherIcon(LauncherIcon icon) {\n+        if (icon instanceof DefaultLauncherIcon defaultIcon) {\n+            return Optional.of(defaultIcon);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Singleton.\n+     *\/\n+    public static DefaultLauncherIcon INSTANCE = new DefaultLauncherIcon() {};\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/DefaultLauncherIcon.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,74 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+\/**\n+ * File association.\n+ *\/\n+public interface FileAssociation {\n+\n+    \/**\n+     * Returns file association description if available or an empty {@link Optional} instance.\n+     * @return file association description\n+     *\/\n+    Optional<String> description();\n+\n+    \/**\n+     * Returns file association icon if available or an empty {@link Optional} instance.\n+     * @see {@link #hasIcon()}\n+     * @return file association icon\n+     *\/\n+    Optional<Path> icon();\n+\n+    \/**\n+     * Returns <code>true<\/code> if the file association has an icon.\n+     * @see {@link #icon()}\n+     * @return <code>true<\/code> if the file association has an icon\n+     *\/\n+    default boolean hasIcon() {\n+        return icon().isPresent();\n+    }\n+\n+    \/**\n+     * Returns file association MIME type. E.g.: <code>application\/foo<\/code>, <code>text\/plain<code>.\n+     * @return file association MIME type\n+     *\/\n+    String mimeType();\n+\n+    \/**\n+     * Returns file association extension. E.g.: <code>.txt<\/code>\n+     * @return file association extension\n+     *\/\n+    String extension();\n+\n+    \/**\n+     * Default implementation of {@link FileAssociation} interface\n+     *\/\n+    record Stub(Optional<String> description, Optional<Path> icon, String mimeType, String extension) implements FileAssociation {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/FileAssociation.java","additions":74,"deletions":0,"binary":false,"changes":74,"status":"added"},{"patch":"@@ -27,1 +27,0 @@\n-import java.text.MessageFormat;\n@@ -30,1 +29,0 @@\n-import java.util.ResourceBundle;\n@@ -32,0 +30,1 @@\n+import jdk.jpackage.internal.util.LocalizedExceptionBuilder;\n@@ -33,0 +32,1 @@\n+import jdk.jpackage.internal.util.StringBundle;\n@@ -41,6 +41,1 @@\n-        var str = getString(key);\n-        if (args.length != 0) {\n-            return MessageFormat.format(str, args);\n-        } else {\n-            return str;\n-        }\n+        return BUNDLE.format(key, args);\n@@ -49,1 +44,5 @@\n-    private static final ResourceBundle BUNDLE;\n+    static LocalizedExceptionBuilder<?> buildLocalizedException() {\n+        return LocalizedExceptionBuilder.buildLocalizedException(BUNDLE);\n+    }\n+\n+    private static final StringBundle BUNDLE;\n@@ -53,1 +52,1 @@\n-        BUNDLE = MultiResourceBundle.create(\n+        BUNDLE = StringBundle.fromResourceBundle(MultiResourceBundle.create(\n@@ -60,1 +59,1 @@\n-        );\n+        ));\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/I18N.java","additions":10,"deletions":11,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.io.InputStream;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+\n+\/**\n+ * Application launcher.\n+ *\n+ * @see Application#launchers()\n+ *\/\n+public interface Launcher {\n+\n+    \/**\n+     * Gets the name of this launcher.\n+     *\n+     * @return the name of this launcher\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Gets the name of the executable file of this launcher without file extension.\n+     *\n+     * @return the name of the executable file of this launcher\n+     *\/\n+    default String executableName() {\n+        return name();\n+    }\n+\n+    \/**\n+     * Gets extension of the executable file of this launcher if available or an\n+     * empty {@link Optional} instance otherwise.\n+     *\n+     * @return the extension of the executable file of this launcher\n+     *\/\n+    default Optional<String> executableSuffix() {\n+        return Optional.empty();\n+    }\n+\n+    \/**\n+     * Gets the full name of the executable file of this launcher. The full name\n+     * consists of the name and the extension.\n+     *\n+     * @return the full name of the executable file of this launcher\n+     *\/\n+    default String executableNameWithSuffix() {\n+        return executableName() + executableSuffix().orElse(\"\");\n+    }\n+\n+    \/**\n+     * Gets the startup information of this launcher if available or an empty\n+     * {@link Optional} instance otherwise.\n+     *\n+     * @apiNote Launchers from an external application image may not have startup\n+     *          information.\n+     * @return the startup information of this launcher\n+     *\/\n+    Optional<LauncherStartupInfo> startupInfo();\n+\n+    \/**\n+     * Gets the file associations of this launcher.\n+     *\n+     * @return the file associations of this launcher\n+     *\/\n+    List<FileAssociation> fileAssociations();\n+\n+    \/**\n+     * Returns <code>true<\/code> if this launcher should be installed as a service.\n+     *\n+     * @return <code>true<\/code> if this launcher should be installed as a service\n+     *\/\n+    boolean isService();\n+\n+    \/**\n+     * Gets the description of this launcher.\n+     *\n+     * @return the description of this launcher\n+     *\/\n+    String description();\n+\n+    \/**\n+     * Opens a stream with the template executable file for this launcher. Caller is\n+     * responsible for close the stream.\n+     *\n+     * @return a stream with the template executable file for this launcher\n+     *\/\n+    default InputStream executableResource() {\n+        return ResourceLocator.class.getResourceAsStream(\"jpackageapplauncher\");\n+    }\n+\n+    \/**\n+     * Gets the icon for this launcher or an empty {@link Optional} instance if the\n+     * launcher is requested to have no icon.\n+     *\n+     * @return the icon for this launcher\n+     * @see #hasIcon()\n+     * @see #hasDefaultIcon()\n+     * @see #hasCustomIcon()\n+     *\/\n+    Optional<LauncherIcon> icon();\n+\n+    \/**\n+     * Returns <code>true<\/code> if this launcher is requested to have an icon.\n+     *\n+     * @return <code>true<\/code> if this launcher is requested to have an icon\n+     * @see #icon()\n+     * @see #hasDefaultIcon()\n+     * @see #hasCustomIcon()\n+     *\/\n+    default boolean hasIcon() {\n+        return icon().isPresent();\n+    }\n+\n+    \/**\n+     * Returns <code>true<\/code> if this launcher has a default icon.\n+     *\n+     * @return <code>true<\/code> if this launcher has a default icon\n+     * @see DefaultLauncherIcon\n+     * @see #icon()\n+     * @see #hasIcon()\n+     * @see #hasCustomIcon()\n+     *\/\n+    default boolean hasDefaultIcon() {\n+        return icon().flatMap(DefaultLauncherIcon::fromLauncherIcon).isPresent();\n+    }\n+\n+    \/**\n+     * Returns <code>true<\/code> if this launcher has a custom icon.\n+     *\n+     * @return <code>true<\/code> if this launcher has a custom icon\n+     * @see CustomLauncherIcon\n+     * @see #icon()\n+     * @see #hasDefaultIcon()\n+     * @see #hasIcon()\n+     *\/\n+    default boolean hasCustomIcon() {\n+        return icon().flatMap(CustomLauncherIcon::fromLauncherIcon).isPresent();\n+    }\n+\n+    \/**\n+     * Gets key in the resource bundle of {@link jdk.jpackage\/} module referring to\n+     * the default launcher icon.\n+     *\n+     * @return the key in the resource bundle referring to the default launcher icon\n+     *\/\n+    String defaultIconResourceName();\n+\n+    \/**\n+     * Gets the additional properties for application launcher entries in the app\n+     * image (\".jpackage\") file.\n+     *\n+     * @return the additional properties for application launcher entries in\n+     *         \".jpackage\" file\n+     *\/\n+    Map<String, String> extraAppImageFileData();\n+\n+    \/**\n+     * Default implementation of {@link Launcher} interface.\n+     *\/\n+    record Stub(String name, Optional<LauncherStartupInfo> startupInfo, List<FileAssociation> fileAssociations,\n+            boolean isService, String description, Optional<LauncherIcon> icon, String defaultIconResourceName,\n+            Map<String, String> extraAppImageFileData) implements Launcher {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Launcher.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"},{"patch":"@@ -0,0 +1,31 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+\/**\n+ * Application launcher icon.\n+ *\/\n+public interface LauncherIcon {\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherIcon.java","additions":31,"deletions":0,"binary":false,"changes":31,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Application launcher startup configuration using non-modular jar file.\n+ * <p>\n+ * Use {@link #create} method to create objects implementing this interface.\n+ *\/\n+public interface LauncherJarStartupInfo extends LauncherStartupInfo,\n+        LauncherJarStartupInfoMixin {\n+\n+    \/**\n+     * Constructs {@link LauncherJarStartupInfo} instance from the given\n+     * {@link LauncherJarStartupInfo} and {@link LauncherJarStartupInfoMixin} instances.\n+     *\n+     * @param info the generic launcher startup information\n+     * @param mixin the supplementary launcher startup information\n+     * @return the proxy dispatching calls to the given objects\n+     *\/\n+    public static LauncherJarStartupInfo create(LauncherStartupInfo info,\n+            LauncherJarStartupInfoMixin mixin) {\n+        return CompositeProxy.create(LauncherJarStartupInfo.class, info, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherJarStartupInfo.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+\n+\/**\n+ * Details of Linux application launcher startup configuration using non-modular jar file.\n+ *\/\n+public interface LauncherJarStartupInfoMixin {\n+\n+    \/**\n+     * Gets the path to the input jar file.\n+     * @return the path to the input jar file\n+     *\/\n+    Path jarPath();\n+\n+    \/**\n+     * Returns <code>true<\/code> if the input jar file has <code>Main-Class<\/code> entry in the manifest.\n+     * @return <code>true<\/code> if the input jar file has <code>Main-Class<\/code> entry in the manifest\n+     *\/\n+    boolean isJarWithMainClass();\n+\n+    \/**\n+     * Default implementation of {@link LauncherJarStartupInfoMixin} interface.\n+     *\/\n+    record Stub(Path jarPath, boolean isJarWithMainClass) implements LauncherJarStartupInfoMixin {}\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherJarStartupInfoMixin.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Application launcher startup configuration using Java module.\n+ * <p>\n+ * Use {@link #create} method to create objects implementing this interface.\n+ *\/\n+public interface LauncherModularStartupInfo extends LauncherStartupInfo,\n+        LauncherModularStartupInfoMixin {\n+\n+    \/**\n+     * Constructs {@link LauncherModularStartupInfo} instance from the given\n+     * {@link LauncherJarStartupInfo} and {@link LauncherModularStartupInfoMixin} instances.\n+     *\n+     * @param info the generic launcher startup information\n+     * @param mixin the supplementary launcher startup information\n+     * @return the proxy dispatching calls to the given objects\n+     *\/\n+    public static LauncherModularStartupInfo create(LauncherStartupInfo info,\n+            LauncherModularStartupInfoMixin mixin) {\n+        return CompositeProxy.create(LauncherModularStartupInfo.class, info, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherModularStartupInfo.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+\/**\n+ * Details of application launcher startup configuration using Java module.\n+ *\/\n+public interface LauncherModularStartupInfoMixin {\n+\n+    \/**\n+     * Gets the main module name.\n+     * @return the main module name\n+     *\/\n+    String moduleName();\n+\n+    \/**\n+     * Gets the path to the input module location.\n+     * @return the path to the input module location\n+     *\/\n+    List<Path> modulePath();\n+\n+    \/**\n+     * Default implementation of {@link LauncherModularStartupInfoMixin} interface.\n+     *\/\n+    record Stub(String moduleName, List<Path> modulePath) implements LauncherModularStartupInfoMixin {\n+    }\n+\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherModularStartupInfoMixin.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,90 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.lang.constant.ClassDesc;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+\/**\n+ * Generic startup configuration of an application launcher.\n+ *\n+ * @see Launcher#startupInfo()\n+ *\/\n+public interface LauncherStartupInfo {\n+\n+    \/**\n+     * Gets the qualified name of the main class of this launcher startup configuration.\n+     * @return the qualified name of the main class of this launcher startup configuration\n+     *\/\n+    String qualifiedClassName();\n+\n+    \/**\n+     * Returns the simple name of the main class of this launcher startup configuration as given in the source code.\n+     * @return the simple name of the main class of this launcher startup configuration as given in the source code\n+     *\/\n+    default String simpleClassName() {\n+        return ClassDesc.of(qualifiedClassName()).displayName();\n+    }\n+\n+    \/**\n+     * Gets the package name of the main class of this launcher startup configuration.\n+     * @return the package name of the main class of this launcher startup configuration\n+     *\/\n+    default String packageName() {\n+        return ClassDesc.of(qualifiedClassName()).packageName();\n+    }\n+\n+    \/**\n+     * Gets JVM options of this launcher startup configuration.\n+     * @return the JVM options of this launcher startup configuration\n+     *\/\n+    List<String> javaOptions();\n+\n+    \/**\n+     * Gets the default parameters for the <code>main(String[] args)<\/code>\n+     * method of the main class of this launcher startup configuration.\n+     *\n+     * @return the default parameters for the <code>main(String[] args)<\/code>\n+     * method of the main class of this launcher startup configuration\n+     *\/\n+    List<String> defaultParameters();\n+\n+    \/**\n+     * Gets the files and directories that should be put on a classpath for\n+     * an application launcher this launcher startup configuration applies to.\n+     * @return the classpath of this launcher startup configuration\n+     *\/\n+    List<Path> classPath();\n+\n+    \/**\n+     * Default implementation of {@link LauncherStartupInfo} interface.\n+     *\/\n+    record Stub(String qualifiedClassName, List<String> javaOptions,\n+            List<String> defaultParameters, List<Path> classPath)\n+            implements LauncherStartupInfo {\n+\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherStartupInfo.java","additions":90,"deletions":0,"binary":false,"changes":90,"status":"added"},{"patch":"@@ -0,0 +1,331 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+\/**\n+ * Native application package.\n+ *\n+ * The interface specifies the source app image layout with two transformations:\n+ * package app image layout and installed app image layout.\n+ * <p>\n+ * Use {@link #appImageLayout()} or {@link #asApplicationLayout()} to get the\n+ * unresolved source app image layout.\n+ * <p>\n+ * Package app image layout is the source app image layout resolved at the\n+ * relative installation directory of the package. Additionally, to resolve the\n+ * source layout, some packages may transform the source layout.\n+ * <p>\n+ * Use {@link #packageLayout()} or {@link #asPackageApplicationLayout()} to get\n+ * the package app image layout.\n+ * <p>\n+ * Installed app image layout is the layout of the installed app image.\n+ * <p>\n+ * Use {@link #installedPackageLayout()} or\n+ * {@link #asInstalledPackageApplicationLayout()} to get the installed app image\n+ * layout.\n+ * <p>\n+ * The following table shows app image layouts of the application named \"Duke\"\n+ * on different platforms:\n+ * <table border=\"1\">\n+ * <tr>\n+ * <th><\/th>\n+ * <th>Source app image layout<\/th>\n+ * <th>Package app image layout<\/th>\n+ * <th>Installed app image layout<\/th>\n+ * <\/tr>\n+ * <tr>\n+ * <th>Windows<\/th>\n+ * <td>bin\/foo.exe app\/foo.jar<\/td>\n+ * <td>Duke\/bin\/foo.exe Duke\/app\/foo.jar<\/td>\n+ * <td>Duke\/bin\/foo.exe Duke\/app\/foo.jar<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th>Linux<\/th>\n+ * <td>bin\/foo lib\/app\/foo.jar<\/td>\n+ * <td>opt\/duke\/bin\/foo opt\/duke\/lib\/app\/foo.jar<\/td>\n+ * <td>\/opt\/duke\/bin\/foo \/opt\/duke\/lib\/app\/foo.jar<\/td>\n+ * <\/tr>\n+ * <tr>\n+ * <th>OSX<\/th>\n+ * <td>Contents\/MacOS\/foo Contents\/app\/foo.jar<\/td>\n+ * <td>Applications\/Duke.app\/Contents\/MacOS\/foo Applications\/Duke.app\/Contents\/app\/foo.jar<\/td>\n+ * <td>\/Applications\/Duke.app\/Contents\/MacOS\/foo \/Applications\/Duke.app\/Contents\/app\/foo.jar<\/td>\n+ * <\/tr>\n+ * <\/table>\n+ *\/\n+public interface Package {\n+\n+    \/**\n+     * Gets the application of this package.\n+     *\n+     * @return the application of this package\n+     *\/\n+    Application app();\n+\n+    \/**\n+     * Gets the type of this package.\n+     *\n+     * @return the type of this package\n+     *\/\n+    PackageType type();\n+\n+    \/**\n+     * Gets the type of this package as {@link StandardPackageType} type or an empty\n+     * {@link Optional} instance if the return value of {@link #type()} call is not\n+     * an instance of {@link StandardPackageType} type.\n+     *\n+     * @return the type of this package as {@link StandardPackageType} type\n+     *\/\n+    default Optional<StandardPackageType> asStandardPackageType() {\n+        if (type() instanceof StandardPackageType stdType) {\n+            return Optional.of(stdType);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the name of the native package of this package.\n+     * <p>\n+     * The value is a valid file system name and can be safely used to name\n+     * files\/directories in the file system.\n+     *\n+     * @return the name of the native package of this package\n+     *\/\n+    String packageName();\n+\n+    \/**\n+     * Gets the description of this package.\n+     * @return the description of this package\n+     *\/\n+    String description();\n+\n+    \/**\n+     * Gets the version of this package.\n+     * @return the version of this package\n+     *\/\n+    String version();\n+\n+    \/**\n+     * Gets the \"About\" URL of this package if available or an empty\n+     * {@link Optional} instance otherwise.\n+     *\n+     * @return the \"About\" URL of this package\n+     *\/\n+    Optional<String> aboutURL();\n+\n+    \/**\n+     * Gets the path to a license file of this package if available or an empty\n+     * {@link Optional} instance otherwise.\n+     *\n+     * @return the path to a license file of this package\n+     *\/\n+    Optional<Path> licenseFile();\n+\n+    \/**\n+     * Gets the path to a directory with the application app image of this package\n+     * if available or an empty {@link Optional} instance otherwise.\n+     *\n+     * @return the path to a directory with the application app image of this\n+     *         package\n+     *\/\n+    Optional<Path> predefinedAppImage();\n+\n+    \/**\n+     * Gets the unresolved source app image layout of the application of this package.\n+     *\n+     * @return the unresolved app image layout of the application of this package\n+     *\n+     * @see #packageLayout\n+     * @see #installedPackageLayout\n+     *\/\n+    default AppImageLayout appImageLayout() {\n+        return app().imageLayout();\n+    }\n+\n+    \/**\n+     * Returns the unresolved source app image layout of the application of this\n+     * package as {@link ApplicationLayout} type or an empty {@link Optional}\n+     * instance if the layout object is of incompatible type.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n+     * returns <code>true<\/code>.\n+     *\n+     * @return the unresolved source app image layout of the application of this\n+     *         package as {@link ApplicationLayout} type\n+     *\n+     * @see #appImageLayout\n+     *\/\n+    default Optional<ApplicationLayout> asApplicationLayout() {\n+        return app().asApplicationLayout();\n+    }\n+\n+    \/**\n+     * Gets the layout of the installed app image of the application resolved at the\n+     * relative installation directory of this package.\n+     *\n+     * @return the layout of the installed app image of the application resolved at\n+     *         the relative installation directory of this package\n+     *\n+     * @see #relativeInstallDir\n+     * @see #appImageLayout\n+     * @see #installedPackageLayout\n+     *\/\n+    default AppImageLayout packageLayout() {\n+        return appImageLayout().resolveAt(relativeInstallDir());\n+    }\n+\n+    \/**\n+     * Returns the layout of the installed app image of the application resolved at\n+     * the relative installation directory of this package as\n+     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n+     * layout object is of incompatible type.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n+     * returns <code>true<\/code>.\n+     *\n+     * @return the layout of the installed app image of the application resolved at\n+     *         the relative installation directory of this package as\n+     *         {@link ApplicationLayout} type\n+     *\n+     * @see #packageLayout\n+     *\/\n+    default Optional<ApplicationLayout> asPackageApplicationLayout() {\n+        if (packageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Gets the layout of the installed app image of this package.\n+     *\n+     * @return the layout of the installed app image of this package\n+     *\n+     * @see #appImageLayout\n+     * @see #packageLayout\n+     *\/\n+    default AppImageLayout installedPackageLayout() {\n+        return asStandardPackageType().map(stdType -> {\n+            switch (stdType) {\n+                case LINUX_DEB, LINUX_RPM, MAC_DMG, MAC_PKG -> {\n+                    return packageLayout().resolveAt(Path.of(\"\/\"));\n+                }\n+                case WIN_EXE, WIN_MSI -> {\n+                    return packageLayout();\n+                }\n+                default -> {\n+                    \/\/ Should never get here\n+                    throw new IllegalStateException();\n+                }\n+            }\n+        }).orElseThrow(UnsupportedOperationException::new);\n+    }\n+\n+    \/**\n+     * Returns the layout of the installed app image of this package as\n+     * {@link ApplicationLayout} type or an empty {@link Optional} instance if the\n+     * layout object is of incompatible type.\n+     * <p>\n+     * Returns an empty {@link Optional} instance if {@link #isRuntimeInstaller()}\n+     * returns <code>true<\/code>.\n+     *\n+     * @return the layout of the installed app image of this package as\n+     *         {@link ApplicationLayout} type\n+     *\n+     * @see #installedPackageLayout\n+     *\/\n+    default Optional<ApplicationLayout> asInstalledPackageApplicationLayout() {\n+        if (installedPackageLayout() instanceof ApplicationLayout layout) {\n+            return Optional.of(layout);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Get the name without an extension of the package file of this package.\n+     *\n+     * @return the name without an extension of the package file of this package\n+     *\/\n+    default String packageFileName() {\n+        return String.format(\"%s-%s\", packageName(), version());\n+    }\n+\n+    \/**\n+     * Gets the extension of the package file of this package if available or an\n+     * empty {@link Optional} instance otherwise.\n+     *\n+     * @return the extension of the package file of this package\n+     *\/\n+    default Optional<String> packageFileSuffix() {\n+        return asStandardPackageType().map(StandardPackageType::suffix);\n+    }\n+\n+    \/**\n+     * Gets the full name of the package file of this package. The full name\n+     * consists of the name and the extension.\n+     *\n+     * @return the full name of the package file of this package\n+     *\/\n+    default String packageFileNameWithSuffix() {\n+        return packageFileName() + packageFileSuffix().orElse(\"\");\n+    }\n+\n+    \/**\n+     * Returns <code>true<\/code> if the application of this package is Java runtime.\n+     *\n+     * @return <code>true<\/code> if the application of this package is Java runtime\n+     *\n+     * @see Application#isRuntime()\n+     *\/\n+    default boolean isRuntimeInstaller() {\n+        return app().isRuntime();\n+    }\n+\n+    \/**\n+     * Gets the relative path to the package installation directory of this package.\n+     *\n+     * On Windows it is relative to the program files directory\n+     * (<code>\"%ProgramFiles%\"<\/code>) and to the system root (<code>\"\/\"<\/code>) on\n+     * other platforms.\n+     *\n+     * @return the relative path to the package installation directory of this\n+     *         package\n+     *\/\n+    Path relativeInstallDir();\n+\n+    \/**\n+     * Default implementation of {@link Package} interface.\n+     *\/\n+    record Stub(Application app, PackageType type, String packageName, String description, String version,\n+            Optional<String> aboutURL, Optional<Path> licenseFile, Optional<Path> predefinedAppImage,\n+            Path relativeInstallDir) implements Package {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Package.java","additions":331,"deletions":0,"binary":false,"changes":331,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+\n+\/**\n+ * Generic package type. E.g.: application image, rpm, msi are all package types.\n+ *\n+ * @see jdk.jpackage.internal.model.Package\n+ *\/\n+public interface PackageType {}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/PackageType.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+\n+\/**\n+ * Creates native package from the given {@link jdk.jpackage.internal.model.Package} object.\n+ *\n+ * @ see ApplicationWriter\n+ *\/\n+@FunctionalInterface\n+public interface PackageWriter {\n+    \/**\n+     * Creates native package from the given {@link jdk.jpackage.internal.model.Package} object in the given directory.\n+     * @param pkg the source package\n+     * @param dst the directory where to create a native package\n+     * @throws PackagerException if packaging error occurs\n+     * @throws IOException if an I\/O error occurs\n+     *\/\n+    void write(Package pkg, Path dst) throws PackagerException, IOException;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/PackageWriter.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -25,1 +25,0 @@\n-\n@@ -28,2 +27,1 @@\n-import java.text.MessageFormat;\n-import java.util.ResourceBundle;\n+import jdk.jpackage.internal.util.StringBundle;\n@@ -31,0 +29,12 @@\n+\/**\n+ * Signals that error has occurred at packaging phase.\n+ * <p>\n+ * The preferred way to construct instances of this class is to use\n+ * {@link jdk.jpackage.internal.util.LocalizedExceptionBuilder#buildLocalizedException(StringBundle)} methods\n+ *\n+ * {@snippet :\n+ * StringBundle i18n = getStringBundle(); \/\/ Some way to obtain a string bundle with localized messages\n+ *\n+ * throw buildLocalizedException(i18n).message(\"error.no.name\").create();\n+ * }\n+ *\/\n@@ -32,0 +42,1 @@\n+\n@@ -33,2 +44,0 @@\n-    private static final ResourceBundle bundle = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.MainResources\");\n@@ -41,1 +50,1 @@\n-        super(bundle.getString(key), cause);\n+        super(I18N.getString(key), cause);\n@@ -45,1 +54,5 @@\n-        super(bundle.getString(key));\n+        super(I18N.getString(key));\n+    }\n+\n+    public PackagerException(String key, Object... arguments) {\n+        super(I18N.format(key, arguments));\n@@ -48,3 +61,2 @@\n-    public PackagerException(String key, String ... arguments) {\n-        super(MessageFormat.format(\n-                bundle.getString(key), (Object[]) arguments));\n+    public PackagerException(Throwable cause, String key, Object... arguments) {\n+        super(I18N.format(key, arguments), cause);\n@@ -53,4 +65,17 @@\n-    public PackagerException(\n-            Throwable cause, String key, String ... arguments) {\n-        super(MessageFormat.format(bundle.getString(key),\n-                (Object[]) arguments), cause);\n+    \/**\n+     * Throws the cause of the given {@link RuntimeException} exception\n+     * as {@link PackagerException} if the cause is of this type or re-throws the given\n+     * {@link RuntimeException} exception as-is otherwise.\n+     * <p>\n+     * Never return a value. It always throws some exception object.\n+     *\n+     * @param ex exception to re-throw\n+     * @return doesn't return value\n+     * @throws PackagerException\n+     *\/\n+    public static RuntimeException rethrowPackagerException(RuntimeException ex) throws PackagerException {\n+        if (ex.getCause() instanceof PackagerException pkgEx) {\n+            throw pkgEx;\n+        } else {\n+            throw ex;\n+        }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/PackagerException.java","additions":39,"deletions":14,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+\/**\n+ * Creates Java runtime.\n+ *\/\n+@FunctionalInterface\n+public interface RuntimeBuilder {\n+\n+    \/**\n+     * Creates Java runtime in the given app image.\n+     *\n+     * @implNote Java runtime should be created in the directory returned by\n+     *           {@link AppImageLayout#runtimeDirectory()} method called on the\n+     *           given app image layout object.\n+     *\n+     * @param appImageLayout the app image where to create Java runtime.\n+     * @throws PackagerException if packaging error occurs\n+     *\/\n+    void createRuntime(AppImageLayout appImageLayout) throws PackagerException;\n+\n+    \/**\n+     * Gets the default set of paths where to find Java modules.\n+     *\n+     * @return the default set of paths where to find Java modules\n+     *\/\n+    public static List<Path> getDefaultModulePath() {\n+        return List.of(\n+                Path.of(System.getProperty(\"java.home\"), \"jmods\").toAbsolutePath());\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeBuilder.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import static jdk.jpackage.internal.util.PathUtils.resolveNullablePath;\n+\n+import java.nio.file.Path;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+\/**\n+ * Java runtime app image layout.\n+ * <p>\n+ * Use {@link #DEFAULT} field to get the default runtime app image layout or\n+ * {@link #create(Path)} method to create custom runtime app image layout.\n+ *\/\n+public interface RuntimeLayout extends AppImageLayout {\n+\n+    @Override\n+    default RuntimeLayout resolveAt(Path root) {\n+        return create(new AppImageLayout.Stub(resolveNullablePath(root, rootDirectory()),\n+                resolveNullablePath(root, runtimeDirectory())));\n+    }\n+\n+    \/**\n+     * Creates Java runtime app image layout.\n+     * <p>\n+     * {@link #runtimeDirectory()} method\n+     * called on the created object will return the value of the\n+     * <code>runtimeDirectory<code> parameter. {@link #rootDirectory()} method\n+     * called on the created object will return <code>Path.of(\"\")<code> value.\n+     *\n+     * @param runtimeDirectory Java runtime directory\n+     * @return Java runtime app image layout\n+     *\/\n+    static RuntimeLayout create(Path runtimeDirectory) {\n+        return create(new AppImageLayout.Stub(Path.of(\"\"), runtimeDirectory));\n+    }\n+\n+    private static RuntimeLayout create(AppImageLayout layout) {\n+        return CompositeProxy.create(RuntimeLayout.class, layout);\n+    }\n+\n+    \/**\n+     * Singleton.\n+     * <p>\n+     * {@link #runtimeDirectory()} of the singleton returns empty string (\"\"), i.e.\n+     * the runtime directory is the same as the directory at which the layout is\n+     * resolved.\n+     *\/\n+    static final RuntimeLayout DEFAULT = create(Path.of(\"\"));\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/RuntimeLayout.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+\/**\n+ * Standard native package types.\n+ *\/\n+public enum StandardPackageType implements PackageType {\n+    WIN_MSI(\".msi\"),\n+    WIN_EXE(\".exe\"),\n+    LINUX_DEB(\".deb\"),\n+    LINUX_RPM(\".rpm\"),\n+    MAC_PKG(\".pkg\"),\n+    MAC_DMG(\".dmg\");\n+\n+    StandardPackageType(String suffix) {\n+        this.suffix = suffix;\n+    }\n+\n+    \/**\n+     * Gets file extension of this package type.\n+     * E.g.: <code>.msi<\/code>, <code>.dmg<\/code>, <code>.deb<\/code>.\n+     * @return file extension of this package type\n+     *\/\n+    public String suffix() {\n+        return suffix;\n+    }\n+\n+    private final String suffix;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/StandardPackageType.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * Classes and interfaces of the internal application packaging model.\n+ *\n+ * Primary entities are: {@link Application}, {@link jdk.jpackage.internal.model.Package}, and {@link Launcher}.\n+ *\n+ * @apiNote\n+ * All methods of all interfaces and classes in this package return non-null values unless stated otherwise.\n+ *\/\n+package jdk.jpackage.internal.model;\n\\ No newline at end of file\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/package-info.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,256 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.pipeline;\n+\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Spliterator;\n+import java.util.Spliterators;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+public final class BinaryMatrix {\n+\n+    BinaryMatrix(BinaryMatrix other) {\n+        rows = other.rows;\n+        columns = other.columns;\n+        size = other.size;\n+        values = (BitSet)other.values.clone();\n+    }\n+\n+    BinaryMatrix(int dimension) {\n+        this(dimension, dimension);\n+    }\n+\n+    BinaryMatrix(int rows, int columns) {\n+        this(rows, columns, null);\n+    }\n+\n+    BinaryMatrix(int rows, int columns, BitSet values) {\n+        this.rows = requirePositiveInteger(rows, \"Number of rows must be positive integer\");\n+        this.columns = requirePositiveInteger(columns, \"Number of columns must be positive integer\");\n+        size = rows * columns;\n+        this.values = Optional.ofNullable(values).orElseGet(() -> new BitSet(size));\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(columns, rows, values);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj)\n+            return true;\n+        if (obj == null)\n+            return false;\n+        if (getClass() != obj.getClass())\n+            return false;\n+        BinaryMatrix other = (BinaryMatrix) obj;\n+        return columns == other.columns && rows == other.rows && Objects.equals(values, other.values);\n+    }\n+\n+    interface Cursor {\n+        int row();\n+\n+        int column();\n+\n+        boolean value();\n+\n+        void value(boolean value);\n+    }\n+\n+    boolean isSquare() {\n+        return columns == rows;\n+    }\n+\n+    boolean isEmpty() {\n+        return values.isEmpty();\n+    }\n+\n+    int getRowCount() {\n+        return rows;\n+    }\n+\n+    int getColumnCount() {\n+        return columns;\n+    }\n+\n+    Iterator<Cursor> getRowIterator(int row) {\n+        return new RowIterator(row);\n+    }\n+\n+    Iterator<Cursor> getColumnIterator(int column) {\n+        return new ColumnIterator(column);\n+    }\n+\n+    Spliterator<Cursor> getRowSpliterator(int row) {\n+        return Spliterators.spliterator(getRowIterator(row), columns, Spliterator.ORDERED);\n+    }\n+\n+    Spliterator<Cursor> getColumnSpliterator(int column) {\n+        return Spliterators.spliterator(getColumnIterator(column), rows, Spliterator.ORDERED);\n+    }\n+\n+    Stream<Cursor> getRowAsStream(int row) {\n+        return toStream(getRowSpliterator(row));\n+    }\n+\n+    Stream<Cursor> getColumnAsStream(int column) {\n+        return toStream(getColumnSpliterator(column));\n+    }\n+\n+    boolean isSet(int row, int column) {\n+        return values.get(toIndex(row, column));\n+    }\n+\n+    void set(int row, int column, boolean value) {\n+        values.set(toIndex(row, column), value);\n+    }\n+\n+    void set(int row, int column) {\n+        set(row, column, true);\n+    }\n+\n+    void unset(int row, int column) {\n+        set(row, column, false);\n+    }\n+\n+    private int toIndex(int row, int column) {\n+        Objects.checkIndex(row, rows);\n+        Objects.checkIndex(column, columns);\n+        return row * columns + column;\n+    }\n+\n+    private static int requirePositiveInteger(int value, String message) {\n+        Objects.requireNonNull(message);\n+        if (value <= 0) {\n+            throw new IllegalArgumentException(message);\n+        }\n+        return value;\n+    }\n+\n+    private static Stream<Cursor> toStream(Spliterator<Cursor> split) {\n+        return StreamSupport.stream(split, false);\n+    }\n+\n+    \/**\n+     * Iterator over values of some selection.\n+     *\/\n+    private abstract class SelectionIterator implements Iterator<Cursor> {\n+        SelectionIterator(int index, int limit) {\n+            this.limit = Objects.checkIndex(limit, size + 1);\n+            this.index = Objects.checkIndex(index, limit);\n+        }\n+\n+        @Override\n+        public final boolean hasNext() {\n+            return index < limit;\n+        }\n+\n+        @Override\n+        public final Cursor next() {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+\n+            final var value = new CursorImpl(index, BinaryMatrix.this);\n+\n+            index = nextIndex(index);\n+\n+            return value;\n+        }\n+\n+        protected abstract int nextIndex(int idx);\n+\n+        private final int limit;\n+\n+        private int index;\n+    }\n+\n+    \/**\n+     * Iterator over values of some column.\n+     *\/\n+    private class ColumnIterator extends SelectionIterator {\n+        ColumnIterator(int column) {\n+            super(toIndex(0, column), size);\n+        }\n+\n+        @Override\n+        protected int nextIndex(int idx) {\n+            return idx + columns;\n+        }\n+    }\n+\n+    \/**\n+     * Iterator over values of some row.\n+     *\/\n+    private class RowIterator extends SelectionIterator {\n+        RowIterator(int row) {\n+            super(toIndex(row, 0), (row + 1) * columns);\n+        }\n+\n+        @Override\n+        protected int nextIndex(int idx) {\n+            return idx + 1;\n+        }\n+    }\n+\n+    private record CursorImpl(int index, BinaryMatrix matrix) implements Cursor {\n+\n+        CursorImpl {\n+            Objects.checkIndex(index, matrix.size);\n+        }\n+\n+        @Override\n+        public int row() {\n+            return index \/ matrix.columns;\n+        }\n+\n+        @Override\n+        public int column() {\n+            return index % matrix.columns;\n+        }\n+\n+        @Override\n+        public boolean value() {\n+            return matrix.values.get(index);\n+        }\n+\n+        @Override\n+        public void value(boolean value) {\n+            matrix.values.set(index, value);\n+        }\n+\n+    }\n+\n+    private final int rows;\n+    private final int columns;\n+    private final int size;\n+    private final BitSet values;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/pipeline\/BinaryMatrix.java","additions":256,"deletions":0,"binary":false,"changes":256,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.pipeline;\n+\n+import java.util.Objects;\n+\n+public record DirectedEdge<T>(T tail, T head) {\n+\n+    public DirectedEdge {\n+        Objects.requireNonNull(tail);\n+        Objects.requireNonNull(head);\n+\n+        if (tail.equals(head)) {\n+            throw new IllegalArgumentException(\"Loop edge\");\n+        }\n+    }\n+\n+    public T from() {\n+        return tail;\n+    }\n+\n+    public T to() {\n+        return head;\n+    }\n+\n+    public static <U> DirectedEdge<U> create(U tail, U head) {\n+        return new DirectedEdge<>(tail, head);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/pipeline\/DirectedEdge.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.pipeline;\n+\n+import static java.util.stream.Collectors.toCollection;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.TreeSet;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+\n+\/**\n+ * Fixed directed acyclic graph (DAG).\n+ * <p>\n+ * Number of nodes is fixed, links between nodes can be added or removed.\n+ *\n+ * @param edgeMatrix the edge matrix. [i,j] addresses an edge, where 'i' is the\n+ *                   index of the head node of the edge in the node container\n+ *                   and 'j' is the index of the tail node of the edge in the\n+ *                   node container\n+ * @param nodes      the node container\n+ *\/\n+public record FixedDAG<T>(BinaryMatrix edgeMatrix, Nodes<T> nodes) {\n+\n+    public static <U> Builder<U> build() {\n+        return new Builder<>();\n+    }\n+\n+    public static final class Builder<U> {\n+\n+        public Builder<U> addNode(U node) {\n+            Objects.requireNonNull(node);\n+            if (!nodes.contains(node)) {\n+                nodes.add(node);\n+            }\n+            return this;\n+        }\n+\n+        public Builder<U> addEdge(U tail, U head) {\n+            return addEdge(DirectedEdge.create(tail, head));\n+        }\n+\n+        public Builder<U> addEdge(DirectedEdge<U> edge) {\n+            addNode(edge.tail());\n+            addNode(edge.head());\n+            edges.add(edge);\n+            return this;\n+        }\n+\n+        public FixedDAG<U> create() {\n+            return FixedDAG.create(edges, nodes);\n+        }\n+\n+        private final List<U> nodes = new ArrayList<>();\n+        private final List<DirectedEdge<U>> edges = new ArrayList<>();\n+    }\n+\n+    public interface Nodes<U> extends Iterable<U> {\n+        int size();\n+        int indexOf(U node);\n+        U get(int index);\n+\n+        static <V> Nodes<V> ofList(List<V> list) {\n+            return new Nodes<>() {\n+\n+                @Override\n+                public int size() {\n+                    return list.size();\n+                }\n+\n+                @Override\n+                public int indexOf(V node) {\n+                    final int index = list.indexOf(node);\n+                    if (index < 0) {\n+                        throw new NoSuchElementException();\n+                    }\n+                    return index;\n+                }\n+\n+                @Override\n+                public V get(int index) {\n+                    return list.get(index);\n+                }\n+\n+                @Override\n+                public Iterator<V> iterator() {\n+                    return list.iterator();\n+                }\n+\n+            };\n+        }\n+    }\n+\n+    public FixedDAG {\n+        Objects.requireNonNull(nodes);\n+\n+        Objects.requireNonNull(edgeMatrix);\n+        if (!edgeMatrix.isSquare()) {\n+            throw new IllegalArgumentException(\"Matrix must be square\");\n+        }\n+\n+        if (edgeMatrix.getColumnCount() != nodes.size()) {\n+            throw new IllegalArgumentException(\"Matrix must have number of columns equal to the number of nodes\");\n+        }\n+    }\n+\n+    public static <U> FixedDAG<U> create(Collection<DirectedEdge<U>> edges, List<U> nodes) {\n+        return create(edges, Nodes.ofList(nodes));\n+    }\n+\n+    static <U> FixedDAG<U> create(Collection<DirectedEdge<U>> edges, Nodes<U> nodes) {\n+        final var edgeMatrix = new BinaryMatrix(nodes.size());\n+        for (final var edge : edges) {\n+            final int row = nodes.indexOf(edge.tail());\n+            final int column = nodes.indexOf(edge.head());\n+            edgeMatrix.set(row, column);\n+        }\n+\n+        if (isCyclic(edgeMatrix, null)) {\n+            throw new UnsupportedOperationException(\"Cyclic edges not allowed\");\n+        }\n+\n+        return new FixedDAG<>(edgeMatrix, nodes);\n+    }\n+\n+    \/**\n+     * Returns topologically ordered nodes of this graph.\n+     * <p>\n+     * For every directed edge (\"tail\", \"head\") from \"tail\" to \"head\", \"tail\" comes before \"head\".\n+     *\n+     * @return topologically ordered nodes of this graph\n+     *\/\n+    public List<T> topologicalSort() {\n+        final List<T> result = new ArrayList<>();\n+        isCyclic(edgeMatrix, index -> {\n+            result.add(nodes.get(index));\n+        });\n+        return result;\n+    }\n+\n+    public List<T> getAllHeadsOf(T node) {\n+        return getAllNodesOf(node, true);\n+    }\n+\n+    public List<T> getAllTailsOf(T node) {\n+        return getAllNodesOf(node, false);\n+    }\n+\n+    \/**\n+     * Gets the list of nodes that are heads of the edges sharing the same tail,\n+     * which is the given node.\n+     * <p>\n+     * The returned list is ordered by the indexes of the nodes in the node\n+     * container of this graph.\n+     *\n+     * @param node a node\n+     * @return the list of nodes that are heads of the edges sharing the same tail,\n+     *         which is the given node\n+     *\n+     * @see Nodes\n+     *\/\n+    public List<T> getHeadsOf(T node) {\n+        final int tail = nodes.indexOf(node);\n+        return getOutgoingEdges(tail, edgeMatrix).map(BinaryMatrix.Cursor::column).map(nodes::get).toList();\n+    }\n+\n+    \/**\n+     * Gets the list of nodes that are tails of the edges sharing the same head,\n+     * which is the given node.\n+     * <p>\n+     * The returned list is ordered by the indexes of the nodes in the node\n+     * container of this graph.\n+     *\n+     * @param node a node\n+     * @return the list of nodes that are tails of the edges sharing the same head,\n+     *         which is the given node\n+     *\n+     * @see Nodes\n+     *\/\n+    public List<T> getTailsOf(T node) {\n+        final int head = nodes.indexOf(node);\n+        return getIncomingEdges(head, edgeMatrix).map(BinaryMatrix.Cursor::row).map(nodes::get).toList();\n+    }\n+\n+    \/**\n+     * Get the list of nodes without incoming edges.\n+     * <p>\n+     * A node without incoming edges is a node that is not a head of any of the edges in the graph.\n+     * <p>\n+     * The returned list is ordered by the indexes of the nodes in the node\n+     * container of this graph.\n+     *\n+     * @return the list of nodes without incoming edges\n+     *\/\n+    public List<T> getNoIncomingEdges() {\n+        return getNoIncomingEdges(edgeMatrix).mapToObj(nodes::get).toList();\n+    }\n+\n+    \/**\n+     * Get the list of nodes without outgoing edges.\n+     * <p>\n+     * A node without outgoing edges is a node that is not a tail of any of the edges in the graph.\n+     * <p>\n+     * The returned list is ordered by the indexes of the nodes in the node\n+     * container of this graph.\n+     *\n+     * @return the list of nodes without outgoing edges\n+     *\/\n+    public List<T> getNoOutgoingEdges() {\n+        return getNoOutgoingEdges(edgeMatrix).mapToObj(nodes::get).toList();\n+    }\n+\n+    public void dumpToStdout() {\n+        dump(System.out::println);\n+    }\n+\n+    public void dump(Consumer<String> sink) {\n+        sink.accept(\"graph LR;\"); \/\/ mermaid \"left-to-right\" graph format\n+        StreamSupport.stream(nodes.spliterator(), true).map(tail -> {\n+            return getHeadsOf(tail).stream().map(head -> tail + \"-->\" + head);\n+        }).flatMap(x -> x).toList().forEach(sink);\n+    }\n+\n+    private List<T> getAllNodesOf(T node, boolean heads) {\n+        final Set<Integer> nodeIndexes = new TreeSet<>();\n+        traverseNodes(nodes.indexOf(node), edgeMatrix, heads, nodeIndex -> {\n+            return nodeIndexes.add(nodeIndex);\n+        });\n+\n+        return nodeIndexes.stream().map(nodes::get).toList();\n+    }\n+\n+    static void traverseNodes(int nodeIndex, BinaryMatrix edgeMatrix, boolean heads, Function<Integer, Boolean> nodeAccumulator) {\n+        final Stream<Integer> nodes;\n+        if (heads) {\n+            nodes = getOutgoingEdges(nodeIndex, edgeMatrix).map(BinaryMatrix.Cursor::column);\n+        } else {\n+            nodes = getIncomingEdges(nodeIndex, edgeMatrix).map(BinaryMatrix.Cursor::row);\n+        }\n+        nodes.forEach(n -> {\n+            if (nodeAccumulator.apply(n)) {\n+                traverseNodes(n, edgeMatrix, heads, nodeAccumulator);\n+            }\n+        });\n+    }\n+\n+    static Stream<BinaryMatrix.Cursor> getOutgoingEdges(int node, BinaryMatrix edgeMatrix) {\n+        return edgeMatrix.getRowAsStream(node).filter(BinaryMatrix.Cursor::value);\n+    }\n+\n+    static Stream<BinaryMatrix.Cursor> getIncomingEdges(int node, BinaryMatrix edgeMatrix) {\n+        return edgeMatrix.getColumnAsStream(node).filter(BinaryMatrix.Cursor::value);\n+    }\n+\n+    static IntStream getNoIncomingEdges(BinaryMatrix edgeMatrix) {\n+        return IntStream.range(0, edgeMatrix.getColumnCount()).filter(column -> {\n+            return getIncomingEdges(column, edgeMatrix).findAny().isEmpty();\n+        });\n+    }\n+\n+    static IntStream getNoOutgoingEdges(BinaryMatrix edgeMatrix) {\n+        return IntStream.range(0, edgeMatrix.getRowCount()).filter(row -> {\n+            return getOutgoingEdges(row, edgeMatrix).findAny().isEmpty();\n+        });\n+    }\n+\n+    private static boolean isCyclic(BinaryMatrix edgeMatrix, Consumer<Integer> topologicalOrderAccumulator) {\n+\n+        final var edgeMatrixCopy = new BinaryMatrix(edgeMatrix);\n+\n+        \/\/ Use Kahn's algorithm from https:\/\/en.wikipedia.org\/wiki\/Topological_sorting#Kahn's_algorithm to find cyclic edges\n+        \/\/ Variable names picked from the algorithm pseudo-code.\n+\n+        \/\/ Nodes with no incoming edges.\n+        List<Integer> S = getNoIncomingEdges(edgeMatrix).mapToObj(Integer::valueOf).collect(toCollection(ArrayList::new));\n+\n+        for (var i = 0; i != S.size(); ++i) {\n+            final var n = S.get(i);\n+\n+            if (topologicalOrderAccumulator != null) {\n+                topologicalOrderAccumulator.accept(n);\n+            }\n+\n+            for (final var e : getOutgoingEdges(n, edgeMatrixCopy).toList()) {\n+                e.value(false); \/\/ remove the edge\n+\n+                final var m = e.column();\n+\n+                if (getIncomingEdges(m, edgeMatrixCopy).findAny().isEmpty()) {\n+                    \/\/ No incoming edges to 'm' node.\n+                    if (topologicalOrderAccumulator != null) {\n+                        if (i > 0) {\n+                            S = S.subList(i, S.size());\n+                            i = 0;\n+                        }\n+\n+                        final var insertAtIndex = Math.abs((Collections.binarySearch(S, m) + 1));\n+                        if (insertAtIndex == 0) {\n+                            if (i == -1) {\n+                                S.add(0, m);\n+                            } else {\n+                                S.set(0, m);\n+                                i = -1;\n+                            }\n+                        } else {\n+                            S.add(insertAtIndex, m);\n+                        }\n+                    } else if (i >= 0) {\n+                        S.set(i, m);\n+                        i--;\n+                    } else {\n+                        S.add(m);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return !edgeMatrixCopy.isEmpty();\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/pipeline\/FixedDAG.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -0,0 +1,211 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.pipeline;\n+\n+import static jdk.jpackage.internal.pipeline.FixedDAG.getIncomingEdges;\n+import static jdk.jpackage.internal.pipeline.FixedDAG.getNoOutgoingEdges;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionException;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+\n+public final class TaskPipelineBuilder {\n+\n+    public final class TaskBuilder extends TaskSpecBuilder<Callable<Void>> {\n+\n+        TaskBuilder(Callable<Void> task) {\n+            super(task);\n+        }\n+\n+        @Override\n+        public TaskBuilder addDependent(Callable<Void> v) {\n+            super.addDependent(v);\n+            return this;\n+        }\n+\n+        @Override\n+        public TaskBuilder addDependency(Callable<Void> v) {\n+            super.addDependency(v);\n+            return this;\n+        }\n+\n+        @Override\n+        public TaskBuilder addDependencies(Collection<? extends Callable<Void>> v) {\n+            super.addDependencies(v);\n+            return this;\n+        }\n+\n+        @Override\n+        public TaskBuilder addDependents(Collection<? extends Callable<Void>> v) {\n+            super.addDependents(v);\n+            return this;\n+        }\n+\n+        public TaskPipelineBuilder add() {\n+            final var links = createLinks();\n+            if (links.isEmpty()) {\n+                return addTask(task());\n+            } else {\n+                links.forEach(TaskPipelineBuilder.this::linkTasks);\n+                return TaskPipelineBuilder.this;\n+            }\n+        }\n+    }\n+\n+    public TaskBuilder task(Callable<Void> task) {\n+        return new TaskBuilder(task);\n+    }\n+\n+    public TaskPipelineBuilder executor(Executor v) {\n+        executor = v;\n+        return this;\n+    }\n+\n+    public TaskPipelineBuilder sequentialExecutor() {\n+        executor = null;\n+        return this;\n+    }\n+\n+    public TaskPipelineBuilder addTask(Callable<Void> task) {\n+        taskGraphBuilder.addNode(task);\n+        return this;\n+    }\n+\n+    public TaskPipelineBuilder linkTasks(Callable<Void> tail, Callable<Void> head) {\n+        return linkTasks(DirectedEdge.create(tail, head));\n+    }\n+\n+    public TaskPipelineBuilder linkTasks(DirectedEdge<Callable<Void>> edge) {\n+        taskGraphBuilder.addEdge(edge);\n+        return this;\n+    }\n+\n+    public Callable<Void> create() {\n+        final var taskGraph = taskGraphBuilder.create();\n+        if (executor == null) {\n+            final var tasks = taskGraph.topologicalSort();\n+            return new SequentialWrapperTask(tasks);\n+        } else {\n+            return new ParallelWrapperTask(taskGraph, executor);\n+        }\n+    }\n+\n+    private record SequentialWrapperTask(List<Callable<Void>> tasks) implements Callable<Void> {\n+\n+        SequentialWrapperTask {\n+            Objects.requireNonNull(tasks);\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+            for (final var task : tasks) {\n+                task.call();\n+            }\n+            return null;\n+        }\n+\n+    }\n+\n+    private record ParallelWrapperTask(FixedDAG<Callable<Void>> taskGraph, Executor executor) implements Callable<Void> {\n+\n+        ParallelWrapperTask {\n+            Objects.requireNonNull(taskGraph);\n+            Objects.requireNonNull(executor);\n+        }\n+\n+        @Override\n+        public Void call() throws Exception {\n+\n+            final var taskFutures = new CompletableFuture<?>[taskGraph.nodes().size()];\n+\n+            \/\/ Schedule tasks in the order they should be executed: dependencies before dependents.\n+            for (final var task : taskGraph.topologicalSort()) {\n+                final var taskIndex = taskGraph.nodes().indexOf(task);\n+\n+                final var dependencyTaskFutures = getIncomingEdges(taskIndex, taskGraph.edgeMatrix())\n+                        .map(BinaryMatrix.Cursor::row)\n+                        .map(dependencyTaskIndex -> {\n+                            return taskFutures[dependencyTaskIndex];\n+                        }).toArray(CompletableFuture<?>[]::new);\n+\n+                final CompletableFuture<?> f;\n+                if (dependencyTaskFutures.length == 0) {\n+                    f = CompletableFuture.runAsync(toRunnable(task), executor);\n+                } else {\n+                    f = CompletableFuture.allOf(dependencyTaskFutures).thenRun(toRunnable(task));\n+                }\n+\n+                taskFutures[taskIndex] = f;\n+            }\n+\n+            final var rootFutures = getNoOutgoingEdges(taskGraph.edgeMatrix()).mapToObj(taskIndex -> {\n+                return taskFutures[taskIndex];\n+            }).toArray(CompletableFuture[]::new);\n+\n+            final CompletableFuture <?> rootFuture;\n+            if (rootFutures.length == 1) {\n+                rootFuture = rootFutures[0];\n+            } else {\n+                rootFuture = CompletableFuture.allOf(rootFutures);\n+            }\n+\n+            try {\n+                rootFuture.get();\n+            } catch (ExecutionException ee) {\n+                if (ee.getCause() instanceof Exception ex) {\n+                    throw ex;\n+                } else {\n+                    throw ee;\n+                }\n+            }\n+\n+            return null;\n+        }\n+\n+        private static Runnable toRunnable(Callable<Void> callable) {\n+            return () -> {\n+                try {\n+                    callable.call();\n+                } catch (Error er) {\n+                    throw er;\n+                } catch (RuntimeException ex) {\n+                    throw ex;\n+                } catch (Throwable t) {\n+                    throw new CompletionException(t);\n+                }\n+            };\n+        }\n+\n+    }\n+\n+    private final FixedDAG.Builder<Callable<Void>> taskGraphBuilder = new FixedDAG.Builder<>();\n+    private Executor executor;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/pipeline\/TaskPipelineBuilder.java","additions":211,"deletions":0,"binary":false,"changes":211,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.pipeline;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+public class TaskSpecBuilder<T> {\n+\n+    public TaskSpecBuilder(T task) {\n+        this.task = Objects.requireNonNull(task);\n+    }\n+\n+    public T task() {\n+        return task;\n+    }\n+\n+    public TaskSpecBuilder<T> addDependent(T v) {\n+        Objects.requireNonNull(v);\n+        dependents.add(v);\n+        return this;\n+    }\n+\n+    public TaskSpecBuilder<T> addDependency(T v) {\n+        Objects.requireNonNull(v);\n+        dependencies.add(v);\n+        return this;\n+    }\n+\n+    public TaskSpecBuilder<T> addDependencies(Collection<? extends T> v) {\n+        Objects.requireNonNull(v);\n+        v.forEach(Objects::requireNonNull);\n+        dependencies.addAll(v);\n+        return this;\n+    }\n+\n+    public TaskSpecBuilder<T> addDependents(Collection<? extends T> v) {\n+        Objects.requireNonNull(v);\n+        v.forEach(Objects::requireNonNull);\n+        dependents.addAll(v);\n+        return this;\n+    }\n+\n+    public List<DirectedEdge<T>> createLinks() {\n+        List<DirectedEdge<T>> edges = new ArrayList<>();\n+\n+        for (var dependency : dependencies) {\n+            edges.add(DirectedEdge.create(dependency, task));\n+        }\n+\n+        for (var dependent : dependents) {\n+            edges.add(DirectedEdge.create(task, dependent));\n+        }\n+\n+        return edges;\n+    }\n+\n+    private final Set<T> dependencies = new LinkedHashSet<>();\n+    private final Set<T> dependents = new LinkedHashSet<>();\n+    private final T task;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/pipeline\/TaskSpecBuilder.java","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -76,0 +76,1 @@\n+error.no.name.advice=Specify name with --name\n@@ -80,1 +81,3 @@\n-error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\"\n+error.invalid-app-image=Error: app-image dir \"{0}\" generated by another jpackage version or malformed \"{1}\" file\n+\n+error.invalid-install-dir=Invalid installation directory \"{0}\"\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/resources\/MainResources.properties","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.Collection;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * This class consists exclusively of static methods that operate on or return collections.\n+ *\/\n+public final class CollectionUtils {\n+\n+    \/**\n+     * Casts the given collection to the requested type.\n+     *\n+     * @param <T> the type of elements in this output collection\n+     * @param <B> the type of elements in this input collection\n+     * @param <C> the output collection type\n+     * @param v the input collection. Null is permitted.\n+     * @return the input collection cast to the requested type\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends B, B, C extends Collection<T>> C toCollection(Collection<B> v) {\n+        Collection<?> tmp = v;\n+        return (C) tmp;\n+    }\n+\n+    \/**\n+     * Casts the given collection to the requested upper bounded wildcard (UBW) type.\n+     *\n+     * @param <T> the type of elements in this output collection\n+     * @param <B> the upper bound type of elements in this input collection\n+     * @param <C> the output collection type\n+     * @param v the input collection. Null is permitted.\n+     * @return the input collection cast to the requested type\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public static <T extends B, B, C extends Collection<T>> C toCollectionUBW(Collection<? extends B> v) {\n+        Collection<?> tmp = v;\n+        return (C) tmp;\n+    }\n+\n+    \/**\n+     * Converts the given collection to {@link Set}.\n+     *\n+     * @param <T> the type of elements in this output collection\n+     * @param v   the input collection. Null is permitted.\n+     * @return the input collection if it is of type {@link Set} or a new\n+     *         {@link Set} instance created from the input collection\n+     *\/\n+    public static <T> Set<T> toSet(Collection<T> col) {\n+        if (col instanceof Set<T> set) {\n+            return set;\n+        } else {\n+            return Optional.ofNullable(col).map(Collection::stream).orElseGet(Stream::of).collect(Collectors.toSet());\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CollectionUtils.java","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -0,0 +1,532 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.BinaryOperator;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * Dynamic proxy dispatching method calls to multiple objects. It is aimed at\n+ * creating objects from mixins. The class provides functionality similar to\n+ * that of <code>net.sf.cglib.proxy.Mixin<\/code> class from the cglib library.\n+ *\n+ * Sample usage:\n+ * {@snippet :\n+ * interface Sailboat {\n+ *     default void trimSails() {\n+ *     }\n+ * }\n+ *\n+ * interface WithMain {\n+ *     void trimMain();\n+ * }\n+ *\n+ * interface WithJib {\n+ *     void trimJib();\n+ * }\n+ *\n+ * interface Sloop extends Sailboat, WithMain, WithJib {\n+ *     @Override\n+ *     public default void trimSails() {\n+ *         System.out.println(\"On the sloop:\");\n+ *         trimMain();\n+ *         trimJib();\n+ *     }\n+ * }\n+ *\n+ * interface Catboat extends Sailboat, WithMain {\n+ *     @Override\n+ *     public default void trimSails() {\n+ *         System.out.println(\"On the catboat:\");\n+ *         trimMain();\n+ *     }\n+ * }\n+ *\n+ * final var withMain = new WithMain() {\n+ *     @Override\n+ *     public void trimMain() {\n+ *         System.out.println(\"  trim the main\");\n+ *     }\n+ * };\n+ *\n+ * final var withJib = new WithJib() {\n+ *     @Override\n+ *     public void trimJib() {\n+ *         System.out.println(\"  trim the jib\");\n+ *     }\n+ * };\n+ *\n+ * Sloop sloop = CompositeProxy.create(Sloop.class, new Sailboat() {\n+ * }, withMain, withJib);\n+ *\n+ * Catboat catboat = CompositeProxy.create(Catboat.class, new Sailboat() {\n+ * }, withMain);\n+ *\n+ * sloop.trimSails();\n+ * catboat.trimSails();\n+ * }\n+ *\n+ * Output:\n+ *\n+ * <pre>\n+ * On the sloop:\n+ *   trim the main\n+ *   trim the jib\n+ * On the cat:\n+ *   trim the main\n+ * <\/pre>\n+ *\n+ * @see Proxy\n+ *\/\n+public final class CompositeProxy {\n+\n+    \/**\n+     * Builder of {@link CompositeProxy} instances.\n+     *\/\n+    public static final class Builder {\n+\n+        \/**\n+         * Returns a proxy instance for the specified interface that dispatches method\n+         * invocations to the specified handlers. Uses previously configured invocation\n+         * tunnel and conflict resolver objects with the created proxy object.\n+         *\n+         * @param <T>           the interface type\n+         * @param interfaceType the interface class composite proxy instance should\n+         *                      implement\n+         * @param slices        handlers for the method calls of the interface\n+         * @return a new instance of {@link Proxy} implementing the given interface and\n+         *         dispatching the interface method invocations to the given handlers\n+         *\/\n+        public <T> T create(Class<T> interfaceType, Object... slices) {\n+            return CompositeProxy.createCompositeProxy(interfaceType, conflictResolver, invokeTunnel, slices);\n+        }\n+\n+        \/**\n+         * Sets the method dispatch conflict resolver for this builder. The conflict\n+         * resolver is used by composite proxy to select a method call handler from\n+         * multiple candidates.\n+         *\n+         * @param v the conflict resolver for this builder or <code>null<\/code> if the\n+         *          default conflict resolver should be used\n+         * @return this\n+         *\/\n+        public Builder conflictResolver(BinaryOperator<Method> v) {\n+            conflictResolver = v;\n+            return this;\n+        }\n+\n+        \/**\n+         * Sets the invocation tunnel for this builder.\n+         *\n+         * @param v the invocation tunnel for this builder or <code>null<\/code> if no\n+         *          invocation tunnel should be used\n+         * @return this\n+         *\/\n+        public Builder invokeTunnel(InvokeTunnel v) {\n+            invokeTunnel = v;\n+            return this;\n+        }\n+\n+        private Builder() {}\n+\n+        private BinaryOperator<Method> conflictResolver = STANDARD_CONFLICT_RESOLVER;\n+        private InvokeTunnel invokeTunnel;\n+    }\n+\n+    \/**\n+     * Invocation tunnel. Must be used when building a composite proxy from objects\n+     * that implement package-private interfaces to prevent\n+     * {@link IllegalAccessException} exceptions being thrown by {@link Proxy}\n+     * instances. Must be implemented by classes from packages with package-private\n+     * interfaces used with {@link CompositeProxy} class.\n+     *\n+     * Assumed implementation:\n+     * {@snippet :\n+     *\n+     * package org.foo;\n+     *\n+     * import java.lang.reflect.InvocationHandler;\n+     * import java.lang.reflect.Method;\n+     * import jdk.jpackage.internal.util.CompositeProxy;\n+     *\n+     * final class CompositeProxyTunnel implements CompositeProxy.InvokeTunnel {\n+     *\n+     *     @Override\n+     *     public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\n+     *         return method.invoke(obj, args);\n+     *     }\n+     *\n+     *     @Override\n+     *     public Object invokeDefault(Object proxy, Method method, Object[] args) throws Throwable {\n+     *         return InvocationHandler.invokeDefault(proxy, method, args);\n+     *     }\n+     *\n+     *     static final CompositeProxyTunnel INSTANCE = new CompositeProxyTunnel();\n+     * }\n+     * }\n+     *\/\n+    public interface InvokeTunnel {\n+        \/**\n+         * Processes a method invocation on an object of composite proxy and returns the result.\n+         *\n+         * @implNote Implementation should call the given method on the given object\n+         *           with the given arguments and return the result of the call.\n+         * @param obj    the object on which to invoke the method\n+         * @param method the method to invoke\n+         * @param args   the arguments to use in the method call\n+         * @return the result of the method call\n+         * @throws Throwable if the method throws\n+         *\/\n+        Object invoke(Object obj, Method method, Object[] args) throws Throwable;\n+\n+        \/**\n+         * Processes a default interface method invocation on a composite proxy and\n+         * returns the result.\n+         *\n+         * @implNote Implementation should call\n+         *           {@link InvocationHandler#invokeDefault(Object, Method, Object...)}\n+         *           method on the given proxy object with the given arguments and\n+         *           return the result of the call.\n+         * @param proxy  the <code>proxy<\/code> parameter for\n+         *               {@link InvocationHandler#invokeDefault(Object, Method, Object...)}\n+         *               call\n+         * @param method the <code>method<\/code> parameter for\n+         *               {@link InvocationHandler#invokeDefault(Object, Method, Object...)}\n+         *               call\n+         * @param args   the <code>args<\/code> parameter for\n+         *               {@link InvocationHandler#invokeDefault(Object, Method, Object...)}\n+         *               call\n+         * @return the result of the\n+         *         {@link InvocationHandler#invokeDefault(Object, Method, Object...)}\n+         *         call\n+         * @throws Throwable if the {@link InvocationHandler#invokeDefault(Object, Method, Object...)} call throws\n+         *\/\n+        Object invokeDefault(Object proxy, Method method, Object[] args) throws Throwable;\n+    }\n+\n+    \/**\n+     * Creates a new proxy builder.\n+     * @return a new proxy builder\n+     *\/\n+    public static Builder build() {\n+        return new Builder();\n+    }\n+\n+    \/**\n+     * Shortcut for\n+     * <code>CompositeProxy.build().create(interfaceType, slices)<\/code>.\n+     *\n+     * @see Builder#create(Class, Object...)\n+     *\/\n+    public static <T> T create(Class<T> interfaceType, Object... slices) {\n+        return build().create(interfaceType, slices);\n+    }\n+\n+    private CompositeProxy() {\n+    }\n+\n+    private static <T> T createCompositeProxy(Class<T> interfaceType, BinaryOperator<Method> conflictResolver,\n+            InvokeTunnel invokeTunnel, Object... slices) {\n+\n+        validateTypeIsInterface(interfaceType);\n+\n+        final var interfaces = interfaceType.getInterfaces();\n+        List.of(interfaces).forEach(CompositeProxy::validateTypeIsInterface);\n+\n+        if (interfaces.length != slices.length) {\n+            throw new IllegalArgumentException(\n+                    String.format(\"type %s must extend %d interfaces\", interfaceType.getName(), slices.length));\n+        }\n+\n+        final Map<Class<?>, Object> interfaceDispatch = createInterfaceDispatch(interfaces, slices);\n+\n+        final Map<Method, Handler> methodDispatch = getProxyableMethods(interfaceType).map(method -> {\n+            var handler = createHandler(interfaceType, method, interfaceDispatch, conflictResolver, invokeTunnel);\n+            if (handler != null) {\n+                return Map.entry(method, handler);\n+            } else {\n+                return null;\n+            }\n+        }).filter(Objects::nonNull).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+        @SuppressWarnings(\"unchecked\")\n+        T proxy = (T) Proxy.newProxyInstance(interfaceType.getClassLoader(), new Class<?>[] { interfaceType },\n+                new CompositeProxyInvocationHandler(methodDispatch));\n+\n+        return proxy;\n+    }\n+\n+    private static Map<Class<?>, Object> createInterfaceDispatch(Class<?>[] interfaces, Object[] slices) {\n+\n+        final Map<Class<?>, Object> interfaceDispatch = Stream.of(interfaces).collect(toMap(x -> x, iface -> {\n+            return Stream.of(slices).filter(obj -> {\n+                return Set.of(obj.getClass().getInterfaces()).contains(iface);\n+            }).reduce((a, b) -> {\n+                throw new IllegalArgumentException(\n+                        String.format(\"both [%s] and [%s] slices implement %s\", a, b, iface));\n+            }).orElseThrow(() -> createInterfaceNotImplementedException(List.of(iface)));\n+        }));\n+\n+        if (interfaceDispatch.size() != interfaces.length) {\n+            final List<Class<?>> missingInterfaces = new ArrayList<>(Set.of(interfaces));\n+            missingInterfaces.removeAll(interfaceDispatch.keySet());\n+            throw createInterfaceNotImplementedException(missingInterfaces);\n+        }\n+\n+        return Stream.of(interfaces).flatMap(iface -> {\n+            return unfoldInterface(iface).map(unfoldedIface -> {\n+                return Map.entry(unfoldedIface, interfaceDispatch.get(iface));\n+            });\n+        }).collect(toMap(Map.Entry::getKey, Map.Entry::getValue));\n+    }\n+\n+    private static Stream<Class<?>> unfoldInterface(Class<?> interfaceType) {\n+        return Stream.concat(Stream.of(interfaceType),\n+                Stream.of(interfaceType.getInterfaces()).flatMap(CompositeProxy::unfoldInterface));\n+    }\n+\n+    private static IllegalArgumentException createInterfaceNotImplementedException(\n+            Collection<Class<?>> missingInterfaces) {\n+        return new IllegalArgumentException(String.format(\"none of the slices implement %s\", missingInterfaces));\n+    }\n+\n+    private static void validateTypeIsInterface(Class<?> type) {\n+        if (!type.isInterface()) {\n+            throw new IllegalArgumentException(String.format(\"type %s must be an interface\", type.getName()));\n+        }\n+    }\n+\n+    private static Handler createHandler(Class<?> interfaceType, Method method, Map<Class<?>, Object> interfaceDispatch,\n+            BinaryOperator<Method> conflictResolver, InvokeTunnel invokeTunnel) {\n+\n+        final var methodDeclaringClass = method.getDeclaringClass();\n+\n+        if (!methodDeclaringClass.equals(interfaceType)) {\n+            \/\/ The method is declared in one of the superinterfaces.\n+            final var slice = interfaceDispatch.get(methodDeclaringClass);\n+\n+            if (isInvokeDefault(method, slice)) {\n+                return createHandlerForDefaultMethod(method, invokeTunnel);\n+            } else {\n+                return createHandlerForMethod(slice, method, invokeTunnel);\n+            }\n+        } else if (method.isDefault()) {\n+            return createHandlerForDefaultMethod(method, invokeTunnel);\n+        } else {\n+            \/\/ Find a slice handling the method.\n+            var handler = interfaceDispatch.entrySet().stream().map(e -> {\n+                try {\n+                    Class<?> iface = e.getKey();\n+                    Object slice = e.getValue();\n+                    return createHandlerForMethod(slice, iface.getMethod(method.getName(), method.getParameterTypes()),\n+                            invokeTunnel);\n+                } catch (NoSuchMethodException ex) {\n+                    return null;\n+                }\n+            }).filter(Objects::nonNull).reduce(new ConflictResolverAdapter(conflictResolver)).orElseThrow(() -> {\n+                return new IllegalArgumentException(String.format(\"none of the slices can handle %s\", method));\n+            });\n+\n+            return handler;\n+        }\n+    }\n+\n+    private static Stream<Method> getProxyableMethods(Class<?> interfaceType) {\n+        return Stream.of(interfaceType.getMethods()).filter(method -> !Modifier.isStatic(method.getModifiers()));\n+    }\n+\n+    private static boolean isInvokeDefault(Method method, Object slice) {\n+        if (!method.isDefault()) {\n+            return false;\n+        }\n+\n+        \/\/ The \"method\" is default.\n+        \/\/ See if is overridden by any non-abstract method in the \"slice\".\n+        \/\/ If it is, InvocationHandler.invokeDefault() should not be used to call it.\n+\n+        final var sliceClass = slice.getClass();\n+\n+        final var methodOverriden = Stream.of(sliceClass.getMethods()).filter(Predicate.not(Predicate.isEqual(method)))\n+                .filter(sliceMethod -> !Modifier.isAbstract(sliceMethod.getModifiers()))\n+                .anyMatch(sliceMethod -> signatureEquals(sliceMethod, method));\n+\n+        return !methodOverriden;\n+    }\n+\n+    private static boolean signatureEquals(Method a, Method b) {\n+        if (!Objects.equals(a.getName(), b.getName()) || !Arrays.equals(a.getParameterTypes(), b.getParameterTypes())) {\n+            return false;\n+        }\n+\n+        return Objects.equals(a.getReturnType(), b.getReturnType());\n+    }\n+\n+    private record CompositeProxyInvocationHandler(Map<Method, Handler> dispatch) implements InvocationHandler {\n+\n+        @Override\n+        public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n+            var handler = dispatch.get(method);\n+            if (handler != null) {\n+                return handler.invoke(proxy, args);\n+            } else if (method.isDefault()) {\n+                return InvocationHandler.invokeDefault(proxy, method, args);\n+            } else {\n+                handler = OBJECT_METHOD_DISPATCH.get(method);\n+                if (handler != null) {\n+                    return handler.invoke(proxy, args);\n+                } else {\n+                    throw new UnsupportedOperationException(String.format(\"No handler for %s\", method));\n+                }\n+            }\n+        }\n+\n+        private static String objectToString(Object obj) {\n+            return obj.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(obj));\n+        }\n+\n+        private static boolean objectEquals(Object obj, Object other) {\n+            return obj == other;\n+        }\n+\n+        private static Method getMethod(Class<?> type, String methodName, Class<?>...paramaterTypes) {\n+            try {\n+                return type.getDeclaredMethod(methodName, paramaterTypes);\n+            } catch (NoSuchMethodException|SecurityException ex) {\n+                throw new InternalError(ex);\n+            }\n+        }\n+\n+        static class ObjectMethodHandler extends HandlerOfMethod {\n+\n+            ObjectMethodHandler(Method method) {\n+                super(method);\n+            }\n+\n+            @Override\n+            public Object invoke(Object proxy, Object[] args) throws Throwable {\n+                if (args == null) {\n+                    return method.invoke(null, proxy);\n+                } else {\n+                    final var newArgs = new Object[args.length + 1];\n+                    newArgs[0] = proxy;\n+                    System.arraycopy(args, 0, newArgs, 1, args.length);\n+                    return method.invoke(null, newArgs);\n+                }\n+            }\n+        }\n+\n+        private static final Map<Method, Handler> OBJECT_METHOD_DISPATCH = Map.of(\n+                getMethod(Object.class, \"toString\"),\n+                new ObjectMethodHandler(getMethod(CompositeProxyInvocationHandler.class, \"objectToString\", Object.class)),\n+                getMethod(Object.class, \"equals\", Object.class),\n+                new ObjectMethodHandler(getMethod(CompositeProxyInvocationHandler.class, \"objectEquals\", Object.class, Object.class)),\n+                getMethod(Object.class, \"hashCode\"),\n+                new ObjectMethodHandler(getMethod(System.class, \"identityHashCode\", Object.class))\n+        );\n+    }\n+\n+    private static HandlerOfMethod createHandlerForDefaultMethod(Method method, InvokeTunnel invokeTunnel) {\n+        if (invokeTunnel != null) {\n+            return new HandlerOfMethod(method) {\n+                @Override\n+                public Object invoke(Object proxy, Object[] args) throws Throwable {\n+                    return invokeTunnel.invokeDefault(proxy, this.method, args);\n+                }\n+            };\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static HandlerOfMethod createHandlerForMethod(Object obj, Method method, InvokeTunnel invokeTunnel) {\n+        if (invokeTunnel != null) {\n+            return new HandlerOfMethod(method) {\n+                @Override\n+                public Object invoke(Object proxy, Object[] args) throws Throwable {\n+                    return invokeTunnel.invoke(obj, this.method, args);\n+                }\n+            };\n+        } else {\n+            return new HandlerOfMethod(method) {\n+                @Override\n+                public Object invoke(Object proxy, Object[] args) throws Throwable {\n+                    return this.method.invoke(obj, args);\n+                }\n+            };\n+        }\n+    }\n+\n+    @FunctionalInterface\n+    private interface Handler {\n+\n+        Object invoke(Object proxy, Object[] args) throws Throwable;\n+    }\n+\n+    private abstract static class HandlerOfMethod implements Handler {\n+        HandlerOfMethod(Method method) {\n+            this.method = method;\n+        }\n+\n+        protected final Method method;\n+    }\n+\n+    private record ConflictResolverAdapter(BinaryOperator<Method> conflictResolver)\n+            implements BinaryOperator<HandlerOfMethod> {\n+\n+        @Override\n+        public HandlerOfMethod apply(HandlerOfMethod a, HandlerOfMethod b) {\n+            var m = conflictResolver.apply(a.method, b.method);\n+            if (m == a.method) {\n+                return a;\n+            } else if (m == b.method) {\n+                return b;\n+            } else {\n+                throw new UnsupportedOperationException();\n+            }\n+        }\n+    }\n+\n+    private static final BinaryOperator<Method> STANDARD_CONFLICT_RESOLVER = (a, b) -> {\n+        if (a.isDefault() == b.isDefault()) {\n+            throw new IllegalArgumentException(String.format(\"ambiguous choice between %s and %s\", a, b));\n+        } else if (!a.isDefault()) {\n+            return a;\n+        } else {\n+            return b;\n+        }\n+    };\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CompositeProxy.java","additions":532,"deletions":0,"binary":false,"changes":532,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.util.function.BiFunction;\n+\n+\/**\n+ * Builder of exceptions with localized messages.\n+ * @param <T> Subclass extending {@link LocalizedExceptionBuilder} class.\n+ *\/\n+public class LocalizedExceptionBuilder<T extends LocalizedExceptionBuilder<T>> {\n+\n+    protected LocalizedExceptionBuilder(StringBundle i18n) {\n+        this.i18n = i18n;\n+    }\n+\n+    \/**\n+     * Creates an exception builder with the given source of error messages.\n+     *\n+     * @param i18n the source of error messages\n+     * @return the exception builder\n+     *\/\n+    public static LocalizedExceptionBuilder<?> buildLocalizedException(StringBundle i18n) {\n+        return new LocalizedExceptionBuilder<>(i18n);\n+    }\n+\n+    \/**\n+     * Creates an instance of type extending {@link Exception} class from the\n+     * configured message and cause.\n+     * <p>\n+     * Use {@link #message(String, Object...)}, {@link #causeAndMessage(Throwable)},\n+     * and {@link #cause(Throwable)} methods to initialize message and\/or cause.\n+     *\n+     * @param <U>           the exception class\n+     * @param exceptionCtor the exception constructor\n+     * @return the exception\n+     *\/\n+    public final <U extends Exception> U create(BiFunction<String, Throwable, U> exceptionCtor) {\n+        return exceptionCtor.apply(msg, cause);\n+    }\n+\n+    \/**\n+     * Configures this builder if strings from the associated string bundle should\n+     * be used as patterns for message formatting or not.\n+     *\n+     * Affects the behavior of the subsequent {@link #message(String, Object...)}\n+     * calls.\n+     *\n+     * @param v <code>true<\/code> if strings from the associated string bundle\n+     *          should be used as patterns for message formatting by this builder or\n+     *          <code>false<\/code> otherwise\n+     * @return this\n+     *\n+     * @see #noformat()\n+     *\/\n+    public final T format(boolean v) {\n+        format = v;\n+        return thiz();\n+    }\n+\n+    \/**\n+     * A shortcut for <code>format(false)<\/code> call.\n+     *\n+     * @return this\n+     *\n+     * @see #format(boolean)\n+     *\/\n+    public final T noformat() {\n+        return format(false);\n+    }\n+\n+    \/**\n+     * Sets the message.\n+     *\n+     * @param msgId key of the string in the associated string bundle for the\n+     *              formatting pattern\n+     * @param args  the arguments for formatting message\n+     * @return this\n+     *\/\n+    public final T message(String msgId, Object... args) {\n+        msg = formatString(msgId, args);\n+        return thiz();\n+    }\n+\n+    \/**\n+     * Sets the cause.\n+     *\n+     * @param v the cause. A null value is permitted, and indicates that the cause\n+     *          is nonexistent or unknown.\n+     * @return this\n+     *\/\n+    public final T cause(Throwable v) {\n+        cause = v;\n+        return thiz();\n+    }\n+\n+    \/**\n+     * Sets the cause and the message. The message is copied from the given\n+     * {@link Throwable} object as is.\n+     *\n+     * @param t the cause. Must not be null.\n+     * @return this\n+     *\/\n+    public final T causeAndMessage(Throwable t) {\n+        boolean oldformat = format;\n+        return noformat().message(t.getMessage()).cause(t).format(oldformat);\n+    }\n+\n+    protected final String formatString(String keyId, Object... args) {\n+        if (format) {\n+            return i18n.format(keyId, args);\n+        } else if (args.length == 0) {\n+            return keyId;\n+        } else {\n+            throw new IllegalArgumentException(\"Formatting arguments not allowed in no format mode\");\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private T thiz() {\n+        return (T)this;\n+    }\n+\n+    private boolean format = true;\n+    private String msg;\n+    private Throwable cause;\n+\n+    private final StringBundle i18n;\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/LocalizedExceptionBuilder.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,0 +53,16 @@\n+\n+    public static Path normalizedAbsolutePath(Path path) {\n+        if (path != null) {\n+            return path.normalize().toAbsolutePath();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    public static String normalizedAbsolutePathString(Path path) {\n+        if (path != null) {\n+            return normalizedAbsolutePath(path).toString();\n+        } else {\n+            return null;\n+        }\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/PathUtils.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import java.text.MessageFormat;\n+import java.util.ResourceBundle;\n+\n+\n+\/**\n+ * String bundle contains locale-specific strings.\n+ * It can be viewed a specialized variant of {@link ResourceBundle}.\n+ * <p>\n+ * Use {@link #fromResourceBundle(ResourceBundle)} to obtain {@link StringBundle}\n+ * instance from {@link ResourceBundle} object.\n+ *\/\n+@FunctionalInterface\n+public interface StringBundle {\n+\n+    \/**\n+     * Gets a string for the given key from this string bundle.\n+     * @param key the key for the desired string\n+     * @return the string for the given key\n+     *\n+     * @see ResourceBundle#getString(String)\n+     *\/\n+    String getString(String key);\n+\n+    \/**\n+     * Gets a formatted message built from the pattern string matching\n+     * the given key in this string bundle and the given arguments.\n+     * <p>\n+     * If non-empty list of arguments provided the function calls {@link MessageFormat#format(String, Object...)}.\n+     * Otherwise, it returns the result of {@link #getString(String)} method call.\n+     *\n+     * @param key the key for the desired pattern\n+     * @param args the array of arguments for formatting or an empty array for no formatting\n+     * @return the formatted message\n+     *\/\n+    default String format(String key, Object ... args) {\n+        var str = getString(key);\n+        if (args.length != 0) {\n+            return MessageFormat.format(str, args);\n+        } else {\n+            return str;\n+        }\n+    }\n+\n+    \/**\n+     * Gets {@link StringBundle} instance from the given {@link ResourceBundle} object.\n+     * @param bundle the resource bundle\n+     * @return the string bundle\n+     *\/\n+    public static StringBundle fromResourceBundle(ResourceBundle bundle) {\n+        return bundle::getString;\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/StringBundle.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-\n+    requires java.naming;\n","filename":"src\/jdk.jpackage\/share\/classes\/module-info.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,1 @@\n+import jdk.jpackage.internal.resources.ResourceLocator;\n@@ -86,1 +87,2 @@\n-            var resource = new OverridableResource(defaultName).setCategory(category);\n+            var resource = new OverridableResource(defaultName,\n+                    ResourceLocator.class).setCategory(category);\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/PackageScripts.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.jpackage.internal.resources.ResourceLocator;\n@@ -108,1 +109,1 @@\n-        try ( InputStream is = OverridableResource.readDefault(resourceName);\n+        try ( InputStream is = ResourceLocator.class.getResourceAsStream(resourceName);\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/ShellCustomAction.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.jpackage.internal.model.Package;\n@@ -28,1 +29,0 @@\n-import java.util.Map;\n@@ -32,2 +32,1 @@\n-    ShellCustomAction create(PlatformPackage thePackage,\n-            Map<String, ? super Object> params) throws IOException;\n+    ShellCustomAction create(BuildEnv env, Package pkg) throws IOException;\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/ShellCustomActionFactory.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,2 @@\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.Application;\n@@ -33,0 +35,1 @@\n+import java.util.Objects;\n@@ -36,2 +39,0 @@\n-import jdk.jpackage.internal.AppImageFile.LauncherInfo;\n-import static jdk.jpackage.internal.StandardBundlerParam.PREDEFINED_APP_IMAGE;\n@@ -44,4 +45,2 @@\n-    UnixLaunchersAsServices(PlatformPackage thePackage,\n-            List<String> requiredPackages, Map<String, Object> params,\n-            Function<LauncherInfo, UnixLauncherAsService> factory) throws\n-            IOException {\n+    UnixLaunchersAsServices(Path outputRoot, Application app, List<String> requiredPackages,\n+            Function<Launcher, UnixLauncherAsService> factory) {\n@@ -49,2 +48,3 @@\n-        this.thePackage = thePackage;\n-        this.requiredPackages = requiredPackages;\n+        Objects.requireNonNull(factory);\n+        this.outputRoot = Objects.requireNonNull(outputRoot);\n+        this.requiredPackages = Objects.requireNonNull(requiredPackages);\n@@ -53,3 +53,1 @@\n-        launchers = AppImageFile.getLaunchers(PREDEFINED_APP_IMAGE.fetchFrom(\n-                params), params).stream().filter(LauncherInfo::isService).map(\n-                factory::apply).toList();\n+        launchers = app.launchers().stream().filter(Launcher::isService).map(factory::apply).toList();\n@@ -96,2 +94,1 @@\n-            launcher.getResource().saveToFile(launcher.descriptorFilePath(\n-                    thePackage.sourceRoot()));\n+            launcher.getResource().saveToFile(launcher.descriptorFilePath(outputRoot));\n@@ -109,3 +106,2 @@\n-        UnixLauncherAsService(String name, Map<String, Object> mainParams,\n-                OverridableResource resource) {\n-            super(name, mainParams, resource);\n+        UnixLauncherAsService(Application app, Launcher launcher, OverridableResource resource) {\n+            super(app, launcher, resource);\n@@ -117,1 +113,1 @@\n-    private final PlatformPackage thePackage;\n+    private final Path outputRoot;\n","filename":"src\/jdk.jpackage\/unix\/classes\/jdk\/jpackage\/internal\/UnixLaunchersAsServices.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import java.io.UncheckedIOException;\n@@ -35,1 +36,0 @@\n-import java.text.MessageFormat;\n@@ -40,0 +40,2 @@\n+import java.util.Objects;\n+import java.util.Optional;\n@@ -41,2 +43,2 @@\n-import java.util.ResourceBundle;\n-import java.util.function.Supplier;\n+import java.util.function.Function;\n+import java.util.stream.Stream;\n@@ -44,10 +46,3 @@\n-\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.ShortPathUtils.adjustPath;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.COPYRIGHT;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.WindowsAppImageBuilder.ICON_ICO;\n+import jdk.jpackage.internal.model.WinApplication;\n+import jdk.jpackage.internal.model.WinExePackage;\n+import jdk.jpackage.internal.model.WinLauncher;\n@@ -57,2 +52,0 @@\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.WinResources\");\n@@ -60,2 +53,7 @@\n-    private static final String LAUNCHER_PROPERTIES_TEMPLATE =\n-            \"WinLauncher.template\";\n+    ExecutableRebrander(WinExePackage pkg,\n+            Function<String, OverridableResource> resourceSupplier,\n+            UpdateResourceAction... extraActions) {\n+        this(ExecutableProperties.create(pkg), resourceSupplier.apply(\n+                \"WinInstaller.template\").setPublicName(\"WinInstaller.properties\"),\n+                extraActions);\n+    }\n@@ -63,2 +61,7 @@\n-    private static final String INSTALLER_PROPERTIES_TEMPLATE =\n-            \"WinInstaller.template\";\n+    ExecutableRebrander(WinApplication app, WinLauncher launcher,\n+            Function<String, OverridableResource> resourceSupplier,\n+            UpdateResourceAction... extraActions) {\n+        this(ExecutableProperties.create(app, launcher), resourceSupplier.apply(\n+                \"WinLauncher.template\").setPublicName(launcher.executableName() + \".properties\"),\n+                extraActions);\n+    }\n@@ -66,2 +69,5 @@\n-    private static final String INSTALLER_PROPERTIES_RESOURE_DIR_ID =\n-            \"WinInstaller.properties\";\n+    private ExecutableRebrander(ExecutableProperties props,\n+            OverridableResource propertiesFileResource,\n+            UpdateResourceAction... extraActions) {\n+        this.extraActions = List.of(extraActions);\n+        this.propertiesFileResource = Objects.requireNonNull(propertiesFileResource);\n@@ -69,0 +75,1 @@\n+        this.props = new HashMap<>();\n@@ -70,8 +77,5 @@\n-    void rebrandInstaller(Map<String, ? super Object> params, Path target)\n-            throws IOException {\n-        Path icon = ICON_ICO.fetchFrom(params);\n-        rebrandExecutable(params, icon, () -> {\n-            return createResource(INSTALLER_PROPERTIES_TEMPLATE, params).setPublicName(\n-                    INSTALLER_PROPERTIES_RESOURE_DIR_ID);\n-        }, target);\n-    }\n+        validateValueAndPut(this.props, Map.entry(\"COMPANY_NAME\", props.vendor), \"vendor\");\n+        validateValueAndPut(this.props, Map.entry(\"FILE_DESCRIPTION\",props.description), \"description\");\n+        validateValueAndPut(this.props, Map.entry(\"FILE_VERSION\", props.version.toString()), \"version\");\n+        validateValueAndPut(this.props, Map.entry(\"LEGAL_COPYRIGHT\", props.copyright), \"copyright\");\n+        validateValueAndPut(this.props, Map.entry(\"PRODUCT_NAME\", props.name), \"name\");\n@@ -79,7 +83,3 @@\n-    void rebrandLauncher(Map<String, ? super Object> params, Path icon,\n-            Path target) throws IOException {\n-        rebrandExecutable(params, icon, () -> {\n-            return createResource(\n-                    LAUNCHER_PROPERTIES_TEMPLATE, params).setPublicName(\n-                            APP_NAME.fetchFrom(params) + \".properties\");\n-        }, target);\n+        this.props.put(\"FIXEDFILEINFO_FILE_VERSION\", toFixedFileVersion(props.version));\n+        this.props.put(\"INTERNAL_NAME\", props.executableName);\n+        this.props.put(\"ORIGINAL_FILENAME\", props.executableName);\n@@ -88,18 +88,6 @@\n-    private void rebrandExecutable(Map<String, ? super Object> params, Path icon,\n-            Supplier<OverridableResource> resourceSupplier, Path target) throws\n-            IOException {\n-        if (!target.isAbsolute() || (icon != null && !icon.isAbsolute())) {\n-            Path absIcon = null;\n-            if (icon != null) {\n-                absIcon = icon.toAbsolutePath();\n-            }\n-            rebrandExecutable(params, absIcon, resourceSupplier,\n-                    target.toAbsolutePath());\n-            return;\n-        }\n-        rebrandExecutable(params, target, (resourceLock) -> {\n-            rebrandProperties(resourceLock, resourceSupplier.get(),\n-                    createSubstituteData(\n-                            params), target);\n-            if (icon != null) {\n-                iconSwapWrapper(resourceLock, icon.toString());\n+    void execute(BuildEnv env, Path target, Optional<Path> icon) {\n+        String[] propsArray = toStringArray(propertiesFileResource, props);\n+\n+        UpdateResourceAction versionSwapper = resourceLock -> {\n+            if (versionSwap(resourceLock, propsArray) != 0) {\n+                throw I18N.buildException().message(\"error.version-swap\", target).create(RuntimeException::new);\n@@ -107,2 +95,12 @@\n-        });\n-    }\n+        };\n+\n+        Optional<UpdateResourceAction> updateIcon = icon\n+                .map(Path::toAbsolutePath)\n+                .map(ShortPathUtils::adjustPath)\n+                .map(absIcon -> {\n+                    return resourceLock -> {\n+                        if (iconSwap(resourceLock, absIcon.toString()) != 0) {\n+                            throw I18N.buildException().message(\"error.icon-swap\", absIcon).create(RuntimeException::new);\n+                        }\n+                    };\n+                });\n@@ -110,3 +108,8 @@\n-    ExecutableRebrander addAction(UpdateResourceAction action) {\n-        if (extraActions == null) {\n-            extraActions = new ArrayList<>();\n+        try {\n+            final List<UpdateResourceAction> actions = new ArrayList<>();\n+            actions.add(versionSwapper);\n+            updateIcon.ifPresent(actions::add);\n+            actions.addAll(extraActions);\n+            rebrandExecutable(env, target, actions);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -114,2 +117,0 @@\n-        extraActions.add(action);\n-        return this;\n@@ -118,2 +119,4 @@\n-    private void rebrandExecutable(Map<String, ? super Object> params,\n-            final Path target, UpdateResourceAction action) throws IOException {\n+    private static void rebrandExecutable(BuildEnv env, final Path target,\n+            List<UpdateResourceAction> actions) throws IOException {\n+        Objects.requireNonNull(actions);\n+        actions.forEach(Objects::requireNonNull);\n@@ -121,7 +124,3 @@\n-            String tempDirectory = TEMP_ROOT.fetchFrom(params)\n-                    .toAbsolutePath().toString();\n-            if (WindowsDefender.isThereAPotentialWindowsDefenderIssue(\n-                    tempDirectory)) {\n-                Log.verbose(MessageFormat.format(I18N.getString(\n-                        \"message.potential.windows.defender.issue\"),\n-                        tempDirectory));\n+            String tempDirectory = env.buildRoot().toAbsolutePath().toString();\n+            if (WindowsDefender.isThereAPotentialWindowsDefenderIssue(tempDirectory)) {\n+                Log.verbose(I18N.format(\"message.potential.windows.defender.issue\", tempDirectory));\n@@ -135,2 +134,1 @@\n-                throw new RuntimeException(MessageFormat.format(\n-                    I18N.getString(\"error.lock-resource\"), shortTargetPath.orElse(target)));\n+                throw I18N.buildException().message(\"error.lock-resource\", shortTargetPath.orElse(target)).create(RuntimeException::new);\n@@ -141,5 +139,2 @@\n-                action.editResource(resourceLock);\n-                if (extraActions != null) {\n-                    for (UpdateResourceAction extraAction : extraActions) {\n-                        extraAction.editResource(resourceLock);\n-                    }\n+                for (var action : actions) {\n+                    action.editResource(resourceLock);\n@@ -164,2 +159,1 @@\n-                throw new RuntimeException(MessageFormat.format(I18N.getString(\n-                        \"error.unlock-resource\"), target));\n+                throw I18N.buildException().message(\"error.unlock-resource\", target).create(RuntimeException::new);\n@@ -172,8 +166,2 @@\n-    @FunctionalInterface\n-    static interface UpdateResourceAction {\n-        public void editResource(long resourceLock) throws IOException;\n-    }\n-\n-    private static String getFixedFileVersion(String value) {\n-        int addComponentsCount = 4\n-                - DottedVersion.greedy(value).getComponents().length;\n+    private static String toFixedFileVersion(DottedVersion value) {\n+        int addComponentsCount = 4 - value.getComponents().length;\n@@ -181,1 +169,1 @@\n-            StringBuilder sb = new StringBuilder(value);\n+            StringBuilder sb = new StringBuilder(value.toComponentsString());\n@@ -188,1 +176,1 @@\n-        return value;\n+        return value.toComponentsString();\n@@ -191,24 +179,3 @@\n-    private Map<String, String> createSubstituteData(\n-            Map<String, ? super Object> params) {\n-        Map<String, String> data = new HashMap<>();\n-\n-        String fixedFileVersion = getFixedFileVersion(VERSION.fetchFrom(params));\n-\n-        \/\/ mapping Java parameters in strings for version resource\n-        validateValueAndPut(data, \"COMPANY_NAME\", VENDOR, params);\n-        validateValueAndPut(data, \"FILE_DESCRIPTION\", DESCRIPTION, params);\n-        validateValueAndPut(data, \"FILE_VERSION\", VERSION, params);\n-        validateValueAndPut(data, \"LEGAL_COPYRIGHT\", COPYRIGHT, params);\n-        validateValueAndPut(data, \"PRODUCT_NAME\", APP_NAME, params);\n-        data.put(\"FIXEDFILEINFO_FILE_VERSION\", fixedFileVersion);\n-\n-        return data;\n-    }\n-\n-    private void rebrandProperties(long resourceLock, OverridableResource properties,\n-            Map<String, String> data, Path target) throws IOException {\n-\n-        String targetExecutableName = IOUtils.getFileName(target).toString();\n-        data.put(\"INTERNAL_NAME\", targetExecutableName);\n-        data.put(\"ORIGINAL_FILENAME\", targetExecutableName);\n-\n+    private static String[] toStringArray(\n+            OverridableResource propertiesFileResource,\n+            Map<String, String> props) {\n@@ -216,4 +183,9 @@\n-        properties\n-            .setSubstitutionData(data)\n-            .setCategory(I18N.getString(\"resource.executable-properties-template\"))\n-            .saveToStream(buffer);\n+        try {\n+            propertiesFileResource\n+                    .setSubstitutionData(props)\n+                    .setCategory(I18N.getString(\n+                            \"resource.executable-properties-template\"))\n+                    .saveToStream(buffer);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n+        }\n@@ -221,1 +193,0 @@\n-        final List<String> propList = new ArrayList<>();\n@@ -224,1 +195,1 @@\n-            final Properties configProp = new Properties();\n+            var configProp = new Properties();\n@@ -226,4 +197,5 @@\n-            configProp.forEach((k, v) -> {\n-                propList.add(k.toString());\n-                propList.add(v.toString());\n-            });\n+            return configProp.entrySet().stream().flatMap(e -> Stream.of(\n+                    e.getKey().toString(), e.getValue().toString())).toArray(\n+                    String[]::new);\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -231,3 +203,0 @@\n-\n-        versionSwapWrapper(resourceLock, propList.toArray(String[]::new),\n-                target.toString());\n@@ -236,7 +205,4 @@\n-    private static void validateValueAndPut(\n-            Map<String, String> data, String key,\n-            BundlerParamInfo<String> param,\n-            Map<String, ? super Object> params) {\n-        String value = param.fetchFrom(params);\n-        if (value.contains(\"\\r\") || value.contains(\"\\n\")) {\n-            Log.error(\"Configuration Parameter \" + param.getID()\n+    private static void validateValueAndPut(Map<String, String> target,\n+            Map.Entry<String, String> e, String label) {\n+        if (e.getValue().contains(\"\\r\") || e.getValue().contains(\"\\n\")) {\n+            Log.error(\"Configuration parameter \" + label\n@@ -244,2 +210,1 @@\n-            data.put(key, \"\");\n-            return;\n+            e = Map.entry(e.getKey(), \"\");\n@@ -247,1 +212,1 @@\n-        data.put(key, value);\n+        target.put(e.getKey(), e.getValue());\n@@ -250,7 +215,3 @@\n-    private static void iconSwapWrapper(long resourceLock,\n-            String iconTarget) {\n-        iconTarget = adjustPath(iconTarget);\n-        if (iconSwap(resourceLock, iconTarget) != 0) {\n-            throw new RuntimeException(MessageFormat.format(I18N.getString(\n-                    \"error.icon-swap\"), iconTarget));\n-        }\n+    @FunctionalInterface\n+    static interface UpdateResourceAction {\n+        public void editResource(long resourceLock) throws IOException;\n@@ -259,5 +220,14 @@\n-    private static void versionSwapWrapper(long resourceLock,\n-            String[] executableProperties, String target) {\n-        if (versionSwap(resourceLock, executableProperties) != 0) {\n-            throw new RuntimeException(MessageFormat.format(I18N.getString(\n-                    \"error.version-swap\"), target));\n+    private static record ExecutableProperties(String vendor, String description,\n+            DottedVersion version, String copyright, String name, String executableName) {\n+        static ExecutableProperties create(WinApplication app,\n+                WinLauncher launcher) {\n+            return new ExecutableProperties(app.vendor(), launcher.description(),\n+                    app.winVersion(), app.copyright(), launcher.name(),\n+                    launcher.executableNameWithSuffix());\n+        }\n+\n+        static ExecutableProperties create(WinExePackage pkg) {\n+            return new ExecutableProperties(pkg.app().vendor(),\n+                    pkg.description(), DottedVersion.lazy(pkg.version()),\n+                    pkg.app().copyright(), pkg.packageName(),\n+                    pkg.packageFileNameWithSuffix());\n@@ -267,1 +237,3 @@\n-    private List<UpdateResourceAction> extraActions;\n+    private final Map<String, String> props;\n+    private final List<UpdateResourceAction> extraActions;\n+    private final OverridableResource propertiesFileResource;\n@@ -277,1 +249,1 @@\n-    private static native int iconSwap(long resourceLock, String iconTarget);\n+    private static native int iconSwap(long resourceLock, String newIcon);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":122,"deletions":150,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -27,2 +27,0 @@\n-import static jdk.jpackage.internal.WinMsiBundler.WIN_APP_IMAGE;\n-\n@@ -41,1 +39,0 @@\n-import java.util.Map;\n@@ -43,0 +40,3 @@\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n@@ -51,2 +51,3 @@\n-    static OSVersionCondition createFromAppImage(ApplicationLayout appLayout, Map<String, ? super Object> params) {\n-        Objects.requireNonNull(appLayout);\n+    static OSVersionCondition createFromAppImage(BuildEnv env, Application app) {\n+        Objects.requireNonNull(env);\n+        Objects.requireNonNull(app);\n@@ -56,4 +57,1 @@\n-        if (!StandardBundlerParam.isRuntimeInstaller(params)) {\n-            final var launcherName = StandardBundlerParam.APP_NAME.fetchFrom(params);\n-            executables.add(appLayout.launchersDirectory().resolve(launcherName + \".exe\"));\n-        }\n+        final var appImageLayout = app.imageLayout().resolveAt(env.appImageDir());\n@@ -61,1 +59,5 @@\n-        executables.add(appLayout.runtimeDirectory().resolve(\"bin\\\\java.dll\"));\n+        app.mainLauncher().map(mainLauncher -> {\n+            return ((ApplicationLayout)appImageLayout).launchersDirectory().resolve(mainLauncher.executableNameWithSuffix());\n+        }).ifPresent(executables::add);\n+\n+        executables.add(appImageLayout.runtimeDirectory().resolve(\"bin\\\\java.dll\"));\n@@ -179,13 +181,2 @@\n-            void initFromParams(Map<String, ? super Object> params) {\n-                super.initFromParams(params);\n-\n-                final Path appImageRoot = WIN_APP_IMAGE.fetchFrom(params);\n-\n-                ApplicationLayout appImageLayout;\n-                if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-                    appImageLayout = ApplicationLayout.javaRuntime();\n-                } else {\n-                    appImageLayout = ApplicationLayout.platformAppImage();\n-                }\n-\n-                appImageLayout = appImageLayout.resolveAt(appImageRoot);\n+            void initFromParams(BuildEnv env, WinMsiPackage pkg) {\n+                super.initFromParams(env, pkg);\n@@ -193,1 +184,1 @@\n-                final var cond = OSVersionCondition.createFromAppImage(appImageLayout, params);\n+                final var cond = OSVersionCondition.createFromAppImage(env, pkg.app());\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/OSVersionCondition.java","additions":15,"deletions":24,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,8 @@\n-        setAppImageSupplier(WindowsAppImageBuilder::new);\n+        setAppImageSupplier((params, output) -> {\n+            \/\/ Order is important!\n+            var app = WinFromParams.APPLICATION.fetchFrom(params);\n+            var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+            WinPackagingPipeline.build()\n+                    .excludeDirFromCopying(output.getParent())\n+                    .create().execute(BuildEnv.withAppImageDir(env, output), app);\n+        });\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinAppBundler.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n+import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n+import static jdk.jpackage.internal.util.function.ThrowingRunnable.toRunnable;\n@@ -30,1 +31,0 @@\n-import java.io.InputStream;\n@@ -33,1 +33,1 @@\n-import java.text.MessageFormat;\n+import java.nio.file.StandardCopyOption;\n@@ -37,1 +37,1 @@\n-import jdk.jpackage.internal.util.PathUtils;\n+import jdk.jpackage.internal.model.WinExePackage;\n@@ -46,19 +46,0 @@\n-    public static final BundlerParamInfo<Path> EXE_IMAGE_DIR\n-            = new StandardBundlerParam<>(\n-                    \"win.exe.imageDir\",\n-                    Path.class,\n-                    params -> {\n-                        Path imagesRoot = IMAGES_ROOT.fetchFrom(params);\n-                        if (!Files.exists(imagesRoot)) {\n-                            try {\n-                                Files.createDirectories(imagesRoot);\n-                            } catch (IOException ioe) {\n-                                return null;\n-                            }\n-                        }\n-                        return imagesRoot.resolve(\"win-exe.image\");\n-                    },\n-                    (s, p) -> null);\n-\n-    private static final String EXE_WRAPPER_NAME = \"msiwrapper.exe\";\n-\n@@ -80,6 +61,0 @@\n-    @Override\n-    public Path execute(Map<String, ? super Object> params,\n-            Path outputParentDir) throws PackagerException {\n-        return bundle(params, outputParentDir);\n-    }\n-\n@@ -102,1 +77,2 @@\n-    public Path bundle(Map<String, ? super Object> params, Path outdir)\n+    @Override\n+    public Path execute(Map<String, ? super Object> params, Path outdir)\n@@ -105,0 +81,4 @@\n+        \/\/ Order is important!\n+        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n+        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+\n@@ -107,1 +87,2 @@\n-        Path exeImageDir = EXE_IMAGE_DIR.fetchFrom(params);\n+        Path msiDir = env.buildRoot().resolve(\"msi\");\n+        toRunnable(() -> Files.createDirectories(msiDir)).run();\n@@ -110,1 +91,1 @@\n-        Path msi = msiBundler.execute(params, exeImageDir);\n+        Path msi = msiBundler.execute(params, msiDir);\n@@ -118,1 +99,1 @@\n-            .run(params);\n+            .run(env, pkg.packageName());\n@@ -120,2 +101,3 @@\n-            return buildEXE(params, msi, outdir);\n-        } catch (IOException ex) {\n+            var exePkg = new WinExePackageBuilder(pkg).icon(ICON.fetchFrom(params)).create();\n+            return buildEXE(env, exePkg, msi, outdir);\n+        } catch (IOException|ConfigException ex) {\n@@ -127,1 +109,1 @@\n-    private Path buildEXE(Map<String, ? super Object> params, Path msi,\n+    private Path buildEXE(BuildEnv env, WinExePackage pkg, Path msi,\n@@ -130,3 +112,1 @@\n-        Log.verbose(MessageFormat.format(\n-                I18N.getString(\"message.outputting-to-location\"),\n-                outdir.toAbsolutePath().toString()));\n+        Log.verbose(I18N.format(\"message.outputting-to-location\", outdir.toAbsolutePath()));\n@@ -135,1 +115,1 @@\n-        final Path exePath = PathUtils.replaceSuffix(msi, \".exe\");\n+        final Path exePath = msi.getParent().resolve(pkg.packageFileNameWithSuffix());\n@@ -137,1 +117,1 @@\n-        createResource(EXE_WRAPPER_NAME, params)\n+        env.createResource(\"msiwrapper.exe\")\n@@ -142,1 +122,1 @@\n-        new ExecutableRebrander().addAction((resourceLock) -> {\n+        new ExecutableRebrander(pkg, env::createResource, resourceLock -> {\n@@ -145,1 +125,1 @@\n-        }).rebrandInstaller(params, exePath);\n+        }).execute(env, exePath, pkg.icon());\n@@ -147,2 +127,1 @@\n-        Path dstExePath = outdir.toAbsolutePath().resolve(exePath.getFileName());\n-        Files.deleteIfExists(dstExePath);\n+        Path dstExePath = outdir.resolve(exePath.getFileName());\n@@ -150,1 +129,1 @@\n-        Files.copy(exePath, dstExePath);\n+        Files.copy(exePath, dstExePath, StandardCopyOption.REPLACE_EXISTING);\n@@ -152,1 +131,1 @@\n-        dstExePath.toFile().setWritable(true, true);\n+        dstExePath.toFile().setExecutable(true);\n@@ -154,3 +133,1 @@\n-        Log.verbose(MessageFormat.format(\n-                I18N.getString(\"message.output-location\"),\n-                outdir.toAbsolutePath().toString()));\n+        Log.verbose(I18N.format(\"message.output-location\", outdir.toAbsolutePath()));\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":27,"deletions":50,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.WinExePackage;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+\n+final class WinExePackageBuilder {\n+\n+    WinExePackageBuilder(WinMsiPackage pkg) {\n+        this.pkg = Objects.requireNonNull(pkg);\n+    }\n+\n+    WinExePackage create() throws ConfigException {\n+        if (icon != null) {\n+            LauncherBuilder.validateIcon(icon);\n+        }\n+        return WinExePackage.create(pkg, Optional.ofNullable(icon));\n+    }\n+\n+    WinExePackageBuilder icon(Path v) {\n+        icon = v;\n+        return this;\n+    }\n+\n+    private Path icon;\n+\n+    private final WinMsiPackage pkg;\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExePackageBuilder.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static jdk.jpackage.internal.BundlerParamInfo.createBooleanBundlerParam;\n+import static jdk.jpackage.internal.BundlerParamInfo.createStringBundlerParam;\n+import static jdk.jpackage.internal.FromParams.createApplicationBuilder;\n+import static jdk.jpackage.internal.FromParams.createApplicationBundlerParam;\n+import static jdk.jpackage.internal.FromParams.createPackageBuilder;\n+import static jdk.jpackage.internal.FromParams.createPackageBundlerParam;\n+import static jdk.jpackage.internal.StandardBundlerParam.MENU_HINT;\n+import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n+import static jdk.jpackage.internal.StandardBundlerParam.SHORTCUT_HINT;\n+import static jdk.jpackage.internal.WinPackagingPipeline.APPLICATION_LAYOUT;\n+import static jdk.jpackage.internal.model.StandardPackageType.WIN_MSI;\n+import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_DESKTOP;\n+import static jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut.WIN_SHORTCUT_START_MENU;\n+import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.UUID;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.WinApplication;\n+import jdk.jpackage.internal.model.WinLauncher;\n+import jdk.jpackage.internal.model.WinLauncherMixin;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+\n+final class WinFromParams {\n+\n+    private static WinApplication createWinApplication(\n+            Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var launcherFromParams = new LauncherFromParams();\n+\n+        final var app = createApplicationBuilder(params, toFunction(launcherParams -> {\n+\n+            final var launcher = launcherFromParams.create(launcherParams);\n+\n+            final boolean isConsole = CONSOLE_HINT.findIn(launcherParams).orElse(false);\n+\n+            final var shortcuts = Map.of(WIN_SHORTCUT_DESKTOP, List.of(SHORTCUT_HINT,\n+                WIN_SHORTCUT_HINT), WIN_SHORTCUT_START_MENU, List.of(MENU_HINT,\n+                        WIN_MENU_HINT)).entrySet().stream().filter(e -> {\n+\n+                    final var shortcutParams = e.getValue();\n+\n+                    return shortcutParams.get(0).findIn(launcherParams).orElseGet(() -> {\n+                        return shortcutParams.get(1).findIn(launcherParams).orElse(false);\n+                    });\n+                }).map(Map.Entry::getKey).collect(toSet());\n+\n+            return WinLauncher.create(launcher, new WinLauncherMixin.Stub(isConsole, shortcuts));\n+\n+        }), APPLICATION_LAYOUT).create();\n+\n+        return WinApplication.create(app);\n+    }\n+\n+    private static WinMsiPackage createWinMsiPackage(Map<String, ? super Object> params) throws ConfigException, IOException {\n+\n+        final var app = APPLICATION.fetchFrom(params);\n+\n+        final var superPkgBuilder = createPackageBuilder(params, app, WIN_MSI);\n+\n+        final var pkgBuilder = new WinMsiPackageBuilder(superPkgBuilder);\n+\n+        HELP_URL.copyInto(params, pkgBuilder::helpURL);\n+        MSI_SYSTEM_WIDE.copyInto(params, pkgBuilder::isSystemWideInstall);\n+        MENU_GROUP.copyInto(params, pkgBuilder::startMenuGroupName);\n+        UPDATE_URL.copyInto(params, pkgBuilder::updateURL);\n+        INSTALLDIR_CHOOSER.copyInto(params, pkgBuilder::withInstallDirChooser);\n+        SHORTCUT_PROMPT.copyInto(params, pkgBuilder::withShortcutPrompt);\n+\n+        if (app.isService()) {\n+            RESOURCE_DIR.copyInto(params, resourceDir -> {\n+                pkgBuilder.serviceInstaller(resourceDir.resolve(\"service-installer.exe\"));\n+            });\n+        }\n+\n+        try {\n+            UPGRADE_UUID.findIn(params).map(UUID::fromString).ifPresent(pkgBuilder::upgradeCode);\n+        } catch (IllegalArgumentException ex) {\n+            throw new ConfigException(ex);\n+        }\n+\n+        return pkgBuilder.create();\n+    }\n+\n+    static final BundlerParamInfo<WinApplication> APPLICATION = createApplicationBundlerParam(\n+            WinFromParams::createWinApplication);\n+\n+    static final BundlerParamInfo<WinMsiPackage> MSI_PACKAGE = createPackageBundlerParam(\n+            WinFromParams::createWinMsiPackage);\n+\n+    private static final BundlerParamInfo<Boolean> WIN_MENU_HINT = createBooleanBundlerParam(\n+            Arguments.CLIOptions.WIN_MENU_HINT.getId());\n+\n+    private static final BundlerParamInfo<Boolean> WIN_SHORTCUT_HINT = createBooleanBundlerParam(\n+            Arguments.CLIOptions.WIN_SHORTCUT_HINT.getId());\n+\n+    public static final BundlerParamInfo<Boolean> CONSOLE_HINT = createBooleanBundlerParam(\n+            Arguments.CLIOptions.WIN_CONSOLE_HINT.getId());\n+\n+    private static final BundlerParamInfo<Boolean> INSTALLDIR_CHOOSER = new BundlerParamInfo<>(\n+            Arguments.CLIOptions.WIN_DIR_CHOOSER.getId(),\n+            Boolean.class,\n+            null,\n+            (s, p) -> Boolean.valueOf(s)\n+    );\n+\n+    private static final BundlerParamInfo<Boolean> SHORTCUT_PROMPT = new BundlerParamInfo<>(\n+            Arguments.CLIOptions.WIN_SHORTCUT_PROMPT.getId(),\n+            Boolean.class,\n+            null,\n+            (s, p) -> Boolean.valueOf(s)\n+    );\n+\n+    private static final BundlerParamInfo<String> MENU_GROUP = createStringBundlerParam(\n+            Arguments.CLIOptions.WIN_MENU_GROUP.getId());\n+\n+    private static final BundlerParamInfo<Boolean> MSI_SYSTEM_WIDE = createBooleanBundlerParam(\n+            Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId());\n+\n+    private static final BundlerParamInfo<String> HELP_URL = createStringBundlerParam(\n+            Arguments.CLIOptions.WIN_HELP_URL.getId());\n+\n+    private static final BundlerParamInfo<String> UPDATE_URL = createStringBundlerParam(\n+            Arguments.CLIOptions.WIN_UPDATE_URL.getId());\n+\n+    private static final BundlerParamInfo<String> UPGRADE_UUID = createStringBundlerParam(\n+            Arguments.CLIOptions.WIN_UPGRADE_UUID.getId());\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -28,0 +28,2 @@\n+import static jdk.jpackage.internal.model.ConfigException.rethrowConfigException;\n+\n@@ -30,0 +32,1 @@\n+import java.io.UncheckedIOException;\n@@ -32,1 +35,0 @@\n-import java.nio.charset.StandardCharsets;\n@@ -37,1 +39,0 @@\n-import java.text.MessageFormat;\n@@ -44,2 +45,0 @@\n-import java.util.Objects;\n-import java.util.Optional;\n@@ -47,1 +46,0 @@\n-import java.util.UUID;\n@@ -57,1 +55,3 @@\n-import jdk.jpackage.internal.AppImageFile.LauncherInfo;\n+import jdk.jpackage.internal.PackagingPipeline.PackageBuildEnv;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n@@ -59,1 +59,1 @@\n-import jdk.jpackage.internal.model.MsiVersion;\n+import jdk.jpackage.internal.model.Package;\n@@ -61,13 +61,2 @@\n-\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.ABOUT_URL;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALLER_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.DESCRIPTION;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n-import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.TEMP_ROOT;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import jdk.jpackage.internal.util.FileUtils;\n+import jdk.jpackage.internal.model.RuntimeLayout;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n@@ -141,89 +130,0 @@\n-    public static final BundlerParamInfo<Path> MSI_IMAGE_DIR =\n-            new StandardBundlerParam<>(\n-            \"win.msi.imageDir\",\n-            Path.class,\n-            params -> {\n-                Path imagesRoot = IMAGES_ROOT.fetchFrom(params);\n-                if (!Files.exists(imagesRoot)) {\n-                    try {\n-                        Files.createDirectories(imagesRoot);\n-                    } catch (IOException ioe) {\n-                        return null;\n-                    }\n-                }\n-                return imagesRoot.resolve(\"win-msi.image\");\n-            },\n-            (s, p) -> null);\n-\n-    public static final BundlerParamInfo<Path> WIN_APP_IMAGE =\n-            new StandardBundlerParam<>(\n-            \"win.app.image\",\n-            Path.class,\n-            null,\n-            (s, p) -> null);\n-\n-    static final StandardBundlerParam<InstallableFile> SERVICE_INSTALLER\n-            = new StandardBundlerParam<>(\n-                    \"win.msi.serviceInstaller\",\n-                    InstallableFile.class,\n-                    null,\n-                    null\n-            );\n-\n-    public static final StandardBundlerParam<Boolean> MSI_SYSTEM_WIDE  =\n-            new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.WIN_PER_USER_INSTALLATION.getId(),\n-                    Boolean.class,\n-                    params -> true, \/\/ MSIs default to system wide\n-                    \/\/ valueOf(null) is false,\n-                    \/\/ and we actually do want null\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s))? null\n-                            : Boolean.valueOf(s)\n-            );\n-\n-    public static final StandardBundlerParam<String> PRODUCT_VERSION =\n-            new StandardBundlerParam<>(\n-                    \"win.msi.productVersion\",\n-                    String.class,\n-                    VERSION::fetchFrom,\n-                    (s, p) -> s\n-            );\n-\n-    private static final BundlerParamInfo<String> HELP_URL =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.WIN_HELP_URL.getId(),\n-            String.class,\n-            null,\n-            (s, p) -> s);\n-\n-    private static final BundlerParamInfo<String> UPDATE_URL =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.WIN_UPDATE_URL.getId(),\n-            String.class,\n-            null,\n-            (s, p) -> s);\n-\n-    private static final BundlerParamInfo<String> UPGRADE_UUID =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.WIN_UPGRADE_UUID.getId(),\n-            String.class,\n-            null,\n-            (s, p) -> s);\n-\n-    private static final BundlerParamInfo<String> INSTALLER_FILE_NAME =\n-            new StandardBundlerParam<> (\n-            \"win.installerName\",\n-            String.class,\n-            params -> {\n-                String nm = INSTALLER_NAME.fetchFrom(params);\n-                if (nm == null) return null;\n-\n-                String version = VERSION.fetchFrom(params);\n-                if (version == null) {\n-                    return nm;\n-                } else {\n-                    return nm + \"-\" + version;\n-                }\n-            },\n-            (s, p) -> s);\n-\n@@ -231,1 +131,0 @@\n-        appImageBundler = new WinAppBundler().setDependentTask(true);\n@@ -280,21 +179,0 @@\n-    private static UUID getUpgradeCode(Map<String, ? super Object> params) {\n-        String upgradeCode = UPGRADE_UUID.fetchFrom(params);\n-        if (upgradeCode != null) {\n-            return UUID.fromString(upgradeCode);\n-        }\n-        return createNameUUID(\"UpgradeCode\", params, List.of(VENDOR, APP_NAME));\n-    }\n-\n-    private static UUID getProductCode(Map<String, ? super Object> params) {\n-        return createNameUUID(\"ProductCode\", params, List.of(VENDOR, APP_NAME,\n-                VERSION));\n-    }\n-\n-    private static UUID createNameUUID(String prefix,\n-            Map<String, ? super Object> params,\n-            List<StandardBundlerParam<String>> components) {\n-        String key = Stream.concat(Stream.of(prefix), components.stream().map(\n-                c -> c.fetchFrom(params))).collect(Collectors.joining(\"\/\"));\n-        return UUID.nameUUIDFromBytes(key.getBytes(StandardCharsets.UTF_8));\n-    }\n-\n@@ -305,1 +183,3 @@\n-            appImageBundler.validate(params);\n+            \/\/ Order is important!\n+            WinFromParams.APPLICATION.fetchFrom(params);\n+            BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n@@ -311,6 +191,0 @@\n-            try {\n-                getUpgradeCode(params);\n-            } catch (IllegalArgumentException ex) {\n-                throw new ConfigException(ex);\n-            }\n-\n@@ -318,3 +192,3 @@\n-                Log.verbose(MessageFormat.format(I18N.getString(\n-                        \"message.tool-version\"), wixToolset.getToolPath(tool).\n-                                getFileName(), wixToolset.getVersion()));\n+                Log.verbose(I18N.format(\"message.tool-version\",\n+                        wixToolset.getToolPath(tool).getFileName(),\n+                        wixToolset.getVersion()));\n@@ -329,14 +203,0 @@\n-            \/********* validate bundle parameters *************\/\n-\n-            try {\n-                String version = PRODUCT_VERSION.fetchFrom(params);\n-                MsiVersion.of(version);\n-            } catch (IllegalArgumentException ex) {\n-                throw new ConfigException(ex.getMessage(), I18N.getString(\n-                        \"error.version-string-wrong-format.advice\"), ex);\n-            }\n-\n-            FileAssociation.verify(FileAssociation.fetchFrom(params));\n-\n-            initServiceInstallerResource(params);\n-\n@@ -345,5 +205,1 @@\n-            if (re.getCause() instanceof ConfigException) {\n-                throw (ConfigException) re.getCause();\n-            } else {\n-                throw new ConfigException(re);\n-            }\n+            throw rethrowConfigException(re);\n@@ -353,15 +209,2 @@\n-    private void prepareProto(Map<String, ? super Object> params)\n-                throws PackagerException, IOException {\n-        Path appImage = StandardBundlerParam.getPredefinedAppImage(params);\n-        String appName = Objects.requireNonNull(APP_NAME.fetchFrom(params));\n-        Path appDir;\n-\n-        \/\/ we either have an application image or need to build one\n-        if (appImage != null) {\n-            appDir = MSI_IMAGE_DIR.fetchFrom(params).resolve(appName);\n-            \/\/ copy everything from appImage dir into appDir\/name\n-            FileUtils.copyRecursive(appImage, appDir);\n-        } else {\n-            appDir = appImageBundler.execute(params, MSI_IMAGE_DIR.fetchFrom(\n-                    params));\n-        }\n+    private void prepareProto(Package pkg, BuildEnv env, AppImageLayout appImageLayout) throws\n+            PackagerException, IOException {\n@@ -370,1 +213,1 @@\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n+        if (appImageLayout instanceof RuntimeLayout runtimeLayout) {\n@@ -375,11 +218,4 @@\n-            installerIcon = ApplicationLayout.javaRuntime()\n-                    .resolveAt(appDir)\n-                    .runtimeDirectory()\n-                    .resolve(Path.of(\"bin\", \"java.exe\"));\n-        } else {\n-            var appLayout = ApplicationLayout.windowsAppImage().resolveAt(appDir);\n-\n-            installerIcon = appLayout.launchersDirectory()\n-                    .resolve(appName + \".exe\");\n-\n-            new PackageFile(appName).save(appLayout);\n+            installerIcon = runtimeLayout.runtimeDirectory().resolve(Path.of(\"bin\", \"java.exe\"));\n+        } else if (appImageLayout instanceof ApplicationLayout appLayout) {\n+            installerIcon = appLayout.launchersDirectory().resolve(\n+                    pkg.app().mainLauncher().orElseThrow().executableNameWithSuffix());\n@@ -389,4 +225,1 @@\n-        params.put(WIN_APP_IMAGE.getID(), appDir);\n-\n-        String licenseFile = LICENSE_FILE.fetchFrom(params);\n-        if (licenseFile != null) {\n+        pkg.licenseFile().ifPresent(licenseFile -> {\n@@ -395,3 +228,1 @@\n-            Path lfile = Path.of(licenseFile);\n-            Path destFile = CONFIG_ROOT.fetchFrom(params)\n-                    .resolve(lfile.getFileName());\n+            Path destFile = env.configDir().resolve(licenseFile.getFileName());\n@@ -399,1 +230,5 @@\n-            IOUtils.copyFile(lfile, destFile);\n+            try {\n+                IOUtils.copyFile(licenseFile, destFile);\n+            } catch (IOException ex) {\n+                throw new UncheckedIOException(ex);\n+            }\n@@ -402,12 +237,1 @@\n-        }\n-\n-        try {\n-            var serviceInstallerResource = initServiceInstallerResource(params);\n-            if (serviceInstallerResource != null) {\n-                var serviceInstallerPath = serviceInstallerResource.getExternalPath();\n-                params.put(SERVICE_INSTALLER.getID(), new InstallableFile(\n-                        serviceInstallerPath, serviceInstallerPath.getFileName()));\n-            }\n-        } catch (ConfigException ex) {\n-            throw new PackagerException(ex);\n-        }\n+        });\n@@ -422,32 +246,15 @@\n-        Path imageDir = MSI_IMAGE_DIR.fetchFrom(params);\n-        try {\n-            Files.createDirectories(imageDir);\n-\n-            prepareProto(params);\n-\n-            for (var wixFragment : wixFragments) {\n-                wixFragment.initFromParams(params);\n-                wixFragment.addFilesToConfigRoot();\n-            }\n-\n-            Map<String, String> wixVars = prepareMainProjectFile(params);\n-            return buildMSI(params, wixVars, outputParentDir);\n-        } catch (IOException ex) {\n-            Log.verbose(ex);\n-            throw new PackagerException(ex);\n-        }\n-    }\n-\n-    private long getAppImageSizeKb(Map<String, ? super Object> params) throws\n-            IOException {\n-        ApplicationLayout appLayout;\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            appLayout = ApplicationLayout.javaRuntime();\n-        } else {\n-            appLayout = ApplicationLayout.windowsAppImage();\n-        }\n-        appLayout = appLayout.resolveAt(WIN_APP_IMAGE.fetchFrom(params));\n-\n-        long size = appLayout.sizeInBytes() >> 10;\n-\n-        return size;\n+        \/\/ Order is important!\n+        var pkg = WinFromParams.MSI_PACKAGE.fetchFrom(params);\n+        var env = BuildEnvFromParams.BUILD_ENV.fetchFrom(params);\n+\n+        WinPackagingPipeline.build()\n+                .excludeDirFromCopying(outputParentDir)\n+                .task(PackagingPipeline.PackageTaskID.CREATE_CONFIG_FILES)\n+                        .packageAction(this::prepareConfigFiles)\n+                        .add()\n+                .task(PackagingPipeline.PackageTaskID.CREATE_PACKAGE_FILE)\n+                        .packageAction(this::buildPackage)\n+                        .add()\n+                .create().execute(env, pkg, outputParentDir);\n+\n+        return outputParentDir.resolve(pkg.packageFileNameWithSuffix()).toAbsolutePath();\n@@ -456,48 +263,5 @@\n-    private Map<String, String> prepareMainProjectFile(\n-            Map<String, ? super Object> params) throws IOException {\n-        Map<String, String> data = new HashMap<>();\n-\n-        final UUID productCode = getProductCode(params);\n-        final UUID upgradeCode = getUpgradeCode(params);\n-\n-        data.put(\"JpProductCode\", productCode.toString());\n-        data.put(\"JpProductUpgradeCode\", upgradeCode.toString());\n-\n-        Log.verbose(MessageFormat.format(I18N.getString(\"message.product-code\"),\n-                productCode));\n-        Log.verbose(MessageFormat.format(I18N.getString(\"message.upgrade-code\"),\n-                upgradeCode));\n-\n-        data.put(\"JpAllowUpgrades\", \"yes\");\n-        if (!StandardBundlerParam.isRuntimeInstaller(params)) {\n-            data.put(\"JpAllowDowngrades\", \"yes\");\n-        }\n-\n-        data.put(\"JpAppName\", APP_NAME.fetchFrom(params));\n-        data.put(\"JpAppDescription\", DESCRIPTION.fetchFrom(params));\n-        data.put(\"JpAppVendor\", VENDOR.fetchFrom(params));\n-        data.put(\"JpAppVersion\", PRODUCT_VERSION.fetchFrom(params));\n-        if (Files.exists(installerIcon)) {\n-            data.put(\"JpIcon\", installerIcon.toString());\n-        }\n-\n-        Optional.ofNullable(HELP_URL.fetchFrom(params)).ifPresent(value -> {\n-            data.put(\"JpHelpURL\", value);\n-        });\n-\n-        Optional.ofNullable(UPDATE_URL.fetchFrom(params)).ifPresent(value -> {\n-            data.put(\"JpUpdateURL\", value);\n-        });\n-\n-        Optional.ofNullable(ABOUT_URL.fetchFrom(params)).ifPresent(value -> {\n-            data.put(\"JpAboutURL\", value);\n-        });\n-\n-        data.put(\"JpAppSizeKb\", Long.toString(getAppImageSizeKb(params)));\n-\n-        final Path configDir = CONFIG_ROOT.fetchFrom(params);\n-\n-        data.put(\"JpConfigDir\", configDir.toAbsolutePath().toString());\n-\n-        if (MSI_SYSTEM_WIDE.fetchFrom(params)) {\n-            data.put(\"JpIsSystemWide\", \"yes\");\n+    private void prepareConfigFiles(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n+        prepareProto(env.pkg(), env.env(), env.resolvedLayout());\n+        for (var wixFragment : wixFragments) {\n+            wixFragment.initFromParams(env.env(), env.pkg());\n+            wixFragment.addFilesToConfigRoot();\n@@ -506,2 +270,1 @@\n-        return data;\n-    }\n+        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n@@ -509,3 +272,1 @@\n-    private Path buildMSI(Map<String, ? super Object> params,\n-            Map<String, String> wixVars, Path outdir)\n-            throws IOException {\n+        Log.verbose(I18N.format(\"message.preparing-msi-config\", msiOut.toAbsolutePath()));\n@@ -513,1 +274,1 @@\n-        Path msiOut = outdir.resolve(INSTALLER_FILE_NAME.fetchFrom(params) + \".msi\");\n+        final var wixVars = createWixVars(env);\n@@ -515,3 +276,1 @@\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.preparing-msi-config\"), msiOut.toAbsolutePath()\n-                        .toString()));\n+        final var wixObjDir = env.env().buildRoot().resolve(\"wixobj\");\n@@ -519,1 +278,1 @@\n-        var wixObjDir = TEMP_ROOT.fetchFrom(params).resolve(\"wixobj\");\n+        final var configDir = env.env().configDir();\n@@ -521,1 +280,1 @@\n-        var wixPipeline = WixPipeline.build()\n+        final var wixPipelineBuilder = WixPipeline.build()\n@@ -523,3 +282,2 @@\n-                .setWorkDir(WIN_APP_IMAGE.fetchFrom(params))\n-                .addSource(CONFIG_ROOT.fetchFrom(params).resolve(\"main.wxs\"),\n-                        wixVars);\n+                .setWorkDir(env.env().appImageDir())\n+                .addSource(configDir.resolve(\"main.wxs\"), wixVars);\n@@ -528,1 +286,1 @@\n-            wixFragment.configureWixPipeline(wixPipeline);\n+            wixFragment.configureWixPipeline(wixPipelineBuilder);\n@@ -531,3 +289,0 @@\n-        Log.verbose(MessageFormat.format(I18N.getString(\n-                \"message.generating-msi\"), msiOut.toAbsolutePath().toString()));\n-\n@@ -536,1 +291,1 @@\n-                wixPipeline.addLightOptions(\"-sice:ICE27\");\n+                wixPipelineBuilder.addLightOptions(\"-sice:ICE27\");\n@@ -538,2 +293,2 @@\n-                if (!MSI_SYSTEM_WIDE.fetchFrom(params)) {\n-                    wixPipeline.addLightOptions(\"-sice:ICE91\");\n+                if (!env.pkg().isSystemWideInstall()) {\n+                    wixPipelineBuilder.addLightOptions(\"-sice:ICE91\");\n@@ -549,2 +304,0 @@\n-        final Path configDir = CONFIG_ROOT.fetchFrom(params);\n-\n@@ -560,1 +313,1 @@\n-            wixResources.addResource(createResource(name, params).setPublicName(name).setCategory(\n+            wixResources.addResource(env.env().createResource(name).setPublicName(name).setCategory(\n@@ -564,1 +317,1 @@\n-        wixResources.addResource(createResource(\"main.wxs\", params).setPublicName(\"main.wxs\").\n+        wixResources.addResource(env.env().createResource(\"main.wxs\").setPublicName(\"main.wxs\").\n@@ -567,1 +320,1 @@\n-        wixResources.addResource(createResource(\"overrides.wxi\", params).setPublicName(\n+        wixResources.addResource(env.env().createResource(\"overrides.wxi\").setPublicName(\n@@ -574,1 +327,4 @@\n-        List<Path> customWxlFiles = getWxlFilesFromDir(params, RESOURCE_DIR).stream()\n+        List<Path> customWxlFiles = env.env().resourceDir()\n+                .map(WinMsiBundler::getWxlFilesFromDir)\n+                .orElseGet(Collections::emptyList)\n+                .stream()\n@@ -578,5 +334,4 @@\n-                .peek(custom -> Log.verbose(MessageFormat.format(\n-                        I18N.getString(\"message.using-custom-resource\"),\n-                                String.format(\"[%s]\", I18N.getString(\"resource.wxl-file\")),\n-                                custom.getFileName().toString())))\n-                .toList();\n+                .peek(custom -> Log.verbose(I18N.format(\n+                        \"message.using-custom-resource\", String.format(\"[%s]\",\n+                                I18N.getString(\"resource.wxl-file\")),\n+                        custom.getFileName()))).toList();\n@@ -587,1 +342,1 @@\n-            wixResources.addResource(createResource(name, params).setPublicName(name).\n+            wixResources.addResource(env.env().createResource(name).setPublicName(name).\n@@ -595,9 +350,0 @@\n-        final var imageDir = WIN_APP_IMAGE.fetchFrom(params);\n-\n-        new ScriptRunner()\n-                .setDirectory(imageDir)\n-                .setResourceCategoryId(\"resource.post-app-image-script\")\n-                .setScriptNameSuffix(\"post-image\")\n-                .setEnvironmentVariable(\"JpAppImageDir\", imageDir.toAbsolutePath().toString())\n-                .run(params);\n-\n@@ -608,1 +354,1 @@\n-            wixPipeline.addLightOptions(\"-loc\", wxl.toString());\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n@@ -614,1 +360,1 @@\n-            wixPipeline.addLightOptions(\"-loc\", wxl.toString());\n+            wixPipelineBuilder.addLightOptions(\"-loc\", wxl.toString());\n@@ -619,1 +365,1 @@\n-        final Path primaryWxlFile = CONFIG_ROOT.fetchFrom(params).resolve(\n+        final Path primaryWxlFile = configDir.resolve(\n@@ -628,1 +374,1 @@\n-                wixPipeline.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n+                wixPipelineBuilder.addLightOptions(uniqueCultures.stream().collect(Collectors.joining(\";\",\n@@ -633,1 +379,1 @@\n-                    wixPipeline.addLightOptions(\"-culture\", culture);\n+                    wixPipelineBuilder.addLightOptions(\"-culture\", culture);\n@@ -642,1 +388,2 @@\n-        wixPipeline.create(wixToolset).buildMsi(msiOut.toAbsolutePath());\n+        wixPipeline = wixPipelineBuilder.create(wixToolset);\n+    }\n@@ -644,1 +391,4 @@\n-        return msiOut;\n+    private void buildPackage(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws PackagerException, IOException {\n+        final var msiOut = env.outputDir().resolve(env.pkg().packageFileNameWithSuffix());\n+        Log.verbose(I18N.format(\"message.generating-msi\", msiOut.toAbsolutePath()));\n+        wixPipeline.buildMsi(msiOut.toAbsolutePath());\n@@ -647,5 +397,14 @@\n-    private static List<Path> getWxlFilesFromDir(Map<String, ? super Object> params,\n-            StandardBundlerParam<Path> pathParam) throws IOException {\n-        Path dir = pathParam.fetchFrom(params);\n-        if (dir == null) {\n-            return Collections.emptyList();\n+    private Map<String, String> createWixVars(PackageBuildEnv<WinMsiPackage, AppImageLayout> env) throws IOException {\n+        Map<String, String> data = new HashMap<>();\n+\n+        final var pkg = env.pkg();\n+\n+        data.put(\"JpProductCode\", pkg.productCode().toString());\n+        data.put(\"JpProductUpgradeCode\", pkg.upgradeCode().toString());\n+\n+        Log.verbose(I18N.format(\"message.product-code\", pkg.productCode()));\n+        Log.verbose(I18N.format(\"message.upgrade-code\", pkg.upgradeCode()));\n+\n+        data.put(\"JpAllowUpgrades\", \"yes\");\n+        if (!pkg.isRuntimeInstaller()) {\n+            data.put(\"JpAllowDowngrades\", \"yes\");\n@@ -654,0 +413,33 @@\n+        data.put(\"JpAppName\", pkg.packageName());\n+        data.put(\"JpAppDescription\", pkg.description());\n+        data.put(\"JpAppVendor\", pkg.app().vendor());\n+        data.put(\"JpAppVersion\", pkg.version());\n+        if (Files.exists(installerIcon)) {\n+            data.put(\"JpIcon\", installerIcon.toString());\n+        }\n+\n+        pkg.helpURL().ifPresent(value -> {\n+            data.put(\"JpHelpURL\", value);\n+        });\n+\n+        pkg.updateURL().ifPresent(value -> {\n+            data.put(\"JpUpdateURL\", value);\n+        });\n+\n+        pkg.aboutURL().ifPresent(value -> {\n+            data.put(\"JpAboutURL\", value);\n+        });\n+\n+        data.put(\"JpAppSizeKb\", Long.toString(AppImageLayout.toPathGroup(\n+                env.resolvedLayout()).sizeInBytes() >> 10));\n+\n+        data.put(\"JpConfigDir\", env.env().configDir().toAbsolutePath().toString());\n+\n+        if (pkg.isSystemWideInstall()) {\n+            data.put(\"JpIsSystemWide\", \"yes\");\n+        }\n+\n+        return data;\n+    }\n+\n+    private static List<Path> getWxlFilesFromDir(Path dir) {\n@@ -664,0 +456,2 @@\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -667,1 +461,1 @@\n-    private static String getCultureFromWxlFile(Path wxlPath) throws IOException {\n+    private static String getCultureFromWxlFile(Path wxlPath) {\n@@ -677,2 +471,1 @@\n-                    \"\/\/WixLocalization\/@Culture\", doc,\n-                    XPathConstants.NODESET);\n+                    \"\/\/WixLocalization\/@Culture\", doc, XPathConstants.NODESET);\n@@ -680,2 +473,2 @@\n-                throw new IOException(MessageFormat.format(I18N.getString(\n-                        \"error.extract-culture-from-wix-l10n-file\"),\n+                throw new IOException(I18N.format(\n+                        \"error.extract-culture-from-wix-l10n-file\",\n@@ -688,2 +481,4 @@\n-            throw new IOException(MessageFormat.format(I18N.getString(\n-                    \"error.read-wix-l10n-file\"), wxlPath.toAbsolutePath().normalize()), ex);\n+            throw new UncheckedIOException(new IOException(\n+                    I18N.format(\"error.read-wix-l10n-file\", wxlPath.toAbsolutePath().normalize()), ex));\n+        } catch (IOException ex) {\n+            throw new UncheckedIOException(ex);\n@@ -694,2 +489,0 @@\n-        if (f == null || !Files.isRegularFile(f)) return;\n-\n@@ -761,32 +554,0 @@\n-\n-    }\n-\n-    private static OverridableResource initServiceInstallerResource(\n-            Map<String, ? super Object> params) throws ConfigException {\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            \/\/ Runtime installer doesn't install launchers,\n-            \/\/ service installer not needed\n-            return null;\n-        }\n-\n-        if (!AppImageFile.getLaunchers(\n-                StandardBundlerParam.getPredefinedAppImage(params), params).stream().anyMatch(\n-                LauncherInfo::isService)) {\n-            \/\/ Not a single launcher is requested to be installed as a service,\n-            \/\/ service installer not needed\n-            return null;\n-        }\n-\n-        var result = createResource(null, params)\n-                .setPublicName(\"service-installer.exe\")\n-                .setSourceOrder(OverridableResource.Source.External);\n-        if (result.getResourceDir() != null) {\n-            result.setExternal(result.getResourceDir().resolve(result.getPublicName()));\n-\n-            if (Files.exists(result.getExternalPath())) {\n-                return result;\n-            }\n-        }\n-\n-        throw new ConfigException(I18N.getString(\"error.missing-service-installer\"),\n-                I18N.getString(\"error.missing-service-installer.advice\"));\n@@ -797,1 +558,1 @@\n-    private AppImageBundler appImageBundler;\n+    private WixPipeline wixPipeline;\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiBundler.java","additions":144,"deletions":383,"binary":false,"changes":527,"status":"modified"},{"patch":"@@ -0,0 +1,146 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.I18N.buildConfigException;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.MsiVersion;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import jdk.jpackage.internal.model.WinMsiPackageMixin;\n+\n+final class WinMsiPackageBuilder {\n+\n+    WinMsiPackageBuilder(PackageBuilder pkgBuilder) {\n+        this.pkgBuilder = Objects.requireNonNull(pkgBuilder);\n+    }\n+\n+    WinMsiPackage create() throws ConfigException {\n+        var pkg = pkgBuilder.create();\n+\n+        try {\n+            MsiVersion.of(pkg.version());\n+        } catch (IllegalArgumentException ex) {\n+            throw buildConfigException(ex)\n+                    .advice(\"error.version-string-wrong-format.advice\")\n+                    .create();\n+        }\n+\n+        if (pkg.app().isService() && (serviceInstaller == null || !Files.exists(serviceInstaller))) {\n+            throw buildConfigException()\n+                    .message(\"error.missing-service-installer\")\n+                    .advice(\"error.missing-service-installer.advice\")\n+                    .create();\n+        }\n+\n+        return WinMsiPackage.create(pkg, new WinMsiPackageMixin.Stub(\n+                MsiVersion.of(pkg.version()),\n+                withInstallDirChooser,\n+                withShortcutPrompt,\n+                Optional.ofNullable(helpURL),\n+                Optional.ofNullable(updateURL),\n+                Optional.ofNullable(startMenuGroupName).orElseGet(DEFAULTS::startMenuGroupName),\n+                isSystemWideInstall,\n+                Optional.ofNullable(upgradeCode).orElseGet(() -> upgradeCode(pkg.app())),\n+                productCode(pkg.app(), pkg.version()),\n+                Optional.ofNullable(serviceInstaller)));\n+    }\n+\n+    private static UUID upgradeCode(Application app) {\n+        return createNameUUID(\"UpgradeCode\", app.vendor(), app.name());\n+    }\n+\n+    private static UUID productCode(Application app, String pkgVersion) {\n+        return createNameUUID(\"ProductCode\", app.vendor(), app.name(), pkgVersion);\n+    }\n+\n+    WinMsiPackageBuilder withInstallDirChooser(boolean v) {\n+        withInstallDirChooser = v;\n+        return this;\n+    }\n+\n+    WinMsiPackageBuilder withShortcutPrompt(boolean v) {\n+        withShortcutPrompt = v;\n+        return this;\n+    }\n+\n+    WinMsiPackageBuilder helpURL(String v) {\n+        helpURL = v;\n+        return this;\n+    }\n+\n+    WinMsiPackageBuilder updateURL(String v) {\n+        updateURL = v;\n+        return this;\n+    }\n+\n+    WinMsiPackageBuilder startMenuGroupName(String v) {\n+        startMenuGroupName = v;\n+        return this;\n+    }\n+\n+    WinMsiPackageBuilder isSystemWideInstall(boolean v) {\n+        isSystemWideInstall = v;\n+        return this;\n+    }\n+\n+    WinMsiPackageBuilder serviceInstaller(Path v) {\n+        serviceInstaller = v;\n+        return this;\n+    }\n+\n+    WinMsiPackageBuilder upgradeCode(UUID v) {\n+        upgradeCode = v;\n+        return this;\n+    }\n+\n+    private static UUID createNameUUID(String... components) {\n+        String key = String.join(\"\/\", components);\n+        return UUID.nameUUIDFromBytes(key.getBytes(StandardCharsets.UTF_8));\n+    }\n+\n+    record Defaults(String startMenuGroupName) {}\n+\n+    private boolean withInstallDirChooser;\n+    private boolean withShortcutPrompt;\n+    private String helpURL;\n+    private String updateURL;\n+    private String startMenuGroupName;\n+    private boolean isSystemWideInstall = true;\n+    private Path serviceInstaller;\n+    private UUID upgradeCode;\n+\n+    private final PackageBuilder pkgBuilder;\n+\n+    private static final Defaults DEFAULTS = new Defaults(I18N.getString(\"param.menu-group.default\"));\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinMsiPackageBuilder.java","additions":146,"deletions":0,"binary":false,"changes":146,"status":"added"},{"patch":"@@ -0,0 +1,85 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal;\n+\n+import static jdk.jpackage.internal.ApplicationImageUtils.createLauncherIconResource;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import jdk.jpackage.internal.PackagingPipeline.AppImageBuildEnv;\n+import jdk.jpackage.internal.PackagingPipeline.BuildApplicationTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.CopyAppImageTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.PrimaryTaskID;\n+import jdk.jpackage.internal.PackagingPipeline.TaskID;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.Package;\n+import jdk.jpackage.internal.model.PackagerException;\n+import jdk.jpackage.internal.model.WinApplication;\n+import jdk.jpackage.internal.model.WinLauncher;\n+\n+final class WinPackagingPipeline {\n+\n+    enum WinAppImageTaskID implements TaskID {\n+        REBRAND_LAUNCHERS\n+    }\n+\n+    static PackagingPipeline.Builder build() {\n+        return PackagingPipeline.buildStandard()\n+                .appImageLayoutForPackaging(Package::appImageLayout)\n+                .task(CopyAppImageTaskID.COPY).noaction().add()\n+                .task(WinAppImageTaskID.REBRAND_LAUNCHERS)\n+                        .addDependency(BuildApplicationTaskID.LAUNCHERS)\n+                        .addDependent(PrimaryTaskID.BUILD_APPLICATION_IMAGE)\n+                        .applicationAction(WinPackagingPipeline::rebrandLaunchers).add();\n+    }\n+\n+    private static void rebrandLaunchers(AppImageBuildEnv<WinApplication, ApplicationLayout> env)\n+            throws IOException, PackagerException {\n+        for (var launcher : env.app().launchers()) {\n+            final var iconTarget = createLauncherIconResource(env.app(), launcher, env.env()::createResource).map(iconResource -> {\n+                var iconDir = env.env().buildRoot().resolve(\"icons\");\n+                var theIconTarget = iconDir.resolve(launcher.executableName() + \".ico\");\n+                try {\n+                    if (null == iconResource.saveToFile(theIconTarget)) {\n+                        theIconTarget = null;\n+                    }\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+                return theIconTarget;\n+            });\n+\n+            var launcherExecutable = env.resolvedLayout().launchersDirectory().resolve(\n+                    launcher.executableNameWithSuffix());\n+\n+            \/\/ Update branding of launcher executable\n+            new ExecutableRebrander(env.app(),\n+                    (WinLauncher) launcher, env.env()::createResource).execute(\n+                            env.env(), launcherExecutable, iconTarget);\n+        }\n+    }\n+\n+    static final ApplicationLayout APPLICATION_LAYOUT = ApplicationLayoutUtils.PLATFORM_APPLICATION_LAYOUT;\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":85,"deletions":0,"binary":false,"changes":85,"status":"added"},{"patch":"@@ -1,145 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import java.text.MessageFormat;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.ResourceBundle;\n-\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.ICON;\n-import static jdk.jpackage.internal.StandardBundlerParam.ADD_LAUNCHERS;\n-\n-public class WindowsAppImageBuilder extends AbstractAppImageBuilder {\n-    private static final ResourceBundle I18N = ResourceBundle.getBundle(\n-            \"jdk.jpackage.internal.resources.WinResources\");\n-\n-    private static final String TEMPLATE_APP_ICON =\"JavaApp.ico\";\n-\n-    public static final BundlerParamInfo<Path> ICON_ICO =\n-            new StandardBundlerParam<>(\n-            \"icon.ico\",\n-            Path.class,\n-            params -> {\n-                Path f = ICON.fetchFrom(params);\n-                if (f != null && f.getFileName() != null && !f.getFileName()\n-                        .toString().toLowerCase().endsWith(\".ico\")) {\n-                    Log.error(MessageFormat.format(\n-                            I18N.getString(\"message.icon-not-ico\"), f));\n-                    return null;\n-                }\n-                return f;\n-            },\n-            (s, p) -> Path.of(s));\n-\n-    public static final StandardBundlerParam<Boolean> CONSOLE_HINT =\n-            new StandardBundlerParam<>(\n-            Arguments.CLIOptions.WIN_CONSOLE_HINT.getId(),\n-            Boolean.class,\n-            params -> false,\n-            \/\/ valueOf(null) is false,\n-            \/\/ and we actually do want null in some cases\n-            (s, p) -> (s == null\n-            || \"null\".equalsIgnoreCase(s)) ? true : Boolean.valueOf(s));\n-\n-    WindowsAppImageBuilder(Path imageOutDir) {\n-        super(imageOutDir);\n-    }\n-\n-    private void writeEntry(InputStream in, Path dstFile) throws IOException {\n-        Files.createDirectories(IOUtils.getParent(dstFile));\n-        Files.copy(in, dstFile);\n-    }\n-\n-    private static String getLauncherName(Map<String, ? super Object> params) {\n-        return APP_NAME.fetchFrom(params) + \".exe\";\n-    }\n-\n-    \/\/ Returns launcher resource name for launcher we need to use.\n-    public static String getLauncherResourceName(\n-            Map<String, ? super Object> params) {\n-        if (CONSOLE_HINT.fetchFrom(params)) {\n-            return \"jpackageapplauncher.exe\";\n-        } else {\n-            return \"jpackageapplauncherw.exe\";\n-        }\n-    }\n-\n-    @Override\n-    public void prepareApplicationFiles(Map<String, ? super Object> params)\n-            throws IOException {\n-        \/\/ create the .exe launchers\n-        createLauncherForEntryPoint(params, null);\n-\n-        \/\/ copy the jars\n-        copyApplication(params);\n-\n-        \/\/ create the additional launcher(s), if any\n-        List<Map<String, ? super Object>> entryPoints = ADD_LAUNCHERS.fetchFrom(params);\n-        for (Map<String, ? super Object> entryPoint : entryPoints) {\n-            createLauncherForEntryPoint(AddLauncherArguments.merge(params,\n-                    entryPoint, ICON.getID(), ICON_ICO.getID()), params);\n-        }\n-    }\n-\n-    private void createLauncherForEntryPoint(Map<String, ? super Object> params,\n-            Map<String, ? super Object> mainParams) throws IOException {\n-\n-        var iconResource = createIconResource(TEMPLATE_APP_ICON, ICON_ICO, params,\n-                mainParams);\n-        Path iconTarget = null;\n-        if (iconResource != null) {\n-            Path iconDir = StandardBundlerParam.TEMP_ROOT.fetchFrom(params).resolve(\n-                    \"icons\");\n-            iconTarget = iconDir.resolve(APP_NAME.fetchFrom(params) + \".ico\");\n-            if (null == iconResource.saveToFile(iconTarget)) {\n-                iconTarget = null;\n-            }\n-        }\n-\n-        writeCfgFile(params);\n-\n-        \/\/ Copy executable to bin folder\n-        Path executableFile = appLayout.launchersDirectory().resolve(\n-                getLauncherName(params));\n-\n-        try (InputStream is_launcher =\n-                getResourceAsStream(getLauncherResourceName(params))) {\n-            writeEntry(is_launcher, executableFile);\n-        }\n-\n-        \/\/ Update branding of launcher executable\n-        new ExecutableRebrander().rebrandLauncher(params, iconTarget, executableFile);\n-\n-        executableFile.toFile().setExecutable(true);\n-        executableFile.toFile().setReadOnly();\n-    }\n-}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WindowsAppImageBuilder.java","additions":0,"deletions":145,"binary":false,"changes":145,"status":"deleted"},{"patch":"@@ -28,0 +28,6 @@\n+import jdk.jpackage.internal.model.WinLauncher;\n+import jdk.jpackage.internal.model.WinMsiPackage;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.DottedVersion;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.util.PathGroup;\n@@ -31,1 +37,0 @@\n-import java.nio.file.Files;\n@@ -35,1 +40,0 @@\n-import java.util.Collections;\n@@ -45,0 +49,1 @@\n+import java.util.function.Function;\n@@ -48,0 +53,1 @@\n+import static java.util.stream.Collectors.toMap;\n@@ -57,9 +63,2 @@\n-import jdk.jpackage.internal.AppImageFile.LauncherInfo;\n-import jdk.jpackage.internal.util.XmlConsumer;\n-import static jdk.jpackage.internal.StandardBundlerParam.APP_NAME;\n-import static jdk.jpackage.internal.StandardBundlerParam.INSTALL_DIR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VENDOR;\n-import static jdk.jpackage.internal.StandardBundlerParam.VERSION;\n-import static jdk.jpackage.internal.WinMsiBundler.MSI_SYSTEM_WIDE;\n-import static jdk.jpackage.internal.WinMsiBundler.SERVICE_INSTALLER;\n-import static jdk.jpackage.internal.WinMsiBundler.WIN_APP_IMAGE;\n+import static jdk.jpackage.internal.util.CollectionUtils.toCollection;\n+import jdk.jpackage.internal.model.WinLauncherMixin.WinShortcut;\n@@ -67,2 +66,2 @@\n-import jdk.jpackage.internal.model.DottedVersion;\n-import jdk.jpackage.internal.util.PathGroup;\n+import jdk.jpackage.internal.model.AppImageLayout;\n+import jdk.jpackage.internal.model.FileAssociation;\n@@ -71,0 +70,2 @@\n+import jdk.jpackage.internal.util.XmlConsumer;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n@@ -76,1 +77,1 @@\n-class WixAppImageFragmentBuilder extends WixFragmentBuilder {\n+final class WixAppImageFragmentBuilder extends WixFragmentBuilder {\n@@ -79,4 +80,2 @@\n-    void initFromParams(Map<String, ? super Object> params) {\n-        super.initFromParams(params);\n-\n-        Path appImageRoot = WIN_APP_IMAGE.fetchFrom(params);\n+    void initFromParams(BuildEnv env, WinMsiPackage pkg) {\n+        super.initFromParams(env, pkg);\n@@ -84,7 +83,1 @@\n-        Supplier<ApplicationLayout> appImageSupplier = () -> {\n-            if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-                return ApplicationLayout.javaRuntime();\n-            } else {\n-                return ApplicationLayout.platformAppImage();\n-            }\n-        };\n+        Path appImageRoot = env.appImageDir();\n@@ -92,1 +85,1 @@\n-        systemWide = MSI_SYSTEM_WIDE.fetchFrom(params);\n+        systemWide = pkg.isSystemWideInstall();\n@@ -95,3 +88,3 @@\n-                VENDOR.fetchFrom(params),\n-                APP_NAME.fetchFrom(params),\n-                VERSION.fetchFrom(params)).toString();\n+                pkg.app().vendor(),\n+                pkg.app().name(),\n+                pkg.version()).toString();\n@@ -100,7 +93,1 @@\n-                WINDOWS_INSTALL_DIR.fetchFrom(params));\n-\n-        do {\n-            ApplicationLayout layout = appImageSupplier.get();\n-            \/\/ Don't want AppImageFile.FILENAME in installed application.\n-            new InstallableFile(AppImageFile.getPathInAppImage(Path.of(\"\")),\n-                    null).excludeFromApplicationLayout(layout);\n+                pkg.relativeInstallDir());\n@@ -108,5 +95,4 @@\n-            \/\/ Want absolute paths to source files in generated WiX sources.\n-            \/\/ This is to handle scenario if sources would be processed from\n-            \/\/ different current directory.\n-            appImage = layout.resolveAt(appImageRoot.toAbsolutePath().normalize());\n-        } while (false);\n+        \/\/ Want absolute paths to source files in generated WiX sources.\n+        \/\/ This is to handle scenario if sources would be processed from\n+        \/\/ different current directory.\n+        initAppImageLayouts(pkg.appImageLayout(), appImageRoot.toAbsolutePath().normalize());\n@@ -114,1 +100,1 @@\n-        installedAppImage = appImageSupplier.get().resolveAt(INSTALLDIR);\n+        launchers = toCollection(pkg.app().launchers());\n@@ -116,9 +102,1 @@\n-        shortcutFolders = Stream.of(ShortcutsFolder.values()).filter(\n-                shortcutFolder -> shortcutFolder.requested(params)).collect(\n-                        Collectors.toSet());\n-\n-        if (StandardBundlerParam.isRuntimeInstaller(params)) {\n-            launchers = Collections.emptyList();\n-        } else {\n-            launchers = AppImageFile.getLaunchers(appImageRoot, params);\n-        }\n+        shortcutFolders = ShortcutsFolder.getForPackage(pkg);\n@@ -127,1 +105,1 @@\n-                .filter(LauncherInfo::isService)\n+                .filter(Launcher::isService)\n@@ -129,3 +107,2 @@\n-                    var launcherPath = addExeSuffixToPath(\n-                    installedAppImage.launchersDirectory().resolve(\n-                            launcher.getName()));\n+                    var launcherPath = installedAppImage.launchersDirectory().resolve(\n+                            launcher.executableNameWithSuffix());\n@@ -133,1 +110,1 @@\n-                    return new WixLauncherAsService(launcher.getName(), params)\n+                    return new WixLauncherAsService(pkg.app(), launcher, env::createResource)\n@@ -139,1 +116,0 @@\n-            serviceInstaller = SERVICE_INSTALLER.fetchFrom(params);\n@@ -141,0 +117,1 @@\n+            final var serviceInstallerPath = pkg.serviceInstaller().orElseThrow();\n@@ -142,1 +119,1 @@\n-                    serviceInstaller.srcPath().toAbsolutePath().normalize(),\n+                    serviceInstallerPath.toAbsolutePath().normalize(),\n@@ -144,1 +121,1 @@\n-                            serviceInstaller.installPath()));\n+                            serviceInstallerPath.getFileName()));\n@@ -147,1 +124,1 @@\n-        programMenuFolderName = MENU_GROUP.fetchFrom(params);\n+        programMenuFolderName = pkg.startMenuGroupName();\n@@ -149,1 +126,7 @@\n-        initFileAssociations(params);\n+        if (!pkg.isRuntimeInstaller()) {\n+            packageFile = new PackageFile(pkg.packageName());\n+        } else {\n+            packageFile = null;\n+        }\n+\n+        initFileAssociations();\n@@ -156,0 +139,3 @@\n+        if (packageFile != null) {\n+            packageFile.save(ApplicationLayout.build().setAll(getConfigRoot()).create());\n+        }\n@@ -190,21 +176,0 @@\n-    private void normalizeFileAssociation(FileAssociation fa) {\n-        fa.launcherPath = addExeSuffixToPath(\n-                installedAppImage.launchersDirectory().resolve(fa.launcherPath));\n-\n-        if (fa.iconPath != null && !Files.exists(fa.iconPath)) {\n-            fa.iconPath = null;\n-        }\n-\n-        if (fa.iconPath != null) {\n-            fa.iconPath = fa.iconPath.toAbsolutePath();\n-        }\n-\n-        \/\/ Filter out empty extensions.\n-        fa.extensions = fa.extensions.stream().filter(Predicate.not(\n-                String::isEmpty)).toList();\n-    }\n-\n-    private static Path addExeSuffixToPath(Path path) {\n-        return PathUtils.addSuffix(path, \".exe\");\n-    }\n-\n@@ -212,1 +177,1 @@\n-        String fname = String.format(\"fa_%s.ico\", String.join(\"_\", fa.extensions));\n+        String fname = String.format(\"fa_%s.ico\", fa.extension());\n@@ -216,6 +181,4 @@\n-    private void initFileAssociations(Map<String, ? super Object> params) {\n-        associations = FileAssociation.fetchFrom(params).stream()\n-                .peek(this::normalizeFileAssociation)\n-                \/\/ Filter out file associations without extensions.\n-                .filter(fa -> !fa.extensions.isEmpty())\n-                .toList();\n+    private void initFileAssociations() {\n+        associations = launchers.stream().collect(toMap(\n+                Launcher::executableNameWithSuffix,\n+                WinLauncher::fileAssociations));\n@@ -223,1 +186,1 @@\n-        associations.stream().filter(fa -> fa.iconPath != null).forEach(fa -> {\n+        associations.values().stream().flatMap(List::stream).filter(FileAssociation::hasIcon).toList().forEach(fa -> {\n@@ -226,2 +189,2 @@\n-            appImage.pathGroup().setPath(key, fa.iconPath);\n-            installedAppImage.pathGroup().setPath(key, getInstalledFaIcoPath(fa));\n+            appImagePathGroup.setPath(key, fa.icon().orElseThrow().toAbsolutePath().normalize());\n+            installedAppImagePathGroup.setPath(key, getInstalledFaIcoPath(fa));\n@@ -231,0 +194,19 @@\n+    private void initAppImageLayouts(AppImageLayout appImageLayout, Path appImageRoot) {\n+        var srcAppImageLayout = appImageLayout.resolveAt(appImageRoot);\n+\n+        var installedAppImageLayout = appImageLayout.resolveAt(INSTALLDIR);\n+\n+        appImagePathGroup = AppImageLayout.toPathGroup(srcAppImageLayout);\n+        installedAppImagePathGroup = AppImageLayout.toPathGroup(installedAppImageLayout);\n+\n+        if (srcAppImageLayout instanceof ApplicationLayout appLayout) {\n+            \/\/ Don't want app image info file in installed application.\n+            var appImageFile = AppImageFile.getPathInAppImage(appLayout);\n+            appImagePathGroup.ghostPath(appImageFile);\n+\n+            installedAppImage = (ApplicationLayout)installedAppImageLayout;\n+        } else {\n+            installedAppImage = null;\n+        }\n+    }\n+\n@@ -379,2 +361,1 @@\n-        componentIds = componentIds.stream().filter(Objects::nonNull).collect(\n-                Collectors.toList());\n+        componentIds = componentIds.stream().filter(Objects::nonNull).toList();\n@@ -472,2 +453,5 @@\n-        for (var fa : associations) {\n-            componentIds.addAll(addFaComponents(xml, fa));\n+        for (var entry : associations.entrySet()) {\n+            var launcherExe = entry.getKey();\n+            for (var fa : entry.getValue()) {\n+                componentIds.add(addFaComponent(xml, launcherExe, fa));\n+            }\n@@ -484,7 +468,2 @@\n-                Path launcherPath = addExeSuffixToPath(installedAppImage\n-                        .launchersDirectory().resolve(launcher.getName()));\n-\n-                if ((launcher.isMenu() &&\n-                        (folder.equals(ShortcutsFolder.ProgramMenu))) ||\n-                    (launcher.isShortcut() &&\n-                        (folder.equals(ShortcutsFolder.Desktop)))) {\n+                Path launcherPath = installedAppImage.launchersDirectory().resolve(\n+                        launcher.executableNameWithSuffix());\n@@ -492,2 +471,2 @@\n-                    String componentId = addShortcutComponent(xml, launcherPath,\n-                            folder);\n+                if (folder.isRequestedFor(launcher)) {\n+                    String componentId = addShortcutComponent(xml, launcherPath, folder);\n@@ -543,14 +522,3 @@\n-    private List<String> addFaComponents(XMLStreamWriter xml,\n-            FileAssociation fa) throws XMLStreamException, IOException {\n-        List<String> components = new ArrayList<>();\n-        for (var extension: fa.extensions) {\n-            Path path = INSTALLDIR.resolve(String.format(\"%s_%s\", extension,\n-                    fa.launcherPath.getFileName()));\n-            components.add(addComponent(xml, path, Component.ProgId, unused -> {\n-                xml.writeAttribute(\"Description\", fa.description);\n-\n-                if (fa.iconPath != null) {\n-                    xml.writeAttribute(\"Icon\", Id.File.of(getInstalledFaIcoPath(\n-                            fa)));\n-                    xml.writeAttribute(\"IconIndex\", \"0\");\n-                }\n+    private String addFaComponent(XMLStreamWriter xml,\n+            String launcherExe, FileAssociation fa) throws\n+            XMLStreamException, IOException {\n@@ -558,3 +526,3 @@\n-                xml.writeStartElement(\"Extension\");\n-                xml.writeAttribute(\"Id\", extension);\n-                xml.writeAttribute(\"Advertise\", \"no\");\n+        Path path = INSTALLDIR.resolve(String.format(\"%s_%s\", fa.extension(), launcherExe));\n+        return addComponent(xml, path, Component.ProgId, unused -> {\n+            xml.writeAttribute(\"Description\", fa.description().orElseThrow());\n@@ -562,4 +530,4 @@\n-                var mimeIt = fa.mimeTypes.iterator();\n-                if (mimeIt.hasNext()) {\n-                    String mime = mimeIt.next();\n-                    xml.writeAttribute(\"ContentType\", mime);\n+            if (fa.hasIcon()) {\n+                xml.writeAttribute(\"Icon\", Id.File.of(getInstalledFaIcoPath(fa)));\n+                xml.writeAttribute(\"IconIndex\", \"0\");\n+            }\n@@ -567,8 +535,3 @@\n-                    if (!defaultedMimes.contains(mime)) {\n-                        xml.writeStartElement(\"MIME\");\n-                        xml.writeAttribute(\"ContentType\", mime);\n-                        xml.writeAttribute(\"Default\", \"yes\");\n-                        xml.writeEndElement();\n-                        defaultedMimes.add(mime);\n-                    }\n-                }\n+            xml.writeStartElement(\"Extension\");\n+            xml.writeAttribute(\"Id\", fa.extension());\n+            xml.writeAttribute(\"Advertise\", \"no\");\n@@ -576,6 +539,2 @@\n-                xml.writeStartElement(\"Verb\");\n-                xml.writeAttribute(\"Id\", \"open\");\n-                xml.writeAttribute(\"Command\", \"!(loc.ContextMenuCommandLabel)\");\n-                xml.writeAttribute(\"Argument\", \"\\\"%1\\\" %*\");\n-                xml.writeAttribute(\"TargetFile\", Id.File.of(fa.launcherPath));\n-                xml.writeEndElement(); \/\/ <Verb>\n+            var mime = fa.mimeType();\n+            xml.writeAttribute(\"ContentType\", mime);\n@@ -583,3 +542,7 @@\n-                xml.writeEndElement(); \/\/ <Extension>\n-            }));\n-        }\n+            if (!defaultedMimes.contains(mime)) {\n+                xml.writeStartElement(\"MIME\");\n+                xml.writeAttribute(\"ContentType\", mime);\n+                xml.writeAttribute(\"Default\", \"yes\");\n+                xml.writeEndElement();\n+                defaultedMimes.add(mime);\n+            }\n@@ -587,1 +550,10 @@\n-        return components;\n+            xml.writeStartElement(\"Verb\");\n+            xml.writeAttribute(\"Id\", \"open\");\n+            xml.writeAttribute(\"Command\", \"!(loc.ContextMenuCommandLabel)\");\n+            xml.writeAttribute(\"Argument\", \"\\\"%1\\\" %*\");\n+            xml.writeAttribute(\"TargetFile\", Id.File.of(\n+                    installedAppImage.launchersDirectory().resolve(launcherExe)));\n+            xml.writeEndElement(); \/\/ <Verb>\n+\n+            xml.writeEndElement(); \/\/ <Extension>\n+        });\n@@ -632,1 +604,2 @@\n-    private void startDirectoryElement(XMLStreamWriter xml, String wix3ElementName, Path path) throws XMLStreamException {\n+    private void startDirectoryElement(XMLStreamWriter xml,\n+            String wix3ElementName, Path path) throws XMLStreamException {\n@@ -673,1 +646,1 @@\n-        appImage.transform(installedAppImage, new PathGroup.TransformHandler() {\n+        appImagePathGroup.transform(installedAppImagePathGroup, new PathGroup.TransformHandler() {\n@@ -697,0 +670,5 @@\n+        \/\/ The installed \"app\" directory is never empty as it contains at least \".package\" file.\n+        \/\/ However, the \"app\" directory in the source app image can be empty because the \".package\"\n+        \/\/ file is picked from the build config directory, not from the source app image.\n+        Optional.ofNullable(installedAppImage).map(ApplicationLayout::appDirectory).ifPresent(emptyDirs::remove);\n+\n@@ -734,1 +712,1 @@\n-        appImage.transform(installedAppImage, new PathGroup.TransformHandler() {\n+        appImagePathGroup.transform(installedAppImagePathGroup, new PathGroup.TransformHandler() {\n@@ -739,4 +717,0 @@\n-\n-            @Override\n-            public void createDirectory(final Path dir) throws IOException {\n-            }\n@@ -750,0 +724,8 @@\n+        if (packageFile != null) {\n+            files.add(Map.entry(\n+                    PackageFile.getPathInAppImage(\n+                            ApplicationLayout.build().setAll(\n+                                    getConfigRoot().toAbsolutePath().normalize()).create()),\n+                    PackageFile.getPathInAppImage(installedAppImage)));\n+        }\n+\n@@ -817,3 +799,0 @@\n-        PathGroup srcPathGroup = appImage.pathGroup();\n-        PathGroup dstPathGroup = installedAppImage.pathGroup();\n-\n@@ -822,1 +801,1 @@\n-        srcPathGroup.transform(dstPathGroup, new PathGroup.TransformHandler() {\n+        appImagePathGroup.transform(installedAppImagePathGroup, new PathGroup.TransformHandler() {\n@@ -829,4 +808,0 @@\n-\n-            @Override\n-            public void createDirectory(Path dst) throws IOException {\n-            }\n@@ -934,1 +909,1 @@\n-        ProgramMenu(PROGRAM_MENU_PATH, Arguments.CLIOptions.WIN_MENU_HINT,\n+        ProgramMenu(PROGRAM_MENU_PATH, WinShortcut.WIN_SHORTCUT_START_MENU,\n@@ -936,1 +911,1 @@\n-        Desktop(DESKTOP_PATH, Arguments.CLIOptions.WIN_SHORTCUT_HINT,\n+        Desktop(DESKTOP_PATH, WinShortcut.WIN_SHORTCUT_DESKTOP,\n@@ -939,1 +914,1 @@\n-        private ShortcutsFolder(Path root, Arguments.CLIOptions cliOption,\n+        private ShortcutsFolder(Path root, WinShortcut shortcutId,\n@@ -942,8 +917,1 @@\n-            this.bundlerParam = new StandardBundlerParam<>(\n-                    cliOption.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    \/\/ valueOf(null) is false,\n-                    \/\/ and we actually do want null in some cases\n-                    (s, p) -> (s == null || \"null\".equalsIgnoreCase(s)) ? false : Boolean.valueOf(s)\n-            );\n+            this.shortcutId = shortcutId;\n@@ -961,2 +929,2 @@\n-        boolean requested(Map<String, ? super Object> params) {\n-            return bundlerParam.fetchFrom(params);\n+        boolean isRequestedFor(WinLauncher launcher) {\n+            return launcher.shortcuts().contains(shortcutId);\n@@ -969,0 +937,10 @@\n+        static Set<ShortcutsFolder> getForPackage(WinMsiPackage pkg) {\n+            var launchers = Optional.ofNullable(pkg.app().launchers()).map(\n+                    List::stream).orElseGet(Stream::of);\n+            return  launchers.map(launcher -> {\n+                return Stream.of(ShortcutsFolder.values()).filter(shortcutsFolder -> {\n+                    return shortcutsFolder.isRequestedFor((WinLauncher)launcher);\n+                });\n+            }).flatMap(Function.identity()).collect(Collectors.toSet());\n+        }\n+\n@@ -972,1 +950,1 @@\n-        private final StandardBundlerParam<Boolean> bundlerParam;\n+        private final WinShortcut shortcutId;\n@@ -983,1 +961,1 @@\n-    private List<FileAssociation> associations;\n+    private Map<String, List<FileAssociation>> associations;\n@@ -987,1 +965,1 @@\n-    private List<LauncherInfo> launchers;\n+    private List<WinLauncher> launchers;\n@@ -993,1 +971,0 @@\n-    private ApplicationLayout appImage;\n@@ -996,0 +973,3 @@\n+    private PathGroup appImagePathGroup;\n+    private PathGroup installedAppImagePathGroup;\n+\n@@ -999,0 +979,2 @@\n+    private PackageFile packageFile;\n+\n@@ -1023,34 +1005,0 @@\n-\n-    private static final StandardBundlerParam<String> MENU_GROUP =\n-            new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.WIN_MENU_GROUP.getId(),\n-                    String.class,\n-                    params -> I18N.getString(\"param.menu-group.default\"),\n-                    (s, p) -> s\n-            );\n-\n-    private static final BundlerParamInfo<String> WINDOWS_INSTALL_DIR =\n-            new StandardBundlerParam<>(\n-            \"windows-install-dir\",\n-            String.class,\n-            params -> {\n-                 String dir = INSTALL_DIR.fetchFrom(params);\n-                 if (dir != null) {\n-                     if (dir.contains(\":\") || dir.contains(\"..\")) {\n-                         Log.error(MessageFormat.format(I18N.getString(\n-                                \"message.invalid.install.dir\"), dir,\n-                                APP_NAME.fetchFrom(params)));\n-                     } else {\n-                        if (dir.startsWith(\"\\\\\")) {\n-                             dir = dir.substring(1);\n-                        }\n-                        if (dir.endsWith(\"\\\\\")) {\n-                             dir = dir.substring(0, dir.length() - 1);\n-                        }\n-                        return dir;\n-                     }\n-                 }\n-                 return APP_NAME.fetchFrom(params); \/\/ Default to app name\n-             },\n-            (s, p) -> s\n-    );\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixAppImageFragmentBuilder.java","additions":158,"deletions":210,"binary":false,"changes":368,"status":"modified"},{"patch":"@@ -41,1 +41,0 @@\n-import static jdk.jpackage.internal.StandardBundlerParam.CONFIG_ROOT;\n@@ -43,1 +42,0 @@\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n@@ -47,0 +45,1 @@\n+import jdk.jpackage.internal.model.WinMsiPackage;\n@@ -69,1 +68,1 @@\n-    void initFromParams(Map<String, ? super Object> params) {\n+    void initFromParams(BuildEnv env, WinMsiPackage pkg) {\n@@ -72,2 +71,2 @@\n-        configRoot = CONFIG_ROOT.fetchFrom(params);\n-        fragmentResource = createResource(defaultResourceName, params).setPublicName(outputFileName);\n+        configRoot = env.configDir();\n+        fragmentResource = env.createResource(defaultResourceName).setPublicName(outputFileName);\n@@ -124,1 +123,1 @@\n-    final protected Map<WixNamespace, String> getWixNamespaces() {\n+    protected final Map<WixNamespace, String> getWixNamespaces() {\n@@ -149,1 +148,1 @@\n-    final protected Path getConfigRoot() {\n+    protected final Path getConfigRoot() {\n@@ -155,1 +154,1 @@\n-    final protected void defineWixVariable(String variableName) {\n+    protected final void defineWixVariable(String variableName) {\n@@ -159,1 +158,1 @@\n-    final protected void setWixVariable(String variableName, String variableValue) {\n+    protected final void setWixVariable(String variableName, String variableValue) {\n@@ -166,1 +165,1 @@\n-    final protected void addResource(OverridableResource resource, String saveAsName) {\n+    protected final void addResource(OverridableResource resource, String saveAsName) {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixFragmentBuilder.java","additions":9,"deletions":10,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-import java.util.Map;\n+import java.util.function.Function;\n@@ -41,1 +41,2 @@\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n+import jdk.jpackage.internal.model.WinApplication;\n+import jdk.jpackage.internal.model.WinLauncher;\n@@ -50,3 +51,3 @@\n-    WixLauncherAsService(String name, Map<String, ? super Object> mainParams) {\n-        super(name, mainParams,\n-                createResource(\"service-install.wxi\", mainParams).setCategory(\n+    WixLauncherAsService(WinApplication app, WinLauncher launcher, Function<String, OverridableResource> createResource) {\n+        super(app, launcher,\n+                createResource.apply(\"service-install.wxi\").setCategory(\n@@ -55,1 +56,1 @@\n-        serviceConfigResource = createResource(\"service-config.wxi\", mainParams).setCategory(\n+        serviceConfigResource = createResource.apply(\"service-config.wxi\").setCategory(\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixLauncherAsService.java","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,0 +55,1 @@\n+import jdk.jpackage.internal.resources.ResourceLocator;\n@@ -73,1 +74,1 @@\n-        new OverridableResource(\"wix3-to-wix4-conv.xsl\")\n+        new OverridableResource(\"wix3-to-wix4-conv.xsl\", ResourceLocator.class)\n@@ -163,1 +164,1 @@\n-    final static class ResourceGroup {\n+    static final class ResourceGroup {\n@@ -418,1 +419,1 @@\n-    private final static Set<String> KNOWN_NAMESPACES = Set.of(\n+    private static final Set<String> KNOWN_NAMESPACES = Set.of(\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixSourceConverter.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import jdk.jpackage.internal.model.WinMsiPackage;\n@@ -39,1 +40,0 @@\n-import java.util.stream.Stream;\n@@ -42,3 +42,0 @@\n-import jdk.jpackage.internal.util.XmlConsumer;\n-import static jdk.jpackage.internal.OverridableResource.createResource;\n-import static jdk.jpackage.internal.StandardBundlerParam.LICENSE_FILE;\n@@ -47,0 +44,2 @@\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+import jdk.jpackage.internal.util.XmlConsumer;\n@@ -54,2 +53,2 @@\n-    void initFromParams(Map<String, ? super Object> params) {\n-        super.initFromParams(params);\n+    void initFromParams(BuildEnv env, WinMsiPackage pkg) {\n+        super.initFromParams(env, pkg);\n@@ -57,2 +56,1 @@\n-        String licenseFile = LICENSE_FILE.fetchFrom(params);\n-        withLicenseDlg = licenseFile != null;\n+        withLicenseDlg = pkg.licenseFile().isPresent();\n@@ -60,1 +58,1 @@\n-            Path licenseFileName = IOUtils.getFileName(Path.of(licenseFile));\n+            Path licenseFileName = pkg.licenseFile().orElseThrow().getFileName();\n@@ -65,1 +63,1 @@\n-        withInstallDirChooserDlg = INSTALLDIR_CHOOSER.fetchFrom(params);\n+        withInstallDirChooserDlg = pkg.withInstallDirChooser();\n@@ -67,5 +65,1 @@\n-        List<ShortcutsFolder> shortcutFolders = Stream.of(\n-                ShortcutsFolder.values()).filter(shortcutFolder -> {\n-            return shortcutFolder.requested(params)\n-                    && SHORTCUT_PROMPT.fetchFrom(params);\n-        }).toList();\n+        final var shortcutFolders = ShortcutsFolder.getForPackage(pkg);\n@@ -73,1 +67,1 @@\n-        withShortcutPromptDlg = !shortcutFolders.isEmpty();\n+        withShortcutPromptDlg = !shortcutFolders.isEmpty() && pkg.withShortcutPrompt();\n@@ -78,1 +72,1 @@\n-            CustomDialog dialog = new CustomDialog(params, I18N.getString(\n+            CustomDialog dialog = new CustomDialog(env::createResource, I18N.getString(\n@@ -89,1 +83,1 @@\n-            CustomDialog dialog = new CustomDialog(params, I18N.getString(\n+            CustomDialog dialog = new CustomDialog(env::createResource, I18N.getString(\n@@ -130,1 +124,1 @@\n-            try (InputStream is = OverridableResource.readDefault(fname)) {\n+            try (InputStream is = ResourceLocator.class.getResourceAsStream(fname)) {\n@@ -512,1 +506,1 @@\n-        CustomDialog(Map<String, ? super Object> params, String category,\n+        CustomDialog(Function<String, OverridableResource> createResource, String category,\n@@ -517,1 +511,1 @@\n-            addResource(createResource(wxsFileName, params).setCategory(category).setPublicName(\n+            addResource(createResource.apply(wxsFileName).setCategory(category).setPublicName(\n@@ -535,16 +529,0 @@\n-\n-    private static final BundlerParamInfo<Boolean> INSTALLDIR_CHOOSER\n-            = new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.WIN_DIR_CHOOSER.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    (s, p) -> Boolean.valueOf(s)\n-            );\n-\n-    private static final StandardBundlerParam<Boolean> SHORTCUT_PROMPT\n-            = new StandardBundlerParam<>(\n-                    Arguments.CLIOptions.WIN_SHORTCUT_PROMPT.getId(),\n-                    Boolean.class,\n-                    params -> false,\n-                    (s, p) -> Boolean.valueOf(s)\n-            );\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WixUiFragmentBuilder.java","additions":16,"deletions":38,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-import java.text.MessageFormat;\n+import static jdk.jpackage.internal.model.I18N.buildLocalizedException;\n@@ -48,3 +48,3 @@\n-            throw new IllegalArgumentException(MessageFormat.format(\n-                    I18N.getString(\"error.msi-product-version-components\"),\n-                    value));\n+            throw buildLocalizedException()\n+                    .message(\"error.msi-product-version-components\", value)\n+                    .create(IllegalArgumentException::new);\n@@ -54,2 +54,3 @@\n-            throw new IllegalArgumentException(I18N.getString(\n-                    \"error.msi-product-version-major-out-of-range\"));\n+            throw buildLocalizedException()\n+                    .message(\"error.msi-product-version-major-out-of-range\")\n+                    .create(IllegalArgumentException::new);\n@@ -60,2 +61,3 @@\n-            throw new IllegalArgumentException(I18N.getString(\n-                    \"error.msi-product-version-minor-out-of-range\"));\n+            throw buildLocalizedException()\n+                    .message(\"error.msi-product-version-minor-out-of-range\")\n+                    .create(IllegalArgumentException::new);\n@@ -66,2 +68,3 @@\n-            throw new IllegalArgumentException(I18N.getString(\n-                    \"error.msi-product-version-build-out-of-range\"));\n+            throw buildLocalizedException()\n+                    .message(\"error.msi-product-version-build-out-of-range\")\n+                    .create(IllegalArgumentException::new);\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/MsiVersion.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface WinApplication extends Application, WinApplicationMixin {\n+\n+    public static WinApplication create(Application app) {\n+        return CompositeProxy.create(WinApplication.class, app, new WinApplicationMixin.Stub(app));\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinApplication.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+public interface WinApplicationMixin {\n+\n+    DottedVersion winVersion();\n+\n+    record Stub(DottedVersion winVersion) implements WinApplicationMixin {\n+        public Stub(Application app) {\n+            this(DottedVersion.greedy(app.version()));\n+        }\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinApplicationMixin.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,51 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import static jdk.jpackage.internal.model.StandardPackageType.WIN_EXE;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface WinExePackage extends Package, WinExePackageMixin {\n+\n+    public static WinExePackage create(WinMsiPackage msiPackage, Optional<Path> icon) {\n+        return CompositeProxy.create(WinExePackage.class, createExePackage(\n+                msiPackage), new WinExePackageMixin.Stub(msiPackage, icon));\n+    }\n+\n+    private static Package createExePackage(WinMsiPackage pkg) {\n+        return new Package.Stub(\n+                pkg.app(),\n+                WIN_EXE,\n+                pkg.packageName(),\n+                pkg.description(),\n+                pkg.version(),\n+                pkg.aboutURL(),\n+                pkg.licenseFile(),\n+                pkg.predefinedAppImage(),\n+                pkg.relativeInstallDir());\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinExePackage.java","additions":51,"deletions":0,"binary":false,"changes":51,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+\n+public interface WinExePackageMixin {\n+\n+    WinMsiPackage msiPackage();\n+\n+    Optional<Path> icon();\n+\n+    record Stub(WinMsiPackage msiPackage, Optional<Path> icon) implements WinExePackageMixin {}\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinExePackageMixin.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import static java.util.stream.Collectors.toMap;\n+\n+import java.io.InputStream;\n+import java.util.Map;\n+import java.util.Optional;\n+import jdk.jpackage.internal.resources.ResourceLocator;\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface WinLauncher extends Launcher, WinLauncherMixin {\n+\n+    @Override\n+    default Optional<String> executableSuffix() {\n+        return Optional.of(\".exe\");\n+    }\n+\n+    @Override\n+    default InputStream executableResource() {\n+        return ResourceLocator.class.getResourceAsStream(\n+                isConsole() ? \"jpackageapplauncher.exe\" : \"jpackageapplauncherw.exe\");\n+    }\n+\n+    @Override\n+    default Map<String, String> extraAppImageFileData() {\n+        return shortcuts().stream().collect(toMap(WinShortcut::name, v -> Boolean.toString(true)));\n+    }\n+\n+    public static WinLauncher create(Launcher launcher, WinLauncherMixin mixin) {\n+        return CompositeProxy.create(WinLauncher.class, launcher, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncher.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,53 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Set;\n+\n+public interface WinLauncherMixin {\n+\n+    boolean isConsole();\n+\n+    enum WinShortcut {\n+        WIN_SHORTCUT_DESKTOP(\"shortcut\"),\n+        WIN_SHORTCUT_START_MENU(\"menu\"),\n+        ;\n+\n+        WinShortcut(String name) {\n+            this.name = name;\n+        }\n+\n+        public String getName() {\n+            return name;\n+        }\n+\n+        private final String name;\n+    }\n+\n+    Set<WinShortcut> shortcuts();\n+\n+    record Stub(boolean isConsole, Set<WinShortcut> shortcuts) implements WinLauncherMixin {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinLauncherMixin.java","additions":53,"deletions":0,"binary":false,"changes":53,"status":"added"},{"patch":"@@ -0,0 +1,36 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import jdk.jpackage.internal.util.CompositeProxy;\n+\n+public interface WinMsiPackage extends Package, WinMsiPackageMixin {\n+\n+    WinApplication app();\n+\n+    public static WinMsiPackage create(Package pkg, WinMsiPackageMixin mixin) {\n+        return CompositeProxy.create(WinMsiPackage.class, pkg, mixin);\n+    }\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinMsiPackage.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.nio.file.Path;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+public interface WinMsiPackageMixin {\n+\n+    DottedVersion msiVersion();\n+\n+    boolean withInstallDirChooser();\n+\n+    boolean withShortcutPrompt();\n+\n+    Optional<String> helpURL();\n+\n+    Optional<String> updateURL();\n+\n+    String startMenuGroupName();\n+\n+    boolean isSystemWideInstall();\n+\n+    UUID upgradeCode();\n+\n+    UUID productCode();\n+\n+    Optional<Path> serviceInstaller();\n+\n+    record Stub(DottedVersion msiVersion, boolean withInstallDirChooser, boolean withShortcutPrompt,\n+            Optional<String> helpURL, Optional<String> updateURL, String startMenuGroupName,\n+            boolean isSystemWideInstall, UUID upgradeCode, UUID productCode,\n+            Optional<Path> serviceInstaller) implements WinMsiPackageMixin {}\n+}\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/model\/WinMsiPackageMixin.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,196 @@\n+#!\/bin\/bash\n+\n+# Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+\n+#\n+# Filters output produced by running jpackage with \"jpackage.test.stash-root=<PATH>\" property.\n+#\n+\n+set -e\n+set -o pipefail\n+\n+\n+declare -a stash_dirs\n+if [ $# -eq 0 ]; then\n+  stash_dirs=(${0%\/*})\n+else\n+  stash_dirs=($@)\n+fi\n+\n+\n+sed_inplace_option=-i\n+sed_version_string=$(sed --version 2>&1 | head -1 || true)\n+if [ \"${sed_version_string#sed (GNU sed)}\" != \"$sed_version_string\" ]; then\n+  # GNU sed, the default\n+  :\n+elif [ \"${sed_version_string#sed: illegal option}\" != \"$sed_version_string\" ]; then\n+  # Macos sed\n+  sed_inplace_option=\"-i ''\"\n+else\n+  echo 'WARNING: Unknown sed variant, assume it is GNU compatible'\n+fi\n+\n+\n+winActions='\n+'\n+winMsiActions='\n+  winMsiRmDotPackage\n+  winMsiFilterAppImageListing\n+  winMsiFilterUiWxf\n+  winMsiFilterBundleWxf\n+'\n+winAllActions=\"${winActions} ${winMsiActions}\"\n+\n+macActions='\n+  macFormatInfoPlist\n+  macFormatEntitlements\n+'\n+macPkgActions='\n+  macPkgFormatCplPlist\n+'\n+macDmgActions='\n+  macDmgFilterScpt\n+'\n+macAllActions=\"${macActions} ${macDmgActions} ${macPkgActions}\"\n+\n+linuxActions=\n+linuxRpmActions=\n+linuxDebActions=\n+linuxAllActions=\"${linuxActions} ${linuxRpmActions} ${linuxDebActions}\"\n+\n+actions='\n+  rmPostImageScript\n+  sortAppImageListing\n+'\n+allActions=\"${actions} ${winAllActions} ${macAllActions} ${linuxAllActions}\"\n+\n+\n+rmPostImageScript() {\n+  # Remove post-image scripts\n+  find \"$stash_dir\" '(' -name '*-post-image.sh' -o -name '*-post-image.wsf' ')' -type f -exec rm -f {} \\;\n+}\n+\n+sortAppImageListing() {\n+  # Sort app image listings\n+  find \"$stash_dir\" -name 'app-image-listing.txt' -type f -exec sort -o {} {} \\;\n+}\n+\n+\n+#\n+# MAC:\n+#\n+\n+macFormatInfoPlist() {\n+  # Info.plist\n+  # - Format\n+  find \"$stash_dir\" -name 'Info.plist' -type f -exec xmllint --output '{}' --format '{}' \\;\n+}\n+\n+macFormatEntitlements() {\n+  # *.entitlements\n+  # - Format\n+  find \"$stash_dir\" -name '*.entitlements' -type f -exec xmllint --output '{}' --format '{}' \\;\n+}\n+\n+#\n+# DMG:\n+#\n+\n+macDmgFilterScpt() {\n+  # *.scpt\n+  #  - Trim random absolute temp path\n+  #  - Replace \"\/dmg-workdir\/\" (new) with \"\/images\/\" (old)\n+  find \"$stash_dir\" -name '*.scpt' -type f | xargs -I {} sed $sed_inplace_option \\\n+      -e 's|\"\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"\/jdk.jpackage\/|' \\\n+      -e 's|\"file:\/\/\/.*\/jdk.jpackage[0-9]\\{1,\\}\/|\"file:\/\/\/jdk.jpackage\/|' \\\n+      -e 's|\/dmg-workdir\/|\/images\/|' \\\n+      '{}'\n+}\n+\n+#\n+# PKG:\n+#\n+\n+macPkgFormatCplPlist() {\n+  # cpl.plist:\n+  # - Format and strip <!DOCTYPE ...> (old)\n+  find \"$stash_dir\" -name 'cpl.plist' -type f -exec xmllint --output '{}' --dropdtd --format '{}' \\;\n+}\n+\n+\n+#\n+# WIN:\n+#\n+\n+#\n+# MSI:\n+#\n+\n+winMsiRmDotPackage() {\n+  # .package\n+  # - Strip it. Old jpackage created this file in the app image.\n+  #   New jpackage creates it in the \"config\" directory.\n+  #   Value is verified in tests, can ignore it here.\n+  find \"$stash_dir\" -name '.package' -type f -exec rm -f {} \\;\n+}\n+\n+winMsiFilterAppImageListing() {\n+  # app-image-listing.txt:\n+  # - Remove \"app\\.jpackage.xml\" and \"app\\.package\" entries. The new jpackage doesn't create them in the app image\n+  find \"$stash_dir\" -path '*msi\/*\/app-image-listing.txt' -type f | xargs -I {} sed $sed_inplace_option \\\n+      -e '\/^app\\\\\\.package[\\r]\\{0,\\}$\/d' \\\n+      -e '\/^app\\\\\\.jpackage\\.xml[\\r]\\{0,\\}$\/d' \\\n+      '{}'\n+}\n+\n+winMsiFilterUiWxf() {\n+  # ui.wxf:\n+  # - Order of namespaces is undefined, strip them for simplicity\n+  find \"$stash_dir\" -name 'ui.wxf' -type f | xargs -I {} sed $sed_inplace_option \\\n+      -e 's|^<Wix[^>]*>|<Wix>|' \\\n+      '{}'\n+}\n+\n+winMsiFilterBundleWxf() {\n+  # bundle.wxf:\n+  # - Order of namespaces is undefined, strip them for simplicity (same as with ui.wxf)\n+  # - Trim paths down to file names in \"Source\" attributes.\n+  #   They all are different because the new jpackage doesn't copy app images.\n+  # - Order of files and directories is undefined, sort xml.\n+  #   It turns the file into garbage, but all that matters is that the\n+  #   old and the new jpackage variants should produce the same \"garbage\"\n+  find \"$stash_dir\" -name 'bundle.wxf' -type f | xargs -I {} sed $sed_inplace_option \\\n+      -e 's|^<Wix[^>]*>|<Wix>|' \\\n+      -e 's|Source=\".*\\\\\\([^\\\\]\\{1,\\}\\)\"|Source=\"\\1\"|' \\\n+      -e 's|Source=\"\\\\jdk.jpackage\\\\images\\\\win-msi.image\\\\.*\\\\app\\\\\\.package\"|Source=\"\\\\jdk.jpackage\\\\config\\\\\\.package\"|' \\\n+      '{}'\n+  find \"$stash_dir\" -name 'bundle.wxf' -type f -exec sort -o {} {} \\;\n+}\n+\n+\n+for stash_dir in \"${stash_dirs[@]}\"; do\n+  printf \"In %s:\\n\" \"$stash_dir\"\n+  for a in ${allActions}; do\n+    echo \"  $a...\"\n+    $a\n+  done\n+done\n","filename":"test\/jdk\/tools\/jpackage\/clean_stashed_files.sh","additions":196,"deletions":0,"binary":false,"changes":196,"status":"added"},{"patch":"@@ -396,1 +396,7 @@\n-            }).collect(toMap(tokens -> tokens[0], tokens -> tokens[1], (oldValue, newValue) -> {\n+            }).collect(toMap(tokens -> tokens[0], tokens -> {\n+                if (tokens.length == 1) {\n+                    return \"\";\n+                } else {\n+                    return tokens[1];\n+                }\n+            }, (oldValue, newValue) -> {\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/AdditionalLauncher.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,392 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.test;\n+\n+import static java.util.stream.Collectors.joining;\n+import static jdk.jpackage.internal.util.function.ThrowingConsumer.toConsumer;\n+import static jdk.jpackage.test.ApplicationLayout.linuxUsrTreePackageImage;\n+import static jdk.jpackage.test.ApplicationLayout.platformAppImage;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+import java.util.stream.Stream;\n+import jdk.internal.util.OperatingSystem;\n+import jdk.jpackage.test.JPackageUserScript.WinGlobals;\n+\n+final class ConfigFilesStasher {\n+\n+    private enum RootDirExpr {\n+        CONFIG_DIR(\"fs.GetFolder(fs.GetParentFolderName(WScript.ScriptFullName))\", \"${0%\/*}\"),\n+        IMAGE_DIR(\"fs.GetFolder(shell.CurrentDirectory)\", \"${PWD}\");\n+\n+        private RootDirExpr(String jsExpr, String shellExpr) {\n+            this.expr = TKit.isWindows() ? jsExpr : shellExpr;\n+        }\n+\n+        String expr() {\n+            return expr;\n+        }\n+\n+        SrcPath srcPath(WildcardPath path) {\n+            return new SrcPath(this, path);\n+        }\n+\n+        SrcPath srcPath(Path path) {\n+            return srcPath(WildcardPath.create(path));\n+        }\n+\n+        private final String expr;\n+    }\n+\n+    private static Path prepareStashDir(JPackageCommand cmd, Path stashRoot) throws IOException {\n+        final var pwd = Path.of(\"\").toAbsolutePath();\n+        final var absTestWorkDir = TKit.workDir().toAbsolutePath();\n+        final var relativeTestWorkDir = pwd.relativize(absTestWorkDir).normalize();\n+        if (relativeTestWorkDir.getNameCount() >= absTestWorkDir.getNameCount()) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        final var stashTestRoot = stashRoot.resolve(relativeTestWorkDir);\n+\n+        if (!absTestWorkDir.equals(currentTestWorkDir)) {\n+            currentTestWorkDir = absTestWorkDir;\n+            TKit.deleteDirectoryContentsRecursive(stashTestRoot);\n+        }\n+\n+        final var stashTestBasedir = stashTestRoot.resolve(stashDirBasedir(cmd));\n+        Files.createDirectories(stashTestBasedir);\n+\n+        final var stashDir = TKit.createUniquePath(stashTestBasedir.resolve(\"item\"));\n+\n+        Files.createDirectories(stashDir);\n+\n+        return stashDir;\n+    }\n+\n+    private static Path stashDirBasedir(JPackageCommand cmd) {\n+        if (cmd.isImagePackageType()) {\n+            return Path.of(\"app-image\", OperatingSystem.current().name().toLowerCase());\n+        } else {\n+            return Path.of(cmd.packageType().getType());\n+        }\n+    }\n+\n+    private static void stash(JPackageCommand cmd, Path stashRoot) throws IOException {\n+        final var script = createStashScript(cmd,  stashRoot);\n+        if (!script.isEmpty()) {\n+            if (cmd.isImagePackageType()) {\n+                final var stashScript = TKit.createTempFile(\"stash-script\" + JPackageUserScript.scriptFilenameExtension());\n+                JPackageUserScript.create(stashScript, script);\n+                var pwd = cmd.outputBundle();\n+                if (TKit.isWindows()) {\n+                    pwd = WindowsHelper.toShortPath(pwd.toAbsolutePath()).orElse(pwd);\n+                }\n+                Executor.of(shell(), stashScript.toAbsolutePath().toString()).setDirectory(pwd).dumpOutput().execute();\n+            } else {\n+                JPackageUserScript.POST_IMAGE.create(cmd, script);\n+            }\n+        }\n+    }\n+\n+    private static List<String> createStashScript(JPackageCommand cmd, Path stashRoot) throws IOException {\n+        if ((cmd.packageType() == PackageType.WIN_EXE)) {\n+            \/\/ Skip for exe, msi is sufficient.\n+            return List.of();\n+        }\n+\n+        if (!cmd.isImagePackageType() && Files.exists(setupDirectory(cmd, \"--resource-dir\").resolve(JPackageUserScript.POST_IMAGE.scriptName(cmd)))) {\n+            \/\/ The command already has a \"post-image\" script configured, don't disturb it.\n+            return List.of();\n+        }\n+\n+        final var stashDir = prepareStashDir(cmd, stashRoot);\n+\n+        final List<String> script = new ArrayList<>();\n+        if (TKit.isWindows()) {\n+            List.of(WinGlobals.JS_LIST_DIR_RECURSIVE, WinGlobals.JS_SHELL, WinGlobals.JS_FS).forEach(v -> {\n+                v.appendTo(script::addAll);\n+            });\n+        } else {\n+            script.addAll(List.of(\"set -e\", \"set -o pipefail\"));\n+        }\n+\n+        script.addAll(listAppImage(stashDir.resolve(\"app-image-listing.txt\")));\n+\n+        if (!cmd.isImagePackageType()) {\n+            script.addAll(copyDirExpr(RootDirExpr.CONFIG_DIR, Path.of(\"\"), stashDir.resolve(\"config\")));\n+        }\n+\n+        if (cmd.packageType() == PackageType.LINUX_DEB) {\n+            script.addAll(copyDirExpr(RootDirExpr.IMAGE_DIR, Path.of(\"DEBIAN\"), stashDir.resolve(\"DEBIAN\")));\n+        }\n+\n+        if (cmd.packageType() == PackageType.LINUX_RPM) {\n+            script.addAll(copyDirExpr(RootDirExpr.CONFIG_DIR, Path.of(\"..\/SPECS\"), stashDir.resolve(\"SPECS\")));\n+        }\n+\n+        if (cmd.isRuntime()) {\n+            \/\/ Runtume packages don't have \"Info.plist\", though they should. See JDK-8351073\n+            return script;\n+        }\n+\n+        final var appLayout = appImageAppLayout(cmd);\n+\n+        script.addAll(copyFileExpr(RootDirExpr.IMAGE_DIR, WildcardPath.create(appLayout.appDirectory(), \"*.cfg\"), stashDir.resolve(\"cfg-files\")));\n+\n+        if (TKit.isLinux()) {\n+            for (final var wildcard : List.of(\"*.desktop\", \"*-MimeInfo.xml\")) {\n+                script.addAll(copyFileExpr(RootDirExpr.IMAGE_DIR, WildcardPath.create(appLayout.desktopIntegrationDirectory(), wildcard), stashDir.resolve(\"desktop\")));\n+            }\n+            if (isWithServices(cmd)) {\n+                script.addAll(copyDirExpr(RootDirExpr.IMAGE_DIR, Path.of(\"lib\/systemd\/system\"), stashDir.resolve(\"systemd\")));\n+            }\n+        }\n+\n+        if (cmd.packageType() == PackageType.MAC_PKG) {\n+            if (isWithServices(cmd)) {\n+                script.addAll(copyDirExpr(RootDirExpr.CONFIG_DIR, Path.of(\"..\/services\"), stashDir.resolve(\"services\")));\n+                script.addAll(copyDirExpr(RootDirExpr.CONFIG_DIR, Path.of(\"..\/support\"), stashDir.resolve(\"support\")));\n+            }\n+        }\n+\n+        if (TKit.isOSX()) {\n+            script.addAll(copyFileExpr(RootDirExpr.IMAGE_DIR, WildcardPath.create(appLayout.contentDirectory().resolve(\"Info.plist\")), stashDir.resolve(\"Info.plist\")));\n+        }\n+\n+        return script;\n+    }\n+\n+    private static String shell() {\n+        if (OperatingSystem.isWindows()) {\n+            return \"cscript\";\n+        }\n+        return Optional.ofNullable(System.getenv(\"SHELL\")).orElseGet(() -> \"sh\");\n+    }\n+\n+    private static ApplicationLayout appImageAppLayout(JPackageCommand cmd) {\n+        if (cmd.isRuntime()) {\n+            throw new UnsupportedOperationException();\n+        }\n+\n+        if (cmd.isImagePackageType()) {\n+            return platformAppImage();\n+        }\n+\n+        if (PackageType.LINUX.contains(cmd.packageType())) {\n+            final var installDir = cmd.getArgumentValue(\"--install-dir\");\n+            if (Optional.ofNullable(installDir).map(Set.of(\"\/usr\", \"\/usr\/local\")::contains).orElse(false)) {\n+                return linuxUsrTreePackageImage(Path.of(\"\/\").relativize(Path.of(installDir)), LinuxHelper.getPackageName(cmd));\n+            } else {\n+                return platformAppImage().resolveAt(Path.of(\"\/\").relativize(cmd.appInstallationDirectory()));\n+            }\n+        } else {\n+            return platformAppImage();\n+        }\n+    }\n+\n+    private static boolean isWithServices(JPackageCommand cmd) {\n+        boolean[] withServices = new boolean[1];\n+        withServices[0] = cmd.hasArgument(\"--launcher-as-service\");\n+        if (!withServices[0]) {\n+            AdditionalLauncher.forEachAdditionalLauncher(cmd, (launcherName, propertyFilePath) -> {\n+                try {\n+                    final var launcherAsService = new AdditionalLauncher.PropertyFile(propertyFilePath)\n+                            .getPropertyBooleanValue(\"launcher-as-service\").orElse(false);\n+                    if (launcherAsService) {\n+                        withServices[0] = true;\n+                    }\n+                } catch (IOException ex) {\n+                    throw new UncheckedIOException(ex);\n+                }\n+            });\n+        }\n+        return withServices[0];\n+    }\n+\n+    private static List<String> listAppImage(Path to) {\n+        final var fromPath = RootDirExpr.IMAGE_DIR.srcPath(Path.of(\"\"));\n+        if (TKit.isWindows()) {\n+            final String toStr = to.toString().replace('\\\\', '\/');\n+            return List.of(\n+                    String.format(\"WScript.Echo('Save listing of %s into [%s]')\",\n+                            fromPath.label(), toStr),\n+                    String.format(\"var o = fs.CreateTextFile('%s', true)\", toStr),\n+                    String.format(\"listDir(fs.GetFolder(%s), fs.GetFolder(%s))\", fromPath.expr(), fromPath.expr()),\n+                    \"o.Close()\"\n+            );\n+        } else {\n+            return List.of(\n+                    String.format(\"printf 'Save listing of %%s into [%%s]\\\\n' '%s' '%s'\",\n+                            fromPath.label(), to),\n+                    String.format(\"(cd %s; find . > '%s')\", fromPath.expr(), to)\n+            );\n+        }\n+    }\n+\n+    private static List<String> copyDirExpr(RootDirExpr root, Path from, Path to) {\n+        return copyExpr(root, WildcardPath.create(from), to, new Expr(\"fs.CopyFolder(%s, '%s')\", \"cp -R %s '%s'\"));\n+    }\n+\n+    private static List<String> copyFileExpr(RootDirExpr root, WildcardPath from, Path to) {\n+        return copyExpr(root, from, to, new Expr(\"fs.CopyFile(%s, '%s')\", \"cp %s '%s'\"));\n+    }\n+\n+    private static List<String> copyExpr(RootDirExpr root, WildcardPath from, Path to, Expr copyFormatExpr) {\n+        final String format = new Expr(\n+                \"WScript.Echo('Copy %s into [%s]')\\n%s\",\n+                \"printf 'Copy %%s into [%%s]\\\\n' '%s' '%s'\\n%s\"\n+        ).value();\n+\n+        final var toStr = to.toString().replace('\\\\', '\/');\n+        final var fromPath = root.srcPath(from);\n+\n+        final String copyExpr;\n+        if (from.wildcardName().isEmpty()) {\n+            copyExpr = String.format(copyFormatExpr.value(), fromPath.expr(), toStr);\n+        } else {\n+            \/\/ To copy wildcard names, the destination directory must exist.\n+            final var mkdirExpr = (new Expr(\n+                    String.format(\"if (!fs.FolderExists('%s')) fs.CreateFolder('%s')\", toStr, toStr),\n+                    String.format(\"mkdir -p '%s'\", toStr)\n+            ).value());\n+\n+            final var copyExprBody = Stream.of(\n+                    mkdirExpr,\n+                    String.format(copyFormatExpr.value(), fromPath.expr(), toStr + '\/')\n+            ).map(str -> {\n+                return \"  \" + str;\n+            }).collect(joining(\"\\n\"));\n+\n+            \/\/ Copying will fail for a wildcard expression without matches, make it conditional.\n+            copyExpr = new Expr(\n+                    String.format(\"if (fs.FolderExists(%s) || fs.FileExists(%s)) {\\n%s\\n}\", fromPath.expr(), fromPath.expr(), copyExprBody),\n+                    String.format(\"v=$(printf '%%s' %s)\\nif [ \\\"${v%%\/'%s'}\\\" = \\\"$v\\\" ]; then\\n%s\\nfi\", fromPath.expr(), from.wildcardName(), copyExprBody)\n+            ).value();\n+        }\n+\n+        return List.of(String.format(format, fromPath.label(), toStr, copyExpr));\n+    }\n+\n+    private record WildcardPath(Path basedir, String wildcardName) {\n+        WildcardPath {\n+            Objects.requireNonNull(basedir);\n+            Objects.requireNonNull(wildcardName);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            final var sb = new StringBuilder();\n+            sb.append(basedir);\n+            if (!wildcardName.isEmpty()) {\n+                sb.append(File.separator);\n+                sb.append(wildcardName);\n+            }\n+            return sb.toString();\n+        }\n+\n+        static WildcardPath create(Path path) {\n+            return new WildcardPath(path, \"\");\n+        }\n+\n+        static WildcardPath create(Path basedir, String wildcardName) {\n+            return new WildcardPath(basedir, wildcardName);\n+        }\n+    }\n+\n+    private record Expr(String jsValue, String shellValue) {\n+        Expr {\n+            Objects.requireNonNull(jsValue);\n+            Objects.requireNonNull(shellValue);\n+        }\n+\n+        String value() {\n+            if (TKit.isWindows()) {\n+                return jsValue;\n+            } else {\n+                return shellValue;\n+            }\n+        }\n+    }\n+\n+    private record SrcPath(RootDirExpr root, WildcardPath path) {\n+        SrcPath {\n+            Objects.requireNonNull(root);\n+            if (path.basedir().isAbsolute()) {\n+                throw new IllegalArgumentException();\n+            }\n+        }\n+\n+        String label() {\n+            if (isPathEmpty()) {\n+                return String.format(\"${%s}\", root.name());\n+            } else {\n+                return String.format(\"${%s}\/%s\", root.name(), path.toString().replace('\\\\', '\/'));\n+            }\n+        }\n+\n+        String expr() {\n+            if (isPathEmpty()) {\n+                return new Expr(root.expr(), String.format(\"\\\"%s\\\"\", root.expr())).value();\n+            } else {\n+                final String shellExpr;\n+                if (path.wildcardName().isEmpty()) {\n+                    shellExpr = String.format(\"\\\"%s\/%s\\\"\", root.expr(), path);\n+                } else {\n+                    shellExpr = String.format(\"\\\"%s\/%s\\\"\/%s\", root.expr(), path.basedir(), path.wildcardName());\n+                }\n+                return new Expr(String.format(\"%s + '\/%s'\", root.expr(), path.toString().replace('\\\\', '\/')), shellExpr).value();\n+            }\n+        }\n+\n+        private boolean isPathEmpty() {\n+            return path.toString().isEmpty();\n+        }\n+    }\n+\n+    private static Path setupDirectory(JPackageCommand cmd, String argName) {\n+        if (!cmd.hasArgument(argName)) {\n+            \/\/ Use absolute path as jpackage can be executed in another directory\n+            cmd.setArgumentValue(argName, TKit.createTempDirectory(\"stash-script-resource-dir\").toAbsolutePath());\n+        }\n+\n+        return Path.of(cmd.getArgumentValue(argName));\n+    }\n+\n+    private static Path currentTestWorkDir;\n+\n+    static final Consumer<JPackageCommand> INSTANCE = Optional.ofNullable(TKit.getConfigProperty(\"stash-root\"))\n+            .map(Path::of).map(Path::toAbsolutePath).<Consumer<JPackageCommand>>map(stashRoot -> {\n+                return toConsumer(cmd -> {\n+                    stash(cmd, stashRoot);\n+                });\n+            }).orElse(cmd -> {});\n+}\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/ConfigFilesStasher.java","additions":392,"deletions":0,"binary":false,"changes":392,"status":"added"},{"patch":"@@ -854,0 +854,4 @@\n+        if (expectedExitCode == 0 && !isImagePackageType()) {\n+            ConfigFilesStasher.INSTANCE.accept(this);\n+        }\n+\n@@ -862,0 +866,4 @@\n+        if (expectedExitCode == 0 && isImagePackageType()) {\n+            ConfigFilesStasher.INSTANCE.accept(this);\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageCommand.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Collection;\n@@ -37,0 +38,1 @@\n+import java.util.function.Consumer;\n@@ -47,0 +49,4 @@\n+        this.suffix = suffix + scriptFilenameExtension();\n+    }\n+\n+    static String scriptFilenameExtension() {\n@@ -48,1 +54,1 @@\n-            this.suffix = suffix + \".wsf\";\n+            return \".wsf\";\n@@ -50,1 +56,1 @@\n-            this.suffix = suffix + \".sh\";\n+            return \".sh\";\n@@ -56,1 +62,11 @@\n-        JS_FS(\"var fs = new ActiveXObject('Scripting.FileSystemObject')\");\n+        JS_FS(\"var fs = new ActiveXObject('Scripting.FileSystemObject')\"),\n+        JS_LIST_DIR_RECURSIVE(List.of(\n+                \"function listDir (dir, root) {\",\n+                \"    o.WriteLine((root === undefined) ? dir.Path : dir.Path.substring(1 + root.Path.length))\",\n+                \"    for(var e = new Enumerator(dir.Files); !e.atEnd(); e.moveNext()) {\",\n+                \"        o.WriteLine((root === undefined) ? e.item().Path : e.item().Path.substring(1 + root.Path.length))\",\n+                \"    }\",\n+                \"    for(var e = new Enumerator(dir.SubFolders); !e.atEnd(); e.moveNext()) {\",\n+                \"        listDir(e.item(), root)\",\n+                \"    }\",\n+                \"}\"));\n@@ -59,0 +75,4 @@\n+            this(List.of(expr));\n+        }\n+\n+        WinGlobals(List<String> expr) {\n@@ -62,1 +82,1 @@\n-        public String expr() {\n+        public List<String> expr() {\n@@ -66,1 +86,5 @@\n-        private final String expr;\n+        public void appendTo(Consumer<Collection<String>> acc) {\n+            acc.accept(expr);\n+        }\n+\n+        private final List<String> expr;\n@@ -196,2 +220,2 @@\n-                script.add(WinGlobals.JS_SHELL.expr());\n-                script.add(WinGlobals.JS_FS.expr());\n+                script.addAll(WinGlobals.JS_SHELL.expr());\n+                script.addAll(WinGlobals.JS_FS.expr());\n@@ -243,1 +267,1 @@\n-    private void create(Path scriptFilePath, List<String> script) {\n+    static void create(Path scriptFilePath, List<String> script) {\n@@ -258,1 +282,1 @@\n-            TKit.traceFileContents(scriptFilePath, String.format(\"[%s] script\", name()));\n+            TKit.traceFileContents(scriptFilePath, String.format(\"[%s] script\", scriptFilePath.getFileName()));\n@@ -264,0 +288,4 @@\n+    String scriptName(JPackageCommand cmd) {\n+        return String.format(\"%s-%s\", cmd.name(), suffix);\n+    }\n+\n@@ -265,1 +293,1 @@\n-        return Path.of(cmd.getArgumentValue(\"--resource-dir\"), String.format(\"%s-%s\", cmd.name(), suffix));\n+        return Path.of(cmd.getArgumentValue(\"--resource-dir\"), scriptName(cmd));\n@@ -298,0 +326,4 @@\n+                List.of(WinGlobals.JS_LIST_DIR_RECURSIVE, WinGlobals.JS_SHELL, WinGlobals.JS_FS).forEach(v -> {\n+                    v.appendTo(script::addAll);\n+                });\n+\n@@ -299,11 +331,0 @@\n-                        \"function listDir (dir) {\",\n-                        \"    o.WriteLine(dir.Path)\",\n-                        \"    for(var e = new Enumerator(dir.Files); !e.atEnd(); e.moveNext()) {\",\n-                        \"        o.WriteLine(e.item().Path)\",\n-                        \"    }\",\n-                        \"    for(var e = new Enumerator(dir.SubFolders); !e.atEnd(); e.moveNext()) {\",\n-                        \"        listDir(e.item())\",\n-                        \"    }\",\n-                        \"}\",\n-                        WinGlobals.JS_FS.expr(),\n-                        WinGlobals.JS_SHELL.expr(),\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/JPackageUserScript.java","additions":42,"deletions":21,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -296,2 +296,2 @@\n-    private static Path createUniquePath(String defaultName) {\n-        return createUniquePath(defaultName, workDir());\n+    static Path createUniquePath(Path pathTemplate) {\n+        return createUniquePath(pathTemplate.getFileName().toString(), pathTemplate.getParent());\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/TKit.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5,0 +5,1 @@\n+        jdk.jpackage\/jdk.jpackage.internal.pipeline:+open \\\n@@ -6,3 +7,1 @@\n-        jdk.jpackage\/jdk.jpackage.internal.util.function:+open \\\n-        java.base\/jdk.internal.util \\\n-        jdk.jlink\/jdk.tools.jlink.internal\n+        jdk.jpackage\/jdk.jpackage.internal.util.function:+open\n","filename":"test\/jdk\/tools\/jpackage\/junit\/TEST.properties","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,3 @@\n+import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n+import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n+\n@@ -31,0 +34,1 @@\n+import java.util.HashMap;\n@@ -33,1 +37,4 @@\n-import java.util.LinkedHashMap;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n@@ -35,4 +42,8 @@\n-import static org.junit.jupiter.api.Assertions.assertEquals;\n-import static org.junit.jupiter.api.Assertions.assertFalse;\n-import static org.junit.jupiter.api.Assertions.assertThrowsExactly;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n+import jdk.jpackage.internal.AppImageFile.LauncherInfo;\n+import jdk.jpackage.internal.model.Application;\n+import jdk.jpackage.internal.model.ApplicationLaunchers;\n+import jdk.jpackage.internal.model.ApplicationLayout;\n+import jdk.jpackage.internal.model.ConfigException;\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LauncherStartupInfo;\n+import org.junit.jupiter.api.Assertions;\n@@ -42,0 +53,1 @@\n+import org.junit.jupiter.params.provider.Arguments;\n@@ -47,0 +59,84 @@\n+    static AppImageBuilder build() {\n+        return new AppImageBuilder();\n+    }\n+\n+    static class AppImageBuilder {\n+\n+        AppImageBuilder version(String v) {\n+            version = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        AppImageBuilder launcherName(String v) {\n+            launcherName = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        AppImageBuilder mainClass(String v) {\n+            mainClass = Objects.requireNonNull(v);\n+            return this;\n+        }\n+\n+        AppImageBuilder addExtra(Map<String, String> v) {\n+            extra.putAll(v);\n+            return this;\n+        }\n+\n+        AppImageBuilder addExtra(String key, String value) {\n+            extra.putAll(Map.of(key, value));\n+            return this;\n+        }\n+\n+        AppImageBuilder addlauncher(String name) {\n+            return addlauncher(name, false);\n+        }\n+\n+        AppImageBuilder addlauncher(String name, boolean isService) {\n+            return addlauncher(name, isService, Map.of());\n+        }\n+\n+        AppImageBuilder addlauncher(String name, boolean isService, Map<String, String> extra) {\n+            Objects.requireNonNull(name);\n+            Objects.requireNonNull(extra);\n+            addLauncherInfos.add(new LauncherInfo(name, isService, extra));\n+            return this;\n+        }\n+\n+        AppImageBuilder addlauncher(String name, Map<String, String> extra) {\n+            return addlauncher(name, false, extra);\n+        }\n+\n+        AppImageFile create() {\n+            final var additionalLaunchers = addLauncherInfos.stream().map(li -> {\n+                return (Launcher)new Launcher.Stub(li.name(), Optional.empty(),\n+                        List.of(), li.service(), null, Optional.empty(), null, li.extra());\n+            }).toList();\n+\n+            final var startupInfo = new LauncherStartupInfo.Stub(mainClass, List.of(), List.of(), List.of());\n+            final var mainLauncher = new Launcher.Stub(launcherName, Optional.of(startupInfo),\n+                    List.of(), false, null, Optional.empty(), null, Map.of());\n+\n+            final var app = new Application.Stub(null, null, version, null, null,\n+                    Optional.empty(), List.of(), null, Optional.empty(),\n+                    new ApplicationLaunchers(mainLauncher, additionalLaunchers).asList(), extra);\n+\n+            return new AppImageFile(app);\n+        }\n+\n+        void createInDir(Path dir) {\n+            final var file = create();\n+            final var copy = toSupplier(() -> {\n+                file.save(DUMMY_LAYOUT.resolveAt(dir));\n+                return AppImageFile.load(dir, DUMMY_LAYOUT);\n+            }).get();\n+\n+            assertEquals(file, copy);\n+        }\n+\n+        private String version = \"1.0\";\n+        private String launcherName = \"Foo\";\n+        private String mainClass = \"Main\";\n+        private Map<String, String> extra = new HashMap<>();\n+        private List<LauncherInfo> addLauncherInfos = new ArrayList<>();\n+    }\n+\n@@ -48,9 +144,12 @@\n-    public void testIdentity() throws IOException {\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        params.put(Arguments.CLIOptions.NAME.getId(), \"Foo\");\n-        params.put(Arguments.CLIOptions.APPCLASS.getId(), \"TestClass\");\n-        params.put(Arguments.CLIOptions.VERSION.getId(), \"2.3\");\n-        params.put(Arguments.CLIOptions.DESCRIPTION.getId(), \"Duck is the King\");\n-        AppImageFile aif = create(params);\n-\n-        assertEquals(\"Foo\", aif.getLauncherName());\n+    public void testSimple() {\n+        build().createInDir(tempFolder);\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testExtra(Map<String, String> extra) {\n+        build().addExtra(extra).createInDir(tempFolder);\n+    }\n+\n+    private static Stream<Map<String, String>> testExtra() {\n+        return Stream.of(Map.of(\"a\", \"b\"), Map.of(\"foo\", \"\"));\n@@ -60,16 +159,5 @@\n-    public void testInvalidCommandLine() throws IOException {\n-        \/\/ Just make sure AppImageFile will tolerate jpackage params that would\n-        \/\/ never create app image at both load\/save phases.\n-        \/\/ People would edit this file just because they can.\n-        \/\/ We should be ready to handle curious minds.\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        params.put(\"invalidParamName\", \"randomStringValue\");\n-        params.put(Arguments.CLIOptions.APPCLASS.getId(), \"TestClass\");\n-        params.put(Arguments.CLIOptions.MAIN_JAR.getId(), \"test.jar\");\n-        create(params);\n-\n-        params = new LinkedHashMap<>();\n-        params.put(Arguments.CLIOptions.NAME.getId(), \"foo\");\n-        params.put(Arguments.CLIOptions.APPCLASS.getId(), \"TestClass\");\n-        params.put(Arguments.CLIOptions.VERSION.getId(), \"1.0\");\n-        create(params);\n+    public void testAdditionalLaunchers() {\n+        build().addlauncher(\"T\")\n+                .addlauncher(\"U\", true)\n+                .addlauncher(\"F\", Map.of(\"prop\", \"one\", \"prop2\", \"two\", \"prop3\", \"\"))\n+                .createInDir(tempFolder);\n@@ -80,4 +168,4 @@\n-    public void testInavlidXml(String[] xmlData) throws IOException {\n-        Exception ex = assertThrowsExactly(RuntimeException.class, () -> createFromXml(xmlData));\n-        assertTrue(ex.getMessage().contains(\"generated by another jpackage version or malformed\"));\n-        assertTrue(ex.getMessage().endsWith(\".jpackage.xml\\\"\"));\n+    public void testInavlidXml(List<String> xmlData) throws IOException {\n+        assertThrowsExactly(ConfigException.class, () -> createFromXml(xmlData), () -> {\n+            return I18N.format(\"error.invalid-app-image\", tempFolder, \".jpackage.xml\");\n+        });\n@@ -86,22 +174,7 @@\n-    private static Stream<org.junit.jupiter.params.provider.Arguments> testInavlidXml() {\n-        return Stream.of(\n-                makeArguments((Object)new String[] {\"<foo\/>\"}),\n-                makeArguments((Object)new String[] {\"<jpackage-state\/>\"}),\n-                makeArguments((Object)new String[] {JPACKAGE_STATE_OPEN, \"<\/jpackage-state>\"}),\n-                makeArguments((Object)new String[] {\n-                        JPACKAGE_STATE_OPEN,\n-                        \"<main-launcher><\/main-launcher>\",\n-                        \"<\/jpackage-state>\"\n-                }),\n-                makeArguments((Object)new String[] {\n-                        JPACKAGE_STATE_OPEN,\n-                        \"<main-launcher>Foo<\/main-launcher>\",\n-                        \"<main-class><\/main-class>\",\n-                        \"<\/jpackage-state>\"\n-                }),\n-                makeArguments((Object)new String[] {\n-                        JPACKAGE_STATE_OPEN,\n-                        \"<launcher>A<\/launcher>\",\n-                        \"<launcher>B<\/launcher>\",\n-                        \"<\/jpackage-state>\"\n-                })\n+    private static Stream<List<String>> testInavlidXml() {\n+        return Stream.of(List.of(\"<foo\/>\"),\n+                List.of(\"<jpackage-state\/>\"),\n+                createXml(),\n+                createXml(\"<main-launcher><\/main-launcher>\"),\n+                createXml(\"<main-launcher>Foo<\/main-launcher>\", \"<main-class><\/main-class>\"),\n+                createXml(\"<add-launcher>A<\/add-launcher>\")\n@@ -113,4 +186,3 @@\n-    public void testValidXml(String expectedLauncherName, String xmlData[]) throws IOException {\n-        var file = createFromXml(xmlData);\n-        assertEquals(expectedLauncherName, file.getLauncherName());\n-        assertTrue(file.getAddLaunchers().isEmpty());\n+    public void testValidXml(AppImageFile expected, List<String> xmlData) throws IOException, ConfigException {\n+        final var actual = createFromXml(xmlData);\n+        assertEquals(expected, actual);\n@@ -119,1 +191,1 @@\n-    private static Stream<org.junit.jupiter.params.provider.Arguments> testValidXml() {\n+    private static Stream<Arguments> testValidXml() {\n@@ -121,8 +193,4 @@\n-                makeArguments(\"Foo\", List.of(\n-                        JPACKAGE_STATE_OPEN,\n-                                \"<app-version>1.0<\/app-version>\",\n-                                \"<main-launcher>Foo<\/main-launcher>\",\n-                                \"<main-class>main.Class<\/main-class>\",\n-                                \"<signed>false<\/signed>\",\n-                                \"<app-store>false<\/app-store>\",\n-                        \"<\/jpackage-state>\").toArray(String[]::new)\n+                Arguments.of(build().version(\"72\").launcherName(\"Y\").mainClass(\"main.Class\").create(), createXml(\n+                        \"<main-launcher>Y<\/main-launcher>\",\n+                        \"<app-version>72<\/app-version>\",\n+                        \"<main-class>main.Class<\/main-class>\")\n@@ -130,9 +198,14 @@\n-                makeArguments(\"Boo\", List.of(\n-                        JPACKAGE_STATE_OPEN,\n-                                \"<app-version>1.0<\/app-version>\",\n-                                \"<main-launcher>Boo<\/main-launcher>\",\n-                                \"<main-launcher>Bar<\/main-launcher>\",\n-                                \"<main-class>main.Class<\/main-class>\",\n-                                \"<signed>false<\/signed>\",\n-                                \"<app-store>false<\/app-store>\",\n-                            \"<\/jpackage-state>\").toArray(String[]::new)\n+                Arguments.of(build().addExtra(\"x\", \"property-x\").addExtra(\"signed\", \"false\")\n+                        .addExtra(\"y\", \"\").addlauncher(\"another-launcher\").addlauncher(\"service-launcher\", true)\n+                        .addlauncher(\"launcher-with-extra\", Map.of(\"a\", \"\", \"b\", \"\", \"c\", \"Q\"))\n+                        .addlauncher(\"service-launcher-with-extra\", true, Map.of(\"h\", \"F\")).create(), createXml(\n+                        \"<app-version>1.0<\/app-version>\",\n+                        \"<main-class>Main<\/main-class>\",\n+                        \"<y\/>\",\n+                        \"<x>property-x<\/x>\",\n+                        \"<signed>false<\/signed>\",\n+                        \"<add-launcher name='service-launcher' service='true'\/>\",\n+                        \"<add-launcher name='another-launcher'><\/add-launcher>\",\n+                        \"<add-launcher name='launcher-with-extra'><a><\/a><b\/><c>Q<\/c><\/add-launcher>\",\n+                        \"<add-launcher name='service-launcher-with-extra' service='true'><h>F<\/h><\/add-launcher>\",\n+                        \"<main-launcher>Foo<\/main-launcher>\")\n@@ -140,9 +213,20 @@\n-                makeArguments(\"duke\", List.of(\n-                        JPACKAGE_STATE_OPEN,\n-                                \"<app-version>1.0<\/app-version>\",\n-                                \"<main-launcher>duke<\/main-launcher>\",\n-                                \"<main-class>main.Class<\/main-class>\",\n-                                \"<signed>false<\/signed>\",\n-                                \"<app-store>false<\/app-store>\",\n-                                \"<launcher><\/launcher>\",\n-                        \"<\/jpackage-state>\").toArray(String[]::new)\n+                Arguments.of(build().addExtra(\"signed\", \"FalsE\").create(), createXml(\n+                        \"<app-version>1.2<\/app-version>\",\n+                        \"<app-version>1.0<\/app-version>\",\n+                        \"<main-class>OverwrittenMain<\/main-class>\",\n+                        \"<main-class>Main<\/main-class>\",\n+                        \"<main-launcher>Bar<\/main-launcher>\",\n+                        \"<main-launcher>Foo<\/main-launcher>\",\n+                        \"<signed>false<\/signed>\",\n+                        \"<signed>FalsE<\/signed>\")\n+                ),\n+                Arguments.of(build().addExtra(\"signed\", \"true\").addExtra(\"with-comment\", \"ab\")\n+                        .addlauncher(\"a\", Map.of(\"bar\", \"foo\")).create(), createXml(\n+                        \"<app-version>1.0<\/app-version>\",\n+                        \"<main-class>Main<\/main-class>\",\n+                        \"<main-launcher>Foo<\/main-launcher>\",\n+                        \"<signed>true<\/signed>\",\n+                        \"<with-comment>a<!-- This is a comment -->b<\/with-comment>\",\n+                        \"<add-launcher name='a'><name>foo<\/name><bar>foo<\/bar><service>true<\/service><\/add-launcher>\",\n+                        \"<other><nested>false<\/nested><\/other>\",\n+                        \"<another-other>A<child\/>B<\/another-other>\")\n@@ -153,97 +237,2 @@\n-    @Test\n-    public void testMainLauncherName() throws IOException {\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        params.put(\"name\", \"Foo\");\n-        params.put(\"main-class\", \"main.Class\");\n-        params.put(\"description\", \"Duck App Description\");\n-        AppImageFile aif = create(params);\n-\n-        assertEquals(\"Foo\", aif.getLauncherName());\n-    }\n-\n-    @Test\n-    public void testMainClass() throws IOException {\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        params.put(\"name\", \"Foo\");\n-        params.put(\"main-class\", \"main.Class\");\n-        params.put(\"description\", \"Duck App Description\");\n-        AppImageFile aif = create(params);\n-\n-        assertEquals(\"main.Class\", aif.getMainClass());\n-    }\n-\n-    @Test\n-    public void testMacSign() throws IOException {\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        params.put(\"name\", \"Foo\");\n-        params.put(\"main-class\", \"main.Class\");\n-        params.put(\"description\", \"Duck App Description\");\n-        params.put(\"mac-sign\", Boolean.TRUE);\n-        AppImageFile aif = create(params);\n-\n-        assertTrue(aif.isSigned());\n-    }\n-\n-    @Test\n-    public void testCopyAsSigned() throws IOException {\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        params.put(\"name\", \"Foo\");\n-        params.put(\"main-class\", \"main.Class\");\n-        params.put(\"description\", \"Duck App Description\");\n-        params.put(\"mac-sign\", Boolean.FALSE);\n-\n-        AppImageFile aif = create(params);\n-        assertFalse(aif.isSigned());\n-\n-        aif = aif.copyAsSigned();\n-        assertTrue(aif.isSigned());\n-    }\n-\n-    @Test\n-    public void testMacAppStore() throws IOException {\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        params.put(\"name\", \"Foo\");\n-        params.put(\"main-class\", \"main.Class\");\n-        params.put(\"description\", \"Duck App Description\");\n-        params.put(\"mac-app-store\", Boolean.TRUE);\n-        AppImageFile aif = create(params);\n-\n-        assertTrue(aif.isAppStore());\n-    }\n-\n-    @Test\n-    public void testAddLaunchers() throws IOException {\n-        Map<String, Object> params = new LinkedHashMap<>();\n-        List<Map<String, Object>> launchersAsMap = new ArrayList<>();\n-\n-        Map<String, Object> addLauncher2Params = new LinkedHashMap<>();\n-        addLauncher2Params.put(\"name\", \"Launcher2Name\");\n-        launchersAsMap.add(addLauncher2Params);\n-\n-        Map<String, Object> addLauncher3Params = new LinkedHashMap<>();\n-        addLauncher3Params.put(\"name\", \"Launcher3Name\");\n-        launchersAsMap.add(addLauncher3Params);\n-\n-        params.put(\"name\", \"Duke App\");\n-        params.put(\"main-class\", \"main.Class\");\n-        params.put(\"description\", \"Duke App Description\");\n-        params.put(\"add-launcher\", launchersAsMap);\n-        AppImageFile aif = create(params);\n-\n-        List<AppImageFile.LauncherInfo> addLaunchers = aif.getAddLaunchers();\n-        assertEquals(2, addLaunchers.size());\n-        List<String> names = new ArrayList<>();\n-        names.add(addLaunchers.get(0).getName());\n-        names.add(addLaunchers.get(1).getName());\n-\n-        assertTrue(names.contains(\"Launcher2Name\"));\n-        assertTrue(names.contains(\"Launcher3Name\"));\n-    }\n-\n-    private AppImageFile create(Map<String, Object> params) throws IOException {\n-        AppImageFile.save(tempFolder, params);\n-        return AppImageFile.load(tempFolder);\n-    }\n-\n-    private AppImageFile createFromXml(String... xmlData) throws IOException {\n-        Path path = AppImageFile.getPathInAppImage(tempFolder);\n+    private AppImageFile createFromXml(List<String> xmlData) throws IOException, ConfigException {\n+        Path path = AppImageFile.getPathInAppImage(DUMMY_LAYOUT.resolveAt(tempFolder));\n@@ -255,1 +244,1 @@\n-        data.addAll(List.of(xmlData));\n+        data.addAll(xmlData);\n@@ -260,1 +249,1 @@\n-        AppImageFile image = AppImageFile.load(tempFolder);\n+        AppImageFile image = AppImageFile.load(tempFolder, DUMMY_LAYOUT);\n@@ -264,2 +253,22 @@\n-    static org.junit.jupiter.params.provider.Arguments makeArguments(Object ... args) {\n-        return org.junit.jupiter.params.provider.Arguments.of(args);\n+    private static void assertEquals(AppImageFile expected, AppImageFile actual) {\n+        assertPropertyEquals(expected, actual, AppImageFile::getAppVersion);\n+        assertPropertyEquals(expected, actual, AppImageFile::getLauncherName);\n+        assertPropertyEquals(expected, actual, AppImageFile::getMainClass);\n+        assertPropertyEquals(expected, actual, AppImageFile::getExtra);\n+        Assertions.assertEquals(additionaLaunchersAsMap(expected), additionaLaunchersAsMap(actual));\n+    }\n+\n+    private static Map<String, AppImageFile.LauncherInfo> additionaLaunchersAsMap(AppImageFile file) {\n+        return file.getAddLaunchers().stream().collect(Collectors.toMap(AppImageFile.LauncherInfo::name, x -> x));\n+    }\n+\n+    private static <T, U> void assertPropertyEquals(T expected, T actual, Function<T, U> getProperty) {\n+        Assertions.assertEquals(getProperty.apply(expected), getProperty.apply(actual));\n+    }\n+\n+    private static final List<String> createXml(String ...xml) {\n+        final List<String> content = new ArrayList<>();\n+        content.add(String.format(\"<jpackage-state platform=\\\"%s\\\" version=\\\"%s\\\">\", AppImageFile.getPlatform(), AppImageFile.getVersion()));\n+        content.addAll(List.of(xml));\n+        content.add(\"<\/jpackage-state>\");\n+        return content;\n@@ -271,4 +280,1 @@\n-    private static final String JPACKAGE_STATE_OPEN = String.format(\n-            \"<jpackage-state platform=\\\"%s\\\" version=\\\"%s\\\">\",\n-            AppImageFile.getPlatform(), AppImageFile.getVersion());\n-\n+    private static final ApplicationLayout DUMMY_LAYOUT = ApplicationLayout.build().setAll(\"\").create();\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/AppImageFileTest.java","additions":199,"deletions":193,"binary":false,"changes":392,"status":"modified"},{"patch":"@@ -1,103 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jpackage.internal;\n-\n-import java.io.IOException;\n-import java.nio.file.Files;\n-import java.nio.file.Path;\n-import org.junit.jupiter.api.Test;\n-import org.junit.jupiter.api.io.TempDir;\n-import static org.junit.jupiter.api.Assertions.assertTrue;\n-\n-\n-public class ApplicationLayoutTest {\n-\n-    private Path newFolder(Path folderName, String ... extraFolderNames) throws IOException {\n-        var path = tempFolder.resolve(folderName);\n-        Files.createDirectories(path);\n-        for (var extraFolderName : extraFolderNames) {\n-            path = path.resolve(extraFolderName);\n-            Files.createDirectories(path);\n-        }\n-        return path;\n-    }\n-\n-    private Path newFile(Path fileName) throws IOException {\n-        var path = tempFolder.resolve(fileName);\n-        Files.createDirectories(path.getParent());\n-        Files.createFile(path);\n-        return path;\n-    }\n-\n-    private void fillLinuxAppImage() throws IOException {\n-        appImage = newFolder(Path.of(\"Foo\"));\n-\n-        Path base = appImage.getFileName();\n-\n-        newFolder(base, \"bin\");\n-        newFolder(base, \"lib\", \"app\", \"mods\");\n-        newFolder(base, \"lib\", \"runtime\", \"bin\");\n-        newFile(base.resolve(\"bin\/Foo\"));\n-        newFile(base.resolve(\"lib\/app\/Foo.cfg\"));\n-        newFile(base.resolve(\"lib\/app\/hello.jar\"));\n-        newFile(base.resolve(\"lib\/Foo.png\"));\n-        newFile(base.resolve(\"lib\/libapplauncher.so\"));\n-        newFile(base.resolve(\"lib\/runtime\/bin\/java\"));\n-    }\n-\n-    @Test\n-    public void testLinux() throws IOException {\n-        fillLinuxAppImage();\n-        testApplicationLayout(ApplicationLayout.linuxAppImage());\n-    }\n-\n-    private void testApplicationLayout(ApplicationLayout layout) throws IOException {\n-        ApplicationLayout srcLayout = layout.resolveAt(appImage);\n-        assertApplicationLayout(srcLayout);\n-\n-        ApplicationLayout dstLayout = layout.resolveAt(\n-                appImage.getParent().resolve(\n-                        \"Copy\" + appImage.getFileName().toString()));\n-        srcLayout.move(dstLayout);\n-        Files.deleteIfExists(appImage);\n-        assertApplicationLayout(dstLayout);\n-\n-        dstLayout.copy(srcLayout);\n-        assertApplicationLayout(srcLayout);\n-        assertApplicationLayout(dstLayout);\n-    }\n-\n-    private void assertApplicationLayout(ApplicationLayout layout) throws IOException {\n-        assertTrue(Files.isRegularFile(layout.appDirectory().resolve(\"Foo.cfg\")));\n-        assertTrue(Files.isRegularFile(layout.appDirectory().resolve(\"hello.jar\")));\n-        assertTrue(Files.isDirectory(layout.appModsDirectory()));\n-        assertTrue(Files.isRegularFile(layout.launchersDirectory().resolve(\"Foo\")));\n-        assertTrue(Files.isRegularFile(layout.destktopIntegrationDirectory().resolve(\"Foo.png\")));\n-        assertTrue(Files.isRegularFile(layout.runtimeDirectory().resolve(\"bin\/java\")));\n-    }\n-\n-    @TempDir\n-    private Path tempFolder;\n-    private Path appImage;\n-}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/ApplicationLayoutTest.java","additions":0,"deletions":103,"binary":false,"changes":103,"status":"deleted"},{"patch":"@@ -100,1 +100,1 @@\n-                new OverridableResource(DEFAULT_NAME), tempFolder.resolve(\n+                new OverridableResource(DEFAULT_NAME, ResourceLocator.class), tempFolder.resolve(\n@@ -120,1 +120,1 @@\n-        OverridableResource resource = new OverridableResource(DEFAULT_NAME);\n+        OverridableResource resource = new OverridableResource(DEFAULT_NAME, ResourceLocator.class);\n@@ -173,1 +173,1 @@\n-                new OverridableResource(defaultName.value)\n+                new OverridableResource(defaultName.value, ResourceLocator.class)\n@@ -202,1 +202,1 @@\n-                new OverridableResource(defaultName.value)\n+                new OverridableResource(defaultName.value, ResourceLocator.class)\n@@ -224,1 +224,1 @@\n-                new OverridableResource(null).setResourceDir(customFile.getParent()));\n+                new OverridableResource().setResourceDir(customFile.getParent()));\n@@ -247,1 +247,1 @@\n-        var resource = new OverridableResource(null)\n+        var resource = new OverridableResource()\n@@ -268,1 +268,1 @@\n-        var resourceWriter = buildResourceWriter(new OverridableResource(null)).expectedSource(null);\n+        var resourceWriter = buildResourceWriter(new OverridableResource()).expectedSource(null);\n@@ -278,1 +278,1 @@\n-        NULL_NAME(null);\n+        NO_NAME(\"\");\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/OverridableResourceTest.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotSame;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.Set;\n+import org.junit.jupiter.api.Test;\n+\n+\n+public class AppImageLayoutTest {\n+\n+    @Test\n+    public void testStub() {\n+        final var root = Path.of(\"root\");\n+        final var runtime = Path.of(\"runtime\");\n+        final var layout = new AppImageLayout.Stub(root, runtime);\n+\n+        assertEquals(root, layout.rootDirectory());\n+        assertEquals(runtime, layout.runtimeDirectory());\n+    }\n+\n+    @Test\n+    public void testPathGroup() {\n+        final var layout = new AppImageLayout.Stub(Path.of(\"root\"), Path.of(\"runtime\"));\n+\n+        final var pathGroup = AppImageLayout.toPathGroup(layout);\n+\n+        assertEquals(Set.of(\"runtimeDirectory\"), pathGroup.keys());\n+        assertEquals(List.of(layout.runtimeDirectory()), pathGroup.paths());\n+    }\n+\n+    @Test\n+    public void testResolveAt() {\n+        final var dir = Path.of(\"foo\/bar\");\n+\n+        final var layout = new AppImageLayout.Stub(Path.of(\"\"), Path.of(\"runtime\"));\n+\n+        final var resolvedLayout = layout.resolveAt(dir);\n+\n+        assertNotSame(layout, resolvedLayout);\n+\n+        assertEquals(dir.resolve(layout.rootDirectory()), resolvedLayout.rootDirectory());\n+        assertEquals(dir.resolve(layout.runtimeDirectory()), resolvedLayout.runtimeDirectory());\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/AppImageLayoutTest.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.model;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.io.TempDir;\n+\n+\n+public class ApplicationLayoutTest {\n+\n+    public void test(boolean move, Path tempDir) throws IOException {\n+        final var srcAppImageRoot = tempDir.resolve(\"src\");\n+        Files.createDirectories(srcAppImageRoot);\n+\n+        final var appImageCopyFiles = List.of(\"bin\/Foo\", \"lib\/app\/Foo.cfg\", \"lib\/app\/hello.jar\", \"runtime\/bin\/java\");\n+        final var appImageCopyDirs = List.of(\"lib\/app\/hello\");\n+\n+        final var appImageNoCopyFiles = List.of(\"lib\/Foo.cfg\", \"Foo\");\n+        final var appImageNoCopyDirs = List.of(\"lib\/hello\", \"a\/b\/c\");\n+\n+        for (var path : Stream.concat(appImageCopyFiles.stream(), appImageNoCopyFiles.stream()).map(srcAppImageRoot::resolve).toList()) {\n+            Files.createDirectories(path.getParent());\n+            Files.createFile(path);\n+        }\n+\n+        for (var path : Stream.concat(appImageCopyDirs.stream(), appImageNoCopyDirs.stream()).map(srcAppImageRoot::resolve).toList()) {\n+            Files.createDirectories(path);\n+        }\n+\n+        final var layout = ApplicationLayout.build()\n+                .launchersDirectory(\"bin\")\n+                .appDirectory(\"lib\/app\")\n+                .runtimeDirectory(\"runtime\")\n+                .appModsDirectory(\"mods\")\n+                .contentDirectory(\"content\")\n+                .destktopIntegrationDirectory(\"lib\/apps\")\n+                .create();\n+\n+        final var dstAppImageRoot = tempDir.resolve(\"dst\");\n+        Files.createDirectories(dstAppImageRoot);\n+\n+        final var srcPathGroup = AppImageLayout.toPathGroup(layout.resolveAt(srcAppImageRoot));\n+        final var dstPathGroup = AppImageLayout.toPathGroup(layout.resolveAt(dstAppImageRoot));\n+        if (move) {\n+            srcPathGroup.move(dstPathGroup);\n+        } else {\n+            srcPathGroup.copy(dstPathGroup);\n+        }\n+\n+        for (var path : Stream.concat(appImageNoCopyDirs.stream(), appImageNoCopyFiles.stream()).map(srcAppImageRoot::resolve).toList()) {\n+            assertTrue(Files.exists(path));\n+        }\n+\n+        for (var path : appImageCopyDirs) {\n+            var srcPath = srcAppImageRoot.resolve(path);\n+            if (move) {\n+                assertFalse(Files.exists(srcPath));\n+            } else {\n+                assertTrue(Files.isDirectory(srcPath));\n+            }\n+            assertTrue(Files.isDirectory(dstAppImageRoot.resolve(path)));\n+        }\n+\n+        for (var path : appImageCopyFiles) {\n+            var srcPath = srcAppImageRoot.resolve(path);\n+            if (move) {\n+                assertFalse(Files.exists(srcPath));\n+            } else {\n+                assertTrue(Files.isRegularFile(srcPath));\n+            }\n+            assertTrue(Files.isRegularFile(dstAppImageRoot.resolve(path)));\n+        }\n+    }\n+\n+    @Test\n+    public void testMove(@TempDir Path tempDir) throws IOException {\n+        test(true, tempDir);\n+    }\n+\n+    @Test\n+    public void testCopy(@TempDir Path tempDir) throws IOException {\n+        test(false, tempDir);\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/model\/ApplicationLayoutTest.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,388 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.pipeline;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.util.ArrayList;\n+import java.util.BitSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Spliterator;\n+import java.util.function.Consumer;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+final class BinaryMatrixTest {\n+\n+    record CtorTest(int rows, int columns, boolean isSquare, boolean fail) {\n+\n+        static CtorTest create(int rows, int columns) {\n+            return new CtorTest(rows, columns, rows == columns, false);\n+        }\n+\n+        static CtorTest createFail(int rows, int columns) {\n+            return new CtorTest(rows, columns, false, true);\n+        }\n+\n+        void test() {\n+            if (fail) {\n+                assertThrows(IllegalArgumentException.class, () -> new BinaryMatrix(rows, columns));\n+            } else {\n+                final var matrix = new BinaryMatrix(rows, columns);\n+                assertEquals(rows, matrix.getRowCount());\n+                assertEquals(columns, matrix.getColumnCount());\n+                assertEquals(isSquare, matrix.isSquare());\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testCtor(CtorTest testSpec) {\n+        testSpec.test();\n+    }\n+\n+    private static Stream<CtorTest> testCtor() {\n+        return Stream.of(\n+                CtorTest.create(1, 2),\n+                CtorTest.create(2, 2),\n+                CtorTest.create(7, 4),\n+                CtorTest.createFail(0, 1),\n+                CtorTest.createFail(1, 0),\n+                CtorTest.createFail(-1, 1),\n+                CtorTest.createFail(1, -1),\n+                CtorTest.createFail(0, 0),\n+                CtorTest.createFail(-3, -9)\n+        );\n+    }\n+\n+    record MatrixSpec(int rows, int columns, String encodedMatrixData) {\n+\n+        MatrixSpec(int rows, int columns) {\n+            this(rows, columns, null);\n+        }\n+\n+        BinaryMatrix createMatrix() {\n+            if (encodedMatrixData == null) {\n+                return new BinaryMatrix(rows, columns);\n+            }\n+\n+            final var charArray = encodedMatrixData.toCharArray();\n+\n+            if (charArray.length != rows * columns) {\n+                throw new IllegalArgumentException(\"Matrix data is not matching matrix dimensions\");\n+            }\n+\n+            final var matrixData = new BitSet(charArray.length);\n+\n+            IntStream.range(0, charArray.length).forEach(index -> {\n+                final var chr = charArray[index];\n+                switch (chr) {\n+                    case '0' -> {\n+                        break;\n+                    }\n+\n+                    case '1' -> {\n+                        matrixData.set(index);\n+                        break;\n+                    }\n+\n+                    default -> {\n+                        throw new IllegalArgumentException(String.format(\"Unrecognized character: %c\", chr));\n+                    }\n+                }\n+            });\n+\n+            return new BinaryMatrix(rows, columns, matrixData);\n+        }\n+    }\n+\n+    enum Selection {\n+        ROW,\n+        COLUMN\n+    }\n+\n+    record SelectionTest(MatrixSpec matrixSpec, Selection type, int index, List<Boolean> expected) {\n+\n+        static SelectionTest createRow(int rows, int columns, String encodedMatrixData, int row, int ... expected) {\n+            return new SelectionTest(new MatrixSpec(rows, columns, encodedMatrixData), Selection.ROW, row, conv(expected));\n+        }\n+\n+        static SelectionTest createColumn(int rows, int columns, String encodedMatrixData, int column, int ... expected) {\n+            return new SelectionTest(new MatrixSpec(rows, columns, encodedMatrixData), Selection.COLUMN, column, conv(expected));\n+        }\n+\n+        static SelectionTest createRow(int rows, int columns, int row) {\n+            return new SelectionTest(new MatrixSpec(rows, columns), Selection.ROW, row, null);\n+        }\n+\n+        static SelectionTest createColumn(int rows, int columns, int column) {\n+            return new SelectionTest(new MatrixSpec(rows, columns), Selection.COLUMN, column, null);\n+        }\n+\n+        void test() {\n+            final var matrix = matrixSpec.createMatrix();\n+            if (expected == null) {\n+                assertThrows(IndexOutOfBoundsException.class, () -> getIterator(matrix));\n+                assertThrows(IndexOutOfBoundsException.class, () -> getSpliterator(matrix));\n+            } else {\n+                final var it = getIterator(matrix);\n+                assertEquals(expected, readSelection(it::forEachRemaining));\n+\n+                final var split = getSpliterator(matrix);\n+                assertEquals(expected, readSelection(split::forEachRemaining));\n+\n+                assertThrows(NoSuchElementException.class, it::next);\n+            }\n+        }\n+\n+        List<Boolean> readSelection(Consumer<Consumer<BinaryMatrix.Cursor>> forEach) {\n+            final List<Boolean> actualData = new ArrayList<>();\n+            final int[] variableIndexValue = new int[] { -1 };\n+\n+            forEach.accept(cursor -> {\n+                final int fixedIndex;\n+                final int variableIndex;\n+                switch (type) {\n+                    case ROW -> {\n+                        fixedIndex = cursor.row();\n+                        variableIndex = cursor.column();\n+                    }\n+                    case COLUMN -> {\n+                        fixedIndex = cursor.column();\n+                        variableIndex = cursor.row();\n+                    }\n+                    default -> {\n+                        throw new IllegalArgumentException();\n+                    }\n+                }\n+\n+                assertEquals(index, fixedIndex);\n+                assertEquals(variableIndexValue[0] + 1, variableIndex);\n+                variableIndexValue[0] = variableIndex;\n+\n+                actualData.add(cursor.value());\n+            });\n+\n+            return actualData;\n+        }\n+\n+        Iterator<BinaryMatrix.Cursor> getIterator(BinaryMatrix matrix) {\n+            switch (type) {\n+                case ROW -> {\n+                    return matrix.getRowIterator(index);\n+                }\n+                case COLUMN -> {\n+                    return matrix.getColumnIterator(index);\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }\n+\n+        Spliterator<BinaryMatrix.Cursor> getSpliterator(BinaryMatrix matrix) {\n+            switch (type) {\n+                case ROW -> {\n+                    return matrix.getRowSpliterator(index);\n+                }\n+                case COLUMN -> {\n+                    return matrix.getColumnSpliterator(index);\n+                }\n+                default -> {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSelection(SelectionTest testSpec) {\n+        testSpec.test();\n+    }\n+\n+    private static Stream<SelectionTest> testSelection() {\n+        return Stream.of(\n+                SelectionTest.createRow(1, 1, \"0\", 0, 0),\n+                SelectionTest.createColumn(1, 1, \"0\", 0, 0),\n+                SelectionTest.createRow(1, 1, \"1\", 0, 1),\n+                SelectionTest.createColumn(1, 1, \"1\", 0, 1),\n+\n+                SelectionTest.createRow(3, 2, \"00\" + \"01\" + \"10\", 0, 0, 0),\n+                SelectionTest.createRow(3, 2, \"00\" + \"01\" + \"10\", 1, 0, 1),\n+                SelectionTest.createRow(3, 2, \"00\" + \"01\" + \"10\", 2, 1, 0),\n+                SelectionTest.createColumn(3, 2, \"00\" + \"01\" + \"10\", 0, 0, 0, 1),\n+                SelectionTest.createColumn(3, 2, \"00\" + \"01\" + \"10\", 1, 0, 1, 0),\n+\n+                SelectionTest.createRow(3, 2, -1),\n+                SelectionTest.createRow(3, 2, 3),\n+                SelectionTest.createRow(3, 2, 12),\n+\n+                SelectionTest.createColumn(3, 2, -1),\n+                SelectionTest.createColumn(3, 2, 2),\n+                SelectionTest.createColumn(3, 2, 12)\n+        );\n+    }\n+\n+    record SetValueTest(MatrixSpec matrixSpec, int row, int column, Boolean expected) {\n+\n+        static SetValueTest create(int rows, int columns, String encodedMatrixData, int row, int column, boolean expected) {\n+            return new SetValueTest(new MatrixSpec(rows, columns, encodedMatrixData), row, column, expected);\n+        }\n+\n+        static SetValueTest create(int rows, int columns, int row, int column) {\n+            return new SetValueTest(new MatrixSpec(rows, columns), row, column, null);\n+        }\n+\n+        void test() {\n+            final var matrix = matrixSpec.createMatrix();\n+            final var matrixCopy = matrixSpec.createMatrix();\n+            if (expected == null) {\n+                assertThrows(IndexOutOfBoundsException.class, () -> matrix.set(row, column));\n+                assertEquals(matrixCopy, matrix);\n+\n+                assertThrows(IndexOutOfBoundsException.class, () -> matrix.set(row, column, true));\n+                assertEquals(matrixCopy, matrix);\n+\n+                assertThrows(IndexOutOfBoundsException.class, () -> matrix.set(row, column, false));\n+                assertEquals(matrixCopy, matrix);\n+\n+                assertThrows(IndexOutOfBoundsException.class, () -> matrix.unset(row, column));\n+                assertEquals(matrixCopy, matrix);\n+\n+                assertThrows(IndexOutOfBoundsException.class, () -> matrix.isSet(row, column));\n+                assertEquals(matrixCopy, matrix);\n+            } else {\n+                assertEquals(expected, matrix.isSet(row, column));\n+\n+                matrix.set(row, column, expected);\n+                assertEquals(expected, matrix.isSet(row, column));\n+                assertEquals(matrixCopy, matrix);\n+\n+                if (expected) {\n+                    matrix.set(row, column);\n+                } else {\n+                    matrix.unset(row, column);\n+                }\n+                assertEquals(expected, matrix.isSet(row, column));\n+                assertEquals(matrixCopy, matrix);\n+\n+                matrix.set(row, column, !expected);\n+                assertNotEquals(expected, matrix.isSet(row, column));\n+                assertNotEquals(matrixCopy, matrix);\n+\n+                if (expected) {\n+                    matrix.set(row, column);\n+                } else {\n+                    matrix.unset(row, column);\n+                }\n+                assertEquals(expected, matrix.isSet(row, column));\n+                assertEquals(matrixCopy, matrix);\n+            }\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testSetValue(SetValueTest testSpec) {\n+        testSpec.test();\n+    }\n+\n+    private static List<SetValueTest> testSetValue() {\n+        final List<SetValueTest> data = new ArrayList<>();\n+\n+        data.addAll(List.of(\n+                SetValueTest.create(1, 1, \"0\", 0, 0, false),\n+                SetValueTest.create(1, 1, \"1\", 0, 0, true),\n+\n+                SetValueTest.create(3, 2, -1, 0),\n+                SetValueTest.create(3, 2, 3, 0),\n+                SetValueTest.create(3, 2, 12, 0),\n+\n+                SetValueTest.create(3, 2, 0, -1),\n+                SetValueTest.create(3, 2, 0, 2),\n+                SetValueTest.create(3, 2, 0, 12),\n+\n+                SetValueTest.create(3, 2, 3, 2)\n+        ));\n+\n+        final var matrixData = new boolean[3][5];\n+        matrixData[0] = new boolean[] { false, true, false, true, true };\n+        matrixData[1] = new boolean[] { true, false, true, false, true };\n+        matrixData[2] = new boolean[] { false, false, true, false, false };\n+\n+        final var sb = new StringBuilder();\n+        for (int i = 0; i != 3; ++i) {\n+            for (int j = 0; j != 5; ++j) {\n+                sb.append(matrixData[i][j] ? '1' : '0');\n+            }\n+        }\n+\n+        final var encodedMatrixData = sb.toString();\n+        for (int i = 0; i != 3; ++i) {\n+            for (int j = 0; j != 5; ++j) {\n+                data.add(SetValueTest.create(3, 5, encodedMatrixData, i, j, matrixData[i][j]));\n+            }\n+        }\n+\n+        return data;\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        final var matrixSpec = new MatrixSpec(2, 3, \"001\" + \"101\");\n+\n+        final var a = matrixSpec.createMatrix();\n+        final var b = matrixSpec.createMatrix();\n+\n+        assertTrue(a.equals(b));\n+        assertTrue(a.equals(a));\n+        assertFalse(a.equals(null));\n+        assertFalse(a.equals(matrixSpec));\n+    }\n+\n+    @Test\n+    public void testHashCode() {\n+        final var matrixSpec2x3 = new MatrixSpec(2, 3);\n+\n+        assertEquals(matrixSpec2x3.createMatrix().hashCode(), matrixSpec2x3.createMatrix().hashCode());\n+\n+        final var matrixSpec3x2 = new MatrixSpec(3, 2);\n+        assertNotEquals(matrixSpec2x3.createMatrix().hashCode(), matrixSpec3x2.createMatrix().hashCode());\n+    }\n+\n+    private static List<Boolean> conv(int... values) {\n+        return IntStream.of(values).mapToObj(v -> v != 0).toList();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/pipeline\/BinaryMatrixTest.java","additions":388,"deletions":0,"binary":false,"changes":388,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.pipeline;\n+\n+import static org.junit.jupiter.api.Assertions.assertSame;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.List;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+final class DirectedEdgeTest {\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testCtor(String tail, String head, Class<? extends Exception> expectedExceptionType) {\n+        if (expectedExceptionType != null) {\n+            assertThrows(expectedExceptionType, () -> DirectedEdge.create(tail, head));\n+        } else {\n+            final var edge = DirectedEdge.create(tail, head);\n+            assertSame(tail, edge.from());\n+            assertSame(head, edge.head());\n+            assertSame(head, edge.to());\n+        }\n+    }\n+\n+    private static List<Object[]> testCtor() {\n+        return List.<Object[]>of(\n+                new Object[] { \"a\", \"b\", null },\n+                new Object[] { \"a\", \"a\", IllegalArgumentException.class },\n+                new Object[] { \"a\", null, NullPointerException.class },\n+                new Object[] { null, \"b\", NullPointerException.class },\n+                new Object[] { null, null, NullPointerException.class }\n+        );\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/pipeline\/DirectedEdgeTest.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -0,0 +1,438 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.pipeline;\n+\n+import static org.junit.jupiter.api.Assertions.assertArrayEquals;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+import java.util.stream.StreamSupport;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+final class FixedDAGTest {\n+\n+    @Test\n+    public void testInvalidCtorArgs() {\n+        final var matrix1x2 = new BinaryMatrix(1, 2);\n+        final var nodes = FixedDAG.Nodes.<String>ofList(List.of(A, B));\n+\n+        assertThrows(IllegalArgumentException.class, () -> new FixedDAG<>(matrix1x2, nodes));\n+\n+        final var matrix3x3 = new BinaryMatrix(3, 3);\n+        assertThrows(IllegalArgumentException.class, () -> new FixedDAG<>(matrix3x3, nodes));\n+    }\n+\n+    @Test\n+    public void testNodesToList() {\n+        final var nodes = FixedDAG.Nodes.<String>ofList(List.of(A, B));\n+\n+        assertEquals(2, nodes.size());\n+\n+        assertEquals(A, nodes.get(0));\n+        assertEquals(B, nodes.get(1));\n+        assertThrows(IndexOutOfBoundsException.class, () -> nodes.get(2));\n+\n+        assertEquals(0, nodes.indexOf(A));\n+        assertEquals(1, nodes.indexOf(B));\n+        assertThrows(NoSuchElementException.class, () -> nodes.indexOf(C));\n+\n+        final var copy = new ArrayList<String>();\n+        for (var n : nodes) {\n+            copy.add(n);\n+        }\n+        assertEquals(copy, List.of(A, B));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testCyclic(List<DirectedEdge<String>> edges) {\n+        assertThrows(UnsupportedOperationException.class, () -> create(edges));\n+    }\n+\n+    private static Stream<List<DirectedEdge<String>>> testCyclic() {\n+        return Stream.of(\n+                List.of(edge(A, B), edge(B, A)),\n+\n+                List.of(edge(A, B), edge(B, C), edge(C, D), edge(D, A)),\n+\n+                List.of(edge(A, B), edge(B, C), edge(C, D), edge(D, B)),\n+\n+                \/\/ A <- B -> L\n+                \/\/ |    ^    |\n+                \/\/ |    |    |\n+                \/\/ + <- D <- +\n+                \/\/      |\n+                \/\/      + <- C\n+                List.of(edge(B, A), edge(D, B), edge(D, A), edge(C, D), edge(L, D), edge(B, L)),\n+                List.of(edge(C, D), edge(B, A), edge(D, B), edge(D, A), edge(L, D), edge(B, L))\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testGetNoIncomingEdges(List<DirectedEdge<String>> edges, List<String> expectedNodes) {\n+        final var actualNodes = create(edges).getNoIncomingEdges();\n+        assertEquals(expectedNodes, actualNodes);\n+    }\n+\n+    private static Stream<Object[]> testGetNoIncomingEdges() {\n+        return Stream.<Object[]>of(\n+                new Object[] { List.of(edge(A, B)), List.of(A) },\n+                new Object[] { List.of(edge(A, B), edge(A, B)), List.of(A) },\n+                new Object[] { List.of(edge(A, B), edge(D, B)), List.of(A, D) },\n+                new Object[] { List.of(edge(D, B), edge(A, B)), List.of(D, A) },\n+\n+                new Object[] { List.of(edge(A, B), edge(C, D)), List.of(A, C) },\n+\n+                \/\/ A <- B\n+                \/\/ ^    ^\n+                \/\/ |    |\n+                \/\/ + -- D <- L\n+                \/\/      |\n+                \/\/      + <- C\n+                new Object[] { List.of(edge(B, A), edge(D, B), edge(D, A), edge(C, D), edge(L, D)), List.of(C, L) },\n+                new Object[] { List.of(edge(B, A), edge(L, D), edge(D, B), edge(D, A), edge(C, D)), List.of(L, C) }\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testGetNoOutgoingEdges(List<DirectedEdge<String>> edges, List<String> expectedNodes) {\n+        final var actualNodes = create(edges).getNoOutgoingEdges();\n+        assertEquals(expectedNodes, actualNodes);\n+    }\n+\n+    private static Stream<Object[]> testGetNoOutgoingEdges() {\n+        return Stream.<Object[]>of(\n+                new Object[] { List.of(edge(A, B)), List.of(B) },\n+                new Object[] { List.of(edge(A, B), edge(C, D)), List.of(B, D) }\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testGetTailsOf(String node, List<DirectedEdge<String>> edges, List<String> expectedNodes) {\n+        final var actualNodes = create(edges).getTailsOf(node);\n+        assertEquals(actualNodes, expectedNodes);\n+\n+    }\n+\n+    private static Stream<Object[]> testGetTailsOf() {\n+        return Stream.<Object[]>of(\n+                new Object[] { A, List.of(edge(A, B)), List.of() },\n+                new Object[] { B, List.of(edge(A, B)), List.of(A) },\n+                new Object[] { B, List.of(edge(A, B), edge(A, B)), List.of(A) },\n+                new Object[] { B, List.of(edge(A, B), edge(B, C)), List.of(A) },\n+                new Object[] { B, List.of(edge(A, B), edge(B, C), edge(C, D)), List.of(A) },\n+                new Object[] { B, List.of(edge(A, B), edge(A, C), edge(D, B)), List.of(A, D) },\n+                new Object[] { B, List.of(edge(D, B), edge(A, B), edge(A, C)), List.of(D, A) }\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testGetHeadsOf(String node, List<DirectedEdge<String>> edges, List<String> expectedNodes) {\n+        final var actualNodes = create(edges).getHeadsOf(node);\n+        assertEquals(actualNodes, expectedNodes);\n+    }\n+\n+    private static Stream<Object[]> testGetHeadsOf() {\n+        return Stream.<Object[]>of(\n+                new Object[] { A, List.of(edge(A, B)), List.of(B) },\n+                new Object[] { B, List.of(edge(A, B)), List.of() },\n+                new Object[] { A, List.of(edge(A, B), edge(A, B)), List.of(B) },\n+                new Object[] { B, List.of(edge(A, B), edge(B, C)), List.of(C) },\n+                new Object[] { B, List.of(edge(A, B), edge(B, C), edge(C, D)), List.of(C) },\n+                new Object[] { D, List.of(edge(D, B), edge(D, A), edge(C, D)), List.of(B, A) },\n+                new Object[] { D, List.of(edge(D, A), edge(D, B), edge(C, D)), List.of(A, B) }\n+        );\n+    }\n+\n+    @Test\n+    public void testSome() {\n+        \/\/ A <- B <--- D\n+        \/\/ ^    ^      |\n+        \/\/ |    |      |\n+        \/\/ +--- C -> L |\n+        \/\/ |    ^      |\n+        \/\/ |    |      |\n+        \/\/ +----+------+\n+\n+        final var graphBuilder = FixedDAG.<String>build();\n+\n+        graphBuilder.addEdge(edge(C, L));\n+        graphBuilder.addEdge(edge(D, B));\n+        graphBuilder.addEdge(edge(B, A));\n+        graphBuilder.addEdge(edge(D, A));\n+        graphBuilder.addEdge(edge(C, A));\n+        graphBuilder.addEdge(edge(D, C));\n+        graphBuilder.addEdge(edge(C, B));\n+\n+        final var graph = graphBuilder.create();\n+\n+        assertEquals(graph.getNoIncomingEdges(), List.of(D));\n+        assertEquals(graph.getNoOutgoingEdges(), List.of(L, A));\n+\n+        assertEquals(graph.getHeadsOf(A), List.of());\n+        assertEquals(graph.getTailsOf(A), List.of(C, D, B));\n+\n+        assertEquals(graph.getHeadsOf(B), List.of(A));\n+        assertEquals(graph.getTailsOf(B), List.of(C, D));\n+\n+        assertEquals(graph.getHeadsOf(C), List.of(L, B, A));\n+        assertEquals(graph.getTailsOf(C), List.of(D));\n+\n+        assertEquals(graph.getHeadsOf(D), List.of(C, B, A));\n+        assertEquals(graph.getTailsOf(D), List.of());\n+\n+        assertEquals(graph.getHeadsOf(L), List.of());\n+        assertEquals(graph.getTailsOf(L), List.of(C));\n+    }\n+\n+    @Test\n+    public void testSome2() {\n+        \/\/ B -> A <- C\n+        \/\/ ^         ^\n+        \/\/ |         |\n+        \/\/ +--- D ---+\n+        \/\/      ^\n+        \/\/      |\n+        \/\/ K -> N <- M <- P\n+        \/\/ ^         ^\n+        \/\/ |    O    |\n+        \/\/ |    ^    |\n+        \/\/ |    |    |\n+        \/\/ +--- L ---+\n+        \/\/\n+\n+        final var graphBuilder = FixedDAG.<String>build();\n+\n+        graphBuilder.addEdge(edge(B, A));\n+        graphBuilder.addEdge(edge(C, A));\n+        graphBuilder.addEdge(edge(D, B));\n+        graphBuilder.addEdge(edge(D, C));\n+        graphBuilder.addEdge(edge(N, D));\n+        graphBuilder.addEdge(edge(M, N));\n+        graphBuilder.addEdge(edge(K, N));\n+        graphBuilder.addEdge(edge(L, K));\n+        graphBuilder.addEdge(edge(L, M));\n+        graphBuilder.addEdge(edge(P, M));\n+        graphBuilder.addEdge(edge(L, O));\n+\n+        final var graph = graphBuilder.create();\n+\n+        assertEquals(graph.getNoIncomingEdges(), List.of(L, P));\n+        assertEquals(graph.getNoOutgoingEdges(), List.of(A, O));\n+\n+        assertEquals(graph.getHeadsOf(A), List.of());\n+        assertEquals(graph.getTailsOf(A), List.of(B, C));\n+        assertEquals(graph.getAllHeadsOf(A), List.of());\n+        assertEquals(graph.getAllTailsOf(A), List.of(B, C, D, N, M, K, L, P));\n+\n+        assertEquals(graph.getHeadsOf(B), List.of(A));\n+        assertEquals(graph.getTailsOf(B), List.of(D));\n+        assertEquals(graph.getAllHeadsOf(B), List.of(A));\n+        assertEquals(graph.getAllTailsOf(B), List.of(D, N, M, K, L, P));\n+\n+        assertEquals(graph.getHeadsOf(C), List.of(A));\n+        assertEquals(graph.getTailsOf(C), List.of(D));\n+        assertEquals(graph.getAllHeadsOf(C), List.of(A));\n+        assertEquals(graph.getAllTailsOf(C), List.of(D, N, M, K, L, P));\n+\n+        assertEquals(graph.getHeadsOf(D), List.of(B, C));\n+        assertEquals(graph.getTailsOf(D), List.of(N));\n+        assertEquals(graph.getAllHeadsOf(D), List.of(B, A, C));\n+        assertEquals(graph.getAllTailsOf(D), List.of(N, M, K, L, P));\n+\n+        assertEquals(graph.getHeadsOf(K), List.of(N));\n+        assertEquals(graph.getTailsOf(K), List.of(L));\n+        assertEquals(graph.getAllHeadsOf(K), List.of(B, A, C, D, N));\n+        assertEquals(graph.getAllTailsOf(K), List.of(L));\n+\n+        assertEquals(graph.getHeadsOf(L), List.of(M, K, O));\n+        assertEquals(graph.getTailsOf(L), List.of());\n+        assertEquals(graph.getAllHeadsOf(L), List.of(B, A, C, D, N, M, K, O));\n+        assertEquals(graph.getAllTailsOf(L), List.of());\n+\n+        assertEquals(graph.getHeadsOf(M), List.of(N));\n+        assertEquals(graph.getTailsOf(M), List.of(L, P));\n+        assertEquals(graph.getAllHeadsOf(M), List.of(B, A, C, D, N));\n+        assertEquals(graph.getAllTailsOf(M), List.of(L, P));\n+\n+        assertEquals(graph.getHeadsOf(N), List.of(D));\n+        assertEquals(graph.getTailsOf(N), List.of(M, K));\n+        assertEquals(graph.getAllHeadsOf(N), List.of(B, A, C, D));\n+        assertEquals(graph.getAllTailsOf(N), List.of(M, K, L, P));\n+\n+        assertEquals(graph.getHeadsOf(O), List.of());\n+        assertEquals(graph.getTailsOf(O), List.of(L));\n+        assertEquals(graph.getAllHeadsOf(O), List.of());\n+        assertEquals(graph.getAllTailsOf(O), List.of(L));\n+\n+        assertEquals(graph.getHeadsOf(P), List.of(M));\n+        assertEquals(graph.getTailsOf(P), List.of());\n+        assertEquals(graph.getAllHeadsOf(P), List.of(B, A, C, D, N, M));\n+        assertEquals(graph.getAllTailsOf(P), List.of());\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource\n+    public void testTopologicalSort(List<DirectedEdge<Integer>> edges, int[] expectedNodes) {\n+\n+        final var nodes = edges.stream().map(edge -> {\n+            return Stream.of(edge.tail(), edge.head());\n+        }).flatMap(x -> x).sorted().distinct().toList();\n+\n+        assertArrayEquals(expectedNodes, FixedDAG.create(edges, nodes).topologicalSort().stream().mapToInt(x -> x).toArray());\n+    }\n+\n+    private static List<Object[]> testTopologicalSort() {\n+        return List.<Object[]>of(\n+                new Object[] { List.of(\n+                        edge(11, 15),\n+                        edge(12, 16),\n+                        edge(13, 17),\n+                        edge(14, 15),\n+                        edge(14, 16),\n+                        edge(14, 17),\n+                        edge(14, 18)), IntStream.rangeClosed(11, 18).toArray()\n+                },\n+\n+                new Object[] { List.of(\n+                        edge(5, 2),\n+                        edge(5, 0),\n+                        edge(4, 0),\n+                        edge(2, 3),\n+                        edge(3, 1)), new int[] {4, 5, 0, 2, 3, 1}\n+                },\n+\n+                new Object[] { List.of(\n+                        edge(0, 1),\n+                        edge(0, 4),\n+                        edge(0, 7),\n+                        edge(0, 14),\n+                        edge(1, 5),\n+                        edge(2, 3),\n+                        edge(2, 5),\n+                        edge(2, 6),\n+                        edge(3, 10),\n+                        edge(4, 5),\n+                        edge(4, 8),\n+                        edge(5, 9),\n+                        edge(6, 10),\n+                        edge(7, 8),\n+                        edge(7, 11),\n+                        edge(10, 13),\n+                        edge(11, 12),\n+                        edge(13, 16),\n+                        edge(14, 15)), IntStream.rangeClosed(0, 16).toArray()\n+                },\n+\n+                new Object[] { List.of(\n+                        edge(0, 2),\n+                        edge(0, 4),\n+                        edge(1, 4),\n+                        edge(1, 5),\n+                        edge(2, 5),\n+                        edge(3, 2)), new int[] {0, 1, 3, 2, 4, 5}\n+                },\n+\n+                new Object[] { List.of(\n+                        edge(0, 1),\n+                        edge(0, 2),\n+                        edge(1, 3),\n+                        edge(2, 3),\n+                        edge(3, 4)), IntStream.rangeClosed(0, 4).toArray()\n+                },\n+\n+                new Object[] { List.of(\n+                        edge(1, 2),\n+                        edge(1, 3),\n+                        edge(2, 4),\n+                        edge(3, 4),\n+                        edge(4, 5)), IntStream.rangeClosed(1, 5).toArray()\n+                }\n+        );\n+    }\n+\n+    @Test\n+    public void testEmptyBuilder() {\n+        assertThrows(IllegalArgumentException.class, FixedDAG.<String>build()::create);\n+    }\n+\n+    @Test\n+    public void testSingleNodeBuilder() {\n+        final var graphBuilder = FixedDAG.<String>build();\n+        graphBuilder.addNode(A);\n+        assertNodesEquals(graphBuilder.create().nodes(), A);\n+    }\n+\n+    @Test\n+    public void testIsolatedNodesBuilder() {\n+        final var graphBuilder = FixedDAG.<String>build();\n+        graphBuilder.addNode(A);\n+        graphBuilder.addNode(B);\n+        assertNodesEquals(graphBuilder.create().nodes(), A, B);\n+        assertEquals(graphBuilder.create().getNoOutgoingEdges(), List.of(A, B));\n+        assertEquals(graphBuilder.create().getNoIncomingEdges(), List.of(A, B));\n+\n+        graphBuilder.addEdge(edge(A, C));\n+        assertNodesEquals(graphBuilder.create().nodes(), A, B, C);\n+        assertEquals(graphBuilder.create().getNoOutgoingEdges(), List.of(B, C));\n+        assertEquals(graphBuilder.create().getNoIncomingEdges(), List.of(A, B));\n+    }\n+\n+    private static void assertNodesEquals(FixedDAG.Nodes<String> actual, String... expected) {\n+        assertEquals(List.of(expected), StreamSupport.stream(actual.spliterator(), false).toList());\n+    }\n+\n+    private static FixedDAG<String> create(Collection<DirectedEdge<String>> edges) {\n+        final var graphBuilder = FixedDAG.<String>build();\n+        edges.forEach(graphBuilder::addEdge);\n+        return graphBuilder.create();\n+    }\n+\n+    private static <T> DirectedEdge<T> edge(T tail, T head) {\n+        return DirectedEdge.create(tail, head);\n+    }\n+\n+    private static final String A = \"A\";\n+    private static final String B = \"B\";\n+    private static final String C = \"C\";\n+    private static final String D = \"D\";\n+    private static final String K = \"K\";\n+    private static final String L = \"L\";\n+    private static final String M = \"M\";\n+    private static final String N = \"N\";\n+    private static final String O = \"O\";\n+    private static final String P = \"P\";\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/pipeline\/FixedDAGTest.java","additions":438,"deletions":0,"binary":false,"changes":438,"status":"added"},{"patch":"@@ -0,0 +1,496 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jpackage.internal.pipeline;\n+\n+import static java.util.stream.Collectors.joining;\n+import static java.util.stream.Collectors.toMap;\n+import static org.junit.jupiter.api.Assertions.assertDoesNotThrow;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.locks.LockSupport;\n+import java.util.function.Consumer;\n+import java.util.function.Predicate;\n+import java.util.regex.Pattern;\n+import java.util.stream.Stream;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+final class TaskPipelineBuilderTest {\n+\n+    private static final class TestException extends Exception {\n+\n+        TestException(TestTask sender) {\n+            super(makeMessage(sender));\n+        }\n+\n+        static String makeMessage(TestTask sender) {\n+            return \"Thrown by \" + sender.name();\n+        }\n+\n+        private static final long serialVersionUID = 1L;\n+    }\n+\n+    private enum TestTask implements Consumer<StringBuffer> {\n+        A,\n+        B,\n+        C,\n+        D,\n+        K,\n+        L,\n+        M,\n+        N,\n+        THROW_1(true);\n+\n+        TestTask(boolean fail) {\n+            this.fail = fail;\n+        }\n+\n+        TestTask() {\n+            fail = false;\n+        }\n+\n+        @Override\n+        public void accept(StringBuffer sb) {\n+            LockSupport.parkNanos(Duration.ofMillis(1).toNanos());\n+            System.out.println(String.format(\"[%s] result before append: [%s]; append %s\", Thread.currentThread(), sb, name()));\n+            sb.append(name());\n+        }\n+\n+        Callable<Void> toCallable(StringBuffer sb) {\n+            return new Callable<> () {\n+\n+                @Override\n+                public Void call() throws Exception {\n+                    if (isThrowing()) {\n+                        throw new TestException(TestTask.this);\n+                    }\n+                    accept(sb);\n+                    return null;\n+                }\n+\n+                @Override\n+                public String toString() {\n+                    return TestTask.this.toString();\n+                }\n+\n+            };\n+        }\n+\n+        private boolean isThrowing() {\n+            return fail;\n+        }\n+\n+        static Stream<TestTask> nonThrowingTasks() {\n+            return Stream.of(values()).filter(Predicate.not(TestTask::isThrowing));\n+        }\n+\n+        private final boolean fail;\n+    }\n+\n+    private record TaskSpec(TestTask task, List<TestTask> dependencies, TestTask dependent) {\n+\n+        TaskSpec {\n+            Objects.requireNonNull(task);\n+            Objects.requireNonNull(dependencies);\n+        }\n+\n+        static final class Builder {\n+\n+            Builder(TestTask task) {\n+                this.task = Objects.requireNonNull(task);\n+            }\n+\n+            Builder to(TestTask task) {\n+                dependent = task;\n+                return this;\n+            }\n+\n+            Builder from(TestTask ... tasks) {\n+                dependencies.addAll(List.of(tasks));\n+                return this;\n+            }\n+\n+            TaskSpec create() {\n+                return new TaskSpec(task, dependencies, dependent);\n+            }\n+\n+            private final TestTask task;\n+            private final List<TestTask> dependencies = new ArrayList<>();\n+            private TestTask dependent;\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"testIt\")\n+    public void testIt(TestSpec testSpec) throws Exception {\n+        testSpec.test();\n+    }\n+\n+    public record TestSpec(List<TaskSpec> taskSpecs, Object expectedString, Set<TestTask> expectedAnyFailures, Executor executor) {\n+\n+        public TestSpec {\n+            Objects.requireNonNull(taskSpecs);\n+            Objects.requireNonNull(expectedString);\n+            Objects.requireNonNull(expectedAnyFailures);\n+        }\n+\n+        static final class Builder {\n+\n+            Builder taskSpecs(TaskSpec ...specs) {\n+                taskSpecs.addAll(List.of(specs));\n+                return this;\n+            }\n+\n+            Builder expected(Pattern v) {\n+                expectedRegexp = v;\n+                return this;\n+            }\n+\n+            Builder expected(Predicate<String> v) {\n+                expectedPredicate = v;\n+                return this;\n+            }\n+\n+            Builder expected(String v) {\n+                expectedString = v;\n+                return this;\n+            }\n+\n+            Builder expectedAnyFailure(TestTask... v) {\n+                expectedAnyFailures.addAll(List.of(v));\n+                return this;\n+            }\n+\n+            Builder executor(Executor v) {\n+                executor = v;\n+                return this;\n+            }\n+\n+            TestSpec create() {\n+                final Object expectedObject;\n+                if (!isParallel()) {\n+                    expectedObject = expectedString;\n+                } else if (expectedRegexp != null) {\n+                    expectedObject = expectedRegexp;\n+                } else if (expectedPredicate != null) {\n+                    expectedObject = expectedPredicate;\n+                } else {\n+                    expectedObject = expectedString;\n+                }\n+\n+                if (expectedPredicate != null && expectedRegexp != null) {\n+                    throw new IllegalStateException();\n+                }\n+\n+                return new TestSpec(taskSpecs, expectedObject, expectedAnyFailures, executor);\n+            }\n+\n+            private boolean isParallel() {\n+                return executor != null;\n+            }\n+\n+            private final List<TaskSpec> taskSpecs = new ArrayList<>();\n+            private String expectedString;\n+            private Pattern expectedRegexp;\n+            private Predicate<String> expectedPredicate;\n+            private Set<TestTask> expectedAnyFailures = new HashSet<>();\n+            private Executor executor;\n+        }\n+\n+        @SuppressWarnings(\"unchecked\")\n+        void test() {\n+            final var builder = new TaskPipelineBuilder();\n+            builder.executor(executor);\n+\n+            final var sb = new StringBuffer();\n+\n+            final var taskMap = Stream.of(TestTask.values()).collect(toMap(x -> x, x -> {\n+                return x.toCallable(sb);\n+            }));\n+\n+            taskSpecs.forEach(taskSpec -> {\n+                final var taskBuilder = builder.task(taskMap.get(taskSpec.task))\n+                        .addDependencies(taskSpec.dependencies.stream().map(taskMap::get).toList());\n+                if (taskSpec.dependent != null) {\n+                    taskBuilder.addDependent(taskMap.get(taskSpec.dependent));\n+                }\n+                taskBuilder.add();\n+            });\n+\n+            if (expectedAnyFailures.isEmpty()) {\n+                System.out.println(String.format(\"start for %s\", expectedString));\n+                assertDoesNotThrow(builder.create()::call);\n+            } else {\n+                System.out.println(String.format(\"start for %s throws %s\", expectedString, expectedAnyFailures));\n+                final var ex = assertThrows(TestException.class, builder.create()::call);\n+                assertTrue(expectedAnyFailures.stream().map(TestException::makeMessage).anyMatch(Predicate.isEqual(ex.getMessage())), () -> {\n+                    return String.format(\"Exception message '%s' doesn't match any of failed tasks %s\", ex.getMessage(), expectedAnyFailures);\n+                });\n+            }\n+            System.out.println(\"end\");\n+\n+            final var actualString = sb.toString();\n+\n+            assertEquals(actualString.length(), actualString.chars().distinct().count());\n+\n+            if (expectedString instanceof Pattern expectedRegexp) {\n+                assertTrue(expectedRegexp.matcher(actualString).matches(), () -> {\n+                    return String.format(\"Regexp %s doesn't match string %s\", expectedRegexp, actualString);\n+                });\n+            } else if (expectedString instanceof Predicate<?> expectedPredicate) {\n+                assertTrue(((Predicate<String>)expectedPredicate).test(actualString), () -> {\n+                    return String.format(\"Predicate %s failed for string %s\", expectedString, actualString);\n+                });\n+            } else {\n+                assertEquals(expectedString.toString(), actualString);\n+            }\n+        }\n+    }\n+\n+    private static List<TestSpec> testIt() {\n+        final List<TestSpec> data = new ArrayList<>();\n+\n+        data.add(test().taskSpecs(task(A).create()).expected(\"A\").create());\n+\n+        data.add(test().taskSpecs(task(B).from(A).create()).expected(\"AB\").create());\n+\n+        \/\/ D <- C <- B\n+        \/\/ ^         ^\n+        \/\/ |         |\n+        \/\/ +--- A ---+\n+        data.add(test().taskSpecs(\n+                task(D).create(),\n+                task(C).from(B).to(D).create(),\n+                task(A).to(B).create(),\n+                task(A).to(D).create()\n+        ).expected(\"ABCD\").create());\n+\n+        \/\/ A <- THROW_1 <- B\n+        data.add(test().taskSpecs(\n+                task(A).create(),\n+                task(THROW_1).from(B).to(A).create()\n+        ).expected(\"B\").expectedAnyFailure(THROW_1).create());\n+\n+        data.addAll(testData(ForkJoinPool.commonPool()));\n+        data.addAll(testData(Executors.newSingleThreadExecutor()));\n+        data.addAll(testData(Executors.newFixedThreadPool(5)));\n+\n+        data.addAll(testData(null));\n+\n+        return data;\n+    }\n+\n+    private static List<TestSpec> testData(Executor executor) {\n+        final List<TestSpec> data = new ArrayList<>();\n+\n+        final var allValuesRegexp = Pattern.compile(String.format(\"[%s]{%d}\",\n+                TestTask.nonThrowingTasks().map(Enum::name).collect(joining()), TestTask.nonThrowingTasks().count()));\n+\n+        data.add(test().executor(executor).taskSpecs(\n+                task(D).create(),\n+                task(C).from(B).to(D).create(),\n+                task(A).to(B).create(),\n+                task(A).to(D).create()\n+        ).expected(\"ABCD\").create());\n+\n+        data.add(test().executor(executor).taskSpecs(TestTask.nonThrowingTasks()\n+                .map(TaskPipelineBuilderTest::task)\n+                .map(TaskSpec.Builder::create)\n+                .toArray(TaskSpec[]::new)\n+        ).expected(allValuesRegexp).expected(TestTask.nonThrowingTasks().map(Enum::name).collect(joining())).create());\n+\n+        data.add(test().executor(executor).taskSpecs(TestTask.nonThrowingTasks()\n+                .sorted(Comparator.reverseOrder())\n+                .map(TaskPipelineBuilderTest::task)\n+                .map(TaskSpec.Builder::create)\n+                .toArray(TaskSpec[]::new)\n+        ).expected(allValuesRegexp).expected(TestTask.nonThrowingTasks().sorted(Comparator.reverseOrder()).map(Enum::name).collect(joining())).create());\n+\n+        \/\/ B -> A <- C\n+        \/\/ ^         ^\n+        \/\/ |         |\n+        \/\/ +--- D ---+\n+        data.add(test().executor(executor).taskSpecs(\n+                task(A).create(),\n+                task(C).from(D).to(A).create(),\n+                task(B).from(D).to(A).create()\n+        ).expected(Pattern.compile(\"D(BC|CB)A\")).expected(\"DCBA\").create());\n+\n+        data.add(test().executor(executor).taskSpecs(\n+                task(A).create(),\n+                task(B).from(D).to(A).create(),\n+                task(C).from(D).to(A).create()\n+        ).expected(Pattern.compile(\"D(BC|CB)A\")).expected(\"DBCA\").create());\n+\n+        \/\/ B -> A <- C\n+        \/\/ ^         ^\n+        \/\/ |         |\n+        \/\/ +--- D ---+\n+        \/\/      ^\n+        \/\/      |\n+        \/\/      N\n+        data.add(test().executor(executor).taskSpecs(\n+                task(A).create(),\n+                task(C).from(D).to(A).create(),\n+                task(N).to(D).create(),\n+                task(B).from(D).to(A).create()\n+        ).expected(Pattern.compile(\"ND(BC|CB)A\")).expected(\"NDCBA\").create());\n+\n+        \/\/ B -> A <- C\n+        \/\/ ^         ^\n+        \/\/ |         |\n+        \/\/ +--- D ---+\n+        \/\/      ^\n+        \/\/      |\n+        \/\/ K -> N <- M\n+        \/\/ ^         ^\n+        \/\/ |         |\n+        \/\/ +--- L ---+\n+        data.add(test().executor(executor).taskSpecs(\n+                task(A).create(),\n+                task(C).from(D).to(A).create(),\n+                task(N).to(D).create(),\n+                task(B).from(D).to(A).create(),\n+                task(K).from(L).to(N).create(),\n+                task(M).from(L).to(N).create()\n+        ).expected(Pattern.compile(\"L(KM|MK)ND(BC|CB)A\")).expected(\"LKMNDCBA\").create());\n+\n+        \/\/ +-> A <-+\n+        \/\/ |       |\n+        \/\/ B    THROW_1 <- D\n+        \/\/ ^       ^\n+        \/\/ |       |\n+        \/\/ K       C\n+        data.add(test().executor(executor).taskSpecs(\n+                task(A).create(),\n+                task(B).from(K).to(A).create(),\n+                task(THROW_1).from(D).to(A).create(),\n+                task(C).to(THROW_1).create()\n+        ).expected(c('K').before('B').and(onlyChars(\"KBDC\"))).expected(\"KBDC\").expectedAnyFailure(THROW_1).create());\n+\n+        \/\/ +--> A <--+\n+        \/\/ |    ^    |\n+        \/\/ |    |    |\n+        \/\/ B    C  THROW_1\n+        data.add(test().executor(executor).taskSpecs(\n+                task(A).create(),\n+                task(B).to(A).create(),\n+                task(C).to(A).create(),\n+                task(THROW_1).to(A).create()\n+        ).expected(onlyChars(\"BC\")).expected(\"BC\").expectedAnyFailure(THROW_1).create());\n+\n+        return data;\n+    }\n+\n+    private static TaskSpec.Builder task(TestTask task) {\n+        return new TaskSpec.Builder(task);\n+    }\n+\n+    private static TestSpec.Builder test() {\n+        return new TestSpec.Builder();\n+    }\n+\n+    private record PredicateWithDescritpion<T>(Predicate<T> predicate, String description) implements Predicate<T> {\n+\n+        PredicateWithDescritpion {\n+            Objects.requireNonNull(predicate);\n+            Objects.requireNonNull(description);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return String.format(\"(%s)\",  description);\n+        }\n+\n+        @Override\n+        public Predicate<T> and(Predicate<? super T> other) {\n+            return new PredicateWithDescritpion<>(predicate.and(other), String.format(\"%s and %s\", toString(), other));\n+        }\n+\n+        @Override\n+        public Predicate<T> or(Predicate<? super T> other) {\n+            return new PredicateWithDescritpion<>(predicate.or(other), String.format(\"%s or %s\", toString(), other));\n+        }\n+\n+        @Override\n+        public Predicate<T> negate() {\n+            return new PredicateWithDescritpion<>(predicate, String.format(\"!%s\", toString()));\n+        }\n+\n+        @Override\n+        public boolean test(T t) {\n+            return predicate.test(t);\n+        }\n+    }\n+\n+    private record StringPredicateBuilder(char ch) {\n+        Predicate<String> before(char other) {\n+            return new PredicateWithDescritpion<>(str -> {\n+                return str.indexOf(ch) < str.indexOf(other);\n+            }, String.format(\"%s before %s\",  ch, other));\n+        }\n+\n+        Predicate<String> after(char other) {\n+            return new StringPredicateBuilder(other).before(ch);\n+        }\n+    }\n+\n+    private static StringPredicateBuilder c(char ch) {\n+        return new StringPredicateBuilder(ch);\n+    }\n+\n+    private static Predicate<String> onlyChars(String chars) {\n+        return onlyChars(chars.chars().mapToObj(v -> (char)v).toArray(Character[]::new));\n+    }\n+\n+    private static Predicate<String> onlyChars(Character... chars) {\n+        return new PredicateWithDescritpion<>(str -> {\n+            final Set<Character> set = Set.of(chars);\n+            return str.chars().mapToObj(v -> (char)v).allMatch(set::contains);\n+        }, String.format(\"only %s\", List.of(chars)));\n+    }\n+\n+    private static final TestTask A = TestTask.A;\n+    private static final TestTask B = TestTask.B;\n+    private static final TestTask C = TestTask.C;\n+    private static final TestTask D = TestTask.D;\n+    private static final TestTask K = TestTask.K;\n+    private static final TestTask L = TestTask.L;\n+    private static final TestTask M = TestTask.M;\n+    private static final TestTask N = TestTask.N;\n+    private static final TestTask THROW_1 = TestTask.THROW_1;\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/pipeline\/TaskPipelineBuilderTest.java","additions":496,"deletions":0,"binary":false,"changes":496,"status":"added"},{"patch":"@@ -0,0 +1,374 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.util;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+\n+public class CompositeProxyTest {\n+\n+    static interface Smalltalk {\n+\n+        default String sayHello() {\n+            return \"Hello\";\n+        }\n+\n+        default String sayBye() {\n+            return \"Bye\";\n+        }\n+    }\n+\n+    static interface ConvoMixin {\n+\n+        String sayThings();\n+\n+        record Stub(String sayThings) implements ConvoMixin {\n+        }\n+    }\n+\n+    static interface Convo extends Smalltalk, ConvoMixin {\n+    }\n+\n+    static interface ConvoMixinWithOverrideSayBye {\n+\n+        String sayThings();\n+\n+        String sayBye();\n+\n+        record Stub(String sayThings, String sayBye) implements ConvoMixinWithOverrideSayBye {\n+        }\n+    }\n+\n+    static interface ConvoWithOverrideSayBye extends Smalltalk, ConvoMixinWithOverrideSayBye {\n+        @Override\n+        String sayBye();\n+    }\n+\n+    static interface ConvoWithDefaultSayHelloWithOverrideSayBye extends Smalltalk, ConvoMixinWithOverrideSayBye {\n+        @Override\n+        String sayBye();\n+\n+        @Override\n+        default String sayHello() {\n+            return \"Ciao\";\n+        }\n+\n+        static String saySomething() {\n+            return \"blah\";\n+        }\n+    }\n+\n+    @Test\n+    public void testSmalltalk() {\n+        var convo = CompositeProxy.create(Smalltalk.class);\n+        assertEquals(\"Hello\", convo.sayHello());\n+        assertEquals(\"Bye\", convo.sayBye());\n+    }\n+\n+    @Test\n+    public void testConvo() {\n+        final var otherThings = \"How is your day?\";\n+        var convo = CompositeProxy.create(Convo.class,\n+                new Smalltalk() {}, new ConvoMixin.Stub(otherThings));\n+        assertEquals(\"Hello\", convo.sayHello());\n+        assertEquals(\"Bye\", convo.sayBye());\n+        assertEquals(otherThings, convo.sayThings());\n+    }\n+\n+    @Test\n+    public void testConvoWithDuke() {\n+        final var otherThings = \"How is your day?\";\n+        var convo = CompositeProxy.create(Convo.class, new Smalltalk() {\n+            @Override\n+            public String sayHello() {\n+                return \"Hello, Duke\";\n+            }\n+        }, new ConvoMixin.Stub(otherThings));\n+        assertEquals(\"Hello, Duke\", convo.sayHello());\n+        assertEquals(\"Bye\", convo.sayBye());\n+        assertEquals(otherThings, convo.sayThings());\n+    }\n+\n+    @Test\n+    public void testConvoWithCustomSayBye() {\n+        var mixin = new ConvoMixinWithOverrideSayBye.Stub(\"How is your day?\", \"See you\");\n+\n+        var convo = CompositeProxy.create(ConvoWithOverrideSayBye.class, new Smalltalk() {}, mixin);\n+\n+        var expectedConvo = new ConvoWithOverrideSayBye() {\n+            @Override\n+            public String sayBye() {\n+                return mixin.sayBye;\n+            }\n+\n+            @Override\n+            public String sayThings() {\n+                return mixin.sayThings;\n+            }\n+        };\n+\n+        assertEquals(expectedConvo.sayHello(), convo.sayHello());\n+        assertEquals(expectedConvo.sayBye(), convo.sayBye());\n+        assertEquals(expectedConvo.sayThings(), convo.sayThings());\n+    }\n+\n+    @Test\n+    public void testConvoWithCustomSayHelloAndSayBye() {\n+        var mixin = new ConvoMixinWithOverrideSayBye.Stub(\"How is your day?\", \"See you\");\n+\n+        var convo = CompositeProxy.create(ConvoWithDefaultSayHelloWithOverrideSayBye.class, new Smalltalk() {}, mixin);\n+\n+        var expectedConvo = new ConvoWithDefaultSayHelloWithOverrideSayBye() {\n+            @Override\n+            public String sayBye() {\n+                return mixin.sayBye;\n+            }\n+\n+            @Override\n+            public String sayThings() {\n+                return mixin.sayThings;\n+            }\n+        };\n+\n+        assertEquals(\"Ciao\", expectedConvo.sayHello());\n+        assertEquals(expectedConvo.sayHello(), convo.sayHello());\n+        assertEquals(expectedConvo.sayBye(), convo.sayBye());\n+        assertEquals(expectedConvo.sayThings(), convo.sayThings());\n+    }\n+\n+    @Test\n+    public void testInherited() {\n+        interface Base {\n+            String doSome();\n+        }\n+\n+        interface Next extends Base {\n+            String doNext();\n+        }\n+\n+        interface Last extends Next {\n+        }\n+\n+        var last = CompositeProxy.create(Last.class, new Next() {\n+            @Override\n+            public String doNext() {\n+                return \"next\";\n+            }\n+\n+            @Override\n+            public String doSome() {\n+                return \"some\";\n+            }\n+        });\n+\n+        assertEquals(\"next\", last.doNext());\n+        assertEquals(\"some\", last.doSome());\n+    }\n+\n+    @Test\n+    public void testNestedProxy() {\n+        interface AddM {\n+            String m();\n+        }\n+\n+        interface AddN {\n+            String n();\n+        }\n+\n+        interface A extends AddM {\n+        }\n+\n+        interface B extends AddN  {\n+        }\n+\n+        interface C extends A, B {\n+        }\n+\n+        var proxyA = CompositeProxy.create(A.class, new AddM() {\n+            @Override\n+            public String m() {\n+                return \"hello\";\n+            }\n+        });\n+        var proxyB = CompositeProxy.create(B.class, new AddN() {\n+            @Override\n+            public String n() {\n+                return \"bye\";\n+            }\n+\n+        });\n+        var proxyC = CompositeProxy.create(C.class, proxyA, proxyB);\n+\n+        assertEquals(\"hello\", proxyC.m());\n+        assertEquals(\"bye\", proxyC.n());\n+    }\n+\n+    @Test\n+    public void testComposite() {\n+        interface A {\n+            String sayHello();\n+            String sayBye();\n+            default String talk() {\n+                return String.join(\",\", sayHello(), sayBye());\n+            }\n+        }\n+\n+        interface B extends A {\n+            @Override\n+            default String sayHello() {\n+                return \"ciao\";\n+            }\n+        }\n+\n+        var proxy = CompositeProxy.create(B.class, new A() {\n+            @Override\n+            public String sayHello() {\n+                return \"hello\";\n+            }\n+\n+            @Override\n+            public String sayBye() {\n+                return \"bye\";\n+            }\n+        });\n+\n+        assertEquals(\"ciao,bye\", proxy.talk());\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(booleans = {true, false})\n+    public void testBasicObjectMethods(boolean withOverrides) {\n+        interface A {\n+            default void foo() {}\n+        }\n+\n+        interface B {\n+            default void bar() {}\n+        }\n+\n+        interface C extends A, B {\n+        }\n+\n+        final A aImpl;\n+        final B bImpl;\n+\n+        if (withOverrides) {\n+            aImpl = new A() {\n+                @Override\n+                public String toString() {\n+                    return \"theA\";\n+                }\n+\n+                @Override\n+                public boolean equals(Object other) {\n+                    return true;\n+                }\n+\n+                @Override\n+                public int hashCode() {\n+                    return 7;\n+                }\n+            };\n+\n+            bImpl = new B() {\n+                @Override\n+                public String toString() {\n+                    return \"theB\";\n+                }\n+            };\n+        } else {\n+            aImpl = new A() {};\n+            bImpl = new B() {};\n+        }\n+\n+        var proxy = CompositeProxy.create(C.class, aImpl, bImpl);\n+        var proxy2 = CompositeProxy.create(C.class, aImpl, bImpl);\n+\n+        assertNotEquals(proxy.toString(), proxy2.toString());\n+        assertNotEquals(proxy.hashCode(), proxy2.hashCode());\n+        assertFalse(proxy.equals(proxy2));\n+        assertFalse(proxy2.equals(proxy));\n+        assertTrue(proxy.equals(proxy));\n+        assertTrue(proxy2.equals(proxy2));\n+    }\n+\n+    @Test\n+    public void testJavadocExample() {\n+        interface Sailboat {\n+            default void trimSails() {}\n+        }\n+\n+        interface WithMain {\n+            void trimMain();\n+        }\n+\n+        interface WithJib {\n+            void trimJib();\n+        }\n+\n+        interface Sloop extends Sailboat, WithMain, WithJib {\n+            @Override\n+            public default void trimSails() {\n+                System.out.println(\"On the sloop:\");\n+                trimMain();\n+                trimJib();\n+            }\n+        }\n+\n+        interface Catboat extends Sailboat, WithMain {\n+            @Override\n+            public default void trimSails() {\n+                System.out.println(\"On the catboat:\");\n+                trimMain();\n+            }\n+        }\n+\n+        final var withMain = new WithMain() {\n+            @Override\n+            public void trimMain() {\n+                System.out.println(\"  trim the main\");\n+            }\n+        };\n+\n+        final var withJib = new WithJib() {\n+            @Override\n+            public void trimJib() {\n+                System.out.println(\"  trim the jib\");\n+            }\n+        };\n+\n+        Sloop sloop = CompositeProxy.create(Sloop.class, new Sailboat() {}, withMain, withJib);\n+\n+        Catboat catboat = CompositeProxy.create(Catboat.class, new Sailboat() {}, withMain);\n+\n+        sloop.trimSails();\n+        catboat.trimSails();\n+    }\n+}\n","filename":"test\/jdk\/tools\/jpackage\/junit\/share\/jdk.jpackage\/jdk\/jpackage\/internal\/util\/CompositeProxyTest.java","additions":374,"deletions":0,"binary":false,"changes":374,"status":"added"},{"patch":"@@ -149,3 +149,4 @@\n-                        JPackageUserScript.POST_IMAGE.create(cmd, List.of(\n-                                WinGlobals.JS_SHELL.expr(),\n-                                WinGlobals.JS_FS.expr(),\n+                        final List<String> script = new ArrayList<>();\n+                        script.addAll(WinGlobals.JS_SHELL.expr());\n+                        script.addAll(WinGlobals.JS_FS.expr());\n+                        script.addAll(List.of(\n@@ -156,0 +157,1 @@\n+                        JPackageUserScript.POST_IMAGE.create(cmd, script);\n@@ -206,1 +208,1 @@\n-                .withEmptyDirectory(\"..\/packages\")\n+                .withNonexistantPath(\"..\/packages\")\n","filename":"test\/jdk\/tools\/jpackage\/share\/PostImageScriptTest.java","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -85,0 +85,5 @@\n+        Files.createDirectories(runtimePath.resolve(\"foo\/bar\/src.zip\"));\n+        Files.createFile(runtimePath.resolve(\"foo\/jmods\"));\n+        Files.createFile(runtimePath.resolve(\"foo\/src.zip\"));\n+        Files.createDirectories(runtimePath.resolve(\"custom\/jmods\"));\n+\n@@ -91,0 +96,4 @@\n+        TKit.assertDirectoryExists(appRuntimeDir.resolve(\"foo\/bar\/src.zip\"));\n+        TKit.assertDirectoryExists(appRuntimeDir.resolve(\"custom\/jmods\"));\n+        TKit.assertFileExists(appRuntimeDir.resolve(\"foo\/jmods\"));\n+        TKit.assertFileExists(appRuntimeDir.resolve(\"foo\/src.zip\"));\n","filename":"test\/jdk\/tools\/jpackage\/share\/RuntimeImageTest.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}