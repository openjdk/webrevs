{"files":[{"patch":"@@ -2365,9 +2365,25 @@\n-  int max_size = max_vector_size(bt);\n-  \/\/ Limit the min vector size to 8 bytes.\n-  int size = 8 \/ type2aelembytes(bt);\n-  if (bt == T_BYTE) {\n-    \/\/ To support vector api shuffle\/rearrange.\n-    size = 4;\n-  } else if (bt == T_BOOLEAN) {\n-    \/\/ To support vector api load\/store mask.\n-    size = 2;\n+  \/\/ Theoretically, the minimal vector length supported by AArch64\n+  \/\/ ISA and Vector API species is 64-bit. However, 32-bit or 16-bit\n+  \/\/ vector length is also allowed for special Vector API usages.\n+  int size;\n+  switch(bt) {\n+    case T_BOOLEAN:\n+      \/\/ It needs to load\/store a vector mask with only 2 elements\n+      \/\/ for vector types such as \"2I\/2F\/2L\/2D\".\n+      size = 2;\n+      break;\n+    case T_BYTE:\n+      \/\/ It needs to generate a \"4B\" vector, to support vector cast\n+      \/\/ between \"8B\/16B\" and \"4S\/4I\/4L\/4F\/4D\".\n+      size = 4;\n+      break;\n+    case T_SHORT:\n+      \/\/ It needs to generate a \"2S\" vector, to support vector cast\n+      \/\/ between \"4S\/8S\" and \"2I\/2L\/2F\/2D\".\n+      size = 2;\n+      break;\n+    default:\n+      \/\/ Limit the min vector length to 64-bit normally.\n+      size = 8 \/ type2aelembytes(bt);\n+      \/\/ The number of elements in a vector should be at least 2.\n+      size = MAX2(size, 2);\n@@ -2375,1 +2391,2 @@\n-  if (size < 2) size = 2;\n+\n+  int max_size = max_vector_size(bt);\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":27,"deletions":10,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -192,0 +192,12 @@\n+      case Op_AddReductionVI:\n+      case Op_AndReductionV:\n+      case Op_OrReductionV:\n+      case Op_XorReductionV:\n+      case Op_MinReductionV:\n+      case Op_MaxReductionV:\n+        \/\/ Reductions with less than 8 bytes vector length are\n+        \/\/ not supported for now.\n+        if (length_in_bytes < 8) {\n+          return false;\n+        }\n+        break;\n@@ -4247,2 +4259,2 @@\n-      \/\/ 4S to 4I\n-      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n+      \/\/ 2S to 2I\/2L, 4S to 4I\n+      __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n@@ -4268,1 +4280,1 @@\n-      __ neon_vector_extend($dst$$FloatRegister, T_LONG, length_in_bytes,\n+      __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n@@ -4272,1 +4284,1 @@\n-      __ sve_vector_extend($dst$$FloatRegister, __ D,\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n@@ -4346,5 +4358,9 @@\n-      \/\/ 4S to 4I\/4F\n-      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n-                            $src$$FloatRegister, T_SHORT);\n-      if (bt == T_FLOAT) {\n-        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      if (is_floating_point_type(bt)) {\n+        \/\/ 2S to 2F\/2D, 4S to 4F\n+        __ neon_vector_extend($dst$$FloatRegister, bt == T_FLOAT ? T_INT : T_LONG,\n+                              length_in_bytes, $src$$FloatRegister, T_SHORT);\n+        __ scvtfv(get_arrangement(this), $dst$$FloatRegister, $dst$$FloatRegister);\n+      } else {\n+        \/\/ 2S to 2I\/2L, 4S to 4I\n+        __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n+                              $src$$FloatRegister, T_SHORT);\n@@ -4374,1 +4390,1 @@\n-    \/\/ 4I to 4B\/4S\n+    \/\/ 2I to 2S, 4I to 4B\/4S\n@@ -4437,2 +4453,3 @@\n-instruct vcvtLtoI_neon(vReg dst, vReg src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+instruct vcvtLtoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n@@ -4441,1 +4458,1 @@\n-  format %{ \"vcvtLtoI_neon $dst, $src\" %}\n+  format %{ \"vcvtLtoX_narrow_neon $dst, $src\" %}\n@@ -4443,1 +4460,2 @@\n-    \/\/ 2L to 2I\n+    \/\/ 2L to 2S\/2I\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -4445,1 +4463,1 @@\n-    __ neon_vector_narrow($dst$$FloatRegister, T_INT,\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n@@ -4451,5 +4469,4 @@\n-instruct vcvtLtoI_sve(vReg dst, vReg src, vReg tmp) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_INT &&\n-             !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1)))) ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vcvtLtoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            !is_floating_point_type(Matcher::vector_element_basic_type(n)) &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4);\n@@ -4458,1 +4475,1 @@\n-  format %{ \"vcvtLtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  format %{ \"vcvtLtoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n@@ -4524,1 +4541,1 @@\n-    \/\/ 4F to 4B\/4S\n+    \/\/ 2F to 2S, 4F to 4B\/4S\n@@ -4527,1 +4544,2 @@\n-    __ fcvtzs($dst$$FloatRegister, __ T4S, $src$$FloatRegister);\n+    __ fcvtzs($dst$$FloatRegister, length_in_bytes == 16 ? __ T4S : __ T2S,\n+              $src$$FloatRegister);\n@@ -4593,1 +4611,3 @@\n-  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_INT);\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_INT ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n@@ -4596,1 +4616,1 @@\n-  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2I\" %}\n+  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2S\/2I\" %}\n@@ -4598,1 +4618,1 @@\n-    \/\/ 2D to 2I\n+    \/\/ 2D to 2S\/2I\n@@ -4606,0 +4626,4 @@\n+    if (Matcher::vector_element_basic_type(this) == T_SHORT) {\n+      __ neon_vector_narrow($dst$$FloatRegister, T_SHORT,\n+                            $dst$$FloatRegister, T_INT, 8);\n+    }\n@@ -6399,5 +6423,4 @@\n-        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n-        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-               $src$$FloatRegister);\n-        __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                  $dst$$FloatRegister);\n+        assert(length_in_bytes <= 16, \"unsupported\");\n+        bool isQ = length_in_bytes == 16;\n+        __ cnt($dst$$FloatRegister, isQ ? __ T16B : __ T8B, $src$$FloatRegister);\n+        __ uaddlp($dst$$FloatRegister, isQ ? __ T16B : __ T8B, $dst$$FloatRegister);\n@@ -6405,2 +6428,1 @@\n-          __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T8H : __ T4H,\n-                    $dst$$FloatRegister);\n+          __ uaddlp($dst$$FloatRegister, isQ ? __ T8H : __ T4H, $dst$$FloatRegister);\n@@ -6468,1 +6490,1 @@\n-    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    assert(length_in_bytes <= 16, \"must be\");\n@@ -6855,1 +6877,1 @@\n-        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        assert(length_in_bytes <= 16, \"unsupported\");\n@@ -6914,1 +6936,1 @@\n-        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        assert(length_in_bytes <= 16, \"unsupported\");\n@@ -6950,1 +6972,1 @@\n-      assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+      assert(length_in_bytes <= 16, \"unsupported\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":59,"deletions":37,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -182,0 +182,12 @@\n+      case Op_AddReductionVI:\n+      case Op_AndReductionV:\n+      case Op_OrReductionV:\n+      case Op_XorReductionV:\n+      case Op_MinReductionV:\n+      case Op_MaxReductionV:\n+        \/\/ Reductions with less than 8 bytes vector length are\n+        \/\/ not supported for now.\n+        if (length_in_bytes < 8) {\n+          return false;\n+        }\n+        break;\n@@ -2505,2 +2517,2 @@\n-dnl VECTOR_ZERO_EXTEND($1,      $2,     $3,      $4,       $5        $6,        $7,         )\n-dnl VECTOR_ZERO_EXTEND(op_name, dst_bt, src_bt,  dst_size, src_size, assertion, neon_comment)\n+dnl VECTOR_ZERO_EXTEND($1,      $2,     $3,       $4,        $5,         )\n+dnl VECTOR_ZERO_EXTEND(op_name, src_bt, src_size, assertion, neon_comment)\n@@ -2513,1 +2525,1 @@\n-    assert($6, \"must be\");\n+    assert($4, \"must be\");\n@@ -2516,3 +2528,3 @@\n-      \/\/ $7\n-      __ neon_vector_extend($dst$$FloatRegister, $2, length_in_bytes,\n-                            $src$$FloatRegister, $3, \/* is_unsigned *\/ true);\n+      \/\/ $5\n+      __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n+                            $src$$FloatRegister, $2, \/* is_unsigned *\/ true);\n@@ -2521,2 +2533,2 @@\n-      __ sve_vector_extend($dst$$FloatRegister, __ $4,\n-                           $src$$FloatRegister, __ $5, \/* is_unsigned *\/ true);\n+      __ sve_vector_extend($dst$$FloatRegister, __ elemType_to_regVariant(bt),\n+                           $src$$FloatRegister, __ $3, \/* is_unsigned *\/ true);\n@@ -2527,3 +2539,3 @@\n-VECTOR_ZERO_EXTEND(B, bt,     T_BYTE,  elemType_to_regVariant(bt), B, bt == T_SHORT || bt == T_INT || bt == T_LONG, `4B to 4S\/4I, 8B to 8S')\n-VECTOR_ZERO_EXTEND(S, T_INT,  T_SHORT, elemType_to_regVariant(bt), H, bt == T_INT || bt == T_LONG,                  `4S to 4I')\n-VECTOR_ZERO_EXTEND(I, T_LONG, T_INT,   D,                          S, bt == T_LONG,                                 `2I to 2L')\n+VECTOR_ZERO_EXTEND(B, T_BYTE,  B, bt == T_SHORT || bt == T_INT || bt == T_LONG, `4B to 4S\/4I, 8B to 8S')\n+VECTOR_ZERO_EXTEND(S, T_SHORT, H, bt == T_INT || bt == T_LONG,                  `2S to 2I\/2L, 4S to 4I')\n+VECTOR_ZERO_EXTEND(I, T_INT,   S, bt == T_LONG,                                 `2I to 2L')\n@@ -2598,5 +2610,9 @@\n-      \/\/ 4S to 4I\/4F\n-      __ neon_vector_extend($dst$$FloatRegister, T_INT, length_in_bytes,\n-                            $src$$FloatRegister, T_SHORT);\n-      if (bt == T_FLOAT) {\n-        __ scvtfv(__ T4S, $dst$$FloatRegister, $dst$$FloatRegister);\n+      if (is_floating_point_type(bt)) {\n+        \/\/ 2S to 2F\/2D, 4S to 4F\n+        __ neon_vector_extend($dst$$FloatRegister, bt == T_FLOAT ? T_INT : T_LONG,\n+                              length_in_bytes, $src$$FloatRegister, T_SHORT);\n+        __ scvtfv(get_arrangement(this), $dst$$FloatRegister, $dst$$FloatRegister);\n+      } else {\n+        \/\/ 2S to 2I\/2L, 4S to 4I\n+        __ neon_vector_extend($dst$$FloatRegister, bt, length_in_bytes,\n+                              $src$$FloatRegister, T_SHORT);\n@@ -2626,1 +2642,1 @@\n-    \/\/ 4I to 4B\/4S\n+    \/\/ 2I to 2S, 4I to 4B\/4S\n@@ -2689,2 +2705,3 @@\n-instruct vcvtLtoI_neon(vReg dst, vReg src) %{\n-  predicate(Matcher::vector_element_basic_type(n) == T_INT &&\n+instruct vcvtLtoX_narrow_neon(vReg dst, vReg src) %{\n+  predicate((Matcher::vector_element_basic_type(n) == T_INT ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT) &&\n@@ -2693,1 +2710,1 @@\n-  format %{ \"vcvtLtoI_neon $dst, $src\" %}\n+  format %{ \"vcvtLtoX_narrow_neon $dst, $src\" %}\n@@ -2695,1 +2712,2 @@\n-    \/\/ 2L to 2I\n+    \/\/ 2L to 2S\/2I\n+    BasicType bt = Matcher::vector_element_basic_type(this);\n@@ -2697,1 +2715,1 @@\n-    __ neon_vector_narrow($dst$$FloatRegister, T_INT,\n+    __ neon_vector_narrow($dst$$FloatRegister, bt,\n@@ -2703,5 +2721,4 @@\n-instruct vcvtLtoI_sve(vReg dst, vReg src, vReg tmp) %{\n-  predicate((Matcher::vector_element_basic_type(n) == T_INT &&\n-             !VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1)))) ||\n-            Matcher::vector_element_basic_type(n) == T_BYTE ||\n-            Matcher::vector_element_basic_type(n) == T_SHORT);\n+instruct vcvtLtoX_narrow_sve(vReg dst, vReg src, vReg tmp) %{\n+  predicate(!VM_Version::use_neon_for_vector(Matcher::vector_length_in_bytes(n->in(1))) &&\n+            !is_floating_point_type(Matcher::vector_element_basic_type(n)) &&\n+            type2aelembytes(Matcher::vector_element_basic_type(n)) <= 4);\n@@ -2710,1 +2727,1 @@\n-  format %{ \"vcvtLtoI_sve $dst, $src\\t# KILL $tmp\" %}\n+  format %{ \"vcvtLtoX_narrow_sve $dst, $src\\t# KILL $tmp\" %}\n@@ -2776,1 +2793,1 @@\n-    \/\/ 4F to 4B\/4S\n+    \/\/ 2F to 2S, 4F to 4B\/4S\n@@ -2779,1 +2796,2 @@\n-    __ fcvtzs($dst$$FloatRegister, __ T4S, $src$$FloatRegister);\n+    __ fcvtzs($dst$$FloatRegister, length_in_bytes == 16 ? __ T4S : __ T2S,\n+              $src$$FloatRegister);\n@@ -2845,1 +2863,3 @@\n-  predicate(UseSVE == 0 && Matcher::vector_element_basic_type(n) == T_INT);\n+  predicate(UseSVE == 0 &&\n+            (Matcher::vector_element_basic_type(n) == T_INT ||\n+             Matcher::vector_element_basic_type(n) == T_SHORT));\n@@ -2848,1 +2868,1 @@\n-  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2I\" %}\n+  format %{ \"vcvtDtoI_neon $dst, $src\\t# 2D to 2S\/2I\" %}\n@@ -2850,1 +2870,1 @@\n-    \/\/ 2D to 2I\n+    \/\/ 2D to 2S\/2I\n@@ -2858,0 +2878,4 @@\n+    if (Matcher::vector_element_basic_type(this) == T_SHORT) {\n+      __ neon_vector_narrow($dst$$FloatRegister, T_SHORT,\n+                            $dst$$FloatRegister, T_INT, 8);\n+    }\n@@ -4420,5 +4444,4 @@\n-        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n-        __ cnt($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-               $src$$FloatRegister);\n-        __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T16B : __ T8B,\n-                  $dst$$FloatRegister);\n+        assert(length_in_bytes <= 16, \"unsupported\");\n+        bool isQ = length_in_bytes == 16;\n+        __ cnt($dst$$FloatRegister, isQ ? __ T16B : __ T8B, $src$$FloatRegister);\n+        __ uaddlp($dst$$FloatRegister, isQ ? __ T16B : __ T8B, $dst$$FloatRegister);\n@@ -4426,2 +4449,1 @@\n-          __ uaddlp($dst$$FloatRegister, length_in_bytes == 16 ? __ T8H : __ T4H,\n-                    $dst$$FloatRegister);\n+          __ uaddlp($dst$$FloatRegister, isQ ? __ T8H : __ T4H, $dst$$FloatRegister);\n@@ -4478,1 +4500,1 @@\n-    assert(length_in_bytes == 8 || length_in_bytes == 16, \"must be\");\n+    assert(length_in_bytes <= 16, \"must be\");\n@@ -4854,1 +4876,1 @@\n-        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        assert(length_in_bytes <= 16, \"unsupported\");\n@@ -4913,1 +4935,1 @@\n-        assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+        assert(length_in_bytes <= 16, \"unsupported\");\n@@ -4938,1 +4960,1 @@\n-      assert(length_in_bytes == 8 || length_in_bytes == 16, \"unsupported\");\n+      assert(length_in_bytes <= 16, \"unsupported\");\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":66,"deletions":44,"binary":false,"changes":110,"status":"modified"},{"patch":"@@ -1781,7 +1781,5 @@\n-    if (dst_bt == T_SHORT) {\n-      \/\/ 4B\/8B to 4S\/8S\n-      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n-    } else {\n-      \/\/ 4B to 4I\n-      assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n-      _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n+    \/\/ 4B to 4S\/4I, 8B to 8S\n+    assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_SHORT || dst_bt == T_INT, \"unsupported\");\n+    _xshll(is_unsigned, dst, T8H, src, T8B, 0);\n+    if (dst_bt == T_INT) {\n@@ -1791,2 +1789,3 @@\n-    \/\/ 4S to 4I\n-    assert(dst_vlen_in_bytes == 16 && dst_bt == T_INT, \"unsupported\");\n+    \/\/ 2S to 2I\/2L, 4S to 4I\n+    assert(dst_vlen_in_bytes == 8 || dst_vlen_in_bytes == 16, \"unsupported\");\n+    assert(dst_bt == T_INT || dst_bt == T_LONG, \"unsupported\");\n@@ -1794,0 +1793,3 @@\n+    if (dst_bt == T_LONG) {\n+      _xshll(is_unsigned, dst, T2D, dst, T2S, 0);\n+    }\n@@ -1813,2 +1815,2 @@\n-    \/\/ 4I to 4B\/4S\n-    assert(src_vlen_in_bytes == 16, \"unsupported\");\n+    \/\/ 2I to 2S, 4I to 4B\/4S\n+    assert(src_vlen_in_bytes == 8 || src_vlen_in_bytes == 16, \"unsupported\");\n@@ -1821,1 +1823,1 @@\n-    \/\/ 2L to 2I\n+    \/\/ 2L to 2S\/2I\n@@ -1823,1 +1825,1 @@\n-    assert(dst_bt == T_INT, \"unsupported\");\n+    assert(dst_bt == T_INT || dst_bt == T_SHORT, \"unsupported\");\n@@ -1825,0 +1827,3 @@\n+    if (dst_bt == T_SHORT) {\n+      xtn(dst, T4H, dst, T4S);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":18,"deletions":13,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -600,2 +600,1 @@\n-            case \"short\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4,       4 ),\n-                                                     new CPUMinVectorWidth(ASIMD,      8 )};\n+            case \"short\"  -> new CPUMinVectorWidth[]{new CPUMinVectorWidth(SSE4_ASIMD, 4 )};\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestDependencyOffsets.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -637,0 +637,1 @@\n+            makePair(SSPEC64, ISPEC64),\n@@ -640,0 +641,1 @@\n+            makePair(SSPEC64, LSPEC128),\n@@ -641,0 +643,1 @@\n+            makePair(SSPEC128, LSPEC128),\n@@ -642,0 +645,1 @@\n+            makePair(SSPEC64, FSPEC64),\n@@ -645,0 +649,1 @@\n+            makePair(SSPEC64, DSPEC128),\n@@ -646,0 +651,1 @@\n+            makePair(SSPEC128, DSPEC128),\n@@ -649,0 +655,1 @@\n+            makePair(ISPEC64,  SSPEC64),\n@@ -663,0 +670,1 @@\n+            makePair(LSPEC128, SSPEC64),\n@@ -664,0 +672,1 @@\n+            makePair(LSPEC128, SSPEC128),\n@@ -676,0 +685,1 @@\n+            makePair(FSPEC64,  SSPEC64),\n@@ -690,0 +700,1 @@\n+            makePair(DSPEC128, SSPEC64),\n@@ -691,0 +702,1 @@\n+            makePair(DSPEC128, SSPEC128),\n@@ -739,0 +751,1 @@\n+            makePair(SSPEC64, ISPEC64, true),\n@@ -742,0 +755,1 @@\n+            makePair(SSPEC64, LSPEC128, true),\n@@ -747,0 +761,1 @@\n+            makePair(SSPEC128, LSPEC128, true),\n@@ -777,0 +792,1 @@\n+            makePair(SSPEC64, ISPEC64),\n@@ -778,0 +794,3 @@\n+            makePair(SSPEC64,  LSPEC128),\n+            makePair(SSPEC128, LSPEC128),\n+            makePair(SSPEC64, FSPEC64),\n@@ -779,0 +798,2 @@\n+            makePair(SSPEC64,  DSPEC128),\n+            makePair(SSPEC128, DSPEC128),\n@@ -781,1 +802,2 @@\n-            makePair(ISPEC64, LSPEC128),\n+            makePair(ISPEC64,  SSPEC64),\n+            makePair(ISPEC64,  LSPEC128),\n@@ -785,0 +807,2 @@\n+            makePair(LSPEC128, SSPEC64),\n+            makePair(LSPEC128, SSPEC128),\n@@ -789,0 +813,1 @@\n+            makePair(FSPEC64, SSPEC64),\n@@ -794,0 +819,2 @@\n+            makePair(DSPEC128, SSPEC64),\n+            makePair(DSPEC128, SSPEC128),\n@@ -804,0 +831,1 @@\n+            makePair(SSPEC64, ISPEC64, true),\n@@ -805,0 +833,1 @@\n+            makePair(SSPEC64, LSPEC128, true),\n@@ -806,0 +835,1 @@\n+            makePair(SSPEC128, LSPEC128, true),\n","filename":"test\/hotspot\/jtreg\/compiler\/vectorapi\/reshape\/utils\/TestCastMethods.java","additions":32,"deletions":2,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- *  Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,0 +123,12 @@\n+    @Benchmark\n+    public void microFloat64ToShort64() {\n+        VectorSpecies<Float> ISPECIES = FloatVector.SPECIES_64;\n+        VectorSpecies<Short> OSPECIES = ShortVector.SPECIES_64;\n+        for (int i = 0, j = 0; i < ISPECIES.loopBound(SIZE \/ 2); i += ISPECIES.length(), j += OSPECIES.length()) {\n+            FloatVector.fromArray(ISPECIES, float_arr, i)\n+                .convertShape(VectorOperators.F2S, OSPECIES, 0)\n+                .reinterpretAsShorts()\n+                .intoArray(short_res, j);\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/incubator\/vector\/VectorFPtoIntCastOperations.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2025, NVIDIA CORPORATION & AFFILIATES. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+\n+import java.util.concurrent.TimeUnit;\n+import java.util.Random;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Thread)\n+@Warmup(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 2, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+public class VectorTwoShorts {\n+    @Param({\"64\", \"128\", \"512\", \"1024\"})\n+    public int LEN;\n+\n+    private short[] sA;\n+    private short[] sB;\n+    private short[] sC;\n+\n+    @Param(\"0\")\n+    private int seed;\n+    private Random r = new Random(seed);\n+\n+    @Setup\n+    public void init() {\n+        sA = new short[LEN];\n+        sB = new short[LEN];\n+        sC = new short[LEN];\n+\n+        for (int i = 0; i < LEN; i++) {\n+            sA[i] = (short) r.nextInt();\n+            sB[i] = (short) r.nextInt();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void addVec2S() {\n+        for (int i = 0; i < LEN - 3; i++) {\n+            sC[i + 3] = (short) (sA[i] + sB[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void mulVec2S() {\n+        for (int i = 0; i < LEN - 3; i++) {\n+            sC[i + 3] = (short) (sA[i] * sB[i]);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void reverseBytesVec2S() {\n+        for (int i = 0; i < LEN - 3; i++) {\n+            sC[i + 3] = (short) Short.reverseBytes(sA[i]);\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/VectorTwoShorts.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"}]}