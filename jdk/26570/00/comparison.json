{"files":[{"patch":"@@ -2072,3 +2072,9 @@\n-Node* InvolutionNode::Identity(PhaseGVN* phase) {\n-  \/\/ Op ( Op x ) => x\n-  if (in(1)->Opcode() == Opcode()) {\n+Node* ReverseINode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseI) {\n+    return in(1)->in(1);\n+  }\n+  return this;\n+}\n+\n+Node* ReverseLNode::Identity(PhaseGVN* phase) {\n+  if (in(1)->Opcode() == Op_ReverseL) {\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -442,7 +442,0 @@\n-\/\/------------------------------InvolutionNode----------------------------------\n-\/\/ Represents a self-inverse operation, i.e., op(op(x)) = x for any x\n-class InvolutionNode : public Node {\n-public:\n-  InvolutionNode(Node* in) : Node(nullptr, in) {}\n-  virtual Node* Identity(PhaseGVN* phase);\n-};\n@@ -451,1 +444,1 @@\n-class NegNode : public InvolutionNode {\n+class NegNode : public Node {\n@@ -453,1 +446,1 @@\n-  NegNode(Node* in1) : InvolutionNode(in1) {\n+  NegNode(Node* in1) : Node(nullptr, in1) {\n@@ -565,1 +558,1 @@\n-class ReverseBytesNode : public InvolutionNode {\n+class ReverseBytesNode : public Node {\n@@ -567,1 +560,1 @@\n-  ReverseBytesNode(Node* in) : InvolutionNode(in) {}\n+  ReverseBytesNode(Node* in) : Node(nullptr, in) {}\n@@ -574,3 +567,1 @@\n-  ReverseBytesINode(Node* in) : ReverseBytesNode(in) {\n-  }\n-\n+  ReverseBytesINode(Node* in) : ReverseBytesNode(in) {}\n@@ -614,1 +605,1 @@\n-class ReverseINode : public InvolutionNode {\n+class ReverseINode : public Node {\n@@ -616,1 +607,1 @@\n-  ReverseINode(Node* in) : InvolutionNode(in) {}\n+  ReverseINode(Node* in) : Node(nullptr,in) {}\n@@ -620,0 +611,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n@@ -625,1 +617,1 @@\n-class ReverseLNode : public InvolutionNode {\n+class ReverseLNode : public Node {\n@@ -627,1 +619,1 @@\n-  ReverseLNode(Node* in) : InvolutionNode(in) {}\n+  ReverseLNode(Node* in) : Node(nullptr, in) {}\n@@ -631,0 +623,1 @@\n+  virtual Node* Identity(PhaseGVN* phase);\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":11,"deletions":18,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1,206 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package compiler.c2.irTests;\n-\n-import compiler.lib.generators.Generator;\n-import compiler.lib.generators.Generators;\n-import compiler.lib.generators.RestrictableGenerator;\n-import compiler.lib.ir_framework.DontCompile;\n-import compiler.lib.ir_framework.IR;\n-import compiler.lib.ir_framework.IRNode;\n-import compiler.lib.ir_framework.Run;\n-import compiler.lib.ir_framework.Test;\n-import compiler.lib.ir_framework.TestFramework;\n-import jdk.test.lib.Asserts;\n-\n-\/*\n- * @test\n- * @bug 8350988\n- * @summary Test that Identity simplifications of Involution nodes are being performed as expected.\n- * @library \/test\/lib \/\n- * @run driver compiler.c2.irTests.InvolutionIdentityTests\n- *\/\n-public class InvolutionIdentityTests {\n-\n-    public static final RestrictableGenerator<Integer> GEN_CHAR = Generators.G.safeRestrict(Generators.G.ints(), Character.MIN_VALUE, Character.MAX_VALUE);\n-    public static final RestrictableGenerator<Integer> GEN_SHORT = Generators.G.safeRestrict(Generators.G.ints(), Short.MIN_VALUE, Short.MAX_VALUE);\n-    public static final RestrictableGenerator<Long> GEN_LONG = Generators.G.longs();\n-    public static final RestrictableGenerator<Integer> GEN_INT = Generators.G.ints();\n-    public static final Generator<Float> GEN_FLOAT = Generators.G.floats();\n-    public static final Generator<Double> GEN_DOUBLE = Generators.G.doubles();\n-\n-    public static void main(String[] args) {\n-        TestFramework.run();\n-    }\n-\n-    @Run(test = {\n-        \"testI1\", \"testI2\",\n-        \"testL1\", \"testL2\",\n-        \"testS1\",\n-        \"testUS1\",\n-        \"testF1\",\n-        \"testD1\"\n-    })\n-    public void runMethod() {\n-        int ai = GEN_INT.next();\n-\n-        int mini = Integer.MIN_VALUE;\n-        int maxi = Integer.MAX_VALUE;\n-\n-        assertResultI(0);\n-        assertResultI(ai);\n-        assertResultI(mini);\n-        assertResultI(maxi);\n-\n-        long al = GEN_LONG.next();\n-\n-        long minl = Long.MIN_VALUE;\n-        long maxl = Long.MAX_VALUE;\n-\n-        assertResultL(0);\n-        assertResultL(al);\n-        assertResultL(minl);\n-        assertResultL(maxl);\n-\n-        short as = GEN_SHORT.next().shortValue();\n-\n-        short mins = Short.MIN_VALUE;\n-        short maxs = Short.MAX_VALUE;\n-\n-        assertResultS((short) 0);\n-        assertResultS(as);\n-        assertResultS(mins);\n-        assertResultS(maxs);\n-\n-        char ac = (char) GEN_CHAR.next().intValue();\n-\n-        char minc = Character.MIN_VALUE;\n-        char maxc = Character.MAX_VALUE;\n-\n-        assertResultUS((char) 0);\n-        assertResultUS(ac);\n-        assertResultUS(minc);\n-        assertResultUS(maxc);\n-\n-        float af = GEN_FLOAT.next();\n-        float inf = Float.POSITIVE_INFINITY;\n-        float nanf = Float.NaN;\n-\n-        assertResultF(0f);\n-        assertResultF(-0f);\n-        assertResultF(af);\n-        assertResultF(inf);\n-        assertResultF(nanf);\n-\n-        double ad = GEN_DOUBLE.next();\n-        double ind = Double.POSITIVE_INFINITY;\n-        double nand = Double.NaN;\n-\n-        assertResultD(0d);\n-        assertResultD(-0d);\n-        assertResultD(ad);\n-        assertResultD(ind);\n-        assertResultD(nand);\n-\n-    }\n-\n-    @DontCompile\n-    public void assertResultI(int a) {\n-        Asserts.assertEQ(Integer.reverseBytes(Integer.reverseBytes(a)), testI1(a));\n-        Asserts.assertEQ(Integer.reverse(Integer.reverse(a))          , testI2(a));\n-    }\n-\n-    @DontCompile\n-    public void assertResultL(long a) {\n-        Asserts.assertEQ(Long.reverseBytes(Long.reverseBytes(a)), testL1(a));\n-        Asserts.assertEQ(Long.reverse(Long.reverse(a))          , testL2(a));\n-    }\n-\n-    @DontCompile\n-    public void assertResultS(short a) {\n-        Asserts.assertEQ(Short.reverseBytes(Short.reverseBytes(a)), testS1(a));\n-    }\n-\n-    @DontCompile\n-    public void assertResultUS(char a) {\n-        Asserts.assertEQ(Character.reverseBytes(Character.reverseBytes(a)), testUS1(a));\n-    }\n-\n-    @DontCompile\n-    public void assertResultF(float a) {\n-        Asserts.assertEQ(Float.floatToRawIntBits(-(-a)), Float.floatToRawIntBits(testF1(a)));\n-    }\n-\n-    @DontCompile\n-    public void assertResultD(double a) {\n-        Asserts.assertEQ(Double.doubleToRawLongBits(-(-a)), Double.doubleToRawLongBits(testD1(a)));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.REVERSE_BYTES_I})\n-    public int testI1(int x) {\n-        return Integer.reverseBytes(Integer.reverseBytes(x));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.REVERSE_I})\n-    public int testI2(int x) {\n-        return Integer.reverse(Integer.reverse(x));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.REVERSE_BYTES_L})\n-    public long testL1(long x) {\n-        return Long.reverseBytes(Long.reverseBytes(x));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.REVERSE_L})\n-    public long testL2(long x) {\n-        return Long.reverse(Long.reverse(x));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.REVERSE_BYTES_S})\n-    public short testS1(short x) {\n-        return Short.reverseBytes(Short.reverseBytes(x));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.REVERSE_BYTES_US})\n-    public char testUS1(char x) {\n-        return Character.reverseBytes(Character.reverseBytes(x));\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.NEG_F})\n-    public float testF1(float x) {\n-        return -(-x);\n-    }\n-\n-    @Test\n-    @IR(failOn = {IRNode.NEG_D})\n-    public double testD1(double x) {\n-        return -(-x);\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/InvolutionIdentityTests.java","additions":0,"deletions":206,"binary":false,"changes":206,"status":"deleted"},{"patch":"@@ -1501,10 +1501,0 @@\n-    public static final String NEG_F = PREFIX + \"NEG_F\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(NEG_F, \"NegF\");\n-    }\n-\n-    public static final String NEG_D = PREFIX + \"NEG_D\" + POSTFIX;\n-    static {\n-        beforeMatchingNameRegex(NEG_D, \"NegD\");\n-    }\n-\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"}]}