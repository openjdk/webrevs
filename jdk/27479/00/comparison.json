{"files":[{"patch":"@@ -46,1 +46,1 @@\n-  _global_age_table = NEW_C_HEAP_ARRAY(AgeTable*, MAX_SNAPSHOTS, mtGC);\n+  _global_age_tables = NEW_C_HEAP_ARRAY(AgeTable*, MAX_SNAPSHOTS, mtGC);\n@@ -55,1 +55,1 @@\n-    _global_age_table[i] = new AgeTable(false);\n+    _global_age_tables[i] = new AgeTable(false);\n@@ -61,1 +61,1 @@\n-    _local_age_table = NEW_C_HEAP_ARRAY(AgeTable*, _max_workers, mtGC);\n+    _local_age_tables = NEW_C_HEAP_ARRAY(AgeTable*, _max_workers, mtGC);\n@@ -64,1 +64,1 @@\n-      _local_age_table[i] = new AgeTable(false);\n+      _local_age_tables[i] = new AgeTable(false);\n@@ -68,1 +68,6 @@\n-    _local_age_table = nullptr;\n+    _local_age_tables = nullptr;\n+  }\n+  _epoch = MAX_SNAPSHOTS - 1;  \/\/ see prepare_for_census_update()\n+\n+  if (!ShenandoahGenerationalAdaptiveTenuring) {\n+    _tenuring_threshold[_epoch] = InitialTenuringThreshold;\n@@ -70,1 +75,0 @@\n-  _epoch = MAX_SNAPSHOTS - 1;  \/\/ see update_epoch()\n@@ -75,1 +79,1 @@\n-    delete _global_age_table[i];\n+    delete _global_age_tables[i];\n@@ -77,1 +81,1 @@\n-  FREE_C_HEAP_ARRAY(AgeTable*, _global_age_table);\n+  FREE_C_HEAP_ARRAY(AgeTable*, _global_age_tables);\n@@ -80,1 +84,1 @@\n-  if (_local_age_table) {\n+  if (_local_age_tables) {\n@@ -82,1 +86,1 @@\n-      delete _local_age_table[i];\n+      delete _local_age_tables[i];\n@@ -84,1 +88,1 @@\n-    FREE_C_HEAP_ARRAY(AgeTable*, _local_age_table);\n+    FREE_C_HEAP_ARRAY(AgeTable*, _local_age_tables);\n@@ -145,1 +149,1 @@\n-  _global_age_table[_epoch]->clear();\n+  _global_age_tables[_epoch]->clear();\n@@ -151,1 +155,1 @@\n-void ShenandoahAgeCensus::update_census(size_t age0_pop, AgeTable* pv1, AgeTable* pv2) {\n+void ShenandoahAgeCensus::update_census(size_t age0_pop) {\n@@ -153,1 +157,2 @@\n-  assert(_global_age_table[_epoch]->is_clear(), \"Dirty decks\");\n+  assert(ShenandoahGenerationalAdaptiveTenuring, \"Only update census when adaptive tenuring is enabled\");\n+  assert(_global_age_tables[_epoch]->is_clear(), \"Dirty decks\");\n@@ -155,5 +160,0 @@\n-  if (ShenandoahGenerationalAdaptiveTenuring) {\n-    assert(pv1 == nullptr && pv2 == nullptr, \"Error, check caller\");\n-    \/\/ Seed cohort 0 with population that may have been missed during\n-    \/\/ regular census.\n-    _global_age_table[_epoch]->add(0u, age0_pop);\n@@ -161,15 +161,13 @@\n-    \/\/ Merge data from local age tables into the global age table for the epoch,\n-    \/\/ clearing the local tables.\n-    for (uint i = 0; i < _max_workers; i++) {\n-      \/\/ age stats\n-      _global_age_table[_epoch]->merge(_local_age_table[i]);\n-      _local_age_table[i]->clear();   \/\/ clear for next census\n-      \/\/ Merge noise stats\n-      CENSUS_NOISE(_global_noise[_epoch].merge(_local_noise[i]);)\n-      CENSUS_NOISE(_local_noise[i].clear();)\n-    }\n-  } else {\n-    \/\/ census during evac\n-    assert(pv1 != nullptr && pv2 != nullptr, \"Error, check caller\");\n-    _global_age_table[_epoch]->merge(pv1);\n-    _global_age_table[_epoch]->merge(pv2);\n+  \/\/ Seed cohort 0 with population that may have been missed during\n+  \/\/ regular census.\n+  _global_age_tables[_epoch]->add(0u, age0_pop);\n+\n+  \/\/ Merge data from local age tables into the global age table for the epoch,\n+  \/\/ clearing the local tables.\n+  for (uint i = 0; i < _max_workers; i++) {\n+    \/\/ age stats\n+    _global_age_tables[_epoch]->merge(_local_age_tables[i]);\n+    _local_age_tables[i]->clear();   \/\/ clear for next census\n+    \/\/ Merge noise stats\n+    CENSUS_NOISE(_global_noise[_epoch].merge(_local_noise[i]);)\n+    CENSUS_NOISE(_local_noise[i].clear();)\n@@ -191,1 +189,1 @@\n-    _global_age_table[i]->clear();\n+    _global_age_tables[i]->clear();\n@@ -201,1 +199,1 @@\n-    assert(_local_age_table == nullptr, \"Error\");\n+    assert(_local_age_tables == nullptr, \"Error\");\n@@ -205,1 +203,1 @@\n-    _local_age_table[i]->clear();\n+    _local_age_tables[i]->clear();\n@@ -215,1 +213,1 @@\n-    bool clear = _global_age_table[i]->is_clear();\n+    bool clear = _global_age_tables[i]->is_clear();\n@@ -227,1 +225,1 @@\n-    assert(_local_age_table == nullptr, \"Error\");\n+    assert(_local_age_tables == nullptr, \"Error\");\n@@ -231,1 +229,1 @@\n-    bool clear = _local_age_table[i]->is_clear();\n+    bool clear = _local_age_tables[i]->is_clear();\n@@ -243,1 +241,1 @@\n-  const AgeTable* pv = _global_age_table[snap];\n+  const AgeTable* pv = _global_age_tables[snap];\n@@ -263,7 +261,5 @@\n-  if (!ShenandoahGenerationalAdaptiveTenuring) {\n-    _tenuring_threshold[_epoch] = InitialTenuringThreshold;\n-  } else {\n-    uint tt = compute_tenuring_threshold();\n-    assert(tt <= MAX_COHORTS, \"Out of bounds\");\n-    _tenuring_threshold[_epoch] = tt;\n-  }\n+  assert(ShenandoahGenerationalAdaptiveTenuring, \"Only update when adaptive tenuring is enabled\");\n+  uint tt = compute_tenuring_threshold();\n+  assert(tt <= MAX_COHORTS, \"Out of bounds\");\n+  _tenuring_threshold[_epoch] = tt;\n+\n@@ -299,2 +295,2 @@\n-  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n-  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+  const AgeTable* cur_pv = _global_age_tables[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_tables[prev_epoch];\n@@ -375,2 +371,2 @@\n-  const AgeTable* cur_pv = _global_age_table[cur_epoch];\n-  const AgeTable* prev_pv = _global_age_table[prev_epoch];\n+  const AgeTable* cur_pv = _global_age_tables[cur_epoch];\n+  const AgeTable* prev_pv = _global_age_tables[prev_epoch];\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.cpp","additions":48,"deletions":52,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -100,2 +100,2 @@\n-  AgeTable** _global_age_table;      \/\/ Global age table used for adapting tenuring threshold, one per snapshot\n-  AgeTable** _local_age_table;       \/\/ Local scratch age tables to track object ages, one per worker\n+  AgeTable** _global_age_tables;      \/\/ Global age tables used for adapting tenuring threshold, one per snapshot\n+  AgeTable** _local_age_tables;       \/\/ Local scratch age tables to track object ages, one per worker\n@@ -178,1 +178,1 @@\n-    return _local_age_table[worker_id];\n+    return _local_age_tables[worker_id];\n@@ -212,5 +212,1 @@\n-  \/\/ Optional parameters, pv1 and pv2 are population vectors that together\n-  \/\/ provide object census data (only) for the case when\n-  \/\/ ShenandoahGenerationalCensusAtEvac. In this case, the age0_pop\n-  \/\/ is 0, because the evacuated objects have all had their ages incremented.\n-  void update_census(size_t age0_pop, AgeTable* pv1 = nullptr, AgeTable* pv2 = nullptr);\n+  void update_census(size_t age0_pop);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAgeCensus.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -204,20 +204,2 @@\n-      \/\/ Commit worker statistics to cycle data\n-      heap->phase_timings()->flush_par_workers_to_cycle();\n-\n-      \/\/ Print GC stats for current cycle\n-      {\n-        LogTarget(Info, gc, stats) lt;\n-        if (lt.is_enabled()) {\n-          ResourceMark rm;\n-          LogStream ls(lt);\n-          heap->phase_timings()->print_cycle_on(&ls);\n-          if (ShenandoahEvacTracking) {\n-            ShenandoahEvacuationTracker* evac_tracker = heap->evac_tracker();\n-            ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n-            evac_tracker->print_evacuations_on(&ls, &evac_stats.workers, &evac_stats.mutators);\n-          }\n-        }\n-      }\n-\n-      \/\/ Commit statistics to globals\n-      heap->phase_timings()->flush_cycle_to_global();\n+      \/\/ Manage and print gc stats\n+      heap->process_gc_stats();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":2,"deletions":20,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -26,1 +26,0 @@\n-#include \"gc\/shenandoah\/shenandoahAgeCensus.hpp\"\n@@ -47,13 +46,0 @@\n-ShenandoahEvacuationStats::ShenandoahEvacuationStats()\n-  : _use_age_table(!ShenandoahGenerationalAdaptiveTenuring),\n-    _age_table(nullptr) {\n-  if (_use_age_table) {\n-    _age_table = new AgeTable(false);\n-  }\n-}\n-\n-AgeTable* ShenandoahEvacuationStats::age_table() const {\n-  assert(_use_age_table, \"Don't call\");\n-  return _age_table;\n-}\n-\n@@ -73,7 +59,0 @@\n-void ShenandoahEvacuationStats::record_age(size_t bytes, uint age) {\n-  assert(_use_age_table, \"Don't call!\");\n-  if (age <= markWord::max_age) { \/\/ Filter age sentinel.\n-    _age_table->add(age, bytes >> LogBytesPerWord);\n-  }\n-}\n-\n@@ -84,4 +63,0 @@\n-\n-  if (_use_age_table) {\n-    _age_table->merge(other->age_table());\n-  }\n@@ -94,4 +69,0 @@\n-\n-  if (_use_age_table) {\n-    _age_table->clear();\n-  }\n@@ -115,4 +86,0 @@\n-\n-  if (_use_age_table) {\n-    _age_table->print_on(st);\n-  }\n@@ -128,22 +95,7 @@\n-  if (ShenandoahEvacTracking) {\n-    st->print_cr(\"Workers: \");\n-    workers->print_on(st);\n-    st->cr();\n-    st->print_cr(\"Mutators: \");\n-    mutators->print_on(st);\n-    st->cr();\n-  }\n-\n-  ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  if (heap->mode()->is_generational()) {\n-    AgeTable young_region_ages(false);\n-    for (uint i = 0; i < heap->num_regions(); ++i) {\n-      ShenandoahHeapRegion* r = heap->get_region(i);\n-      if (r->is_young()) {\n-        young_region_ages.add(r->age(), r->get_live_data_words());\n-      }\n-    }\n-    st->print(\"Young regions: \");\n-    young_region_ages.print_on(st);\n-    st->cr();\n-  }\n+  assert(ShenandoahEvacTracking, \"Only when evac tracking is enabled\");\n+  st->print_cr(\"Workers: \");\n+  workers->print_on(st);\n+  st->cr();\n+  st->print_cr(\"Mutators: \");\n+  mutators->print_on(st);\n+  st->cr();\n@@ -176,9 +128,0 @@\n-  if (!ShenandoahGenerationalAdaptiveTenuring) {\n-    \/\/ Ingest mutator & worker collected population vectors into the heap's\n-    \/\/ global census data, and use it to compute an appropriate tenuring threshold\n-    \/\/ for use in the next cycle.\n-    \/\/ The first argument is used for any age 0 cohort population that we may otherwise have\n-    \/\/ missed during the census. This is non-zero only when census happens at marking.\n-    ShenandoahGenerationalHeap::heap()->age_census()->update_census(0, mutators.age_table(), workers.age_table());\n-  }\n-\n@@ -195,4 +138,0 @@\n-\n-void ShenandoahEvacuationTracker::record_age(Thread* thread, size_t bytes, uint age) {\n-  ShenandoahThreadLocalData::record_age(thread, bytes, age);\n-}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.cpp","additions":7,"deletions":68,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -69,3 +69,0 @@\n-  bool      _use_age_table;\n-  AgeTable* _age_table;\n-\n@@ -73,4 +70,0 @@\n-  ShenandoahEvacuationStats();\n-\n-  AgeTable* age_table() const;\n-\n@@ -82,1 +75,0 @@\n-  void record_age(size_t bytes, uint age);\n@@ -109,1 +101,0 @@\n-  void record_age(Thread* thread, size_t bytes, uint age);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahEvacTracker.hpp","additions":0,"deletions":9,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -204,0 +204,18 @@\n+void ShenandoahGenerationalControlThread::maybe_print_young_region_ages() const {\n+  LogTarget(Debug, gc, age) lt;\n+  if (lt.is_enabled()) {\n+    LogStream ls(lt);\n+    AgeTable young_region_ages(false);\n+    for (uint i = 0; i < _heap->num_regions(); ++i) {\n+      const ShenandoahHeapRegion* r = _heap->get_region(i);\n+      if (r->is_young()) {\n+        young_region_ages.add(r->age(), r->get_live_data_words());\n+      }\n+    }\n+\n+    ls.print(\"Young regions: \");\n+    young_region_ages.print_on(&ls);\n+    ls.cr();\n+  }\n+}\n+\n@@ -301,1 +319,5 @@\n-  process_phase_timings();\n+  \/\/ Manage and print gc stats\n+  _heap->process_gc_stats();\n+\n+  \/\/ Print table for young region ages if log is enabled\n+  maybe_print_young_region_ages();\n@@ -320,23 +342,0 @@\n-void ShenandoahGenerationalControlThread::process_phase_timings() const {\n-  \/\/ Commit worker statistics to cycle data\n-  _heap->phase_timings()->flush_par_workers_to_cycle();\n-\n-  ShenandoahEvacuationTracker* evac_tracker = _heap->evac_tracker();\n-  ShenandoahCycleStats         evac_stats   = evac_tracker->flush_cycle_to_global();\n-\n-  \/\/ Print GC stats for current cycle\n-  {\n-    LogTarget(Info, gc, stats) lt;\n-    if (lt.is_enabled()) {\n-      ResourceMark rm;\n-      LogStream ls(lt);\n-      _heap->phase_timings()->print_cycle_on(&ls);\n-      evac_tracker->print_evacuations_on(&ls, &evac_stats.workers,\n-                                              &evac_stats.mutators);\n-    }\n-  }\n-\n-  \/\/ Commit statistics to globals\n-  _heap->phase_timings()->flush_cycle_to_global();\n-}\n-\n@@ -420,1 +419,1 @@\n-      process_phase_timings();\n+      _heap->process_gc_stats();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.cpp","additions":24,"deletions":25,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -132,3 +132,0 @@\n-  \/\/ Flushes cycle timings to global timings and prints the phase timings for the last completed cycle.\n-  void process_phase_timings() const;\n-\n@@ -163,0 +160,3 @@\n+\n+  \/\/ Print table for young region ages if log is enabled\n+  void maybe_print_young_region_ages() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalControlThread.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -363,5 +363,0 @@\n-      \/\/ We record this census only when simulating pre-adaptive tenuring behavior, or\n-      \/\/ when we have been asked to record the census at evacuation rather than at mark\n-      if (!ShenandoahGenerationalAdaptiveTenuring) {\n-        evac_tracker()->record_age(thread, size * HeapWordSize, ShenandoahHeap::get_object_age(copy_val));\n-      }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1444,0 +1444,21 @@\n+void ShenandoahHeap::process_gc_stats() const {\n+  \/\/ Commit worker statistics to cycle data\n+  phase_timings()->flush_par_workers_to_cycle();\n+\n+  \/\/ Print GC stats for current cycle\n+  LogTarget(Info, gc, stats) lt;\n+  if (lt.is_enabled()) {\n+    ResourceMark rm;\n+    LogStream ls(lt);\n+    phase_timings()->print_cycle_on(&ls);\n+    if (ShenandoahEvacTracking) {\n+      ShenandoahCycleStats  evac_stats = evac_tracker()->flush_cycle_to_global();\n+      evac_tracker()->print_evacuations_on(&ls, &evac_stats.workers,\n+                                               &evac_stats.mutators);\n+    }\n+  }\n+\n+  \/\/ Commit statistics to globals\n+  phase_timings()->flush_cycle_to_global();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -209,1 +209,1 @@\n-  void print_gc_on(outputStream *st)           const override;\n+  void print_gc_on(outputStream* st)           const override;\n@@ -212,0 +212,3 @@\n+  \/\/ Flushes cycle timings to global timings and prints the phase timings for the last completed cycle.\n+  void process_gc_stats() const;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -169,4 +169,0 @@\n-  static void record_age(Thread* thread, size_t bytes, uint age) {\n-    data(thread)->_evacuation_stats->record_age(bytes, age);\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahThreadLocalData.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"}]}