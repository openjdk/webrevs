{"files":[{"patch":"@@ -427,46 +427,1 @@\n-                    writeToSlow(pool);\n-                }\n-            }\n-        }\n-\n-        private void writeToSlow(BufWriterImpl pool) {\n-            for (int i = 0; i < charLen; ++i) {\n-                char c = stringValue.charAt(i);\n-                if (c >= '\\001' && c <= '\\177') {\n-                    \/\/ Optimistic writing -- hope everything is bytes\n-                    \/\/ If not, we bail out, and alternate path patches the length\n-                    pool.writeU1((byte) c);\n-                }\n-                else {\n-                    int charLength = stringValue.length();\n-                    int byteLength = i;\n-                    char c1;\n-                    for (int j = i; j < charLength; ++j) {\n-                        c1 = (stringValue).charAt(j);\n-                        if (c1 >= '\\001' && c1 <= '\\177') {\n-                            byteLength++;\n-                        } else if (c1 > '\\u07FF') {\n-                            byteLength += 3;\n-                        } else {\n-                            byteLength += 2;\n-                        }\n-                    }\n-                    if (byteLength > 65535) {\n-                        throw new IllegalArgumentException();\n-                    }\n-                    int byteLengthFinal = byteLength;\n-                    pool.patchInt(pool.size() - i - 2, 2, byteLengthFinal);\n-                    for (int j = i; j < charLength; ++j) {\n-                        c1 = (stringValue).charAt(j);\n-                        if (c1 >= '\\001' && c1 <= '\\177') {\n-                            pool.writeU1((byte) c1);\n-                        } else if (c1 > '\\u07FF') {\n-                            pool.writeU1((byte) (0xE0 | c1 >> 12 & 0xF));\n-                            pool.writeU1((byte) (0x80 | c1 >> 6 & 0x3F));\n-                            pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                        } else {\n-                            pool.writeU1((byte) (0xC0 | c1 >> 6 & 0x1F));\n-                            pool.writeU1((byte) (0x80 | c1 & 0x3F));\n-                        }\n-                    }\n-                    break;\n+                    pool.writeUTF(stringValue);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":1,"deletions":46,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -139,0 +139,23 @@\n+    void writeUTF(String s) {\n+        int charLength = s.length();\n+        reserveSpace(charLength * 3);\n+        int offset = this.offset;\n+        byte[] elems = this.elems;\n+        for (int i = 0; i < charLength; ++i) {\n+            char c = s.charAt(i);\n+            if (c >= '\\001' && c <= '\\177') {\n+                elems[offset++] = (byte) c;\n+            } else if (c > '\\u07FF') {\n+                elems[offset    ] = (byte) (0xE0 | c >> 12 & 0xF);\n+                elems[offset + 1] = (byte) (0x80 | c >> 6 & 0x3F);\n+                elems[offset + 2] = (byte) (0x80 | c & 0x3F);\n+                offset += 3;\n+            } else {\n+                elems[offset    ] = (byte) (0xC0 | c >> 6 & 0x1F);\n+                elems[offset + 1] = (byte) (0x80 | c & 0x3F);\n+                offset += 2;\n+            }\n+        }\n+        this.offset = offset;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"}]}