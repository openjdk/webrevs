{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.event.FileReadEvent;\n@@ -62,0 +63,6 @@\n+    \/**\n+     * Flag set by jdk.internal.event.JFRTracing to determines if\n+     * file reads should be traced by JFR.\n+     *\/\n+    private static boolean jfrTracing;\n+\n@@ -225,0 +232,3 @@\n+        if (jfrTracing) {\n+            return traceRead0();\n+        }\n@@ -230,0 +240,25 @@\n+    private int traceRead0() throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return read0();\n+        }\n+        int result = 0;\n+        boolean endOfFile = false;\n+        long bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            result = read0();\n+            if (result < 0) {\n+                endOfFile = true;\n+            } else {\n+                bytesRead = 1;\n+            }\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -239,0 +274,22 @@\n+    private int traceReadBytes(byte b[], int off, int len) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return readBytes(b, off, len);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = readBytes(b, off, len);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -252,0 +309,3 @@\n+        if (jfrTracing) {\n+            return traceReadBytes(b, 0, b.length);\n+        }\n@@ -271,0 +331,3 @@\n+        if (jfrTracing) {\n+            return traceReadBytes(b, off, len);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":63,"deletions":0,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.event.FileWriteEvent;\n@@ -71,0 +72,6 @@\n+    \/**\n+     * Flag set by jdk.internal.event.JFRTracing to determines if\n+     * file writes should be traced by JFR.\n+     *\/\n+    private static boolean jfrTracing;\n+\n@@ -300,0 +307,19 @@\n+    private void traceWrite(int b, boolean append) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            write(b, append);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            write(b, append);\n+            bytesWritten = 1;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n@@ -310,0 +336,4 @@\n+        if (jfrTracing) {\n+            traceWrite(b, append);\n+            return;\n+        }\n@@ -325,0 +355,19 @@\n+    private void traceWriteBytes(byte b[], int off, int len, boolean append) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            writeBytes(b, off, len, append);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            writeBytes(b, off, len, append);\n+            bytesWritten = len;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n@@ -335,0 +384,4 @@\n+        if (jfrTracing) {\n+            traceWriteBytes(b, 0, b.length, append);\n+            return;\n+        }\n@@ -351,0 +404,4 @@\n+        if (jfrTracing) {\n+            traceWriteBytes(b, off, len, append);\n+            return;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.event.FileReadEvent;\n+import jdk.internal.event.FileWriteEvent;\n@@ -71,0 +73,6 @@\n+    \/**\n+     * Flag set by jdk.internal.event.JFRTracing to determines if\n+     * file reads and writes should be traced by JFR.\n+     *\/\n+    private static boolean jfrTracing;\n+\n@@ -379,0 +387,3 @@\n+        if (jfrTracing) {\n+            return traceRead0();\n+        }\n@@ -384,0 +395,25 @@\n+    private int traceRead0() throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return read0();\n+        }\n+        int result = 0;\n+        long bytesRead = 0;\n+        boolean endOfFile = false;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            result = read0();\n+            if (result < 0) {\n+                endOfFile = true;\n+            } else {\n+                bytesRead = 1;\n+            }\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -392,0 +428,3 @@\n+        if (jfrTracing) {\n+            return traceReadBytes0(b, off, len);\n+        }\n@@ -397,0 +436,22 @@\n+    private int traceReadBytes0(byte b[], int off, int len) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return readBytes0(b, off, len);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = readBytes0(b, off, len);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -540,0 +601,8 @@\n+        if (jfrTracing) {\n+            traceImplWrite(b);\n+            return;\n+        }\n+        implWrite(b);\n+    }\n+\n+    private void implWrite(int b) throws IOException {\n@@ -548,0 +617,19 @@\n+    private void traceImplWrite(int b) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            implWrite(b);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            implWrite(b);\n+            bytesWritten = 1;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n@@ -559,0 +647,8 @@\n+        if (jfrTracing) {\n+            traceImplWriteBytes(b, off, len);\n+            return;\n+        }\n+        implWriteBytes(b, off, len);\n+    }\n+\n+    private void implWriteBytes(byte[] b, int off, int len) throws IOException {\n@@ -567,0 +663,19 @@\n+    private void traceImplWriteBytes(byte b[], int off, int len) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            implWriteBytes(b, off, len);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            implWriteBytes(b, off, len);\n+            bytesWritten = len;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -123,1 +123,2 @@\n-     * Flag that determines if exceptions should be traced by JFR\n+     * Flag set by jdk.internal.event.JFRTracing to determines if\n+     * exceptions should be traced by JFR.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Throwable.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.event;\n+\n+\/**\n+ * Event recording file reads.\n+ *\/\n+public final class FileReadEvent extends Event {\n+\n+    \/\/ The order of these fields must be the same as the parameters in\n+    \/\/ commit(..., String, long, boolean)\n+    public String path;\n+    public long bytesRead;\n+    public boolean endOfFile;\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0L;\n+    }\n+\n+    public static boolean shouldCommit(long duration) {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static void commit(long start, long duration, String path, long bytesRead, boolean endOfFile) {\n+        \/\/ Generated by JFR\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/FileReadEvent.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.event;\n+\n+\/**\n+ * Event recording file writes.\n+ *\/\n+public final class FileWriteEvent extends Event {\n+\n+    \/\/ The order of these fields must be the same as the parameters in\n+    \/\/ commit(..., String, long)\n+    public String path;\n+    public long bytesWritten;\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0L;\n+    }\n+\n+    public static boolean shouldCommit(long duration) {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static void commit(long start, long duration, String path, long bytesWritten) {\n+        \/\/ Generated by JFR\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/FileWriteEvent.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.event;\n+\n+import sun.nio.ch.FileChannelImpl;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.RandomAccessFile;\n+import java.lang.Throwable;\n+import java.lang.reflect.Field;\n+\n+\/**\n+ * Helper class to enable JFR tracing.\n+ *\/\n+public final class JFRTracing {\n+\n+  public static void enable() throws NoSuchFieldException, IllegalAccessException {\n+      enable(Throwable.class);\n+      enable(FileInputStream.class);\n+      enable(FileOutputStream.class);\n+      enable(FileChannelImpl.class);\n+      enable(RandomAccessFile.class);\n+  }\n+\n+  private static void enable(Class<?> clazz) throws NoSuchFieldException, IllegalAccessException {\n+      Field field = clazz.getDeclaredField(\"jfrTracing\");\n+      field.setAccessible(true);\n+      field.setBoolean(null, true);\n+  }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/JFRTracing.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.lang.reflect.Field;\n@@ -37,6 +36,0 @@\n-    public static void enable() throws NoSuchFieldException, IllegalAccessException {\n-        Field field = Throwable.class.getDeclaredField(\"jfrTracing\");\n-        field.setAccessible(true);\n-        field.setBoolean(null, true);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/ThrowableTracer.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-\n+import jdk.internal.event.FileReadEvent;\n+import jdk.internal.event.FileWriteEvent;\n@@ -76,0 +77,4 @@\n+    \/\/ Flag set by jdk.internal.event.JFRTracing to determines if\n+    \/\/ file reads and writes should be traced by JFR.\n+    private static boolean jfrTracing;\n+\n@@ -223,0 +228,7 @@\n+        if (jfrTracing) {\n+            return traceImplRead(dst);\n+        }\n+        return implRead(dst);\n+    }\n+\n+    private int implRead(ByteBuffer dst) throws IOException {\n@@ -253,0 +265,22 @@\n+    private int traceImplRead(ByteBuffer dst) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return implRead(dst);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = implRead(dst);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -254,1 +288,8 @@\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (jfrTracing) {\n+            return traceImplRead(dsts, offset, length);\n+        }\n+        return implRead(dsts, offset, length);\n+    }\n+\n+    private long implRead(ByteBuffer[] dsts, int offset, int length)\n@@ -289,0 +330,22 @@\n+    private long traceImplRead(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return implRead(dsts, offset, length);\n+        }\n+        long bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = implRead(dsts, offset, length);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -291,0 +354,7 @@\n+        if (jfrTracing) {\n+            return traceImplWrite(src);\n+        }\n+        return implWrite(src);\n+    }\n+\n+    private int implWrite(ByteBuffer src) throws IOException {\n@@ -322,0 +392,19 @@\n+    private int traceImplWrite(ByteBuffer src) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            return implWrite(src);\n+        }\n+        int bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            bytesWritten = implWrite(src);\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n+                FileWriteEvent.commit(start, duration, path, bytes);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+\n@@ -323,3 +412,8 @@\n-    public long write(ByteBuffer[] srcs, int offset, int length)\n-        throws IOException\n-    {\n+    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        if (jfrTracing) {\n+            return traceImplWrite(srcs, offset, length);\n+        }\n+        return implWrite(srcs, offset, length);\n+    }\n+\n+    private long implWrite(ByteBuffer[] srcs, int offset, int length) throws IOException {\n@@ -357,0 +451,18 @@\n+    private long traceImplWrite(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            return implWrite(srcs, offset, length);\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            bytesWritten = implWrite(srcs, offset, length);\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n+                FileWriteEvent.commit(start, duration, path, bytes);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n@@ -1031,0 +1143,7 @@\n+        if (jfrTracing) {\n+            return traceImplRead(dst, position);\n+        }\n+        return implRead(dst, position);\n+    }\n+\n+    private int implRead(ByteBuffer dst, long position) throws IOException {\n@@ -1049,0 +1168,22 @@\n+    private int traceImplRead(ByteBuffer dst, long position) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return implRead(dst, position);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = implRead(dst, position);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -1077,0 +1218,7 @@\n+        if (jfrTracing) {\n+            return traceImplWrite(src, position);\n+        }\n+        return implWrite(src, position);\n+    }\n+\n+    private int implWrite(ByteBuffer src, long position) throws IOException {\n@@ -1095,0 +1243,20 @@\n+    private int traceImplWrite(ByteBuffer src, long position) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            return implWrite(src, position);\n+        }\n+\n+        int bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            bytesWritten = implWrite(src, position);\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n+                FileWriteEvent.commit(start, duration, path, bytes);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":173,"deletions":5,"binary":false,"changes":178,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.events;\n-import jdk.jfr.internal.JVMSupport;\n-import jdk.jfr.internal.event.EventConfiguration;\n-\n-public final class EventConfigurations {\n-    public static final EventConfiguration FILE_READ = JVMSupport.getConfiguration(FileReadEvent.class);\n-    public static final EventConfiguration FILE_WRITE = JVMSupport.getConfiguration(FileWriteEvent.class);\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/EventConfigurations.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.MirrorEvent;\n@@ -39,4 +40,2 @@\n-public final class FileReadEvent extends AbstractJDKEvent {\n-\n-    \/\/ The order of these fields must be the same as the parameters in\n-    \/\/ commit(..., String, long, boolean)\n+@StackFilter({\"java.io.FileInputStream\", \"java.io.RandomAccessFile\", \"sun.nio.ch.FileChannelImpl\"})\n+public final class FileReadEvent extends MirrorEvent {\n@@ -57,3 +56,0 @@\n-    public static void commit(long start, long duration, String path, long bytesRead, boolean endOfFile) {\n-        \/\/ Generated\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileReadEvent.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.MirrorEvent;\n@@ -39,4 +40,2 @@\n-public final class FileWriteEvent extends AbstractJDKEvent {\n-\n-    \/\/ The order of these fields must be the same as the parameters in\n-    \/\/ commit(..., String, long)\n+@StackFilter({\"java.io.FileOutputStream\", \"java.io.RandomAccessFile\", \"sun.nio.ch.FileChannelImpl\"})\n+public final class FileWriteEvent extends MirrorEvent {\n@@ -52,4 +51,0 @@\n-\n-    public static void commit(long start, long duration, String path, long bytesWritten) {\n-        \/\/ Generated\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileWriteEvent.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.jfr.events.FileReadEvent;\n+import jdk.jfr.events.FileWriteEvent;\n@@ -60,0 +62,2 @@\n+        register(\"jdk.internal.event.FileReadEvent\", FileReadEvent.class);\n+        register(\"jdk.internal.event.FileWriteEvent\", FileWriteEvent.class);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvents.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import jdk.jfr.events.FileForceEvent;\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.events.FileWriteEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.events.EventConfigurations;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"sun.nio.ch.FileChannelImpl\")\n-final class FileChannelImplInstrumentor {\n-\n-    private FileChannelImplInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public int read(ByteBuffer dst) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(dst);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(dst);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(ByteBuffer dst, long position) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(dst, position);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(dst, position);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(dsts, offset, length);\n-        }\n-        long bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(dsts, offset, length);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int write(ByteBuffer src) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            return write(src);\n-        }\n-        int bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesWritten = write(src);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int write(ByteBuffer src, long position) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            return write(src, position);\n-        }\n-\n-        int bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesWritten = write(src, position);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            return write(srcs, offset, length);\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesWritten = write(srcs, offset, length);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileChannelImplInstrumentor.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-\n-import jdk.jfr.events.EventConfigurations;\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"java.io.FileInputStream\")\n-final class FileInputStreamInstrumentor {\n-\n-    private FileInputStreamInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public int read() throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read();\n-        }\n-        int result = 0;\n-        boolean endOfFile = false;\n-        long bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            result = read();\n-            if (result < 0) {\n-                endOfFile = true;\n-            } else {\n-                bytesRead = 1;\n-            }\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b, off, len);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b, off, len);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileInputStreamInstrumentor.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-\n-import jdk.jfr.events.FileWriteEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.events.EventConfigurations;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"java.io.FileOutputStream\")\n-final class FileOutputStreamInstrumentor {\n-\n-    private FileOutputStreamInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public void write(int b) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = 1;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = b.length;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b, off, len);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b, off, len);\n-            bytesWritten = len;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileOutputStreamInstrumentor.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,1 @@\n+import jdk.internal.event.JFRTracing;\n@@ -44,2 +45,0 @@\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.events.FileWriteEvent;\n@@ -60,2 +59,0 @@\n-        FileReadEvent.class,\n-        FileWriteEvent.class,\n@@ -71,0 +68,2 @@\n+        jdk.internal.event.FileReadEvent.class,\n+        jdk.internal.event.FileWriteEvent.class,\n@@ -91,4 +90,0 @@\n-        FileInputStreamInstrumentor.class,\n-        FileOutputStreamInstrumentor.class,\n-        RandomAccessFileInstrumentor.class,\n-        FileChannelImplInstrumentor.class\n@@ -121,1 +116,1 @@\n-                ThrowableTracer.enable();\n+                JFRTracing.enable();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":5,"deletions":10,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.events.FileWriteEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.events.EventConfigurations;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"java.io.RandomAccessFile\")\n-final class RandomAccessFileInstrumentor {\n-\n-    private RandomAccessFileInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public int read() throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read();\n-        }\n-        int result = 0;\n-        long bytesRead = 0;\n-        boolean endOfFile = false;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            result = read();\n-            if (result < 0) {\n-                endOfFile = true;\n-            } else {\n-                bytesRead = 1;\n-            }\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b, off, len);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b, off, len);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(int b) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = 1;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = b.length;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b, off, len);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b, off, len);\n-            bytesWritten = len;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/RandomAccessFileInstrumentor.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        \/\/ When JFR is initialized the FileReadEvent is registered and an EventConfiguration object\n+        \/\/ When JFR is initialized the DirectBufferStatisticsEvent is registered and an EventConfiguration object\n@@ -55,1 +55,1 @@\n-        Class<?>c = Class.forName(\"jdk.jfr.events.FileReadEvent\");\n+        Class<?>c = Class.forName(\"jdk.jfr.events.DirectBufferStatisticsEvent\");\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriterPackage.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    private static final String FILE_READ_FORCED_CLASS_LOAD = \"Adding forced instrumentation for event type \" + EventNames.FileRead + \" during initial class load\";\n+    private static final String FORCED_CLASS_LOAD = \"Adding forced instrumentation for event type \" + EventNames.DirectBufferStatistics + \" during initial class load\";\n@@ -64,1 +64,1 @@\n-            out.shouldContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldContain(FORCED_CLASS_LOAD);\n@@ -71,1 +71,1 @@\n-            out.shouldContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldContain(FORCED_CLASS_LOAD);\n@@ -78,1 +78,1 @@\n-            out.shouldNotContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldNotContain(FORCED_CLASS_LOAD);\n@@ -85,1 +85,1 @@\n-            out.shouldNotContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldNotContain(FORCED_CLASS_LOAD);\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestRetransformUsingLog.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"}]}