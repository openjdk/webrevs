{"files":[{"patch":"@@ -552,1 +552,1 @@\n-            traceWriteImpl(b);\n+            traceImplWrite(b);\n@@ -555,1 +555,1 @@\n-        writeImpl(b);\n+        implWrite(b);\n@@ -558,1 +558,1 @@\n-    private void writeImpl(int b) throws IOException {\n+    private void implWrite(int b) throws IOException {\n@@ -579,1 +579,1 @@\n-            traceWriteBytesImpl(b, off, len);\n+            traceImplWriteBytes(b, off, len);\n@@ -582,1 +582,1 @@\n-        writeBytesImpl(b, off, len);\n+        implWriteBytes(b, off, len);\n@@ -585,1 +585,1 @@\n-    private void writeBytesImpl(byte[] b, int off, int len) throws IOException {\n+    private void implWriteBytes(byte[] b, int off, int len) throws IOException {\n@@ -1275,1 +1275,1 @@\n-    private void traceWriteImpl(int b) throws IOException {\n+    private void traceImplWrite(int b) throws IOException {\n@@ -1277,1 +1277,1 @@\n-            writeImpl(b);\n+            implWrite(b);\n@@ -1284,1 +1284,1 @@\n-            writeImpl(b);\n+            implWrite(b);\n@@ -1294,1 +1294,1 @@\n-    private void traceWriteBytesImpl(byte b[], int off, int len) throws IOException {\n+    private void traceImplWriteBytes(byte b[], int off, int len) throws IOException {\n@@ -1296,1 +1296,1 @@\n-            writeBytesImpl(b, off, len);\n+            implWriteBytes(b, off, len);\n@@ -1303,1 +1303,1 @@\n-            writeBytesImpl(b, off, len);\n+            ImplWriteBytes(b, off, len);\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -228,1 +228,1 @@\n-            return traceReadImpl(dst);\n+            return traceImplRead(dst);\n@@ -230,1 +230,1 @@\n-        return readImpl(dst);\n+        return implRead(dst);\n@@ -233,1 +233,1 @@\n-    private int readImpl(ByteBuffer dst) throws IOException {\n+    private int implRead(ByteBuffer dst) throws IOException {\n@@ -267,1 +267,1 @@\n-            return traceReadImpl(dsts, offset, length);\n+            return traceImplRead(dsts, offset, length);\n@@ -269,1 +269,1 @@\n-        return readImpl(dsts, offset, length);\n+        return implRead(dsts, offset, length);\n@@ -272,1 +272,1 @@\n-    private long readImpl(ByteBuffer[] dsts, int offset, int length)\n+    private long implRead(ByteBuffer[] dsts, int offset, int length)\n@@ -310,1 +310,1 @@\n-            return traceWriteImpl(src);\n+            return traceImplWrite(src);\n@@ -312,1 +312,1 @@\n-        return writeImpl(src);\n+        return implWrite(src);\n@@ -315,1 +315,1 @@\n-    private int writeImpl(ByteBuffer src) throws IOException {\n+    private int implWrite(ByteBuffer src) throws IOException {\n@@ -350,1 +350,1 @@\n-            return traceWriteImpl(srcs, offset, length);\n+            return traceImplWrite(srcs, offset, length);\n@@ -352,1 +352,1 @@\n-        return writeImpl(srcs, offset, length);\n+        return implWrite(srcs, offset, length);\n@@ -355,1 +355,1 @@\n-    private long writeImpl(ByteBuffer[] srcs, int offset, int length) throws IOException\n+    private long implWrite(ByteBuffer[] srcs, int offset, int length) throws IOException\n@@ -1063,1 +1063,1 @@\n-            return traceReadImpl(dst, position);\n+            return traceImplRead(dst, position);\n@@ -1065,1 +1065,1 @@\n-        return readImpl(dst, position);\n+        return implRead(dst, position);\n@@ -1068,1 +1068,1 @@\n-    private int readImpl(ByteBuffer dst, long position) throws IOException {\n+    private int implRead(ByteBuffer dst, long position) throws IOException {\n@@ -1116,1 +1116,1 @@\n-            return traceWriteImpl(src, position);\n+            return traceImplWrite(src, position);\n@@ -1118,1 +1118,1 @@\n-        return writeImpl(src, position);\n+        return implWrite(src, position);\n@@ -1121,1 +1121,1 @@\n-    private int writeImpl(ByteBuffer src, long position) throws IOException {\n+    private int implWrite(ByteBuffer src, long position) throws IOException {\n@@ -1666,1 +1666,1 @@\n-    private int traceReadImpl(ByteBuffer dst) throws IOException {\n+    private int traceImplRead(ByteBuffer dst) throws IOException {\n@@ -1668,1 +1668,1 @@\n-            return readImpl(dst);\n+            return implRead(dst);\n@@ -1674,1 +1674,1 @@\n-            bytesRead = readImpl(dst);\n+            bytesRead = implRead(dst);\n@@ -1688,1 +1688,1 @@\n-    private int traceReadImpl(ByteBuffer dst, long position) throws IOException {\n+    private int traceImplRead(ByteBuffer dst, long position) throws IOException {\n@@ -1690,1 +1690,1 @@\n-            return readImpl(dst, position);\n+            return implRead(dst, position);\n@@ -1696,1 +1696,1 @@\n-            bytesRead = readImpl(dst, position);\n+            bytesRead = implRead(dst, position);\n@@ -1710,1 +1710,1 @@\n-    private long traceReadImpl(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+    private long traceImplRead(ByteBuffer[] dsts, int offset, int length) throws IOException {\n@@ -1712,1 +1712,1 @@\n-            return readImpl(dsts, offset, length);\n+            return implRead(dsts, offset, length);\n@@ -1718,1 +1718,1 @@\n-            bytesRead = readImpl(dsts, offset, length);\n+            bytesRead = implRead(dsts, offset, length);\n@@ -1732,1 +1732,1 @@\n-    private int traceWriteImpl(ByteBuffer src) throws IOException {\n+    private int traceImplWrite(ByteBuffer src) throws IOException {\n@@ -1734,1 +1734,1 @@\n-            return writeImpl(src);\n+            return implWrite(src);\n@@ -1740,1 +1740,1 @@\n-            bytesWritten = writeImpl(src);\n+            bytesWritten = implWrite(src);\n@@ -1751,1 +1751,1 @@\n-    private int traceWriteImpl(ByteBuffer src, long position) throws IOException {\n+    private int traceImplWrite(ByteBuffer src, long position) throws IOException {\n@@ -1753,1 +1753,1 @@\n-            return writeImpl(src, position);\n+            return implWrite(src, position);\n@@ -1760,1 +1760,1 @@\n-            bytesWritten = writeImpl(src, position);\n+            bytesWritten = implWrite(src, position);\n@@ -1771,1 +1771,1 @@\n-    private long traceWriteImpl(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+    private long traceImplWrite(ByteBuffer[] srcs, int offset, int length) throws IOException {\n@@ -1773,1 +1773,1 @@\n-            return writeImpl(srcs, offset, length);\n+            return implWrite(srcs, offset, length);\n@@ -1779,1 +1779,1 @@\n-            bytesWritten = writeImpl(srcs, offset, length);\n+            bytesWritten = implWrite(srcs, offset, length);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal;\n+\n+import java.util.Properties;\n+\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.event.JFRTracing;\n+import jdk.internal.event.ThrowableTracer;\n+import jdk.internal.platform.Container;\n+import jdk.internal.platform.Metrics;\n+import jdk.jfr.Event;\n+import jdk.jfr.events.ActiveRecordingEvent;\n+import jdk.jfr.events.ActiveSettingEvent;\n+import jdk.jfr.events.ContainerCPUThrottlingEvent;\n+import jdk.jfr.events.ContainerCPUUsageEvent;\n+import jdk.jfr.events.ContainerConfigurationEvent;\n+import jdk.jfr.events.ContainerIOUsageEvent;\n+import jdk.jfr.events.ContainerMemoryUsageEvent;\n+import jdk.jfr.events.DirectBufferStatisticsEvent;\n+import jdk.jfr.events.InitialSecurityPropertyEvent;\n+import jdk.jfr.internal.periodic.PeriodicEvents;\n+\n+public final class JDKEvents {\n+\n+    private static final Class<?>[] eventClasses = {\n+        ActiveSettingEvent.class,\n+        ActiveRecordingEvent.class,\n+        \/\/ jdk.internal.event.* classes need their mirror\n+        \/\/ event class to be listed in the MirrorEvents class.\n+        jdk.internal.event.DeserializationEvent.class,\n+        jdk.internal.event.ErrorThrownEvent.class,\n+        jdk.internal.event.ExceptionStatisticsEvent.class,\n+        jdk.internal.event.ExceptionThrownEvent.class,\n+        jdk.internal.event.FileForceEvent.class,\n+        jdk.internal.event.FileReadEvent.class,\n+        jdk.internal.event.FileWriteEvent.class,\n+        jdk.internal.event.ProcessStartEvent.class,\n+        jdk.internal.event.SecurityPropertyModificationEvent.class,\n+        jdk.internal.event.SecurityProviderServiceEvent.class,\n+        jdk.internal.event.SerializationMisdeclarationEvent.class,\n+        jdk.internal.event.SocketReadEvent.class,\n+        jdk.internal.event.SocketWriteEvent.class,\n+        jdk.internal.event.ThreadSleepEvent.class,\n+        jdk.internal.event.TLSHandshakeEvent.class,\n+        jdk.internal.event.VirtualThreadStartEvent.class,\n+        jdk.internal.event.VirtualThreadEndEvent.class,\n+        jdk.internal.event.VirtualThreadPinnedEvent.class,\n+        jdk.internal.event.VirtualThreadSubmitFailedEvent.class,\n+        jdk.internal.event.X509CertificateEvent.class,\n+        jdk.internal.event.X509ValidationEvent.class,\n+        DirectBufferStatisticsEvent.class,\n+        InitialSecurityPropertyEvent.class,\n+    };\n+\n+    private static final Runnable emitExceptionStatistics = JDKEvents::emitExceptionStatistics;\n+    private static final Runnable emitDirectBufferStatistics = JDKEvents::emitDirectBufferStatistics;\n+    private static final Runnable emitContainerConfiguration = JDKEvents::emitContainerConfiguration;\n+    private static final Runnable emitContainerCPUUsage = JDKEvents::emitContainerCPUUsage;\n+    private static final Runnable emitContainerCPUThrottling = JDKEvents::emitContainerCPUThrottling;\n+    private static final Runnable emitContainerMemoryUsage = JDKEvents::emitContainerMemoryUsage;\n+    private static final Runnable emitContainerIOUsage = JDKEvents::emitContainerIOUsage;\n+    private static final Runnable emitInitialSecurityProperties = JDKEvents::emitInitialSecurityProperties;\n+    private static Metrics containerMetrics = null;\n+    private static boolean initializationTriggered;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static synchronized void initialize() {\n+        try {\n+            if (initializationTriggered == false) {\n+                for (Class<?> eventClass : eventClasses) {\n+                    SecuritySupport.registerEvent((Class<? extends Event>) eventClass);\n+                }\n+                PeriodicEvents.addJDKEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);\n+                PeriodicEvents.addJDKEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n+                PeriodicEvents.addJDKEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n+\n+                initializeContainerEvents();\n+                JFRTracing.enable();\n+                initializationTriggered = true;\n+            }\n+        } catch (Exception e) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Could not initialize JDK events. \" + e.getMessage());\n+        }\n+    }\n+\n+    private static void initializeContainerEvents() {\n+        if (JVM.isContainerized() ) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"JVM is containerized\");\n+            containerMetrics = Container.metrics();\n+            if (containerMetrics != null) {\n+                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Container metrics are available\");\n+            }\n+        }\n+        \/\/ The registration of events and hooks are needed to provide metadata,\n+        \/\/ even when not running in a container\n+        SecuritySupport.registerEvent(ContainerConfigurationEvent.class);\n+        SecuritySupport.registerEvent(ContainerCPUUsageEvent.class);\n+        SecuritySupport.registerEvent(ContainerCPUThrottlingEvent.class);\n+        SecuritySupport.registerEvent(ContainerMemoryUsageEvent.class);\n+        SecuritySupport.registerEvent(ContainerIOUsageEvent.class);\n+\n+        PeriodicEvents.addJDKEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);\n+        PeriodicEvents.addJDKEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n+        PeriodicEvents.addJDKEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n+        PeriodicEvents.addJDKEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n+        PeriodicEvents.addJDKEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);\n+    }\n+\n+    private static void emitExceptionStatistics() {\n+        ThrowableTracer.emitStatistics();\n+    }\n+\n+    private static void emitContainerConfiguration() {\n+        if (containerMetrics != null) {\n+            ContainerConfigurationEvent t = new ContainerConfigurationEvent();\n+            t.containerType = containerMetrics.getProvider();\n+            t.cpuSlicePeriod = containerMetrics.getCpuPeriod();\n+            t.cpuQuota = containerMetrics.getCpuQuota();\n+            t.cpuShares = containerMetrics.getCpuShares();\n+            t.effectiveCpuCount = containerMetrics.getEffectiveCpuCount();\n+            t.memorySoftLimit = containerMetrics.getMemorySoftLimit();\n+            t.memoryLimit = containerMetrics.getMemoryLimit();\n+            t.swapMemoryLimit = containerMetrics.getMemoryAndSwapLimit();\n+            t.hostTotalMemory = JVM.hostTotalMemory();\n+            t.hostTotalSwapMemory = JVM.hostTotalSwapMemory();\n+            t.commit();\n+        }\n+    }\n+\n+    private static void emitContainerCPUUsage() {\n+        if (containerMetrics != null) {\n+            ContainerCPUUsageEvent event = new ContainerCPUUsageEvent();\n+\n+            event.cpuTime = containerMetrics.getCpuUsage();\n+            event.cpuSystemTime = containerMetrics.getCpuSystemUsage();\n+            event.cpuUserTime = containerMetrics.getCpuUserUsage();\n+            event.commit();\n+        }\n+    }\n+    private static void emitContainerMemoryUsage() {\n+        if (containerMetrics != null) {\n+            ContainerMemoryUsageEvent event = new ContainerMemoryUsageEvent();\n+\n+            event.memoryFailCount = containerMetrics.getMemoryFailCount();\n+            event.memoryUsage = containerMetrics.getMemoryUsage();\n+            event.swapMemoryUsage = containerMetrics.getMemoryAndSwapUsage();\n+            event.commit();\n+        }\n+    }\n+\n+    private static void emitContainerIOUsage() {\n+        if (containerMetrics != null) {\n+            ContainerIOUsageEvent event = new ContainerIOUsageEvent();\n+\n+            event.serviceRequests = containerMetrics.getBlkIOServiceCount();\n+            event.dataTransferred = containerMetrics.getBlkIOServiced();\n+            event.commit();\n+        }\n+    }\n+\n+    private static void emitContainerCPUThrottling() {\n+        if (containerMetrics != null) {\n+            ContainerCPUThrottlingEvent event = new ContainerCPUThrottlingEvent();\n+\n+            event.cpuElapsedSlices = containerMetrics.getCpuNumPeriods();\n+            event.cpuThrottledSlices = containerMetrics.getCpuNumThrottled();\n+            event.cpuThrottledTime = containerMetrics.getCpuThrottledTime();\n+            event.commit();\n+        }\n+    }\n+\n+    public static void remove() {\n+        PeriodicEvents.removeEvent(emitExceptionStatistics);\n+        PeriodicEvents.removeEvent(emitDirectBufferStatistics);\n+        PeriodicEvents.removeEvent(emitInitialSecurityProperties);\n+\n+        PeriodicEvents.removeEvent(emitContainerConfiguration);\n+        PeriodicEvents.removeEvent(emitContainerCPUUsage);\n+        PeriodicEvents.removeEvent(emitContainerCPUThrottling);\n+        PeriodicEvents.removeEvent(emitContainerMemoryUsage);\n+        PeriodicEvents.removeEvent(emitContainerIOUsage);\n+    }\n+\n+    private static void emitDirectBufferStatistics() {\n+        DirectBufferStatisticsEvent e = new DirectBufferStatisticsEvent();\n+        e.commit();\n+    }\n+\n+    private static void emitInitialSecurityProperties() {\n+        Properties p = SharedSecrets.getJavaSecurityPropertiesAccess().getInitialProperties();\n+        if (p != null) {\n+            for (String key : p.stringPropertyNames()) {\n+                InitialSecurityPropertyEvent e = new InitialSecurityPropertyEvent();\n+                e.key = key;\n+                e.value = p.getProperty(key);\n+                e.commit();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JDKEvents.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.jfr.internal.instrument.JDKEvents;\n@@ -81,1 +80,1 @@\n-            return JDKEvents.retransformCallback(clazz, oldBytes);\n+            return oldBytes;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-import jdk.jfr.internal.instrument.JDKEvents;\n@@ -86,1 +85,0 @@\n-        JDKEvents.addInstrumentation();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,270 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Properties;\n-\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.event.JFRTracing;\n-import jdk.internal.event.ThrowableTracer;\n-import jdk.jfr.Event;\n-import jdk.jfr.events.ActiveRecordingEvent;\n-import jdk.jfr.events.ActiveSettingEvent;\n-import jdk.jfr.events.ContainerIOUsageEvent;\n-import jdk.jfr.events.ContainerConfigurationEvent;\n-import jdk.jfr.events.ContainerCPUUsageEvent;\n-import jdk.jfr.events.ContainerCPUThrottlingEvent;\n-import jdk.jfr.events.ContainerMemoryUsageEvent;\n-import jdk.jfr.events.DirectBufferStatisticsEvent;\n-import jdk.jfr.events.FileForceEvent;\n-import jdk.jfr.events.InitialSecurityPropertyEvent;\n-\n-import jdk.jfr.internal.JVM;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-import jdk.jfr.internal.SecuritySupport;\n-import jdk.jfr.internal.periodic.PeriodicEvents;\n-import jdk.internal.platform.Container;\n-import jdk.internal.platform.Metrics;\n-\n-public final class JDKEvents {\n-\n-    private static final Class<?>[] eventClasses = {\n-        ActiveSettingEvent.class,\n-        ActiveRecordingEvent.class,\n-        \/\/ jdk.internal.event.* classes need their mirror\n-        \/\/ event class to be listed in the MirrorEvents class.\n-        jdk.internal.event.DeserializationEvent.class,\n-        jdk.internal.event.ErrorThrownEvent.class,\n-        jdk.internal.event.ExceptionStatisticsEvent.class,\n-        jdk.internal.event.ExceptionThrownEvent.class,\n-        jdk.internal.event.FileForceEvent.class,\n-        jdk.internal.event.FileReadEvent.class,\n-        jdk.internal.event.FileWriteEvent.class,\n-        jdk.internal.event.ProcessStartEvent.class,\n-        jdk.internal.event.SecurityPropertyModificationEvent.class,\n-        jdk.internal.event.SecurityProviderServiceEvent.class,\n-        jdk.internal.event.SerializationMisdeclarationEvent.class,\n-        jdk.internal.event.SocketReadEvent.class,\n-        jdk.internal.event.SocketWriteEvent.class,\n-        jdk.internal.event.ThreadSleepEvent.class,\n-        jdk.internal.event.TLSHandshakeEvent.class,\n-        jdk.internal.event.VirtualThreadStartEvent.class,\n-        jdk.internal.event.VirtualThreadEndEvent.class,\n-        jdk.internal.event.VirtualThreadPinnedEvent.class,\n-        jdk.internal.event.VirtualThreadSubmitFailedEvent.class,\n-        jdk.internal.event.X509CertificateEvent.class,\n-        jdk.internal.event.X509ValidationEvent.class,\n-        DirectBufferStatisticsEvent.class,\n-        InitialSecurityPropertyEvent.class,\n-    };\n-\n-    \/\/ This is a list of the classes with instrumentation code that should be applied.\n-    private static final Class<?>[] instrumentationClasses = new Class<?>[] {\n-    };\n-\n-    private static final Class<?>[] targetClasses = new Class<?>[instrumentationClasses.length];\n-    private static final Runnable emitExceptionStatistics = JDKEvents::emitExceptionStatistics;\n-    private static final Runnable emitDirectBufferStatistics = JDKEvents::emitDirectBufferStatistics;\n-    private static final Runnable emitContainerConfiguration = JDKEvents::emitContainerConfiguration;\n-    private static final Runnable emitContainerCPUUsage = JDKEvents::emitContainerCPUUsage;\n-    private static final Runnable emitContainerCPUThrottling = JDKEvents::emitContainerCPUThrottling;\n-    private static final Runnable emitContainerMemoryUsage = JDKEvents::emitContainerMemoryUsage;\n-    private static final Runnable emitContainerIOUsage = JDKEvents::emitContainerIOUsage;\n-    private static final Runnable emitInitialSecurityProperties = JDKEvents::emitInitialSecurityProperties;\n-    private static Metrics containerMetrics = null;\n-    private static boolean initializationTriggered;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static synchronized void initialize() {\n-        try {\n-            if (initializationTriggered == false) {\n-                for (Class<?> eventClass : eventClasses) {\n-                    SecuritySupport.registerEvent((Class<? extends Event>) eventClass);\n-                }\n-                PeriodicEvents.addJDKEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);\n-                PeriodicEvents.addJDKEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n-                PeriodicEvents.addJDKEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n-\n-                initializeContainerEvents();\n-                JFRTracing.enable();\n-                initializationTriggered = true;\n-            }\n-        } catch (Exception e) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Could not initialize JDK events. \" + e.getMessage());\n-        }\n-    }\n-\n-    public static void addInstrumentation() {\n-        try {\n-            List<Class<?>> list = new ArrayList<>();\n-            for (int i = 0; i < instrumentationClasses.length; i++) {\n-                JIInstrumentationTarget tgt = instrumentationClasses[i].getAnnotation(JIInstrumentationTarget.class);\n-                Class<?> clazz = Class.forName(tgt.value());\n-                targetClasses[i] = clazz;\n-                list.add(clazz);\n-            }\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"Retransformed JDK classes\");\n-            JVM.retransformClasses(list.toArray(new Class<?>[list.size()]));\n-        } catch (IllegalStateException ise) {\n-            throw ise;\n-        } catch (Exception e) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Could not add instrumentation for JDK events. \" + e.getMessage());\n-        }\n-    }\n-\n-    private static void initializeContainerEvents() {\n-        if (JVM.isContainerized() ) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"JVM is containerized\");\n-            containerMetrics = Container.metrics();\n-            if (containerMetrics != null) {\n-                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Container metrics are available\");\n-            }\n-        }\n-        \/\/ The registration of events and hooks are needed to provide metadata,\n-        \/\/ even when not running in a container\n-        SecuritySupport.registerEvent(ContainerConfigurationEvent.class);\n-        SecuritySupport.registerEvent(ContainerCPUUsageEvent.class);\n-        SecuritySupport.registerEvent(ContainerCPUThrottlingEvent.class);\n-        SecuritySupport.registerEvent(ContainerMemoryUsageEvent.class);\n-        SecuritySupport.registerEvent(ContainerIOUsageEvent.class);\n-\n-        PeriodicEvents.addJDKEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);\n-        PeriodicEvents.addJDKEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n-        PeriodicEvents.addJDKEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n-        PeriodicEvents.addJDKEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n-        PeriodicEvents.addJDKEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);\n-    }\n-\n-    private static void emitExceptionStatistics() {\n-        ThrowableTracer.emitStatistics();\n-    }\n-\n-    private static void emitContainerConfiguration() {\n-        if (containerMetrics != null) {\n-            ContainerConfigurationEvent t = new ContainerConfigurationEvent();\n-            t.containerType = containerMetrics.getProvider();\n-            t.cpuSlicePeriod = containerMetrics.getCpuPeriod();\n-            t.cpuQuota = containerMetrics.getCpuQuota();\n-            t.cpuShares = containerMetrics.getCpuShares();\n-            t.effectiveCpuCount = containerMetrics.getEffectiveCpuCount();\n-            t.memorySoftLimit = containerMetrics.getMemorySoftLimit();\n-            t.memoryLimit = containerMetrics.getMemoryLimit();\n-            t.swapMemoryLimit = containerMetrics.getMemoryAndSwapLimit();\n-            t.hostTotalMemory = JVM.hostTotalMemory();\n-            t.hostTotalSwapMemory = JVM.hostTotalSwapMemory();\n-            t.commit();\n-        }\n-    }\n-\n-    private static void emitContainerCPUUsage() {\n-        if (containerMetrics != null) {\n-            ContainerCPUUsageEvent event = new ContainerCPUUsageEvent();\n-\n-            event.cpuTime = containerMetrics.getCpuUsage();\n-            event.cpuSystemTime = containerMetrics.getCpuSystemUsage();\n-            event.cpuUserTime = containerMetrics.getCpuUserUsage();\n-            event.commit();\n-        }\n-    }\n-    private static void emitContainerMemoryUsage() {\n-        if (containerMetrics != null) {\n-            ContainerMemoryUsageEvent event = new ContainerMemoryUsageEvent();\n-\n-            event.memoryFailCount = containerMetrics.getMemoryFailCount();\n-            event.memoryUsage = containerMetrics.getMemoryUsage();\n-            event.swapMemoryUsage = containerMetrics.getMemoryAndSwapUsage();\n-            event.commit();\n-        }\n-    }\n-\n-    private static void emitContainerIOUsage() {\n-        if (containerMetrics != null) {\n-            ContainerIOUsageEvent event = new ContainerIOUsageEvent();\n-\n-            event.serviceRequests = containerMetrics.getBlkIOServiceCount();\n-            event.dataTransferred = containerMetrics.getBlkIOServiced();\n-            event.commit();\n-        }\n-    }\n-\n-    private static void emitContainerCPUThrottling() {\n-        if (containerMetrics != null) {\n-            ContainerCPUThrottlingEvent event = new ContainerCPUThrottlingEvent();\n-\n-            event.cpuElapsedSlices = containerMetrics.getCpuNumPeriods();\n-            event.cpuThrottledSlices = containerMetrics.getCpuNumThrottled();\n-            event.cpuThrottledTime = containerMetrics.getCpuThrottledTime();\n-            event.commit();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static byte[] retransformCallback(Class<?> klass, byte[] oldBytes) throws Throwable {\n-        for (int i = 0; i < targetClasses.length; i++) {\n-            if (targetClasses[i].equals(klass)) {\n-                Class<?> c = instrumentationClasses[i];\n-                if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.TRACE)) {\n-                    Logger.log(LogTag.JFR_SYSTEM, LogLevel.TRACE, \"Processing instrumentation class: \" + c);\n-                }\n-                return new JIClassInstrumentation(instrumentationClasses[i], klass, oldBytes).getNewBytes();\n-            }\n-        }\n-        return oldBytes;\n-    }\n-\n-    public static void remove() {\n-        PeriodicEvents.removeEvent(emitExceptionStatistics);\n-        PeriodicEvents.removeEvent(emitDirectBufferStatistics);\n-        PeriodicEvents.removeEvent(emitInitialSecurityProperties);\n-\n-        PeriodicEvents.removeEvent(emitContainerConfiguration);\n-        PeriodicEvents.removeEvent(emitContainerCPUUsage);\n-        PeriodicEvents.removeEvent(emitContainerCPUThrottling);\n-        PeriodicEvents.removeEvent(emitContainerMemoryUsage);\n-        PeriodicEvents.removeEvent(emitContainerIOUsage);\n-    }\n-\n-    private static void emitDirectBufferStatistics() {\n-        DirectBufferStatisticsEvent e = new DirectBufferStatisticsEvent();\n-        e.commit();\n-    }\n-\n-    private static void emitInitialSecurityProperties() {\n-        Properties p = SharedSecrets.getJavaSecurityPropertiesAccess().getInitialProperties();\n-        if (p != null) {\n-            for (String key : p.stringPropertyNames()) {\n-                InitialSecurityPropertyEvent e = new InitialSecurityPropertyEvent();\n-                e.key = key;\n-                e.value = p.getProperty(key);\n-                e.commit();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":0,"deletions":270,"binary":false,"changes":270,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.jfr.internal.SecuritySupport;\n-\n-\/**\n- * This class will perform byte code instrumentation given an \"instrumentor\" class.\n- *\n- * @see JITracer\n- *\n- * @author Staffan Larsen\n- *\/\n-@Deprecated\n-final class JIClassInstrumentation {\n-    private final Class<?> instrumentor;\n-    private final String targetName;\n-    private final String instrumentorName;\n-    private final byte[] newBytes;\n-    private final ClassReader targetClassReader;\n-    private final ClassReader instrClassReader;\n-\n-    \/**\n-     * Creates an instance and performs the instrumentation.\n-     *\n-     * @param instrumentor instrumentor class\n-     * @param target target class\n-     * @param old_target_bytes bytes in target\n-     *\n-     * @throws ClassNotFoundException\n-     * @throws IOException\n-     *\/\n-    JIClassInstrumentation(Class<?> instrumentor, Class<?> target, byte[] old_target_bytes) throws ClassNotFoundException, IOException {\n-        instrumentorName = instrumentor.getName();\n-        this.targetName = target.getName();\n-        this.instrumentor = instrumentor;\n-        this.targetClassReader = new ClassReader(old_target_bytes);\n-        this.instrClassReader = new ClassReader(getOriginalClassBytes(instrumentor));\n-        this.newBytes = makeBytecode();\n-    }\n-\n-    private static byte[] getOriginalClassBytes(Class<?> clazz) throws IOException {\n-        String name = \"\/\" + clazz.getName().replace(\".\", \"\/\") + \".class\";\n-        try (InputStream is = SecuritySupport.getResourceAsStream(name)) {\n-            return is.readAllBytes();\n-        }\n-    }\n-\n-    private byte[] makeBytecode() throws IOException, ClassNotFoundException {\n-\n-        \/\/ Find the methods to instrument and inline\n-\n-        final List<Method> instrumentationMethods = new ArrayList<>();\n-        for (final Method m : instrumentor.getDeclaredMethods()) {\n-            JIInstrumentationMethod im = m.getAnnotation(JIInstrumentationMethod.class);\n-            if (im != null) {\n-                instrumentationMethods.add(m);\n-            }\n-        }\n-\n-        \/\/ We begin by inlining the target's methods into the instrumentor\n-\n-        ClassNode temporary = new ClassNode();\n-        ClassVisitor inliner = new JIInliner(\n-                Opcodes.ASM7,\n-                temporary,\n-                targetName,\n-                instrumentorName,\n-                targetClassReader,\n-                instrumentationMethods);\n-        instrClassReader.accept(inliner, ClassReader.EXPAND_FRAMES);\n-\n-        \/\/ Now we have the target's methods inlined into the instrumentation code (in 'temporary').\n-        \/\/ We now need to replace the target's method with the code in the\n-        \/\/ instrumentation method.\n-\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        JIMethodMergeAdapter ma = new JIMethodMergeAdapter(\n-                cw,\n-                temporary,\n-                instrumentationMethods,\n-                instrumentor.getAnnotationsByType(JITypeMapping.class));\n-        targetClassReader.accept(ma, ClassReader.EXPAND_FRAMES);\n-\n-       return cw.toByteArray();\n-    }\n-\n-    \/**\n-     * Get the instrumented byte codes that can be used to retransform the class.\n-     *\n-     * @return bytes\n-     *\/\n-    public byte[] getNewBytes() {\n-        return newBytes.clone();\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIClassInstrumentation.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.List;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-\n-@Deprecated\n-final class JIInliner extends ClassVisitor {\n-    private final String targetClassName;\n-    private final String instrumentationClassName;\n-    private final ClassNode targetClassNode;\n-    private final List<Method> instrumentationMethods;\n-\n-    \/**\n-     * A ClassVisitor which will check all methods of the class it visits against the instrumentationMethods\n-     * list. If a method is on that list, the method will be further processed for inlining into that\n-     * method.\n-     *\/\n-    JIInliner(int api, ClassVisitor cv, String targetClassName, String instrumentationClassName,\n-            ClassReader targetClassReader,\n-            List<Method> instrumentationMethods) {\n-        super(api, cv);\n-        this.targetClassName = targetClassName;\n-        this.instrumentationClassName = instrumentationClassName;\n-        this.instrumentationMethods = instrumentationMethods;\n-\n-        ClassNode cn = new ClassNode(Opcodes.ASM7);\n-        targetClassReader.accept(cn, ClassReader.EXPAND_FRAMES);\n-        this.targetClassNode = cn;\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-\n-        if (isInstrumentationMethod(name, desc)) {\n-            MethodNode methodToInline = findTargetMethodNode(name, desc);\n-            if (methodToInline == null) {\n-                throw new IllegalArgumentException(\"Could not find the method to instrument in the target class\");\n-            }\n-            if (Modifier.isNative(methodToInline.access)) {\n-                throw new IllegalArgumentException(\"Cannot instrument native methods: \" + targetClassNode.name + \".\" + methodToInline.name + methodToInline.desc);\n-            }\n-\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Inliner processing method \" + name + desc);\n-\n-            JIMethodCallInliner mci = new JIMethodCallInliner(access,\n-                    desc,\n-                    mv,\n-                    methodToInline,\n-                    targetClassName,\n-                    instrumentationClassName);\n-            return mci;\n-        }\n-\n-        return mv;\n-    }\n-\n-    private boolean isInstrumentationMethod(String name, String desc) {\n-        for(Method m : instrumentationMethods) {\n-            if (m.getName().equals(name) && Type.getMethodDescriptor(m).equals(desc)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private MethodNode findTargetMethodNode(String name, String desc) {\n-        for (MethodNode mn : targetClassNode.methods) {\n-            if (mn.desc.equals(desc) && mn.name.equals(name)) {\n-                return mn;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"could not find MethodNode for \"\n-                + name + desc);\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIInliner.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Target(ElementType.METHOD)\n-@Retention(RetentionPolicy.RUNTIME)\n-@interface JIInstrumentationMethod {\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIInstrumentationMethod.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Target(ElementType.TYPE)\n-@Retention(RetentionPolicy.RUNTIME)\n-@interface JIInstrumentationTarget {\n-    String value();\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIInstrumentationTarget.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.LocalVariablesSorter;\n-import jdk.internal.org.objectweb.asm.commons.Remapper;\n-import jdk.internal.org.objectweb.asm.commons.SimpleRemapper;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-\n-\/**\n- * Class responsible for finding the call to inline and inlining it.\n- *\n- * This code is heavily influenced by section 3.2.6 \"Inline Method\" in\n- * \"Using ASM framework to implement common bytecode transformation patterns\",\n- * E. Kuleshov, AOSD.07, March 2007, Vancouver, Canada.\n- * http:\/\/asm.ow2.org\/index.html\n- *\/\n-@Deprecated\n-final class JIMethodCallInliner extends LocalVariablesSorter {\n-\n-    private final String oldClass;\n-    private final String newClass;\n-    private final MethodNode inlineTarget;\n-    private final List<CatchBlock> blocks = new ArrayList<>();\n-    private boolean inlining;\n-\n-    \/**\n-     * inlineTarget defines the method to inline and also contains the actual\n-     * code to inline.\n-     *\n-     * @param access\n-     * @param desc\n-     * @param mv\n-     * @param inlineTarget\n-     * @param oldClass\n-     * @param newClass\n-     * @param logger\n-     *\/\n-    public JIMethodCallInliner(int access, String desc, MethodVisitor mv,\n-            MethodNode inlineTarget, String oldClass, String newClass) {\n-        super(Opcodes.ASM7, access, desc, mv);\n-        this.oldClass = oldClass;\n-        this.newClass = newClass;\n-        this.inlineTarget = inlineTarget;\n-\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG,\n-                \"MethodCallInliner: targetMethod=\" + newClass + \".\"\n-                + inlineTarget.name + inlineTarget.desc);\n-        }\n-    }\n-\n-    @Override\n-    public void visitMethodInsn(int opcode, String owner, String name,\n-            String desc, boolean itf) {\n-        \/\/ Now we are looking at method call in the source method\n-        if (!shouldBeInlined(owner, name, desc)) {\n-            \/\/ If this method call should not be inlined, just keep it\n-            mv.visitMethodInsn(opcode, owner, name, desc, itf);\n-            return;\n-        }\n-        \/\/ If the call should be inlined, we create a MethodInliningAdapter\n-        \/\/ The MIA will walk the instructions in the inlineTarget and add them\n-        \/\/ to the current method, doing the necessary name remappings.\n-        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Inlining call to \" + name + desc);\n-        Remapper remapper = new SimpleRemapper(oldClass, newClass);\n-        Label end = new Label();\n-        inlining = true;\n-        inlineTarget.instructions.resetLabels();\n-        JIMethodInliningAdapter mia = new JIMethodInliningAdapter(this, end,\n-                opcode == Opcodes.INVOKESTATIC ? Opcodes.ACC_STATIC : 0, desc,\n-                remapper);\n-        inlineTarget.accept(mia);\n-        inlining = false;\n-        super.visitLabel(end);\n-    }\n-\n-    \/**\n-     * Determine if the method should be inlined or not.\n-     *\/\n-    private boolean shouldBeInlined(String owner, String name, String desc) {\n-        return inlineTarget.desc.equals(desc) && inlineTarget.name.equals(name)\n-                && owner.equals(newClass.replace('.', '\/'));\n-    }\n-\n-    @Override\n-    public void visitTryCatchBlock(Label start, Label end, Label handler,\n-            String type) {\n-        if (!inlining) {\n-            \/\/ try-catch blocks are saved here and replayed at the end\n-            \/\/ of the method (in visitMaxs)\n-            blocks.add(new CatchBlock(start, end, handler, type));\n-        } else {\n-            super.visitTryCatchBlock(start, end, handler, type);\n-        }\n-    }\n-\n-    @Override\n-    public void visitMaxs(int stack, int locals) {\n-        for (CatchBlock b : blocks) {\n-            super.visitTryCatchBlock(b.start, b.end, b.handler, b.type);\n-        }\n-        super.visitMaxs(stack, locals);\n-    }\n-\n-    static final class CatchBlock {\n-\n-        final Label start;\n-        final Label end;\n-        final Label handler;\n-        final String type;\n-\n-        CatchBlock(Label start, Label end, Label handler, String type) {\n-            this.start = start;\n-            this.end = end;\n-            this.handler = handler;\n-            this.type = type;\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIMethodCallInliner.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.LocalVariablesSorter;\n-import jdk.internal.org.objectweb.asm.commons.Remapper;\n-import jdk.internal.org.objectweb.asm.commons.RemappingMethodAdapter;\n-\n-@Deprecated\n-final class JIMethodInliningAdapter extends RemappingMethodAdapter {\n-    private final LocalVariablesSorter lvs;\n-    private final Label end;\n-\n-    public JIMethodInliningAdapter(LocalVariablesSorter mv, Label end, int acc, String desc, Remapper remapper) {\n-        super(acc, desc, mv, remapper);\n-        this.lvs = mv;\n-        this.end = end;\n-        int offset = isStatic(acc) ? 0 : 1;\n-        Type[] args = Type.getArgumentTypes(desc);\n-        for (int i = args.length - 1; i >= 0; i--) {\n-            super.visitVarInsn(args[i].getOpcode(Opcodes.ISTORE), i + offset);\n-        }\n-        if (offset > 0) {\n-            super.visitVarInsn(Opcodes.ASTORE, 0);\n-        }\n-    }\n-\n-    private boolean isStatic(int acc) {\n-        return (acc & Opcodes.ACC_STATIC) != 0;\n-    }\n-\n-    @Override\n-    public void visitInsn(int opcode) {\n-        if (opcode == Opcodes.RETURN || opcode == Opcodes.IRETURN\n-                || opcode == Opcodes.ARETURN || opcode == Opcodes.LRETURN) {\n-            super.visitJumpInsn(Opcodes.GOTO, end);\n-        } else {\n-            super.visitInsn(opcode);\n-        }\n-    }\n-\n-    @Override\n-    public void visitMaxs(int stack, int locals) {\n-    }\n-\n-    @Override\n-    protected int newLocalMapping(Type type) {\n-        return lvs.newLocal(type);\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIMethodInliningAdapter.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.RemappingMethodAdapter;\n-import jdk.internal.org.objectweb.asm.commons.SimpleRemapper;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-\n-\/**\n- * This class will merge (some) methods from one class into another one.\n- *\n- * @author Staffan Larsen\n- *\/\n-@Deprecated\n-final class JIMethodMergeAdapter extends ClassVisitor {\n-\n-    private final ClassNode cn;\n-    private final List<Method> methodFilter;\n-    private final Map<String, String> typeMap;\n-\n-    \/**\n-     * Methods in methodFilter that exist in cn will be merged into cv. If the method already exists,\n-     * the original method will be deleted.\n-     *\n-     * @param cv\n-     * @param cn - a ClassNode with Methods that will be merged into this class\n-     * @param methodFilter - only methods in this list will be merged\n-     * @param typeMappings - while merging, type references in the methods will be changed according to this map\n-     *\/\n-    public JIMethodMergeAdapter(ClassVisitor cv, ClassNode cn, List<Method> methodFilter, JITypeMapping[] typeMappings) {\n-        super(Opcodes.ASM7, cv);\n-        this.cn = cn;\n-        this.methodFilter = methodFilter;\n-\n-        this.typeMap = new HashMap<>();\n-        for (JITypeMapping tm : typeMappings) {\n-            typeMap.put(tm.from().replace('.', '\/'), tm.to().replace('.', '\/'));\n-        }\n-    }\n-\n-    @Override\n-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        super.visit(version, access, name, signature, superName, interfaces);\n-        typeMap.put(cn.name, name);\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if(methodInFilter(name, desc)) {\n-            \/\/ If the method is one that we will be replacing, delete the method\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Deleting \" + name + desc);\n-            return null;\n-        }\n-        return super.visitMethod(access, name, desc, signature, exceptions);\n-    }\n-\n-    @Override\n-    public void visitEnd() {\n-        SimpleRemapper remapper = new SimpleRemapper(typeMap);\n-        for (MethodNode mn : cn.methods) {\n-            \/\/ Check if the method is in the list of methods to copy\n-            if (methodInFilter(mn.name, mn.desc)) {\n-                if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG)) {\n-                    Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Copying method: \" + mn.name + mn.desc);\n-                    Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"   with mapper: \" + typeMap);\n-                }\n-\n-                String[] exceptions = new String[mn.exceptions.size()];\n-                mn.exceptions.toArray(exceptions);\n-                MethodVisitor mv = cv.visitMethod(mn.access, mn.name, mn.desc, mn.signature, exceptions);\n-                mn.instructions.resetLabels();\n-                mn.accept(new RemappingMethodAdapter(mn.access, mn.desc, mv, remapper));\n-            }\n-        }\n-        super.visitEnd();\n-    }\n-\n-    private boolean methodInFilter(String name, String desc) {\n-        for(Method m : methodFilter) {\n-            if (m.getName().equals(name) && Type.getMethodDescriptor(m).equals(desc)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIMethodMergeAdapter.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@interface JITypeMapping {\n-    String from();\n-    String to();\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JITypeMapping.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.jfr.internal.JDKEvents;\n@@ -60,1 +61,0 @@\n-import jdk.jfr.internal.instrument.JDKEvents;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"filename":"webrev.zip","binary":true,"status":"added"}]}