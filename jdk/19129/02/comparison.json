{"files":[{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.event.FileReadEvent;\n@@ -62,0 +63,3 @@\n+    \/\/ Flag that determines if file reads should be traced by JFR\n+    static boolean jfrTracing;\n+\n@@ -225,0 +229,3 @@\n+        if (jfrTracing) {\n+            return traceRead0();\n+        }\n@@ -230,0 +237,25 @@\n+    private int traceRead0() throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return read0();\n+        }\n+        int result = 0;\n+        boolean endOfFile = false;\n+        long bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            result = read0();\n+            if (result < 0) {\n+                endOfFile = true;\n+            } else {\n+                bytesRead = 1;\n+            }\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -239,0 +271,22 @@\n+    private int traceReadBytes(byte b[], int off, int len) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return readBytes(b, off, len);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = readBytes(b, off, len);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -252,0 +306,3 @@\n+        if (jfrTracing) {\n+            return traceReadBytes(b, 0, b.length);\n+        }\n@@ -271,0 +328,3 @@\n+        if (jfrTracing) {\n+            return traceReadBytes(b, off, len);\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileInputStream.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+import jdk.internal.event.FileWriteEvent;\n@@ -71,0 +72,3 @@\n+    \/\/ Flag that determines if file writes should be traced by JFR\n+    static boolean jfrTracing;\n+\n@@ -300,0 +304,19 @@\n+    private void traceWrite(int b, boolean append) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            write(b, append);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            write(b, append);\n+            bytesWritten = 1;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n@@ -310,0 +333,4 @@\n+        if (jfrTracing) {\n+            traceWrite(b, append);\n+            return;\n+        }\n@@ -325,0 +352,19 @@\n+    private void traceWriteBytes(byte b[], int off, int len, boolean append) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            writeBytes(b, off, len, append);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            writeBytes(b, off, len, append);\n+            bytesWritten = len;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n@@ -335,0 +381,4 @@\n+        if (jfrTracing) {\n+            traceWriteBytes(b, 0, b.length, append);\n+            return;\n+        }\n@@ -351,0 +401,4 @@\n+        if (jfrTracing) {\n+            traceWriteBytes(b, off, len, append);\n+            return;\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/io\/FileOutputStream.java","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import jdk.internal.event.FileReadEvent;\n+import jdk.internal.event.FileWriteEvent;\n@@ -71,0 +73,3 @@\n+    \/\/ Flag that determines if file reads\/writes should be traced by JFR\n+    private static boolean jfrTracing;\n+\n@@ -379,0 +384,3 @@\n+        if (jfrTracing) {\n+            return traceRead0();\n+        }\n@@ -384,0 +392,25 @@\n+    private int traceRead0() throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return read0();\n+        }\n+        int result = 0;\n+        long bytesRead = 0;\n+        boolean endOfFile = false;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            result = read0();\n+            if (result < 0) {\n+                endOfFile = true;\n+            } else {\n+                bytesRead = 1;\n+            }\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n+            }\n+        }\n+        return result;\n+    }\n+\n@@ -392,0 +425,3 @@\n+        if (jfrTracing) {\n+            return traceReadBytes0(b, off, len);\n+        }\n@@ -397,0 +433,22 @@\n+    private int traceReadBytes0(byte b[], int off, int len) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return readBytes0(b, off, len);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = readBytes0(b, off, len);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -540,0 +598,8 @@\n+        if (jfrTracing) {\n+            traceImplWrite(b);\n+            return;\n+        }\n+        implWrite(b);\n+    }\n+\n+    private void implWrite(int b) throws IOException {\n@@ -548,0 +614,19 @@\n+    private void traceImplWrite(int b) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            implWrite(b);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            implWrite(b);\n+            bytesWritten = 1;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n@@ -559,0 +644,8 @@\n+        if (jfrTracing) {\n+            traceImplWriteBytes(b, off, len);\n+            return;\n+        }\n+        implWriteBytes(b, off, len);\n+    }\n+\n+    private void implWriteBytes(byte[] b, int off, int len) throws IOException {\n@@ -567,0 +660,19 @@\n+    private void traceImplWriteBytes(byte b[], int off, int len) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            implWriteBytes(b, off, len);\n+            return;\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            implWriteBytes(b, off, len);\n+            bytesWritten = len;\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                FileWriteEvent.commit(start, duration, path, bytesWritten);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/io\/RandomAccessFile.java","additions":112,"deletions":0,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -0,0 +1,56 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.event;\n+\n+\/**\n+ * Event recording file reads.\n+ *\/\n+public final class FileReadEvent extends Event {\n+\n+    \/\/ The order of these fields must be the same as the parameters in\n+    \/\/ commit(..., String, long, boolean)\n+    public String path;\n+    public long bytesRead;\n+    public boolean endOfFile;\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0L;\n+    }\n+\n+    public static boolean shouldCommit(long duration) {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static void commit(long start, long duration, String path, long bytesRead, boolean endOfFile) {\n+        \/\/ Generated by JFR\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/FileReadEvent.java","additions":56,"deletions":0,"binary":false,"changes":56,"status":"added"},{"patch":"@@ -0,0 +1,55 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.event;\n+\n+\/**\n+ * Event recording file writes.\n+ *\/\n+public final class FileWriteEvent extends Event {\n+\n+    \/\/ The order of these fields must be the same as the parameters in\n+    \/\/ commit(..., String, long)\n+    public String path;\n+    public long bytesWritten;\n+\n+    public static boolean enabled() {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static long timestamp() {\n+        \/\/ Generated by JFR\n+        return 0L;\n+    }\n+\n+    public static boolean shouldCommit(long duration) {\n+        \/\/ Generated by JFR\n+        return false;\n+    }\n+\n+    public static void commit(long start, long duration, String path, long bytesWritten) {\n+        \/\/ Generated by JFR\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/FileWriteEvent.java","additions":55,"deletions":0,"binary":false,"changes":55,"status":"added"},{"patch":"@@ -0,0 +1,52 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.event;\n+\n+import sun.nio.ch.FileChannelImpl;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.RandomAccessFile;\n+import java.lang.Throwable;\n+import java.lang.reflect.Field;\n+\n+\/**\n+ * Helper class to enable JFR tracing.\n+ *\/\n+public final class JFRTracing {\n+\n+  public static void enable() throws NoSuchFieldException, IllegalAccessException {\n+      enable(Throwable.class);\n+      enable(FileInputStream.class);\n+      enable(FileOutputStream.class);\n+      enable(FileChannelImpl.class);\n+      enable(RandomAccessFile.class);\n+  }\n+\n+  private static void enable(Class<?> clazz) throws NoSuchFieldException, IllegalAccessException {\n+      Field field = clazz.getDeclaredField(\"jfrTracing\");\n+      field.setAccessible(true);\n+      field.setBoolean(null, true);\n+  }\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/JFRTracing.java","additions":52,"deletions":0,"binary":false,"changes":52,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import java.lang.reflect.Field;\n@@ -37,6 +36,0 @@\n-    public static void enable() throws NoSuchFieldException, IllegalAccessException {\n-        Field field = Throwable.class.getDeclaredField(\"jfrTracing\");\n-        field.setAccessible(true);\n-        field.setBoolean(null, true);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/event\/ThrowableTracer.java","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -63,1 +63,2 @@\n-\n+import jdk.internal.event.FileReadEvent;\n+import jdk.internal.event.FileWriteEvent;\n@@ -76,0 +77,3 @@\n+    \/\/ Flag that determines if file reads\/writes should be traced by JFR\n+    private static boolean jfrTracing;\n+\n@@ -223,0 +227,7 @@\n+        if (jfrTracing) {\n+            return traceImplRead(dst);\n+        }\n+        return implRead(dst);\n+    }\n+\n+    private int implRead(ByteBuffer dst) throws IOException {\n@@ -253,0 +264,22 @@\n+    private int traceImplRead(ByteBuffer dst) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return implRead(dst);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = implRead(dst);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -254,1 +287,8 @@\n-    public long read(ByteBuffer[] dsts, int offset, int length)\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (jfrTracing) {\n+            return traceImplRead(dsts, offset, length);\n+        }\n+        return implRead(dsts, offset, length);\n+    }\n+\n+    private long implRead(ByteBuffer[] dsts, int offset, int length)\n@@ -289,0 +329,22 @@\n+    private long traceImplRead(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return implRead(dsts, offset, length);\n+        }\n+        long bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = implRead(dsts, offset, length);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -291,0 +353,7 @@\n+        if (jfrTracing) {\n+            return traceImplWrite(src);\n+        }\n+        return implWrite(src);\n+    }\n+\n+    private int implWrite(ByteBuffer src) throws IOException {\n@@ -322,0 +391,19 @@\n+    private int traceImplWrite(ByteBuffer src) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            return implWrite(src);\n+        }\n+        int bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            bytesWritten = implWrite(src);\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n+                FileWriteEvent.commit(start, duration, path, bytes);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+\n@@ -323,2 +411,8 @@\n-    public long write(ByteBuffer[] srcs, int offset, int length)\n-        throws IOException\n+    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        if (jfrTracing) {\n+            return traceImplWrite(srcs, offset, length);\n+        }\n+        return implWrite(srcs, offset, length);\n+    }\n+\n+    private long implWrite(ByteBuffer[] srcs, int offset, int length) throws IOException\n@@ -357,0 +451,18 @@\n+    private long traceImplWrite(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            return implWrite(srcs, offset, length);\n+        }\n+        long bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            bytesWritten = implWrite(srcs, offset, length);\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n+                FileWriteEvent.commit(start, duration, path, bytes);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n@@ -1031,0 +1143,7 @@\n+        if (jfrTracing) {\n+            return traceImplRead(dst, position);\n+        }\n+        return implRead(dst, position);\n+    }\n+\n+    private int implRead(ByteBuffer dst, long position) throws IOException {\n@@ -1049,0 +1168,22 @@\n+    private int traceImplRead(ByteBuffer dst, long position) throws IOException {\n+        if (!FileReadEvent.enabled()) {\n+            return implRead(dst, position);\n+        }\n+        int bytesRead = 0;\n+        long start = 0;\n+        try {\n+            start = FileReadEvent.timestamp();\n+            bytesRead = implRead(dst, position);\n+        } finally {\n+            long duration = FileReadEvent.timestamp() - start;\n+            if (FileReadEvent.shouldCommit(duration)) {\n+                if (bytesRead < 0) {\n+                    FileReadEvent.commit(start, duration, path, 0L, true);\n+                } else {\n+                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n+                }\n+            }\n+        }\n+        return bytesRead;\n+    }\n+\n@@ -1077,0 +1218,7 @@\n+        if (jfrTracing) {\n+            return traceImplWrite(src, position);\n+        }\n+        return implWrite(src, position);\n+    }\n+\n+    private int implWrite(ByteBuffer src, long position) throws IOException {\n@@ -1095,0 +1243,20 @@\n+    private int traceImplWrite(ByteBuffer src, long position) throws IOException {\n+        if (!FileWriteEvent.enabled()) {\n+            return implWrite(src, position);\n+        }\n+\n+        int bytesWritten = 0;\n+        long start = 0;\n+        try {\n+            start = FileWriteEvent.timestamp();\n+            bytesWritten = implWrite(src, position);\n+        } finally {\n+            long duration = FileWriteEvent.timestamp() - start;\n+            if (FileWriteEvent.shouldCommit(duration)) {\n+                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n+                FileWriteEvent.commit(start, duration, path, bytes);\n+            }\n+        }\n+        return bytesWritten;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/FileChannelImpl.java","additions":172,"deletions":4,"binary":false,"changes":176,"status":"modified"},{"patch":"@@ -1,33 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.events;\n-import jdk.jfr.internal.JVMSupport;\n-import jdk.jfr.internal.event.EventConfiguration;\n-\n-public final class EventConfigurations {\n-    public static final EventConfiguration FILE_READ = JVMSupport.getConfiguration(FileReadEvent.class);\n-    public static final EventConfiguration FILE_WRITE = JVMSupport.getConfiguration(FileWriteEvent.class);\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/EventConfigurations.java","additions":0,"deletions":33,"binary":false,"changes":33,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.MirrorEvent;\n@@ -39,4 +40,2 @@\n-public final class FileReadEvent extends AbstractJDKEvent {\n-\n-    \/\/ The order of these fields must be the same as the parameters in\n-    \/\/ commit(..., String, long, boolean)\n+@StackFilter({\"java.io.FileInputStream\", \"java.io.RandomAccessFile\", \"sun.nio.ch.FileChannelImpl\"})\n+public final class FileReadEvent extends MirrorEvent {\n@@ -57,3 +56,0 @@\n-    public static void commit(long start, long duration, String path, long bytesRead, boolean endOfFile) {\n-        \/\/ Generated\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileReadEvent.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.jfr.internal.MirrorEvent;\n@@ -39,4 +40,2 @@\n-public final class FileWriteEvent extends AbstractJDKEvent {\n-\n-    \/\/ The order of these fields must be the same as the parameters in\n-    \/\/ commit(..., String, long)\n+@StackFilter({\"java.io.FileOutputStream\", \"java.io.RandomAccessFile\", \"sun.nio.ch.FileChannelImpl\"})\n+public final class FileWriteEvent extends MirrorEvent {\n@@ -52,4 +51,0 @@\n-\n-    public static void commit(long start, long duration, String path, long bytesWritten) {\n-        \/\/ Generated\n-    }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/events\/FileWriteEvent.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.internal;\n+\n+import java.util.Properties;\n+\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.event.JFRTracing;\n+import jdk.internal.event.ThrowableTracer;\n+import jdk.internal.platform.Container;\n+import jdk.internal.platform.Metrics;\n+import jdk.jfr.Event;\n+import jdk.jfr.events.ActiveRecordingEvent;\n+import jdk.jfr.events.ActiveSettingEvent;\n+import jdk.jfr.events.ContainerCPUThrottlingEvent;\n+import jdk.jfr.events.ContainerCPUUsageEvent;\n+import jdk.jfr.events.ContainerConfigurationEvent;\n+import jdk.jfr.events.ContainerIOUsageEvent;\n+import jdk.jfr.events.ContainerMemoryUsageEvent;\n+import jdk.jfr.events.DirectBufferStatisticsEvent;\n+import jdk.jfr.events.InitialSecurityPropertyEvent;\n+import jdk.jfr.internal.periodic.PeriodicEvents;\n+\n+public final class JDKEvents {\n+\n+    private static final Class<?>[] eventClasses = {\n+        ActiveSettingEvent.class,\n+        ActiveRecordingEvent.class,\n+        \/\/ jdk.internal.event.* classes need their mirror\n+        \/\/ event class to be listed in the MirrorEvents class.\n+        jdk.internal.event.DeserializationEvent.class,\n+        jdk.internal.event.ErrorThrownEvent.class,\n+        jdk.internal.event.ExceptionStatisticsEvent.class,\n+        jdk.internal.event.ExceptionThrownEvent.class,\n+        jdk.internal.event.FileForceEvent.class,\n+        jdk.internal.event.FileReadEvent.class,\n+        jdk.internal.event.FileWriteEvent.class,\n+        jdk.internal.event.ProcessStartEvent.class,\n+        jdk.internal.event.SecurityPropertyModificationEvent.class,\n+        jdk.internal.event.SecurityProviderServiceEvent.class,\n+        jdk.internal.event.SerializationMisdeclarationEvent.class,\n+        jdk.internal.event.SocketReadEvent.class,\n+        jdk.internal.event.SocketWriteEvent.class,\n+        jdk.internal.event.ThreadSleepEvent.class,\n+        jdk.internal.event.TLSHandshakeEvent.class,\n+        jdk.internal.event.VirtualThreadStartEvent.class,\n+        jdk.internal.event.VirtualThreadEndEvent.class,\n+        jdk.internal.event.VirtualThreadPinnedEvent.class,\n+        jdk.internal.event.VirtualThreadSubmitFailedEvent.class,\n+        jdk.internal.event.X509CertificateEvent.class,\n+        jdk.internal.event.X509ValidationEvent.class,\n+        DirectBufferStatisticsEvent.class,\n+        InitialSecurityPropertyEvent.class,\n+    };\n+\n+    private static final Runnable emitExceptionStatistics = JDKEvents::emitExceptionStatistics;\n+    private static final Runnable emitDirectBufferStatistics = JDKEvents::emitDirectBufferStatistics;\n+    private static final Runnable emitContainerConfiguration = JDKEvents::emitContainerConfiguration;\n+    private static final Runnable emitContainerCPUUsage = JDKEvents::emitContainerCPUUsage;\n+    private static final Runnable emitContainerCPUThrottling = JDKEvents::emitContainerCPUThrottling;\n+    private static final Runnable emitContainerMemoryUsage = JDKEvents::emitContainerMemoryUsage;\n+    private static final Runnable emitContainerIOUsage = JDKEvents::emitContainerIOUsage;\n+    private static final Runnable emitInitialSecurityProperties = JDKEvents::emitInitialSecurityProperties;\n+    private static Metrics containerMetrics = null;\n+    private static boolean initializationTriggered;\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public static synchronized void initialize() {\n+        try {\n+            if (initializationTriggered == false) {\n+                for (Class<?> eventClass : eventClasses) {\n+                    SecuritySupport.registerEvent((Class<? extends Event>) eventClass);\n+                }\n+                PeriodicEvents.addJDKEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);\n+                PeriodicEvents.addJDKEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n+                PeriodicEvents.addJDKEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n+\n+                initializeContainerEvents();\n+                JFRTracing.enable();\n+                initializationTriggered = true;\n+            }\n+        } catch (Exception e) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Could not initialize JDK events. \" + e.getMessage());\n+        }\n+    }\n+\n+    private static void initializeContainerEvents() {\n+        if (JVM.isContainerized() ) {\n+            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"JVM is containerized\");\n+            containerMetrics = Container.metrics();\n+            if (containerMetrics != null) {\n+                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Container metrics are available\");\n+            }\n+        }\n+        \/\/ The registration of events and hooks are needed to provide metadata,\n+        \/\/ even when not running in a container\n+        SecuritySupport.registerEvent(ContainerConfigurationEvent.class);\n+        SecuritySupport.registerEvent(ContainerCPUUsageEvent.class);\n+        SecuritySupport.registerEvent(ContainerCPUThrottlingEvent.class);\n+        SecuritySupport.registerEvent(ContainerMemoryUsageEvent.class);\n+        SecuritySupport.registerEvent(ContainerIOUsageEvent.class);\n+\n+        PeriodicEvents.addJDKEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);\n+        PeriodicEvents.addJDKEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n+        PeriodicEvents.addJDKEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n+        PeriodicEvents.addJDKEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n+        PeriodicEvents.addJDKEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);\n+    }\n+\n+    private static void emitExceptionStatistics() {\n+        ThrowableTracer.emitStatistics();\n+    }\n+\n+    private static void emitContainerConfiguration() {\n+        if (containerMetrics != null) {\n+            ContainerConfigurationEvent t = new ContainerConfigurationEvent();\n+            t.containerType = containerMetrics.getProvider();\n+            t.cpuSlicePeriod = containerMetrics.getCpuPeriod();\n+            t.cpuQuota = containerMetrics.getCpuQuota();\n+            t.cpuShares = containerMetrics.getCpuShares();\n+            t.effectiveCpuCount = containerMetrics.getEffectiveCpuCount();\n+            t.memorySoftLimit = containerMetrics.getMemorySoftLimit();\n+            t.memoryLimit = containerMetrics.getMemoryLimit();\n+            t.swapMemoryLimit = containerMetrics.getMemoryAndSwapLimit();\n+            t.hostTotalMemory = JVM.hostTotalMemory();\n+            t.hostTotalSwapMemory = JVM.hostTotalSwapMemory();\n+            t.commit();\n+        }\n+    }\n+\n+    private static void emitContainerCPUUsage() {\n+        if (containerMetrics != null) {\n+            ContainerCPUUsageEvent event = new ContainerCPUUsageEvent();\n+\n+            event.cpuTime = containerMetrics.getCpuUsage();\n+            event.cpuSystemTime = containerMetrics.getCpuSystemUsage();\n+            event.cpuUserTime = containerMetrics.getCpuUserUsage();\n+            event.commit();\n+        }\n+    }\n+    private static void emitContainerMemoryUsage() {\n+        if (containerMetrics != null) {\n+            ContainerMemoryUsageEvent event = new ContainerMemoryUsageEvent();\n+\n+            event.memoryFailCount = containerMetrics.getMemoryFailCount();\n+            event.memoryUsage = containerMetrics.getMemoryUsage();\n+            event.swapMemoryUsage = containerMetrics.getMemoryAndSwapUsage();\n+            event.commit();\n+        }\n+    }\n+\n+    private static void emitContainerIOUsage() {\n+        if (containerMetrics != null) {\n+            ContainerIOUsageEvent event = new ContainerIOUsageEvent();\n+\n+            event.serviceRequests = containerMetrics.getBlkIOServiceCount();\n+            event.dataTransferred = containerMetrics.getBlkIOServiced();\n+            event.commit();\n+        }\n+    }\n+\n+    private static void emitContainerCPUThrottling() {\n+        if (containerMetrics != null) {\n+            ContainerCPUThrottlingEvent event = new ContainerCPUThrottlingEvent();\n+\n+            event.cpuElapsedSlices = containerMetrics.getCpuNumPeriods();\n+            event.cpuThrottledSlices = containerMetrics.getCpuNumThrottled();\n+            event.cpuThrottledTime = containerMetrics.getCpuThrottledTime();\n+            event.commit();\n+        }\n+    }\n+\n+    public static void remove() {\n+        PeriodicEvents.removeEvent(emitExceptionStatistics);\n+        PeriodicEvents.removeEvent(emitDirectBufferStatistics);\n+        PeriodicEvents.removeEvent(emitInitialSecurityProperties);\n+\n+        PeriodicEvents.removeEvent(emitContainerConfiguration);\n+        PeriodicEvents.removeEvent(emitContainerCPUUsage);\n+        PeriodicEvents.removeEvent(emitContainerCPUThrottling);\n+        PeriodicEvents.removeEvent(emitContainerMemoryUsage);\n+        PeriodicEvents.removeEvent(emitContainerIOUsage);\n+    }\n+\n+    private static void emitDirectBufferStatistics() {\n+        DirectBufferStatisticsEvent e = new DirectBufferStatisticsEvent();\n+        e.commit();\n+    }\n+\n+    private static void emitInitialSecurityProperties() {\n+        Properties p = SharedSecrets.getJavaSecurityPropertiesAccess().getInitialProperties();\n+        if (p != null) {\n+            for (String key : p.stringPropertyNames()) {\n+                InitialSecurityPropertyEvent e = new InitialSecurityPropertyEvent();\n+                e.key = key;\n+                e.value = p.getProperty(key);\n+                e.commit();\n+            }\n+        }\n+    }\n+}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JDKEvents.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -30,1 +30,0 @@\n-import jdk.jfr.internal.instrument.JDKEvents;\n@@ -81,1 +80,1 @@\n-            return JDKEvents.retransformCallback(clazz, oldBytes);\n+            return oldBytes;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/JVMUpcalls.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import jdk.jfr.events.FileReadEvent;\n+import jdk.jfr.events.FileWriteEvent;\n@@ -60,0 +62,2 @@\n+        register(\"jdk.internal.event.FileReadEvent\", FileReadEvent.class);\n+        register(\"jdk.internal.event.FileWriteEvent\", FileWriteEvent.class);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/MirrorEvents.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,0 @@\n-import jdk.jfr.internal.instrument.JDKEvents;\n@@ -86,1 +85,0 @@\n-        JDKEvents.addInstrumentation();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import jdk.jfr.events.FileForceEvent;\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.events.FileWriteEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.events.EventConfigurations;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"sun.nio.ch.FileChannelImpl\")\n-final class FileChannelImplInstrumentor {\n-\n-    private FileChannelImplInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public int read(ByteBuffer dst) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(dst);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(dst);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(ByteBuffer dst, long position) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(dst, position);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(dst, position);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(dsts, offset, length);\n-        }\n-        long bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(dsts, offset, length);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int write(ByteBuffer src) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            return write(src);\n-        }\n-        int bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesWritten = write(src);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int write(ByteBuffer src, long position) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            return write(src, position);\n-        }\n-\n-        int bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesWritten = write(src, position);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            return write(srcs, offset, length);\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesWritten = write(srcs, offset, length);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                long bytes = bytesWritten > 0 ? bytesWritten : 0;\n-                FileWriteEvent.commit(start, duration, path, bytes);\n-            }\n-        }\n-        return bytesWritten;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileChannelImplInstrumentor.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -1,119 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-\n-import jdk.jfr.events.EventConfigurations;\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"java.io.FileInputStream\")\n-final class FileInputStreamInstrumentor {\n-\n-    private FileInputStreamInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public int read() throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read();\n-        }\n-        int result = 0;\n-        boolean endOfFile = false;\n-        long bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            result = read();\n-            if (result < 0) {\n-                endOfFile = true;\n-            } else {\n-                bytesRead = 1;\n-            }\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b, off, len);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b, off, len);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileInputStreamInstrumentor.java","additions":0,"deletions":119,"binary":false,"changes":119,"status":"deleted"},{"patch":"@@ -1,107 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-\n-import jdk.jfr.events.FileWriteEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.events.EventConfigurations;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"java.io.FileOutputStream\")\n-final class FileOutputStreamInstrumentor {\n-\n-    private FileOutputStreamInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public void write(int b) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = 1;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = b.length;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b, off, len);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b, off, len);\n-            bytesWritten = len;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/FileOutputStreamInstrumentor.java","additions":0,"deletions":107,"binary":false,"changes":107,"status":"deleted"},{"patch":"@@ -1,275 +0,0 @@\n-\/*\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.Properties;\n-\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.event.ThrowableTracer;\n-import jdk.jfr.Event;\n-import jdk.jfr.events.ActiveRecordingEvent;\n-import jdk.jfr.events.ActiveSettingEvent;\n-import jdk.jfr.events.ContainerIOUsageEvent;\n-import jdk.jfr.events.ContainerConfigurationEvent;\n-import jdk.jfr.events.ContainerCPUUsageEvent;\n-import jdk.jfr.events.ContainerCPUThrottlingEvent;\n-import jdk.jfr.events.ContainerMemoryUsageEvent;\n-import jdk.jfr.events.DirectBufferStatisticsEvent;\n-import jdk.jfr.events.FileForceEvent;\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.events.FileWriteEvent;\n-import jdk.jfr.events.InitialSecurityPropertyEvent;\n-\n-import jdk.jfr.internal.JVM;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-import jdk.jfr.internal.SecuritySupport;\n-import jdk.jfr.internal.periodic.PeriodicEvents;\n-import jdk.internal.platform.Container;\n-import jdk.internal.platform.Metrics;\n-\n-public final class JDKEvents {\n-\n-    private static final Class<?>[] eventClasses = {\n-        FileReadEvent.class,\n-        FileWriteEvent.class,\n-        ActiveSettingEvent.class,\n-        ActiveRecordingEvent.class,\n-        \/\/ jdk.internal.event.* classes need their mirror\n-        \/\/ event class to be listed in the MirrorEvents class.\n-        jdk.internal.event.DeserializationEvent.class,\n-        jdk.internal.event.ErrorThrownEvent.class,\n-        jdk.internal.event.ExceptionStatisticsEvent.class,\n-        jdk.internal.event.ExceptionThrownEvent.class,\n-        jdk.internal.event.FileForceEvent.class,\n-        jdk.internal.event.ProcessStartEvent.class,\n-        jdk.internal.event.SecurityPropertyModificationEvent.class,\n-        jdk.internal.event.SecurityProviderServiceEvent.class,\n-        jdk.internal.event.SerializationMisdeclarationEvent.class,\n-        jdk.internal.event.SocketReadEvent.class,\n-        jdk.internal.event.SocketWriteEvent.class,\n-        jdk.internal.event.ThreadSleepEvent.class,\n-        jdk.internal.event.TLSHandshakeEvent.class,\n-        jdk.internal.event.VirtualThreadStartEvent.class,\n-        jdk.internal.event.VirtualThreadEndEvent.class,\n-        jdk.internal.event.VirtualThreadPinnedEvent.class,\n-        jdk.internal.event.VirtualThreadSubmitFailedEvent.class,\n-        jdk.internal.event.X509CertificateEvent.class,\n-        jdk.internal.event.X509ValidationEvent.class,\n-        DirectBufferStatisticsEvent.class,\n-        InitialSecurityPropertyEvent.class,\n-    };\n-\n-    \/\/ This is a list of the classes with instrumentation code that should be applied.\n-    private static final Class<?>[] instrumentationClasses = new Class<?>[] {\n-        FileInputStreamInstrumentor.class,\n-        FileOutputStreamInstrumentor.class,\n-        RandomAccessFileInstrumentor.class,\n-        FileChannelImplInstrumentor.class\n-    };\n-\n-    private static final Class<?>[] targetClasses = new Class<?>[instrumentationClasses.length];\n-    private static final Runnable emitExceptionStatistics = JDKEvents::emitExceptionStatistics;\n-    private static final Runnable emitDirectBufferStatistics = JDKEvents::emitDirectBufferStatistics;\n-    private static final Runnable emitContainerConfiguration = JDKEvents::emitContainerConfiguration;\n-    private static final Runnable emitContainerCPUUsage = JDKEvents::emitContainerCPUUsage;\n-    private static final Runnable emitContainerCPUThrottling = JDKEvents::emitContainerCPUThrottling;\n-    private static final Runnable emitContainerMemoryUsage = JDKEvents::emitContainerMemoryUsage;\n-    private static final Runnable emitContainerIOUsage = JDKEvents::emitContainerIOUsage;\n-    private static final Runnable emitInitialSecurityProperties = JDKEvents::emitInitialSecurityProperties;\n-    private static Metrics containerMetrics = null;\n-    private static boolean initializationTriggered;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    public static synchronized void initialize() {\n-        try {\n-            if (initializationTriggered == false) {\n-                for (Class<?> eventClass : eventClasses) {\n-                    SecuritySupport.registerEvent((Class<? extends Event>) eventClass);\n-                }\n-                PeriodicEvents.addJDKEvent(jdk.internal.event.ExceptionStatisticsEvent.class, emitExceptionStatistics);\n-                PeriodicEvents.addJDKEvent(DirectBufferStatisticsEvent.class, emitDirectBufferStatistics);\n-                PeriodicEvents.addJDKEvent(InitialSecurityPropertyEvent.class, emitInitialSecurityProperties);\n-\n-                initializeContainerEvents();\n-                ThrowableTracer.enable();\n-                initializationTriggered = true;\n-            }\n-        } catch (Exception e) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Could not initialize JDK events. \" + e.getMessage());\n-        }\n-    }\n-\n-    public static void addInstrumentation() {\n-        try {\n-            List<Class<?>> list = new ArrayList<>();\n-            for (int i = 0; i < instrumentationClasses.length; i++) {\n-                JIInstrumentationTarget tgt = instrumentationClasses[i].getAnnotation(JIInstrumentationTarget.class);\n-                Class<?> clazz = Class.forName(tgt.value());\n-                targetClasses[i] = clazz;\n-                list.add(clazz);\n-            }\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.INFO, \"Retransformed JDK classes\");\n-            JVM.retransformClasses(list.toArray(new Class<?>[list.size()]));\n-        } catch (IllegalStateException ise) {\n-            throw ise;\n-        } catch (Exception e) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.WARN, \"Could not add instrumentation for JDK events. \" + e.getMessage());\n-        }\n-    }\n-\n-    private static void initializeContainerEvents() {\n-        if (JVM.isContainerized() ) {\n-            Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"JVM is containerized\");\n-            containerMetrics = Container.metrics();\n-            if (containerMetrics != null) {\n-                Logger.log(LogTag.JFR_SYSTEM, LogLevel.DEBUG, \"Container metrics are available\");\n-            }\n-        }\n-        \/\/ The registration of events and hooks are needed to provide metadata,\n-        \/\/ even when not running in a container\n-        SecuritySupport.registerEvent(ContainerConfigurationEvent.class);\n-        SecuritySupport.registerEvent(ContainerCPUUsageEvent.class);\n-        SecuritySupport.registerEvent(ContainerCPUThrottlingEvent.class);\n-        SecuritySupport.registerEvent(ContainerMemoryUsageEvent.class);\n-        SecuritySupport.registerEvent(ContainerIOUsageEvent.class);\n-\n-        PeriodicEvents.addJDKEvent(ContainerConfigurationEvent.class, emitContainerConfiguration);\n-        PeriodicEvents.addJDKEvent(ContainerCPUUsageEvent.class, emitContainerCPUUsage);\n-        PeriodicEvents.addJDKEvent(ContainerCPUThrottlingEvent.class, emitContainerCPUThrottling);\n-        PeriodicEvents.addJDKEvent(ContainerMemoryUsageEvent.class, emitContainerMemoryUsage);\n-        PeriodicEvents.addJDKEvent(ContainerIOUsageEvent.class, emitContainerIOUsage);\n-    }\n-\n-    private static void emitExceptionStatistics() {\n-        ThrowableTracer.emitStatistics();\n-    }\n-\n-    private static void emitContainerConfiguration() {\n-        if (containerMetrics != null) {\n-            ContainerConfigurationEvent t = new ContainerConfigurationEvent();\n-            t.containerType = containerMetrics.getProvider();\n-            t.cpuSlicePeriod = containerMetrics.getCpuPeriod();\n-            t.cpuQuota = containerMetrics.getCpuQuota();\n-            t.cpuShares = containerMetrics.getCpuShares();\n-            t.effectiveCpuCount = containerMetrics.getEffectiveCpuCount();\n-            t.memorySoftLimit = containerMetrics.getMemorySoftLimit();\n-            t.memoryLimit = containerMetrics.getMemoryLimit();\n-            t.swapMemoryLimit = containerMetrics.getMemoryAndSwapLimit();\n-            t.hostTotalMemory = JVM.hostTotalMemory();\n-            t.hostTotalSwapMemory = JVM.hostTotalSwapMemory();\n-            t.commit();\n-        }\n-    }\n-\n-    private static void emitContainerCPUUsage() {\n-        if (containerMetrics != null) {\n-            ContainerCPUUsageEvent event = new ContainerCPUUsageEvent();\n-\n-            event.cpuTime = containerMetrics.getCpuUsage();\n-            event.cpuSystemTime = containerMetrics.getCpuSystemUsage();\n-            event.cpuUserTime = containerMetrics.getCpuUserUsage();\n-            event.commit();\n-        }\n-    }\n-    private static void emitContainerMemoryUsage() {\n-        if (containerMetrics != null) {\n-            ContainerMemoryUsageEvent event = new ContainerMemoryUsageEvent();\n-\n-            event.memoryFailCount = containerMetrics.getMemoryFailCount();\n-            event.memoryUsage = containerMetrics.getMemoryUsage();\n-            event.swapMemoryUsage = containerMetrics.getMemoryAndSwapUsage();\n-            event.commit();\n-        }\n-    }\n-\n-    private static void emitContainerIOUsage() {\n-        if (containerMetrics != null) {\n-            ContainerIOUsageEvent event = new ContainerIOUsageEvent();\n-\n-            event.serviceRequests = containerMetrics.getBlkIOServiceCount();\n-            event.dataTransferred = containerMetrics.getBlkIOServiced();\n-            event.commit();\n-        }\n-    }\n-\n-    private static void emitContainerCPUThrottling() {\n-        if (containerMetrics != null) {\n-            ContainerCPUThrottlingEvent event = new ContainerCPUThrottlingEvent();\n-\n-            event.cpuElapsedSlices = containerMetrics.getCpuNumPeriods();\n-            event.cpuThrottledSlices = containerMetrics.getCpuNumThrottled();\n-            event.cpuThrottledTime = containerMetrics.getCpuThrottledTime();\n-            event.commit();\n-        }\n-    }\n-\n-    @SuppressWarnings(\"deprecation\")\n-    public static byte[] retransformCallback(Class<?> klass, byte[] oldBytes) throws Throwable {\n-        for (int i = 0; i < targetClasses.length; i++) {\n-            if (targetClasses[i].equals(klass)) {\n-                Class<?> c = instrumentationClasses[i];\n-                if (Logger.shouldLog(LogTag.JFR_SYSTEM, LogLevel.TRACE)) {\n-                    Logger.log(LogTag.JFR_SYSTEM, LogLevel.TRACE, \"Processing instrumentation class: \" + c);\n-                }\n-                return new JIClassInstrumentation(instrumentationClasses[i], klass, oldBytes).getNewBytes();\n-            }\n-        }\n-        return oldBytes;\n-    }\n-\n-    public static void remove() {\n-        PeriodicEvents.removeEvent(emitExceptionStatistics);\n-        PeriodicEvents.removeEvent(emitDirectBufferStatistics);\n-        PeriodicEvents.removeEvent(emitInitialSecurityProperties);\n-\n-        PeriodicEvents.removeEvent(emitContainerConfiguration);\n-        PeriodicEvents.removeEvent(emitContainerCPUUsage);\n-        PeriodicEvents.removeEvent(emitContainerCPUThrottling);\n-        PeriodicEvents.removeEvent(emitContainerMemoryUsage);\n-        PeriodicEvents.removeEvent(emitContainerIOUsage);\n-    }\n-\n-    private static void emitDirectBufferStatistics() {\n-        DirectBufferStatisticsEvent e = new DirectBufferStatisticsEvent();\n-        e.commit();\n-    }\n-\n-    private static void emitInitialSecurityProperties() {\n-        Properties p = SharedSecrets.getJavaSecurityPropertiesAccess().getInitialProperties();\n-        if (p != null) {\n-            for (String key : p.stringPropertyNames()) {\n-                InitialSecurityPropertyEvent e = new InitialSecurityPropertyEvent();\n-                e.key = key;\n-                e.value = p.getProperty(key);\n-                e.commit();\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JDKEvents.java","additions":0,"deletions":275,"binary":false,"changes":275,"status":"deleted"},{"patch":"@@ -1,130 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-import java.io.InputStream;\n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.ClassWriter;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.jfr.internal.SecuritySupport;\n-\n-\/**\n- * This class will perform byte code instrumentation given an \"instrumentor\" class.\n- *\n- * @see JITracer\n- *\n- * @author Staffan Larsen\n- *\/\n-@Deprecated\n-final class JIClassInstrumentation {\n-    private final Class<?> instrumentor;\n-    private final String targetName;\n-    private final String instrumentorName;\n-    private final byte[] newBytes;\n-    private final ClassReader targetClassReader;\n-    private final ClassReader instrClassReader;\n-\n-    \/**\n-     * Creates an instance and performs the instrumentation.\n-     *\n-     * @param instrumentor instrumentor class\n-     * @param target target class\n-     * @param old_target_bytes bytes in target\n-     *\n-     * @throws ClassNotFoundException\n-     * @throws IOException\n-     *\/\n-    JIClassInstrumentation(Class<?> instrumentor, Class<?> target, byte[] old_target_bytes) throws ClassNotFoundException, IOException {\n-        instrumentorName = instrumentor.getName();\n-        this.targetName = target.getName();\n-        this.instrumentor = instrumentor;\n-        this.targetClassReader = new ClassReader(old_target_bytes);\n-        this.instrClassReader = new ClassReader(getOriginalClassBytes(instrumentor));\n-        this.newBytes = makeBytecode();\n-    }\n-\n-    private static byte[] getOriginalClassBytes(Class<?> clazz) throws IOException {\n-        String name = \"\/\" + clazz.getName().replace(\".\", \"\/\") + \".class\";\n-        try (InputStream is = SecuritySupport.getResourceAsStream(name)) {\n-            return is.readAllBytes();\n-        }\n-    }\n-\n-    private byte[] makeBytecode() throws IOException, ClassNotFoundException {\n-\n-        \/\/ Find the methods to instrument and inline\n-\n-        final List<Method> instrumentationMethods = new ArrayList<>();\n-        for (final Method m : instrumentor.getDeclaredMethods()) {\n-            JIInstrumentationMethod im = m.getAnnotation(JIInstrumentationMethod.class);\n-            if (im != null) {\n-                instrumentationMethods.add(m);\n-            }\n-        }\n-\n-        \/\/ We begin by inlining the target's methods into the instrumentor\n-\n-        ClassNode temporary = new ClassNode();\n-        ClassVisitor inliner = new JIInliner(\n-                Opcodes.ASM7,\n-                temporary,\n-                targetName,\n-                instrumentorName,\n-                targetClassReader,\n-                instrumentationMethods);\n-        instrClassReader.accept(inliner, ClassReader.EXPAND_FRAMES);\n-\n-        \/\/ Now we have the target's methods inlined into the instrumentation code (in 'temporary').\n-        \/\/ We now need to replace the target's method with the code in the\n-        \/\/ instrumentation method.\n-\n-        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES);\n-        JIMethodMergeAdapter ma = new JIMethodMergeAdapter(\n-                cw,\n-                temporary,\n-                instrumentationMethods,\n-                instrumentor.getAnnotationsByType(JITypeMapping.class));\n-        targetClassReader.accept(ma, ClassReader.EXPAND_FRAMES);\n-\n-       return cw.toByteArray();\n-    }\n-\n-    \/**\n-     * Get the instrumented byte codes that can be used to retransform the class.\n-     *\n-     * @return bytes\n-     *\/\n-    public byte[] getNewBytes() {\n-        return newBytes.clone();\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIClassInstrumentation.java","additions":0,"deletions":130,"binary":false,"changes":130,"status":"deleted"},{"patch":"@@ -1,113 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.reflect.Method;\n-import java.lang.reflect.Modifier;\n-import java.util.List;\n-\n-import jdk.internal.org.objectweb.asm.ClassReader;\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-\n-@Deprecated\n-final class JIInliner extends ClassVisitor {\n-    private final String targetClassName;\n-    private final String instrumentationClassName;\n-    private final ClassNode targetClassNode;\n-    private final List<Method> instrumentationMethods;\n-\n-    \/**\n-     * A ClassVisitor which will check all methods of the class it visits against the instrumentationMethods\n-     * list. If a method is on that list, the method will be further processed for inlining into that\n-     * method.\n-     *\/\n-    JIInliner(int api, ClassVisitor cv, String targetClassName, String instrumentationClassName,\n-            ClassReader targetClassReader,\n-            List<Method> instrumentationMethods) {\n-        super(api, cv);\n-        this.targetClassName = targetClassName;\n-        this.instrumentationClassName = instrumentationClassName;\n-        this.instrumentationMethods = instrumentationMethods;\n-\n-        ClassNode cn = new ClassNode(Opcodes.ASM7);\n-        targetClassReader.accept(cn, ClassReader.EXPAND_FRAMES);\n-        this.targetClassNode = cn;\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions);\n-\n-        if (isInstrumentationMethod(name, desc)) {\n-            MethodNode methodToInline = findTargetMethodNode(name, desc);\n-            if (methodToInline == null) {\n-                throw new IllegalArgumentException(\"Could not find the method to instrument in the target class\");\n-            }\n-            if (Modifier.isNative(methodToInline.access)) {\n-                throw new IllegalArgumentException(\"Cannot instrument native methods: \" + targetClassNode.name + \".\" + methodToInline.name + methodToInline.desc);\n-            }\n-\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Inliner processing method \" + name + desc);\n-\n-            JIMethodCallInliner mci = new JIMethodCallInliner(access,\n-                    desc,\n-                    mv,\n-                    methodToInline,\n-                    targetClassName,\n-                    instrumentationClassName);\n-            return mci;\n-        }\n-\n-        return mv;\n-    }\n-\n-    private boolean isInstrumentationMethod(String name, String desc) {\n-        for(Method m : instrumentationMethods) {\n-            if (m.getName().equals(name) && Type.getMethodDescriptor(m).equals(desc)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-\n-    private MethodNode findTargetMethodNode(String name, String desc) {\n-        for (MethodNode mn : targetClassNode.methods) {\n-            if (mn.desc.equals(desc) && mn.name.equals(name)) {\n-                return mn;\n-            }\n-        }\n-        throw new IllegalArgumentException(\"could not find MethodNode for \"\n-                + name + desc);\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIInliner.java","additions":0,"deletions":113,"binary":false,"changes":113,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Target(ElementType.METHOD)\n-@Retention(RetentionPolicy.RUNTIME)\n-@interface JIInstrumentationMethod {\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIInstrumentationMethod.java","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -1,37 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.annotation.ElementType;\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-import java.lang.annotation.Target;\n-\n-@Target(ElementType.TYPE)\n-@Retention(RetentionPolicy.RUNTIME)\n-@interface JIInstrumentationTarget {\n-    String value();\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIInstrumentationTarget.java","additions":0,"deletions":37,"binary":false,"changes":37,"status":"deleted"},{"patch":"@@ -1,152 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.util.ArrayList;\n-import java.util.List;\n-\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.commons.LocalVariablesSorter;\n-import jdk.internal.org.objectweb.asm.commons.Remapper;\n-import jdk.internal.org.objectweb.asm.commons.SimpleRemapper;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-\n-\/**\n- * Class responsible for finding the call to inline and inlining it.\n- *\n- * This code is heavily influenced by section 3.2.6 \"Inline Method\" in\n- * \"Using ASM framework to implement common bytecode transformation patterns\",\n- * E. Kuleshov, AOSD.07, March 2007, Vancouver, Canada.\n- * http:\/\/asm.ow2.org\/index.html\n- *\/\n-@Deprecated\n-final class JIMethodCallInliner extends LocalVariablesSorter {\n-\n-    private final String oldClass;\n-    private final String newClass;\n-    private final MethodNode inlineTarget;\n-    private final List<CatchBlock> blocks = new ArrayList<>();\n-    private boolean inlining;\n-\n-    \/**\n-     * inlineTarget defines the method to inline and also contains the actual\n-     * code to inline.\n-     *\n-     * @param access\n-     * @param desc\n-     * @param mv\n-     * @param inlineTarget\n-     * @param oldClass\n-     * @param newClass\n-     * @param logger\n-     *\/\n-    public JIMethodCallInliner(int access, String desc, MethodVisitor mv,\n-            MethodNode inlineTarget, String oldClass, String newClass) {\n-        super(Opcodes.ASM7, access, desc, mv);\n-        this.oldClass = oldClass;\n-        this.newClass = newClass;\n-        this.inlineTarget = inlineTarget;\n-\n-        if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG)) {\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG,\n-                \"MethodCallInliner: targetMethod=\" + newClass + \".\"\n-                + inlineTarget.name + inlineTarget.desc);\n-        }\n-    }\n-\n-    @Override\n-    public void visitMethodInsn(int opcode, String owner, String name,\n-            String desc, boolean itf) {\n-        \/\/ Now we are looking at method call in the source method\n-        if (!shouldBeInlined(owner, name, desc)) {\n-            \/\/ If this method call should not be inlined, just keep it\n-            mv.visitMethodInsn(opcode, owner, name, desc, itf);\n-            return;\n-        }\n-        \/\/ If the call should be inlined, we create a MethodInliningAdapter\n-        \/\/ The MIA will walk the instructions in the inlineTarget and add them\n-        \/\/ to the current method, doing the necessary name remappings.\n-        Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Inlining call to \" + name + desc);\n-        Remapper remapper = new SimpleRemapper(oldClass, newClass);\n-        Label end = new Label();\n-        inlining = true;\n-        inlineTarget.instructions.resetLabels();\n-        JIMethodInliningAdapter mia = new JIMethodInliningAdapter(this, end,\n-                opcode == Opcodes.INVOKESTATIC ? Opcodes.ACC_STATIC : 0, desc,\n-                remapper);\n-        inlineTarget.accept(mia);\n-        inlining = false;\n-        super.visitLabel(end);\n-    }\n-\n-    \/**\n-     * Determine if the method should be inlined or not.\n-     *\/\n-    private boolean shouldBeInlined(String owner, String name, String desc) {\n-        return inlineTarget.desc.equals(desc) && inlineTarget.name.equals(name)\n-                && owner.equals(newClass.replace('.', '\/'));\n-    }\n-\n-    @Override\n-    public void visitTryCatchBlock(Label start, Label end, Label handler,\n-            String type) {\n-        if (!inlining) {\n-            \/\/ try-catch blocks are saved here and replayed at the end\n-            \/\/ of the method (in visitMaxs)\n-            blocks.add(new CatchBlock(start, end, handler, type));\n-        } else {\n-            super.visitTryCatchBlock(start, end, handler, type);\n-        }\n-    }\n-\n-    @Override\n-    public void visitMaxs(int stack, int locals) {\n-        for (CatchBlock b : blocks) {\n-            super.visitTryCatchBlock(b.start, b.end, b.handler, b.type);\n-        }\n-        super.visitMaxs(stack, locals);\n-    }\n-\n-    static final class CatchBlock {\n-\n-        final Label start;\n-        final Label end;\n-        final Label handler;\n-        final String type;\n-\n-        CatchBlock(Label start, Label end, Label handler, String type) {\n-            this.start = start;\n-            this.end = end;\n-            this.handler = handler;\n-            this.type = type;\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIMethodCallInliner.java","additions":0,"deletions":152,"binary":false,"changes":152,"status":"deleted"},{"patch":"@@ -1,76 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import jdk.internal.org.objectweb.asm.Label;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.LocalVariablesSorter;\n-import jdk.internal.org.objectweb.asm.commons.Remapper;\n-import jdk.internal.org.objectweb.asm.commons.RemappingMethodAdapter;\n-\n-@Deprecated\n-final class JIMethodInliningAdapter extends RemappingMethodAdapter {\n-    private final LocalVariablesSorter lvs;\n-    private final Label end;\n-\n-    public JIMethodInliningAdapter(LocalVariablesSorter mv, Label end, int acc, String desc, Remapper remapper) {\n-        super(acc, desc, mv, remapper);\n-        this.lvs = mv;\n-        this.end = end;\n-        int offset = isStatic(acc) ? 0 : 1;\n-        Type[] args = Type.getArgumentTypes(desc);\n-        for (int i = args.length - 1; i >= 0; i--) {\n-            super.visitVarInsn(args[i].getOpcode(Opcodes.ISTORE), i + offset);\n-        }\n-        if (offset > 0) {\n-            super.visitVarInsn(Opcodes.ASTORE, 0);\n-        }\n-    }\n-\n-    private boolean isStatic(int acc) {\n-        return (acc & Opcodes.ACC_STATIC) != 0;\n-    }\n-\n-    @Override\n-    public void visitInsn(int opcode) {\n-        if (opcode == Opcodes.RETURN || opcode == Opcodes.IRETURN\n-                || opcode == Opcodes.ARETURN || opcode == Opcodes.LRETURN) {\n-            super.visitJumpInsn(Opcodes.GOTO, end);\n-        } else {\n-            super.visitInsn(opcode);\n-        }\n-    }\n-\n-    @Override\n-    public void visitMaxs(int stack, int locals) {\n-    }\n-\n-    @Override\n-    protected int newLocalMapping(Type type) {\n-        return lvs.newLocal(type);\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIMethodInliningAdapter.java","additions":0,"deletions":76,"binary":false,"changes":76,"status":"deleted"},{"patch":"@@ -1,122 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import jdk.internal.org.objectweb.asm.ClassVisitor;\n-import jdk.internal.org.objectweb.asm.MethodVisitor;\n-import jdk.internal.org.objectweb.asm.Opcodes;\n-import jdk.internal.org.objectweb.asm.Type;\n-import jdk.internal.org.objectweb.asm.commons.RemappingMethodAdapter;\n-import jdk.internal.org.objectweb.asm.commons.SimpleRemapper;\n-import jdk.internal.org.objectweb.asm.tree.ClassNode;\n-import jdk.internal.org.objectweb.asm.tree.MethodNode;\n-import jdk.jfr.internal.LogLevel;\n-import jdk.jfr.internal.LogTag;\n-import jdk.jfr.internal.Logger;\n-\n-\/**\n- * This class will merge (some) methods from one class into another one.\n- *\n- * @author Staffan Larsen\n- *\/\n-@Deprecated\n-final class JIMethodMergeAdapter extends ClassVisitor {\n-\n-    private final ClassNode cn;\n-    private final List<Method> methodFilter;\n-    private final Map<String, String> typeMap;\n-\n-    \/**\n-     * Methods in methodFilter that exist in cn will be merged into cv. If the method already exists,\n-     * the original method will be deleted.\n-     *\n-     * @param cv\n-     * @param cn - a ClassNode with Methods that will be merged into this class\n-     * @param methodFilter - only methods in this list will be merged\n-     * @param typeMappings - while merging, type references in the methods will be changed according to this map\n-     *\/\n-    public JIMethodMergeAdapter(ClassVisitor cv, ClassNode cn, List<Method> methodFilter, JITypeMapping[] typeMappings) {\n-        super(Opcodes.ASM7, cv);\n-        this.cn = cn;\n-        this.methodFilter = methodFilter;\n-\n-        this.typeMap = new HashMap<>();\n-        for (JITypeMapping tm : typeMappings) {\n-            typeMap.put(tm.from().replace('.', '\/'), tm.to().replace('.', '\/'));\n-        }\n-    }\n-\n-    @Override\n-    public void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {\n-        super.visit(version, access, name, signature, superName, interfaces);\n-        typeMap.put(cn.name, name);\n-    }\n-\n-    @Override\n-    public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {\n-        if(methodInFilter(name, desc)) {\n-            \/\/ If the method is one that we will be replacing, delete the method\n-            Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Deleting \" + name + desc);\n-            return null;\n-        }\n-        return super.visitMethod(access, name, desc, signature, exceptions);\n-    }\n-\n-    @Override\n-    public void visitEnd() {\n-        SimpleRemapper remapper = new SimpleRemapper(typeMap);\n-        for (MethodNode mn : cn.methods) {\n-            \/\/ Check if the method is in the list of methods to copy\n-            if (methodInFilter(mn.name, mn.desc)) {\n-                if (Logger.shouldLog(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG)) {\n-                    Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"Copying method: \" + mn.name + mn.desc);\n-                    Logger.log(LogTag.JFR_SYSTEM_BYTECODE, LogLevel.DEBUG, \"   with mapper: \" + typeMap);\n-                }\n-\n-                String[] exceptions = new String[mn.exceptions.size()];\n-                mn.exceptions.toArray(exceptions);\n-                MethodVisitor mv = cv.visitMethod(mn.access, mn.name, mn.desc, mn.signature, exceptions);\n-                mn.instructions.resetLabels();\n-                mn.accept(new RemappingMethodAdapter(mn.access, mn.desc, mv, remapper));\n-            }\n-        }\n-        super.visitEnd();\n-    }\n-\n-    private boolean methodInFilter(String name, String desc) {\n-        for(Method m : methodFilter) {\n-            if (m.getName().equals(name) && Type.getMethodDescriptor(m).equals(desc)) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JIMethodMergeAdapter.java","additions":0,"deletions":122,"binary":false,"changes":122,"status":"deleted"},{"patch":"@@ -1,35 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.lang.annotation.Retention;\n-import java.lang.annotation.RetentionPolicy;\n-\n-@Retention(RetentionPolicy.RUNTIME)\n-@interface JITypeMapping {\n-    String from();\n-    String to();\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/JITypeMapping.java","additions":0,"deletions":35,"binary":false,"changes":35,"status":"deleted"},{"patch":"@@ -1,183 +0,0 @@\n-\/*\n- * Copyright (c) 2013, 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package jdk.jfr.internal.instrument;\n-\n-import java.io.IOException;\n-\n-import jdk.jfr.events.FileReadEvent;\n-import jdk.jfr.events.FileWriteEvent;\n-import jdk.jfr.internal.event.EventConfiguration;\n-import jdk.jfr.events.EventConfigurations;\n-\n-\/**\n- * See {@link JITracer} for an explanation of this code.\n- *\/\n-@JIInstrumentationTarget(\"java.io.RandomAccessFile\")\n-final class RandomAccessFileInstrumentor {\n-\n-    private RandomAccessFileInstrumentor() {\n-    }\n-\n-    private String path;\n-\n-    @JIInstrumentationMethod\n-    public int read() throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read();\n-        }\n-        int result = 0;\n-        long bytesRead = 0;\n-        boolean endOfFile = false;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            result = read();\n-            if (result < 0) {\n-                endOfFile = true;\n-            } else {\n-                bytesRead = 1;\n-            }\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileReadEvent.commit(start, duration, path, bytesRead, endOfFile);\n-            }\n-        }\n-        return result;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public int read(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_READ;\n-        if (!eventConfiguration.isEnabled()) {\n-            return read(b, off, len);\n-        }\n-        int bytesRead = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            bytesRead = read(b, off, len);\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                if (bytesRead < 0) {\n-                    FileReadEvent.commit(start, duration, path, 0L, true);\n-                } else {\n-                    FileReadEvent.commit(start, duration, path, bytesRead, false);\n-                }\n-            }\n-        }\n-        return bytesRead;\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(int b) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = 1;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[]) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b);\n-            bytesWritten = b.length;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-\n-    @JIInstrumentationMethod\n-    public void write(byte b[], int off, int len) throws IOException {\n-        EventConfiguration eventConfiguration = EventConfigurations.FILE_WRITE;\n-        if (!eventConfiguration.isEnabled()) {\n-            write(b, off, len);\n-            return;\n-        }\n-        long bytesWritten = 0;\n-        long start = 0;\n-        try {\n-            start = EventConfiguration.timestamp();\n-            write(b, off, len);\n-            bytesWritten = len;\n-        } finally {\n-            long duration = EventConfiguration.timestamp() - start;\n-            if (eventConfiguration.shouldCommit(duration)) {\n-                FileWriteEvent.commit(start, duration, path, bytesWritten);\n-            }\n-        }\n-    }\n-}\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/instrument\/RandomAccessFileInstrumentor.java","additions":0,"deletions":183,"binary":false,"changes":183,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+import jdk.jfr.internal.JDKEvents;\n@@ -60,1 +61,0 @@\n-import jdk.jfr.internal.instrument.JDKEvents;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/management\/ManagementSupport.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n-        \/\/ When JFR is initialized the FileReadEvent is registered and an EventConfiguration object\n+        \/\/ When JFR is initialized the DirectBufferStatisticsEvent is registered and an EventConfiguration object\n@@ -55,1 +55,1 @@\n-        Class<?>c = Class.forName(\"jdk.jfr.events.FileReadEvent\");\n+        Class<?>c = Class.forName(\"jdk.jfr.events.DirectBufferStatisticsEvent\");\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestGetEventWriterPackage.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n-    private static final String FILE_READ_FORCED_CLASS_LOAD = \"Adding forced instrumentation for event type \" + EventNames.FileRead + \" during initial class load\";\n+    private static final String FORCED_CLASS_LOAD = \"Adding forced instrumentation for event type \" + EventNames.DirectBufferStatistics + \" during initial class load\";\n@@ -64,1 +64,1 @@\n-            out.shouldContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldContain(FORCED_CLASS_LOAD);\n@@ -71,1 +71,1 @@\n-            out.shouldContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldContain(FORCED_CLASS_LOAD);\n@@ -78,1 +78,1 @@\n-            out.shouldNotContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldNotContain(FORCED_CLASS_LOAD);\n@@ -85,1 +85,1 @@\n-            out.shouldNotContain(FILE_READ_FORCED_CLASS_LOAD);\n+            out.shouldNotContain(FORCED_CLASS_LOAD);\n","filename":"test\/jdk\/jdk\/jfr\/startupargs\/TestRetransformUsingLog.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"filename":"webrev.zip","binary":true,"status":"added"}]}