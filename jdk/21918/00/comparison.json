{"files":[{"patch":"@@ -291,1 +291,1 @@\n-                                                                   IfProjNode* old_predicate_proj,\n+                                                                   ParsePredicateSuccessProj* old_parse_predicate_proj,\n@@ -300,1 +300,1 @@\n-  get_assertion_predicates(old_predicate_proj, list);\n+  get_assertion_predicates(old_parse_predicate_proj, list);\n@@ -303,2 +303,0 @@\n-  IfNode* iff = old_predicate_proj->in(0)->as_If();\n-  IfProjNode* uncommon_proj = iff->proj_out(1 - old_predicate_proj->as_Proj()->_con)->as_IfProj();\n@@ -310,1 +308,1 @@\n-    iff = predicate->in(0)->as_If();\n+    IfNode* iff = predicate->in(0)->as_If();\n@@ -340,28 +338,8 @@\n-\/\/ is set, then the OpaqueTemplateAssertionPredicate nodes of the Assertion Predicates are put on the list instead of\n-\/\/ the projections.\n-void PhaseIdealLoop::get_assertion_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque) {\n-  ParsePredicateNode* parse_predicate = predicate->in(0)->as_ParsePredicate();\n-  ProjNode* uncommon_proj = parse_predicate->proj_out(1 - predicate->as_Proj()->_con);\n-  Node* rgn = uncommon_proj->unique_ctrl_out();\n-  assert(rgn->is_Region() || rgn->is_Call(), \"must be a region or call uct\");\n-  predicate = parse_predicate->in(0);\n-  while (predicate != nullptr && predicate->is_Proj() && predicate->in(0)->is_If()) {\n-    IfNode* iff = predicate->in(0)->as_If();\n-    uncommon_proj = iff->proj_out(1 - predicate->as_Proj()->_con);\n-    if (uncommon_proj->unique_ctrl_out() != rgn) {\n-      break;\n-    }\n-    Node* bol = iff->in(1);\n-    assert(!bol->is_OpaqueInitializedAssertionPredicate(), \"should not find an Initialized Assertion Predicate\");\n-    if (bol->is_OpaqueTemplateAssertionPredicate()) {\n-      assert(assertion_predicate_has_loop_opaque_node(iff), \"must find OpaqueLoop* nodes\");\n-      if (get_opaque) {\n-        \/\/ Collect the OpaqueTemplateAssertionPredicateNode.\n-        list.push(bol);\n-      } else {\n-        \/\/ Collect the predicate projection.\n-        list.push(predicate);\n-      }\n-    }\n-    predicate = predicate->in(0)->in(0);\n-  }\n+\/\/ is set, then the OpaqueTemplateAssertionPredicateNode nodes of the Assertion Predicates are put on the list instead\n+\/\/ of the projections.\n+void PhaseIdealLoop::get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list,\n+                                              const bool get_opaque) {\n+  Deoptimization::DeoptReason deopt_reason = parse_predicate_proj->in(0)->as_ParsePredicate()->deopt_reason();\n+  PredicateBlockIterator predicate_iterator(parse_predicate_proj, deopt_reason);\n+  TemplateAssertionPredicateCollector template_assertion_predicate_collector(list, get_opaque);\n+  predicate_iterator.for_each(template_assertion_predicate_collector);\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":11,"deletions":33,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -4472,1 +4472,1 @@\n-      IfProjNode* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n+      ParsePredicateSuccessProj* parse_predicate_proj = profiled_loop_predicate_block->parse_predicate_success_proj();\n@@ -4480,1 +4480,1 @@\n-      IfProjNode* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n+      ParsePredicateSuccessProj* parse_predicate_proj = loop_predicate_block->parse_predicate_success_proj();\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -950,1 +950,1 @@\n-  static void get_assertion_predicates(Node* predicate, Unique_Node_List& list, bool get_opaque = false);\n+  static void get_assertion_predicates(ParsePredicateSuccessProj* parse_predicate_proj, Unique_Node_List& list, bool get_opaque = false);\n@@ -1675,1 +1675,1 @@\n-                                                     Deoptimization::DeoptReason reason, IfProjNode* old_predicate_proj,\n+                                                     Deoptimization::DeoptReason reason, ParsePredicateSuccessProj* old_parse_predicate_proj,\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1013,0 +1013,22 @@\n+\/\/ This visitor collects all Template Assertion Predicates If nodes or the corresponding Opaque nodes, depending on the\n+\/\/ provided 'get_opaque' flag, to the provided list.\n+class TemplateAssertionPredicateCollector : public PredicateVisitor {\n+  Unique_Node_List& _list;\n+  const bool _get_opaque;\n+\n+ public:\n+  TemplateAssertionPredicateCollector(Unique_Node_List& list, const bool get_opaque)\n+      : _list(list),\n+        _get_opaque(get_opaque) {}\n+\n+  using PredicateVisitor::visit;\n+\n+  void visit(const TemplateAssertionPredicate& template_assertion_predicate) override {\n+    if (_get_opaque) {\n+      _list.push(template_assertion_predicate.opaque_node());\n+    } else {\n+      _list.push(template_assertion_predicate.tail());\n+    }\n+  }\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}