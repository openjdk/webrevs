{"files":[{"patch":"@@ -346,0 +346,1 @@\n+    assert(p != nullptr, \"must not be null\");\n@@ -350,0 +351,9 @@\n+  template <typename T>\n+  u4 any_or_null_to_offset_u4(T p) const {\n+    if (p == nullptr) {\n+      return 0;\n+    } else {\n+      return any_to_offset_u4<T>(p);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -264,0 +264,8 @@\n+  \/\/ The following functions translate between a u4 offset and an address in the\n+  \/\/ the range of the mapped CDS archive (e.g., Metaspace::is_in_shared_metaspace()).\n+  \/\/ Since the first 16 bytes in this range are dummy data (see ArchiveBuilder::reserve_buffer()),\n+  \/\/ we know that offset 0 never represents a valid object. As a result, an offset of 0\n+  \/\/ is used to encode a nullptr.\n+  \/\/\n+  \/\/ Use the \"archived_address_or_null\" variants if a nullptr may be encoded.\n+\n@@ -266,1 +274,2 @@\n-  template <typename T> T static from_offset(u4 offset) {\n+  template <typename T> T static offset_to_archived_address(u4 offset) {\n+    assert(offset != 0, \"sanity\");\n@@ -272,0 +281,8 @@\n+  template <typename T> T static offset_to_archived_address_or_null(u4 offset) {\n+    if (offset == 0) {\n+      return nullptr;\n+    } else {\n+      return offset_to_archived_address<T>(offset);\n+    }\n+  }\n+\n@@ -273,1 +290,1 @@\n-  template <typename T> static u4 to_offset(T p) {\n+  template <typename T> static u4 archived_address_to_offset(T p) {\n@@ -282,0 +299,8 @@\n+\n+  template <typename T> static u4 archived_address_or_null_to_offset(T p) {\n+    if (p == nullptr) {\n+      return 0;\n+    } else {\n+      return archived_address_to_offset<T>(p);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/cds\/archiveUtils.hpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -257,1 +257,1 @@\n-      Array<char>* line = ArchiveUtils::from_offset<Array<char>*>(offset);\n+      Array<char>* line = ArchiveUtils::offset_to_archived_address<Array<char>*>(offset);\n","filename":"src\/hotspot\/share\/cds\/lambdaFormInvokers.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-    u4 member_method            = b->any_to_offset_u4(key.member_method());\n+    u4 member_method            = b->any_or_null_to_offset_u4(key.member_method()); \/\/ could be null\n@@ -161,6 +161,6 @@\n-    return RunTimeLambdaProxyClassKey(ArchiveUtils::to_offset(caller_ik),\n-                                      ArchiveUtils::to_offset(invoked_name),\n-                                      ArchiveUtils::to_offset(invoked_type),\n-                                      ArchiveUtils::to_offset(method_type),\n-                                      ArchiveUtils::to_offset(member_method),\n-                                      ArchiveUtils::to_offset(instantiated_method_type));\n+    return RunTimeLambdaProxyClassKey(ArchiveUtils::archived_address_to_offset(caller_ik),\n+                                      ArchiveUtils::archived_address_to_offset(invoked_name),\n+                                      ArchiveUtils::archived_address_to_offset(invoked_type),\n+                                      ArchiveUtils::archived_address_to_offset(method_type),\n+                                      ArchiveUtils::archived_address_or_null_to_offset(member_method), \/\/ could be null\n+                                      ArchiveUtils::archived_address_to_offset(instantiated_method_type));\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-    return ArchiveUtils::from_offset<InstanceKlass*>(_klass_offset);\n+    return ArchiveUtils::offset_to_archived_address<InstanceKlass*>(_klass_offset);\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,2 +55,2 @@\n-    Symbol* name() { return ArchiveUtils::from_offset<Symbol*>(_name); }\n-    Symbol* from_name() { return ArchiveUtils::from_offset<Symbol*>(_from_name); }\n+    Symbol* name() { return ArchiveUtils::offset_to_archived_address<Symbol*>(_name); }\n+    Symbol* from_name() { return ArchiveUtils::offset_to_archived_address<Symbol*>(_from_name); }\n@@ -63,1 +63,1 @@\n-    Symbol* constraint_name() { return ArchiveUtils::from_offset<Symbol*>(_name); }\n+    Symbol* constraint_name() { return ArchiveUtils::offset_to_archived_address<Symbol*>(_name); }\n@@ -180,5 +180,1 @@\n-    if (_nest_host_offset == 0) {\n-      return nullptr;\n-    } else {\n-      return ArchiveUtils::from_offset<InstanceKlass*>(_nest_host_offset);\n-    }\n+    return ArchiveUtils::offset_to_archived_address_or_null<InstanceKlass*>(_nest_host_offset);\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,108 @@\n+\/*\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8344824\n+ * @summary CDS dump crashes when member_method of a lambda proxy is null\n+ * @requires vm.cds\n+ * @library \/test\/lib\n+ * @build LambdaInvokeVirtual\n+ * @run driver jdk.test.lib.helpers.ClassFileInstaller -jar LambdaInvokeVirtualApp.jar LambdaInvokeVirtualApp MyFunctionalInterface\n+ * @run driver LambdaInvokeVirtual\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import jdk.test.lib.cds.CDSOptions;\n+import jdk.test.lib.cds.CDSTestUtils;\n+import jdk.test.lib.helpers.ClassFileInstaller;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class LambdaInvokeVirtual {\n+\n+    public static void main(String[] args) throws Exception {\n+        String appJar =  ClassFileInstaller.getJarPath(\"LambdaInvokeVirtualApp.jar\");\n+        String mainClass = LambdaInvokeVirtualApp.class.getName();\n+        String namePrefix = \"LambdaInvokeVirtualApp\";\n+        String classList = namePrefix + \".list\";\n+        String archiveName = namePrefix + \".jsa\";\n+\n+        \/\/ dump class list\n+        CDSTestUtils.dumpClassList(classList, \"-cp\", appJar, mainClass);\n+\n+        \/\/ create archive with the class list\n+        CDSOptions opts = (new CDSOptions())\n+            .addPrefix(\"-XX:ExtraSharedClassListFile=\" + classList,\n+                       \"-cp\", appJar,\n+                       \"-Xlog:cds,cds+class=debug\")\n+            .setArchiveName(archiveName);\n+        CDSTestUtils.createArchiveAndCheck(opts);\n+\n+        \/\/ run with archive\n+        CDSOptions runOpts = (new CDSOptions())\n+            .addPrefix(\"-cp\", appJar)\n+            .setArchiveName(archiveName)\n+            .setUseVersion(false)\n+            .addSuffix(mainClass);\n+        OutputAnalyzer output = CDSTestUtils.runWithArchive(runOpts);\n+        output.shouldHaveExitValue(0);\n+    }\n+}\n+\n+interface MyFunctionalInterface {\n+    Object invokeMethodReference(String s, char c1, char c2) throws Throwable;\n+}\n+\n+class LambdaInvokeVirtualApp {\n+    private static MethodHandle createMethodHandle() throws NoSuchMethodException, IllegalAccessException {\n+        MethodHandles.Lookup lookup = MethodHandles.lookup();\n+        MethodType mt = MethodType.methodType(String.class, char.class, char.class);\n+        return lookup.findVirtual(String.class, \"replace\", mt);\n+    }\n+\n+    public static void main(String argv[]) throws Throwable {\n+        MethodHandle ms = createMethodHandle();\n+        MyFunctionalInterface instance = ms::invoke;\n+\n+\/*\n+        The above is compiled into this bytecode. Note that the MethodHandle is of type REF_invokeVirtual\n+\n+        invokedynamic    InvokeDynamic REF_invokeStatic:Method java\/lang\/invoke\/LambdaMetafactory.metafactory:\"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodType;Ljava\/lang\/invoke\/MethodHandle;Ljava\/lang\/invoke\/MethodType;)Ljava\/lang\/invoke\/CallSite;\":invokeMethodReference:\"(Ljava\/lang\/invoke\/MethodHandle;)LMyFunctionalInterface;\" {\n+            MethodType \"(Ljava\/lang\/String;CC)Ljava\/lang\/Object;\",\n+            MethodHandle REF_invokeVirtual:Method java\/lang\/invoke\/MethodHandle.invoke:\"(Ljava\/lang\/String;CC)Ljava\/lang\/Object;\",\n+            MethodType \"(Ljava\/lang\/String;CC)Ljava\/lang\/Object;\"\n+        };\n+\n+*\/\n+\n+        Object result = instance.invokeMethodReference(\"some string to search\", 's', 'o');\n+        String expected = \"oome otring to oearch\";\n+        if (!result.equals(expected)) {\n+            throw new RuntimeException(\"Expected \\\"\" + expected + \"\\\" but got \\\"\" +\n+                                       result + \"\\\"\");\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/LambdaInvokeVirtual.java","additions":108,"deletions":0,"binary":false,"changes":108,"status":"added"}]}