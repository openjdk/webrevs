{"files":[{"patch":"@@ -32,0 +32,1 @@\n+import jdk.test.lib.Asserts;\n@@ -66,2 +67,2 @@\n-            var j = Config.getInstance().getAll(\"section\", \"x\");\n-            var r = read(\"f\", new ArrayList<String>())\n+            var j = Config.getInstance().getAll(\"section\", \"sub\", \"x\");\n+            var r = readRaw(\"f\", new ArrayList<String>())\n@@ -70,5 +71,1 @@\n-            if (!j.equals(r)) {\n-                System.out.println(j);\n-                System.out.println(r);\n-                throw new RuntimeException(\"Different\");\n-            }\n+            Asserts.assertEQ(r, j);\n@@ -76,1 +73,1 @@\n-        try (var dir = Files.newDirectoryStream(Path.of(\".\"))) {\n+        try (var dir = Files.newDirectoryStream(Path.of(\".\"), \"f*\")) {\n@@ -84,1 +81,1 @@\n-    static List<String> read(String f, List<String> list) throws IOException {\n+    static List<String> readRaw(String f, List<String> list) throws IOException {\n@@ -87,1 +84,1 @@\n-                read(s.substring(8), list);\n+                readRaw(s.substring(8), list);\n@@ -89,2 +86,2 @@\n-            if (s.startsWith(\"x = \")) {\n-                list.add(s.substring(4));\n+            if (s.contains(\"x = \")) {\n+                list.add(s.substring(s.indexOf(\"x = \") + 4));\n@@ -99,1 +96,2 @@\n-        if (Files.exists(p)) return;\n+        if (Files.exists(p)) return;    \/\/ do not overwrite, same file can be\n+                                        \/\/ included twice\n@@ -101,1 +99,1 @@\n-        content.add(\"[section]\");\n+        content.add(\"[section]\");       \/\/ always starts with section\n@@ -103,3 +101,20 @@\n-            if (sr.nextBoolean()) content.add(\"[section]\");\n-            content.add(\"x = \" + sr.nextInt(99999999));\n-            nAssign++;\n+            if (sr.nextBoolean()) {     \/\/ might have more section(s)\n+                content.add(\"[section]\");\n+            }\n+            if (sr.nextBoolean()) {     \/\/ style 1: { on subsection line\n+                content.add(\"sub = {\");\n+            } else {\n+                content.add(\"sub = \");\n+                if (sr.nextBoolean()) {\n+                    content.add(\"{\");   \/\/ style 2: { on individual line\n+                } else {\n+                                        \/\/ style 3: { on key-value line\n+                    content.add(\"{ x = \" + sr.nextInt(99999999));\n+                    nAssign++;\n+                }\n+            }\n+            for (var j = 0; j < sr.nextInt(3); j++) { \/\/ might have more\n+                content.add(\"x = \" + sr.nextInt(99999999));\n+                nAssign++;\n+            }\n+            content.add(\"}\");\n@@ -107,0 +122,1 @@\n+        \/\/ randomly throw in include lines\n@@ -110,2 +126,5 @@\n-                \/\/ but name length always grows, so no recursive\n-                var inc = f + sr.nextInt(20);\n+                \/\/ but name length always grows, so no recursive.\n+                \/\/ Extra length could be 1 digit or 2 digits, so the\n+                \/\/ same file can be included on 2 levels, e.g. f1 includes\n+                \/\/ f12 and f123, and f12 includes f123 again.\n+                var inc = f + sr.nextInt(100);\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":38,"deletions":19,"binary":false,"changes":57,"status":"modified"}]}