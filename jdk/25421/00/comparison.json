{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,5 @@\n+    \/**\n+     * Maximum number of files that can be included.\n+     *\/\n+    private static final int MAX_INCLUDE_FILE = 100;\n+\n@@ -99,1 +104,6 @@\n-    \/*\n+    \/**\n+     * All lines read from all krb5 config files.\n+     *\/\n+    private Map<Path,List<String>> allConfs = new HashMap<>();\n+\n+    \/**\n@@ -205,1 +215,0 @@\n-            List<String> configFile;\n@@ -208,2 +217,2 @@\n-                configFile = loadConfigFile(fileName);\n-                stanzaTable = parseStanzaTable(configFile);\n+                Path p = loadConfigFile(fileName); \/\/ p is main entry\n+                parseStanzaTable(p);\n@@ -227,3 +236,3 @@\n-                    fileName = getNativeFileName();\n-                    configFile = loadConfigFile(fileName);\n-                    stanzaTable = parseStanzaTable(configFile);\n+                    fileName = getNativeFileName(); \/\/ p is main entry\n+                    Path p = loadConfigFile(fileName);\n+                    parseStanzaTable(p);\n@@ -567,2 +576,7 @@\n-     * Reads the lines of the configuration file. All include and includedir\n-     * directives are resolved by calling this method recursively.\n+     * Reads a configuration file. All include and includedir directives are\n+     * also read by calling this method recursively. All contents are stored\n+     * in {@link #allConfs} with file name as key.\n+     *\n+     * Comment and empty lines are removed, all lines are trimmed, include and\n+     * includedir directives are processed and translated to \"#include\" followed\n+     * by a file name (not a directory name), unknown directives are ignored.\n@@ -570,4 +584,1 @@\n-     * @param file the krb5.conf file, must be absolute\n-     * @param content the lines. Comment and empty lines are removed,\n-     *                all lines trimmed, include and includedir\n-     *                directives resolved, unknown directives ignored\n+     * @param file a krb5 config file, must be absolute\n@@ -576,0 +587,1 @@\n+     * @throws KrbException other errors\n@@ -577,3 +589,2 @@\n-    private static Void readConfigFileLines(\n-            Path file, List<String> content, Set<Path> dups)\n-            throws IOException {\n+    private void readConfigFileLines(Path file, Set<Path> dups)\n+            throws KrbException, IOException {\n@@ -584,3 +595,3 @@\n-        if (!file.isAbsolute()) {\n-            throw new IOException(\"Profile path not absolute\");\n-        }\n+\n+        \/\/ Create a new copy so that input is not modified when returned\n+        dups = new HashSet<>(dups);\n@@ -589,1 +600,11 @@\n-            throw new IOException(\"Profile path included more than once\");\n+            throw new KrbException(\"Recursive include\");\n+        }\n+        if (allConfs.size() > MAX_INCLUDE_FILE) {\n+            throw new KrbException(\"Too many include files\");\n+        }\n+        if (allConfs.containsKey(file)) {\n+            \/\/ Already parsed. This is allowed.\n+            return;\n+        }\n+        if (!file.isAbsolute()) {\n+            throw new KrbException(\"Profile path not absolute\");\n@@ -593,0 +614,1 @@\n+        List<String> content = new ArrayList<>();\n@@ -594,1 +616,4 @@\n-        boolean inDirectives = true;\n+        \/\/ Add content to map at the beginning to detect duplicates\n+        allConfs.put(file, content);\n+\n+        boolean inSections = false;\n@@ -600,17 +625,13 @@\n-            if (inDirectives) {\n-                if (line.charAt(0) == '[') {\n-                    inDirectives = false;\n-                    content.add(line);\n-                } else if (line.startsWith(\"includedir \")) {\n-                    Path dir = Paths.get(\n-                            line.substring(\"includedir \".length()).trim());\n-                    try (Stream<Path> files = Files.list(dir)) {\n-                        for (Path p: files.sorted().toList()) {\n-                            if (Files.isDirectory(p)) continue;\n-                            String name = p.getFileName().toString();\n-                            if (name.matches(\"[a-zA-Z0-9_-]+\") ||\n-                                    (!name.startsWith(\".\") &&\n-                                            name.endsWith(\".conf\"))) {\n-                                \/\/ if dir is absolute, so is p\n-                                readConfigFileLines(p, content, dups);\n-                            }\n+            if (line.startsWith(\"includedir \")) {\n+                Path dir = Paths.get(\n+                        line.substring(\"includedir \".length()).trim());\n+                try (Stream<Path> files = Files.list(dir)) {\n+                    for (Path p: files.sorted().toList()) {\n+                        if (Files.isDirectory(p)) continue;\n+                        String name = p.getFileName().toString();\n+                        if (name.matches(\"[a-zA-Z0-9_-]+\") ||\n+                                (!name.startsWith(\".\") &&\n+                                        name.endsWith(\".conf\"))) {\n+                            \/\/ if dir is absolute, so is p\n+                            readConfigFileLines(p, dups);\n+                            content.add(\"#include \" + p);\n@@ -619,9 +640,0 @@\n-                } else if (line.startsWith(\"include \")) {\n-                    readConfigFileLines(\n-                            Paths.get(line.substring(\"include \".length()).trim()),\n-                            content, dups);\n-                } else {\n-                    \/\/ Unsupported directives\n-                    if (DEBUG != null) {\n-                        DEBUG.println(\"Unknown directive: \" + line);\n-                    }\n@@ -629,0 +641,4 @@\n+            } else if (line.startsWith(\"include \")) {\n+                Path p = Paths.get(line.substring(\"include \".length()).trim());\n+                content.add(\"#include \" + p);\n+                readConfigFileLines(p, dups);\n@@ -630,1 +646,13 @@\n-                content.add(line);\n+                if (!inSections) {\n+                    if (line.charAt(0) == '[') {\n+                        inSections = true;\n+                        content.add(line);\n+                    } else {\n+                        \/\/ Unsupported directives\n+                        if (DEBUG != null) {\n+                            DEBUG.println(\"Line not in any section: \" + line);\n+                        }\n+                    }\n+                } else {\n+                    content.add(line);\n+                }\n@@ -633,1 +661,0 @@\n-        return null;\n@@ -637,1 +664,28 @@\n-     * Reads the configuration file and return normalized lines.\n+     * Reads the main configuration file.\n+     *\n+     * @param fileName the configuration file\n+     * @return absolute path to the config file\n+     *\/\n+    private Path loadConfigFile(final String fileName)\n+            throws IOException, KrbException {\n+\n+        if (DEBUG != null) {\n+            DEBUG.println(\"Loading config file from \" + fileName);\n+        }\n+        Set<Path> dupsCheck = new HashSet<>();\n+        Path fullp = Paths.get(fileName).toAbsolutePath();\n+        Path path = Paths.get(fileName);\n+        if (!Files.exists(path)) {\n+            \/\/ This is OK. There are other ways to get\n+            \/\/ Kerberos 5 settings\n+        } else {\n+            readConfigFileLines(fullp, dupsCheck);\n+        }\n+        return fullp;\n+    }\n+\n+    \/**\n+     * Normalizes strings read from one config file. All sections and\n+     * subsections are enclosed in braces. Directives (\"#include\") are\n+     * kept in the same place.\n+     *\n@@ -641,0 +695,1 @@\n+     *     includedir \/tmp\/inc\n@@ -648,1 +703,13 @@\n-     * The result will be (no indentations):\n+     * The output of readConfigFileLines will be (no indentations):\n+     *\n+     *     [realms]\n+     *     #include \/tmp\/inc\/conf1\n+     *     #include \/tmp\/inc\/conf2\n+     *     EXAMPLE.COM =\n+     *     {\n+     *         kdc = kerberos.example.com\n+     *         ...\n+     *     }\n+     *     ...\n+     *\n+     * The output of normalize will be (no indentations):\n@@ -652,0 +719,2 @@\n+     *     #include \/tmp\/inc\/conf1\n+     *     #include \/tmp\/inc\/conf2\n@@ -660,2 +729,3 @@\n-     * @param fileName the configuration file\n-     * @return normalized lines\n+     * @param raw input list of strings\n+     * @return normalized list of strings\n+     * @throws KrbException when the format is not correct\n@@ -663,6 +733,1 @@\n-    private List<String> loadConfigFile(final String fileName)\n-            throws IOException, KrbException {\n-\n-        if (DEBUG != null) {\n-            DEBUG.println(\"Loading config file from \" + fileName);\n-        }\n+    private static List<String> normalize(List<String> raw) throws KrbException {\n@@ -670,13 +735,2 @@\n-        List<String> raw = new ArrayList<>();\n-        Set<Path> dupsCheck = new HashSet<>();\n-\n-        Path fullp = Paths.get(fileName).toAbsolutePath();\n-        Path path = Paths.get(fileName);\n-        if (!Files.exists(path)) {\n-            \/\/ This is OK. There are other ways to get\n-            \/\/ Kerberos 5 settings\n-        } else {\n-            readConfigFileLines(fullp, raw, dupsCheck);\n-        }\n-\n-        String previous = null;\n+        List<String> unwritten = new ArrayList<>();\n+        String previous = null; \/\/ unfinished line\n@@ -684,1 +738,9 @@\n-            if (line.startsWith(\"[\")) {\n+            if (line.startsWith(\"#\")) { \/\/ directives like \"#include\". Do not\n+                                        \/\/ write out immediately, might follow\n+                                        \/\/ a previous line.\n+                if (previous == null) {\n+                    result.add(line);\n+                } else {\n+                    unwritten.add(line);\n+                }\n+            } else if (line.startsWith(\"[\")) {\n@@ -691,0 +753,2 @@\n+                    unwritten.forEach(result::add);\n+                    unwritten.clear();\n@@ -709,0 +773,2 @@\n+                    unwritten.forEach(result::add);\n+                    unwritten.clear();\n@@ -719,0 +785,2 @@\n+                unwritten.forEach(result::add);\n+                unwritten.clear();\n@@ -724,0 +792,2 @@\n+            unwritten.forEach(result::add);\n+            unwritten.clear();\n@@ -737,11 +807,4 @@\n-     * For top-level sections with duplicates names, their contents are merged.\n-     * For sub-sections the former overwrites the latter. For final values,\n-     * they are stored in a vector in their appearing order. Please note these\n-     * values must appear in the same sub-section. Otherwise, the sub-section\n-     * appears first should have already overridden the others.\n-     * <p>\n-     * As a corner case, if the same name is used as both a section name and a\n-     * value name, the first appearance decides the type. That is to say, if the\n-     * first one is for a section, all latter appearances are ignored. If it's\n-     * a value, latter appearances as sections are ignored, but those as values\n-     * are added to the vector.\n+     * Contents of duplicated sections are merged. Values for duplicated names\n+     * are stored in a vector in their appearing order. If the same name is used\n+     * as both a section name and a value name, the first appearance decides the\n+     * type and the latter appearances of different types are ignored.\n@@ -749,2 +812,2 @@\n-     * The behavior described above is compatible to other krb5 implementations\n-     * but it's not decumented publicly anywhere. the best practice is not to\n+     * The behavior described above is compatible to other krb5 implementations,\n+     * but it's not documented publicly anywhere. the best practice is not to\n@@ -754,1 +817,2 @@\n-     * @param v the normalized input as return by loadConfigFile\n+     * @param entry path to config file, could be an included one\n+     * @returns the parsed configuration\n@@ -758,1 +822,1 @@\n-    private Hashtable<String,Object> parseStanzaTable(List<String> v)\n+    private void parseStanzaTable(Path entry)\n@@ -761,0 +825,13 @@\n+        \/\/ Current sections and subsections\n+        Deque<Hashtable<String,Object>> stack = new ArrayDeque<>();\n+        List<String> v = allConfs.get(entry);\n+        if (v == null) {\n+            \/\/ this happens when root krb5.conf is missing\n+            return;\n+        }\n+        v = normalize(v);\n+        if (DEBUG != null) {\n+            DEBUG.println(\">>> Begin Kerberos config at \" + entry);\n+            v.forEach(DEBUG::println);\n+            DEBUG.println(\">>> End Kerberos config at \" + entry);\n+        }\n@@ -762,8 +839,10 @@\n-            if (DEBUG != null) {\n-                DEBUG.println(line);\n-            }\n-            \/\/ There are only 3 kinds of lines\n-            \/\/ 1. a = b\n-            \/\/ 2. a = {\n-            \/\/ 3. }\n-            if (line.equals(\"}\")) {\n+            \/\/ There are only 4 kinds of lines after normalization\n+            \/\/ 1. #include\n+            \/\/ 2. a = b\n+            \/\/ 3. a = {\n+            \/\/ 4. }\n+            if (line.startsWith(\"#include \")) {\n+                \/\/ parse in-place at the top level, i.e. included file\n+                \/\/ is not considered inside the current section.\n+                parseStanzaTable(Path.of(line.substring(9)));\n+            } else if (line.equals(\"}\")) {\n@@ -771,2 +850,1 @@\n-                current = (Hashtable<String,Object>)current.remove(\" PARENT \");\n-                if (current == null) {\n+                if (stack.isEmpty()) {\n@@ -775,0 +853,1 @@\n+                current = stack.pop();\n@@ -787,1 +866,0 @@\n-                    \/\/ When there are dup names for sections\n@@ -789,5 +867,6 @@\n-                        if (current == stanzaTable) {   \/\/ top-level, merge\n-                            \/\/ The value at top-level must be another Hashtable\n-                            subTable = (Hashtable<String,Object>)current.get(key);\n-                        } else {                        \/\/ otherwise, ignored\n-                            \/\/ read and ignore it (do not put into current)\n+                        Object obj = current.get(key);\n+                        if (obj instanceof Hashtable) {\n+                            \/\/ dup section, merge\n+                            subTable = (Hashtable<String,Object>) obj;\n+                        } else {\n+                            \/\/ different type, parse and ignore\n@@ -800,3 +879,2 @@\n-                    \/\/ A special entry for its parent. Put whitespaces around,\n-                    \/\/ so will never be confused with a normal key\n-                    subTable.put(\" PARENT \", current);\n+                    \/\/ Remember where I am.\n+                    stack.push(current);\n@@ -805,1 +883,0 @@\n-                    Vector<String> values;\n@@ -809,3 +886,2 @@\n-                            \/\/ String values are merged\n-                            values = (Vector<String>)obj;\n-                            values.add(value);\n+                            \/\/ dup value, accumulate\n+                            ((Vector<String>) obj).add(value);\n@@ -813,2 +889,1 @@\n-                            \/\/ If a key shows as section first and then a value,\n-                            \/\/ ignore the value.\n+                            \/\/ different type, ignore\n@@ -817,1 +892,1 @@\n-                        values = new Vector<String>();\n+                        Vector<String> values = new Vector<>();\n@@ -827,1 +902,0 @@\n-        return current;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Config.java","additions":190,"deletions":116,"binary":false,"changes":306,"status":"modified"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.krb5.Config;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8356997\n+ * @summary Support \"include\" anywhere\n+ * @modules java.security.jgss\/sun.security.krb5\n+ * @library \/test\/lib\n+ * @run main\/othervm IncludeDup\n+ *\/\n+public class IncludeDup {\n+    public static void main(String[] args) throws Exception {\n+        var cwd = Path.of(\"\").toAbsolutePath().toString();\n+        Files.writeString(Path.of(\"krb5.conf\"), String.format(\"\"\"\n+                include %1$s\/outside\n+                [a]\n+                include %1$s\/beginsec\n+                b = {\n+                    c = 1\n+                }\n+                [a]\n+                b = {\n+                    c = 2\n+                }\n+                include %1$s\/insec\n+                include %1$s\/insec2\n+                b = {\n+                include %1$s\/insubsec\n+                    c = 3\n+                include %1$s\/endsubsec\n+                }\n+                include %1$s\/endsec\n+                \"\"\", cwd));\n+        for (var inc : List.of(\"outside\", \"beginsec\", \"insec\", \"insec2\",\n+                \"insubsec\", \"endsubsec\", \"endsec\")) {\n+            Files.writeString(Path.of(inc), String.format(\"\"\"\n+                    [a]\n+                    b = {\n+                        c = %s\n+                    }\n+                    \"\"\", inc));\n+        }\n+        System.setProperty(\"java.security.krb5.conf\", \"krb5.conf\");\n+        Asserts.assertEQ(Config.getInstance().getAll(\"a\", \"b\", \"c\"),\n+                \"outside beginsec 1 2 insec insec2 insubsec 3 endsubsec endsec\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeDup.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"},{"patch":"@@ -0,0 +1,120 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356997\n+ * @summary Support \"include\" anywhere\n+ * @modules java.security.jgss\/sun.security.krb5\n+ * @library \/test\/lib\n+ * @run main\/othervm IncludeRandom\n+ *\/\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.krb5.Config;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.SecureRandom;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/\/ A randomized class to prove that wherever the \"include\" line is inside\n+\/\/ a krb5.conf file, it can always be parsed correctly.\n+public class IncludeRandom {\n+\n+    static SecureRandom sr = SeededSecureRandom.one();\n+\n+    \/\/ Must be global. Counting in recursive methods\n+    static int nInc = 0; \/\/ number of included files\n+    static int nAssign = 0; \/\/ number of assignments to the same setting\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"java.security.krb5.conf\", \"f\");\n+        for (var i = 0; i < 10_000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() throws Exception {\n+        nInc = 0;\n+        nAssign = 0;\n+        write(\"f\");\n+        if (nAssign != 0) {\n+            Config.refresh();\n+            var j = Config.getInstance().getAll(\"section\", \"x\");\n+            var r = read(\"f\", new ArrayList<String>())\n+                    .stream()\n+                    .collect(Collectors.joining(\" \"));\n+            if (!j.equals(r)) {\n+                System.out.println(j);\n+                System.out.println(r);\n+                throw new RuntimeException(\"Different\");\n+            }\n+        }\n+        try (var dir = Files.newDirectoryStream(Path.of(\".\"))) {\n+            for (var f : dir) {\n+                Files.delete(f);\n+            }\n+        }\n+    }\n+\n+    \/\/ read settings as raw files\n+    static List<String> read(String f, List<String> list) throws IOException {\n+        for (var s : Files.readAllLines(Path.of(f))) {\n+            if (s.startsWith(\"include \")) {\n+                read(s.substring(8), list);\n+            }\n+            if (s.startsWith(\"x = \")) {\n+                list.add(s.substring(4));\n+            }\n+        }\n+        return list;\n+    }\n+\n+    \/\/ write krb5.conf with random include\n+    static void write(String f) throws IOException {\n+        var p = Path.of(f);\n+        if (Files.exists(p)) return;\n+        var content = new ArrayList<String>();\n+        content.add(\"[section]\");\n+        for (var i = 0; i < sr.nextInt(5); i++) {\n+            if (sr.nextBoolean()) content.add(\"[section]\");\n+            content.add(\"x = \" + sr.nextInt(99999999));\n+            nAssign++;\n+        }\n+        for (var i = 0; i < sr.nextInt(3); i++) {\n+            if (nInc < 98) {\n+                \/\/ include file name is random, so there could be dup\n+                \/\/ but name length always grows, so no recursive\n+                var inc = f + sr.nextInt(20);\n+                content.add(sr.nextInt(content.size() + 1),\n+                        \"include \" + Path.of(inc).toAbsolutePath());\n+                nInc++;\n+                write(inc);\n+            }\n+        }\n+        Files.write(p, content);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":120,"deletions":0,"binary":false,"changes":120,"status":"added"}]}