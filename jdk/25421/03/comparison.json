{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,5 @@\n+    \/**\n+     * Maximum number of files that can be included.\n+     *\/\n+    private static final int MAX_INCLUDE_FILE = 100;\n+\n@@ -99,1 +104,6 @@\n-    \/*\n+    \/**\n+     * All lines read from all krb5 config files.\n+     *\/\n+    private Map<Path,List<String>> allConfs = new HashMap<>();\n+\n+    \/**\n@@ -205,1 +215,0 @@\n-            List<String> configFile;\n@@ -208,2 +217,2 @@\n-                configFile = loadConfigFile(fileName);\n-                stanzaTable = parseStanzaTable(configFile);\n+                Path p = loadConfigFile(fileName); \/\/ p is main entry\n+                parseStanzaTable(p);\n@@ -227,3 +236,3 @@\n-                    fileName = getNativeFileName();\n-                    configFile = loadConfigFile(fileName);\n-                    stanzaTable = parseStanzaTable(configFile);\n+                    fileName = getNativeFileName(); \/\/ p is main entry\n+                    Path p = loadConfigFile(fileName);\n+                    parseStanzaTable(p);\n@@ -567,2 +576,3 @@\n-     * Reads the lines of the configuration file. All include and includedir\n-     * directives are resolved by calling this method recursively.\n+     * Reads a configuration file. All include and includedir directives are\n+     * also read by calling this method recursively. All contents are stored\n+     * in {@link #allConfs} with file name as key.\n@@ -570,4 +580,5 @@\n-     * @param file the krb5.conf file, must be absolute\n-     * @param content the lines. Comment and empty lines are removed,\n-     *                all lines trimmed, include and includedir\n-     *                directives resolved, unknown directives ignored\n+     * Comment and empty lines are removed, all lines are trimmed, include and\n+     * includedir directives are processed and translated to \"#include\" followed\n+     * by a file name (not a directory name), unknown directives are ignored.\n+     *\n+     * @param file a krb5 config file, must be absolute\n@@ -576,0 +587,1 @@\n+     * @throws KrbException other errors\n@@ -577,3 +589,2 @@\n-    private static Void readConfigFileLines(\n-            Path file, List<String> content, Set<Path> dups)\n-            throws IOException {\n+    private void readConfigFileLines(Path file, Set<Path> dups)\n+            throws KrbException, IOException {\n@@ -584,0 +595,1 @@\n+\n@@ -585,1 +597,4 @@\n-            throw new IOException(\"Profile path not absolute\");\n+            throw new KrbException(\"Profile path not absolute\");\n+        }\n+        if (allConfs.size() > MAX_INCLUDE_FILE) {\n+            throw new KrbException(\"Too many include files\");\n@@ -589,1 +604,1 @@\n-            throw new IOException(\"Profile path included more than once\");\n+            throw new KrbException(\"Recursive include\");\n@@ -592,7 +607,5 @@\n-        List<String> lines = Files.readAllLines(file);\n-\n-        boolean inDirectives = true;\n-        for (String line: lines) {\n-            line = line.trim();\n-            if (line.isEmpty() || line.startsWith(\"#\") || line.startsWith(\";\")) {\n-                continue;\n+        try {\n+            if (allConfs.containsKey(file)) {\n+                \/\/ Already parsed. Including a file multiple times is allowed.\n+                \/\/ Just make sure it cannot be recursive.\n+                return;\n@@ -600,5 +613,14 @@\n-            if (inDirectives) {\n-                if (line.charAt(0) == '[') {\n-                    inDirectives = false;\n-                    content.add(line);\n-                } else if (line.startsWith(\"includedir \")) {\n+\n+            List<String> lines = Files.readAllLines(file);\n+            List<String> content = new ArrayList<>();\n+\n+            \/\/ Add content to map at the beginning to detect duplicates\n+            allConfs.put(file, content);\n+\n+            boolean inSections = false;\n+            for (String line : lines) {\n+                line = line.trim();\n+                if (line.isEmpty() || line.startsWith(\"#\") || line.startsWith(\";\")) {\n+                    continue;\n+                }\n+                if (line.startsWith(\"includedir \")) {\n@@ -608,1 +630,1 @@\n-                        for (Path p: files.sorted().toList()) {\n+                        for (Path p : files.sorted().toList()) {\n@@ -615,1 +637,2 @@\n-                                readConfigFileLines(p, content, dups);\n+                                readConfigFileLines(p, dups);\n+                                content.add(\"#include \" + p);\n@@ -620,3 +643,3 @@\n-                    readConfigFileLines(\n-                            Paths.get(line.substring(\"include \".length()).trim()),\n-                            content, dups);\n+                    Path p = Paths.get(line.substring(\"include \".length()).trim());\n+                    content.add(\"#include \" + p);\n+                    readConfigFileLines(p, dups);\n@@ -624,3 +647,12 @@\n-                    \/\/ Unsupported directives\n-                    if (DEBUG != null) {\n-                        DEBUG.println(\"Unknown directive: \" + line);\n+                    if (!inSections) {\n+                        if (line.charAt(0) == '[') {\n+                            inSections = true;\n+                            content.add(line);\n+                        } else {\n+                            \/\/ Unsupported directives\n+                            if (DEBUG != null) {\n+                                DEBUG.println(\"Line not in any section: \" + line);\n+                            }\n+                        }\n+                    } else {\n+                        content.add(line);\n@@ -629,2 +661,0 @@\n-            } else {\n-                content.add(line);\n@@ -632,0 +662,2 @@\n+        } finally {\n+            dups.remove(file);\n@@ -633,1 +665,0 @@\n-        return null;\n@@ -637,1 +668,27 @@\n-     * Reads the configuration file and return normalized lines.\n+     * Reads the main configuration file.\n+     *\n+     * @param fileName the configuration file\n+     * @return absolute path to the config file\n+     *\/\n+    private Path loadConfigFile(final String fileName)\n+            throws IOException, KrbException {\n+\n+        if (DEBUG != null) {\n+            DEBUG.println(\"Loading config file from \" + fileName);\n+        }\n+        Set<Path> dupsCheck = new HashSet<>();\n+        Path fullp = Paths.get(fileName).toAbsolutePath();\n+        if (!Files.exists(fullp)) {\n+            \/\/ This is OK. There are other ways to get\n+            \/\/ Kerberos 5 settings\n+        } else {\n+            readConfigFileLines(fullp, dupsCheck);\n+        }\n+        return fullp;\n+    }\n+\n+    \/**\n+     * Normalizes strings read from one config file. All sections and\n+     * subsections are enclosed in braces. Directives (\"#include\") are\n+     * kept in the same place.\n+     *\n@@ -641,0 +698,1 @@\n+     *     includedir \/tmp\/inc\n@@ -648,1 +706,13 @@\n-     * The result will be (no indentations):\n+     * The output of readConfigFileLines will be (no indentations):\n+     *\n+     *     [realms]\n+     *     #include \/tmp\/inc\/conf1\n+     *     #include \/tmp\/inc\/conf2\n+     *     EXAMPLE.COM =\n+     *     {\n+     *         kdc = kerberos.example.com\n+     *         ...\n+     *     }\n+     *     ...\n+     *\n+     * The output of normalize will be (no indentations):\n@@ -652,0 +722,2 @@\n+     *     #include \/tmp\/inc\/conf1\n+     *     #include \/tmp\/inc\/conf2\n@@ -660,2 +732,3 @@\n-     * @param fileName the configuration file\n-     * @return normalized lines\n+     * @param raw input list of strings\n+     * @return normalized list of strings\n+     * @throws KrbException when the format is not correct\n@@ -663,6 +736,1 @@\n-    private List<String> loadConfigFile(final String fileName)\n-            throws IOException, KrbException {\n-\n-        if (DEBUG != null) {\n-            DEBUG.println(\"Loading config file from \" + fileName);\n-        }\n+    private static List<String> normalize(List<String> raw) throws KrbException {\n@@ -670,13 +738,2 @@\n-        List<String> raw = new ArrayList<>();\n-        Set<Path> dupsCheck = new HashSet<>();\n-\n-        Path fullp = Paths.get(fileName).toAbsolutePath();\n-        Path path = Paths.get(fileName);\n-        if (!Files.exists(path)) {\n-            \/\/ This is OK. There are other ways to get\n-            \/\/ Kerberos 5 settings\n-        } else {\n-            readConfigFileLines(fullp, raw, dupsCheck);\n-        }\n-\n-        String previous = null;\n+        List<String> unwritten = new ArrayList<>();\n+        String previous = null; \/\/ unfinished line\n@@ -684,1 +741,9 @@\n-            if (line.startsWith(\"[\")) {\n+            if (line.startsWith(\"#\")) { \/\/ directives like \"#include\". Do not\n+                                        \/\/ write out immediately, might follow\n+                                        \/\/ a previous line.\n+                if (previous == null) {\n+                    result.add(line);\n+                } else {\n+                    unwritten.add(line);\n+                }\n+            } else if (line.startsWith(\"[\")) {\n@@ -691,0 +756,2 @@\n+                    unwritten.forEach(result::add);\n+                    unwritten.clear();\n@@ -709,0 +776,2 @@\n+                    unwritten.forEach(result::add);\n+                    unwritten.clear();\n@@ -719,0 +788,2 @@\n+                unwritten.forEach(result::add);\n+                unwritten.clear();\n@@ -724,0 +795,2 @@\n+            unwritten.forEach(result::add);\n+            unwritten.clear();\n@@ -737,11 +810,4 @@\n-     * For top-level sections with duplicates names, their contents are merged.\n-     * For sub-sections the former overwrites the latter. For final values,\n-     * they are stored in a vector in their appearing order. Please note these\n-     * values must appear in the same sub-section. Otherwise, the sub-section\n-     * appears first should have already overridden the others.\n-     * <p>\n-     * As a corner case, if the same name is used as both a section name and a\n-     * value name, the first appearance decides the type. That is to say, if the\n-     * first one is for a section, all latter appearances are ignored. If it's\n-     * a value, latter appearances as sections are ignored, but those as values\n-     * are added to the vector.\n+     * Contents of duplicated sections are merged. Values for duplicated names\n+     * are stored in a vector in their appearing order. If the same name is used\n+     * as both a section name and a value name, the first appearance decides the\n+     * type and the latter appearances of different types are ignored.\n@@ -749,2 +815,2 @@\n-     * The behavior described above is compatible to other krb5 implementations\n-     * but it's not decumented publicly anywhere. the best practice is not to\n+     * The behavior described above is compatible to other krb5 implementations,\n+     * but it's not documented publicly anywhere. the best practice is not to\n@@ -754,1 +820,1 @@\n-     * @param v the normalized input as return by loadConfigFile\n+     * @param entry path to config file, could be an included one\n@@ -758,1 +824,1 @@\n-    private Hashtable<String,Object> parseStanzaTable(List<String> v)\n+    private void parseStanzaTable(Path entry)\n@@ -761,0 +827,13 @@\n+        \/\/ Current sections and subsections\n+        Deque<Hashtable<String,Object>> stack = new ArrayDeque<>();\n+        List<String> v = allConfs.get(entry);\n+        if (v == null) {\n+            \/\/ this happens when root krb5.conf is missing\n+            return;\n+        }\n+        v = normalize(v);\n+        if (DEBUG != null) {\n+            DEBUG.println(\">>> Begin Kerberos config at \" + entry);\n+            v.forEach(DEBUG::println);\n+            DEBUG.println(\">>> End Kerberos config at \" + entry);\n+        }\n@@ -762,8 +841,10 @@\n-            if (DEBUG != null) {\n-                DEBUG.println(line);\n-            }\n-            \/\/ There are only 3 kinds of lines\n-            \/\/ 1. a = b\n-            \/\/ 2. a = {\n-            \/\/ 3. }\n-            if (line.equals(\"}\")) {\n+            \/\/ There are only 4 kinds of lines after normalization\n+            \/\/ 1. #include\n+            \/\/ 2. a = b\n+            \/\/ 3. a = {\n+            \/\/ 4. }\n+            if (line.startsWith(\"#include \")) {\n+                \/\/ parse in-place at the top level, i.e. included file\n+                \/\/ is not considered inside the current section.\n+                parseStanzaTable(Path.of(line.substring(9)));\n+            } else if (line.equals(\"}\")) {\n@@ -771,2 +852,1 @@\n-                current = (Hashtable<String,Object>)current.remove(\" PARENT \");\n-                if (current == null) {\n+                if (stack.isEmpty()) {\n@@ -775,0 +855,1 @@\n+                current = stack.pop();\n@@ -787,1 +868,0 @@\n-                    \/\/ When there are dup names for sections\n@@ -789,5 +869,6 @@\n-                        if (current == stanzaTable) {   \/\/ top-level, merge\n-                            \/\/ The value at top-level must be another Hashtable\n-                            subTable = (Hashtable<String,Object>)current.get(key);\n-                        } else {                        \/\/ otherwise, ignored\n-                            \/\/ read and ignore it (do not put into current)\n+                        Object obj = current.get(key);\n+                        if (obj instanceof Hashtable) {\n+                            \/\/ dup section, merge\n+                            subTable = (Hashtable<String,Object>) obj;\n+                        } else {\n+                            \/\/ different type, parse and ignore\n@@ -800,3 +881,2 @@\n-                    \/\/ A special entry for its parent. Put whitespaces around,\n-                    \/\/ so will never be confused with a normal key\n-                    subTable.put(\" PARENT \", current);\n+                    \/\/ Remember where I am.\n+                    stack.push(current);\n@@ -805,1 +885,0 @@\n-                    Vector<String> values;\n@@ -809,3 +888,2 @@\n-                            \/\/ String values are merged\n-                            values = (Vector<String>)obj;\n-                            values.add(value);\n+                            \/\/ dup value, accumulate\n+                            ((Vector<String>) obj).add(value);\n@@ -813,2 +891,1 @@\n-                            \/\/ If a key shows as section first and then a value,\n-                            \/\/ ignore the value.\n+                            \/\/ different type, ignore\n@@ -817,1 +894,1 @@\n-                        values = new Vector<String>();\n+                        Vector<String> values = new Vector<>();\n@@ -827,1 +904,0 @@\n-        return current;\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Config.java","additions":184,"deletions":108,"binary":false,"changes":292,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.krb5.Config;\n+import sun.security.krb5.KrbException;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+\n+\/*\n+ * @test\n+ * @bug 8356997\n+ * @summary Support \"include\" anywhere\n+ * @modules java.security.jgss\/sun.security.krb5\n+ * @library \/test\/lib\n+ * @run main\/othervm DuplicatedIncludes\n+ *\/\n+public class DuplicatedIncludes {\n+    public static void main(String[] args) throws Exception {\n+\n+        var cwd = Path.of(\"\").toAbsolutePath().toString();\n+        System.setProperty(\"java.security.krb5.conf\", \"krb5.conf\");\n+\n+        \/\/ It's OK to include a file multiple times\n+        Files.writeString(Path.of(\"krb5.conf\"), String.format(\"\"\"\n+                include %1$s\/sub\n+                include %1$s\/sub\n+                \"\"\", cwd));\n+\n+        Files.writeString(Path.of(\"sub\"), \"\"\"\n+                [a]\n+                b = c\n+                \"\"\");\n+        Config.refresh();\n+\n+        \/\/ But a file cannot include itself\n+        Files.writeString(Path.of(\"sub\"), String.format(\"\"\"\n+                include %1$s\/sub\n+                \"\"\", cwd));\n+        Asserts.assertThrows(KrbException.class, () -> Config.refresh());\n+\n+        \/\/ A file also cannot include a file that includes it\n+        Files.writeString(Path.of(\"sub\"), String.format(\"\"\"\n+                include %1$s\/sub2\n+                \"\"\", cwd));\n+        Files.writeString(Path.of(\"sub2\"), String.format(\"\"\"\n+                include %1$s\/sub\n+                \"\"\", cwd));\n+        Asserts.assertThrows(KrbException.class, () -> Config.refresh());\n+\n+        \/\/ It's OK for a file to include another file that has already\n+        \/\/ been included multiple times, as long as it's not on the stack.\n+        \/\/ This proves it's necessary to place \"dups.remove(file)\" in a\n+        \/\/ finally block in Config::readConfigFileLines. This case is\n+        \/\/ not covered by IncludeRandom.java because of the structured\n+        \/\/ include pattern (included always longer than includee) there.\n+        Files.writeString(Path.of(\"krb5.conf\"), String.format(\"\"\"\n+                include %1$s\/sub\n+                include %1$s\/sub\n+                include %1$s\/sub2\n+                \"\"\", cwd));\n+        Files.writeString(Path.of(\"sub\"), \"\");\n+        Files.writeString(Path.of(\"sub2\"), String.format(\"\"\"\n+                include %1$s\/sub\n+                \"\"\", cwd));\n+        Config.refresh();\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/DuplicatedIncludes.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8356997\n+ * @summary Support \"include\" anywhere\n+ * @modules java.security.jgss\/sun.security.krb5\n+ * @library \/test\/lib\n+ * @run main\/othervm IncludeRandom\n+ *\/\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.security.SeededSecureRandom;\n+import sun.security.krb5.Config;\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.security.SecureRandom;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+\/\/ A randomized class to prove that wherever the \"include\" line is inside\n+\/\/ a krb5.conf file, it can always be parsed correctly.\n+public class IncludeRandom {\n+\n+    static SecureRandom sr = SeededSecureRandom.one();\n+\n+    \/\/ Must be global. Counting in recursive methods\n+    static int nInc = 0; \/\/ number of included files\n+    static int nAssign = 0; \/\/ number of assignments to the same setting\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"java.security.krb5.conf\", \"f\");\n+        for (var i = 0; i < 10_000; i++) {\n+            test();\n+        }\n+    }\n+\n+    static void test() throws Exception {\n+        nInc = 0;\n+        nAssign = 0;\n+        write(\"f\");\n+        if (nAssign != 0) {\n+            Config.refresh();\n+            var j = Config.getInstance().getAll(\"section\", \"sub\", \"x\");\n+            var r = readRaw(\"f\", new ArrayList<String>())\n+                    .stream()\n+                    .collect(Collectors.joining(\" \"));\n+            Asserts.assertEQ(r, j);\n+        }\n+        try (var dir = Files.newDirectoryStream(Path.of(\".\"), \"f*\")) {\n+            for (var f : dir) {\n+                Files.delete(f);\n+            }\n+        }\n+    }\n+\n+    \/\/ read settings as raw files\n+    static List<String> readRaw(String f, List<String> list) throws IOException {\n+        for (var s : Files.readAllLines(Path.of(f))) {\n+            if (s.startsWith(\"include \")) {\n+                readRaw(s.substring(8), list);\n+            }\n+            if (s.contains(\"x = \")) {\n+                list.add(s.substring(s.indexOf(\"x = \") + 4));\n+            }\n+        }\n+        return list;\n+    }\n+\n+    \/\/ write krb5.conf with random include\n+    static void write(String f) throws IOException {\n+        var p = Path.of(f);\n+        if (Files.exists(p)) return;    \/\/ do not overwrite, same file can be\n+                                        \/\/ included twice\n+        var content = new ArrayList<String>();\n+        content.add(\"[section]\");       \/\/ always starts with section\n+        for (var i = 0; i < sr.nextInt(5); i++) {\n+            if (sr.nextBoolean()) {     \/\/ might have more section(s)\n+                content.add(\"[section]\");\n+            }\n+            if (sr.nextBoolean()) {     \/\/ style 1: { on subsection line\n+                content.add(\"sub = {\");\n+            } else {\n+                content.add(\"sub = \");\n+                if (sr.nextBoolean()) {\n+                    content.add(\"{\");   \/\/ style 2: { on individual line\n+                } else {\n+                                        \/\/ style 3: { on key-value line\n+                    content.add(\"{ x = \" + sr.nextInt(99999999));\n+                    nAssign++;\n+                }\n+            }\n+            for (var j = 0; j < sr.nextInt(3); j++) { \/\/ might have more\n+                content.add(\"x = \" + sr.nextInt(99999999));\n+                nAssign++;\n+            }\n+            content.add(\"}\");\n+        }\n+        \/\/ randomly throw in include lines\n+        for (var i = 0; i < sr.nextInt(3); i++) {\n+            if (nInc < 98) {\n+                \/\/ include file name is random, so there could be dup\n+                \/\/ but name length always grows, so no recursive.\n+                \/\/ Extra length could be 1 digit or 2 digits, so the\n+                \/\/ same file can be included on 2 levels, e.g. f1 includes\n+                \/\/ f12 and f123, and f12 includes f123 again.\n+                var inc = f + sr.nextInt(100);\n+                content.add(sr.nextInt(content.size() + 1),\n+                        \"include \" + Path.of(inc).toAbsolutePath());\n+                nInc++;\n+                write(inc);\n+            }\n+        }\n+        Files.write(p, content);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeRandom.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,75 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import jdk.test.lib.Asserts;\n+import sun.security.krb5.Config;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+\n+\/*\n+ * @test\n+ * @bug 8356997\n+ * @summary Support \"include\" anywhere\n+ * @modules java.security.jgss\/sun.security.krb5\n+ * @library \/test\/lib\n+ * @run main\/othervm IncludeSameKey\n+ *\/\n+public class IncludeSameKey {\n+    public static void main(String[] args) throws Exception {\n+        var cwd = Path.of(\"\").toAbsolutePath().toString();\n+        Files.writeString(Path.of(\"krb5.conf\"), String.format(\"\"\"\n+                include %1$s\/outside\n+                [a]\n+                include %1$s\/beginsec\n+                b = {\n+                    c = 1\n+                }\n+                [a]\n+                b = {\n+                    c = 2\n+                }\n+                include %1$s\/insec\n+                include %1$s\/insec2\n+                b = {\n+                include %1$s\/insubsec\n+                    c = 3\n+                include %1$s\/endsubsec\n+                }\n+                include %1$s\/endsec\n+                \"\"\", cwd));\n+        for (var inc : List.of(\"outside\", \"beginsec\", \"insec\", \"insec2\",\n+                \"insubsec\", \"endsubsec\", \"endsec\")) {\n+            Files.writeString(Path.of(inc), String.format(\"\"\"\n+                    [a]\n+                    b = {\n+                        c = %s\n+                    }\n+                    \"\"\", inc));\n+        }\n+        System.setProperty(\"java.security.krb5.conf\", \"krb5.conf\");\n+        Asserts.assertEQ(Config.getInstance().getAll(\"a\", \"b\", \"c\"),\n+                \"outside beginsec 1 2 insec insec2 insubsec 3 endsubsec endsec\");\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/krb5\/config\/IncludeSameKey.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"added"}]}