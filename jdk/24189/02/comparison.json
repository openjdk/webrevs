{"files":[{"patch":"@@ -270,1 +270,0 @@\n-    size = MAX2((size_t)1, size);         \/\/ malloc(0)\n@@ -290,1 +289,0 @@\n-    new_size = MAX2((size_t)1, new_size); \/\/ realloc(.., 0)\n","filename":"src\/hotspot\/share\/nmt\/nmtPreInit.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -624,5 +624,6 @@\n-void* os::malloc(size_t size, MemTag mem_tag) {\n-  return os::malloc(size, mem_tag, CALLER_PC);\n-}\n-\n-void* os::malloc(size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n+\/\/ Use pre-init if too early for NMT and check for size overflow and if we are still under MallocLimit\n+size_t os::pre_init_and_check_size(void** raw_ptr, void* old_ptr, size_t size, MemTag mem_tag) {\n+  \/\/ On malloc(0), implementations of malloc(3) have the choice to return either\n+  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n+  \/\/ we chose the latter.\n+  size = MAX2((size_t)1, size);\n@@ -631,2 +632,2 @@\n-  void* rc = nullptr;\n-  if (NMTPreInit::handle_malloc(&rc, size)) {\n+  *raw_ptr = nullptr;\n+  if (NMTPreInit::handle_realloc(raw_ptr, old_ptr, size, mem_tag)) {\n@@ -635,1 +636,1 @@\n-    return rc;\n+    return size;\n@@ -640,5 +641,0 @@\n-  \/\/ On malloc(0), implementations of malloc(3) have the choice to return either\n-  \/\/ null or a unique non-null pointer. To unify libc behavior across our platforms\n-  \/\/ we chose the latter.\n-  size = MAX2((size_t)1, size);\n-\n@@ -646,2 +642,2 @@\n-  if (MemTracker::check_exceeds_limit(size, mem_tag)) {\n-    return nullptr;\n+  if ((old_ptr == nullptr) && MemTracker::check_exceeds_limit(size, mem_tag)) {\n+    return 0;\n@@ -651,1 +647,0 @@\n-\n@@ -654,0 +649,40 @@\n+    return 0;\n+  }\n+\n+  return outer_size;\n+}\n+\n+\/\/ Record the allocated pointer with NMT and clear bits as needed\n+void* os::record_and_clear_bits(void* raw_ptr, size_t size, size_t old_size, MemTag mem_tag, const NativeCallStack& stack) {\n+  \/\/ Register alloc with NMT\n+  void* const client_ptr = MemTracker::record_malloc((address)raw_ptr, size, mem_tag, stack);\n+\n+  \/\/ Clear bits\n+  if (old_size == 0) {\n+    if (CDSConfig::is_dumping_static_archive()) {\n+      \/\/ Need to deterministically fill all the alignment gaps in C++ structures.\n+      ::memset((char*)client_ptr, 0, size);\n+    } else {\n+      DEBUG_ONLY(::memset((char*)client_ptr, uninitBlockPad, size);)\n+    }\n+  } else if (old_size < size) {\n+    DEBUG_ONLY(::memset((char*)client_ptr + old_size, uninitBlockPad, size - old_size);)\n+  }\n+\n+  DEBUG_ONLY(break_if_ptr_caught(client_ptr);)\n+  return client_ptr;\n+}\n+\n+void* os::malloc(size_t size, MemTag mem_tag) {\n+  return os::malloc(size, mem_tag, CALLER_PC);\n+}\n+\n+void* os::malloc(size_t size, MemTag mem_tag, const NativeCallStack& stack) {\n+\n+  void* ptr = nullptr;\n+  void* old_ptr = nullptr;\n+  size_t outer_size = os::pre_init_and_check_size(&ptr, old_ptr, size, mem_tag);\n+  if (ptr != nullptr) {\n+    return ptr;\n+  }\n+  if (outer_size == 0) {\n@@ -661,11 +696,2 @@\n-\n-  void* const inner_ptr = MemTracker::record_malloc((address)outer_ptr, size, mem_tag, stack);\n-\n-  if (CDSConfig::is_dumping_static_archive()) {\n-    \/\/ Need to deterministically fill all the alignment gaps in C++ structures.\n-    ::memset(inner_ptr, 0, size);\n-  } else {\n-    DEBUG_ONLY(::memset(inner_ptr, uninitBlockPad, size);)\n-  }\n-  DEBUG_ONLY(break_if_ptr_caught(inner_ptr);)\n-  return inner_ptr;\n+ \n+  return record_and_clear_bits(outer_ptr, size, 0, mem_tag, stack);\n@@ -680,6 +706,0 @@\n-  \/\/ Special handling for NMT preinit phase before arguments are parsed\n-  void* rc = nullptr;\n-  if (NMTPreInit::handle_realloc(&rc, memblock, size, mem_tag)) {\n-    return rc;\n-  }\n-\n@@ -690,3 +710,1 @@\n-  DEBUG_ONLY(check_crash_protection());\n-\n-  \/\/ On realloc(p, 0), implementers of realloc(3) have the choice to return either\n+  \/\/ On malloc(0), implementations of malloc(3) have the choice to return either\n@@ -697,0 +715,9 @@\n+  void* ptr = nullptr;\n+  size_t outer_size = os::pre_init_and_check_size(&ptr, memblock, size, mem_tag);\n+  if (ptr != nullptr) {\n+    return ptr;\n+  }\n+  if (outer_size == 0) {\n+    return nullptr;\n+  }\n+\n@@ -700,7 +727,0 @@\n-    const size_t new_outer_size = size + MemTracker::overhead_per_malloc();\n-\n-    \/\/ Handle size overflow.\n-    if (new_outer_size < size) {\n-      return nullptr;\n-    }\n-\n@@ -708,1 +728,0 @@\n-\n@@ -724,3 +743,2 @@\n-    ALLOW_C_FUNCTION(::realloc, void* const new_outer_ptr = ::realloc(header, new_outer_size);)\n-\n-    if (new_outer_ptr == nullptr) {\n+    ALLOW_C_FUNCTION(::realloc, void* const outer_ptr = ::realloc(header, outer_size);)\n+    if (outer_ptr == nullptr) {\n@@ -732,0 +750,1 @@\n+\n@@ -735,4 +754,0 @@\n-    \/\/ After a successful realloc(3), we account the resized block with its new size\n-    \/\/ to NMT.\n-    void* const new_inner_ptr = MemTracker::record_malloc(new_outer_ptr, size, mem_tag, stack);\n-\n@@ -741,4 +756,0 @@\n-    if (old_size < size) {\n-      \/\/ We also zap the newly extended region.\n-      ::memset((char*)new_inner_ptr + old_size, uninitBlockPad, size - old_size);\n-    }\n@@ -747,2 +758,1 @@\n-    rc = new_inner_ptr;\n-\n+    ptr = record_and_clear_bits(outer_ptr, size, old_size, mem_tag, stack);\n@@ -750,1 +760,0 @@\n-\n@@ -752,2 +761,2 @@\n-    ALLOW_C_FUNCTION(::realloc, rc = ::realloc(memblock, size);)\n-    if (rc == nullptr) {\n+    ALLOW_C_FUNCTION(::realloc, ptr = ::realloc(memblock, size);)\n+    if (ptr == nullptr) {\n@@ -756,1 +765,1 @@\n-\n+    DEBUG_ONLY(break_if_ptr_caught(ptr);)\n@@ -759,3 +768,1 @@\n-  DEBUG_ONLY(break_if_ptr_caught(rc);)\n-\n-  return rc;\n+  return ptr;\n@@ -764,1 +771,1 @@\n-void  os::free(void *memblock) {\n+void os::free(void *memblock) {\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":72,"deletions":65,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -1088,0 +1088,5 @@\n+\n+ private:\n+  static size_t pre_init_and_check_size(void** raw_ptr, void* old_ptr, size_t size, MemTag mem_tag);\n+  static void* record_and_clear_bits(void* raw_ptr, size_t size, size_t old_size, MemTag mem_tag, const NativeCallStack& stack);\n+\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"}]}