{"files":[{"patch":"@@ -30,0 +30,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -34,0 +35,1 @@\n+#include <type_traits>\n@@ -104,1 +106,4 @@\n-template <typename E> class GrowableArrayIterator;\n+template <typename E, bool is_const = true> class GrowableArrayIterator;\n+\n+template <typename E>\n+using GrowableArrayNonConstIterator = GrowableArrayIterator<E, false>;\n@@ -192,0 +197,8 @@\n+  GrowableArrayIterator<E, false> ncbegin() {\n+    return GrowableArrayNonConstIterator<E>(this, 0);\n+  }\n+\n+  GrowableArrayIterator<E, false> ncend() {\n+    return GrowableArrayNonConstIterator<E>(this, length());\n+  }\n+\n@@ -868,1 +881,1 @@\n-template <typename E>\n+template <typename E, bool is_const>\n@@ -872,3 +885,5 @@\n- private:\n-  const GrowableArrayView<E>* _array; \/\/ GrowableArray we iterate over\n-  int _position;                      \/\/ The current position in the GrowableArray\n+private:\n+  using C = std::conditional_t<is_const, const GrowableArrayView<E>, GrowableArrayView<E>>;\n+\n+  C* _array;     \/\/ GrowableArray we iterate over\n+  int _position; \/\/ The current position in the GrowableArray\n@@ -877,1 +892,1 @@\n-  GrowableArrayIterator(const GrowableArrayView<E>* array, int position) : _array(array), _position(position) {\n+  GrowableArrayIterator(C* array, int position) : _array(array), _position(position) {\n@@ -881,4 +896,44 @@\n- public:\n-  GrowableArrayIterator() : _array(nullptr), _position(0) { }\n-  GrowableArrayIterator& operator++() { ++_position; return *this; }\n-  E operator*()                       { return _array->at(_position); }\n+public:\n+  using value_type = std::conditional_t<is_const, const E, E>;\n+  using difference_type = int;\n+  using reference = std::add_lvalue_reference_t<value_type>;\n+\n+  GrowableArrayIterator() : _array(nullptr), _position(0) {}\n+\n+  GrowableArrayIterator operator+(difference_type i) const {\n+    int new_pos = checked_cast<int>(jlong(_position) + jlong(i));\n+    return GrowableArrayIterator(_array, new_pos);\n+  }\n+\n+  GrowableArrayIterator operator-(difference_type i) const {\n+    assert(i != min_jint, \"invalid operand\");\n+    return *this + (-i);\n+  }\n+\n+  GrowableArrayIterator& operator++() {\n+    assert(_position < _array->length(), \"illegal position\");\n+    ++_position;\n+    return *this;\n+  }\n+\n+  GrowableArrayIterator operator++(int) {\n+    GrowableArrayIterator old = *this;\n+    ++(*this);\n+    return old;\n+  }\n+\n+  GrowableArrayIterator& operator--() {\n+    assert(_position > 0, \"illegal position\");\n+    --_position;\n+    return *this;\n+  }\n+\n+  GrowableArrayIterator operator--(int) {\n+    GrowableArrayIterator old = *this;\n+    --(*this);\n+    return old;\n+  }\n+\n+  reference operator*() const {\n+    return _array->at(_position);\n+  }\n@@ -886,1 +941,1 @@\n-  bool operator==(const GrowableArrayIterator& rhs)  {\n+  bool operator==(const GrowableArrayIterator& rhs) const {\n@@ -891,1 +946,1 @@\n-  bool operator!=(const GrowableArrayIterator& rhs)  {\n+  bool operator!=(const GrowableArrayIterator& rhs) const {\n@@ -895,0 +950,10 @@\n+\n+  bool operator<(const GrowableArrayIterator& rhs) const {\n+    assert(_array == rhs._array, \"iterator belongs to different array\");\n+    return _position < rhs._position;\n+  }\n+\n+  bool operator>(const GrowableArrayIterator& rhs) const {\n+    assert(_array == rhs._array, \"iterator belongs to different array\");\n+    return _position > rhs._position;\n+  }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":77,"deletions":12,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_UTILITIES_SORT_HPP\n+#define SHARE_UTILITIES_SORT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+\/\/ An insertion sort that is stable and inplace.\n+\/\/ This algorithm should be the ideal solution to sort a sequence with few elements. Arrays::sort\n+\/\/ uses insertion sort for arrays up to around 50 elements.\n+\/\/ For the requirements for the parameters, see those of std::sort.\n+class InsertionSort : AllStatic {\n+public:\n+  template <class RandomIt, class Compare>\n+  static void sort(RandomIt begin, RandomIt end, Compare comp) {\n+    if (begin == end) {\n+      \/\/ Empty array\n+      return;\n+    }\n+\n+    for (RandomIt current = begin + 1; current < end; current++) {\n+      typename RandomIt::value_type current_elem = *current;\n+\n+      \/\/ Elements in [begin, current) has already been sorted, we search backward to find a\n+      \/\/ location to insert the element at current\n+      RandomIt pos = current;\n+      while (pos > begin) {\n+        \/\/ Since the sort is stable, we must insert the current element at the first location at\n+        \/\/ which the element is not greater than the current element (note that we are traversing\n+        \/\/ backward)\n+        RandomIt prev = pos - 1;\n+        if (!comp(current_elem, *prev)) {\n+          break;\n+        }\n+\n+        pos = prev;\n+      }\n+\n+      \/\/ Shift all elements in [pos, current) up by one then move current_elem to pos\n+      if (pos < current) {\n+        for (RandomIt i = current; i > pos; i--) {\n+          *i = *(i - 1);\n+        }\n+        *pos = current_elem;\n+      }\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_SORT_HPP\n","filename":"src\/hotspot\/share\/utilities\/sort.hpp","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/growableArray.hpp\"\n+#include <utilities\/globalDefinitions.hpp>\n+#include <utilities\/sort.hpp>\n+#include \"unittest.hpp\"\n+\n+constexpr int TEST_ARRAY_SIZE = 128;\n+\n+class TwoInt {\n+public:\n+  int val;\n+  int idx;\n+\n+  TwoInt() : val(0), idx(0) {}\n+  TwoInt(int val, int idx) : val(val), idx(idx) {}\n+};\n+\n+int ARRAY0[TEST_ARRAY_SIZE];\n+TwoInt ARRAY1[TEST_ARRAY_SIZE];\n+\n+\/\/ Verify that the sort is correct, i.e. a[i] <= a[i + 1]\n+void test_insertion_sort() {\n+  for (int i = 0; i < TEST_ARRAY_SIZE; i++) {\n+    ARRAY0[i] = os::random();\n+  }\n+  GrowableArrayFromArray<int> view(ARRAY0, TEST_ARRAY_SIZE);\n+  InsertionSort::sort(view.ncbegin(), view.ncend(), [](int a, int b) {\n+    return a < b;\n+  });\n+  for (int i = 0; i < TEST_ARRAY_SIZE - 1; i++) {\n+    ASSERT_TRUE(ARRAY0[i] <= ARRAY0[i + 1]);\n+  }\n+}\n+\n+\/\/ Verify that the sort is stable. Since there are 128 elements but the keys can only take 16\n+\/\/ values, there will inevitably be a lot of elements with the same key. We then verify that if the\n+\/\/ keys of 2 elements are the same, then the element that has the smaller idx will be ordered\n+\/\/ before the one with the larger idx.\n+void test_insertion_sort_stable() {\n+  for (int i = 0; i < TEST_ARRAY_SIZE; i++) {\n+    ARRAY1[i] = TwoInt(os::random() & 15, i);\n+  }\n+  GrowableArrayFromArray<TwoInt> view(ARRAY1, TEST_ARRAY_SIZE);\n+  InsertionSort::sort(view.ncbegin(), view.ncend(), [](TwoInt a, TwoInt b) {\n+    return a.val < b.val;\n+  });\n+  for (int i = 0; i < TEST_ARRAY_SIZE - 1; i++) {\n+    TwoInt a = ARRAY1[i];\n+    TwoInt b = ARRAY1[i + 1];\n+    ASSERT_TRUE(a.val <= b.val);\n+    if (a.val == b.val) {\n+      ASSERT_TRUE(a.idx < b.idx);\n+    }\n+  }\n+}\n+\n+TEST(utilities, insertion_sort) {\n+  for (int i = 0; i < 100; i++) {\n+    test_insertion_sort();\n+    test_insertion_sort_stable();\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_sort.cpp","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"}]}