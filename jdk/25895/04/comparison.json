{"files":[{"patch":"@@ -0,0 +1,72 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#ifndef SHARE_UTILITIES_SORT_HPP\n+#define SHARE_UTILITIES_SORT_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+\n+\/\/ An insertion sort that is stable and inplace.\n+\/\/ This algorithm should be the ideal solution to sort a sequence with few elements. Arrays::sort\n+\/\/ uses insertion sort for arrays up to around 50 elements.\n+\/\/ comp should return a value > 0 iff the first argument is larger than the second argument. A full\n+\/\/ comparison function satisfies this requirement but a simple a > b ? 1 : 0 also satisfies it.\n+class InsertionSort : AllStatic {\n+public:\n+  template <class T, class Compare>\n+  static void sort(T* data, int size, Compare comp) {\n+    if (size == 0) {\n+      return;\n+    }\n+\n+    T* begin = data;\n+    T* end = data + size;\n+    for (T* current = begin + 1; current < end; current++) {\n+      T current_elem = *current;\n+\n+      \/\/ Elements in [begin, current) has already been sorted, we search backward to find a\n+      \/\/ location to insert the element at current. In the meantime, shift all elements on the way\n+      \/\/ up by 1.\n+      T* pos = current;\n+      while (pos > begin) {\n+        \/\/ Since the sort is stable, we must insert the current element at the first location at\n+        \/\/ which the element is not greater than the current element (note that we are traversing\n+        \/\/ backward)\n+        T* prev = pos - 1;\n+        if (comp(*prev, current_elem) <= 0) {\n+          break;\n+        }\n+\n+        *pos = *prev;\n+        pos = prev;\n+      }\n+\n+      \/\/ Shift all elements in [pos, current) up by one then move current_elem to pos\n+      if (pos < current) {\n+        *pos = current_elem;\n+      }\n+    }\n+  }\n+};\n+\n+#endif \/\/ SHARE_UTILITIES_SORT_HPP\n","filename":"src\/hotspot\/share\/utilities\/sort.hpp","additions":72,"deletions":0,"binary":false,"changes":72,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/powerOfTwo.hpp\"\n+#include \"utilities\/sort.hpp\"\n+#include \"unittest.hpp\"\n+\n+constexpr int TEST_ARRAY_SIZE = 128;\n+\n+class TwoInt {\n+public:\n+  int val;\n+  int idx;\n+\n+  TwoInt() : val(0), idx(0) {}\n+  TwoInt(int val, int idx) : val(val), idx(idx) {}\n+};\n+\n+int ARRAY0[TEST_ARRAY_SIZE];\n+TwoInt ARRAY1[TEST_ARRAY_SIZE];\n+\n+\/\/ Verify that the sort is correct, i.e. a[i] <= a[i + 1]\n+void test_insertion_sort(int size) {\n+  assert(size <= TEST_ARRAY_SIZE, \"invalid parameter\");\n+  for (int i = 0; i < size; i++) {\n+    ARRAY0[i] = os::random();\n+  }\n+  InsertionSort::sort(ARRAY0, size, [](int a, int b) {\n+    return a > b ? 1 : 0;\n+  });\n+  for (int i = 0; i < size - 1; i++) {\n+    ASSERT_TRUE(ARRAY0[i] <= ARRAY0[i + 1]);\n+  }\n+}\n+\n+\/\/ Verify that the sort is stable. Since there are 128 elements but the keys can only take 16\n+\/\/ values, there will inevitably be a lot of elements with the same key. We then verify that if the\n+\/\/ keys of 2 elements are the same, then the element that has the smaller idx will be ordered\n+\/\/ before the one with the larger idx.\n+void test_insertion_sort_stable(int size, int key_bound) {\n+  assert(size <= TEST_ARRAY_SIZE, \"invalid parameter\");\n+  assert(is_power_of_2(key_bound), \"invalid parameter\");\n+  for (int i = 0; i < size; i++) {\n+    ARRAY1[i] = TwoInt(os::random() & (key_bound - 1), i);\n+  }\n+  InsertionSort::sort(ARRAY1, size, [](TwoInt a, TwoInt b) {\n+    return a.val > b.val ? 1 : 0;\n+  });\n+  for (int i = 0; i < size - 1; i++) {\n+    TwoInt a = ARRAY1[i];\n+    TwoInt b = ARRAY1[i + 1];\n+    ASSERT_TRUE(a.val <= b.val);\n+    if (a.val == b.val) {\n+      ASSERT_TRUE(a.idx < b.idx);\n+    }\n+  }\n+}\n+\n+TEST(utilities, insertion_sort) {\n+  for (int i = 0; i < 100; i++) {\n+    test_insertion_sort(0);\n+    test_insertion_sort(1);\n+    test_insertion_sort(2);\n+    test_insertion_sort(10);\n+    test_insertion_sort(TEST_ARRAY_SIZE);\n+    test_insertion_sort_stable(1, 1);\n+    test_insertion_sort_stable(2, 1);\n+    test_insertion_sort_stable(3, 2);\n+    test_insertion_sort_stable(10, 4);\n+    test_insertion_sort_stable(TEST_ARRAY_SIZE, 16);\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_sort.cpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"}]}