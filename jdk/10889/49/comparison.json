{"files":[{"patch":"@@ -1824,0 +1824,36 @@\n+\n+    \/**\n+     * Used by StringConcatHelper via JLA. Adds the current builder count to the\n+     * accumulation of items being concatenated. If the coder for the builder is\n+     * UTF16 then upgrade the whole concatenation to UTF16.\n+     *\n+     * @param lengthCoder running accumulation of length and coder\n+     *\n+     * @return updated accumulation of length and coder\n+     *\/\n+    long mix(long lengthCoder) {\n+        return (lengthCoder + count) | ((long)coder << 32);\n+    }\n+\n+    \/**\n+     * Used by StringConcatHelper via JLA. Adds the characters in the builder value to the\n+     * concatenation buffer and then updates the running accumulation of length.\n+     *\n+     * @param lengthCoder running accumulation of length and coder\n+     * @param buffer      concatenation buffer\n+     *\n+     * @return running accumulation of length and coder minus the number of characters added\n+     *\/\n+    long prepend(long lengthCoder, byte[] buffer) {\n+        lengthCoder -= count;\n+\n+        if (lengthCoder < ((long)UTF16 << 32)) {\n+            System.arraycopy(value, 0, buffer, (int)lengthCoder, count);\n+        } else if (coder == LATIN1) {\n+            StringUTF16.inflate(value, 0, buffer, (int)lengthCoder, count);\n+        } else {\n+            System.arraycopy(value, 0, buffer, (int)lengthCoder << 1, count << 1);\n+        }\n+\n+        return lengthCoder;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/AbstractStringBuilder.java","additions":36,"deletions":0,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.util.FormatConcatItem;\n@@ -46,0 +48,9 @@\n+    \/**\n+     * Return the coder for the character.\n+     * @param value character\n+     * @return      coder\n+     *\/\n+    static long coder(char value) {\n+        return StringLatin1.canEncode(value) ? LATIN1 : UTF16;\n+    }\n+\n@@ -79,1 +90,1 @@\n-        return checkOverflow(lengthCoder + 1) | (StringLatin1.canEncode(value) ? 0 : UTF16);\n+        return checkOverflow(lengthCoder + 1) | coder(value);\n@@ -119,0 +130,15 @@\n+    \/**\n+     * Mix value length and coder into current length and coder.\n+     * @param lengthCoder String length with coder packed into higher bits\n+     *                    the upper word.\n+     * @param value       value to mix in\n+     * @return            new length and coder\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long mix(long lengthCoder, FormatConcatItem value) {\n+        lengthCoder = value.mix(lengthCoder);\n+\n+        return checkOverflow(lengthCoder);\n+    }\n+\n@@ -322,0 +348,41 @@\n+    \/**\n+     * Prepends the stringly representation of FormatConcatItem value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      String value to encode\n+     * @return           updated index (coder value retained)\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    private static long prepend(long indexCoder, byte[] buf,\n+                                FormatConcatItem value) {\n+        try {\n+            return value.prepend(indexCoder, buf);\n+        } catch (Throwable ex) {\n+            throw new AssertionError(\"FormatConcatItem prepend error\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param indexCoder final char index in the buffer, along with coder packed\n+     *                   into higher bits.\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index (coder value retained)\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static long prepend(long indexCoder, byte[] buf,\n+                        FormatConcatItem value, String prefix) {\n+        indexCoder = prepend(indexCoder, buf, value);\n+        if (prefix != null) indexCoder = prepend(indexCoder, buf, prefix);\n+        return indexCoder;\n+    }\n+\n@@ -335,1 +402,2 @@\n-            throw new InternalError(\"Storage is not completely initialized, \" + (int)indexCoder + \" bytes left\");\n+            throw new InternalError(\"Storage is not completely initialized, \" +\n+                    (int)indexCoder + \" bytes left\");\n@@ -452,0 +520,65 @@\n+    \/*\n+     * Initialize after phase1.\n+     *\/\n+    static class LateInit {\n+        static final MethodHandle GETCHAR_LATIN1_MH;\n+\n+        static final MethodHandle GETCHAR_UTF16_MH;\n+\n+        static final MethodHandle PUTCHAR_LATIN1_MH;\n+\n+        static final MethodHandle PUTCHAR_UTF16_MH;\n+\n+        static {\n+            MethodType getCharMT =\n+                MethodType.methodType(char.class,\n+                        byte[].class, int.class);\n+            MethodType putCharMT =\n+                MethodType.methodType(void.class,\n+                        byte[].class, int.class, int.class);\n+            GETCHAR_LATIN1_MH = lookupStatic(\"getCharLatin1\", getCharMT);\n+            GETCHAR_UTF16_MH = lookupStatic(\"getCharUTF16\", getCharMT);\n+            PUTCHAR_LATIN1_MH = lookupStatic(\"putCharLatin1\", putCharMT);\n+            PUTCHAR_UTF16_MH = lookupStatic(\"putCharUTF16\", putCharMT);\n+        }\n+\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static char getCharLatin1(byte[] buffer, int index) {\n+        return (char)buffer[index];\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static char getCharUTF16(byte[] buffer, int index) {\n+        return StringUTF16.getChar(buffer, index);\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static void putCharLatin1(byte[] buffer, int index, int ch) {\n+        buffer[index] = (byte)ch;\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static void putCharUTF16(byte[] buffer, int index, int ch) {\n+        StringUTF16.putChar(buffer, index, ch);\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static MethodHandle selectGetChar(long indexCoder) {\n+        return indexCoder < UTF16 ? LateInit.GETCHAR_LATIN1_MH :\n+                                    LateInit.GETCHAR_UTF16_MH;\n+    }\n+\n+    @ForceInline\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    static MethodHandle selectPutChar(long indexCoder) {\n+        return indexCoder < UTF16 ? LateInit.PUTCHAR_LATIN1_MH :\n+                                    LateInit.PUTCHAR_UTF16_MH;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":135,"deletions":2,"binary":false,"changes":137,"status":"modified"},{"patch":"@@ -0,0 +1,613 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.FormatProcessor;\n+import java.util.function.Function;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * {@link StringTemplate} is the run-time representation of a string template or\n+ * text block template in a template expression.\n+ * <p>\n+ * In the source code of a Java program, a string template or text block template\n+ * contains an interleaved succession of <em>fragment literals<\/em> and <em>embedded\n+ * expressions<\/em>. The {@link StringTemplate#fragments()} method returns the\n+ * fragment literals, and the {@link StringTemplate#values()} method returns the\n+ * results of evaluating the embedded expressions. {@link StringTemplate} does not\n+ * provide access to the source code of the embedded expressions themselves; it is\n+ * not a compile-time representation of a string template or text block template.\n+ * <p>\n+ * {@link StringTemplate} is primarily used in conjunction with a template processor\n+ * to produce a string or other meaningful value. Evaluation of a template expression\n+ * first produces an instance of {@link StringTemplate}, representing the right hand side\n+ * of the template expression, and then passes the instance to the template processor\n+ * given by the template expression.\n+ * <p>\n+ * For example, the following code contains a template expression that uses the template\n+ * processor {@code RAW}, which simply yields the {@link StringTemplate} passed to it:\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+ * List<String> fragments = st.fragments();\n+ * List<Object> values = st.values();\n+ * }\n+ * {@code fragments} will be equivalent to {@code List.of(\"\", \" + \", \" = \", \"\")},\n+ * which includes the empty first and last fragments. {@code values} will be the\n+ * equivalent of {@code List.of(10, 20, 30)}.\n+ * <p>\n+ * The following code contains a template expression with the same template but with a\n+ * different template processor, {@code STR}:\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * String s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n+ * }\n+ * When the template expression is evaluated, an instance of {@link StringTemplate} is\n+ * produced that returns the same lists from {@link StringTemplate#fragments()} and\n+ * {@link StringTemplate#values()} as shown above. The {@link StringTemplate#STR} template\n+ * processor uses these lists to yield an interpolated string. The value of {@code s} will\n+ * be equivalent to {@code \"10 + 20 = 30\"}.\n+ * <p>\n+ * The {@code interpolate()} method provides a direct way to perform string interpolation\n+ * of a {@link StringTemplate}. Template processors can use the following code pattern:\n+ * {@snippet :\n+ * List<String> fragments = st.fragments();\n+ * List<Object> values    = st.values();\n+ * ... check or manipulate the fragments and\/or values ...\n+ * String result = StringTemplate.interpolate(fragments, values);\n+ * }\n+ * The {@link StringTemplate#process(Processor)} method, in conjunction with\n+ * the {@link StringTemplate#RAW} processor, may be used to defer processing of a\n+ * {@link StringTemplate}.\n+ * {@snippet :\n+ * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+ * ...other steps...\n+ * String result = st.process(STR);\n+ * }\n+ * The factory methods {@link StringTemplate#of(String)} and\n+ * {@link StringTemplate#of(List, List)} can be used to construct a {@link StringTemplate}.\n+ *\n+ * @see Processor\n+ * @see java.util.FormatProcessor\n+ *\n+ * @implNote Implementations of {@link StringTemplate} must minimally implement the\n+ * methods {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n+ * Instances of {@link StringTemplate} are considered immutable. To preserve the\n+ * semantics of string templates and text block templates, the list returned by\n+ * {@link StringTemplate#fragments()} must be one element larger than the list returned\n+ * by {@link StringTemplate#values()}.\n+ *\n+ * @since 21\n+ *\n+ * @jls 15.8.6 Process Template Expressions\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public interface StringTemplate {\n+    \/**\n+     * Returns a list of fragment literals for this {@link StringTemplate}.\n+     * The fragment literals are the character sequences preceding each of the embedded\n+     * expressions in source code, plus the character sequence following the last\n+     * embedded expression. Such character sequences may be zero-length if an embedded\n+     * expression appears at the beginning or end of a template, or if two embedded\n+     * expressions are directly adjacent in a template.\n+     * In the example: {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * List<String> fragments = st.fragments(); \/\/ @highlight substring=\"fragments()\"\n+     * }\n+     * {@code fragments} will be equivalent to\n+     * {@code List.of(\"The student \", \" is in \", \"'s classroom.\")}\n+     *\n+     * @return list of string fragments\n+     *\/\n+    List<String> fragments();\n+\n+    \/**\n+     * Returns a list of embedded expression results for this {@link StringTemplate}.\n+     * In the example:\n+     * {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * List<Object> values = st.values(); \/\/ @highlight substring=\"values()\"\n+     * }\n+     * {@code values} will be equivalent to {@code List.of(student, teacher)}\n+     *\n+     * @return list of expression values\n+     *\/\n+    List<Object> values();\n+\n+    \/**\n+     * Returns the string interpolation of the fragments and values for this\n+     * {@link StringTemplate}.\n+     * <p>\n+     * For better visibility and when practical, it is recommended to use the\n+     * {@link StringTemplate#STR} processor instead of invoking the\n+     * {@link StringTemplate#interpolate()} method.\n+     * {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * String result = st.interpolate(); \/\/ @highlight substring=\"interpolate()\"\n+     * }\n+     * In the above example, the value of  {@code result} will be\n+     * {@code \"The student Mary is in Johnson's classroom.\"}. This is\n+     * produced by the interleaving concatenation of fragments and values from the supplied\n+     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n+     * as if invoking {@link String#valueOf(Object)}.\n+     *\n+     * @return interpolation of this {@link StringTemplate}\n+     *\n+     * @implSpec The default implementation returns the result of invoking\n+     * {@code StringTemplate.interpolate(this.fragments(), this.values())}.\n+     *\/\n+    default String interpolate() {\n+        return StringTemplate.interpolate(fragments(), values());\n+    }\n+\n+    \/**\n+     * Returns the result of applying the specified processor to this {@link StringTemplate}.\n+     * This method can be used as an alternative to string template expressions. For example,\n+     * {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * String result1 = STR.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * String result2 = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\".process(STR); \/\/ @highlight substring=\"process\"\n+     * }\n+     * Produces an equivalent result for both {@code result1} and {@code result2}.\n+     *\n+     * @param processor the {@link Processor} instance to process\n+     *\n+     * @param <R>  Processor's process result type.\n+     * @param <E>  Exception thrown type.\n+     *\n+     * @return constructed object of type {@code R}\n+     *\n+     * @throws E exception thrown by the template processor when validation fails\n+     * @throws NullPointerException if processor is null\n+     *\n+     * @implSpec The default implementation returns the result of invoking\n+     * {@code processor.process(this)}. If the invocation throws an exception that\n+     * exception is forwarded to the caller.\n+     *\/\n+    default <R, E extends Throwable> R\n+    process(Processor<? extends R, ? extends E> processor) throws E {\n+        Objects.requireNonNull(processor, \"processor should not be null\");\n+\n+        return processor.process(this);\n+    }\n+\n+    \/**\n+     * Produces a diagnostic string that describes the fragments and values of the supplied\n+     * {@link StringTemplate}.\n+     *\n+     * @param stringTemplate  the {@link StringTemplate} to represent\n+     *\n+     * @return diagnostic string representing the supplied string template\n+     *\n+     * @throws NullPointerException if stringTemplate is null\n+     *\/\n+    static String toString(StringTemplate stringTemplate) {\n+        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n+        return \"StringTemplate{ fragments = [ \\\"\" +\n+                String.join(\"\\\", \\\"\", stringTemplate.fragments()) +\n+                \"\\\" ], values = \" +\n+                stringTemplate.values() +\n+                \" }\";\n+    }\n+\n+    \/**\n+     * Returns a {@link StringTemplate} as if constructed by invoking\n+     * {@code StringTemplate.of(List.of(string), List.of())}. That is, a {@link StringTemplate}\n+     * with one fragment and no values.\n+     *\n+     * @param string  single string fragment\n+     *\n+     * @return StringTemplate composed from string\n+     *\n+     * @throws NullPointerException if string is null\n+     *\/\n+    static StringTemplate of(String string) {\n+        Objects.requireNonNull(string, \"string must not be null\");\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.of(List.of(string), List.of());\n+    }\n+\n+    \/**\n+     * Returns a StringTemplate with the given fragments and values.\n+     *\n+     * @implSpec The {@code fragments} list size must be one more that the\n+     * {@code values} list size.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from string\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n+     *\n+     * @implNote Contents of both lists are copied to construct immutable lists.\n+     *\/\n+    static StringTemplate of(List<String> fragments, List<?> values) {\n+        Objects.requireNonNull(fragments, \"fragments must not be null\");\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        if (values.size() + 1 != fragments.size()) {\n+            throw new IllegalArgumentException(\n+                    \"fragments list size is not one more than values list size\");\n+        }\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.of(fragments, values);\n+    }\n+\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments. To accommodate interpolation, values are converted to strings\n+     * as if invoking {@link String#valueOf(Object)}.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n+     *\/\n+    static String interpolate(List<String> fragments, List<?> values) {\n+        Objects.requireNonNull(fragments, \"fragments must not be null\");\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        int fragmentsSize = fragments.size();\n+        int valuesSize = values.size();\n+        if (fragmentsSize != valuesSize + 1) {\n+            throw new IllegalArgumentException(\"fragments must have one more element than values\");\n+        }\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.interpolate(fragments, values);\n+    }\n+\n+    \/**\n+     * Combine zero or more {@link StringTemplate StringTemplates} into a single\n+     * {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n+     * assert st.interpolate().equals(STR.\"\\{a}\\{b}\\{c}\");\n+     * }\n+     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n+     * end with the last fragment from each {@link StringTemplate} concatenated with the\n+     * first fragment of the next. To demonstrate, if we were to take two strings and we\n+     * combined them as follows: {@snippet lang = \"java\":\n+     * String s1 = \"abc\";\n+     * String s2 = \"xyz\";\n+     * String sc = s1 + s2;\n+     * assert Objects.equals(sc, \"abcxyz\");\n+     * }\n+     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n+     * character {@code \"x\"} of the second string. The same would be true of combining\n+     * {@link StringTemplate StringTemplates}.\n+     * {@snippet lang =\"java\":\n+     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n+     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n+     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n+     * StringTemplate stc = StringTemplate.combine(st1, st2);\n+     *\n+     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n+     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n+     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * }\n+     * Values lists are simply concatenated to produce a single values list.\n+     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n+     * n is the total of number of values across all the supplied\n+     * {@link StringTemplate StringTemplates}.\n+     *\n+     * @param stringTemplates  zero or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if stringTemplates is null or if any of the\n+     * {@code stringTemplates} are null\n+     *\n+     * @implNote If zero {@link StringTemplate} arguments are provided then a\n+     * {@link StringTemplate} with an empty fragment and no values is returned, as if invoking\n+     * <code>StringTemplate.of(\"\")<\/code> . If only one {@link StringTemplate} argument is provided\n+     * then it is returned unchanged.\n+     *\/\n+    static StringTemplate combine(StringTemplate... stringTemplates) {\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.combine(stringTemplates);\n+    }\n+\n+    \/**\n+     * Combine a list of {@link StringTemplate StringTemplates} into a single\n+     * {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(List.of(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\"));\n+     * assert st.interpolate().equals(STR.\"\\{a}\\{b}\\{c}\");\n+     * }\n+     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n+     * end with the last fragment from each {@link StringTemplate} concatenated with the\n+     * first fragment of the next. To demonstrate, if we were to take two strings and we\n+     * combined them as follows: {@snippet lang = \"java\":\n+     * String s1 = \"abc\";\n+     * String s2 = \"xyz\";\n+     * String sc = s1 + s2;\n+     * assert Objects.equals(sc, \"abcxyz\");\n+     * }\n+     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n+     * character {@code \"x\"} of the second string. The same would be true of combining\n+     * {@link StringTemplate StringTemplates}.\n+     * {@snippet lang =\"java\":\n+     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n+     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n+     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n+     * StringTemplate stc = StringTemplate.combine(st1, st2);\n+     *\n+     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n+     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n+     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * }\n+     * Values lists are simply concatenated to produce a single values list.\n+     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n+     * n is the total of number of values across all the supplied\n+     * {@link StringTemplate StringTemplates}.\n+     *\n+     * @param stringTemplates  list of {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if stringTemplates is null or if any of the\n+     * its elements are null\n+     *\n+     * @implNote If {@code stringTemplates.size() == 0} then a {@link StringTemplate} with\n+     * an empty fragment and no values is returned, as if invoking\n+     * <code>StringTemplate.of(\"\")<\/code> . If {@code stringTemplates.size() == 1}\n+     * then the first element of the list is returned unchanged.\n+     *\/\n+    static StringTemplate combine(List<StringTemplate> stringTemplates) {\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.combine(stringTemplates.toArray(new StringTemplate[0]));\n+    }\n+\n+    \/**\n+     * This {@link Processor} instance is conventionally used for the string interpolation\n+     * of a supplied {@link StringTemplate}.\n+     * <p>\n+     * For better visibility and when practical, it is recommended that users use the\n+     * {@link StringTemplate#STR} processor instead of invoking the\n+     * {@link StringTemplate#interpolate()} method.\n+     * Example: {@snippet :\n+     * int x = 10;\n+     * int y = 20;\n+     * String result = STR.\"\\{x} + \\{y} = \\{x + y}\"; \/\/ @highlight substring=\"STR\"\n+     * }\n+     * In the above example, the value of {@code result} will be {@code \"10 + 20 = 30\"}. This is\n+     * produced by the interleaving concatenation of fragments and values from the supplied\n+     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n+     * as if invoking {@link String#valueOf(Object)}.\n+     * @implNote {@link StringTemplate#STR} is statically imported implicitly into every\n+     * Java compilation unit.<p>The result of interpolation is not interned.\n+     *\/\n+    Processor<String, RuntimeException> STR = StringTemplate::interpolate;\n+\n+    \/**\n+     * This {@link Processor} instance is conventionally used to indicate that the\n+     * processing of the {@link StringTemplate} is to be deferred to a later time. Deferred\n+     * processing can be resumed by invoking the\n+     * {@link StringTemplate#process(Processor)} or\n+     * {@link Processor#process(StringTemplate)} methods.\n+     * {@snippet :\n+     * import static java.lang.StringTemplate.RAW;\n+     * ...\n+     * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+     * ...other steps...\n+     * String result = STR.process(st);\n+     * }\n+     * @implNote Unlike {@link StringTemplate#STR}, {@link StringTemplate#RAW} must be\n+     * statically imported explicitly.\n+     *\/\n+    Processor<StringTemplate, RuntimeException> RAW = st -> st;\n+\n+    \/**\n+     * This interface describes the methods provided by a generalized string template processor. The\n+     * primary method {@link Processor#process(StringTemplate)} is used to validate\n+     * and compose a result using a {@link StringTemplate StringTemplate's} fragments and values lists.\n+     * <p>\n+     * For example:\n+     * {@snippet :\n+     * class MyProcessor implements Processor<String, IllegalArgumentException> {\n+     *     @Override\n+     *     public String process(StringTemplate st) throws IllegalArgumentException {\n+     *          StringBuilder sb = new StringBuilder();\n+     *          Iterator<String> fragmentsIter = st.fragments().iterator();\n+     *\n+     *          for (Object value : st.values()) {\n+     *              sb.append(fragmentsIter.next());\n+     *\n+     *              if (value instanceof Boolean) {\n+     *                  throw new IllegalArgumentException(\"I don't like Booleans\");\n+     *              }\n+     *\n+     *              sb.append(value);\n+     *          }\n+     *\n+     *          sb.append(fragmentsIter.next());\n+     *\n+     *          return sb.toString();\n+     *     }\n+     * }\n+     *\n+     * MyProcessor myProcessor = new MyProcessor();\n+     * try {\n+     *     int x = 10;\n+     *     int y = 20;\n+     *     String result = myProcessor.\"\\{x} + \\{y} = \\{x + y}\";\n+     *     ...\n+     * } catch (IllegalArgumentException ex) {\n+     *     ...\n+     * }\n+     * }\n+     * Implementations of this interface may provide, but are not limited to, validating\n+     * inputs, composing inputs into a result, and transforming an intermediate string\n+     * result to a non-string value before delivering the final result.\n+     * <p>\n+     * The user has the option of validating inputs used in composition. For example an SQL\n+     * processor could prevent injection vulnerabilities by sanitizing inputs or throwing an\n+     * exception of type {@code E} if an SQL statement is a potential vulnerability.\n+     * <p>\n+     * Composing allows user control over how the result is assembled. Most often, a\n+     * user will construct a new string from the string template, with placeholders\n+     * replaced by string representations of value list elements. These string\n+     * representations are created as if invoking {@link String#valueOf}.\n+     * <p>\n+     * Transforming allows the processor to return something other than a string. For\n+     * instance, a JSON processor could return a JSON object, by parsing the string created\n+     * by composition, instead of the composed string.\n+     * <p>\n+     * {@link Processor} is a {@link FunctionalInterface}. This permits\n+     * declaration of a processor using lambda expressions;\n+     * {@snippet :\n+     * Processor<String, RuntimeException> processor = st -> {\n+     *     List<String> fragments = st.fragments();\n+     *     List<Object> values = st.values();\n+     *     \/\/ check or manipulate the fragments and\/or values\n+     *     ...\n+     *     return StringTemplate.interpolate(fragments, values);\n+     * };\n+     * }\n+     * The {@link StringTemplate#interpolate()} method is available for those processors\n+     * that just need to work with the string interpolation;\n+     * {@snippet :\n+     * Processor<String, RuntimeException> processor = StringTemplate::interpolate;\n+     * }\n+     * or simply transform the string interpolation into something other than\n+     * {@link String};\n+     * {@snippet :\n+     * Processor<JSONObject, RuntimeException> jsonProcessor = st -> new JSONObject(st.interpolate());\n+     * }\n+     * @implNote The Java compiler automatically imports {@link StringTemplate#STR}\n+     *\n+     * @param <R>  Processor's process result type\n+     * @param <E>  Exception thrown type\n+     *\n+     * @see StringTemplate\n+     * @see java.util.FormatProcessor\n+     *\n+     * @since 21\n+     *\n+     * @jls 15.8.6 Process Template Expressions\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    @FunctionalInterface\n+    public interface Processor<R, E extends Throwable> {\n+\n+        \/**\n+         * Constructs a result based on the template fragments and values in the\n+         * supplied {@link StringTemplate stringTemplate} object.\n+         *\n+         * @param stringTemplate  a {@link StringTemplate} instance\n+         *\n+         * @return constructed object of type R\n+         *\n+         * @throws E exception thrown by the template processor when validation fails\n+         *\/\n+        R process(StringTemplate stringTemplate) throws E;\n+\n+        \/**\n+         * This factory method can be used to create a {@link Processor} containing a\n+         * {@link Processor#process} method derived from a lambda expression. As an example;\n+         * {@snippet :\n+         * Processor<String, RuntimeException> mySTR = Processor.of(StringTemplate::interpolate);\n+         * int x = 10;\n+         * int y = 20;\n+         * String str = mySTR.\"\\{x} + \\{y} = \\{x + y}\";\n+         * }\n+         * The result type of the constructed {@link Processor} may be derived from\n+         * the lambda expression, thus this method may be used in a var\n+         * statement. For example, {@code mySTR} from above can also be declared using;\n+         * {@snippet :\n+         * var mySTR = Processor.of(StringTemplate::interpolate);\n+         * }\n+         * {@link RuntimeException} is the assumed exception thrown type.\n+         *\n+         * @param process a function that takes a {@link StringTemplate} as an argument\n+         *                and returns the inferred result type\n+         *\n+         * @return a {@link Processor}\n+         *\n+         * @param <R>  Processor's process result type\n+         * @param <E>  Exception thrown type\n+         *\/\n+        static <R, E extends Throwable> Processor<R, E> of(Function<StringTemplate, R> process) {\n+            return process::apply;\n+        }\n+\n+        \/**\n+         * Built-in policies using this additional interface have the flexibility to\n+         * specialize the composition of the templated string by returning a customized\n+         * {@link MethodHandle} from {@link Linkage#linkage linkage}.\n+         * These specializations are typically implemented to improve performance;\n+         * specializing value types or avoiding boxing and vararg arrays.\n+         *\n+         * @implNote This interface is sealed to only allow standard processors.\n+         *\n+         * @since 21\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+        public sealed interface Linkage permits FormatProcessor {\n+            \/**\n+             * This method creates a {@link MethodHandle} that when invoked with arguments of\n+             * those specified in {@code type} returns a result that equals that returned by\n+             * the template processor's process method. The difference being that this method\n+             * can preview the template's fragments and value types in advance of usage and\n+             * thereby has the opportunity to produce a specialized implementation.\n+             *\n+             * @param fragments  string template fragments\n+             * @param type       method type, includes the StringTemplate receiver as\n+             * well as the value types\n+             *\n+             * @return {@link MethodHandle} for the processor applied to template\n+             *\n+             * @throws NullPointerException if any of the arguments are null\n+             *\/\n+            MethodHandle linkage(List<String> fragments, MethodType type);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringTemplate.java","additions":613,"deletions":0,"binary":false,"changes":613,"status":"added"},{"patch":"@@ -80,1 +80,1 @@\n-import jdk.internal.misc.VM;\n+import jdk.internal.javac.PreviewFeature;\n@@ -84,0 +84,1 @@\n+import jdk.internal.misc.VM;\n@@ -2524,0 +2525,17 @@\n+            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+            public long stringConcatCoder(char value) {\n+                return StringConcatHelper.coder(value);\n+            }\n+\n+            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+            public long stringBuilderConcatMix(long lengthCoder,\n+                                               StringBuilder sb) {\n+                return sb.mix(lengthCoder);\n+            }\n+\n+            @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+            public long stringBuilderConcatPrepend(long lengthCoder, byte[] buf,\n+                                                   StringBuilder sb) {\n+                return sb.prepend(lengthCoder, buf);\n+            }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.util.FormatConcatItem;\n@@ -34,0 +36,3 @@\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n@@ -113,0 +118,2 @@\n+     *\n+     * @since 21\n@@ -114,1 +121,2 @@\n-    private static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    public static final int MAX_INDY_CONCAT_ARG_SLOTS = 200;\n@@ -324,0 +332,1 @@\n+        Objects.requireNonNull(recipe, \"Recipe is null\");\n@@ -491,3 +500,1 @@\n-            if (cl == byte.class || cl == short.class) {\n-                ptypes[i] = int.class;\n-            }\n+            ptypes[i] = promoteToIntType(ptypes[i]);\n@@ -498,1 +505,1 @@\n-            else if (cl == Object.class) {\n+            if (cl == Object.class) {\n@@ -667,1 +674,0 @@\n-\n@@ -713,0 +719,3 @@\n+            if (idx == STRING_CONCAT_ITEM) {\n+                cl = FormatConcatItem.class;\n+            }\n@@ -725,1 +734,2 @@\n-            TYPE_COUNT = 5;\n+            STRING_CONCAT_ITEM = 5,\n+            TYPE_COUNT = 6;\n@@ -727,5 +737,6 @@\n-        if (cl == String.class)  return STRING_IDX;\n-        if (cl == int.class)     return INT_IDX;\n-        if (cl == boolean.class) return BOOLEAN_IDX;\n-        if (cl == char.class)    return CHAR_IDX;\n-        if (cl == long.class)    return LONG_IDX;\n+        if (cl == String.class)                          return STRING_IDX;\n+        if (cl == int.class)                             return INT_IDX;\n+        if (cl == boolean.class)                         return BOOLEAN_IDX;\n+        if (cl == char.class)                            return CHAR_IDX;\n+        if (cl == long.class)                            return LONG_IDX;\n+        if (FormatConcatItem.class.isAssignableFrom(cl)) return STRING_CONCAT_ITEM;\n@@ -989,0 +1000,27 @@\n+    \/**\n+     * Promote integral types to int.\n+     *\/\n+    private static Class<?> promoteToIntType(Class<?> t) {\n+        \/\/ use int for subword integral types; still need special mixers\n+        \/\/ and prependers for char, boolean\n+        return t == byte.class || t == short.class ? int.class : t;\n+    }\n+\n+    \/**\n+     * Returns a stringifier for references and floats\/doubles only.\n+     * Always returns null for other primitives.\n+     *\n+     * @param t class to stringify\n+     * @return stringifier; null, if not available\n+     *\/\n+    private static MethodHandle stringifierFor(Class<?> t) {\n+        if (t == Object.class) {\n+            return objectStringifier();\n+        } else if (t == float.class) {\n+            return floatStringifier();\n+        } else if (t == double.class) {\n+            return doubleStringifier();\n+        }\n+        return null;\n+    }\n+\n@@ -1001,0 +1039,297 @@\n+\n+    \/**\n+     * Simplified concatenation method to facilitate {@link StringTemplate}\n+     * concatenation. This method returns a single concatenation method that\n+     * interleaves fragments and values. fragment|value|fragment|value|...|value|fragment.\n+     * The number of fragments must be one more that the number of ptypes.\n+     * The total number of slots used by the ptypes must be less than or equal\n+     * to {@value #MAX_INDY_CONCAT_ARG_SLOTS}.\n+     *\n+     * @param fragments list of string fragments\n+     * @param ptypes    list of expression types\n+     *\n+     * @return the {@link MethodHandle} for concatenation\n+     *\n+     * @throws StringConcatException If any of the linkage invariants are violated.\n+     * @throws NullPointerException If any of the incoming arguments is null.\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    public static MethodHandle makeConcatWithTemplate(\n+            List<String> fragments,\n+            List<Class<?>> ptypes)\n+            throws StringConcatException\n+    {\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+        Objects.requireNonNull(ptypes, \"ptypes is null\");\n+        ptypes = List.copyOf(ptypes);\n+\n+        if (fragments.size() != ptypes.size() + 1) {\n+            throw new IllegalArgumentException(\"fragments size not equal ptypes size plus one\");\n+        }\n+\n+        if (ptypes.isEmpty()) {\n+            return MethodHandles.constant(String.class, fragments.get(0));\n+        }\n+\n+        Class<?>[] ttypes = new Class<?>[ptypes.size()];\n+        MethodHandle[] filters = new MethodHandle[ptypes.size()];\n+        int slots = 0;\n+\n+        int pos = 0;\n+        for (Class<?> ptype : ptypes) {\n+            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n+\n+            if (MAX_INDY_CONCAT_ARG_SLOTS < slots) {\n+                throw new StringConcatException(\"Too many concat argument slots: \" +\n+                        slots + \", can only accept \" + MAX_INDY_CONCAT_ARG_SLOTS);\n+            }\n+\n+            boolean isSpecialized = ptype.isPrimitive();\n+            boolean isFormatConcatItem = FormatConcatItem.class.isAssignableFrom(ptype);\n+            Class<?> ttype = isSpecialized ? promoteToIntType(ptype) :\n+                             isFormatConcatItem ? FormatConcatItem.class : Object.class;\n+            MethodHandle filter = isFormatConcatItem ? null : stringifierFor(ttype);\n+\n+            if (filter != null) {\n+                filters[pos] = filter;\n+                ttype = String.class;\n+            }\n+\n+            ttypes[pos++] = ttype;\n+        }\n+\n+        MethodHandle mh = MethodHandles.dropArguments(newString(), 2, ttypes);\n+\n+        long initialLengthCoder = INITIAL_CODER;\n+        String lastFragment = \"\";\n+        pos = 0;\n+        for (String fragment : fragments) {\n+            lastFragment = fragment;\n+\n+            if (ttypes.length <= pos) {\n+                break;\n+            }\n+\n+            Class<?> ttype = ttypes[pos];\n+            \/\/ (long,byte[],ttype) -> long\n+            MethodHandle prepender = prepender(lastFragment.isEmpty() ? null : fragment, ttype);\n+            initialLengthCoder = JLA.stringConcatMix(initialLengthCoder, fragment);\n+            \/\/ (byte[],long,ttypes...) -> String (unchanged)\n+            mh = MethodHandles.filterArgumentsWithCombiner(mh, 1, prepender,1, 0, 2 + pos);\n+\n+            pos++;\n+        }\n+\n+        MethodHandle newArrayCombinator = lastFragment.isEmpty() ? newArray() :\n+                newArrayWithSuffix(lastFragment);\n+        \/\/ (long,ttypes...) -> String\n+        mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, newArrayCombinator,\n+                1 \/\/ index\n+        );\n+\n+        pos = 0;\n+        for (Class<?> ttype : ttypes) {\n+            \/\/ (long,ttype) -> long\n+            MethodHandle mix = mixer(ttypes[pos]);\n+            boolean lastPType = pos == ttypes.length - 1;\n+\n+            if (lastPType) {\n+                \/\/ (ttype) -> long\n+                mix = MethodHandles.insertArguments(mix, 0, initialLengthCoder);\n+                \/\/ (ttypes...) -> String\n+                mh = MethodHandles.foldArgumentsWithCombiner(mh, 0, mix,\n+                        1 + pos \/\/ selected argument\n+                );\n+            } else {\n+                \/\/ (long,ttypes...) -> String\n+                mh = MethodHandles.filterArgumentsWithCombiner(mh, 0, mix,\n+                        0, \/\/ old-index\n+                        1 + pos \/\/ selected argument\n+                );\n+            }\n+\n+            pos++;\n+        }\n+\n+        mh = MethodHandles.filterArguments(mh, 0, filters);\n+        MethodType mt = MethodType.methodType(String.class, ptypes);\n+        mh = mh.viewAsType(mt, true);\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * This method breaks up large concatenations into separate\n+     * {@link MethodHandle MethodHandles} based on the number of slots required\n+     * per {@link MethodHandle}. Each {@link MethodHandle} after the first will\n+     * have an extra {@link String} slot for the result from the previous\n+     * {@link MethodHandle}.\n+     * {@link #makeConcatWithTemplate}\n+     * is used to construct the {@link MethodHandle MethodHandles}. The total\n+     * number of slots used by the ptypes is open ended. However, care must\n+     * be given when combining the {@link MethodHandle MethodHandles} so that\n+     * the combine total does not exceed the 255 slot limit.\n+     *\n+     * @param fragments list of string fragments\n+     * @param ptypes    list of expression types\n+     * @param maxSlots  maximum number of slots per {@link MethodHandle}.\n+     *\n+     * @return List of {@link MethodHandle MethodHandles}\n+     *\n+     * @throws IllegalArgumentException If maxSlots is not between 1 and\n+     *                                  MAX_INDY_CONCAT_ARG_SLOTS.\n+     * @throws StringConcatException If any of the linkage invariants are violated.\n+     * @throws NullPointerException If any of the incoming arguments is null.\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    public static List<MethodHandle> makeConcatWithTemplateCluster(\n+            List<String> fragments,\n+            List<Class<?>> ptypes,\n+            int maxSlots)\n+            throws StringConcatException\n+    {\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+        Objects.requireNonNull(ptypes, \"ptypes is null\");\n+\n+        if (fragments.size() != ptypes.size() + 1) {\n+            throw new StringConcatException(\"fragments size not equal ptypes size plus one\");\n+        }\n+\n+        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n+            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n+                    MAX_INDY_CONCAT_ARG_SLOTS);\n+\n+        }\n+\n+        if (ptypes.isEmpty()) {\n+            return List.of(MethodHandles.constant(String.class, fragments.get(0)));\n+        }\n+\n+        List<MethodHandle> mhs = new ArrayList<>();\n+        List<String> fragmentsSection = new ArrayList<>();\n+        List<Class<?>> ptypeSection = new ArrayList<>();\n+        int slots = 0;\n+\n+        int pos = 0;\n+        for (Class<?> ptype : ptypes) {\n+            boolean lastPType = pos == ptypes.size() - 1;\n+            fragmentsSection.add(fragments.get(pos));\n+            ptypeSection.add(ptype);\n+\n+            slots += ptype == long.class || ptype == double.class ? 2 : 1;\n+\n+            if (maxSlots <= slots || lastPType) {\n+                fragmentsSection.add(lastPType ? fragments.get(pos + 1) : \"\");\n+                MethodHandle mh = makeConcatWithTemplate(fragmentsSection,\n+                        ptypeSection);\n+                mhs.add(mh);\n+                fragmentsSection.clear();\n+                fragmentsSection.add(\"\");\n+                ptypeSection.clear();\n+                ptypeSection.add(String.class);\n+                slots = 1;\n+            }\n+\n+            pos++;\n+        }\n+\n+        return mhs;\n+    }\n+\n+    \/**\n+     * This method creates a {@link MethodHandle} expecting one input, the\n+     * receiver of the supplied getters. This method uses\n+     * {@link #makeConcatWithTemplateCluster}\n+     * to create the intermediate {@link MethodHandle MethodHandles}.\n+     *\n+     * @param fragments list of string fragments\n+     * @param getters   list of getter {@link MethodHandle MethodHandles}\n+     * @param maxSlots  maximum number of slots per {@link MethodHandle} in\n+     *                  cluster.\n+     *\n+     * @return the {@link MethodHandle} for concatenation\n+     *\n+     * @throws IllegalArgumentException If maxSlots is not between 1 and\n+     *                                  MAX_INDY_CONCAT_ARG_SLOTS or if the\n+     *                                  getters don't use the same argument type\n+     * @throws StringConcatException If any of the linkage invariants are violated\n+     * @throws NullPointerException If any of the incoming arguments is null\n+     *\n+     * @since 21\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    public static MethodHandle makeConcatWithTemplateGetters(\n+            List<String> fragments,\n+            List<MethodHandle> getters,\n+            int maxSlots)\n+            throws StringConcatException\n+    {\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+        Objects.requireNonNull(getters, \"getters is null\");\n+\n+        if (fragments.size() != getters.size() + 1) {\n+            throw new StringConcatException(\"fragments size not equal getters size plus one\");\n+        }\n+\n+        if (maxSlots < 1 || MAX_INDY_CONCAT_ARG_SLOTS < maxSlots) {\n+            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n+                    MAX_INDY_CONCAT_ARG_SLOTS);\n+\n+        }\n+\n+        if (getters.size() == 0) {\n+            throw new StringConcatException(\"no getters supplied\");\n+        }\n+\n+        Class<?> receiverType = null;\n+        List<Class<?>> ptypes = new ArrayList<>();\n+\n+        for (MethodHandle getter : getters) {\n+            MethodType mt = getter.type();\n+            Class<?> returnType = mt.returnType();\n+\n+            if (returnType == void.class || mt.parameterCount() != 1) {\n+                throw new StringConcatException(\"not a getter \" + mt);\n+            }\n+\n+            if (receiverType == null) {\n+                receiverType = mt.parameterType(0);\n+            } else if (receiverType != mt.parameterType(0)) {\n+                throw new StringConcatException(\"not the same receiever type \" +\n+                        mt + \" needs \" + receiverType);\n+            }\n+\n+            ptypes.add(returnType);\n+        }\n+\n+        MethodType resultType = MethodType.methodType(String.class, receiverType);\n+        List<MethodHandle> clusters = makeConcatWithTemplateCluster(fragments, ptypes,\n+                maxSlots);\n+\n+        MethodHandle mh = null;\n+        Iterator<MethodHandle> getterIterator = getters.iterator();\n+\n+        for (MethodHandle cluster : clusters) {\n+            MethodType mt = cluster.type();\n+            MethodHandle[] filters = new MethodHandle[mt.parameterCount()];\n+            int pos = 0;\n+\n+            if (mh != null) {\n+                filters[pos++] = mh;\n+            }\n+\n+            while (pos < filters.length) {\n+                filters[pos++] = getterIterator.next();\n+            }\n+\n+            cluster = MethodHandles.filterArguments(cluster, 0, filters);\n+            mh = MethodHandles.permuteArguments(cluster, resultType,\n+                    new int[filters.length]);\n+        }\n+\n+        return mh;\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":347,"deletions":12,"binary":false,"changes":359,"status":"modified"},{"patch":"@@ -0,0 +1,1005 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.misc.Unsafe;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * A <em>carrier<\/em> is an opaque object that can be used to store component values\n+ * while avoiding primitive boxing associated with collection objects. Component values\n+ * can be primitive or Object.\n+ * <p>\n+ * Clients can create new carrier instances by describing a carrier <em>shape<\/em>, that\n+ * is, a {@linkplain MethodType method type} whose parameter types describe the types of\n+ * the carrier component values, or by providing the parameter types directly.\n+ *\n+ * {@snippet :\n+ * \/\/ Create a carrier for a string and an integer\n+ * CarrierElements elements = CarrierFactory.of(String.class, int.class);\n+ * \/\/ Fetch the carrier constructor MethodHandle\n+ * MethodHandle initializingConstructor = elements.initializingConstructor();\n+ * \/\/ Fetch the list of carrier component MethodHandles\n+ * List<MethodHandle> components = elements.components();\n+ *\n+ * \/\/ Create an instance of the carrier with a string and an integer\n+ * Object carrier = initializingConstructor.invokeExact(\"abc\", 10);\n+ * \/\/ Extract the first component, type string\n+ * String string = (String)components.get(0).invokeExact(carrier);\n+ * \/\/ Extract the second component, type int\n+ * int i = (int)components.get(1).invokeExact(carrier);\n+ * }\n+ *\n+ * Alternatively, the client can use static methods when the carrier use is scattered.\n+ * This is possible since {@link Carriers} ensures that the same underlying carrier\n+ * class is used when the same component types are provided.\n+ *\n+ * {@snippet :\n+ * \/\/ Describe carrier using a MethodType\n+ * MethodType mt = MethodType.methodType(Object.class, String.class, int.class);\n+ * \/\/ Fetch the carrier constructor MethodHandle\n+ * MethodHandle constructor = Carriers.constructor(mt);\n+ * \/\/ Fetch the list of carrier component MethodHandles\n+ * List<MethodHandle> components = Carriers.components(mt);\n+ * }\n+ *\n+ * @implNote The strategy for storing components is deliberately left unspecified\n+ * so that future improvements will not be hampered by issues of backward compatibility.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class Carriers {\n+    \/**\n+     * Maximum number of components in a carrier (based on the maximum\n+     * number of args to a constructor.)\n+     *\/\n+    public static final int MAX_COMPONENTS = 255 - \/* this *\/ 1;\n+\n+    \/**\n+     * Number of integer slots used by a long.\n+     *\/\n+    static final int LONG_SLOTS = Long.SIZE \/ Integer.SIZE;\n+\n+    \/*\n+     * Initialize {@link MethodHandle} constants.\n+     *\/\n+    static {\n+        try {\n+            Lookup lookup = MethodHandles.lookup();\n+            FLOAT_TO_INT = lookup.findStatic(Float.class, \"floatToRawIntBits\",\n+                    methodType(int.class, float.class));\n+            INT_TO_FLOAT = lookup.findStatic(Float.class, \"intBitsToFloat\",\n+                    methodType(float.class, int.class));\n+            DOUBLE_TO_LONG = lookup.findStatic(Double.class, \"doubleToRawLongBits\",\n+                    methodType(long.class, double.class));\n+            LONG_TO_DOUBLE = lookup.findStatic(Double.class, \"longBitsToDouble\",\n+                    methodType(double.class, long.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"carrier static init fail\", ex);\n+        }\n+    }\n+\n+    \/*\n+     * float\/double conversions.\n+     *\/\n+    private static final MethodHandle FLOAT_TO_INT;\n+    private static final MethodHandle INT_TO_FLOAT;\n+    private static final MethodHandle DOUBLE_TO_LONG;\n+    private static final MethodHandle LONG_TO_DOUBLE;\n+\n+    \/**\n+     * Given an initializer {@link MethodHandle} recast and reorder arguments to\n+     * match shape.\n+     *\n+     * @param carrierShape  carrier shape\n+     * @param initializer   carrier constructor to reshape\n+     *\n+     * @return constructor with arguments recasted and reordered\n+     *\/\n+    static MethodHandle reshapeInitializer(CarrierShape carrierShape,\n+                                           MethodHandle initializer) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        int objectIndex = carrierShape.objectOffset() + 1;\n+        int intIndex = carrierShape.intOffset() + 1;\n+        int longIndex = carrierShape.longOffset() + 1;\n+        int[] reorder = new int[count + 1];\n+        Class<?>[] permutePTypes = new Class<?>[count + 1];\n+        MethodHandle[] filters = new MethodHandle[count + 1];\n+        boolean hasFilters = false;\n+        permutePTypes[0] = CarrierObject.class;\n+        reorder[0] = 0;\n+        int index = 1;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle filter = null;\n+            int from;\n+\n+            if (!ptype.isPrimitive()) {\n+                from = objectIndex++;\n+                ptype = Object.class;\n+            } else if (ptype == double.class) {\n+                from = longIndex++;\n+                filter = DOUBLE_TO_LONG;\n+            } else if (ptype == float.class) {\n+                from = intIndex++;\n+                filter = FLOAT_TO_INT;\n+            } else if (ptype == long.class) {\n+                from = longIndex++;\n+            } else {\n+                from = intIndex++;\n+                ptype = int.class;\n+            }\n+\n+            permutePTypes[index] = ptype;\n+            reorder[from] = index++;\n+\n+            if (filter != null) {\n+                filters[from] = filter;\n+                hasFilters = true;\n+            }\n+        }\n+\n+        if (hasFilters) {\n+            initializer = MethodHandles.filterArguments(initializer, 0, filters);\n+        }\n+\n+        MethodType permutedMethodType =\n+                methodType(initializer.type().returnType(), permutePTypes);\n+        initializer = MethodHandles.permuteArguments(initializer,\n+                permutedMethodType, reorder);\n+        initializer = MethodHandles.explicitCastArguments(initializer,\n+                methodType(CarrierObject.class, ptypes).insertParameterTypes(0, CarrierObject.class));\n+\n+        return initializer;\n+    }\n+\n+    \/**\n+     * Given components array, recast and reorder components to match shape.\n+     *\n+     * @param carrierShape  carrier reshape\n+     * @param components    carrier components to reshape\n+     *\n+     * @return list of components reshaped\n+     *\/\n+    static List<MethodHandle> reshapeComponents(CarrierShape carrierShape,\n+                                                MethodHandle[] components) {\n+        int count = carrierShape.count();\n+        Class<?>[] ptypes = carrierShape.ptypes();\n+        MethodHandle[] reorder = new MethodHandle[count];\n+        int objectIndex = carrierShape.objectOffset();\n+        int intIndex = carrierShape.intOffset();\n+        int longIndex = carrierShape.longOffset();\n+        int index = 0;\n+\n+        for (Class<?> ptype : ptypes) {\n+            MethodHandle component;\n+\n+            if (!ptype.isPrimitive()) {\n+                component = components[objectIndex++];\n+            } else if (ptype == double.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[longIndex++], LONG_TO_DOUBLE);\n+            } else if (ptype == float.class) {\n+                component = MethodHandles.filterReturnValue(\n+                        components[intIndex++], INT_TO_FLOAT);\n+            } else if (ptype == long.class) {\n+                component = components[longIndex++];\n+            } else {\n+                component = components[intIndex++];\n+            }\n+\n+            MethodType methodType = methodType(ptype, CarrierObject.class);\n+            reorder[index++] =\n+                    MethodHandles.explicitCastArguments(component, methodType);\n+        }\n+\n+        return List.of(reorder);\n+    }\n+\n+    \/**\n+     * Factory for carriers that are backed by long[] and Object[].\n+     *\/\n+    static final class CarrierObjectFactory {\n+        \/**\n+         * Unsafe access.\n+         *\/\n+        private static final Unsafe UNSAFE;\n+\n+        \/*\n+         * Constructor accessor MethodHandles.\n+         *\/\n+        private static final MethodHandle CONSTRUCTOR;\n+        private static final MethodHandle GET_LONG;\n+        private static final MethodHandle PUT_LONG;\n+        private static final MethodHandle GET_INTEGER;\n+        private static final MethodHandle PUT_INTEGER;\n+        private static final MethodHandle GET_OBJECT;\n+        private static final MethodHandle PUT_OBJECT;\n+\n+        static {\n+            try {\n+                UNSAFE = Unsafe.getUnsafe();\n+                Lookup lookup = MethodHandles.lookup();\n+                CONSTRUCTOR = lookup.findConstructor(CarrierObject.class,\n+                        methodType(void.class, int.class, int.class));\n+                GET_LONG = lookup.findVirtual(CarrierObject.class, \"getLong\",\n+                        methodType(long.class, int.class));\n+                PUT_LONG = lookup.findVirtual(CarrierObject.class, \"putLong\",\n+                        methodType(CarrierObject.class, int.class, long.class));\n+                GET_INTEGER = lookup.findVirtual(CarrierObject.class, \"getInteger\",\n+                        methodType(int.class, int.class));\n+                PUT_INTEGER = lookup.findVirtual(CarrierObject.class, \"putInteger\",\n+                        methodType(CarrierObject.class, int.class, int.class));\n+                GET_OBJECT = lookup.findVirtual(CarrierObject.class, \"getObject\",\n+                        methodType(Object.class, int.class));\n+                PUT_OBJECT = lookup.findVirtual(CarrierObject.class, \"putObject\",\n+                        methodType(CarrierObject.class, int.class, Object.class));\n+            } catch (ReflectiveOperationException ex) {\n+                throw new AssertionError(\"carrier static init fail\", ex);\n+            }\n+        }\n+\n+        \/**\n+         * Constructor builder.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} to generic carrier constructor.\n+         *\/\n+        MethodHandle constructor(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            int primitiveCount = carrierShape.primitiveCount();\n+\n+            MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR,\n+                    0, primitiveCount, objectCount);\n+\n+            return constructor;\n+        }\n+\n+        \/**\n+         * Adds constructor arguments for each of the allocated slots.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link MethodHandle} to specific carrier constructor.\n+         *\/\n+        MethodHandle initializer(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            MethodHandle initializer = MethodHandles.identity(CarrierObject.class);\n+\n+            \/\/ long array index\n+            int index = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_LONG, 1, index++);\n+                initializer = MethodHandles.collectArguments(put, 0, initializer);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_INTEGER, 1, index++);\n+                initializer = MethodHandles.collectArguments(put, 0, initializer);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                MethodHandle put = MethodHandles.insertArguments(PUT_OBJECT, 1, i);\n+                initializer = MethodHandles.collectArguments(put, 0, initializer);\n+            }\n+\n+            return initializer;\n+        }\n+\n+        \/**\n+         * Utility to construct the basic accessors from the components.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return array of carrier accessors\n+         *\/\n+        MethodHandle[] createComponents(CarrierShape carrierShape) {\n+            int longCount = carrierShape.longCount();\n+            int intCount = carrierShape.intCount();\n+            int objectCount = carrierShape.objectCount();\n+            MethodHandle[] components =\n+                    new MethodHandle[carrierShape.ptypes().length];\n+\n+            \/\/ long array index\n+            int index = 0;\n+            \/\/ component index\n+            int comIndex = 0;\n+            for (int i = 0; i < longCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_LONG, 1, index++);\n+            }\n+\n+            \/\/ transition to int array index (double number of longs)\n+            index *= LONG_SLOTS;\n+            for (int i = 0; i < intCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_INTEGER, 1, index++);\n+            }\n+\n+            for (int i = 0; i < objectCount; i++) {\n+                components[comIndex++] = MethodHandles.insertArguments(GET_OBJECT, 1, i);\n+            }\n+            return components;\n+        }\n+\n+        \/**\n+         * Cache mapping {@link MethodType} to previously defined {@link CarrierElements}.\n+         *\/\n+        private static Map<MethodType, CarrierElements>\n+                methodTypeCache = ReferencedKeyMap.create(ConcurrentHashMap::new);\n+\n+        \/**\n+         * Permute a raw constructor and component accessor {@link MethodHandle MethodHandles} to\n+         * match the order and types of the parameter types.\n+         *\n+         * @param carrierShape  carrier object shape\n+         *\n+         * @return {@link CarrierElements} instance\n+         *\/\n+        CarrierElements carrier(CarrierShape carrierShape) {\n+            return methodTypeCache.computeIfAbsent(carrierShape.methodType, (mt) -> {\n+                MethodHandle constructor = constructor(carrierShape);\n+                MethodHandle initializer = initializer(carrierShape);\n+                MethodHandle[] components = createComponents(carrierShape);\n+                return new CarrierElements(\n+                        carrierShape,\n+                        CarrierObject.class,\n+                        constructor,\n+                        reshapeInitializer(carrierShape, initializer),\n+                        reshapeComponents(carrierShape, components));\n+            });\n+        }\n+    }\n+\n+    \/**\n+     * Wrapper object for carrier data. Instance types are stored in the {@code objects}\n+     * array, while primitive types are recast to {@code int\/long} and stored in the\n+     * {@code primitives} array. Primitive byte, short, char, boolean and int are stored as\n+     * integers. Longs and doubles are stored as longs.  Longs take up the first part of the\n+     * primitives array using normal indices. Integers follow using int[] indices offset beyond\n+     * the longs using unsafe getInt\/putInt.\n+     *\/\n+    static class CarrierObject {\n+        \/**\n+         * Carrier for primitive values.\n+         *\/\n+        private final long[] primitives;\n+\n+        \/**\n+         * Carrier for objects;\n+         *\/\n+        private final Object[] objects;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param primitiveCount  slot count required for primitives\n+         * @param objectCount     slot count required for objects\n+         *\/\n+        protected CarrierObject(int primitiveCount, int objectCount) {\n+            this.primitives = createPrimitivesArray(primitiveCount);\n+            this.objects = createObjectsArray(objectCount);\n+        }\n+\n+        \/**\n+         * Create a primitives array of an appropriate length.\n+         *\n+         * @param primitiveCount  slot count required for primitives\n+         *\n+         * @return primitives array of an appropriate length.\n+         *\/\n+        private long[] createPrimitivesArray(int primitiveCount) {\n+            return primitiveCount != 0 ? new long[(primitiveCount + 1) \/ LONG_SLOTS] : null;\n+        }\n+\n+        \/**\n+         * Create a objects array of an appropriate length.\n+         *\n+         * @param objectCount  slot count required for objects\n+         *\n+         * @return objects array of an appropriate length.\n+         *\/\n+        private Object[] createObjectsArray(int objectCount) {\n+            return objectCount != 0 ? new Object[objectCount] : null;\n+        }\n+\n+        \/**\n+         * Compute offset for unsafe access to long.\n+         *\n+         * @param i  index in primitive[]\n+         *\n+         * @return offset for unsafe access\n+         *\/\n+        private static long offsetToLong(int i) {\n+            return Unsafe.ARRAY_LONG_BASE_OFFSET +\n+                    (long)i * Unsafe.ARRAY_LONG_INDEX_SCALE;\n+        }\n+\n+        \/**\n+         * Compute offset for unsafe access to int.\n+         *\n+         * @param i  index in primitive[]\n+         *\n+         * @return offset for unsafe access\n+         *\/\n+        private static long offsetToInt(int i) {\n+            return Unsafe.ARRAY_LONG_BASE_OFFSET +\n+                    (long)i * Unsafe.ARRAY_INT_INDEX_SCALE;\n+        }\n+\n+        \/**\n+         * Compute offset for unsafe access to object.\n+         *\n+         * @param i  index in objects[]\n+         *\n+         * @return offset for unsafe access\n+         *\/\n+        private static long offsetToObject(int i) {\n+            return Unsafe.ARRAY_OBJECT_BASE_OFFSET +\n+                    (long)i * Unsafe.ARRAY_OBJECT_INDEX_SCALE;\n+        }\n+\n+        \/**\n+         * {@return long value at index}\n+         *\n+         * @param i  array index\n+         *\/\n+        private long getLong(int i) {\n+            return CarrierObjectFactory.UNSAFE.getLong(primitives, offsetToLong(i));\n+        }\n+\n+        \/**\n+         * Put a long value into the primitive[].\n+         *\n+         * @param i      array index\n+         * @param value  long value to store\n+         *\n+         * @return this object\n+         *\/\n+        private CarrierObject putLong(int i, long value) {\n+            CarrierObjectFactory.UNSAFE.putLong(primitives, offsetToLong(i), value);\n+\n+            return this;\n+        }\n+\n+        \/**\n+         * {@return int value at index}\n+         *\n+         * @param i  array index\n+         *\/\n+        private int getInteger(int i) {\n+            return CarrierObjectFactory.UNSAFE.getInt(primitives, offsetToInt(i));\n+        }\n+\n+        \/**\n+         * Put a int value into the int[].\n+         *\n+         * @param i      array index\n+         * @param value  int value to store\n+         *\n+         * @return this object\n+         *\/\n+        private CarrierObject putInteger(int i, int value) {\n+            CarrierObjectFactory.UNSAFE.putInt(primitives, offsetToInt(i), value);\n+\n+            return this;\n+        }\n+\n+        \/**\n+         * {@return Object value at index}\n+         *\n+         * @param i  array index\n+         *\/\n+        private Object getObject(int i) {\n+            return CarrierObjectFactory.UNSAFE.getReference(objects, offsetToObject(i));\n+        }\n+\n+        \/**\n+         * Put a object value into the objects[].\n+         *\n+         * @param i      array index\n+         * @param value  object value to store\n+         *\n+         * @return this object\n+         *\/\n+        private CarrierObject putObject(int i, Object value) {\n+            CarrierObjectFactory.UNSAFE.putReference(objects, offsetToObject(i), value);\n+\n+            return this;\n+        }\n+    }\n+\n+    \/**\n+     * Class used to tally ahd track the number of ints, longs and objects.\n+     *\n+     * @param longCount    number of longs and doubles\n+     * @param intCount     number of byte, short, int, chars and booleans\n+     * @param objectCount  number of objects\n+     *\/\n+    private record CarrierCounts(int longCount, int intCount, int objectCount) {\n+        \/**\n+         * Count the number of fields required in each of Object, int and long.\n+         *\n+         * @param ptypes  parameter types\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        static CarrierCounts tally(Class<?>[] ptypes) {\n+            return tally(ptypes, ptypes.length);\n+        }\n+\n+        \/**\n+         * Count the number of fields required in each of Object, int and long\n+         * limited to the first {@code n} parameters.\n+         *\n+         * @param ptypes  parameter types\n+         * @param n       number of parameters to check\n+         *\n+         * @return a {@link CarrierCounts} instance containing counts\n+         *\/\n+        private static CarrierCounts tally(Class<?>[] ptypes, int n) {\n+            int longCount = 0;\n+            int intCount = 0;\n+            int objectCount = 0;\n+\n+            for (int i = 0; i < n; i++) {\n+                Class<?> ptype = ptypes[i];\n+\n+                if (!ptype.isPrimitive()) {\n+                    objectCount++;\n+                } else if (ptype == long.class || ptype == double.class) {\n+                    longCount++;\n+                } else {\n+                    intCount++;\n+                }\n+            }\n+\n+            return new CarrierCounts(longCount, intCount, objectCount);\n+        }\n+\n+        \/**\n+         * {@return total number of components}\n+         *\/\n+        private int count() {\n+            return longCount + intCount + objectCount;\n+        }\n+\n+        \/**\n+         * {@return total number of slots}\n+         *\/\n+        private int slotCount() {\n+            return longCount * LONG_SLOTS + intCount + objectCount;\n+        }\n+\n+    }\n+\n+    \/**\n+     * Constructor\n+     *\/\n+    private Carriers() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Shape of carrier based on counts of each of the three fundamental data\n+     * types.\n+     *\/\n+    private static class CarrierShape {\n+        \/**\n+         * {@link MethodType} providing types for the carrier's components.\n+         *\/\n+        final MethodType methodType;\n+\n+        \/**\n+         * Counts of different parameter types.\n+         *\/\n+        final CarrierCounts counts;\n+\n+        \/**\n+         * Constructor.\n+         *\n+         * @param methodType  {@link MethodType} providing types for the\n+         *                    carrier's components\n+         *\/\n+        public CarrierShape(MethodType methodType) {\n+            this.methodType = methodType;\n+            this.counts = CarrierCounts.tally(methodType.parameterArray());\n+        }\n+\n+        \/**\n+         * {@return number of long fields needed}\n+         *\/\n+        int longCount() {\n+            return counts.longCount();\n+        }\n+\n+        \/**\n+         * {@return number of int fields needed}\n+         *\/\n+        int intCount() {\n+            return counts.intCount();\n+        }\n+\n+        \/**\n+         * {@return number of object fields needed}\n+         *\/\n+        int objectCount() {\n+            return counts.objectCount();\n+        }\n+\n+        \/**\n+         * {@return slot count required for primitives}\n+         *\/\n+        int primitiveCount() {\n+            return counts.longCount() * LONG_SLOTS + counts.intCount();\n+        }\n+\n+        \/**\n+         * {@return array of parameter types}\n+         *\/\n+        Class<?>[] ptypes() {\n+            return methodType.parameterArray();\n+        }\n+\n+        \/**\n+         * {@return number of components}\n+         *\/\n+        int count() {\n+            return counts.count();\n+        }\n+\n+        \/**\n+         * {@return number of slots used}\n+         *\/\n+        int slotCount() {\n+            return counts.slotCount();\n+        }\n+\n+        \/**\n+         * {@return index of first long component}\n+         *\/\n+        int longOffset() {\n+            return 0;\n+        }\n+\n+        \/**\n+         * {@return index of first int component}\n+         *\/\n+        int intOffset() {\n+            return longCount();\n+        }\n+\n+        \/**\n+         * {@return index of first object component}\n+         *\/\n+        int objectOffset() {\n+            return longCount() + intCount();\n+        }\n+    }\n+\n+    \/**\n+     * This factory class generates {@link CarrierElements} instances containing the\n+     * {@link MethodHandle MethodHandles} to the constructor and accessors of a carrier\n+     * object.\n+     * <p>\n+     * Clients can create instances by describing a carrier <em>shape<\/em>, that\n+     * is, a {@linkplain MethodType method type} whose parameter types describe the types of\n+     * the carrier component values, or by providing the parameter types directly.\n+     *\/\n+    static final class CarrierFactory {\n+        \/**\n+         * Constructor\n+         *\/\n+        private CarrierFactory() {\n+            throw new AssertionError(\"private constructor\");\n+        }\n+\n+        private static final CarrierObjectFactory FACTORY = new CarrierObjectFactory();\n+\n+        \/**\n+         * Factory method to return a {@link CarrierElements} instance that matches the shape of\n+         * the supplied {@link MethodType}. The return type of the {@link MethodType} is ignored.\n+         *\n+         * @param methodType  {@link MethodType} whose parameter types supply the\n+         *                    the shape of the carrier's components\n+         *\n+         * @return {@link CarrierElements} instance\n+         *\n+         * @throws NullPointerException is methodType is null\n+         * @throws IllegalArgumentException if number of component slots exceeds maximum\n+         *\/\n+        static CarrierElements of(MethodType methodType) {\n+            Objects.requireNonNull(methodType, \"methodType must not be null\");\n+            MethodType constructorMT = methodType.changeReturnType(Object.class);\n+            CarrierShape carrierShape = new CarrierShape(constructorMT);\n+            int slotCount = carrierShape.slotCount();\n+\n+            if (MAX_COMPONENTS < slotCount) {\n+                throw new IllegalArgumentException(\"Exceeds maximum number of component slots\");\n+            }\n+\n+            return FACTORY.carrier(carrierShape);\n+        }\n+\n+        \/**\n+         * Factory method to return  a {@link CarrierElements} instance that matches the shape of\n+         * the supplied parameter types.\n+         *\n+         * @param ptypes   parameter types that supply the shape of the carrier's components\n+         *\n+         * @return {@link CarrierElements} instance\n+         *\n+         * @throws NullPointerException is ptypes is null\n+         * @throws IllegalArgumentException if number of component slots exceeds maximum\n+         *\/\n+        static CarrierElements of(Class<?>...ptypes) {\n+            Objects.requireNonNull(ptypes, \"ptypes must not be null\");\n+            return of(methodType(Object.class, ptypes));\n+        }\n+    }\n+\n+    \/**\n+     * Instances of this class provide the {@link MethodHandle MethodHandles} to the\n+     * constructor and accessors of a carrier object. The original component types can be\n+     * gleaned from the parameter types of the constructor {@link MethodHandle} or by the\n+     * return types of the components' {@link MethodHandle MethodHandles}.\n+     *\/\n+    static final class CarrierElements {\n+        \/**\n+         * Slot count required for objects.\n+         *\/\n+        private final int objectCount;\n+\n+        \/**\n+         * Slot count required for primitives.\n+         *\/\n+        private final int primitiveCount;\n+\n+        \/**\n+         * Underlying carrier class.\n+         *\/\n+        private final Class<?> carrierClass;\n+\n+        \/**\n+         * Constructor {@link MethodHandle}.\n+         *\/\n+        private final MethodHandle constructor;\n+\n+        \/**\n+         * Initializer {@link MethodHandle}.\n+         *\/\n+        private final MethodHandle initializer;\n+\n+        \/**\n+         * List of component {@link MethodHandle MethodHandles}\n+         *\/\n+        private final List<MethodHandle> components;\n+\n+        \/**\n+         * Constructor\n+         *\/\n+        private CarrierElements() {\n+            throw new AssertionError(\"private constructor\");\n+        }\n+\n+        \/**\n+         * Constructor\n+         *\/\n+        CarrierElements(CarrierShape carrierShape,\n+                        Class<?> carrierClass,\n+                        MethodHandle constructor,\n+                        MethodHandle initializer,\n+                        List<MethodHandle> components) {\n+            this.objectCount = carrierShape.objectCount();\n+            this.primitiveCount = carrierShape.primitiveCount();\n+            this.carrierClass = carrierClass;\n+            this.constructor = constructor;\n+            this.initializer = initializer;\n+            this.components = components;\n+        }\n+\n+        \/**\n+         * {@return slot count required for objects}\n+         *\/\n+        int objectCount() {\n+            return objectCount;\n+        }\n+\n+        \/**\n+         * {@return slot count required for primitives}\n+         *\/\n+        int primitiveCount() {\n+            return primitiveCount;\n+        }\n+\n+        \/**\n+         * {@return the underlying carrier class}\n+         *\/\n+        Class<?> carrierClass() {\n+            return carrierClass;\n+        }\n+\n+        \/**\n+         * {@return the constructor {@link MethodHandle} for the carrier. The\n+         * carrier constructor will always have a return type of {@link Object} }\n+         *\/\n+        MethodHandle constructor() {\n+            return constructor;\n+        }\n+\n+        \/**\n+         * {@return the initializer {@link MethodHandle} for the carrier}\n+         *\/\n+        MethodHandle initializer() {\n+            return initializer;\n+        }\n+\n+        \/**\n+         * Return the constructor plus initializer {@link MethodHandle} for the carrier.\n+         * The {@link MethodHandle} will always have a return type of {@link Object}.\n+         * @return the constructor plus initializer {@link MethodHandle}\n+         *\/\n+        MethodHandle initializingConstructor() {\n+            return MethodHandles.foldArguments(initializer, 0, constructor);\n+        }\n+\n+        \/**\n+         * {@return immutable list of component accessor {@link MethodHandle MethodHandles}\n+         * for all the carrier's components. The receiver type of the accessors\n+         * will always be {@link Object} }\n+         *\/\n+        List<MethodHandle> components() {\n+            return components;\n+        }\n+\n+        \/**\n+         * {@return a component accessor {@link MethodHandle} for component {@code i}.\n+         * The receiver type of the accessor will be {@link Object} }\n+         *\n+         * @param i  component index\n+         *\n+         * @throws IllegalArgumentException if {@code i} is out of bounds\n+         *\/\n+        MethodHandle component(int i) {\n+            if (i < 0 || components.size() <= i) {\n+                throw new IllegalArgumentException(\"i is out of bounds \" + i +\n+                        \" of \" + components.size());\n+            }\n+\n+            return components.get(i);\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"Carrier\" + constructor.type().parameterList();\n+        }\n+    }\n+\n+    \/**\n+     * {@return the underlying carrier class of the carrier representing {@code methodType} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static Class<?> carrierClass(MethodType methodType) {\n+        return CarrierFactory.of(methodType).carrierClass();\n+    }\n+\n+    \/**\n+     * {@return the constructor {@link MethodHandle} for the carrier representing {@code\n+     * methodType}. The carrier constructor will always have a return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static MethodHandle constructor(MethodType methodType) {\n+        MethodHandle constructor = CarrierFactory.of(methodType).constructor();\n+        constructor = constructor.asType(constructor.type().changeReturnType(Object.class));\n+        return constructor;\n+    }\n+\n+    \/**\n+     * {@return the initializer {@link MethodHandle} for the carrier representing {@code\n+     * methodType}. The carrier initializer will always take an {@link Object} along with\n+     * component values and a return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static MethodHandle initializer(MethodType methodType) {\n+        MethodHandle initializer = CarrierFactory.of(methodType).initializer();\n+        initializer = initializer.asType(initializer.type()\n+                .changeReturnType(Object.class).changeParameterType(0, Object.class));\n+        return initializer;\n+    }\n+\n+    \/**\n+     * {@return the combination {@link MethodHandle} of the constructor and initializer\n+     * for the carrier representing {@code methodType}. The carrier constructor\/initializer\n+     * will always take the component values and a return type of {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static MethodHandle initializingConstructor(MethodType methodType) {\n+        MethodHandle constructor = CarrierFactory.of(methodType).initializingConstructor();\n+        constructor = constructor.asType(constructor.type().changeReturnType(Object.class));\n+        return constructor;\n+    }\n+\n+    \/**\n+     * {@return immutable list of component accessor {@link MethodHandle MethodHandles} for\n+     * all the components of the carrier representing {@code methodType}. The receiver type of\n+     * the accessors will always be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     *\/\n+    static List<MethodHandle> components(MethodType methodType) {\n+        return CarrierFactory\n+                .of(methodType)\n+                .components()\n+                .stream()\n+                .map(c -> c.asType(c.type().changeParameterType(0, Object.class)))\n+                .toList();\n+    }\n+\n+    \/**\n+     * {@return a component accessor {@link MethodHandle} for component {@code i} of the\n+     * carrier representing {@code methodType}. The receiver type of the accessor will always\n+     * be {@link Object} }\n+     *\n+     * @param methodType  {@link MethodType} whose parameter types supply the shape of the\n+     *                    carrier's components\n+     * @param i           component index\n+     *\n+     * @throws IllegalArgumentException if {@code i} is out of bounds\n+     *\/\n+    static MethodHandle component(MethodType methodType, int i) {\n+        MethodHandle component = CarrierFactory.of(methodType).component(i);\n+        component = component.asType(component.type().changeParameterType(0, Object.class));\n+        return component;\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carriers.java","additions":1005,"deletions":0,"binary":false,"changes":1005,"status":"added"},{"patch":"@@ -0,0 +1,230 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.Objects;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * View\/wrapper of keys used by the backing {@link ReferencedKeyMap}.\n+ * There are two style of keys; one for entries in the backing map and\n+ * one for queries to the backing map. This second style avoids the\n+ * overhead of a {@link Reference} object.\n+ *\n+ * @param <T> key type\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+interface ReferenceKey<T> {\n+    \/**\n+     * {@return the value of the unwrapped key}\n+     *\/\n+    T get();\n+\n+    \/**\n+     * Cleanup unused key.\n+     *\/\n+    void unused();\n+\n+    \/**\n+     * {@link WeakReference} wrapper key for entries in the backing map.\n+     *\n+     * @param <T> key type\n+     *\n+     * @since 21\n+     *\/\n+    class WeakKey<T> extends WeakReference<T> implements ReferenceKey<T> {\n+        \/**\n+         * Saved hashcode of the key. Used when {@link WeakReference} is\n+         * null.\n+         *\/\n+        int hashcode;\n+\n+        \/**\n+         * Private constructor.\n+         *\n+         * @param key   unwrapped key value\n+         * @param queue reference queue\n+         *\/\n+        WeakKey(T key, ReferenceQueue<T> queue) {\n+            super(key, queue);\n+            this.hashcode = Objects.hashCode(key);\n+        }\n+\n+        \/**\n+         * Cleanup unused key. No need to enqueue since the key did not make it\n+         * into the map.\n+         *\/\n+        @Override\n+        public void unused() {\n+            clear();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            \/\/ Necessary when removing a null reference\n+            if (obj == this) {\n+                return true;\n+            }\n+            \/\/ Necessary when comparing an unwrapped key\n+            if (obj instanceof ReferenceKey<?> key) {\n+                obj = key.get();\n+            }\n+            return Objects.equals(get(), obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            \/\/ Use saved hashcode\n+            return hashcode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"java.util.WeakKey#\" + System.identityHashCode(this);\n+        }\n+    }\n+\n+    \/**\n+     * {@link SoftReference} wrapper key for entries in the backing map.\n+     *\n+     * @param <T> key type\n+     *\n+     * @since 21\n+     *\/\n+    class SoftKey<T> extends SoftReference<T> implements ReferenceKey<T> {\n+        \/**\n+         * Saved hashcode of the key. Used when {@link SoftReference} is\n+         * null.\n+         *\/\n+        int hashcode;\n+\n+        \/**\n+         * Private constructor.\n+         *\n+         * @param key   unwrapped key value\n+         * @param queue reference queue\n+         *\/\n+        SoftKey(T key, ReferenceQueue<T> queue) {\n+            super(key, queue);\n+            this.hashcode = Objects.hashCode(key);\n+        }\n+\n+        \/**\n+         * Cleanup unused key. No need to enqueue since the key did not make it\n+         * into the map.\n+         *\/\n+        @Override\n+        public void unused() {\n+            clear();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            \/\/ Necessary when removing a null reference\n+            if (obj == this) {\n+                return true;\n+            }\n+            \/\/ Necessary when comparing an unwrapped key\n+            if (obj instanceof ReferenceKey<?> key) {\n+                obj = key.get();\n+            }\n+            return Objects.equals(get(), obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            \/\/ Use saved hashcode\n+            return hashcode;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"java.util.SoftKey#\" + System.identityHashCode(this);\n+        }\n+    }\n+\n+    \/**\n+     * Wrapper for querying the backing map. Avoids the overhead of an\n+     * {@link Reference} object.\n+     *\n+     * @param <T> key type\n+     *\n+     * @since 21\n+     *\/\n+    class StrongKey<T> implements ReferenceKey<T> {\n+        T key;\n+\n+        \/**\n+         * Private constructor.\n+         *\n+         * @param key unwrapped key value\n+         *\/\n+        StrongKey(T key) {\n+            this.key = key;\n+        }\n+\n+        \/**\n+         * {@return the unwrapped key}\n+         *\/\n+        @Override\n+        public T get() {\n+            return key;\n+        }\n+\n+        @Override\n+        public void unused() {\n+            key = null;\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            \/\/ Necessary when comparing an unwrapped key\n+            if (obj instanceof ReferenceKey<?> key) {\n+                obj = key.get();\n+            }\n+            return Objects.equals(get(), obj);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            \/\/ Use unwrapped key hash code\n+            return get().hashCode();\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"java.util.StrongKey#\" + System.identityHashCode(this);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferenceKey.java","additions":230,"deletions":0,"binary":false,"changes":230,"status":"added"},{"patch":"@@ -0,0 +1,332 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n+import java.lang.ref.WeakReference;\n+import java.util.AbstractMap;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Objects;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class provides management of {@link Map maps} where it is desirable to\n+ * remove entries automatically when the key is garbage collected. This is\n+ * accomplished by using a backing map where the keys are either a\n+ * {@link WeakReference} or a {@link SoftReference}.\n+ * <p>\n+ * To create a {@link ReferencedKeyMap} the user must provide a {@link Supplier}\n+ * of the backing map and whether {@link WeakReference} or\n+ * {@link SoftReference} is to be used.\n+ *\n+ * {@snippet :\n+ * \/\/ Use HashMap and WeakReference\n+ * Map<Long, String> map = ReferencedKeyMap.create(false, HashMap::new);\n+ * map.put(10_000_000L, \"a\");\n+ * map.put(10_000_001L, \"b\");\n+ * map.put(10_000_002L, \"c\");\n+ * map.put(10_000_003L, \"d\");\n+ * map.put(10_000_004L, \"e\");\n+ *\n+ * \/\/ Use ConcurrentHashMap and SoftReference\n+ * map = ReferencedKeyMap.create(true, ConcurrentHashMap::new);\n+ * map.put(20_000_000L, \"v\");\n+ * map.put(20_000_001L, \"w\");\n+ * map.put(20_000_002L, \"x\");\n+ * map.put(20_000_003L, \"y\");\n+ * map.put(20_000_004L, \"z\");\n+ * }\n+ *\n+ * @implNote Care must be given that the backing map does replacement by\n+ * replacing the value in the map entry instead of deleting the old entry and\n+ * adding a new entry, otherwise replaced entries may end up with a strongly\n+ * referenced key. {@link HashMap} and {@link ConcurrentHashMap} are known\n+ * to be safe.\n+ *\n+ * @param <K> the type of keys maintained by this map\n+ * @param <V> the type of mapped values\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class ReferencedKeyMap<K, V> implements Map<K, V> {\n+    \/**\n+     * true if {@link SoftReference} keys are to be used,\n+     * {@link WeakReference} otherwise.\n+     *\/\n+    private final boolean isSoft;\n+\n+    \/**\n+     * Backing {@link Map}.\n+     *\/\n+    private final Map<ReferenceKey<K>, V> map;\n+\n+    \/**\n+     * {@link ReferenceQueue} for cleaning up {@link ReferenceKey.WeakKey EntryKeys}.\n+     *\/\n+    private final ReferenceQueue<K> stale;\n+\n+    \/**\n+     * Private constructor.\n+     *\n+     * @param isSoft  true if {@link SoftReference} keys are to\n+     *                be used, {@link WeakReference} otherwise.\n+     * @param map     backing map\n+     *\/\n+    private ReferencedKeyMap(boolean isSoft, Map<ReferenceKey<K>, V> map) {\n+        this.isSoft = isSoft;\n+        this.map = map;\n+        this.stale = new ReferenceQueue<>();\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeyMap} map.\n+     *\n+     * @param isSoft    true if {@link SoftReference} keys are to\n+     *                  be used, {@link WeakReference} otherwise.\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new map with {@link Reference} keys\n+     *\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    static <K, V> ReferencedKeyMap<K, V>\n+    create(boolean isSoft, Supplier<Map<ReferenceKey<K>, V>> supplier) {\n+        return new ReferencedKeyMap<K, V>(isSoft, supplier.get());\n+    }\n+\n+    \/**\n+     * Create a new {@link ReferencedKeyMap} map using\n+     * {@link WeakReference} keys.\n+     *\n+     * @param supplier  {@link Supplier} of the backing map\n+     *\n+     * @return a new map with {@link Reference} keys\n+     *\n+     * @param <K> the type of keys maintained by the new map\n+     * @param <V> the type of mapped values\n+     *\/\n+    static <K, V> ReferencedKeyMap<K, V>\n+    create(Supplier<Map<ReferenceKey<K>, V>> supplier) {\n+        return new ReferencedKeyMap<K, V>(false, supplier.get());\n+    }\n+\n+    \/**\n+     * {@return a key suitable for a map entry}\n+     *\n+     * @param key unwrapped key\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private ReferenceKey<K> entryKey(Object key) {\n+        if (isSoft) {\n+            return new ReferenceKey.SoftKey<>((K)key, stale);\n+        } else {\n+            return new ReferenceKey.WeakKey<>((K)key, stale);\n+        }\n+    }\n+\n+    \/**\n+     * {@return a key suitable for lookup}\n+     *\n+     * @param key unwrapped key\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private ReferenceKey<K> lookupKey(Object key) {\n+        return new ReferenceKey.StrongKey<>((K)key);\n+    }\n+\n+    @Override\n+    public int size() {\n+        removeStaleReferences();\n+        return map.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        removeStaleReferences();\n+        return map.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        removeStaleReferences();\n+        return map.containsKey(lookupKey(key));\n+    }\n+\n+    @Override\n+    public boolean containsValue(Object value) {\n+        Objects.requireNonNull(value, \"value must not be null\");\n+        removeStaleReferences();\n+        return map.containsValue(value);\n+    }\n+\n+    @Override\n+    public V get(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        removeStaleReferences();\n+        return map.get(lookupKey(key));\n+    }\n+\n+    @Override\n+    public V put(K key, V newValue) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n+        Objects.requireNonNull(newValue, \"value must not be null\");\n+        removeStaleReferences();\n+        ReferenceKey<K> entryKey = entryKey(key);\n+        \/\/ If {@code put} returns non-null then was actually a {@code replace}\n+        \/\/ and older key was used. In that case the new key was not used and the\n+        \/\/ reference marked stale.\n+        V oldValue = map.put(entryKey, newValue);\n+        if (oldValue != null) {\n+            entryKey.unused();\n+        }\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public V remove(Object key) {\n+        \/\/ Rely on gc to clean up old key.\n+        return map.remove(lookupKey(key));\n+    }\n+\n+    @Override\n+    public void putAll(Map<? extends K, ? extends V> m) {\n+        removeStaleReferences();\n+        for (Entry<? extends K, ? extends V> entry : m.entrySet()) {\n+            K key = entry.getKey();\n+            V value = entry.getValue();\n+            put(key, value);\n+        }\n+    }\n+\n+    @Override\n+    public void clear() {\n+        removeStaleReferences();\n+        \/\/ Rely on gc to clean up old keys.\n+        map.clear();\n+    }\n+\n+    \/**\n+     * Common routine for collecting the current set of keys.\n+     *\n+     * @return {@link Stream} of valid keys (unwrapped)\n+     *\/\n+    private Stream<K> filterKeySet() {\n+        return map.keySet()\n+                .stream()\n+                .map(ReferenceKey::get)\n+                .filter(Objects::nonNull);\n+    }\n+\n+    @Override\n+    public Set<K> keySet() {\n+        removeStaleReferences();\n+        return filterKeySet().collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public Collection<V> values() {\n+        removeStaleReferences();\n+        return map.values();\n+    }\n+\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+        removeStaleReferences();\n+        return filterKeySet()\n+                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public V putIfAbsent(K key, V newValue) {\n+        removeStaleReferences();\n+        ReferenceKey<K> entryKey = entryKey(key);\n+        \/\/ If {@code putIfAbsent} returns non-null then was actually a\n+        \/\/ {@code replace}  and older key was used. In that case the new key was\n+        \/\/ not used and the reference marked stale.\n+        V oldValue = map.putIfAbsent(entryKey, newValue);\n+        if (oldValue != null) {\n+            entryKey.unused();\n+        }\n+        return oldValue;\n+    }\n+\n+    @Override\n+    public boolean remove(Object key, Object value) {\n+        \/\/ Rely on gc to clean up old key.\n+        return map.remove(lookupKey(key), value);\n+    }\n+\n+    @Override\n+    public boolean replace(K key, V oldValue, V newValue) {\n+        removeStaleReferences();\n+        \/\/ If replace is successful then the older key will be used and the\n+        \/\/ lookup key will suffice.\n+        return map.replace(lookupKey(key), oldValue, newValue);\n+    }\n+\n+    @Override\n+    public V replace(K key, V value) {\n+        removeStaleReferences();\n+        \/\/ If replace is successful then the older key will be used and the\n+        \/\/ lookup key will suffice.\n+        return map.replace(lookupKey(key), value);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        removeStaleReferences();\n+        return filterKeySet()\n+                .map(k -> k + \"=\" + get(k))\n+                .collect(Collectors.joining(\", \", \"{\", \"}\"));\n+    }\n+\n+    \/**\n+     * Removes enqueued weak references from map.\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    public void removeStaleReferences() {\n+        while (true) {\n+            ReferenceKey.WeakKey<K> key = (ReferenceKey.WeakKey<K>)stale.poll();\n+            if (key == null) {\n+                break;\n+            }\n+            map.remove(key);\n+        }\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferencedKeyMap.java","additions":332,"deletions":0,"binary":false,"changes":332,"status":"added"},{"patch":"@@ -0,0 +1,130 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class implements specialized {@link StringTemplate StringTemplates} produced by\n+ * string template bootstrap method callsites generated by the compiler. Instances of this\n+ * class are produced by {@link StringTemplateImplFactory}.\n+ * <p>\n+ * Values are stored by subclassing {@link Carriers.CarrierObject}. This allows specializations\n+ * and sharing of value shapes without creating a new class for each shape.\n+ * <p>\n+ * {@link StringTemplate} fragments are shared via binding to the\n+ * {@link java.lang.invoke.CallSite CallSite's} {@link MethodHandle}.\n+ * <p>\n+ * The {@link StringTemplateImpl} instance also carries\n+ * specialized {@link MethodHandle MethodHandles} for producing the values list and interpolation.\n+ * These {@link MethodHandle MethodHandles} are  also shared by binding to the\n+ * {@link java.lang.invoke.CallSite CallSite}.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class StringTemplateImpl extends Carriers.CarrierObject implements StringTemplate {\n+    \/**\n+     * List of string fragments for the string template. This value of this list is shared by\n+     * all instances created at the {@link java.lang.invoke.CallSite CallSite}.\n+     *\/\n+    private final List<String> fragments;\n+\n+    \/**\n+     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n+     * {@code values} method. This {@link MethodHandle} is shared by all instances created at the\n+     * {@link java.lang.invoke.CallSite CallSite}.\n+     *\/\n+    private final MethodHandle valuesMH;\n+\n+    \/**\n+     * Specialized {@link MethodHandle} used to implement the {@link StringTemplate StringTemplate's}\n+     * {@code interpolate} method. This {@link MethodHandle} is shared by all instances created at the\n+     * {@link java.lang.invoke.CallSite CallSite}.\n+     *\/\n+    private final MethodHandle interpolateMH;\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param primitiveCount  number of primitive slots required (bound at callsite)\n+     * @param objectCount     number of object slots required (bound at callsite)\n+     * @param fragments       list of string fragments (bound in (bound at callsite)\n+     * @param valuesMH        {@link MethodHandle} to produce list of values (bound at callsite)\n+     * @param interpolateMH   {@link MethodHandle} to produce interpolation (bound at callsite)\n+     *\/\n+    StringTemplateImpl(int primitiveCount, int objectCount,\n+                       List<String> fragments, MethodHandle valuesMH, MethodHandle interpolateMH) {\n+        super(primitiveCount, objectCount);\n+        this.fragments = fragments;\n+        this.valuesMH = valuesMH;\n+        this.interpolateMH = interpolateMH;\n+    }\n+\n+    @Override\n+    public List<String> fragments() {\n+        return fragments;\n+    }\n+\n+    @Override\n+    public List<Object> values() {\n+        try {\n+            return (List<Object>)valuesMH.invokeExact(this);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(\"string template values failure\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public String interpolate() {\n+        try {\n+            return (String)interpolateMH.invokeExact(this);\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(\"string template interpolate failure\", ex);\n+        }\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+        return other instanceof StringTemplate st &&\n+                Objects.equals(fragments(), st.fragments()) &&\n+                Objects.equals(values(), st.values());\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(fragments(), values());\n+    }\n+\n+    @java.lang.Override\n+    public java.lang.String toString() {\n+        return StringTemplate.toString(this);\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImpl.java","additions":130,"deletions":0,"binary":false,"changes":130,"status":"added"},{"patch":"@@ -0,0 +1,197 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.StringConcatException;\n+import java.lang.invoke.StringConcatFactory;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class synthesizes {@link StringTemplate StringTemplates} based on\n+ * fragments and bootstrap method type. Usage is primarily from\n+ * {@link java.lang.runtime.TemplateRuntime}.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class StringTemplateImplFactory {\n+\n+    \/**\n+     * Private constructor.\n+     *\/\n+    StringTemplateImplFactory() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/*\n+     * {@link StringTemplateImpl} constructor MethodHandle.\n+     *\/\n+    private static final MethodHandle CONSTRUCTOR;\n+\n+    \/**\n+     * List (for nullable) of MethodHandle;\n+     *\/\n+    private static final MethodHandle TO_LIST;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(void.class, int.class, int.class, List.class,\n+                    MethodHandle.class, MethodHandle.class);\n+            CONSTRUCTOR = lookup.findConstructor(StringTemplateImpl.class, mt)\n+                    .asType(mt.changeReturnType(Carriers.CarrierObject.class));\n+\n+            mt = MethodType.methodType(List.class, Object[].class);\n+            TO_LIST = lookup.findStatic(StringTemplateImplFactory.class, \"toList\", mt);\n+        } catch(ReflectiveOperationException ex) {\n+            throw new AssertionError(\"carrier static init fail\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Create a new {@link StringTemplateImpl} constructor.\n+     *\n+     * @param fragments  string template fragments\n+     * @param type       values types with StringTemplate return\n+     *\n+     * @return {@link MethodHandle} that can construct a {@link StringTemplateImpl} with arguments\n+     * used as values.\n+     *\/\n+    static MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type) {\n+        Carriers.CarrierElements elements = Carriers.CarrierFactory.of(type);\n+        MethodHandle[] components = elements\n+                .components()\n+                .stream()\n+                .map(c -> c.asType(c.type().changeParameterType(0, StringTemplateImpl.class)))\n+                .toArray(MethodHandle[]::new);\n+        Class<?>[] ptypes = elements\n+                .components()\n+                .stream()\n+                .map(c -> c.type().returnType())\n+                .toArray(Class<?>[]::new);\n+        int[] permute = new int[ptypes.length];\n+\n+        MethodHandle interpolateMH;\n+        MethodType mt;\n+        try {\n+            interpolateMH = StringConcatFactory.makeConcatWithTemplate(fragments, List.of(ptypes));\n+        } catch (StringConcatException ex) {\n+            throw new RuntimeException(\"constructing internal string template\", ex);\n+        }\n+        interpolateMH = MethodHandles.filterArguments(interpolateMH, 0, components);\n+        mt = MethodType.methodType(String.class, StringTemplateImpl.class);\n+        interpolateMH = MethodHandles.permuteArguments(interpolateMH, mt, permute);\n+\n+        mt = MethodType.methodType(List.class, ptypes);\n+        MethodHandle valuesMH = TO_LIST.asCollector(Object[].class, components.length).asType(mt);\n+        valuesMH = MethodHandles.filterArguments(valuesMH, 0, components);\n+        mt = MethodType.methodType(List.class, StringTemplateImpl.class);\n+        valuesMH = MethodHandles.permuteArguments(valuesMH, mt, permute);\n+\n+        MethodHandle constructor = MethodHandles.insertArguments(CONSTRUCTOR,0,\n+                elements.primitiveCount(), elements.objectCount(),\n+                fragments, valuesMH, interpolateMH);\n+        constructor = MethodHandles.foldArguments(elements.initializer(), 0, constructor);\n+\n+        mt = MethodType.methodType(StringTemplate.class, ptypes);\n+        constructor = constructor.asType(mt);\n+\n+        return constructor;\n+    }\n+\n+    \/**\n+     * Generic {@link StringTemplate}.\n+     *\n+     * @param fragments  immutable list of string fragments from string template\n+     * @param values     immutable list of expression values\n+     *\/\n+    private record SimpleStringTemplate(List<String> fragments, List<Object> values)\n+            implements StringTemplate {\n+        @Override\n+        public String toString() {\n+            return StringTemplate.toString(this);\n+        }\n+    }\n+\n+    \/**\n+     * Returns a new StringTemplate composed from fragments and values.\n+     *\n+     * @param fragments array of string fragments\n+     * @param values    array of expression values\n+     *\n+     * @return StringTemplate composed from fragments and values\n+     *\/\n+    static StringTemplate newTrustedStringTemplate(String[] fragments, Object[] values) {\n+        return new SimpleStringTemplate(List.of(fragments), toList(values));\n+    }\n+\n+    \/**\n+     * Returns a new StringTemplate composed from fragments and values.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    array of expression values\n+     *\n+     * @return StringTemplate composed from fragments and values\n+     *\/\n+    static StringTemplate newTrustedStringTemplate(List<String> fragments, Object[] values) {\n+        return new SimpleStringTemplate(List.copyOf(fragments), toList(values));\n+    }\n+\n+    \/**\n+     * Returns a new StringTemplate composed from fragments and values.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from fragments and values\n+     *\/\n+\n+    static StringTemplate newStringTemplate(List<String> fragments, List<?> values) {\n+        @SuppressWarnings(\"unchecked\")\n+        List<Object> copy = (List<Object>)values.stream().toList();\n+        return new SimpleStringTemplate(List.copyOf(fragments), copy);\n+    }\n+\n+    \/**\n+     * Collect nullable elements from an array into a unmodifiable list.\n+     * Elements are guaranteed to be safe.\n+     *\n+     * @param elements  elements to place in list\n+     *\n+     * @return unmodifiable list.\n+     *\/\n+    private static List<Object> toList(Object[] elements) {\n+        return Arrays.stream(elements).toList();\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImplFactory.java","additions":197,"deletions":0,"binary":false,"changes":197,"status":"added"},{"patch":"@@ -0,0 +1,224 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.ConstantCallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.StringTemplate.Processor;\n+import java.lang.StringTemplate.Processor.Linkage;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Manages string template bootstrapping and creation. These methods may be used, for example,\n+ * by Java compiler implementations to implement the bodies of methods for {@link StringTemplate}\n+ * objects.\n+ * <p>\n+ * The {@link TemplateRuntime#newLargeStringTemplate} bootstrap method is used to create\n+ * {@link StringTemplate StringTemplates} that have more than\n+ * {@link java.lang.invoke.StringConcatFactory#MAX_INDY_CONCAT_ARG_SLOTS} values.\n+ * <p>\n+ * The {@link TemplateRuntime#newStringTemplate} bootstrap method is used to create\n+ * optimized {@link StringTemplate StringTemplates}.\n+ * <p>\n+ * The {@link TemplateRuntime#newLargeStringTemplate} bootstrap method is used\n+ * to bind to specialized processors that implement {@link Linkage}.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public final class TemplateRuntime {\n+    private static final JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+\n+    \/**\n+     * {@link MethodHandle} to {@link TemplateRuntime#defaultProcess}.\n+     *\/\n+    private static final MethodHandle DEFAULT_PROCESS_MH;\n+\n+    \/**\n+     * {@link MethodHandle} to {@link TemplateRuntime#newTrustedStringTemplate}.\n+     *\/\n+    private static final MethodHandle NEW_TRUSTED_STRING_TEMPLATE;\n+\n+    \/**\n+     * Initialize {@link MethodHandle MethodHandles}.\n+     *\/\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+\n+            MethodType mt = MethodType.methodType(Object.class,\n+                    List.class, Processor.class, Object[].class);\n+            DEFAULT_PROCESS_MH =\n+                lookup.findStatic(TemplateRuntime.class, \"defaultProcess\", mt);\n+\n+            mt = MethodType.methodType(StringTemplate.class, String[].class, Object[].class);\n+            NEW_TRUSTED_STRING_TEMPLATE =\n+                lookup.findStatic(StringTemplateImplFactory.class, \"newTrustedStringTemplate\", mt);\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"string bootstrap fail\", ex);\n+        }\n+    }\n+\n+    \/**\n+     * Private constructor.\n+     *\/\n+    private TemplateRuntime() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * String template bootstrap method for creating large string templates.\n+     * The non-static arguments are the fragments list and values list.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     *\n+     * @return {@link CallSite} to handle create large string template\n+     *\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite newLargeStringTemplate(MethodHandles.Lookup lookup,\n+                                                  String name,\n+                                                  MethodType type) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+\n+        return new ConstantCallSite(NEW_TRUSTED_STRING_TEMPLATE.asType(type));\n+    }\n+\n+    \/**\n+     * String template bootstrap method for creating string templates.\n+     * The static arguments include the fragments list.\n+     * The non-static arguments are the values.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     * @param fragments       fragments from string template\n+     *\n+     * @return {@link CallSite} to handle create string template\n+     *\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite newStringTemplate(MethodHandles.Lookup lookup,\n+                                             String name,\n+                                             MethodType type,\n+                                             String... fragments) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+\n+        MethodHandle mh = StringTemplateImplFactory\n+                .createStringTemplateImplMH(List.of(fragments), type).asType(type);\n+\n+        return new ConstantCallSite(mh);\n+    }\n+\n+    \/**\n+     * String template bootstrap method for static final processors.\n+     * The static arguments include the fragments list  and a {@link MethodHandle}\n+     * to retrieve the value of the static final processor.\n+     * The non-static arguments are the values.\n+     *\n+     * @param lookup          method lookup\n+     * @param name            method name\n+     * @param type            method type\n+     * @param processorGetter {@link MethodHandle} to get static final processor\n+     * @param fragments       fragments from string template\n+     *\n+     * @return {@link CallSite} to handle string template processing\n+     *\n+     * @throws NullPointerException if any of the arguments is null\n+     * @throws Throwable            if linkage fails\n+     *\/\n+    public static CallSite processStringTemplate(MethodHandles.Lookup lookup,\n+                                                 String name,\n+                                                 MethodType type,\n+                                                 MethodHandle processorGetter,\n+                                                 String... fragments) throws Throwable {\n+        Objects.requireNonNull(lookup, \"lookup is null\");\n+        Objects.requireNonNull(name, \"name is null\");\n+        Objects.requireNonNull(type, \"type is null\");\n+        Objects.requireNonNull(processorGetter, \"processorGetter is null\");\n+        Objects.requireNonNull(fragments, \"fragments is null\");\n+\n+        Processor<?, ?> processor = (Processor<?, ?>)processorGetter.invoke();\n+        MethodHandle mh = processor instanceof Linkage linkage\n+                ? linkage.linkage(List.of(fragments), type)\n+                : defaultProcessMethodHandle(type, processor, List.of(fragments));\n+\n+        return new ConstantCallSite(mh);\n+    }\n+\n+    \/**\n+     * Creates a simple {@link StringTemplate} and then invokes the processor's process method.\n+     *\n+     * @param fragments fragments from string template\n+     * @param processor {@link Processor} to process\n+     * @param values    array of expression values\n+     *\n+     * @return result of processing the string template\n+     *\/\n+    private static Object defaultProcess(\n+            List<String> fragments,\n+            Processor<?, ?> processor,\n+            Object[] values\n+    ) throws Throwable {\n+        return processor.process(StringTemplate.of(fragments, Arrays.stream(values).toList()));\n+    }\n+\n+    \/**\n+     * Generate a {@link MethodHandle} which is effectively invokes\n+     * {@code processor.process(new StringTemplate(fragments, values...)}.\n+     *\n+     * @return default process {@link MethodHandle}\n+     *\/\n+    private static MethodHandle defaultProcessMethodHandle(\n+            MethodType type,\n+            Processor<?, ?> processor,\n+            List<String> fragments\n+    ) {\n+        MethodHandle mh = MethodHandles.insertArguments(DEFAULT_PROCESS_MH, 0, fragments, processor);\n+        return mh.asCollector(Object[].class, type.parameterCount()).asType(type);\n+    }\n+}\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateRuntime.java","additions":224,"deletions":0,"binary":false,"changes":224,"status":"added"},{"patch":"@@ -0,0 +1,151 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class provides runtime support for string templates. The methods within\n+ * are intended for internal use only.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class TemplateSupport implements JavaTemplateAccess {\n+\n+    \/**\n+     * Private constructor.\n+     *\/\n+    private TemplateSupport() {\n+    }\n+\n+    static {\n+        SharedSecrets.setJavaTemplateAccess(new TemplateSupport());\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/**\n+     * Returns a StringTemplate composed from fragments and values.\n+     *\n+     * @implSpec The {@code fragments} list size must be one more that the\n+     * {@code values} list size.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from fragments and values\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n+     *\n+     * @implNote Contents of both lists are copied to construct immutable lists.\n+     *\/\n+    @Override\n+    public StringTemplate of(List<String> fragments, List<?> values) {\n+        return StringTemplateImplFactory.newStringTemplate(fragments, values);\n+    }\n+\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\/\n+    @Override\n+    public String interpolate(List<String> fragments, List<?> values) {\n+        int fragmentsSize = fragments.size();\n+        int valuesSize = values.size();\n+        if (fragmentsSize == 1) {\n+            return fragments.get(0);\n+        }\n+        int size = fragmentsSize + valuesSize;\n+        String[] strings = new String[size];\n+        int i = 0, j = 0;\n+        for (; j < valuesSize; j++) {\n+            strings[i++] = fragments.get(j);\n+            strings[i++] = String.valueOf(values.get(j));\n+        }\n+        strings[i] = fragments.get(j);\n+        return JLA.join(\"\", \"\", \"\", strings, size);\n+    }\n+\n+    \/**\n+     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n+     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n+     * }\n+     *\n+     * @param sts  zero or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if sts is null or if any element of sts is null\n+     *\/\n+    @Override\n+    public StringTemplate combine(StringTemplate... sts) {\n+        Objects.requireNonNull(sts, \"sts must not be null\");\n+        if (sts.length == 0) {\n+            return StringTemplate.of(\"\");\n+        } else if (sts.length == 1) {\n+            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n+        }\n+        int size = 0;\n+        for (StringTemplate st : sts) {\n+            Objects.requireNonNull(st, \"string templates should not be null\");\n+            size += st.values().size();\n+        }\n+        String[] combinedFragments = new String[size + 1];\n+        Object[] combinedValues = new Object[size];\n+        combinedFragments[0] = \"\";\n+        int fragmentIndex = 1;\n+        int valueIndex = 0;\n+        for (StringTemplate st : sts) {\n+            Iterator<String> iterator = st.fragments().iterator();\n+            combinedFragments[fragmentIndex - 1] += iterator.next();\n+            while (iterator.hasNext()) {\n+                combinedFragments[fragmentIndex++] = iterator.next();\n+            }\n+            for (Object value : st.values()) {\n+                combinedValues[valueIndex++] = value;\n+            }\n+        }\n+        return StringTemplateImplFactory.newTrustedStringTemplate(combinedFragments, combinedValues);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateSupport.java","additions":151,"deletions":0,"binary":false,"changes":151,"status":"added"},{"patch":"@@ -0,0 +1,285 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.invoke.MethodHandle;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.vm.annotation.Stable;\n+\n+\/**\n+ * Digits provides a fast methodology for converting integers and longs to\n+ * ASCII strings.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+sealed interface Digits permits Digits.DecimalDigits, Digits.HexDigits, Digits.OctalDigits {\n+    \/**\n+     * Insert digits for long value in buffer from high index to low index.\n+     *\n+     * @param value      value to convert\n+     * @param buffer     byte buffer to copy into\n+     * @param index      insert point + 1\n+     * @param putCharMH  method to put character\n+     *\n+     * @return the last index used\n+     *\n+     * @throws Throwable if putCharMH fails (unusual).\n+     *\/\n+    int digits(long value, byte[] buffer, int index,\n+               MethodHandle putCharMH) throws Throwable;\n+\n+    \/**\n+     * Calculate the number of digits required to represent the long.\n+     *\n+     * @param value value to convert\n+     *\n+     * @return number of digits\n+     *\/\n+    int size(long value);\n+\n+    \/**\n+     * Digits class for decimal digits.\n+     *\/\n+    final class DecimalDigits implements Digits {\n+        @Stable\n+        private static final short[] DIGITS;\n+\n+        \/**\n+         * Singleton instance of DecimalDigits.\n+         *\/\n+        static final Digits INSTANCE = new DecimalDigits();\n+\n+        static {\n+            short[] digits = new short[10 * 10];\n+\n+            for (int i = 0; i < 10; i++) {\n+                short hi = (short) ((i + '0') << 8);\n+\n+                for (int j = 0; j < 10; j++) {\n+                    short lo = (short) (j + '0');\n+                    digits[i * 10 + j] = (short) (hi | lo);\n+                }\n+            }\n+\n+            DIGITS = digits;\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\/\n+        private DecimalDigits() {\n+        }\n+\n+        @Override\n+        public int digits(long value, byte[] buffer, int index,\n+                          MethodHandle putCharMH) throws Throwable {\n+            boolean negative = value < 0;\n+            if (!negative) {\n+                value = -value;\n+            }\n+\n+            long q;\n+            int r;\n+            while (value <= Integer.MIN_VALUE) {\n+                q = value \/ 100;\n+                r = (int)((q * 100) - value);\n+                value = q;\n+                int digits = DIGITS[r];\n+\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            int iq, ivalue = (int)value;\n+            while (ivalue <= -100) {\n+                iq = ivalue \/ 100;\n+                r = (iq * 100) - ivalue;\n+                ivalue = iq;\n+                int digits = DIGITS[r];\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            if (ivalue < 0) {\n+                ivalue = -ivalue;\n+            }\n+\n+            int digits = DIGITS[ivalue];\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+            if (9 < ivalue) {\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            if (negative) {\n+                putCharMH.invokeExact(buffer, --index, (int)'-');\n+            }\n+\n+            return index;\n+        }\n+\n+        @Override\n+        public int size(long value) {\n+            boolean negative = value < 0;\n+            int sign = negative ? 1 : 0;\n+\n+            if (!negative) {\n+                value = -value;\n+            }\n+\n+            long precision = -10;\n+            for (int i = 1; i < 19; i++) {\n+                if (value > precision)\n+                    return i + sign;\n+\n+                precision = 10 * precision;\n+            }\n+\n+            return 19 + sign;\n+        }\n+    }\n+\n+    \/**\n+     * Digits class for hexadecimal digits.\n+     *\/\n+    final class HexDigits implements Digits {\n+        @Stable\n+        private static final short[] DIGITS;\n+\n+        \/**\n+         * Singleton instance of HexDigits.\n+         *\/\n+        static final Digits INSTANCE = new HexDigits();\n+\n+        static {\n+            short[] digits = new short[16 * 16];\n+\n+            for (int i = 0; i < 16; i++) {\n+                short hi = (short) ((i < 10 ? i + '0' : i - 10 + 'a') << 8);\n+\n+                for (int j = 0; j < 16; j++) {\n+                    short lo = (short) (j < 10 ? j + '0' : j - 10 + 'a');\n+                    digits[(i << 4) + j] = (short) (hi | lo);\n+                }\n+            }\n+\n+            DIGITS = digits;\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\/\n+        private HexDigits() {\n+        }\n+\n+        @Override\n+        public int digits(long value, byte[] buffer, int index,\n+                          MethodHandle putCharMH) throws Throwable {\n+            while ((value & ~0xFF) != 0) {\n+                int digits = DIGITS[(int) (value & 0xFF)];\n+                value >>>= 8;\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            int digits = DIGITS[(int) (value & 0xFF)];\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+            if (0xF < value) {\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            return index;\n+        }\n+\n+        @Override\n+        public int size(long value) {\n+            return value == 0 ? 1 :\n+                    67 - Long.numberOfLeadingZeros(value) >> 2;\n+        }\n+    }\n+\n+    \/**\n+     * Digits class for octal digits.\n+     *\/\n+    final class OctalDigits implements Digits {\n+        @Stable\n+        private static final short[] DIGITS;\n+\n+        \/**\n+         * Singleton instance of HexDigits.\n+         *\/\n+        static final Digits INSTANCE = new OctalDigits();\n+\n+        static {\n+            short[] digits = new short[8 * 8];\n+\n+            for (int i = 0; i < 8; i++) {\n+                short hi = (short) ((i + '0') << 8);\n+\n+                for (int j = 0; j < 8; j++) {\n+                    short lo = (short) (j + '0');\n+                    digits[(i << 3) + j] = (short) (hi | lo);\n+                }\n+            }\n+\n+            DIGITS = digits;\n+        }\n+\n+        \/**\n+         * Constructor.\n+         *\/\n+        private OctalDigits() {\n+        }\n+\n+        @Override\n+        public int digits(long value, byte[] buffer, int index,\n+                          MethodHandle putCharMH) throws Throwable {\n+            while ((value & ~0x3F) != 0) {\n+                int digits = DIGITS[(int) (value & 0x3F)];\n+                value >>>= 6;\n+                putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            int digits = DIGITS[(int) (value & 0x3F)];\n+            putCharMH.invokeExact(buffer, --index, digits & 0xFF);\n+\n+            if (7 < value) {\n+                putCharMH.invokeExact(buffer, --index, digits >> 8);\n+            }\n+\n+            return index;\n+        }\n+\n+        @Override\n+        public int size(long value) {\n+            return (66 - Long.numberOfLeadingZeros(value)) \/ 3;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/Digits.java","additions":285,"deletions":0,"binary":false,"changes":285,"status":"added"},{"patch":"@@ -0,0 +1,538 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.io.IOException;\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.nio.ByteOrder;\n+import java.nio.charset.StandardCharsets;\n+import java.text.DecimalFormatSymbols;\n+import java.util.Digits.*;\n+import java.util.Formatter.FormatSpecifier;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.util.FormatConcatItem;\n+\n+import static java.lang.invoke.MethodType.methodType;\n+\n+\/**\n+ * A specialized objects used by FormatterBuilder that knows how to insert\n+ * themselves into a concatenation performed by StringConcatFactory.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+class FormatItem {\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    private static final MethodHandle CHAR_MIX =\n+            JLA.stringConcatHelper(\"mix\",\n+                    MethodType.methodType(long.class, long.class,char.class));\n+\n+    private static final MethodHandle STRING_PREPEND =\n+            JLA.stringConcatHelper(\"prepend\",\n+                    MethodType.methodType(long.class, long.class, byte[].class,\n+                            String.class, String.class));\n+\n+    private static final MethodHandle SELECT_GETCHAR_MH =\n+            JLA.stringConcatHelper(\"selectGetChar\",\n+                    MethodType.methodType(MethodHandle.class, long.class));\n+\n+    private static final MethodHandle SELECT_PUTCHAR_MH =\n+            JLA.stringConcatHelper(\"selectPutChar\",\n+                    MethodType.methodType(MethodHandle.class, long.class));\n+\n+    private static final long charMix(long lengthCoder, char value) {\n+        try {\n+            return (long)CHAR_MIX.invokeExact(lengthCoder, value);\n+        } catch (Error | RuntimeException ex) {\n+            throw ex;\n+        } catch (Throwable ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static final long stringMix(long lengthCoder, String value) {\n+        return JLA.stringConcatMix(lengthCoder, value);\n+    }\n+\n+    private static final long stringPrepend(long lengthCoder, byte[] buffer,\n+                                            String value) throws Throwable {\n+        return (long)STRING_PREPEND.invokeExact(lengthCoder, buffer, value,\n+                (String)null);\n+    }\n+\n+    private static MethodHandle selectGetChar(long indexCoder) throws Throwable {\n+        return (MethodHandle)SELECT_GETCHAR_MH.invokeExact(indexCoder);\n+    }\n+\n+    private static MethodHandle selectPutChar(long indexCoder) throws Throwable {\n+        return (MethodHandle)SELECT_PUTCHAR_MH.invokeExact(indexCoder);\n+    }\n+\n+    private static final MethodHandle PUT_CHAR_DIGIT;\n+\n+    static {\n+        try {\n+            Lookup lookup = MethodHandles.lookup();\n+            PUT_CHAR_DIGIT = lookup.findStatic(FormatItem.class, \"putByte\",\n+                    MethodType.methodType(void.class,\n+                            byte[].class, int.class, int.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new AssertionError(\"putByte lookup failed\", ex);\n+        }\n+    }\n+\n+    private static void putByte(byte[] buffer, int index, int ch) {\n+        buffer[index] = (byte)ch;\n+    }\n+\n+    private FormatItem() {\n+        throw new AssertionError(\"private constructor\");\n+    }\n+\n+    \/**\n+     * Decimal value format item.\n+     *\/\n+    static final class FormatItemDecimal implements FormatConcatItem {\n+        private final char groupingSeparator;\n+        private final char zeroDigit;\n+        private final char minusSign;\n+        private final int digitOffset;\n+        private final byte[] digits;\n+        private final int length;\n+        private final boolean isNegative;\n+        private final int width;\n+        private final byte prefixSign;\n+        private final int groupSize;\n+        private final long value;\n+        private final boolean parentheses;\n+\n+        FormatItemDecimal(DecimalFormatSymbols dfs, int width, char sign,\n+                          boolean parentheses, int groupSize, long value) throws Throwable {\n+            this.groupingSeparator = dfs.getGroupingSeparator();\n+            this.zeroDigit = dfs.getZeroDigit();\n+            this.minusSign = dfs.getMinusSign();\n+            this.digitOffset = this.zeroDigit - '0';\n+            int length = DecimalDigits.INSTANCE.size(value);\n+            this.digits = new byte[length];\n+            DecimalDigits.INSTANCE.digits(value, this.digits, length, PUT_CHAR_DIGIT);\n+            this.isNegative = value < 0L;\n+            this.length = this.isNegative ? length - 1 : length;\n+            this.width = width;\n+            this.groupSize = groupSize;\n+            this.value = value;\n+            this.parentheses = parentheses && isNegative;\n+            this.prefixSign = (byte)(isNegative ? (parentheses ? '\\0' : minusSign) : sign);\n+        }\n+\n+        private int signLength() {\n+            return (prefixSign != '\\0' ? 1 : 0) + (parentheses ? 2 : 0);\n+        }\n+\n+        private int groupLength() {\n+            return 0 < groupSize ? (length - 1) \/ groupSize : 0;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return JLA.stringConcatCoder(zeroDigit) |\n+                    (lengthCoder +\n+                     Integer.max(length + signLength() + groupLength(), width));\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            if (parentheses) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)')');\n+            }\n+\n+            if (0 < groupSize) {\n+                int groupIndex = groupSize;\n+\n+                for (int i = 1; i <= length; i++) {\n+                    if (groupIndex-- == 0) {\n+                        putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                                (int)groupingSeparator);\n+                        groupIndex = groupSize - 1;\n+                    }\n+\n+                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                            digits[digits.length - i] + digitOffset);\n+                }\n+            } else {\n+                for (int i = 1; i <= length; i++) {\n+                    putCharMH.invokeExact(buffer, (int)--lengthCoder,\n+                            digits[digits.length - i] + digitOffset);\n+                }\n+            }\n+\n+            for (int i = length + signLength() + groupLength(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            if (parentheses) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'(');\n+            }\n+            if (prefixSign != '\\0') {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)prefixSign);\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Hexadecimal format item.\n+     *\/\n+    static final class FormatItemHexadecimal implements FormatConcatItem {\n+        private final int width;\n+        private final boolean hasPrefix;\n+        private final long value;\n+        private final int length;\n+\n+        FormatItemHexadecimal(int width, boolean hasPrefix, long value) {\n+            this.width = width;\n+            this.hasPrefix = hasPrefix;\n+            this.value = value;\n+            this.length = HexDigits.INSTANCE.size(value);\n+        }\n+\n+        private int prefixLength() {\n+            return hasPrefix ? 2 : 0;\n+        }\n+\n+        private int zeroesLength() {\n+            return Integer.max(0, width - length - prefixLength());\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + length + prefixLength() + zeroesLength();\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            HexDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+            lengthCoder -= length;\n+\n+            for (int i = 0; i < zeroesLength(); i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            if (hasPrefix) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'x');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Hexadecimal format item.\n+     *\/\n+    static final class FormatItemOctal implements FormatConcatItem {\n+        private final int width;\n+        private final boolean hasPrefix;\n+        private final long value;\n+        private final int length;\n+\n+        FormatItemOctal(int width, boolean hasPrefix, long value) {\n+            this.width = width;\n+            this.hasPrefix = hasPrefix;\n+            this.value = value;\n+            this.length = OctalDigits.INSTANCE.size(value);\n+        }\n+\n+        private int prefixLength() {\n+            return hasPrefix && value != 0 ? 1 : 0;\n+        }\n+\n+        private int zeroesLength() {\n+            return Integer.max(0, width - length - prefixLength());\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + length + prefixLength() + zeroesLength();\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            OctalDigits.INSTANCE.digits(value, buffer, (int)lengthCoder, putCharMH);\n+            lengthCoder -= length;\n+\n+            for (int i = 0; i < zeroesLength(); i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            if (hasPrefix && value != 0) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'0');\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Boolean format item.\n+     *\/\n+    static final class FormatItemBoolean implements FormatConcatItem {\n+        private final boolean value;\n+\n+        FormatItemBoolean(boolean value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + (value ? \"true\".length() : \"false\".length());\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            if (value) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'r');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'t');\n+            } else {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'e');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'s');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'a');\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'f');\n+            }\n+\n+            return lengthCoder;\n+         }\n+    }\n+\n+    \/**\n+     * Character format item.\n+     *\/\n+    static final class FormatItemCharacter implements FormatConcatItem {\n+        private final char value;\n+\n+        FormatItemCharacter(char value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return charMix(lengthCoder, value);\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)value);\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * String format item.\n+     *\/\n+    static final class FormatItemString implements FormatConcatItem {\n+        private String value;\n+\n+        FormatItemString(String value) {\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return stringMix(lengthCoder, value);\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            return stringPrepend(lengthCoder, buffer, value);\n+        }\n+    }\n+\n+    \/**\n+     * FormatSpecifier format item.\n+     *\/\n+    static final class FormatItemFormatSpecifier implements FormatConcatItem {\n+        private StringBuilder sb;\n+\n+        FormatItemFormatSpecifier(FormatSpecifier fs, Locale locale, Object value) {\n+            this.sb = new StringBuilder(64);\n+            Formatter formatter = new Formatter(this.sb, locale);\n+\n+            try {\n+                fs.print(formatter, value, locale);\n+            } catch (IOException ex) {\n+                throw new AssertionError(\"FormatItemFormatSpecifier IOException\", ex);\n+            }\n+        }\n+\n+        FormatItemFormatSpecifier(Locale locale,\n+                                  int flags, int width, int precision,\n+                                  Formattable formattable) {\n+            this.sb = new StringBuilder(64);\n+            Formatter formatter = new Formatter(this.sb, locale);\n+            formattable.formatTo(formatter, flags, width, precision);\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return JLA.stringBuilderConcatMix(lengthCoder, sb);\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            return JLA.stringBuilderConcatPrepend(lengthCoder, buffer, sb);\n+        }\n+    }\n+\n+    protected static abstract sealed class FormatItemModifier implements FormatConcatItem\n+        permits FormatItemFillLeft,\n+                FormatItemFillRight\n+    {\n+        private final long itemLengthCoder;\n+        protected final FormatConcatItem item;\n+\n+        FormatItemModifier(FormatConcatItem item) {\n+            this.itemLengthCoder = item.mix(0L);\n+            this.item = item;\n+        }\n+\n+        int length() {\n+            return (int)itemLengthCoder;\n+        }\n+\n+        long coder() {\n+            return itemLengthCoder & ~Integer.MAX_VALUE;\n+        }\n+\n+        @Override\n+        public abstract long mix(long lengthCoder);\n+\n+        @Override\n+        public abstract long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+    }\n+\n+    \/**\n+     * Fill left format item.\n+     *\/\n+    static final class FormatItemFillLeft extends FormatItemModifier\n+            implements FormatConcatItem {\n+        private final int width;\n+\n+        FormatItemFillLeft(int width, FormatConcatItem item) {\n+            super(item);\n+            this.width = Integer.max(length(), width);\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return (lengthCoder | coder()) + width;\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+            lengthCoder = item.prepend(lengthCoder, buffer);\n+\n+            for (int i = length(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+            }\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+    \/**\n+     * Fill right format item.\n+     *\/\n+    static final class FormatItemFillRight extends FormatItemModifier\n+            implements FormatConcatItem {\n+        private final int width;\n+\n+        FormatItemFillRight(int width, FormatConcatItem item) {\n+            super(item);\n+            this.width = Integer.max(length(), width);\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return (lengthCoder | coder()) + width;\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            for (int i = length(); i < width; i++) {\n+                putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)' ');\n+            }\n+\n+            lengthCoder = item.prepend(lengthCoder, buffer);\n+\n+            return lengthCoder;\n+        }\n+    }\n+\n+\n+    \/**\n+     * Null format item.\n+     *\/\n+    static final class FormatItemNull implements FormatConcatItem {\n+        FormatItemNull() {\n+        }\n+\n+        @Override\n+        public long mix(long lengthCoder) {\n+            return lengthCoder + \"null\".length();\n+        }\n+\n+        @Override\n+        public long prepend(long lengthCoder, byte[] buffer) throws Throwable {\n+            MethodHandle putCharMH = selectPutChar(lengthCoder);\n+\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'l');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'u');\n+            putCharMH.invokeExact(buffer, (int)--lengthCoder, (int)'n');\n+\n+            return lengthCoder;\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":538,"deletions":0,"binary":false,"changes":538,"status":"added"},{"patch":"@@ -0,0 +1,284 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.StringTemplate.Processor;\n+import java.lang.StringTemplate.Processor.Linkage;\n+import java.util.regex.Matcher;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This {@link Processor} constructs a {@link String} result using\n+ * {@link Formatter} specifications and values found in the {@link StringTemplate}.\n+ * Unlike {@link Formatter}, {@link FormatProcessor} uses the value from the\n+ * embedded expression that immediately follows, without whitespace, the\n+ * <a href=\"..\/util\/Formatter.html#syntax\">format specifier<\/a>.\n+ * For example:\n+ * {@snippet :\n+ * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n+ * int x = 10;\n+ * int y = 20;\n+ * String result = fmt.\"%05d\\{x} + %05d\\{y} = %05d\\{x + y}\";\n+ * }\n+ * In the above example, the value of {@code result} will be {@code \"00010 + 00020 = 00030\"}.\n+ * <p>\n+ * Embedded expressions without a preceeding format specifier, use {@code %s}\n+ * by default.\n+ * {@snippet :\n+ * FormatProcessor fmt = FormatProcessor.create(Locale.ROOT);\n+ * int x = 10;\n+ * int y = 20;\n+ * String result1 = fmt.\"\\{x} + \\{y} = \\{x + y}\";\n+ * String result2 = fmt.\"%s\\{x} + %s\\{y} = %s\\{x + y}\";\n+ * }\n+ * In the above example, the value of {@code result1} and {@code result2} will\n+ * both be {@code \"10 + 20 = 30\"}.\n+ * <p>\n+ * The {@link FormatProcessor} format specification used and exceptions thrown are the\n+ * same as those of {@link Formatter}.\n+ * <p>\n+ * However, there are two significant differences related to the position of arguments.\n+ * An explict {@code n$} and relative {@code <} index will cause an exception due to\n+ * a missing argument list.\n+ * Whitespace appearing between the specification and the embedded expression will\n+ * also cause an exception.\n+ * <p>\n+ * {@link FormatProcessor} allows the use of different locales. For example:\n+ * {@snippet :\n+ * Locale locale = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n+ * FormatProcessor thaiFMT = FormatProcessor.create(locale);\n+ * int x = 10;\n+ * int y = 20;\n+ * String result = thaiFMT.\"%4d\\{x} + %4d\\{y} = %5d\\{x + y}\";\n+ * }\n+ * In the above example, the value of {@code result} will be\n+ * {@code \"  \\u0E51\\u0E50 +   \\u0E52\\u0E50 =    \\u0E53\\u0E50\"}.\n+ * <p>\n+ * For day to day use, the predefined {@link FormatProcessor#FMT} {@link FormatProcessor}\n+ * is available. {@link FormatProcessor#FMT} is defined using the {@link Locale#ROOT}.\n+ * Example: {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n+ * }\n+ * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n+ *\n+ * @since 21\n+ *\n+ * @see Processor\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public final class FormatProcessor implements Processor<String, RuntimeException>, Linkage {\n+    \/**\n+     * {@link Locale} used to format\n+     *\/\n+    private final Locale locale;\n+\n+    \/**\n+     * Constructor.\n+     *\n+     * @param locale  {@link Locale} used to format\n+     *\/\n+    private FormatProcessor(Locale locale) {\n+        this.locale = locale;\n+    }\n+\n+    \/**\n+     * Create a new {@link FormatProcessor} using the specified locale.\n+     *\n+     * @param locale {@link Locale} used to format\n+     *\n+     * @return a new instance of {@link FormatProcessor}\n+     *\n+     * @throws java.lang.NullPointerException if locale is null\n+     *\/\n+    public static FormatProcessor create(Locale locale) {\n+        Objects.requireNonNull(locale);\n+        return new FormatProcessor(locale);\n+    }\n+\n+    \/**\n+     * Constructs a {@link String} based on the fragments, format\n+     * specifications found in the fragments and values in the\n+     * supplied {@link StringTemplate} object. This method constructs a\n+     * format string from the fragments, gathers up the values and\n+     * evaluates the expression asif evaulating\n+     * {@code new Formatter(locale).format(format, values).toString()}.\n+     * <p>\n+     * If an embedded expression is not immediately preceded by a\n+     * specifier then a {@code %s} is inserted in the format.\n+     *\n+     * @param stringTemplate  a {@link StringTemplate} instance\n+     *\n+     * @return constructed {@link String}\n+\n+     * @throws  IllegalFormatException\n+     *          If a format specifier contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          a specifier not followed immediately by an embedded expression or\n+     *          other illegal conditions. For specification of all possible\n+     *          formatting errors, see the\n+     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n+     *          section of the formatter class specification.\n+     *\n+     * @see java.util.Formatter\n+     *\/\n+    @Override\n+    public final String process(StringTemplate stringTemplate) {\n+        Objects.requireNonNull(stringTemplate);\n+        String format = stringTemplateFormat(stringTemplate.fragments());\n+        Object[] values = stringTemplate.values().toArray();\n+\n+        return new Formatter(locale).format(format, values).toString();\n+    }\n+\n+    \/**\n+     * Constructs a {@link MethodHandle} that when supplied with the values from\n+     * a {@link StringTemplate} will produce a result equivalent to that provided by\n+     * {@link FormatProcessor#process(StringTemplate)}. This {@link MethodHandle}\n+     * is used by {@link FormatProcessor#FMT} and the ilk to perform a more\n+     * specialized composition of a result. This is specialization is done by\n+     * prescanning the fragments and value types of a {@link StringTemplate}.\n+     * <p>\n+     * Process template expressions can be specialized  when the processor is\n+     * of type {@link Linkage} and fetched from a static constant as is\n+     * {@link FormatProcessor#FMT} ({@code static final FormatProcessor}).\n+     * <p>\n+     * Other {@link FormatProcessor FormatProcessors} can be specialized when stored in a static\n+     * final.\n+     * For example:\n+     * {@snippet :\n+     * FormatProcessor THAI_FMT = FormatProcessor.create(Locale.forLanguageTag(\"th-TH-u-nu-thai\"));\n+     * }\n+     * {@code THAI_FMT} will now produce specialized {@link MethodHandle MethodHandles} by way\n+     * of {@link FormatProcessor#linkage(List, MethodType)}.\n+     *\n+     * See {@link FormatProcessor#process(StringTemplate)} for more information.\n+     *\n+     * @throws  IllegalFormatException\n+     *          If a format specifier contains an illegal syntax, a format\n+     *          specifier that is incompatible with the given arguments,\n+     *          a specifier not followed immediately by an embedded expression or\n+     *          other illegal conditions. For specification of all possible\n+     *          formatting errors, see the\n+     *          <a href=\"..\/util\/Formatter.html#detail\">details<\/a>\n+     *          section of the formatter class specification.\n+     *\n+     * @see java.util.Formatter\n+     *\/\n+    @Override\n+    public MethodHandle linkage(List<String> fragments, MethodType type) {\n+        Objects.requireNonNull(fragments);\n+        Objects.requireNonNull(type);\n+        String format = stringTemplateFormat(fragments);\n+        Class<?>[] ptypes = type.dropParameterTypes(0, 1).parameterArray();\n+        MethodHandle mh = new FormatterBuilder(format, locale, ptypes).build();\n+        mh = MethodHandles.dropArguments(mh, 0, type.parameterType(0));\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * Find a format specification at the end of a fragment.\n+     *\n+     * @param fragment  fragment to check\n+     * @param needed    if the specification is needed\n+     *\n+     * @return true if the specification is found and needed\n+     *\n+     * @throws MissingFormatArgumentException if not at end or found and not needed\n+     *\/\n+    private static boolean findFormat(String fragment, boolean needed) {\n+        Matcher matcher = Formatter.FORMAT_SPECIFIER_PATTERN.matcher(fragment);\n+        String group;\n+\n+        while (matcher.find()) {\n+            group = matcher.group();\n+\n+            if (!group.equals(\"%%\") && !group.equals(\"%n\")) {\n+                if (matcher.end() == fragment.length() && needed) {\n+                    return true;\n+                }\n+\n+                throw new MissingFormatArgumentException(group +\n+                        \" is not immediately followed by an embedded expression\");\n+            }\n+        }\n+\n+        return false;\n+    }\n+\n+    \/**\n+     * Convert {@link StringTemplate} fragments, containing format specifications,\n+     * to a form that can be passed on to {@link Formatter}. The method scans each fragment,\n+     * matching up formatter specifications with the following expression. If no\n+     * specification is found, the method inserts \"%s\".\n+     *\n+     * @param fragments  string template fragments\n+     *\n+     * @return  format string\n+     *\/\n+    private static String stringTemplateFormat(List<String> fragments) {\n+        StringBuilder sb = new StringBuilder();\n+        int lastIndex = fragments.size() - 1;\n+        List<String> formats = fragments.subList(0, lastIndex);\n+        String last = fragments.get(lastIndex);\n+\n+        for (String format : formats) {\n+            if (findFormat(format, true)) {\n+                sb.append(format);\n+            } else {\n+                sb.append(format);\n+                sb.append(\"%s\");\n+            }\n+        }\n+\n+        if (!findFormat(last, false)) {\n+            sb.append(last);\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    \/**\n+     * This predefined {@link FormatProcessor} instance constructs a {@link String} result using\n+     * the Locale.ROOT {@link Locale}. See {@link FormatProcessor} for more details.\n+     * Example: {@snippet :\n+     * int x = 10;\n+     * int y = 20;\n+     * String result = FMT.\"0x%04x\\{x} + 0x%04x\\{y} = 0x%04x\\{x + y}\"; \/\/ @highlight substring=\"FMT\"\n+     * }\n+     * In the above example, the value of {@code result} will be {@code \"0x000a + 0x0014 = 0x001E\"}.\n+     *\n+     * @see java.util.FormatProcessor\n+     *\/\n+    public static final FormatProcessor FMT = FormatProcessor.create(Locale.ROOT);\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":284,"deletions":0,"binary":false,"changes":284,"status":"added"},{"patch":"@@ -39,0 +39,1 @@\n+import java.lang.invoke.MethodHandle;\n@@ -63,0 +64,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -2770,2 +2772,1 @@\n-        for (int i = 0; i < fsa.size(); i++) {\n-            var fs = fsa.get(i);\n+        for (FormatString fs : fsa) {\n@@ -2789,1 +2790,1 @@\n-                    default -> {  \/\/ explicit index\n+                    default -> { \/\/ explicit index\n@@ -2804,1 +2805,1 @@\n-    private static final String formatSpecifier\n+    static final String FORMAT_SPECIFIER\n@@ -2807,1 +2808,1 @@\n-    private static final Pattern fsPattern = Pattern.compile(formatSpecifier);\n+    static final Pattern FORMAT_SPECIFIER_PATTERN = Pattern.compile(FORMAT_SPECIFIER);\n@@ -2812,1 +2813,1 @@\n-    private List<FormatString> parse(String s) {\n+    static List<FormatString> parse(String s) {\n@@ -2840,1 +2841,1 @@\n-                    m = fsPattern.matcher(s);\n+                    m = FORMAT_SPECIFIER_PATTERN.matcher(s);\n@@ -2855,1 +2856,1 @@\n-    private interface FormatString {\n+    interface FormatString {\n@@ -2891,1 +2892,2 @@\n-    private static class FormatSpecifier implements FormatString {\n+    static class FormatSpecifier implements FormatString {\n+        private static final double SCALEUP = Math.scalb(1.0, 54);\n@@ -2893,6 +2895,6 @@\n-        private int index = 0;\n-        private int flags = Flags.NONE;\n-        private int width = -1;\n-        private int precision = -1;\n-        private boolean dt = false;\n-        private char c;\n+        int index = 0;\n+        int flags = Flags.NONE;\n+        int width = -1;\n+        int precision = -1;\n+        boolean dt = false;\n+        char c;\n@@ -3548,1 +3550,0 @@\n-                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3550,0 +3551,1 @@\n+                localizedMagnitude(fmt, sb, mant, 0, flags, newW, l);\n@@ -3719,2 +3721,1 @@\n-                    double scaleUp = Math.scalb(1.0, 54);\n-                    d *= scaleUp;\n+                    d *= SCALEUP;\n@@ -4623,1 +4624,1 @@\n-    private static class Flags {\n+    static class Flags {\n@@ -4701,1 +4702,1 @@\n-    private static class Conversion {\n+    static class Conversion {\n@@ -4826,1 +4827,1 @@\n-    private static class DateTime {\n+    static class DateTime {\n@@ -4877,0 +4878,1 @@\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":23,"deletions":21,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -0,0 +1,485 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.util;\n+\n+import java.io.IOException;\n+import java.lang.invoke.*;\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.text.DecimalFormat;\n+import java.text.DecimalFormatSymbols;\n+import java.text.NumberFormat;\n+import java.text.spi.NumberFormatProvider;\n+import java.util.FormatItem.*;\n+import java.util.Formatter.*;\n+\n+import jdk.internal.javac.PreviewFeature;\n+import jdk.internal.util.FormatConcatItem;\n+\n+import sun.invoke.util.Wrapper;\n+import sun.util.locale.provider.LocaleProviderAdapter;\n+import sun.util.locale.provider.ResourceBundleBasedAdapter;\n+\n+import static java.util.Formatter.Conversion.*;\n+import static java.util.Formatter.Flags.*;\n+import static java.lang.invoke.MethodHandles.*;\n+import static java.lang.invoke.MethodType.*;\n+\n+\/**\n+ * This package private class supports the construction of the {@link MethodHandle}\n+ * used by {@link FormatProcessor}.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class FormatterBuilder {\n+    private static final Lookup LOOKUP = lookup();\n+\n+    private final String format;\n+    private final Locale locale;\n+    private final Class<?>[] ptypes;\n+    private final DecimalFormatSymbols dfs;\n+    private final boolean isGenericDFS;\n+\n+    FormatterBuilder(String format, Locale locale, Class<?>[] ptypes) {\n+        this.format = format;\n+        this.locale = locale;\n+        this.ptypes = ptypes;\n+        this.dfs = DecimalFormatSymbols.getInstance(locale);\n+        this.isGenericDFS = isGenericDFS(this.dfs);\n+    }\n+\n+    private static boolean isGenericDFS(DecimalFormatSymbols dfs) {\n+        return dfs.getZeroDigit() == '0' &&\n+               dfs.getDecimalSeparator() == '.' &&\n+               dfs.getGroupingSeparator() == ',' &&\n+               dfs.getMinusSign() == '-';\n+    }\n+\n+    private static Class<?> mapType(Class<?> type) {\n+        return type.isPrimitive() || type == String.class ? type : Object.class;\n+    }\n+\n+    private static MethodHandle findStringConcatItemConstructor(Class<?> cls,\n+                                          Class<?>... ptypes) {\n+        MethodType methodType = methodType(void.class, ptypes);\n+\n+        try {\n+            MethodHandle mh = LOOKUP.findConstructor(cls, methodType);\n+\n+            return mh.asType(mh.type().changeReturnType(FormatConcatItem.class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Missing constructor in \" +\n+                    cls + \": \" + methodType);\n+        }\n+    }\n+\n+    private static MethodHandle findMethod(Class<?> cls, String name,\n+                                           Class<?> rType, Class<?>... ptypes) {\n+        MethodType methodType = methodType(rType, ptypes);\n+\n+        try {\n+            return LOOKUP.findVirtual(cls, name, methodType);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Missing method in \" +\n+                    cls + \": \" + name + \" \" + methodType);\n+        }\n+    }\n+\n+    private static MethodHandle findStaticMethod(Class<?> cls, String name,\n+                                                 Class<?> rType, Class<?>... ptypes) {\n+        MethodType methodType = methodType(rType, ptypes);\n+\n+        try {\n+            return LOOKUP.findStatic(cls, name, methodType);\n+        } catch (ReflectiveOperationException e) {\n+            throw new AssertionError(\"Missing static method in \" +\n+                    cls + \": \" + name + \" \" + methodType);\n+        }\n+    }\n+\n+    private static final MethodHandle FIDecimal_MH =\n+            findStringConcatItemConstructor(FormatItemDecimal.class,\n+                    DecimalFormatSymbols.class, int.class, char.class, boolean.class,\n+                    int.class, long.class);\n+\n+    private static final MethodHandle FIHexadecimal_MH =\n+            findStringConcatItemConstructor(FormatItemHexadecimal.class,\n+                    int.class, boolean.class, long.class);\n+\n+    private static final MethodHandle FIOctal_MH =\n+            findStringConcatItemConstructor(FormatItemOctal.class,\n+                    int.class, boolean.class, long.class);\n+\n+    private static final MethodHandle FIBoolean_MH =\n+            findStringConcatItemConstructor(FormatItemBoolean.class,\n+                    boolean.class);\n+\n+    private static final MethodHandle FICharacter_MH =\n+            findStringConcatItemConstructor(FormatItemCharacter.class,\n+                    char.class);\n+\n+    private static final MethodHandle FIString_MH =\n+            findStringConcatItemConstructor(FormatItemString.class,\n+                    String.class);\n+\n+    private static final MethodHandle FIFormatSpecifier_MH =\n+            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n+                    FormatSpecifier.class, Locale.class, Object.class);\n+\n+    private static final MethodHandle FIFormattable_MH =\n+            findStringConcatItemConstructor(FormatItemFormatSpecifier.class,\n+                    Locale.class, int.class, int.class, int.class,\n+                    Formattable.class);\n+\n+    private static final MethodHandle FIFillLeft_MH =\n+             findStringConcatItemConstructor(FormatItemFillLeft.class,\n+                    int.class, FormatConcatItem.class);\n+\n+    private static final MethodHandle FIFillRight_MH =\n+            findStringConcatItemConstructor(FormatItemFillRight.class,\n+                     int.class, FormatConcatItem.class);\n+\n+    private static final MethodHandle FINull_MH =\n+            findStringConcatItemConstructor(FormatItemNull.class);\n+\n+    private static final MethodHandle NullCheck_MH =\n+            findStaticMethod(FormatterBuilder.class, \"nullCheck\", boolean.class,\n+                    Object.class);\n+\n+    private static final MethodHandle FormattableCheck_MH =\n+            findStaticMethod(FormatterBuilder.class, \"formattableCheck\", boolean.class,\n+                    Object.class);\n+\n+    private static final MethodHandle ToLong_MH =\n+            findStaticMethod(java.util.FormatterBuilder.class, \"toLong\", long.class,\n+                    int.class);\n+\n+    private static final MethodHandle ToString_MH =\n+            findStaticMethod(String.class, \"valueOf\", String.class,\n+                    Object.class);\n+\n+    private static final MethodHandle HashCode_MH =\n+            findStaticMethod(Objects.class, \"hashCode\", int.class,\n+                    Object.class);\n+\n+    private static boolean nullCheck(Object object) {\n+        return object == null;\n+    }\n+\n+    private static boolean formattableCheck(Object object) {\n+        return Formattable.class.isAssignableFrom(object.getClass());\n+    }\n+\n+    private static long toLong(int value) {\n+        return (long)value & 0xFFFFFFFFL;\n+    }\n+\n+    private static boolean isFlag(int value, int flags) {\n+        return (value & flags) != 0;\n+    }\n+\n+    private static boolean validFlags(int value, int flags) {\n+        return (value & ~flags) == 0;\n+    }\n+\n+    private static int groupSize(Locale locale, DecimalFormatSymbols dfs) {\n+        if (isGenericDFS(dfs)) {\n+            return 3;\n+        }\n+\n+        DecimalFormat df;\n+        NumberFormat nf = NumberFormat.getNumberInstance(locale);\n+\n+        if (nf instanceof DecimalFormat) {\n+            df = (DecimalFormat)nf;\n+        } else {\n+            LocaleProviderAdapter adapter = LocaleProviderAdapter\n+                    .getAdapter(NumberFormatProvider.class, locale);\n+\n+            if (!(adapter instanceof ResourceBundleBasedAdapter)) {\n+                adapter = LocaleProviderAdapter.getResourceBundleBased();\n+            }\n+\n+            String[] all = adapter.getLocaleResources(locale)\n+                    .getNumberPatterns();\n+\n+            df = new DecimalFormat(all[0], dfs);\n+        }\n+\n+        return df.isGroupingUsed() ? df.getGroupingSize() : 0;\n+    }\n+\n+    private MethodHandle formatSpecifier(FormatSpecifier fs, Class<?> ptype) {\n+        boolean isPrimitive = ptype.isPrimitive();\n+        MethodHandle mh = identity(ptype);\n+        MethodType mt = mh.type();\n+\n+\/\/cannot cast to primitive types as it breaks null values formatting\n+\/\/        if (ptype == byte.class || ptype == short.class ||\n+\/\/            ptype == Byte.class || ptype == Short.class ||\n+\/\/            ptype == Integer.class) {\n+\/\/            mt = mt.changeReturnType(int.class);\n+\/\/        } else if (ptype == Long.class) {\n+\/\/            mt = mt.changeReturnType(long.class);\n+\/\/        } else if (ptype == float.class || ptype == Float.class ||\n+\/\/                   ptype == Double.class) {\n+\/\/            mt = mt.changeReturnType(double.class);\n+\/\/        } else if (ptype == Boolean.class) {\n+\/\/            mt = mt.changeReturnType(boolean.class);\n+\/\/        } else if (ptype == Character.class) {\n+\/\/            mt = mt.changeReturnType(char.class);\n+\/\/        }\n+\n+        Class<?> itype = mt.returnType();\n+\n+        if (itype != ptype) {\n+            mh = explicitCastArguments(mh, mt);\n+        }\n+\n+        boolean handled = false;\n+        int flags = fs.flags;\n+        int width = fs.width;\n+        int precision = fs.precision;\n+        Character conv = fs.dt ? 't' : fs.c;\n+\n+        switch (Character.toLowerCase(conv)) {\n+            case BOOLEAN -> {\n+                if (itype == boolean.class && precision == -1) {\n+                    if (flags == 0 && width == -1 && isPrimitive) {\n+                        return null;\n+                    }\n+\n+                    if (validFlags(flags, LEFT_JUSTIFY)) {\n+                        handled = true;\n+                        mh = filterReturnValue(mh, FIBoolean_MH);\n+                    }\n+                }\n+            }\n+            case STRING -> {\n+                if (flags == 0 && width == -1 && precision == -1) {\n+                    if (isPrimitive || ptype == String.class) {\n+                        return null;\n+                    } else if (itype.isPrimitive()) {\n+                        return mh;\n+                    }\n+                }\n+\n+                if (validFlags(flags, LEFT_JUSTIFY) && precision == -1) {\n+                    if (itype == String.class) {\n+                        handled = true;\n+                        mh = filterReturnValue(mh, FIString_MH);\n+                    } else if (!itype.isPrimitive()) {\n+                        handled = true;\n+                        MethodHandle test = FormattableCheck_MH;\n+                        test = test.asType(test.type().changeParameterType(0, ptype));\n+                        MethodHandle pass = insertArguments(FIFormattable_MH,\n+                                0, locale, flags, width, precision);\n+                        pass = pass.asType(pass.type().changeParameterType(0, ptype));\n+                        MethodHandle fail = ToString_MH;\n+                        fail = filterReturnValue(fail, FIString_MH);\n+                        fail = fail.asType(fail.type().changeParameterType(0, ptype));\n+                        mh = guardWithTest(test, pass, fail);\n+                    }\n+                }\n+            }\n+            case CHARACTER -> {\n+                if (itype == char.class && precision == -1) {\n+                    if (flags == 0 && width == -1) {\n+                        return isPrimitive ? null : mh;\n+                    }\n+\n+                    if (validFlags(flags, LEFT_JUSTIFY)) {\n+                        handled = true;\n+                        mh = filterReturnValue(mh, FICharacter_MH);\n+                    }\n+                }\n+            }\n+            case DECIMAL_INTEGER -> {\n+                if ((itype == int.class || itype == long.class) && precision == -1) {\n+                    if (itype == int.class) {\n+                        mh = explicitCastArguments(mh,\n+                                mh.type().changeReturnType(long.class));\n+                    }\n+\n+                    if (flags == 0 && isGenericDFS && width == -1) {\n+                        return mh;\n+                    } else if (validFlags(flags, PLUS | LEADING_SPACE |\n+                                                 ZERO_PAD | GROUP |\n+                                                 PARENTHESES)) {\n+                        handled = true;\n+                        int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n+                        char sign = isFlag(flags, PLUS)          ? '+' :\n+                                    isFlag(flags, LEADING_SPACE) ? ' ' : '\\0';\n+                        boolean parentheses = isFlag(flags, PARENTHESES);\n+                        int groupSize = isFlag(flags, GROUP) ?\n+                                groupSize(locale, dfs) : 0;\n+                        mh = filterReturnValue(mh,\n+                                insertArguments(FIDecimal_MH, 0, dfs, zeroPad,\n+                                        sign, parentheses, groupSize));\n+                    }\n+                }\n+            }\n+            case OCTAL_INTEGER -> {\n+                if ((itype == int.class || itype == long.class) &&\n+                         precision == -1 &&\n+                         validFlags(flags, ZERO_PAD | ALTERNATE)) {\n+                    handled = true;\n+\n+                    if (itype == int.class) {\n+                        mh = filterReturnValue(mh, ToLong_MH);\n+                    }\n+\n+                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n+                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIOctal_MH, 0, zeroPad, hasPrefix));\n+                }\n+            }\n+            case HEXADECIMAL_INTEGER -> {\n+                if ((itype == int.class || itype == long.class) &&\n+                        precision == -1 &&\n+                        validFlags(flags, ZERO_PAD | ALTERNATE)) {\n+                    handled = true;\n+\n+                    if (itype == int.class) {\n+                        mh = filterReturnValue(mh, ToLong_MH);\n+                    }\n+\n+                    int zeroPad = isFlag(flags, ZERO_PAD) ? width : -1;\n+                    boolean hasPrefix = isFlag(flags, ALTERNATE);\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIHexadecimal_MH, 0, zeroPad, hasPrefix));\n+                }\n+            }\n+        }\n+\n+        if (handled) {\n+            if (!isPrimitive) {\n+                MethodHandle test = NullCheck_MH.asType(\n+                        NullCheck_MH.type().changeParameterType(0, ptype));\n+                MethodHandle pass = dropArguments(FINull_MH, 0, ptype);\n+                mh = guardWithTest(test, pass, mh);\n+            }\n+\n+            if (0 < width) {\n+                if (isFlag(flags, LEFT_JUSTIFY)) {\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIFillRight_MH, 0, width));\n+                } else {\n+                    mh = filterReturnValue(mh,\n+                            insertArguments(FIFillLeft_MH, 0, width));\n+                }\n+            }\n+\n+            if (!isFlag(flags, UPPERCASE)) {\n+                return mh;\n+            }\n+        }\n+\n+        mh = insertArguments(FIFormatSpecifier_MH, 0, fs, locale);\n+        mh = mh.asType(mh.type().changeParameterType(0, ptype));\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * Construct concat {@link MethodHandle} for based on format.\n+     *\n+     * @param fsa  list of specifiers\n+     *\n+     * @return concat {@link MethodHandle} for based on format\n+     *\/\n+    private MethodHandle buildFilters(List<FormatString> fsa,\n+                                      List<String> segments,\n+                                      MethodHandle[] filters) {\n+        MethodHandle mh = null;\n+        int iParam = 0;\n+        StringBuilder segment = new StringBuilder();\n+\n+        for (FormatString fs : fsa) {\n+            int index = fs.index();\n+\n+            switch (index) {\n+                case -2:  \/\/ fixed string, \"%n\", or \"%%\"\n+                    String string = fs.toString();\n+\n+                    if (\"%%\".equals(string)) {\n+                        segment.append('%');\n+                    } else if (\"%n\".equals(string)) {\n+                        segment.append(System.lineSeparator());\n+                    } else {\n+                        segment.append(string);\n+                    }\n+                    break;\n+                case 0:  \/\/ ordinary index\n+                    segments.add(segment.toString());\n+                    segment.setLength(0);\n+\n+                    if (iParam < ptypes.length) {\n+                        Class<?> ptype = ptypes[iParam];\n+                        filters[iParam++] = formatSpecifier((FormatSpecifier)fs, ptype);\n+                    } else {\n+                        throw new MissingFormatArgumentException(fs.toString());\n+                    }\n+                    break;\n+                case -1:  \/\/ relative index\n+                default:  \/\/ explicit index\n+                    throw new IllegalFormatFlagsException(\"Indexing not allowed: \" + fs.toString());\n+            }\n+        }\n+\n+        segments.add(segment.toString());\n+\n+        return mh;\n+    }\n+\n+    \/**\n+     * Build a {@link MethodHandle} to format arguments.\n+     *\n+     * @return new {@link MethodHandle} to format arguments\n+     *\/\n+    MethodHandle build() {\n+        List<String> segments = new ArrayList<>();\n+        MethodHandle[] filters = new MethodHandle[ptypes.length];\n+        buildFilters(Formatter.parse(format), segments, filters);\n+        Class<?>[] ftypes = new Class<?>[filters.length];\n+\n+        for (int i = 0; i < filters.length; i++) {\n+            MethodHandle filter = filters[i];\n+            ftypes[i] = filter == null ? ptypes[i] : filter.type().returnType();\n+        }\n+\n+        try {\n+            MethodHandle mh = StringConcatFactory.makeConcatWithTemplate(segments,\n+                    List.of(ftypes));\n+            mh = filterArguments(mh, 0, filters);\n+\n+            return mh;\n+        } catch (StringConcatException ex) {\n+            throw new AssertionError(\"concat fail\", ex);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":485,"deletions":0,"binary":false,"changes":485,"status":"added"},{"patch":"@@ -48,0 +48,1 @@\n+import jdk.internal.javac.PreviewFeature;\n@@ -423,0 +424,18 @@\n+   \/**\n+    * Get the coder for the supplied character.\n+    *\/\n+   @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+   long stringConcatCoder(char value);\n+\n+   \/**\n+    * Update lengthCoder for StringBuilder.\n+    *\/\n+   @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+   long stringBuilderConcatMix(long lengthCoder, StringBuilder sb);\n+\n+    \/**\n+     * Prepend StringBuilder content.\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+   long stringBuilderConcatPrepend(long lengthCoder, byte[] buf, StringBuilder sb);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":19,"deletions":0,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.access;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.List;\n+\n+public interface JavaTemplateAccess {\n+\n+    \/**\n+     * Returns a StringTemplate composed from fragments and values.\n+     *\n+     * @implSpec The {@code fragments} list size must be one more that the\n+     * {@code values} list size.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from fragments and values\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n+     *\n+     * @implNote Contents of both lists are copied to construct immutable lists.\n+     *\/\n+    StringTemplate of(List<String> fragments, List<?> values);\n+\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\/\n+    String interpolate(List<String> fragments, List<?> values);\n+\n+    \/**\n+     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n+     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n+     * }\n+     *\n+     * @param sts  zero or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if sts is null or if any element of sts is null\n+     *\/\n+    StringTemplate combine(StringTemplate... sts);\n+\n+}\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaTemplateAccess.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -92,0 +92,1 @@\n+    private static JavaTemplateAccess javaTemplateAccess;\n@@ -519,0 +520,15 @@\n+    public static void setJavaTemplateAccess(JavaTemplateAccess jta) {\n+        javaTemplateAccess = jta;\n+    }\n+\n+    public static JavaTemplateAccess getJavaTemplateAccess() {\n+        var access = javaTemplateAccess;\n+        if (access == null) {\n+            try {\n+                Class.forName(\"java.lang.runtime.TemplateSupport\", true, null);\n+                access = javaTemplateAccess;\n+            } catch (ClassNotFoundException e) {}\n+        }\n+        return access;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+        @JEP(number=430, title=\"String Templates\", status=\"First Preview\")\n+        STRING_TEMPLATES,\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.internal.util;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * Implementations of this class provide information necessary to\n+ * assist {@link java.lang.invoke.StringConcatFactory} perform optimal\n+ * insertion.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public interface FormatConcatItem {\n+    \/**\n+     * Calculate the length of the insertion.\n+     *\n+     * @param lengthCoder current value of the length + coder\n+     * @return adjusted value of the length + coder\n+     *\/\n+    long mix(long lengthCoder);\n+\n+    \/**\n+     * Insert content into buffer prior to the current length.\n+     *\n+     * @param lengthCoder current value of the length + coder\n+     * @param buffer      buffer to append to\n+     *\n+     * @return adjusted value of the length + coder\n+     *\n+     * @throws Throwable if fails to prepend value (unusual).\n+     *\/\n+    long prepend(long lengthCoder, byte[] buffer) throws Throwable;\n+}\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/FormatConcatItem.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.util.Collections;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ClassTree.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.source.tree;\n+\n+import java.util.List;\n+\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * A tree node for a string template expression.\n+ *\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+public interface StringTemplateTree extends ExpressionTree {\n+    \/**\n+     * Returns templated string processor (may be qualified) or null.\n+     *\n+     * @return templated string processor\n+     *\/\n+    ExpressionTree getProcessor();\n+\n+    \/**\n+     * Returns string fragments.\n+     *\n+     * @return string fragments\n+     *\/\n+    List<String> getFragments();\n+\n+    \/**\n+     * Returns list of expressions.\n+     *\n+     * @return list of expressions\n+     *\/\n+    List<? extends ExpressionTree> getExpressions();\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/StringTemplateTree.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -178,0 +178,6 @@\n+        \/**\n+         * Used for instances of {@link StringTemplateTree}.\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+        TEMPLATE(StringTemplateTree.class),\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/Tree.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -262,0 +262,9 @@\n+    \/**\n+     * Visits a StringTemplateTree node.\n+     * @param node the node being visited\n+     * @param p a parameter value\n+     * @return a result value\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+    R visitStringTemplate(StringTemplateTree node, P p);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/TreeVisitor.java","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -631,0 +631,13 @@\n+    \/**\n+     * {@inheritDoc} This implementation calls {@code defaultAction}.\n+     *\n+     * @param node {@inheritDoc}\n+     * @param p {@inheritDoc}\n+     * @return  the result of {@code defaultAction}\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+    public R visitStringTemplate(StringTemplateTree node, P p) {\n+        return defaultAction(node, p);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/SimpleTreeVisitor.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -762,0 +762,17 @@\n+    \/**\n+     * {@inheritDoc}\n+     *\n+     * @implSpec This implementation scans the children in left to right order.\n+     *\n+     * @param node  {@inheritDoc}\n+     * @param p  {@inheritDoc}\n+     * @return the result of scanning\n+     *\/\n+    @Override\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES, reflective=true)\n+    public R visitStringTemplate(StringTemplateTree node, P p) {\n+        R r = scan(node.getProcessor(), p);\n+        r = scanAndReduce(node.getExpressions(), p, r);\n+        return r;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/util\/TreeScanner.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -214,0 +214,1 @@\n+            case STRING_TEMPLATES -> true;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Preview.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -237,0 +237,1 @@\n+        STRING_TEMPLATES(JDK21, Fragments.FeatureStringTemplates, DiagKind.PLURAL),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Source.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -177,0 +177,1 @@\n+    public final Type methodHandlesType;\n@@ -237,0 +238,6 @@\n+    \/\/ For string templates\n+    public final Type stringTemplateType;\n+    public final Type templateRuntimeType;\n+    public final Type processorType;\n+    public final Type linkageType;\n+\n@@ -545,0 +552,1 @@\n+        methodHandlesType = enterClass(\"java.lang.invoke.MethodHandles\");\n@@ -612,1 +620,0 @@\n-\n@@ -623,0 +630,6 @@\n+        \/\/ For string templates\n+        stringTemplateType = enterClass(\"java.lang.StringTemplate\");\n+        templateRuntimeType = enterClass(\"java.lang.runtime.TemplateRuntime\");\n+        processorType = enterClass(\"java.lang.StringTemplate$Processor\");\n+        linkageType = enterClass(\"java.lang.StringTemplate$Processor$Linkage\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -4986,0 +4986,21 @@\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        JCExpression processor = tree.processor;\n+        Type resultType = syms.stringTemplateType;\n+\n+        if (processor != null) {\n+            resultType = attribTree(processor, env, new ResultInfo(KindSelector.VAL, Type.noType));\n+            resultType = chk.checkProcessorType(processor, resultType, env);\n+        }\n+\n+        Env<AttrContext> localEnv = env.dup(tree, env.info.dup());\n+\n+        for (JCExpression arg : tree.expressions) {\n+            chk.checkNonVoid(arg.pos(), attribExpr(arg, localEnv));\n+        }\n+\n+        tree.type = resultType;\n+        result = resultType;\n+\n+        check(tree, resultType, KindSelector.VAL, resultInfo);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -120,0 +120,2 @@\n+    public boolean disablePreviewCheck;\n+\n@@ -157,0 +159,2 @@\n+        disablePreviewCheck = false;\n+\n@@ -3795,1 +3799,1 @@\n-        if ((s.flags() & PREVIEW_API) != 0 && !preview.participatesInPreview(syms, other, s)) {\n+        if ((s.flags() & PREVIEW_API) != 0 && !preview.participatesInPreview(syms, other, s) && !disablePreviewCheck) {\n@@ -4313,0 +4317,21 @@\n+    public Type checkProcessorType(JCExpression processor, Type resultType, Env<AttrContext> env) {\n+        Type processorType = processor.type;\n+        Type interfaceType = types.asSuper(processorType, syms.processorType.tsym);\n+\n+        if (interfaceType != null) {\n+            List<Type> typeArguments = interfaceType.getTypeArguments();\n+\n+            if (typeArguments.size() == 2) {\n+                resultType = typeArguments.head;\n+            } else {\n+                log.error(DiagnosticFlag.RESOLVE_ERROR, processor.pos,\n+                        Errors.ProcessorTypeCannotBeARawType(processorType.tsym));\n+            }\n+        } else {\n+            log.error(DiagnosticFlag.RESOLVE_ERROR, processor.pos,\n+                    Errors.NotAProcessorType(processorType.tsym));\n+        }\n+\n+        return resultType;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":26,"deletions":1,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -62,4 +62,5 @@\n-        TRANSPATTERNS(7),\n-        UNLAMBDA(8),\n-        LOWER(9),\n-        GENERATE(10);\n+        TRANSLITERALS(7),\n+        TRANSPATTERNS(8),\n+        UNLAMBDA(9),\n+        LOWER(10),\n+        GENERATE(11);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/CompileStates.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1529,0 +1529,24 @@\n+        @Override\n+        public void visitStringTemplate(JCStringTemplate tree) {\n+            JCExpression processor = tree.processor;\n+\n+            if (processor != null) {\n+                scan(processor);\n+                Type interfaceType = types.asSuper(processor.type, syms.processorType.tsym);\n+\n+                if (interfaceType != null) {\n+                    List<Type> typeArguments = interfaceType.getTypeArguments();\n+\n+                    if (typeArguments.size() == 2) {\n+                        Type throwType = typeArguments.tail.head;\n+\n+                        if (throwType != null) {\n+                            markThrown(tree, throwType);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            scan(tree.expressions);\n+        }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,344 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package com.sun.tools.javac.comp;\n+\n+import com.sun.tools.javac.code.Flags;\n+import com.sun.tools.javac.code.Symbol;\n+import com.sun.tools.javac.code.Symbol.ClassSymbol;\n+import com.sun.tools.javac.code.Symbol.DynamicMethodSymbol;\n+import com.sun.tools.javac.code.Symbol.MethodSymbol;\n+import com.sun.tools.javac.code.Symbol.VarSymbol;\n+import com.sun.tools.javac.code.Symtab;\n+import com.sun.tools.javac.code.Type;\n+import com.sun.tools.javac.code.Type.*;\n+import com.sun.tools.javac.code.Types;\n+import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;\n+import com.sun.tools.javac.tree.JCTree;\n+import com.sun.tools.javac.tree.JCTree.*;\n+import com.sun.tools.javac.tree.TreeInfo;\n+import com.sun.tools.javac.tree.TreeMaker;\n+import com.sun.tools.javac.tree.TreeTranslator;\n+import com.sun.tools.javac.util.Context;\n+import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;\n+import com.sun.tools.javac.util.List;\n+import com.sun.tools.javac.util.Name;\n+import com.sun.tools.javac.util.Names;\n+\n+import java.util.Iterator;\n+\n+\/** This pass translates constructed literals (string templates, ...) to conventional Java.\n+ *\n+ *  <p><b>This is NOT part of any supported API.\n+ *  If you write code that depends on this, you do so at your own risk.\n+ *  This code and its internal interfaces are subject to change or\n+ *  deletion without notice.<\/b>\n+ *\/\n+public final class TransLiterals extends TreeTranslator {\n+    \/**\n+     * The context key for the TransTypes phase.\n+     *\/\n+    protected static final Context.Key<TransLiterals> transLiteralsKey = new Context.Key<>();\n+\n+    \/**\n+     * Get the instance for this context.\n+     *\/\n+    public static TransLiterals instance(Context context) {\n+        TransLiterals instance = context.get(transLiteralsKey);\n+        if (instance == null)\n+            instance = new TransLiterals(context);\n+        return instance;\n+    }\n+\n+    private final Symtab syms;\n+    private final Resolve rs;\n+    private final Types types;\n+    private final Operators operators;\n+    private final Names names;\n+    private TreeMaker make = null;\n+    private Env<AttrContext> env = null;\n+    private ClassSymbol currentClass = null;\n+    private MethodSymbol currentMethodSym = null;\n+\n+    protected TransLiterals(Context context) {\n+        context.put(transLiteralsKey, this);\n+        syms = Symtab.instance(context);\n+        rs = Resolve.instance(context);\n+        make = TreeMaker.instance(context);\n+        types = Types.instance(context);\n+        operators = Operators.instance(context);\n+        names = Names.instance(context);\n+    }\n+\n+    JCExpression makeLit(Type type, Object value) {\n+        return make.Literal(type.getTag(), value).setType(type.constType(value));\n+    }\n+\n+    JCExpression makeString(String string) {\n+        return makeLit(syms.stringType, string);\n+    }\n+\n+    List<JCExpression> makeStringList(List<String> strings) {\n+        List<JCExpression> exprs = List.nil();\n+        for (String string : strings) {\n+            exprs = exprs.append(makeString(string));\n+        }\n+        return exprs;\n+    }\n+\n+    JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {\n+        JCBinary tree = make.Binary(optag, lhs, rhs);\n+        tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);\n+        tree.type = tree.operator.type.getReturnType();\n+        return tree;\n+    }\n+\n+    MethodSymbol lookupMethod(DiagnosticPosition pos, Name name, Type qual, List<Type> args) {\n+        return rs.resolveInternalMethod(pos, env, qual, name, args, List.nil());\n+    }\n+\n+    @Override\n+    public void visitClassDef(JCClassDecl tree) {\n+        ClassSymbol prevCurrentClass = currentClass;\n+        try {\n+            currentClass = tree.sym;\n+            super.visitClassDef(tree);\n+        } finally {\n+            currentClass = prevCurrentClass;\n+        }\n+    }\n+\n+    @Override\n+    public void visitMethodDef(JCMethodDecl tree) {\n+        MethodSymbol prevMethodSym = currentMethodSym;\n+        try {\n+            currentMethodSym = tree.sym;\n+            super.visitMethodDef(tree);\n+        } finally {\n+            currentMethodSym = prevMethodSym;\n+        }\n+    }\n+\n+    final class TransStringTemplate {\n+        final JCStringTemplate tree;\n+        final JCExpression processor;\n+        final List<String> fragments;\n+        final List<JCExpression> expressions;\n+        final List<Type> expressionTypes;\n+        final boolean useValuesList;\n+\n+        TransStringTemplate(JCStringTemplate tree) {\n+            this.tree = tree;\n+            this.processor = tree.processor;\n+            this.fragments = tree.fragments;\n+            this.expressions = translate(tree.expressions);\n+            this.expressionTypes = expressions.stream()\n+                    .map(arg -> arg.type == syms.botType ? syms.objectType : arg.type)\n+                    .collect(List.collector());\n+            int slots = expressionTypes.stream()\n+                    .mapToInt(t -> types.isSameType(t, syms.longType) ||\n+                            types.isSameType(t, syms.doubleType) ? 2 : 1).sum();\n+            this.useValuesList = 200 < slots; \/\/ StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS\n+         }\n+\n+        JCExpression concatExpression(List<String> fragments, List<JCExpression> expressions) {\n+            JCExpression expr = null;\n+            Iterator<JCExpression> iterator = expressions.iterator();\n+            for (String fragment : fragments) {\n+                expr = expr == null ? makeString(fragment)\n+                        : makeBinary(Tag.PLUS, expr, makeString(fragment));\n+                if (iterator.hasNext()) {\n+                    JCExpression expression = iterator.next();\n+                    Type expressionType = expression.type;\n+                    expr = makeBinary(Tag.PLUS, expr, expression.setType(expressionType));\n+                }\n+            }\n+            return expr;\n+        }\n+\n+        JCExpression bsmCall(Name name, Name bootstrapName, Type type,\n+                             List<JCExpression> args,\n+                             List<Type> argTypes,\n+                             List<LoadableConstant> staticArgValues,\n+                             List<Type> staticArgsTypes) {\n+            Symbol bsm = rs.resolveQualifiedMethod(tree.pos(), env,\n+                    syms.templateRuntimeType, bootstrapName, staticArgsTypes, List.nil());\n+            MethodType indyType = new MethodType(argTypes, type, List.nil(), syms.methodClass);\n+            DynamicMethodSymbol dynSym = new DynamicMethodSymbol(\n+                    name,\n+                    syms.noSymbol,\n+                    ((MethodSymbol)bsm).asHandle(),\n+                    indyType,\n+                    staticArgValues.toArray(new LoadableConstant[0])\n+            );\n+            JCFieldAccess qualifier = make.Select(make.Type(syms.processorType), dynSym.name);\n+            qualifier.sym = dynSym;\n+            qualifier.type = type;\n+            JCMethodInvocation apply = make.Apply(List.nil(), qualifier, args);\n+            apply.type = type;\n+            return apply;\n+        }\n+\n+        JCExpression processCall(JCExpression stringTemplate) {\n+            MethodSymbol appyMeth = lookupMethod(tree.pos(), names.process,\n+                    syms.processorType, List.of(syms.stringTemplateType));\n+            JCExpression applySelect = make.Select(processor, appyMeth);\n+            JCExpression process = make.Apply(null, applySelect, List.of(stringTemplate))\n+                    .setType(syms.objectType);\n+            JCTypeCast cast = make.TypeCast(tree.type, process);\n+            return cast;\n+        }\n+\n+        JCExpression newStringTemplate() {\n+            List<LoadableConstant> staticArgValues = List.nil();\n+            List<Type> staticArgsTypes =\n+                    List.of(syms.methodHandleLookupType, syms.stringType,\n+                            syms.methodTypeType);\n+            if (useValuesList) {\n+                JCNewArray fragmentArray = make.NewArray(make.Type(syms.stringType),\n+                        List.nil(), makeStringList(fragments));\n+                fragmentArray.type = new ArrayType(syms.stringType, syms.arrayClass);\n+                JCNewArray valuesArray = make.NewArray(make.Type(syms.objectType),\n+                        List.nil(), expressions);\n+                valuesArray.type = new ArrayType(syms.objectType, syms.arrayClass);\n+                return bsmCall(names.process, names.newLargeStringTemplate, syms.stringTemplateType,\n+                        List.of(fragmentArray, valuesArray),\n+                        List.of(fragmentArray.type, valuesArray.type),\n+                        staticArgValues, staticArgsTypes);\n+            } else {\n+                for (String fragment : fragments) {\n+                    staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n+                    staticArgsTypes = staticArgsTypes.append(syms.stringType);\n+                }\n+                return bsmCall(names.process, names.newStringTemplate, syms.stringTemplateType,\n+                        expressions, expressionTypes, staticArgValues, staticArgsTypes);\n+            }\n+        }\n+\n+        JCExpression bsmProcessCall() {\n+            List<JCExpression> args = expressions.prepend(processor);\n+            List<Type> argTypes = expressionTypes.prepend(processor.type);\n+            VarSymbol processorSym = (VarSymbol)TreeInfo.symbol(processor);\n+            List<LoadableConstant> staticArgValues = List.of(processorSym.asMethodHandle(true));\n+            List<Type> staticArgsTypes =\n+                    List.of(syms.methodHandleLookupType, syms.stringType,\n+                            syms.methodTypeType, syms.methodHandleType);\n+            for (String fragment : fragments) {\n+                staticArgValues = staticArgValues.append(LoadableConstant.String(fragment));\n+                staticArgsTypes = staticArgsTypes.append(syms.stringType);\n+            }\n+            return bsmCall(names.process, names.processStringTemplate, tree.type,\n+                    args, argTypes, staticArgValues, staticArgsTypes);\n+        }\n+\n+        boolean isNamedProcessor(Name name) {\n+            if (processor instanceof JCIdent ident && ident.sym instanceof VarSymbol varSym) {\n+                if (varSym.flags() == (Flags.PUBLIC | Flags.FINAL | Flags.STATIC) &&\n+                        varSym.name == name &&\n+                        types.isSameType(varSym.owner.type, syms.stringTemplateType)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        }\n+\n+        boolean isLinkageProcessor() {\n+            return processor != null &&\n+                   !useValuesList &&\n+                   types.isSubtype(processor.type, syms.linkageType) &&\n+                   processor.type.isFinal() &&\n+                   TreeInfo.symbol(processor) instanceof VarSymbol varSymbol &&\n+                   varSymbol.isStatic() &&\n+                   varSymbol.isFinal();\n+        }\n+\n+        JCExpression visit() {\n+            JCExpression result;\n+            make.at(tree.pos);\n+\n+            if (processor == null || isNamedProcessor(names.RAW)) {\n+                result = newStringTemplate();\n+            } else if (isNamedProcessor(names.STR)) {\n+                result = concatExpression(fragments, expressions);\n+            } else if (isLinkageProcessor()) {\n+                result = bsmProcessCall();\n+            } else {\n+                result = processCall(newStringTemplate());\n+            }\n+\n+            return result;\n+        }\n+    }\n+\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        int prevPos = make.pos;\n+        try {\n+            tree.processor = translate(tree.processor);\n+            tree.expressions = translate(tree.expressions);\n+\n+            TransStringTemplate transStringTemplate = new TransStringTemplate(tree);\n+\n+            result = transStringTemplate.visit();\n+        } catch (Throwable ex) {\n+            ex.printStackTrace();\n+            throw ex;\n+        } finally {\n+            make.at(prevPos);\n+        }\n+    }\n+\n+    public void visitVarDef(JCVariableDecl tree) {\n+        MethodSymbol prevMethodSym = currentMethodSym;\n+        try {\n+            tree.mods = translate(tree.mods);\n+            tree.vartype = translate(tree.vartype);\n+            if (currentMethodSym == null) {\n+                \/\/ A class or instance field initializer.\n+                currentMethodSym =\n+                        new MethodSymbol((tree.mods.flags& Flags.STATIC) | Flags.BLOCK,\n+                                names.empty, null,\n+                                currentClass);\n+            }\n+            if (tree.init != null) tree.init = translate(tree.init);\n+            result = tree;\n+        } finally {\n+            currentMethodSym = prevMethodSym;\n+        }\n+    }\n+\n+    public JCTree translateTopLevelClass(Env<AttrContext> env, JCTree cdef, TreeMaker make) {\n+        try {\n+            this.make = make;\n+            this.env = env;\n+            translate(cdef);\n+        } finally {\n+            this.make = null;\n+            this.env = null;\n+        }\n+\n+        return cdef;\n+    }\n+\n+}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":344,"deletions":0,"binary":false,"changes":344,"status":"added"},{"patch":"@@ -839,0 +839,7 @@\n+\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        tree.expressions = tree.expressions.stream()\n+                .map(e -> translate(e, erasure(e.type))).collect(List.collector());\n+        tree.type = erasure(tree.type);\n+        result = tree;\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransTypes.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import java.util.ArrayList;\n@@ -32,1 +31,0 @@\n-import java.util.stream.Collectors;\n@@ -39,0 +37,1 @@\n+import com.sun.tools.javac.code.Scope.ImportScope;\n@@ -44,0 +43,2 @@\n+import com.sun.tools.javac.parser.Parser;\n+import com.sun.tools.javac.parser.ParserFactory;\n@@ -116,0 +117,1 @@\n+    private final ParserFactory parserFactory;\n@@ -143,0 +145,1 @@\n+        parserFactory = ParserFactory.instance(context);\n@@ -328,0 +331,34 @@\n+        private void importJavaLang(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter typeImportFilter) {\n+            \/\/ Import-on-demand java.lang.\n+            PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);\n+            if (javaLang.members().isEmpty() && !javaLang.exists()) {\n+                log.error(Errors.NoJavaLang);\n+                throw new Abort();\n+            }\n+            importAll(make.at(tree.pos()).Import(make.Select(make.QualIdent(javaLang.owner), javaLang), false),\n+                javaLang, env);\n+        }\n+\n+        private void staticImports(JCCompilationUnit tree, Env<AttrContext> env, ImportFilter staticImportFilter) {\n+             if (preview.isEnabled() && preview.isPreview(Feature.STRING_TEMPLATES)) {\n+                Lint prevLint = chk.setLint(lint.suppress(LintCategory.DEPRECATION, LintCategory.REMOVAL, LintCategory.PREVIEW));\n+                boolean prevPreviewCheck = chk.disablePreviewCheck;\n+\n+                try {\n+                    chk.disablePreviewCheck = true;\n+                    String autoImports = \"\"\"\n+                            import static java.lang.StringTemplate.STR;\n+                            \"\"\";\n+                    Parser parser = parserFactory.newParser(autoImports, false, false, false, false);\n+                    JCCompilationUnit importTree = parser.parseCompilationUnit();\n+\n+                    for (JCImport imp : importTree.getImports()) {\n+                        doImport(imp);\n+                    }\n+                } finally {\n+                    chk.setLint(prevLint);\n+                    chk.disablePreviewCheck = prevPreviewCheck;\n+                }\n+            }\n+        }\n+\n@@ -350,8 +387,2 @@\n-                \/\/ Import-on-demand java.lang.\n-                PackageSymbol javaLang = syms.enterPackage(syms.java_base, names.java_lang);\n-                if (javaLang.members().isEmpty() && !javaLang.exists()) {\n-                    log.error(Errors.NoJavaLang);\n-                    throw new Abort();\n-                }\n-                importAll(make.at(tree.pos()).Import(make.Select(make.QualIdent(javaLang.owner), javaLang), false),\n-                    javaLang, env);\n+                importJavaLang(tree, env, typeImportFilter);\n+                staticImports(tree, env, staticImportFilter);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":41,"deletions":10,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1596,0 +1596,6 @@\n+            if (shouldStop(CompileState.TRANSLITERALS))\n+                return;\n+\n+            env.tree = TransLiterals.instance(context).translateTopLevelClass(env, env.tree, localMake);\n+            compileStates.put(env, CompileState.TRANSLITERALS);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/main\/JavaCompiler.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+import java.util.Iterator;\n@@ -42,1 +43,0 @@\n-import java.util.regex.Pattern;\n@@ -65,1 +65,1 @@\n-    private int NOT_FOUND = -1;\n+    private final static int NOT_FOUND = -1;\n@@ -70,1 +70,1 @@\n-    private Source source;\n+    private final Source source;\n@@ -75,1 +75,1 @@\n-    private Preview preview;\n+    private final Preview preview;\n@@ -92,0 +92,20 @@\n+    \/**\n+     * Origin scanner factory.\n+     *\/\n+    protected final ScannerFactory fac;\n+\n+    \/**\n+     * Buffer for building literals, used by nextToken().\n+     *\/\n+    protected final StringBuilder sb;\n+\n+    \/**\n+     * Tokens pending to be read from string template embedded expressions.\n+     *\/\n+    protected List<Token> pendingTokens;\n+\n+    \/**\n+     * String template fragment ranges; end-endPos pairs.\n+     *\/\n+    protected List<Integer> fragmentRanges;\n+\n@@ -123,1 +143,1 @@\n-     * Buffer for building literals, used by nextToken().\n+     * true if contains templated string escape sequences, set by nextToken().\n@@ -125,1 +145,1 @@\n-    protected StringBuilder sb;\n+    protected boolean isStringTemplate;\n@@ -128,1 +148,1 @@\n-     * Origin scanner factory.\n+     * true if errors are pending from embedded expressions.\n@@ -130,1 +150,1 @@\n-    protected ScannerFactory fac;\n+    protected boolean hasStringTemplateErrors;\n@@ -137,1 +157,1 @@\n-    protected Lint lint;\n+    protected final Lint lint;\n@@ -152,3 +172,3 @@\n-     * @param fac     the factory which created this Scanner\n-     * @param array   the input character array.\n-     * @param length  The length of the meaningful content in the array.\n+     * @param fac      factory which created this Scanner\n+     * @param array    input character array\n+     * @param length   length of the meaningful content in the array\n@@ -166,0 +186,2 @@\n+        this.pendingTokens = List.nil();\n+        this.fragmentRanges = List.nil();\n@@ -329,0 +351,80 @@\n+    \/**\n+     * Scan the content of a string template expression.\n+     *\n+     * @param pos     start of literal\n+     * @param endPos  start of embedded expression\n+     *\/\n+    private void scanEmbeddedExpression(int pos, int endPos) {\n+        \/\/ If first embedded expression.\n+        if (!isStringTemplate) {\n+            checkSourceLevel(pos, Feature.STRING_TEMPLATES);\n+            fragmentRanges = fragmentRanges.append(pos);\n+            isStringTemplate = true;\n+        }\n+        \/\/ Track end of previous fragment.\n+        fragmentRanges = fragmentRanges.append(endPos);\n+        \/\/ Keep backslash and add rest of placeholder.\n+        sb.append(\"{}\");\n+\n+        \/\/ Separate tokenizer for the embedded expression.\n+        JavaTokenizer tokenizer = new JavaTokenizer(fac, buffer(), length());\n+        tokenizer.reset(position());\n+\n+        \/\/ Track brace depth.\n+        int braceCount = 0;\n+\n+        \/\/ Accumulate tokens.\n+        List<Token> tokens = List.nil();\n+\n+        \/\/ Stash first left brace.\n+        Token token = tokenizer.readToken();\n+        tokens = tokens.append(token);\n+\n+        while (isAvailable()) {\n+            \/\/ Read and stash next token.\n+            token = tokenizer.readToken();\n+            tokens = tokens.append(token);\n+\n+            \/\/ Intercept errors\n+            if (token.kind == TokenKind.ERROR) {\n+                \/\/ Track start of next fragment.\n+                if (isTextBlock) {\n+                    reset(length());\n+                } else {\n+                    skipToEOLN();\n+                }\n+                hasStringTemplateErrors = true;\n+                return;\n+            }\n+\n+            if (token.kind == TokenKind.RBRACE) {\n+                \/\/ Potential closing brace.\n+                if (braceCount == 0) {\n+                    break;\n+                }\n+\n+                braceCount--;\n+            } else if (token.kind == TokenKind.LBRACE) {\n+                \/\/ Nesting deeper.\n+                braceCount++;\n+            } else if (token.kind == TokenKind.STRINGFRAGMENT) {\n+                tokens = tokens.appendList(tokenizer.pendingTokens);\n+                tokenizer.pendingTokens = List.nil();\n+            } else if (token.kind == TokenKind.EOF) {\n+                break;\n+            }\n+        }\n+\n+        \/\/ If no closing brace will be picked up as an unterminated string.\n+\n+        \/\/ Set main tokenizer to continue at next position.\n+        int position = tokenizer.position();\n+        reset(position);\n+\n+        \/\/ Track start of next fragment.\n+        fragmentRanges = fragmentRanges.append(position);\n+\n+        \/\/ Pend the expression tokens after the STRINGFRAGMENT.\n+        pendingTokens = pendingTokens.appendList(tokens);\n+    }\n+\n@@ -331,2 +433,3 @@\n-     * character is a backslash then the next character is validated as a proper\n-     * escape character. Conversion of escape sequences takes place at end of nextToken().\n+     * character is a backslash then the next character is assumed to be a proper\n+     * escape character. Actual conversion of escape sequences takes place\n+     * during at the end of readToken.\n@@ -334,1 +437,1 @@\n-     * @param pos position of the first character in literal.\n+     * @param pos          position of the first character in literal.\n@@ -337,0 +440,1 @@\n+        int backslash = position();\n@@ -339,1 +443,0 @@\n-\n@@ -341,2 +444,8 @@\n-                case '0': case '1': case '2': case '3':\n-                case '4': case '5': case '6': case '7':\n+                case '0':\n+                case '1':\n+                case '2':\n+                case '3':\n+                case '4':\n+                case '5':\n+                case '6':\n+                case '7':\n@@ -382,0 +491,7 @@\n+                case '{':\n+                    scanEmbeddedExpression(pos, backslash);\n+                    if (hasStringTemplateErrors) {\n+                        return;\n+                    }\n+                    break;\n+\n@@ -397,2 +513,0 @@\n-        \/\/ Assume the best.\n-        tk = Tokens.TokenKind.STRINGLITERAL;\n@@ -401,0 +515,2 @@\n+        tk = TokenKind.STRINGLITERAL;\n+\n@@ -421,1 +537,7 @@\n-                if (accept(\"\\\"\\\"\\\"\")) {\n+                if (hasStringTemplateErrors) {\n+                    break;\n+                } else if (accept(\"\\\"\\\"\\\"\")) {\n+                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n+                        tk = TokenKind.STRINGFRAGMENT;\n+                    }\n+\n@@ -445,1 +567,6 @@\n-                if (accept('\\\"')) {\n+                if (hasStringTemplateErrors) {\n+                    break;\n+                } else if (accept('\\\"')) {\n+                    if (isStringTemplate && tk == TokenKind.STRINGLITERAL) {\n+                        tk = TokenKind.STRINGFRAGMENT;\n+                    }\n@@ -460,2 +587,10 @@\n-        \/\/ String ended without close delimiter sequence.\n-        lexError(pos, isTextBlock ? Errors.UnclosedTextBlock : Errors.UnclosedStrLit);\n+        \/\/ String ended without close delimiter sequence or has embedded expression errors.\n+        if (isStringTemplate) {\n+            lexError(pos, isTextBlock ? Errors.TextBlockTemplateIsNotWellFormed\n+                                      : Errors.StringTemplateIsNotWellFormed);\n+            fragmentRanges = List.nil();\n+            pendingTokens = List.nil();\n+        } else {\n+            lexError(pos, isTextBlock ? Errors.UnclosedTextBlock\n+                                      : Errors.UnclosedStrLit);\n+        }\n@@ -463,1 +598,1 @@\n-        if (firstEOLN  != NOT_FOUND) {\n+        if (!hasStringTemplateErrors && firstEOLN  != NOT_FOUND) {\n@@ -784,0 +919,6 @@\n+        if (pendingTokens.nonEmpty()) {\n+            Token token = pendingTokens.head;\n+            pendingTokens = pendingTokens.tail;\n+            return token;\n+        }\n+\n@@ -789,0 +930,3 @@\n+        isStringTemplate = false;\n+        hasStringTemplateErrors = false;\n+        fragmentRanges = List.nil();\n@@ -983,0 +1127,1 @@\n+                        int errorPos = position();\n@@ -992,1 +1137,0 @@\n-\n@@ -1029,2 +1173,2 @@\n-                                arg = (32 < ch && ch < 127) ? String.format(\"%s\", ch) :\n-                                                              String.format(\"\\\\u%04x\", (int) ch);\n+                                arg = (32 < ch && ch < 127) ? String.valueOf(ch) :\n+                                                              \"\\\\u%04x\".formatted((int) ch);\n@@ -1043,0 +1187,5 @@\n+            \/\/ Track end of final fragment.\n+            if (isStringTemplate) {\n+                fragmentRanges = fragmentRanges.append(endPos);\n+            }\n+\n@@ -1074,0 +1223,5 @@\n+                if (isStringTemplate) {\n+                    \/\/ Break string into fragments and then return the first of the framents.\n+                    return getFragments(string, comments);\n+                }\n+\n@@ -1103,0 +1257,60 @@\n+    \/**\n+     * Convert the string into a list of pending tokens to precede embedded\n+     * expressions.\n+     *\n+     * @param string    string to fragment\n+     * @param comments  comments for first token\n+     *\n+     * @return first pending token.\n+     *\/\n+    private Token getFragments(String string, List<Comment> comments) {\n+        List<Token> tokens = List.nil();\n+        Iterator<Integer> rangeIter = fragmentRanges.iterator();\n+        for (String fragment : fragment(string)) {\n+            fragment = fragment.translateEscapes();\n+            int fragmentPos = rangeIter.next();\n+            int fragmentEndPos = rangeIter.next();\n+            Token token = new StringToken(TokenKind.STRINGFRAGMENT,\n+                    fragmentPos, fragmentEndPos, fragment, comments);\n+            comments = null;\n+            tokens = tokens.append(token);\n+        }\n+        pendingTokens = tokens.appendList(pendingTokens);\n+        Token first = pendingTokens.head;\n+        pendingTokens = pendingTokens.tail;\n+        return first;\n+    }\n+\n+    \/**\n+     * Break string template up into fragments. \"\\{}\" indicates where\n+     * embedded expressions occur.\n+     *\n+     * @param string string template\n+     *\n+     * @return list of fragment strings\n+     *\/\n+    List<String> fragment(String string) {\n+        List<String> fragments = List.nil();\n+        StringBuilder sb = new StringBuilder();\n+        int length = string.length();\n+        for (int i = 0; i < length; i++) {\n+            char ch = string.charAt(i);\n+            if (ch != '\\\\') {\n+                sb.append(ch);\n+            } else if (i + 2 < length && string.charAt(i + 1) == '{'\n+                    && string.charAt(i + 2) == '}') {\n+                fragments = fragments.append(sb.toString());\n+                sb.setLength(0);\n+                i += 2;\n+            } else if (i + 1 < length){\n+                sb.append('\\\\');\n+                sb.append(string.charAt(i + 1));\n+                i++;\n+            } else {\n+                \/\/ Error already reported.\n+            }\n+        }\n+        fragments = fragments.append(sb.toString());\n+        return fragments;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":243,"deletions":29,"binary":false,"changes":272,"status":"modified"},{"patch":"@@ -653,0 +653,53 @@\n+    \/**\n+     * StringTemplate =\n+     *    [STRINGFRAGMENT] [EmbeddedExpression]\n+     *  | STRINGLITERAL\n+     *\n+     * EmbeddedExpression =\n+     *  LBRACE term RBRACE\n+     *\/\n+    JCExpression stringTemplate(JCExpression processor) {\n+        checkSourceLevel(Feature.STRING_TEMPLATES);\n+        \/\/ Disable standalone string templates\n+        if (processor == null) {\n+            log.error(DiagnosticFlag.SYNTAX, token.pos,\n+                    Errors.ProcessorMissingFromStringTemplateExpression);\n+        }\n+        int oldmode = mode;\n+        selectExprMode();\n+        Token stringToken = token;\n+        int pos = stringToken.pos;\n+        int endPos = stringToken.endPos;\n+        TokenKind kind = stringToken.kind;\n+        String string = token.stringVal();\n+        List<String> fragments = List.of(string);\n+        List<JCExpression> expressions = List.nil();\n+        nextToken();\n+        if (kind != STRINGLITERAL) {\n+            while (token.kind == STRINGFRAGMENT) {\n+                stringToken = token;\n+                endPos = stringToken.endPos;\n+                string = stringToken.stringVal();\n+                fragments = fragments.append(string);\n+                nextToken();\n+             }\n+            while (token.pos < endPos && token.kind != DEFAULT && token.kind != ERROR) {\n+                accept(LBRACE);\n+                JCExpression expression = token.kind == RBRACE ? F.at(pos).Literal(TypeTag.BOT, null)\n+                                                               : term(EXPR);\n+                expressions = expressions.append(expression);\n+                if (token.kind != ERROR) {\n+                    accept(RBRACE);\n+                }\n+            }\n+            \/\/ clean up remaining expression tokens if error\n+            while (token.pos < endPos && token.kind != DEFAULT) {\n+                nextToken();\n+            }\n+            S.setPrevToken(stringToken);\n+        }\n+        JCExpression t = toP(F.at(pos).StringTemplate(processor, fragments, expressions));\n+        setMode(oldmode);\n+        return t;\n+    }\n+\n@@ -1281,0 +1334,8 @@\n+         case STRINGFRAGMENT:\n+             if (typeArgs == null && isMode(EXPR)) {\n+                 selectExprMode();\n+                 t = stringTemplate(null);\n+             } else {\n+                 return illegal();\n+             }\n+             break;\n@@ -1411,0 +1472,6 @@\n+                            case STRINGFRAGMENT:\n+                            case STRINGLITERAL:\n+                                if (typeArgs != null) return illegal();\n+                                t = stringTemplate(t);\n+                                typeArgs = null;\n+                                break loop;\n@@ -1633,0 +1700,6 @@\n+                } else if (token.kind == TokenKind.STRINGFRAGMENT ||\n+                           token.kind == TokenKind.STRINGLITERAL) {\n+                    if (typeArgs != null) {\n+                        return illegal();\n+                    }\n+                    t = stringTemplate(t);\n@@ -1792,0 +1865,1 @@\n+                        case STRINGFRAGMENT:\n@@ -2709,0 +2783,1 @@\n+                    case STRINGFRAGMENT:\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":75,"deletions":0,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,5 @@\n+    \/**\n+     * Sets the previous token.\n+     *\/\n+    void setPrevToken(Token prevToken);\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,2 +33,0 @@\n-import com.sun.tools.javac.parser.JavaTokenizer.*;\n-\n@@ -47,1 +45,1 @@\n-    private Tokens tokens;\n+    private final Tokens tokens;\n@@ -59,1 +57,1 @@\n-    private List<Token> savedTokens = new ArrayList<>();\n+    private final List<Token> savedTokens = new ArrayList<>();\n@@ -61,1 +59,1 @@\n-    private JavaTokenizer tokenizer;\n+    private final JavaTokenizer tokenizer;\n@@ -101,1 +99,1 @@\n-            for (int i = savedTokens.size() ; i < lookahead ; i ++) {\n+            for (int i = savedTokens.size() ; i < lookahead ; i++) {\n@@ -110,0 +108,4 @@\n+    public void setPrevToken(Token prevToken) {\n+        this.prevToken = prevToken;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":9,"deletions":7,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -154,0 +154,1 @@\n+        STRINGFRAGMENT(Tag.STRING),\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,0 +119,9 @@\n+    \/**\n+     * Returns the character buffer.\n+     *\n+     * @return character buffer.\n+     *\/\n+    protected char[] buffer() {\n+        return buffer;\n+    }\n+\n@@ -382,0 +391,3 @@\n+    protected boolean isOneOf(char ch1, char ch2, char ch3, char ch4) {\n+        return is(ch1) || is(ch2) || is(ch3) || is(ch4);\n+    }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1312,0 +1312,17 @@\n+compiler.err.string.template.is.not.well.formed=\\\n+    string template is not well formed\n+\n+compiler.err.text.block.template.is.not.well.formed=\\\n+    text block template is not well formed\n+\n+compiler.err.processor.missing.from.string.template.expression=\\\n+    processor missing from string template expression\n+\n+# 0: symbol\n+compiler.err.processor.type.cannot.be.a.raw.type=\\\n+    processor type cannot be a raw type: {0}\n+\n+# 0: symbol\n+compiler.err.not.a.processor.type=\\\n+    not a processor type: {0}\n+\n@@ -3098,0 +3115,3 @@\n+compiler.misc.feature.string.templates=\\\n+    string templates\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -272,0 +272,4 @@\n+        \/** String template expression.\n+         *\/\n+        STRING_TEMPLATE,\n+\n@@ -2502,0 +2506,52 @@\n+    \/**\n+     * String template expression.\n+     *\/\n+    public static class JCStringTemplate extends JCExpression implements StringTemplateTree {\n+        public JCExpression processor;\n+        public List<String> fragments;\n+        public List<JCExpression> expressions;\n+\n+        protected JCStringTemplate(JCExpression processor,\n+                                   List<String> fragments,\n+                                   List<JCExpression> expressions) {\n+            this.processor = processor;\n+            this.fragments = fragments;\n+            this.expressions = expressions;\n+        }\n+\n+        @Override\n+        public ExpressionTree getProcessor() {\n+            return processor;\n+        }\n+\n+        @Override\n+        public List<String> getFragments() {\n+            return fragments;\n+        }\n+\n+        @Override\n+        public List<? extends ExpressionTree> getExpressions() {\n+            return expressions;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Kind getKind() {\n+            return Kind.TEMPLATE;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public Tag getTag() {\n+            return STRING_TEMPLATE;\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public void accept(Visitor v) {\n+            v.visitStringTemplate(this);\n+        }\n+\n+        @Override @DefinedBy(Api.COMPILER_TREE)\n+        public <R, D> R accept(TreeVisitor<R, D> v, D d) {\n+            return v.visitStringTemplate(this, d);\n+        }\n+    }\n+\n@@ -3481,0 +3537,3 @@\n+        JCStringTemplate StringTemplate(JCExpression processor,\n+                                        List<String> fragments,\n+                                        List<JCExpression> expressions);\n@@ -3552,0 +3611,1 @@\n+        public void visitStringTemplate(JCStringTemplate that) { visitTree(that); }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/JCTree.java","additions":60,"deletions":0,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.stream.Collectors;\n@@ -1477,0 +1478,17 @@\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        try {\n+            JCExpression processor = tree.processor;\n+            print(\"[\");\n+            if (processor != null) {\n+                printExpr(processor);\n+            }\n+            print(\"]\");\n+            print(\"\\\"\" + tree.fragments.stream().collect(Collectors.joining(\"\\\\{}\")) + \"\\\"\");\n+            print(\"(\");\n+            printExprs(tree.expressions);\n+            print(\")\");\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/Pretty.java","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -285,0 +285,8 @@\n+    @DefinedBy(Api.COMPILER_TREE)\n+    public JCTree visitStringTemplate(StringTemplateTree node, P p) {\n+        JCStringTemplate t = (JCStringTemplate) node;\n+        JCExpression processor = copy(t.processor, p);\n+        List<JCExpression> expressions = copy(t.expressions, p);\n+        return M.at(t.pos).StringTemplate(processor, t.fragments, expressions);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeCopier.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -333,0 +333,1 @@\n+            case STRING_TEMPLATE:\n@@ -548,0 +549,8 @@\n+            case STRING_TEMPLATE: {\n+                JCStringTemplate node = (JCStringTemplate) tree;\n+                if (node.processor == null) {\n+                    return node.pos;\n+                } else {\n+                    return getStartPos(node.processor);\n+                }\n+            }\n@@ -976,0 +985,2 @@\n+        case CLASSDEF:\n+            return ((JCClassDecl) tree).sym;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeInfo.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -552,0 +552,8 @@\n+    public JCStringTemplate StringTemplate(JCExpression processor,\n+                                           List<String> fragments,\n+                                           List<JCExpression> expressions) {\n+        JCStringTemplate tree = new JCStringTemplate(processor, fragments, expressions);\n+        tree.pos = pos;\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeMaker.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -356,0 +356,5 @@\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        scan(tree.processor);\n+        scan(tree.expressions);\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeScanner.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -414,0 +414,7 @@\n+    public void visitStringTemplate(JCStringTemplate tree) {\n+        tree.processor = translate(tree.processor);\n+        tree.expressions = translate(tree.expressions);\n+\n+        result = tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/tree\/TreeTranslator.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -225,0 +225,8 @@\n+    \/\/ templated string\n+    public final Name process;\n+    public final Name STR;\n+    public final Name RAW;\n+    public final Name newStringTemplate;\n+    public final Name newLargeStringTemplate;\n+    public final Name processStringTemplate;\n+\n@@ -398,0 +406,8 @@\n+        \/\/ templated string\n+        process = fromString(\"process\");\n+        STR = fromString(\"STR\");\n+        RAW = fromString(\"RAW\");\n+        newStringTemplate = fromString(\"newStringTemplate\");\n+        newLargeStringTemplate = fromString(\"newLargeStringTemplate\");\n+        processStringTemplate = fromString(\"processStringTemplate\");\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/util\/Names.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,1 +38,0 @@\n-\n","filename":"src\/jdk.incubator.concurrent\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -275,0 +275,1 @@\n+        STRINGFRAGMENT(TokenKind.STRINGFRAGMENT, XEXPR1|XTERM),\n@@ -482,2 +483,10 @@\n-            scanner.nextToken();\n-            current = scanner.token();\n+            if (current != null && current.kind == TokenKind.STRINGFRAGMENT) {\n+                int endPos = current.endPos;\n+                do {\n+                    scanner.nextToken();\n+                    current = scanner.token();\n+                } while (current != null && current.endPos <= endPos && current.kind != TokenKind.EOF);\n+            } else {\n+                scanner.nextToken();\n+                current = scanner.token();\n+            }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/CompletenessAnalyzer.java","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.StringConcatFactory;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\/**\n+ * @test\n+ * @summary Test StringConcatFactory.makeConcatWithTemplate... methods.\n+ * @enablePreview true\n+ *\/\n+\n+public class MakeConcatWithTemplate {\n+    public static void main(String... args) {\n+        makeConcatWithTemplate();\n+        makeConcatWithTemplateCluster();\n+        makeConcatWithTemplateGetters();\n+    }\n+\n+    static List<String> fragments(int n) {\n+        String[] array = new String[n];\n+        Arrays.fill(array, \"abc\");\n+        return Arrays.asList(array);\n+    }\n+\n+    static List<Class<?>> types(int n) {\n+        Class<?>[] array = new Class<?>[n];\n+        Arrays.fill(array, int.class);\n+        return Arrays.asList(array);\n+    }\n+\n+    static List<Integer> values(int n) {\n+        Integer[] array = new Integer[n];\n+        Arrays.fill(array, 123);\n+        return Arrays.asList(array);\n+    }\n+\n+    static List<MethodHandle> getters(int n) {\n+        MethodHandle[] array = new MethodHandle[n];\n+        MethodHandle m = MethodHandles.dropArguments(MethodHandles.constant(int.class, 123), 0, Object.class);\n+        Arrays.fill(array, m);\n+        return Arrays.asList(array);\n+    }\n+\n+    static void makeConcatWithTemplate() {\n+        try {\n+            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS - 1;\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n+            m.invokeWithArguments(values(n));\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n+            m.invokeWithArguments(values(n));\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        boolean threw = false;\n+        try {\n+            int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS + 1;\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplate(fragments(n + 1), types(n));\n+            m.invokeWithArguments(values(n));\n+        } catch (Throwable e) {\n+            threw = true;\n+        }\n+\n+        if (!threw) {\n+            throw new RuntimeException(\"Exception expected - makeConcatWithTemplate\");\n+        }\n+    }\n+\n+    static void makeConcatWithTemplateCluster() {\n+        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n+        int c = 3;\n+        try {\n+            List<MethodHandle> ms = StringConcatFactory.makeConcatWithTemplateCluster(fragments(c * n + 1), types(c * n), n);\n+            MethodHandle m0 = ms.get(0);\n+            MethodHandle m1 = ms.get(1);\n+            MethodHandle m2 = ms.get(2);\n+            MethodHandle m3 = ms.get(3);\n+\n+            String s = (String)m0.invokeWithArguments(values(n));\n+            List<Object> args = new ArrayList<>();\n+            args.add(s);\n+            args.addAll(values(n - 1)); \/\/ one less for carry over string\n+            s = (String)m1.invokeWithArguments(args);\n+            args.clear();\n+            args.add(s);\n+            args.addAll(values(n - 1)); \/\/ one less for carry over string\n+            s = (String)m2.invokeWithArguments(args);\n+            args.clear();\n+            args.add(s);\n+            args.addAll(values(2)); \/\/ two remaining carry overs\n+            s = (String)m3.invokeWithArguments(args);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void makeConcatWithTemplateGetters() {\n+        int n = StringConcatFactory.MAX_INDY_CONCAT_ARG_SLOTS;\n+        int c = 3;\n+        try {\n+            MethodHandle m = StringConcatFactory.makeConcatWithTemplateGetters(fragments(c * n + 1), getters(c * n), n);\n+            String s = (String)m.invoke(null);\n+        } catch (Throwable e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/MakeConcatWithTemplate.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test features provided by the Carriers class.\n+ * @modules java.base\/java.lang.runtime\n+ * @enablePreview true\n+ * @compile --patch-module java.base=${test.src} CarriersTest.java\n+ * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.runtime.CarriersTest\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class CarriersTest {\n+    public static void main(String[] args) throws Throwable {\n+        primitivesTest();\n+        primitivesTestLarge();\n+        limitsTest();\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static final int MAX_COMPONENTS = 254;\n+\n+    static void primitivesTest() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class);\n+        MethodHandle constructor = Carriers.initializingConstructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\");\n+        List<MethodHandle> components = Carriers.components(methodType);\n+        assertTrue((byte)components.get(0).invokeExact(object) == (byte)0xFF,\n+                \"primitive byte test failure\");\n+        assertTrue((short)components.get(1).invokeExact(object) == (short)0xFFFF,\n+                \"primitive short test failure\");\n+        assertTrue((char)components.get(2).invokeExact(object) == 'C',\n+                \"primitive char test failure\");\n+        assertTrue((int)components.get(3).invokeExact(object) == 0xFFFFFFFF,\n+                \"primitive int test failure\");\n+        assertTrue((long)components.get(4).invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"primitive long test failure\");\n+        assertTrue((float)components.get(5).invokeExact(object) == 1.0f \/ 3.0f,\n+                \"primitive float test failure\");\n+        assertTrue((double)components.get(6).invokeExact(object) == 1.0 \/ 3.0,\n+                \"primitive double test failure\");\n+        assertTrue((boolean)components.get(7).invokeExact(object),\n+                \"primitive boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components.get(8).invokeExact(object)),\n+                \"primitive String test failure\");\n+    }\n+\n+    static void primitivesTestLarge() throws Throwable {\n+        MethodType methodType =\n+                MethodType.methodType(Object.class, byte.class, short.class,\n+                        char.class, int.class, long.class,\n+                        float.class, double.class,\n+                        boolean.class, String.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class,\n+                        Object.class, Object.class,Object.class,Object.class\n+                );\n+        MethodHandle constructor = Carriers.initializingConstructor(methodType);\n+        Object object = (Object)constructor.invokeExact((byte)0xFF, (short)0xFFFF,\n+                'C', 0xFFFFFFFF, 0xFFFFFFFFFFFFFFFFL,\n+                1.0f \/ 3.0f, 1.0 \/ 3.0,\n+                true, \"abcde\",\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null,\n+                (Object)null, (Object)null, (Object)null, (Object)null\n+        );\n+        List<MethodHandle> components = Carriers.components(methodType);\n+        assertTrue((byte)components.get(0).invokeExact(object) == (byte)0xFF,\n+                \"large primitive byte test failure\");\n+        assertTrue((short)components.get(1).invokeExact(object) == (short)0xFFFF,\n+                \"large primitive short test failure\");\n+        assertTrue((char)components.get(2).invokeExact(object) == 'C',\n+                \"large primitive char test failure\");\n+        assertTrue((int)components.get(3).invokeExact(object) == 0xFFFFFFFF,\n+                \"large primitive int test failure\");\n+        assertTrue((long)components.get(4).invokeExact(object) == 0xFFFFFFFFFFFFFFFFL,\n+                \"large primitive long test failure\");\n+        assertTrue((float)components.get(5).invokeExact(object) == 1.0f \/ 3.0f,\n+                \"large primitive float test failure\");\n+        assertTrue((double)components.get(6).invokeExact(object) == 1.0 \/ 3.0,\n+                \"large primitive double test failure\");\n+        assertTrue((boolean)components.get(7).invokeExact(object),\n+                \"large primitive boolean test failure\");\n+        assertTrue(\"abcde\".equals((String)components.get(8).invokeExact(object)),\n+                \"large primitive String test failure\");\n+    }\n+\n+    static void limitsTest() {\n+        boolean passed;\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS + 1];\n+            Arrays.fill(ptypes, Object.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carriers.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+\n+        passed = false;\n+        try {\n+            Class<?>[] ptypes = new Class<?>[MAX_COMPONENTS \/ 2 + 1];\n+            Arrays.fill(ptypes, long.class);\n+            MethodType methodType = MethodType.methodType(Object.class, ptypes);\n+            MethodHandle constructor = Carriers.constructor(methodType);\n+        } catch (IllegalArgumentException ex) {\n+            passed = true;\n+        }\n+\n+        if (!passed) {\n+            throw new RuntimeException(\"failed to report too many components \");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/CarriersTest.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -0,0 +1,109 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test features provided by the ReferencedKeyMap class.\n+ * @modules java.base\/java.lang.runtime\n+ * @enablePreview\n+ * @compile --patch-module java.base=${test.src} ReferencedKeyTest.java\n+ * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.runtime.ReferencedKeyTest\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Supplier;\n+\n+public class ReferencedKeyTest {\n+    static long BASE_KEY = 10_000_000L;\n+\n+    public static void main(String[] args) throws Throwable {\n+        mapTest(false, HashMap::new);\n+        mapTest(true, HashMap::new);\n+        mapTest(false, ConcurrentHashMap::new);\n+        mapTest(true, ConcurrentHashMap::new);\n+    }\n+\n+    static void assertTrue(boolean test, String message) {\n+        if (!test) {\n+            throw new RuntimeException(message);\n+        }\n+    }\n+\n+    static void  mapTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, String>> supplier) {\n+        Map<Long, String> map = ReferencedKeyMap.create(isSoft, supplier);\n+        populate(map);\n+        collect();\n+        \/\/ assertTrue(map.isEmpty() || isSoft, \"Weak not collecting\");\n+        populate(map);\n+        methods(map);\n+    }\n+\n+    static void methods(Map<Long, String> map) {\n+        assertTrue(map.size() == 26, \"missing key\");\n+        assertTrue(map.containsKey(BASE_KEY + 'a' -'a'), \"missing key\");\n+        assertTrue(map.get(BASE_KEY + 'b' -'a').equals(\"b\"), \"wrong key\");\n+        assertTrue(map.containsValue(\"c\"), \"missing value\");\n+        map.remove(BASE_KEY + 'd' -'a');\n+        assertTrue(map.get(BASE_KEY + 'd' -'a') == null, \"not removed\");\n+        map.putAll(Map.of(1L, \"A\", 2L, \"B\"));\n+        assertTrue(map.get(2L).equals(\"B\"), \"collection not added\");\n+        assertTrue(map.keySet().contains(1L), \"key missing\");\n+        assertTrue(map.values().contains(\"A\"), \"key missing\");\n+        assertTrue(map.entrySet().contains(Map.entry(1L, \"A\")), \"key missing\");\n+        map.putIfAbsent(3L, \"C\");\n+        assertTrue(map.get(3L).equals(\"C\"), \"key missing\");\n+        map.putIfAbsent(2L, \"D\");\n+        assertTrue(map.get(2L).equals(\"B\"), \"key replaced\");\n+        map.remove(3L);\n+        assertTrue(map.get(3L) == null, \"key not removed\");\n+        map.replace(2L, \"D\");\n+        assertTrue(map.get(2L).equals(\"D\"), \"key not replaced\");\n+        map.replace(2L, \"B\", \"E\");\n+        assertTrue(map.get(2L).equals(\"D\"), \"key replaced\");\n+    }\n+\n+    static void collect() {\n+        System.gc();\n+        sleep();\n+    }\n+\n+    static void sleep() {\n+        try {\n+            Thread.sleep(100L);\n+        } catch (InterruptedException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    static void populate(Map<Long, String> map) {\n+        for (int i = 0; i < 26; i++) {\n+            Long key = BASE_KEY + i;\n+            String value = String.valueOf((char) ('a' + i));\n+            map.put(key, value);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/runtime\/ReferencedKeyTest.java","additions":109,"deletions":0,"binary":false,"changes":109,"status":"added"},{"patch":"@@ -0,0 +1,504 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise runtime handing of templated strings.\n+ * @enablePreview true\n+ *\/\n+\n+import java.lang.StringTemplate.*;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.function.*;\n+\n+import static java.lang.StringTemplate.RAW;\n+\n+public class Basic {\n+    public static void main(String... arg) {\n+        equalsHashCode();\n+        concatenationTests();\n+        componentTests();\n+        limitsTests();\n+        processorTests();\n+        stringTemplateCoverage();\n+        simpleProcessorCoverage();\n+    }\n+\n+    static void ASSERT(String a, String b) {\n+        if (!Objects.equals(a, b)) {\n+            System.out.println(a);\n+            System.out.println(b);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    static void ASSERT(Object a, Object b) {\n+        if (!Objects.deepEquals(a, b)) {\n+            System.out.println(a);\n+            System.out.println(b);\n+            throw new RuntimeException(\"Test failed\");\n+        }\n+    }\n+\n+    \/*\n+     * equals and hashCode tests.\n+     *\/\n+    static void equalsHashCode() {\n+        int x = 10;\n+        int y = 20;\n+        int a = 10;\n+        int b = 20;\n+\n+        StringTemplate st0 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+        StringTemplate st1 = RAW.\"\\{a} + \\{b} = \\{a + b}\";\n+        StringTemplate st2 = RAW.\"\\{x} + \\{y} = \\{x + y}!\";\n+        x++;\n+        StringTemplate st3 = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+\n+        if (!st0.equals(st1)) throw new RuntimeException(\"st0 != st1\");\n+        if (st0.equals(st2)) throw new RuntimeException(\"st0 == st2\");\n+        if (st0.equals(st3)) throw new RuntimeException(\"st0 == st3\");\n+\n+        if (st0.hashCode() != st1.hashCode()) throw new RuntimeException(\"st0.hashCode() != st1.hashCode()\");\n+    }\n+\n+    \/*\n+     * Concatenation tests.\n+     *\/\n+    static void concatenationTests() {\n+        int x = 10;\n+        int y = 20;\n+\n+        ASSERT(STR.\"\\{x} \\{y}\", x + \" \" + y);\n+        ASSERT(STR.\"\\{x + y}\", \"\" + (x + y));\n+        ASSERT(STR.process(RAW.\"\\{x} \\{y}\"), x + \" \" + y);\n+        ASSERT(STR.process(RAW.\"\\{x + y}\"), \"\" + (x + y));\n+        ASSERT((RAW.\"\\{x} \\{y}\").process(STR), x + \" \" + y);\n+        ASSERT((RAW.\"\\{x + y}\").process(STR), \"\" + (x + y));\n+    }\n+\n+    \/*\n+     * Component tests.\n+     *\/\n+    static void componentTests() {\n+        int x = 10;\n+        int y = 20;\n+\n+        StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+        ASSERT(st.values(), List.of(x, y, x + y));\n+        ASSERT(st.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n+        ASSERT(st.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n+    }\n+\n+    \/*\n+     * Limits tests.\n+     *\/\n+    static void limitsTests() {\n+        int x = 9;\n+\n+        StringTemplate ts250 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts250.values().size(), 250);\n+        ASSERT(ts250.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999\n+               \"\"\");\n+\n+        StringTemplate ts251 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\n+             \"\"\";\n+        ASSERT(ts251.values().size(), 251);\n+        ASSERT(ts251.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9\n+               \"\"\");\n+\n+        StringTemplate ts252 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts252.values().size(), 252);\n+        ASSERT(ts252.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 99\n+               \"\"\");\n+\n+        StringTemplate ts253 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts253.values().size(), 253);\n+        ASSERT(ts253.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 999\n+               \"\"\");\n+\n+        StringTemplate ts254 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts254.values().size(), 254);\n+        ASSERT(ts254.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999\n+               \"\"\");\n+\n+        StringTemplate ts255 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts255.values().size(), 255);\n+        ASSERT(ts255.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 99999\n+               \"\"\");\n+\n+        StringTemplate ts256 = RAW.\"\"\"\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\\{x} \\{x}\\{x}\\{x}\\{x}\\{x}\\{x}\n+             \"\"\";\n+        ASSERT(ts256.values().size(), 256);\n+        ASSERT(ts256.interpolate(), \"\"\"\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 9999999999\n+\n+               9999999999 9999999999\n+               9999999999 9999999999\n+               9999999999 999999\n+               \"\"\");\n+\n+    }\n+\n+    \/*\n+     * Processor tests.\n+     *\/\n+    public static final Processor<StringTemplate, RuntimeException> STRINGIFY = st -> {\n+        List<Object> values = st.values()\n+                .stream()\n+                .map(v -> (Object)String.valueOf(v))\n+                .toList();\n+\n+        return StringTemplate.of(st.fragments(), values);\n+    };\n+\n+    public static final Processor<StringTemplate, RuntimeException> UPPER = st -> {\n+        List<String> fragments = st.fragments()\n+                .stream()\n+                .map(String::toUpperCase)\n+                .toList();\n+\n+        return StringTemplate.of(fragments, st.values());\n+    };\n+\n+    public static final Processor<String, RuntimeException> CHAIN = st -> {\n+        st = STRINGIFY.process(st);\n+        st = UPPER.process(st);\n+        return STR.process(st);\n+    };\n+\n+    static void processorTests() {\n+        String name = \"Joan\";\n+        int age = 25;\n+        ASSERT(CHAIN.\"\\{name} is \\{age} years old\", \"Joan IS 25 YEARS OLD\");\n+    }\n+\n+    \/*\n+     *  StringTemplate coverage\n+     *\/\n+    static void stringTemplateCoverage() {\n+        StringTemplate tsNoValues = StringTemplate.of(\"No Values\");\n+\n+        ASSERT(tsNoValues.values(), List.of());\n+        ASSERT(tsNoValues.fragments(), List.of(\"No Values\"));\n+        ASSERT(tsNoValues.interpolate(), STR.\"No Values\");\n+\n+        int x = 10, y = 20;\n+        StringTemplate src = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+        StringTemplate tsValues = StringTemplate.of(src.fragments(), src.values());\n+        ASSERT(tsValues.fragments(), List.of(\"\", \" + \", \" = \", \"\"));\n+        ASSERT(tsValues.values(), List.of(x, y, x + y));\n+        ASSERT(tsValues.interpolate(), x + \" + \" + y + \" = \" + (x + y));\n+        ASSERT(StringTemplate.combine(src, src).interpolate(),\n+                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n+        ASSERT(StringTemplate.combine(src), src);\n+        ASSERT(StringTemplate.combine().interpolate(), \"\");\n+        ASSERT(StringTemplate.combine(List.of(src, src)).interpolate(),\n+                RAW.\"\\{x} + \\{y} = \\{x + y}\\{x} + \\{y} = \\{x + y}\".interpolate());\n+    }\n+\n+    \/*\n+     * SimpleProcessor coverage.\n+     *\/\n+\n+    static class Processor0 implements Processor<String, IllegalArgumentException> {\n+        @Override\n+        public String process(StringTemplate stringTemplate) throws IllegalArgumentException {\n+            StringBuilder sb = new StringBuilder();\n+            Iterator<String> fragmentsIter = stringTemplate.fragments().iterator();\n+\n+            for (Object value : stringTemplate.values()) {\n+                sb.append(fragmentsIter.next());\n+\n+                if (value instanceof Boolean) {\n+                    throw new IllegalArgumentException(\"I don't like Booleans\");\n+                }\n+\n+                sb.append(value);\n+            }\n+\n+            sb.append(fragmentsIter.next());\n+\n+            return sb.toString();\n+        }\n+    }\n+\n+    static Processor0 processor0 = new Processor0();\n+\n+    static Processor<String, RuntimeException> processor1 =\n+        st -> st.interpolate();\n+\n+    static Processor<String, RuntimeException> processor2 = st -> st.interpolate();\n+\n+    static Processor<String, RuntimeException> processor3 = st -> st.interpolate();\n+\n+    static Processor<String, RuntimeException> processor4 = st ->\n+        StringTemplate.interpolate(st.fragments(), st.values());\n+\n+\n+    static void simpleProcessorCoverage() {\n+        try {\n+            int x = 10;\n+            int y = 20;\n+            ASSERT(processor0.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor1.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor2.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor3.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+            ASSERT(processor4.\"\\{x} + \\{y} = \\{x + y}\", \"10 + 20 = 30\");\n+        } catch (IllegalArgumentException ex) {\n+            throw new RuntimeException(\"processor fail\");\n+        }\n+    }\n+\n+    static String justify(String string, int width) {\n+        boolean leftJustify = width < 0;\n+        int length = string.length();\n+        width = Math.abs(width);\n+        int diff = width - length;\n+\n+        if (diff < 0) {\n+            string = \"*\".repeat(width);\n+        } else if (0 < diff) {\n+            if (leftJustify) {\n+                string += \" \".repeat(diff);\n+            } else {\n+                string = \" \".repeat(diff) + string;\n+            }\n+        }\n+\n+        return string;\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":504,"deletions":0,"binary":false,"changes":504,"status":"added"},{"patch":"@@ -0,0 +1,915 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise format builder.\n+ * @enablePreview true\n+ *\/\n+\n+import java.util.FormatProcessor;\n+import java.util.Objects;\n+import java.util.Locale;\n+\n+import static java.util.FormatProcessor.FMT;\n+\n+public class FormatterBuilder {\n+    public static void main(String... args) {\n+        Locale.setDefault(Locale.US);\n+        suite(FMT);\n+        Locale thai = Locale.forLanguageTag(\"th-TH-u-nu-thai\");\n+        FormatProcessor thaiFormat = FormatProcessor.create(thai);\n+        Locale.setDefault(thai);\n+        suite(thaiFormat);\n+    }\n+\n+    static void test(String a, String b) {\n+        if (!Objects.equals(a, b)) {\n+            throw new RuntimeException(\"format and FMT do not match: \" + a + \" : \" + b);\n+        }\n+    }\n+\n+    static void suite(FormatProcessor fmt) {\n+        Object nullObject = null;\n+        test(String.format(\"%b\", false), fmt.\"%b\\{false}\");\n+        test(String.format(\"%b\", true), fmt.\"%b\\{true}\");\n+        test(String.format(\"%10b\", false), fmt.\"%10b\\{false}\");\n+        test(String.format(\"%10b\", true), fmt.\"%10b\\{true}\");\n+        test(String.format(\"%-10b\", false), fmt.\"%-10b\\{false}\");\n+        test(String.format(\"%-10b\", true), fmt.\"%-10b\\{true}\");\n+        test(String.format(\"%B\", false), fmt.\"%B\\{false}\");\n+        test(String.format(\"%B\", true), fmt.\"%B\\{true}\");\n+        test(String.format(\"%10B\", false), fmt.\"%10B\\{false}\");\n+        test(String.format(\"%10B\", true), fmt.\"%10B\\{true}\");\n+        test(String.format(\"%-10B\", false), fmt.\"%-10B\\{false}\");\n+        test(String.format(\"%-10B\", true), fmt.\"%-10B\\{true}\");\n+\n+        test(String.format(\"%h\", 12345), fmt.\"%h\\{12345}\");\n+        test(String.format(\"%h\", 0xABCDE), fmt.\"%h\\{0xABCDE}\");\n+        test(String.format(\"%10h\", 12345), fmt.\"%10h\\{12345}\");\n+        test(String.format(\"%10h\", 0xABCDE), fmt.\"%10h\\{0xABCDE}\");\n+        test(String.format(\"%-10h\", 12345), fmt.\"%-10h\\{12345}\");\n+        test(String.format(\"%-10h\", 0xABCDE), fmt.\"%-10h\\{0xABCDE}\");\n+        test(String.format(\"%H\", 12345), fmt.\"%H\\{12345}\");\n+        test(String.format(\"%H\", 0xABCDE), fmt.\"%H\\{0xABCDE}\");\n+        test(String.format(\"%10H\", 12345), fmt.\"%10H\\{12345}\");\n+        test(String.format(\"%10H\", 0xABCDE), fmt.\"%10H\\{0xABCDE}\");\n+        test(String.format(\"%-10H\", 12345), fmt.\"%-10H\\{12345}\");\n+        test(String.format(\"%-10H\", 0xABCDE), fmt.\"%-10H\\{0xABCDE}\");\n+\n+        test(String.format(\"%s\", (byte)0xFF), fmt.\"%s\\{(byte)0xFF}\");\n+        test(String.format(\"%s\", (short)0xFFFF), fmt.\"%s\\{(short)0xFFFF}\");\n+        test(String.format(\"%s\", 12345), fmt.\"%s\\{12345}\");\n+        test(String.format(\"%s\", 12345L), fmt.\"%s\\{12345L}\");\n+        test(String.format(\"%s\", 1.33f), fmt.\"%s\\{1.33f}\");\n+        test(String.format(\"%s\", 1.33), fmt.\"%s\\{1.33}\");\n+        test(String.format(\"%s\", \"abcde\"), fmt.\"%s\\{\"abcde\"}\");\n+        test(String.format(\"%s\", nullObject), fmt.\"%s\\{nullObject}\");\n+        test(String.format(\"%10s\", (byte)0xFF), fmt.\"%10s\\{(byte)0xFF}\");\n+        test(String.format(\"%10s\", (short)0xFFFF), fmt.\"%10s\\{(short)0xFFFF}\");\n+        test(String.format(\"%10s\", 12345), fmt.\"%10s\\{12345}\");\n+        test(String.format(\"%10s\", 12345L), fmt.\"%10s\\{12345L}\");\n+        test(String.format(\"%10s\", 1.33f), fmt.\"%10s\\{1.33f}\");\n+        test(String.format(\"%10s\", 1.33), fmt.\"%10s\\{1.33}\");\n+        test(String.format(\"%10s\", \"abcde\"), fmt.\"%10s\\{\"abcde\"}\");\n+        test(String.format(\"%10s\", nullObject), fmt.\"%10s\\{nullObject}\");\n+        test(String.format(\"%-10s\", (byte)0xFF), fmt.\"%-10s\\{(byte)0xFF}\");\n+        test(String.format(\"%-10s\", (short)0xFFFF), fmt.\"%-10s\\{(short)0xFFFF}\");\n+        test(String.format(\"%-10s\", 12345), fmt.\"%-10s\\{12345}\");\n+        test(String.format(\"%-10s\", 12345L), fmt.\"%-10s\\{12345L}\");\n+        test(String.format(\"%-10s\", 1.33f), fmt.\"%-10s\\{1.33f}\");\n+        test(String.format(\"%-10s\", 1.33), fmt.\"%-10s\\{1.33}\");\n+        test(String.format(\"%-10s\", \"abcde\"), fmt.\"%-10s\\{\"abcde\"}\");\n+        test(String.format(\"%-10s\", nullObject), fmt.\"%-10s\\{nullObject}\");\n+        test(String.format(\"%S\", (byte)0xFF), fmt.\"%S\\{(byte)0xFF}\");\n+        test(String.format(\"%S\", (short)0xFFFF), fmt.\"%S\\{(short)0xFFFF}\");\n+        test(String.format(\"%S\", 12345), fmt.\"%S\\{12345}\");\n+        test(String.format(\"%S\", 12345L), fmt.\"%S\\{12345L}\");\n+        test(String.format(\"%S\", 1.33f), fmt.\"%S\\{1.33f}\");\n+        test(String.format(\"%S\", 1.33), fmt.\"%S\\{1.33}\");\n+        test(String.format(\"%S\", \"abcde\"), fmt.\"%S\\{\"abcde\"}\");\n+        test(String.format(\"%S\", nullObject), fmt.\"%S\\{nullObject}\");\n+        test(String.format(\"%10S\", (byte)0xFF), fmt.\"%10S\\{(byte)0xFF}\");\n+        test(String.format(\"%10S\", (short)0xFFFF), fmt.\"%10S\\{(short)0xFFFF}\");\n+        test(String.format(\"%10S\", 12345), fmt.\"%10S\\{12345}\");\n+        test(String.format(\"%10S\", 12345L), fmt.\"%10S\\{12345L}\");\n+        test(String.format(\"%10S\", 1.33f), fmt.\"%10S\\{1.33f}\");\n+        test(String.format(\"%10S\", 1.33), fmt.\"%10S\\{1.33}\");\n+        test(String.format(\"%10S\", \"abcde\"), fmt.\"%10S\\{\"abcde\"}\");\n+        test(String.format(\"%10S\", nullObject), fmt.\"%10S\\{nullObject}\");\n+        test(String.format(\"%-10S\", (byte)0xFF), fmt.\"%-10S\\{(byte)0xFF}\");\n+        test(String.format(\"%-10S\", (short)0xFFFF), fmt.\"%-10S\\{(short)0xFFFF}\");\n+        test(String.format(\"%-10S\", 12345), fmt.\"%-10S\\{12345}\");\n+        test(String.format(\"%-10S\", 12345L), fmt.\"%-10S\\{12345L}\");\n+        test(String.format(\"%-10S\", 1.33f), fmt.\"%-10S\\{1.33f}\");\n+        test(String.format(\"%-10S\", 1.33), fmt.\"%-10S\\{1.33}\");\n+        test(String.format(\"%-10S\", \"abcde\"), fmt.\"%-10S\\{\"abcde\"}\");\n+        test(String.format(\"%-10S\", nullObject), fmt.\"%-10S\\{nullObject}\");\n+\n+        test(String.format(\"%c\", 'a'), fmt.\"%c\\{'a'}\");\n+        test(String.format(\"%10c\", 'a'), fmt.\"%10c\\{'a'}\");\n+        test(String.format(\"%-10c\", 'a'), fmt.\"%-10c\\{'a'}\");\n+        test(String.format(\"%C\", 'a'), fmt.\"%C\\{'a'}\");\n+        test(String.format(\"%10C\", 'a'), fmt.\"%10C\\{'a'}\");\n+        test(String.format(\"%-10C\", 'a'), fmt.\"%-10C\\{'a'}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"% d\", -12345), fmt.\"% d\\{-12345}\");\n+        test(String.format(\"% d\", 0), fmt.\"% d\\{0}\");\n+        test(String.format(\"% d\", 12345), fmt.\"% d\\{12345}\");\n+        test(String.format(\"% 10d\", -12345), fmt.\"% 10d\\{-12345}\");\n+        test(String.format(\"% 10d\", 0), fmt.\"% 10d\\{0}\");\n+        test(String.format(\"% 10d\", 12345), fmt.\"% 10d\\{12345}\");\n+        test(String.format(\"% -10d\", -12345), fmt.\"% -10d\\{-12345}\");\n+        test(String.format(\"% -10d\", 0), fmt.\"% -10d\\{0}\");\n+        test(String.format(\"% -10d\", 12345), fmt.\"% -10d\\{12345}\");\n+        test(String.format(\"%, d\", -12345), fmt.\"%, d\\{-12345}\");\n+        test(String.format(\"%, d\", 0), fmt.\"%, d\\{0}\");\n+        test(String.format(\"%, d\", 12345), fmt.\"%, d\\{12345}\");\n+        test(String.format(\"%, 10d\", -12345), fmt.\"%, 10d\\{-12345}\");\n+        test(String.format(\"%, 10d\", 0), fmt.\"%, 10d\\{0}\");\n+        test(String.format(\"%, 10d\", 12345), fmt.\"%, 10d\\{12345}\");\n+        test(String.format(\"%, -10d\", -12345), fmt.\"%, -10d\\{-12345}\");\n+        test(String.format(\"%, -10d\", 0), fmt.\"%, -10d\\{0}\");\n+        test(String.format(\"%, -10d\", 12345), fmt.\"%, -10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+        test(String.format(\"% 010d\", -12345), fmt.\"% 010d\\{-12345}\");\n+        test(String.format(\"% 010d\", 0), fmt.\"% 010d\\{0}\");\n+        test(String.format(\"% 010d\", 12345), fmt.\"% 010d\\{12345}\");\n+        test(String.format(\"%, 010d\", -12345), fmt.\"%, 010d\\{-12345}\");\n+        test(String.format(\"%, 010d\", 0), fmt.\"%, 010d\\{0}\");\n+        test(String.format(\"%, 010d\", 12345), fmt.\"%, 010d\\{12345}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"%+d\", -12345), fmt.\"%+d\\{-12345}\");\n+        test(String.format(\"%+d\", 0), fmt.\"%+d\\{0}\");\n+        test(String.format(\"%+d\", 12345), fmt.\"%+d\\{12345}\");\n+        test(String.format(\"%+10d\", -12345), fmt.\"%+10d\\{-12345}\");\n+        test(String.format(\"%+10d\", 0), fmt.\"%+10d\\{0}\");\n+        test(String.format(\"%+10d\", 12345), fmt.\"%+10d\\{12345}\");\n+        test(String.format(\"%+-10d\", -12345), fmt.\"%+-10d\\{-12345}\");\n+        test(String.format(\"%+-10d\", 0), fmt.\"%+-10d\\{0}\");\n+        test(String.format(\"%+-10d\", 12345), fmt.\"%+-10d\\{12345}\");\n+        test(String.format(\"%,+d\", -12345), fmt.\"%,+d\\{-12345}\");\n+        test(String.format(\"%,+d\", 0), fmt.\"%,+d\\{0}\");\n+        test(String.format(\"%,+d\", 12345), fmt.\"%,+d\\{12345}\");\n+        test(String.format(\"%,+10d\", -12345), fmt.\"%,+10d\\{-12345}\");\n+        test(String.format(\"%,+10d\", 0), fmt.\"%,+10d\\{0}\");\n+        test(String.format(\"%,+10d\", 12345), fmt.\"%,+10d\\{12345}\");\n+        test(String.format(\"%,+-10d\", -12345), fmt.\"%,+-10d\\{-12345}\");\n+        test(String.format(\"%,+-10d\", 0), fmt.\"%,+-10d\\{0}\");\n+        test(String.format(\"%,+-10d\", 12345), fmt.\"%,+-10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+        test(String.format(\"%+010d\", -12345), fmt.\"%+010d\\{-12345}\");\n+        test(String.format(\"%+010d\", 0), fmt.\"%+010d\\{0}\");\n+        test(String.format(\"%+010d\", 12345), fmt.\"%+010d\\{12345}\");\n+        test(String.format(\"%,+010d\", -12345), fmt.\"%,+010d\\{-12345}\");\n+        test(String.format(\"%,+010d\", 0), fmt.\"%,+010d\\{0}\");\n+        test(String.format(\"%,+010d\", 12345), fmt.\"%,+010d\\{12345}\");\n+\n+        test(String.format(\"%d\", -12345), fmt.\"%d\\{-12345}\");\n+        test(String.format(\"%d\", 0), fmt.\"%d\\{0}\");\n+        test(String.format(\"%d\", 12345), fmt.\"%d\\{12345}\");\n+        test(String.format(\"%10d\", -12345), fmt.\"%10d\\{-12345}\");\n+        test(String.format(\"%10d\", 0), fmt.\"%10d\\{0}\");\n+        test(String.format(\"%10d\", 12345), fmt.\"%10d\\{12345}\");\n+        test(String.format(\"%-10d\", -12345), fmt.\"%-10d\\{-12345}\");\n+        test(String.format(\"%-10d\", 0), fmt.\"%-10d\\{0}\");\n+        test(String.format(\"%-10d\", 12345), fmt.\"%-10d\\{12345}\");\n+        test(String.format(\"%,d\", -12345), fmt.\"%,d\\{-12345}\");\n+        test(String.format(\"%,d\", 0), fmt.\"%,d\\{0}\");\n+        test(String.format(\"%,d\", 12345), fmt.\"%,d\\{12345}\");\n+        test(String.format(\"%,10d\", -12345), fmt.\"%,10d\\{-12345}\");\n+        test(String.format(\"%,10d\", 0), fmt.\"%,10d\\{0}\");\n+        test(String.format(\"%,10d\", 12345), fmt.\"%,10d\\{12345}\");\n+        test(String.format(\"%,-10d\", -12345), fmt.\"%,-10d\\{-12345}\");\n+        test(String.format(\"%,-10d\", 0), fmt.\"%,-10d\\{0}\");\n+        test(String.format(\"%,-10d\", 12345), fmt.\"%,-10d\\{12345}\");\n+        test(String.format(\"%(d\", -12345), fmt.\"%(d\\{-12345}\");\n+        test(String.format(\"%(d\", 0), fmt.\"%(d\\{0}\");\n+        test(String.format(\"%(d\", 12345), fmt.\"%(d\\{12345}\");\n+        test(String.format(\"%(10d\", -12345), fmt.\"%(10d\\{-12345}\");\n+        test(String.format(\"%(10d\", 0), fmt.\"%(10d\\{0}\");\n+        test(String.format(\"%(10d\", 12345), fmt.\"%(10d\\{12345}\");\n+        test(String.format(\"%(-10d\", -12345), fmt.\"%(-10d\\{-12345}\");\n+        test(String.format(\"%(-10d\", 0), fmt.\"%(-10d\\{0}\");\n+        test(String.format(\"%(-10d\", 12345), fmt.\"%(-10d\\{12345}\");\n+        test(String.format(\"%,(d\", -12345), fmt.\"%,(d\\{-12345}\");\n+        test(String.format(\"%,(d\", 0), fmt.\"%,(d\\{0}\");\n+        test(String.format(\"%,(d\", 12345), fmt.\"%,(d\\{12345}\");\n+        test(String.format(\"%,(10d\", -12345), fmt.\"%,(10d\\{-12345}\");\n+        test(String.format(\"%,(10d\", 0), fmt.\"%,(10d\\{0}\");\n+        test(String.format(\"%,(10d\", 12345), fmt.\"%,(10d\\{12345}\");\n+        test(String.format(\"%,(-10d\", -12345), fmt.\"%,(-10d\\{-12345}\");\n+        test(String.format(\"%,(-10d\", 0), fmt.\"%,(-10d\\{0}\");\n+        test(String.format(\"%,(-10d\", 12345), fmt.\"%,(-10d\\{12345}\");\n+        test(String.format(\"%010d\", -12345), fmt.\"%010d\\{-12345}\");\n+        test(String.format(\"%010d\", 0), fmt.\"%010d\\{0}\");\n+        test(String.format(\"%010d\", 12345), fmt.\"%010d\\{12345}\");\n+        test(String.format(\"%,010d\", -12345), fmt.\"%,010d\\{-12345}\");\n+        test(String.format(\"%,010d\", 0), fmt.\"%,010d\\{0}\");\n+        test(String.format(\"%,010d\", 12345), fmt.\"%,010d\\{12345}\");\n+        test(String.format(\"%(010d\", -12345), fmt.\"%(010d\\{-12345}\");\n+        test(String.format(\"%(010d\", 0), fmt.\"%(010d\\{0}\");\n+        test(String.format(\"%(010d\", 12345), fmt.\"%(010d\\{12345}\");\n+        test(String.format(\"%,(010d\", -12345), fmt.\"%,(010d\\{-12345}\");\n+        test(String.format(\"%,(010d\", 0), fmt.\"%,(010d\\{0}\");\n+        test(String.format(\"%,(010d\", 12345), fmt.\"%,(010d\\{12345}\");\n+\n+        test(String.format(\"%o\", -12345), fmt.\"%o\\{-12345}\");\n+        test(String.format(\"%o\", 0), fmt.\"%o\\{0}\");\n+        test(String.format(\"%o\", 12345), fmt.\"%o\\{12345}\");\n+        test(String.format(\"%10o\", -12345), fmt.\"%10o\\{-12345}\");\n+        test(String.format(\"%10o\", 0), fmt.\"%10o\\{0}\");\n+        test(String.format(\"%10o\", 12345), fmt.\"%10o\\{12345}\");\n+        test(String.format(\"%-10o\", -12345), fmt.\"%-10o\\{-12345}\");\n+        test(String.format(\"%-10o\", 0), fmt.\"%-10o\\{0}\");\n+        test(String.format(\"%-10o\", 12345), fmt.\"%-10o\\{12345}\");\n+        test(String.format(\"%#o\", -12345), fmt.\"%#o\\{-12345}\");\n+        test(String.format(\"%#o\", 0), fmt.\"%#o\\{0}\");\n+        test(String.format(\"%#o\", 12345), fmt.\"%#o\\{12345}\");\n+        test(String.format(\"%#10o\", -12345), fmt.\"%#10o\\{-12345}\");\n+        test(String.format(\"%#10o\", 0), fmt.\"%#10o\\{0}\");\n+        test(String.format(\"%#10o\", 12345), fmt.\"%#10o\\{12345}\");\n+        test(String.format(\"%#-10o\", -12345), fmt.\"%#-10o\\{-12345}\");\n+        test(String.format(\"%#-10o\", 0), fmt.\"%#-10o\\{0}\");\n+        test(String.format(\"%#-10o\", 12345), fmt.\"%#-10o\\{12345}\");\n+        test(String.format(\"%010o\", -12345), fmt.\"%010o\\{-12345}\");\n+        test(String.format(\"%010o\", 0), fmt.\"%010o\\{0}\");\n+        test(String.format(\"%010o\", 12345), fmt.\"%010o\\{12345}\");\n+        test(String.format(\"%#010o\", -12345), fmt.\"%#010o\\{-12345}\");\n+        test(String.format(\"%#010o\", 0), fmt.\"%#010o\\{0}\");\n+        test(String.format(\"%#010o\", 12345), fmt.\"%#010o\\{12345}\");\n+\n+        test(String.format(\"%x\", -12345), fmt.\"%x\\{-12345}\");\n+        test(String.format(\"%x\", 0), fmt.\"%x\\{0}\");\n+        test(String.format(\"%x\", 12345), fmt.\"%x\\{12345}\");\n+        test(String.format(\"%10x\", -12345), fmt.\"%10x\\{-12345}\");\n+        test(String.format(\"%10x\", 0), fmt.\"%10x\\{0}\");\n+        test(String.format(\"%10x\", 12345), fmt.\"%10x\\{12345}\");\n+        test(String.format(\"%-10x\", -12345), fmt.\"%-10x\\{-12345}\");\n+        test(String.format(\"%-10x\", 0), fmt.\"%-10x\\{0}\");\n+        test(String.format(\"%-10x\", 12345), fmt.\"%-10x\\{12345}\");\n+        test(String.format(\"%X\", -12345), fmt.\"%X\\{-12345}\");\n+        test(String.format(\"%X\", 0), fmt.\"%X\\{0}\");\n+        test(String.format(\"%X\", 12345), fmt.\"%X\\{12345}\");\n+        test(String.format(\"%10X\", -12345), fmt.\"%10X\\{-12345}\");\n+        test(String.format(\"%10X\", 0), fmt.\"%10X\\{0}\");\n+        test(String.format(\"%10X\", 12345), fmt.\"%10X\\{12345}\");\n+        test(String.format(\"%-10X\", -12345), fmt.\"%-10X\\{-12345}\");\n+        test(String.format(\"%-10X\", 0), fmt.\"%-10X\\{0}\");\n+        test(String.format(\"%-10X\", 12345), fmt.\"%-10X\\{12345}\");\n+        test(String.format(\"%#x\", -12345), fmt.\"%#x\\{-12345}\");\n+        test(String.format(\"%#x\", 0), fmt.\"%#x\\{0}\");\n+        test(String.format(\"%#x\", 12345), fmt.\"%#x\\{12345}\");\n+        test(String.format(\"%#10x\", -12345), fmt.\"%#10x\\{-12345}\");\n+        test(String.format(\"%#10x\", 0), fmt.\"%#10x\\{0}\");\n+        test(String.format(\"%#10x\", 12345), fmt.\"%#10x\\{12345}\");\n+        test(String.format(\"%#-10x\", -12345), fmt.\"%#-10x\\{-12345}\");\n+        test(String.format(\"%#-10x\", 0), fmt.\"%#-10x\\{0}\");\n+        test(String.format(\"%#-10x\", 12345), fmt.\"%#-10x\\{12345}\");\n+        test(String.format(\"%#X\", -12345), fmt.\"%#X\\{-12345}\");\n+        test(String.format(\"%#X\", 0), fmt.\"%#X\\{0}\");\n+        test(String.format(\"%#X\", 12345), fmt.\"%#X\\{12345}\");\n+        test(String.format(\"%#10X\", -12345), fmt.\"%#10X\\{-12345}\");\n+        test(String.format(\"%#10X\", 0), fmt.\"%#10X\\{0}\");\n+        test(String.format(\"%#10X\", 12345), fmt.\"%#10X\\{12345}\");\n+        test(String.format(\"%#-10X\", -12345), fmt.\"%#-10X\\{-12345}\");\n+        test(String.format(\"%#-10X\", 0), fmt.\"%#-10X\\{0}\");\n+        test(String.format(\"%#-10X\", 12345), fmt.\"%#-10X\\{12345}\");\n+        test(String.format(\"%010x\", -12345), fmt.\"%010x\\{-12345}\");\n+        test(String.format(\"%010x\", 0), fmt.\"%010x\\{0}\");\n+        test(String.format(\"%010x\", 12345), fmt.\"%010x\\{12345}\");\n+        test(String.format(\"%010X\", -12345), fmt.\"%010X\\{-12345}\");\n+        test(String.format(\"%010X\", 0), fmt.\"%010X\\{0}\");\n+        test(String.format(\"%010X\", 12345), fmt.\"%010X\\{12345}\");\n+        test(String.format(\"%#010x\", -12345), fmt.\"%#010x\\{-12345}\");\n+        test(String.format(\"%#010x\", 0), fmt.\"%#010x\\{0}\");\n+        test(String.format(\"%#010x\", 12345), fmt.\"%#010x\\{12345}\");\n+        test(String.format(\"%#010X\", -12345), fmt.\"%#010X\\{-12345}\");\n+        test(String.format(\"%#010X\", 0), fmt.\"%#010X\\{0}\");\n+        test(String.format(\"%#010X\", 12345), fmt.\"%#010X\\{12345}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+        test(String.format(\"% f\", -12345.6), fmt.\"% f\\{-12345.6}\");\n+        test(String.format(\"% f\", 0.0), fmt.\"% f\\{0.0}\");\n+        test(String.format(\"% f\", 12345.6), fmt.\"% f\\{12345.6}\");\n+        test(String.format(\"% 10f\", -12345.6), fmt.\"% 10f\\{-12345.6}\");\n+        test(String.format(\"% 10f\", 0.0), fmt.\"% 10f\\{0.0}\");\n+        test(String.format(\"% 10f\", 12345.6), fmt.\"% 10f\\{12345.6}\");\n+        test(String.format(\"% -10f\", -12345.6), fmt.\"% -10f\\{-12345.6}\");\n+        test(String.format(\"% -10f\", 0.0), fmt.\"% -10f\\{0.0}\");\n+        test(String.format(\"% -10f\", 12345.6), fmt.\"% -10f\\{12345.6}\");\n+        test(String.format(\"%, f\", -12345.6), fmt.\"%, f\\{-12345.6}\");\n+        test(String.format(\"%, f\", 0.0), fmt.\"%, f\\{0.0}\");\n+        test(String.format(\"%, f\", 12345.6), fmt.\"%, f\\{12345.6}\");\n+        test(String.format(\"%, 10f\", -12345.6), fmt.\"%, 10f\\{-12345.6}\");\n+        test(String.format(\"%, 10f\", 0.0), fmt.\"%, 10f\\{0.0}\");\n+        test(String.format(\"%, 10f\", 12345.6), fmt.\"%, 10f\\{12345.6}\");\n+        test(String.format(\"%, -10f\", -12345.6), fmt.\"%, -10f\\{-12345.6}\");\n+        test(String.format(\"%, -10f\", 0.0), fmt.\"%, -10f\\{0.0}\");\n+        test(String.format(\"%, -10f\", 12345.6), fmt.\"%, -10f\\{12345.6}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n+        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n+        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n+        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n+        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n+        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n+        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n+        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n+        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n+        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n+        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n+        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n+        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n+        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n+        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n+        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n+        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n+        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n+\n+        test(String.format(\"%f\", -12345.6), fmt.\"%f\\{-12345.6}\");\n+        test(String.format(\"%f\", 0.0), fmt.\"%f\\{0.0}\");\n+        test(String.format(\"%f\", 12345.6), fmt.\"%f\\{12345.6}\");\n+        test(String.format(\"%10f\", -12345.6), fmt.\"%10f\\{-12345.6}\");\n+        test(String.format(\"%10f\", 0.0), fmt.\"%10f\\{0.0}\");\n+        test(String.format(\"%10f\", 12345.6), fmt.\"%10f\\{12345.6}\");\n+        test(String.format(\"%-10f\", -12345.6), fmt.\"%-10f\\{-12345.6}\");\n+        test(String.format(\"%-10f\", 0.0), fmt.\"%-10f\\{0.0}\");\n+        test(String.format(\"%-10f\", 12345.6), fmt.\"%-10f\\{12345.6}\");\n+        test(String.format(\"%,f\", -12345.6), fmt.\"%,f\\{-12345.6}\");\n+        test(String.format(\"%,f\", 0.0), fmt.\"%,f\\{0.0}\");\n+        test(String.format(\"%,f\", 12345.6), fmt.\"%,f\\{12345.6}\");\n+        test(String.format(\"%,10f\", -12345.6), fmt.\"%,10f\\{-12345.6}\");\n+        test(String.format(\"%,10f\", 0.0), fmt.\"%,10f\\{0.0}\");\n+        test(String.format(\"%,10f\", 12345.6), fmt.\"%,10f\\{12345.6}\");\n+        test(String.format(\"%,-10f\", -12345.6), fmt.\"%,-10f\\{-12345.6}\");\n+        test(String.format(\"%,-10f\", 0.0), fmt.\"%,-10f\\{0.0}\");\n+        test(String.format(\"%,-10f\", 12345.6), fmt.\"%,-10f\\{12345.6}\");\n+        test(String.format(\"%(f\", -12345.6), fmt.\"%(f\\{-12345.6}\");\n+        test(String.format(\"%(f\", 0.0), fmt.\"%(f\\{0.0}\");\n+        test(String.format(\"%(f\", 12345.6), fmt.\"%(f\\{12345.6}\");\n+        test(String.format(\"%(10f\", -12345.6), fmt.\"%(10f\\{-12345.6}\");\n+        test(String.format(\"%(10f\", 0.0), fmt.\"%(10f\\{0.0}\");\n+        test(String.format(\"%(10f\", 12345.6), fmt.\"%(10f\\{12345.6}\");\n+        test(String.format(\"%(-10f\", -12345.6), fmt.\"%(-10f\\{-12345.6}\");\n+        test(String.format(\"%(-10f\", 0.0), fmt.\"%(-10f\\{0.0}\");\n+        test(String.format(\"%(-10f\", 12345.6), fmt.\"%(-10f\\{12345.6}\");\n+        test(String.format(\"%,(f\", -12345.6), fmt.\"%,(f\\{-12345.6}\");\n+        test(String.format(\"%,(f\", 0.0), fmt.\"%,(f\\{0.0}\");\n+        test(String.format(\"%,(f\", 12345.6), fmt.\"%,(f\\{12345.6}\");\n+        test(String.format(\"%,(10f\", -12345.6), fmt.\"%,(10f\\{-12345.6}\");\n+        test(String.format(\"%,(10f\", 0.0), fmt.\"%,(10f\\{0.0}\");\n+        test(String.format(\"%,(10f\", 12345.6), fmt.\"%,(10f\\{12345.6}\");\n+        test(String.format(\"%,(-10f\", -12345.6), fmt.\"%,(-10f\\{-12345.6}\");\n+        test(String.format(\"%,(-10f\", 0.0), fmt.\"%,(-10f\\{0.0}\");\n+        test(String.format(\"%,(-10f\", 12345.6), fmt.\"%,(-10f\\{12345.6}\");\n+        test(String.format(\"%+f\", -12345.6), fmt.\"%+f\\{-12345.6}\");\n+        test(String.format(\"%+f\", 0.0), fmt.\"%+f\\{0.0}\");\n+        test(String.format(\"%+f\", 12345.6), fmt.\"%+f\\{12345.6}\");\n+        test(String.format(\"%+10f\", -12345.6), fmt.\"%+10f\\{-12345.6}\");\n+        test(String.format(\"%+10f\", 0.0), fmt.\"%+10f\\{0.0}\");\n+        test(String.format(\"%+10f\", 12345.6), fmt.\"%+10f\\{12345.6}\");\n+        test(String.format(\"%+-10f\", -12345.6), fmt.\"%+-10f\\{-12345.6}\");\n+        test(String.format(\"%+-10f\", 0.0), fmt.\"%+-10f\\{0.0}\");\n+        test(String.format(\"%+-10f\", 12345.6), fmt.\"%+-10f\\{12345.6}\");\n+        test(String.format(\"%,+f\", -12345.6), fmt.\"%,+f\\{-12345.6}\");\n+        test(String.format(\"%,+f\", 0.0), fmt.\"%,+f\\{0.0}\");\n+        test(String.format(\"%,+f\", 12345.6), fmt.\"%,+f\\{12345.6}\");\n+        test(String.format(\"%,+10f\", -12345.6), fmt.\"%,+10f\\{-12345.6}\");\n+        test(String.format(\"%,+10f\", 0.0), fmt.\"%,+10f\\{0.0}\");\n+        test(String.format(\"%,+10f\", 12345.6), fmt.\"%,+10f\\{12345.6}\");\n+        test(String.format(\"%,+-10f\", -12345.6), fmt.\"%,+-10f\\{-12345.6}\");\n+        test(String.format(\"%,+-10f\", 0.0), fmt.\"%,+-10f\\{0.0}\");\n+        test(String.format(\"%,+-10f\", 12345.6), fmt.\"%,+-10f\\{12345.6}\");\n+        test(String.format(\"%(+f\", -12345.6), fmt.\"%(+f\\{-12345.6}\");\n+        test(String.format(\"%(+f\", 0.0), fmt.\"%(+f\\{0.0}\");\n+        test(String.format(\"%(+f\", 12345.6), fmt.\"%(+f\\{12345.6}\");\n+        test(String.format(\"%(+10f\", -12345.6), fmt.\"%(+10f\\{-12345.6}\");\n+        test(String.format(\"%(+10f\", 0.0), fmt.\"%(+10f\\{0.0}\");\n+        test(String.format(\"%(+10f\", 12345.6), fmt.\"%(+10f\\{12345.6}\");\n+        test(String.format(\"%(+-10f\", -12345.6), fmt.\"%(+-10f\\{-12345.6}\");\n+        test(String.format(\"%(+-10f\", 0.0), fmt.\"%(+-10f\\{0.0}\");\n+        test(String.format(\"%(+-10f\", 12345.6), fmt.\"%(+-10f\\{12345.6}\");\n+        test(String.format(\"%,(+f\", -12345.6), fmt.\"%,(+f\\{-12345.6}\");\n+        test(String.format(\"%,(+f\", 0.0), fmt.\"%,(+f\\{0.0}\");\n+        test(String.format(\"%,(+f\", 12345.6), fmt.\"%,(+f\\{12345.6}\");\n+        test(String.format(\"%,(+10f\", -12345.6), fmt.\"%,(+10f\\{-12345.6}\");\n+        test(String.format(\"%,(+10f\", 0.0), fmt.\"%,(+10f\\{0.0}\");\n+        test(String.format(\"%,(+10f\", 12345.6), fmt.\"%,(+10f\\{12345.6}\");\n+        test(String.format(\"%,(+-10f\", -12345.6), fmt.\"%,(+-10f\\{-12345.6}\");\n+        test(String.format(\"%,(+-10f\", 0.0), fmt.\"%,(+-10f\\{0.0}\");\n+        test(String.format(\"%,(+-10f\", 12345.6), fmt.\"%,(+-10f\\{12345.6}\");\n+\n+        test(String.format(\"%e\", -12345.6), fmt.\"%e\\{-12345.6}\");\n+        test(String.format(\"%e\", 0.0), fmt.\"%e\\{0.0}\");\n+        test(String.format(\"%e\", 12345.6), fmt.\"%e\\{12345.6}\");\n+        test(String.format(\"%10e\", -12345.6), fmt.\"%10e\\{-12345.6}\");\n+        test(String.format(\"%10e\", 0.0), fmt.\"%10e\\{0.0}\");\n+        test(String.format(\"%10e\", 12345.6), fmt.\"%10e\\{12345.6}\");\n+        test(String.format(\"%-10e\", -12345.6), fmt.\"%-10e\\{-12345.6}\");\n+        test(String.format(\"%-10e\", 0.0), fmt.\"%-10e\\{0.0}\");\n+        test(String.format(\"%-10e\", 12345.6), fmt.\"%-10e\\{12345.6}\");\n+        test(String.format(\"%E\", -12345.6), fmt.\"%E\\{-12345.6}\");\n+        test(String.format(\"%E\", 0.0), fmt.\"%E\\{0.0}\");\n+        test(String.format(\"%E\", 12345.6), fmt.\"%E\\{12345.6}\");\n+        test(String.format(\"%10E\", -12345.6), fmt.\"%10E\\{-12345.6}\");\n+        test(String.format(\"%10E\", 0.0), fmt.\"%10E\\{0.0}\");\n+        test(String.format(\"%10E\", 12345.6), fmt.\"%10E\\{12345.6}\");\n+        test(String.format(\"%-10E\", -12345.6), fmt.\"%-10E\\{-12345.6}\");\n+        test(String.format(\"%-10E\", 0.0), fmt.\"%-10E\\{0.0}\");\n+        test(String.format(\"%-10E\", 12345.6), fmt.\"%-10E\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+        test(String.format(\"% g\", -12345.6), fmt.\"% g\\{-12345.6}\");\n+        test(String.format(\"% g\", 0.0), fmt.\"% g\\{0.0}\");\n+        test(String.format(\"% g\", 12345.6), fmt.\"% g\\{12345.6}\");\n+        test(String.format(\"% 10g\", -12345.6), fmt.\"% 10g\\{-12345.6}\");\n+        test(String.format(\"% 10g\", 0.0), fmt.\"% 10g\\{0.0}\");\n+        test(String.format(\"% 10g\", 12345.6), fmt.\"% 10g\\{12345.6}\");\n+        test(String.format(\"% -10g\", -12345.6), fmt.\"% -10g\\{-12345.6}\");\n+        test(String.format(\"% -10g\", 0.0), fmt.\"% -10g\\{0.0}\");\n+        test(String.format(\"% -10g\", 12345.6), fmt.\"% -10g\\{12345.6}\");\n+        test(String.format(\"% G\", -12345.6), fmt.\"% G\\{-12345.6}\");\n+        test(String.format(\"% G\", 0.0), fmt.\"% G\\{0.0}\");\n+        test(String.format(\"% G\", 12345.6), fmt.\"% G\\{12345.6}\");\n+        test(String.format(\"% 10G\", -12345.6), fmt.\"% 10G\\{-12345.6}\");\n+        test(String.format(\"% 10G\", 0.0), fmt.\"% 10G\\{0.0}\");\n+        test(String.format(\"% 10G\", 12345.6), fmt.\"% 10G\\{12345.6}\");\n+        test(String.format(\"% -10G\", -12345.6), fmt.\"% -10G\\{-12345.6}\");\n+        test(String.format(\"% -10G\", 0.0), fmt.\"% -10G\\{0.0}\");\n+        test(String.format(\"% -10G\", 12345.6), fmt.\"% -10G\\{12345.6}\");\n+        test(String.format(\"%, g\", -12345.6), fmt.\"%, g\\{-12345.6}\");\n+        test(String.format(\"%, g\", 0.0), fmt.\"%, g\\{0.0}\");\n+        test(String.format(\"%, g\", 12345.6), fmt.\"%, g\\{12345.6}\");\n+        test(String.format(\"%, 10g\", -12345.6), fmt.\"%, 10g\\{-12345.6}\");\n+        test(String.format(\"%, 10g\", 0.0), fmt.\"%, 10g\\{0.0}\");\n+        test(String.format(\"%, 10g\", 12345.6), fmt.\"%, 10g\\{12345.6}\");\n+        test(String.format(\"%, -10g\", -12345.6), fmt.\"%, -10g\\{-12345.6}\");\n+        test(String.format(\"%, -10g\", 0.0), fmt.\"%, -10g\\{0.0}\");\n+        test(String.format(\"%, -10g\", 12345.6), fmt.\"%, -10g\\{12345.6}\");\n+        test(String.format(\"%, G\", -12345.6), fmt.\"%, G\\{-12345.6}\");\n+        test(String.format(\"%, G\", 0.0), fmt.\"%, G\\{0.0}\");\n+        test(String.format(\"%, G\", 12345.6), fmt.\"%, G\\{12345.6}\");\n+        test(String.format(\"%, 10G\", -12345.6), fmt.\"%, 10G\\{-12345.6}\");\n+        test(String.format(\"%, 10G\", 0.0), fmt.\"%, 10G\\{0.0}\");\n+        test(String.format(\"%, 10G\", 12345.6), fmt.\"%, 10G\\{12345.6}\");\n+        test(String.format(\"%, -10G\", -12345.6), fmt.\"%, -10G\\{-12345.6}\");\n+        test(String.format(\"%, -10G\", 0.0), fmt.\"%, -10G\\{0.0}\");\n+        test(String.format(\"%, -10G\", 12345.6), fmt.\"%, -10G\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n+        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n+        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n+        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n+        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n+        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n+        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n+        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n+        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n+        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n+        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n+        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n+        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n+        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n+        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n+        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n+        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n+        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n+        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n+        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n+        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n+        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n+        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n+        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n+        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n+        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n+        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n+        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n+        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n+        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n+        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n+        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n+        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n+        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n+        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n+        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n+\n+        test(String.format(\"%g\", -12345.6), fmt.\"%g\\{-12345.6}\");\n+        test(String.format(\"%g\", 0.0), fmt.\"%g\\{0.0}\");\n+        test(String.format(\"%g\", 12345.6), fmt.\"%g\\{12345.6}\");\n+        test(String.format(\"%10g\", -12345.6), fmt.\"%10g\\{-12345.6}\");\n+        test(String.format(\"%10g\", 0.0), fmt.\"%10g\\{0.0}\");\n+        test(String.format(\"%10g\", 12345.6), fmt.\"%10g\\{12345.6}\");\n+        test(String.format(\"%-10g\", -12345.6), fmt.\"%-10g\\{-12345.6}\");\n+        test(String.format(\"%-10g\", 0.0), fmt.\"%-10g\\{0.0}\");\n+        test(String.format(\"%-10g\", 12345.6), fmt.\"%-10g\\{12345.6}\");\n+        test(String.format(\"%G\", -12345.6), fmt.\"%G\\{-12345.6}\");\n+        test(String.format(\"%G\", 0.0), fmt.\"%G\\{0.0}\");\n+        test(String.format(\"%G\", 12345.6), fmt.\"%G\\{12345.6}\");\n+        test(String.format(\"%10G\", -12345.6), fmt.\"%10G\\{-12345.6}\");\n+        test(String.format(\"%10G\", 0.0), fmt.\"%10G\\{0.0}\");\n+        test(String.format(\"%10G\", 12345.6), fmt.\"%10G\\{12345.6}\");\n+        test(String.format(\"%-10G\", -12345.6), fmt.\"%-10G\\{-12345.6}\");\n+        test(String.format(\"%-10G\", 0.0), fmt.\"%-10G\\{0.0}\");\n+        test(String.format(\"%-10G\", 12345.6), fmt.\"%-10G\\{12345.6}\");\n+        test(String.format(\"%,g\", -12345.6), fmt.\"%,g\\{-12345.6}\");\n+        test(String.format(\"%,g\", 0.0), fmt.\"%,g\\{0.0}\");\n+        test(String.format(\"%,g\", 12345.6), fmt.\"%,g\\{12345.6}\");\n+        test(String.format(\"%,10g\", -12345.6), fmt.\"%,10g\\{-12345.6}\");\n+        test(String.format(\"%,10g\", 0.0), fmt.\"%,10g\\{0.0}\");\n+        test(String.format(\"%,10g\", 12345.6), fmt.\"%,10g\\{12345.6}\");\n+        test(String.format(\"%,-10g\", -12345.6), fmt.\"%,-10g\\{-12345.6}\");\n+        test(String.format(\"%,-10g\", 0.0), fmt.\"%,-10g\\{0.0}\");\n+        test(String.format(\"%,-10g\", 12345.6), fmt.\"%,-10g\\{12345.6}\");\n+        test(String.format(\"%,G\", -12345.6), fmt.\"%,G\\{-12345.6}\");\n+        test(String.format(\"%,G\", 0.0), fmt.\"%,G\\{0.0}\");\n+        test(String.format(\"%,G\", 12345.6), fmt.\"%,G\\{12345.6}\");\n+        test(String.format(\"%,10G\", -12345.6), fmt.\"%,10G\\{-12345.6}\");\n+        test(String.format(\"%,10G\", 0.0), fmt.\"%,10G\\{0.0}\");\n+        test(String.format(\"%,10G\", 12345.6), fmt.\"%,10G\\{12345.6}\");\n+        test(String.format(\"%,-10G\", -12345.6), fmt.\"%,-10G\\{-12345.6}\");\n+        test(String.format(\"%,-10G\", 0.0), fmt.\"%,-10G\\{0.0}\");\n+        test(String.format(\"%,-10G\", 12345.6), fmt.\"%,-10G\\{12345.6}\");\n+        test(String.format(\"%(g\", -12345.6), fmt.\"%(g\\{-12345.6}\");\n+        test(String.format(\"%(g\", 0.0), fmt.\"%(g\\{0.0}\");\n+        test(String.format(\"%(g\", 12345.6), fmt.\"%(g\\{12345.6}\");\n+        test(String.format(\"%(10g\", -12345.6), fmt.\"%(10g\\{-12345.6}\");\n+        test(String.format(\"%(10g\", 0.0), fmt.\"%(10g\\{0.0}\");\n+        test(String.format(\"%(10g\", 12345.6), fmt.\"%(10g\\{12345.6}\");\n+        test(String.format(\"%(-10g\", -12345.6), fmt.\"%(-10g\\{-12345.6}\");\n+        test(String.format(\"%(-10g\", 0.0), fmt.\"%(-10g\\{0.0}\");\n+        test(String.format(\"%(-10g\", 12345.6), fmt.\"%(-10g\\{12345.6}\");\n+        test(String.format(\"%(G\", -12345.6), fmt.\"%(G\\{-12345.6}\");\n+        test(String.format(\"%(G\", 0.0), fmt.\"%(G\\{0.0}\");\n+        test(String.format(\"%(G\", 12345.6), fmt.\"%(G\\{12345.6}\");\n+        test(String.format(\"%(10G\", -12345.6), fmt.\"%(10G\\{-12345.6}\");\n+        test(String.format(\"%(10G\", 0.0), fmt.\"%(10G\\{0.0}\");\n+        test(String.format(\"%(10G\", 12345.6), fmt.\"%(10G\\{12345.6}\");\n+        test(String.format(\"%(-10G\", -12345.6), fmt.\"%(-10G\\{-12345.6}\");\n+        test(String.format(\"%(-10G\", 0.0), fmt.\"%(-10G\\{0.0}\");\n+        test(String.format(\"%(-10G\", 12345.6), fmt.\"%(-10G\\{12345.6}\");\n+        test(String.format(\"%,(g\", -12345.6), fmt.\"%,(g\\{-12345.6}\");\n+        test(String.format(\"%,(g\", 0.0), fmt.\"%,(g\\{0.0}\");\n+        test(String.format(\"%,(g\", 12345.6), fmt.\"%,(g\\{12345.6}\");\n+        test(String.format(\"%,(10g\", -12345.6), fmt.\"%,(10g\\{-12345.6}\");\n+        test(String.format(\"%,(10g\", 0.0), fmt.\"%,(10g\\{0.0}\");\n+        test(String.format(\"%,(10g\", 12345.6), fmt.\"%,(10g\\{12345.6}\");\n+        test(String.format(\"%,(-10g\", -12345.6), fmt.\"%,(-10g\\{-12345.6}\");\n+        test(String.format(\"%,(-10g\", 0.0), fmt.\"%,(-10g\\{0.0}\");\n+        test(String.format(\"%,(-10g\", 12345.6), fmt.\"%,(-10g\\{12345.6}\");\n+        test(String.format(\"%,(G\", -12345.6), fmt.\"%,(G\\{-12345.6}\");\n+        test(String.format(\"%,(G\", 0.0), fmt.\"%,(G\\{0.0}\");\n+        test(String.format(\"%,(G\", 12345.6), fmt.\"%,(G\\{12345.6}\");\n+        test(String.format(\"%,(10G\", -12345.6), fmt.\"%,(10G\\{-12345.6}\");\n+        test(String.format(\"%,(10G\", 0.0), fmt.\"%,(10G\\{0.0}\");\n+        test(String.format(\"%,(10G\", 12345.6), fmt.\"%,(10G\\{12345.6}\");\n+        test(String.format(\"%,(-10G\", -12345.6), fmt.\"%,(-10G\\{-12345.6}\");\n+        test(String.format(\"%,(-10G\", 0.0), fmt.\"%,(-10G\\{0.0}\");\n+        test(String.format(\"%,(-10G\", 12345.6), fmt.\"%,(-10G\\{12345.6}\");\n+        test(String.format(\"%+g\", -12345.6), fmt.\"%+g\\{-12345.6}\");\n+        test(String.format(\"%+g\", 0.0), fmt.\"%+g\\{0.0}\");\n+        test(String.format(\"%+g\", 12345.6), fmt.\"%+g\\{12345.6}\");\n+        test(String.format(\"%+10g\", -12345.6), fmt.\"%+10g\\{-12345.6}\");\n+        test(String.format(\"%+10g\", 0.0), fmt.\"%+10g\\{0.0}\");\n+        test(String.format(\"%+10g\", 12345.6), fmt.\"%+10g\\{12345.6}\");\n+        test(String.format(\"%+-10g\", -12345.6), fmt.\"%+-10g\\{-12345.6}\");\n+        test(String.format(\"%+-10g\", 0.0), fmt.\"%+-10g\\{0.0}\");\n+        test(String.format(\"%+-10g\", 12345.6), fmt.\"%+-10g\\{12345.6}\");\n+        test(String.format(\"%+G\", -12345.6), fmt.\"%+G\\{-12345.6}\");\n+        test(String.format(\"%+G\", 0.0), fmt.\"%+G\\{0.0}\");\n+        test(String.format(\"%+G\", 12345.6), fmt.\"%+G\\{12345.6}\");\n+        test(String.format(\"%+10G\", -12345.6), fmt.\"%+10G\\{-12345.6}\");\n+        test(String.format(\"%+10G\", 0.0), fmt.\"%+10G\\{0.0}\");\n+        test(String.format(\"%+10G\", 12345.6), fmt.\"%+10G\\{12345.6}\");\n+        test(String.format(\"%+-10G\", -12345.6), fmt.\"%+-10G\\{-12345.6}\");\n+        test(String.format(\"%+-10G\", 0.0), fmt.\"%+-10G\\{0.0}\");\n+        test(String.format(\"%+-10G\", 12345.6), fmt.\"%+-10G\\{12345.6}\");\n+        test(String.format(\"%,+g\", -12345.6), fmt.\"%,+g\\{-12345.6}\");\n+        test(String.format(\"%,+g\", 0.0), fmt.\"%,+g\\{0.0}\");\n+        test(String.format(\"%,+g\", 12345.6), fmt.\"%,+g\\{12345.6}\");\n+        test(String.format(\"%,+10g\", -12345.6), fmt.\"%,+10g\\{-12345.6}\");\n+        test(String.format(\"%,+10g\", 0.0), fmt.\"%,+10g\\{0.0}\");\n+        test(String.format(\"%,+10g\", 12345.6), fmt.\"%,+10g\\{12345.6}\");\n+        test(String.format(\"%,+-10g\", -12345.6), fmt.\"%,+-10g\\{-12345.6}\");\n+        test(String.format(\"%,+-10g\", 0.0), fmt.\"%,+-10g\\{0.0}\");\n+        test(String.format(\"%,+-10g\", 12345.6), fmt.\"%,+-10g\\{12345.6}\");\n+        test(String.format(\"%,+G\", -12345.6), fmt.\"%,+G\\{-12345.6}\");\n+        test(String.format(\"%,+G\", 0.0), fmt.\"%,+G\\{0.0}\");\n+        test(String.format(\"%,+G\", 12345.6), fmt.\"%,+G\\{12345.6}\");\n+        test(String.format(\"%,+10G\", -12345.6), fmt.\"%,+10G\\{-12345.6}\");\n+        test(String.format(\"%,+10G\", 0.0), fmt.\"%,+10G\\{0.0}\");\n+        test(String.format(\"%,+10G\", 12345.6), fmt.\"%,+10G\\{12345.6}\");\n+        test(String.format(\"%,+-10G\", -12345.6), fmt.\"%,+-10G\\{-12345.6}\");\n+        test(String.format(\"%,+-10G\", 0.0), fmt.\"%,+-10G\\{0.0}\");\n+        test(String.format(\"%,+-10G\", 12345.6), fmt.\"%,+-10G\\{12345.6}\");\n+        test(String.format(\"%(+g\", -12345.6), fmt.\"%(+g\\{-12345.6}\");\n+        test(String.format(\"%(+g\", 0.0), fmt.\"%(+g\\{0.0}\");\n+        test(String.format(\"%(+g\", 12345.6), fmt.\"%(+g\\{12345.6}\");\n+        test(String.format(\"%(+10g\", -12345.6), fmt.\"%(+10g\\{-12345.6}\");\n+        test(String.format(\"%(+10g\", 0.0), fmt.\"%(+10g\\{0.0}\");\n+        test(String.format(\"%(+10g\", 12345.6), fmt.\"%(+10g\\{12345.6}\");\n+        test(String.format(\"%(+-10g\", -12345.6), fmt.\"%(+-10g\\{-12345.6}\");\n+        test(String.format(\"%(+-10g\", 0.0), fmt.\"%(+-10g\\{0.0}\");\n+        test(String.format(\"%(+-10g\", 12345.6), fmt.\"%(+-10g\\{12345.6}\");\n+        test(String.format(\"%(+G\", -12345.6), fmt.\"%(+G\\{-12345.6}\");\n+        test(String.format(\"%(+G\", 0.0), fmt.\"%(+G\\{0.0}\");\n+        test(String.format(\"%(+G\", 12345.6), fmt.\"%(+G\\{12345.6}\");\n+        test(String.format(\"%(+10G\", -12345.6), fmt.\"%(+10G\\{-12345.6}\");\n+        test(String.format(\"%(+10G\", 0.0), fmt.\"%(+10G\\{0.0}\");\n+        test(String.format(\"%(+10G\", 12345.6), fmt.\"%(+10G\\{12345.6}\");\n+        test(String.format(\"%(+-10G\", -12345.6), fmt.\"%(+-10G\\{-12345.6}\");\n+        test(String.format(\"%(+-10G\", 0.0), fmt.\"%(+-10G\\{0.0}\");\n+        test(String.format(\"%(+-10G\", 12345.6), fmt.\"%(+-10G\\{12345.6}\");\n+        test(String.format(\"%,(+g\", -12345.6), fmt.\"%,(+g\\{-12345.6}\");\n+        test(String.format(\"%,(+g\", 0.0), fmt.\"%,(+g\\{0.0}\");\n+        test(String.format(\"%,(+g\", 12345.6), fmt.\"%,(+g\\{12345.6}\");\n+        test(String.format(\"%,(+10g\", -12345.6), fmt.\"%,(+10g\\{-12345.6}\");\n+        test(String.format(\"%,(+10g\", 0.0), fmt.\"%,(+10g\\{0.0}\");\n+        test(String.format(\"%,(+10g\", 12345.6), fmt.\"%,(+10g\\{12345.6}\");\n+        test(String.format(\"%,(+-10g\", -12345.6), fmt.\"%,(+-10g\\{-12345.6}\");\n+        test(String.format(\"%,(+-10g\", 0.0), fmt.\"%,(+-10g\\{0.0}\");\n+        test(String.format(\"%,(+-10g\", 12345.6), fmt.\"%,(+-10g\\{12345.6}\");\n+        test(String.format(\"%,(+G\", -12345.6), fmt.\"%,(+G\\{-12345.6}\");\n+        test(String.format(\"%,(+G\", 0.0), fmt.\"%,(+G\\{0.0}\");\n+        test(String.format(\"%,(+G\", 12345.6), fmt.\"%,(+G\\{12345.6}\");\n+        test(String.format(\"%,(+10G\", -12345.6), fmt.\"%,(+10G\\{-12345.6}\");\n+        test(String.format(\"%,(+10G\", 0.0), fmt.\"%,(+10G\\{0.0}\");\n+        test(String.format(\"%,(+10G\", 12345.6), fmt.\"%,(+10G\\{12345.6}\");\n+        test(String.format(\"%,(+-10G\", -12345.6), fmt.\"%,(+-10G\\{-12345.6}\");\n+        test(String.format(\"%,(+-10G\", 0.0), fmt.\"%,(+-10G\\{0.0}\");\n+        test(String.format(\"%,(+-10G\", 12345.6), fmt.\"%,(+-10G\\{12345.6}\");\n+\n+        test(String.format(\"%a\", -12345.6), fmt.\"%a\\{-12345.6}\");\n+        test(String.format(\"%a\", 0.0), fmt.\"%a\\{0.0}\");\n+        test(String.format(\"%a\", 12345.6), fmt.\"%a\\{12345.6}\");\n+        test(String.format(\"%10a\", -12345.6), fmt.\"%10a\\{-12345.6}\");\n+        test(String.format(\"%10a\", 0.0), fmt.\"%10a\\{0.0}\");\n+        test(String.format(\"%10a\", 12345.6), fmt.\"%10a\\{12345.6}\");\n+        test(String.format(\"%-10a\", -12345.6), fmt.\"%-10a\\{-12345.6}\");\n+        test(String.format(\"%-10a\", 0.0), fmt.\"%-10a\\{0.0}\");\n+        test(String.format(\"%-10a\", 12345.6), fmt.\"%-10a\\{12345.6}\");\n+        test(String.format(\"%A\", -12345.6), fmt.\"%A\\{-12345.6}\");\n+        test(String.format(\"%A\", 0.0), fmt.\"%A\\{0.0}\");\n+        test(String.format(\"%A\", 12345.6), fmt.\"%A\\{12345.6}\");\n+        test(String.format(\"%10A\", -12345.6), fmt.\"%10A\\{-12345.6}\");\n+        test(String.format(\"%10A\", 0.0), fmt.\"%10A\\{0.0}\");\n+        test(String.format(\"%10A\", 12345.6), fmt.\"%10A\\{12345.6}\");\n+        test(String.format(\"%-10A\", -12345.6), fmt.\"%-10A\\{-12345.6}\");\n+        test(String.format(\"%-10A\", 0.0), fmt.\"%-10A\\{0.0}\");\n+        test(String.format(\"%-10A\", 12345.6), fmt.\"%-10A\\{12345.6}\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":915,"deletions":0,"binary":false,"changes":915,"status":"added"},{"patch":"@@ -0,0 +1,308 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise runtime handing of templated strings.\n+ * @enablePreview true\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.FilterOutputStream;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.function.Supplier;\n+import javax.tools.FileObject;\n+import javax.tools.ForwardingJavaFileManager;\n+import javax.tools.JavaFileManager;\n+import javax.tools.JavaFileObject;\n+import javax.tools.SimpleJavaFileObject;\n+import static javax.tools.StandardLocation.CLASS_OUTPUT;\n+import javax.tools.ToolProvider;\n+\n+public class StringTemplateTest {\n+    enum Category{GENERAL, CHARACTER, INTEGRAL, BIG_INT, FLOATING, BIG_FLOAT, DATE};\n+\n+    static final String[] GENERAL = {\"true\", \"false\", \"(Object)null\", \"STR\", \"BO\", \"BOOL\", \"(Boolean)null\"};\n+    static final String[] CHARS = {\"C\", \"CHAR\", \"(Character)null\"};\n+    static final String[] INTS = {\"L\", \"LONG\", \"I\", \"INT\", \"S\", \"SHORT\", \"BY\", \"BYTE\", \"Long.MAX_VALUE\", \"Long.MIN_VALUE\", \"(Long)null\", \"(Integer)null\", \"(Short)null\", \"(Byte)null\"};\n+    static final String[] BIGINTS = {};\n+    static final String[] FLOATS = {\"F\", \"FLOAT\", \"D\", \"DOUBLE\", \"Double.NEGATIVE_INFINITY\", \"Double.NaN\", \"Double.MAX_VALUE\", \"(Double)null\", \"(Float)null\"};\n+    static final String[] BIGFLOATS = {};\n+    static final String[] DATES = {};\n+\n+    final Random r = new Random(1);\n+\n+    String randomValue(Category category) {\n+        return switch (category) {\n+            case GENERAL -> randomChoice(\n+                    GENERAL,\n+                    () -> randomValue(Category.CHARACTER),\n+                    () -> randomValue(Category.INTEGRAL),\n+                    () -> randomValue(Category.BIG_INT),\n+                    () -> randomValue(Category.FLOATING),\n+                    () -> randomValue(Category.BIG_FLOAT),\n+                    () -> randomValue(Category.DATE),\n+                    () -> \"\\\"\" + randomString(r.nextInt(10)) + \"\\\"\");\n+            case CHARACTER -> randomChoice(\n+                    CHARS,\n+                    () -> \"\\'\" + randomString(1) + \"\\'\");\n+            case INTEGRAL -> randomChoice(\n+                    INTS,\n+                    () -> \"(byte)\" + String.valueOf(r.nextInt(Byte.MIN_VALUE, Byte.MAX_VALUE)),\n+                    () -> \"(short)\" + String.valueOf(r.nextInt(Short.MIN_VALUE, Short.MAX_VALUE)),\n+                    () -> String.valueOf(r.nextInt()),\n+                    () -> r.nextLong() + \"l\");\n+            case BIG_INT -> randomChoice(\n+                    BIGINTS,\n+                    () -> \"new java.math.BigInteger(\\\"\" + r.nextLong() + \"\\\")\");\n+            case FLOATING -> randomChoice(\n+                    FLOATS,\n+                    () -> String.valueOf(r.nextDouble()),\n+                    () -> r.nextFloat() + \"f\");\n+            case BIG_FLOAT -> randomChoice(\n+                    BIGFLOATS,\n+                    () -> \"new java.math.BigDecimal(\" + r.nextDouble() + \")\");\n+            case DATE -> randomChoice(\n+                    DATES,\n+                    () -> \"new java.util.Date(\" + r.nextLong() + \"l)\",\n+                    () -> r.nextLong() + \"l\");\n+        };\n+    }\n+\n+    String randomChoice(Supplier<String>... suppl) {\n+        return suppl[r.nextInt(suppl.length)].get();\n+    }\n+\n+    String randomChoice(String... values) {\n+        return values[r.nextInt(values.length)];\n+    }\n+\n+    String randomChoice(String[] values, Supplier<String>... suppl) {\n+        int i = r.nextInt(values.length + suppl.length);\n+        return i < values.length ? values[i] : suppl[i - values.length].get();\n+    }\n+\n+    String randomString(int length) {\n+        var sb = new StringBuilder(length << 2);\n+        while (length-- > 0) {\n+            char ch = (char)r.nextInt(9, 128);\n+            var s = switch (ch) {\n+                case '\\t' -> \"\\\\t\";\n+                case '\\'' -> \"\\\\\\'\";\n+                case '\"' -> \"\\\\\\\"\";\n+                case '\\r' -> \"\\\\r\";\n+                case '\\\\' -> \"\\\\\\\\\";\n+                case '\\n' -> \"\\\\n\";\n+                case '\\f' -> \"\\\\f\";\n+                case '\\b' -> \"\\\\b\";\n+                default -> ch + \"\";\n+            };\n+            sb.append(s);\n+        }\n+        return sb.toString();\n+    }\n+\n+    String randomFormat(Category category) {\n+        char c;\n+        return \"%\" + switch (category) {\n+            case GENERAL -> randomWidth(\"-\") + randomPrecision() + randomChar(\"bBhHsS\");\n+            case CHARACTER -> randomWidth(\"-\") + randomChar(\"cC\");\n+            case INTEGRAL -> switch (c = randomChar(\"doxX\")) {\n+                case 'd' -> randomFlags(\"+ ,(\");\n+                default -> randomFlags(\"\");\n+            } + randomWidth(\"-0\") + c;\n+            case BIG_INT -> switch (c = randomChar(\"doxX\")) {\n+                case 'd' -> randomFlags(\"+ ,(\");\n+                default -> randomFlags(\"+ (\");\n+            } + randomWidth(\"-0\") + c;\n+            case FLOATING -> switch (c = randomChar(\"eEfaAgG\")) {\n+                case 'a', 'A' -> randomFlags(\"+ \") + randomWidth(\"-0\");\n+                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n+                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n+            } + c;\n+            case BIG_FLOAT -> switch (c = randomChar(\"eEfgG\")) {\n+                case 'e', 'E' -> randomFlags(\"+ (\") + randomWidth(\"-0\") + randomPrecision();\n+                default -> randomFlags(\"+ ,(\") + randomWidth(\"-0\") + randomPrecision();\n+            } + c;\n+            case DATE ->  randomWidth(\"-\") + randomChar(\"tT\") + randomChar(\"BbhAaCYyjmdeRTrDFc\");\n+        };\n+    }\n+\n+    String randomFlags(String flags) {\n+        var sb = new StringBuilder(flags.length());\n+        for (var f : flags.toCharArray()) {\n+            if (r.nextBoolean() && (f != ' ' || sb.length() == 0 || sb.charAt(sb.length() - 1) != '+')) sb.append(f);\n+        }\n+        return sb.toString();\n+    }\n+\n+    char randomChar(String chars) {\n+        return chars.charAt(r.nextInt(chars.length()));\n+    }\n+\n+    String randomWidth(String flags) {\n+        var f = r.nextInt(flags.length() + 1);\n+        return r.nextBoolean() ? (r.nextBoolean() ? flags.charAt(r.nextInt(flags.length())) : \"\") + String.valueOf(r.nextInt(10) + 1) : \"\";\n+    }\n+\n+    String randomPrecision() {\n+        return r.nextBoolean() ? '.' + String.valueOf(r.nextInt(10) + 1) : \"\";\n+    }\n+\n+    public Class<?> compile() throws Exception {\n+        var classes = new HashMap<String, byte[]>();\n+        var fileManager = new ForwardingJavaFileManager(ToolProvider.getSystemJavaCompiler().getStandardFileManager(null, null, null)) {\n+            @Override\n+            public ClassLoader getClassLoader(JavaFileManager.Location location) {\n+                return new ClassLoader() {\n+                    @Override\n+                    public Class<?> loadClass(String name) throws ClassNotFoundException {\n+                        try {\n+                            return super.loadClass(name);\n+                        } catch (ClassNotFoundException e) {\n+                            byte[] classData = classes.get(name);\n+                            return defineClass(name, classData, 0, classData.length);\n+                        }\n+                    }\n+                };\n+            }\n+            @Override\n+            public JavaFileObject getJavaFileForOutput(JavaFileManager.Location location, String name, JavaFileObject.Kind kind, FileObject originatingSource) throws UnsupportedOperationException {\n+                return new SimpleJavaFileObject(URI.create(name + \".class\"), JavaFileObject.Kind.CLASS) {\n+                    @Override\n+                    public OutputStream openOutputStream() {\n+                        return new FilterOutputStream(new ByteArrayOutputStream()) {\n+                            @Override\n+                            public void close() throws IOException {\n+                                classes.put(name, ((ByteArrayOutputStream)out).toByteArray());\n+                            }\n+                        };\n+                    }\n+                };\n+            }\n+        };\n+        var source = genSource();\n+\/\/        System.out.println(source);\n+        if (ToolProvider.getSystemJavaCompiler().getTask(null, fileManager, null,\n+                List.of(\"--enable-preview\", \"-source\", String.valueOf(Runtime.version().feature())), null,\n+                List.of(new SimpleJavaFileObject(URI.create(\"StringTemplateTest$.java\"), JavaFileObject.Kind.SOURCE) {\n+            @Override\n+            public CharSequence getCharContent(boolean ignoreEncodingErrors) {\n+                return source;\n+            }\n+        })).call()) {\n+            return fileManager.getClassLoader(CLASS_OUTPUT).loadClass(\"StringTemplateTest$\");\n+        } else {\n+            throw new AssertionError(\"compilation failed\");\n+        }\n+    }\n+\n+    String genFragments(Category c) {\n+        var fragments = new LinkedList<String>();\n+        for (int i = 0; i < 1500; i++) {\n+            var format = randomFormat(c);\n+            var value = randomValue(c);\n+            var qValue = value.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\\"\", \"\\\\\\\"\");\n+            fragments.add(STR.\"test(FMT.\\\"\\{format}\\\\{\\{value}}\\\", \\\"\\{format}\\\", \\\"\\{qValue}\\\", \\{value}, log);\");\n+        }\n+        return String.join(\"\\n        \", fragments);\n+    }\n+\n+    String genSource() {\n+        return STR.\"\"\"\n+            import java.util.FormatProcessor;\n+            import java.util.Locale;\n+\n+            public class StringTemplateTest$ {\n+                static final FormatProcessor FMT = FormatProcessor.create(Locale.US);\n+                static String STR = \"this is static String\";\n+                static char C = 'c';\n+                static Character CHAR = 'C';\n+                static long L = -12345678910l;\n+                static Long LONG = 9876543210l;\n+                static int I = 42;\n+                static Integer INT = -49;\n+                static boolean BO = true;\n+                static Boolean BOOL = false;\n+                static short S = 13;\n+                static Short SHORT = -17;\n+                static byte BY = -3;\n+                static Byte BYTE = 12;\n+                static float F = 4.789f;\n+                static Float FLOAT = -0.000006f;\n+                static double D = 6545745.6734654563;\n+                static Double DOUBLE = -4323.7645676574;\n+\n+                public static void run(java.util.List<String> log) {\n+                    runGeneral(log);\n+                    runCharacter(log);\n+                    runIntegral(log);\n+                    runBigInt(log);\n+                    runFloating(log);\n+                    runBigFloat(log);\n+                    runDate(log);\n+                }\n+                public static void runGeneral(java.util.List<String> log) {\n+                    \\{genFragments(Category.GENERAL)}\n+                }\n+                public static void runCharacter(java.util.List<String> log) {\n+                    \\{genFragments(Category.CHARACTER)}\n+                }\n+                public static void runIntegral(java.util.List<String> log) {\n+                    \\{genFragments(Category.INTEGRAL)}\n+                }\n+                public static void runBigInt(java.util.List<String> log) {\n+                    \\{genFragments(Category.BIG_INT)}\n+                }\n+                public static void runFloating(java.util.List<String> log) {\n+                    \\{genFragments(Category.FLOATING)}\n+                }\n+                public static void runBigFloat(java.util.List<String> log) {\n+                    \\{genFragments(Category.BIG_FLOAT)}\n+                }\n+                public static void runDate(java.util.List<String> log) {\n+                    \\{genFragments(Category.DATE)}\n+                }\n+                static void test(String fmt, String format, String expression, Object value, java.util.List<String> log) {\n+                    var formatted = String.format(java.util.Locale.US, format, value);\n+                    if (!fmt.equals(formatted)) {\n+                        log.add(\"  format: '%s' expression: '%s' value: '%s' expected: '%s' found: '%s'\".formatted(format, expression, value, formatted, fmt));\n+                    }\n+                }\n+            }\n+            \"\"\";\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        var log = new LinkedList<String>();\n+        new StringTemplateTest().compile().getMethod(\"run\", List.class).invoke(null, log);\n+        if (!log.isEmpty()) {\n+            log.forEach(System.out::println);\n+            throw new AssertionError(STR.\"failed \\{log.size()} tests\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":308,"deletions":0,"binary":false,"changes":308,"status":"added"},{"patch":"@@ -92,1 +92,2 @@\n-        \"record.length()\"\n+        \"record.length()\",\n+        \"\\\"\\\\{0}\\\"\"\n@@ -235,1 +236,6 @@\n-        \"new ;\"\n+        \"new ;\",\n+        \"\\\"\",\n+        \"\\\"\\\\\",\n+        \"\\\"\\\\{\",\n+        \"\\\"\\\\{0\",\n+        \"\\\"\\\\{0}\",\n@@ -372,0 +378,1 @@\n+        assertStatus(\"\\\"\\\"\\\"\\n\", DEFINITELY_INCOMPLETE, null);\n@@ -379,0 +386,4 @@\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\\", DEFINITELY_INCOMPLETE, null);\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\{\", DEFINITELY_INCOMPLETE, null);\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0\", DEFINITELY_INCOMPLETE, null);\n+        assertStatus(\"\\\"\\\"\\\"\\n\\\\{0}\", DEFINITELY_INCOMPLETE, null);\n","filename":"test\/langtools\/jdk\/jshell\/CompletenessTest.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-        check(numAllMembers, \"#allMembers\", 52);\n+        check(numAllMembers, \"#allMembers\", 58);\n","filename":"test\/langtools\/tools\/javac\/api\/TestJavacTaskScanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,33 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.misc.feature.string.templates\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: --enable-preview -source 21  -Xlint:preview\n+\n+class StringTemplate {\n+    String m() {\n+        int x = 10, y = 20;\n+        return STR.\"\\{x} + \\{y} = \\{x + y}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplate.java","additions":33,"deletions":0,"binary":false,"changes":33,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.err.processor.missing.from.string.template.expression\n+ \/\/ key: compiler.misc.feature.string.templates\n+ \/\/ key: compiler.warn.preview.feature.use.plural\n+ \/\/ options: --enable-preview -source 21  -Xlint:preview\n+\n+class StringTemplateNoProcessor {\n+    String m() {\n+        int x = 10, y = 20;\n+        return \"\\{x} + \\{y} = \\{x + y}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNoProcessor.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.not.a.processor.type\n+ \/\/ options: --enable-preview  -source 21\n+\n+import java.lang.*;\n+\n+class StringTemplateNotProcessor {\n+    String m() {\n+        String processor = \"\";\n+        int x = 10, y = 20;\n+        return processor.\"\\{x} + \\{y} = \\{x + y}\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNotProcessor.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,45 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.misc.unexpected.ret.val\n+ \/\/ key: compiler.err.prob.found.req\n+ \/\/ key: compiler.err.processor.type.cannot.be.a.raw.type\n+ \/\/ options: --enable-preview -source 21\n+\n+import java.lang.*;\n+import java.lang.StringTemplate.Processor;\n+\n+class StringTemplateRawProcessor {\n+    void m() {\n+        Processor processor = ts -> ts.interpolate();\n+        try {\n+            int x = 10, y = 20;\n+            return processor.\"\\{x} + \\{y} = \\{x + y}\";\n+        } catch (Throwable x) {\n+            throw new RuntimeException(x);\n+        }\n+    }\n+}\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateRawProcessor.java","additions":45,"deletions":0,"binary":false,"changes":45,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.unclosed.str.lit\n+ \/\/ key: compiler.err.string.template.is.not.well.formed\n+ \/\/ options: --enable-preview -source 21\n+\n+import java.lang.*;\n+\n+class StringTemplateUnclosedString {\n+    String m() {\n+        int x = 10;\n+        return STR.\"\\{x\";\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedString.java","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+ \/\/ key: compiler.note.preview.filename\n+ \/\/ key: compiler.note.preview.recompile\n+ \/\/ key: compiler.err.unclosed.text.block\n+ \/\/ key: compiler.err.text.block.template.is.not.well.formed\n+ \/\/ key: compiler.err.premature.eof\n+ \/\/ options: --enable-preview -source 21\n+\n+import java.lang.*;\n+\n+class StringTemplateUnclosedTextBlock {\n+    String m() {\n+        int x = 10;\n+        return STR.\"\"\"\n+                aaa\n+                \\{x\n+                \"\"\"\n+        ;\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedTextBlock.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,0 +90,1 @@\n+import com.sun.tools.javac.api.JavacTaskPool.Worker;\n@@ -1915,0 +1916,46 @@\n+    @Test\n+    void testStringTemplate1() throws IOException {\n+        String code = \"\"\"\n+                      package test;\n+                      public class Test {\n+                           Test(int a) {\n+                               String s = \"prefix \\\\{a} suffix\";\n+                           }\n+                      }\n+                      \"\"\";\n+\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n+                null, null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n+        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n+        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n+        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n+        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n+        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n+        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"\\\"prefix \\\\{a} suffix\\\"\");\n+    }\n+\n+    @Test\n+    void testStringTemplate2() throws IOException {\n+        String code = \"\"\"\n+                      package test;\n+                      public class Test {\n+                           Test(int a) {\n+                               String s = STR.\"prefix \\\\{a} suffix\";\n+                           }\n+                      }\n+                      \"\"\";\n+\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, null,\n+                null, null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+        ClassTree clazz = (ClassTree) cut.getTypeDecls().get(0);\n+        MethodTree constr = (MethodTree) clazz.getMembers().get(0);\n+        VariableTree decl = (VariableTree) constr.getBody().getStatements().get(0);\n+        SourcePositions sp = Trees.instance(ct).getSourcePositions();\n+        int initStart = (int) sp.getStartPosition(cut, decl.getInitializer());\n+        int initEnd   = (int) sp.getEndPosition(cut, decl.getInitializer());\n+        assertEquals(\"correct templated String span expected\", code.substring(initStart, initEnd), \"STR.\\\"prefix \\\\{a} suffix\\\"\");\n+    }\n+\n@@ -1996,0 +2043,57 @@\n+    @Test\n+    void testIncompleteStringTemplate() throws IOException {\n+        String template = \"\\\"\\\\{o.toString()}\\\"\";\n+        String prefix = \"\"\"\n+                      package t;\n+                      class Test {\n+                          void test(Object o) {\n+                              String s = STR.\"\"\";\n+\n+        Worker<Void> verifyParseable = task -> {\n+            try {\n+                task.parse().iterator().next();\n+                return null;\n+            } catch (IOException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        };\n+        JavacTaskPool pool = new JavacTaskPool(1);\n+        DiagnosticListener<JavaFileObject> dl = d -> {};\n+        List<String> options = List.of(\"--enable-preview\",\n+                                       \"-source\", System.getProperty(\"java.specification.version\"));\n+        for (int i = 0; i < template.length(); i++) {\n+            pool.getTask(null, fm, dl, options,\n+                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i))),\n+                    verifyParseable\n+            );\n+        }\n+        for (int i = 0; i < template.length() - 1; i++) {\n+            pool.getTask(null, fm, dl, options,\n+                    null, Arrays.asList(new MyFileObject(prefix + template.substring(0, i) + \"\\\"\")),\n+                    verifyParseable);\n+        }\n+        String incomplete = prefix + \"\\\"\\\\{o.\";\n+        pool.getTask(null, fm, dl, options,\n+                null, Arrays.asList(new MyFileObject(incomplete)), task -> {\n+            try {\n+                CompilationUnitTree cut = task.parse().iterator().next();\n+                String result = cut.toString().replaceAll(\"\\\\R\", \"\\n\");\n+                System.out.println(\"RESULT\\n\" + result);\n+                assertEquals(\"incorrect AST\",\n+                             result,\n+                             \"\"\"\n+                             package t;\n+                             \\n\\\n+                             class Test {\n+                                 \\n\\\n+                                 void test(Object o) {\n+                                     String s = STR.<error>;\n+                                 }\n+                             }\"\"\");\n+                return null;\n+            } catch (IOException ex) {\n+                throw new AssertionError(ex);\n+            }\n+        });\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":105,"deletions":1,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -0,0 +1,240 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 0000000\n+ * @summary Exercise javac handing of templated strings.\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main Basic\n+ *\/\n+\n+\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.ToolBox;\n+\n+public class Basic {\n+    private static ToolBox TOOLBOX = new ToolBox();\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    public static void main(String... arg) {\n+        primitivesTest();\n+        missingPartsTest();\n+        expressionsTest();\n+        invalidExpressionsTest();\n+        processorTest();\n+    }\n+\n+    \/*\n+     * Primitive types test.\n+     *\/\n+    static void primitivesTest() {\n+        for (String type : new String[] {\n+            \"byte\",\n+            \"short\",\n+            \"int\",\n+            \"long\",\n+            \"float\",\n+            \"double\"\n+        }) {\n+            compPass(type + \" x = 10; \" + type + \"  y = 20; StringTemplate result = RAW.\\\"\\\\{x} + \\\\{y} = \\\\{x + y}\\\";\");\n+        }\n+    }\n+\n+    \/*\n+     * Missing parts test.\n+     *\/\n+    static void missingPartsTest() {\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{x\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{{x}\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{x + }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ * x }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ (x + x }\";\n+        \"\"\");\n+    }\n+\n+    \/*\n+     * Expressions test.\n+     *\/\n+    static void expressionsTest() {\n+        compPass(\"\"\"\n+            int x = 10;\n+            int[] y = new int[] { 10, 20, 30 };\n+            StringTemplate result1 = RAW.\"\\\\{x + 1}\";\n+            StringTemplate result2 = RAW.\"\\\\{x + x}\";\n+            StringTemplate result3 = RAW.\"\\\\{x - x}\";\n+            StringTemplate result4 = RAW.\"\\\\{x * x}\";\n+            StringTemplate result5 = RAW.\"\\\\{x \/ x}\";\n+            StringTemplate result6 = RAW.\"\\\\{x % x}\";\n+            StringTemplate result7 = RAW.\"\\\\{x + (x + x)}\";\n+            StringTemplate result8 = RAW.\"\\\\{y[x - 9]}\";\n+            StringTemplate result9 = RAW.\"\\\\{System.out}\";\n+            StringTemplate result10 = RAW.\\\"\"\"\n+                    \\\\{ \"a string\" }\n+                    \\\"\"\";\n+                    \"\"\");\n+        compPass(\"\"\"\n+            StringTemplate result = RAW.\\\"\"\"\n+                 \\\\{\n+                     new Collection<String>() {\n+                          @Override public int size() { return 0; }\n+                          @Override public boolean isEmpty() { return false; }\n+                          @Override public boolean contains(Object o) { return false; }\n+                          @Override public Iterator<String> iterator() { return null; }\n+                          @Override public Object[] toArray() { return new Object[0]; }\n+                          @Override public <T> T[] toArray(T[] a) { return null; }\n+                          @Override public boolean add(String s) { return false; }\n+                          @Override public boolean remove(Object o) { return false; }\n+                          @Override public boolean containsAll(Collection<?> c) { return false; }\n+                          @Override public boolean addAll(Collection<? extends String> c) { return false; }\n+                          @Override public boolean removeAll(Collection<?> c) { return false; }\n+                          @Override public boolean retainAll(Collection<?> c) { return false; }\n+                          @Override public void clear() { }\n+                      }\n+                 }\n+                 \\\"\"\";\n+         \"\"\");\n+    }\n+\n+    \/*\n+     * Invalid expressions test.\n+     *\/\n+    static void invalidExpressionsTest() {\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ (x == x }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ true ?  : x - 1 }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+             String result = RAW.\"\\\\{ 'a }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ Math.min(, x - 1) }\";\n+        \"\"\");\n+        compFail(\"\"\"\n+            int x = 10;\n+            StringTemplate result = RAW.\"\\\\{ \\\\tx }\";\n+        \"\"\");\n+    }\n+\n+    \/*\n+     * Processor test.\n+     *\/\n+    static void processorTest() {\n+        compPass(\"\"\"\n+         int x = 10, y = 20;\n+         String string = STR.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n+         \"\"\");\n+        compFail(\"\"\"\n+         int x = 10, y = 20;\n+         String processor = \"abc\";\n+         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n+         \"\"\");\n+        compFail(\"\"\"\n+         int x = 10, y = 20;\n+         long processor = 100;\n+         String string = processor.\"\\\\{x} + \\\\{y} = \\\\{x + y}\";\n+         \"\"\");\n+    }\n+\n+    \/*\n+     * Test source for successful compile.\n+     *\/\n+    static void compPass(String code) {\n+        String source = \"\"\"\n+            import java.lang.*;\n+            import java.util.*;\n+            import static java.lang.StringTemplate.RAW;\n+            public class TEST {\n+                public static void main(String... arg) {\n+            \"\"\" +\n+            code.indent(8) +\n+            \"\"\"\n+                }\n+            }\n+            \"\"\";\n+        String output = new JavacTask(TOOLBOX)\n+                .sources(source)\n+                .classpath(\".\")\n+                .options(\"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n+                .run()\n+                .writeAll()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (output.contains(\"compiler.err\")) {\n+            throw new RuntimeException(\"Error detected\");\n+        }\n+    }\n+\n+    \/*\n+     * Test source for unsuccessful compile and specific error.\n+     *\/\n+    static void compFail(String code) {\n+        String source = \"\"\"\n+            import java.lang.*;\n+            import java.util.*;\n+            import static java.lang.StringTemplate.RAW;\n+            public class TEST {\n+                public static void main(String... arg) {\n+            \"\"\" +\n+            code.indent(8) +\n+            \"\"\"\n+                }\n+            }\n+            \"\"\";\n+        String errors = new JavacTask(TOOLBOX)\n+                .sources(source)\n+                .classpath(\".\")\n+                .options(\"-XDrawDiagnostics\", \"-encoding\", \"utf8\", \"--enable-preview\", \"-source\", JAVA_VERSION)\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutput(Task.OutputKind.DIRECT);\n+\n+        if (!errors.contains(\"compiler.err\")) {\n+            throw new RuntimeException(\"No error detected\");\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/template\/Basic.java","additions":240,"deletions":0,"binary":false,"changes":240,"status":"added"},{"patch":"@@ -0,0 +1,107 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Verify proper behavior of TreeScanner w.r.t. templated Strings\n+ * @modules jdk.compiler\n+ *\/\n+\n+import java.io.*;\n+import java.util.*;\n+import javax.tools.*;\n+import com.sun.source.tree.*;\n+import com.sun.source.util.*;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+\n+public class TreeScannerTest {\n+    private static final String JAVA_VERSION = System.getProperty(\"java.specification.version\");\n+\n+    public static void main(String... args) throws Exception {\n+        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();\n+        String code = \"\"\"\n+                      public class Test {\n+                          private void test(int a) {\n+                              String s1 = TEST.\"p\\\\{a}s\";\n+                              String s2 = \"p\\\\{a}s\";\n+                          }\n+                      }\n+                      \"\"\";\n+        JavacTask task = (JavacTask) compiler.getTask(null, null, null,\n+            List.of(\"--enable-preview\", \"-source\", JAVA_VERSION), null, List.of(new TestJFO(code)));\n+        StringBuilder output = new StringBuilder();\n+        TreeScanner<Void,Void> checker = new TreeScanner<Void, Void>() {\n+            private boolean log;\n+\n+            @Override\n+            public Void visitStringTemplate(StringTemplateTree node, Void p) {\n+                boolean prevLog = log;\n+                try {\n+                    log = true;\n+                    return super.visitStringTemplate(node, p);\n+                } finally {\n+                    log = prevLog;\n+                }\n+            }\n+\n+            @Override\n+            public Void scan(Tree tree, Void p) {\n+                if (log) {\n+                    output.append(\"(\");\n+                    output.append(tree != null ? tree.getKind() : \"null\");\n+                    try {\n+                        return super.scan(tree, p);\n+                    } finally {\n+                        output.append(\")\");\n+                    }\n+                } else {\n+                    return super.scan(tree, p);\n+                }\n+            }\n+\n+        };\n+\n+        checker.scan(task.parse(), null);\n+\n+        String expected = \"(IDENTIFIER)(IDENTIFIER)(null)(IDENTIFIER)\";\n+        if (!expected.equals(output.toString())) {\n+            throw new AssertionError(\"expected output not found, found: \" + output);\n+        }\n+    }\n+\n+    private static final class TestJFO extends SimpleJavaFileObject {\n+        private final String code;\n+\n+        public TestJFO(String code) throws URISyntaxException, IOException {\n+            super(new URI(\"mem:\/\/Test.java\"), Kind.SOURCE);\n+            this.code = code;\n+        }\n+\n+        @Override\n+        public CharSequence getCharContent(boolean ignoreEncodingErrors) throws IOException {\n+            return code;\n+        }\n+\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/template\/TreeScannerTest.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"added"},{"patch":"@@ -126,0 +126,4 @@\n+            case TEMPLATE:\n+                ok = ok & verify(k, i, i == StringTemplateTree.class);\n+                break;\n+\n","filename":"test\/langtools\/tools\/javac\/tree\/TreeKindTest.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.lang;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+import static java.util.FormatProcessor.FMT;\n+\n+\/*\n+ * This benchmark measures StringTemplate.FMT FormatProcessor performance;\n+ * exactly mirroring {@link org.openjdk.bench.java.lang.StringFormat} benchmark\n+ *\/\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+@Warmup(iterations = 5, time = 1)\n+@Measurement(iterations = 5, time = 1)\n+@Fork(value = 3, jvmArgsAppend = \"--enable-preview\")\n+public class StringTemplateFMT {\n+\n+    public String s = \"str\";\n+    public int i = 17;\n+\n+    @Benchmark\n+    public String stringFormat() {\n+        return FMT.\"%s\\{s}\";\n+    }\n+\n+    @Benchmark\n+    public String stringIntFormat() {\n+        return FMT.\"%s\\{s} %d\\{i}\";\n+    }\n+\n+    @Benchmark\n+    public String widthStringFormat() {\n+        return FMT.\"%3s\\{s}\";\n+    }\n+\n+    @Benchmark\n+    public String widthStringIntFormat() {\n+        return FMT.\"%3s\\{s} %d\\{i}\";\n+    }\n+\n+    @Benchmark\n+    public String complexFormat() {\n+        return FMT.\"%3s\\{s} %10d\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i} %4S\\{s} %04X\\{i}\";\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringTemplateFMT.java","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"}]}