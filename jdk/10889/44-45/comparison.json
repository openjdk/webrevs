{"files":[{"patch":"@@ -0,0 +1,692 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang;\n+\n+import java.lang.Object;\n+import java.lang.invoke.CallSite;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.FormatProcessor;\n+import java.util.function.Function;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * {@link StringTemplate} is the run-time representation of a string template or\n+ * text block template in a template expression.\n+ *\n+ * <p>\n+ * In the source code of a Java program, a string template or text block template\n+ * contains an interleaved succession of <em>fragment literals<\/em> and <em>embedded\n+ * expressions<\/em>. The {@link StringTemplate#fragments()} method returns the\n+ * fragment literals, and the {@link StringTemplate#values()} method returns the\n+ * results of evaluating the embedded expressions. {@link StringTemplate} does not\n+ * provide access to the source code of the embedded expressions themselves; it is\n+ * not a compile-time representation of a string template or text block template.\n+ * <p>\n+ * {@link StringTemplate} is primarily used in conjunction with a template processor\n+ * to produce a string or other meaningful value. Evaluation of a template expression\n+ * first produces an instance of {@link StringTemplate}, representing the template\n+ * of the template expression, and then passes the instance to the template processor\n+ * given by the template expression.\n+ * <p>\n+ * For example, the following code contains a template expression that uses the template\n+ * processor {@code RAW}, which simply yields the {@link StringTemplate} passed to it:\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+ * List<String> fragments = st.fragments();\n+ * List<Object> values = st.values();\n+ * }\n+ * The value of {@code fragments} will be equivalent to {@code List.of(\"\", \" + \", \" = \", \"\")},\n+ * which includes the empty first and last fragments. The {@code values} will be the\n+ * equivalent of {@code List.of(10, 20, 30)}.\n+ * <p>\n+ * The following code contains a template expression with the same template but with a\n+ * different template processor, {@code STR}:\n+ * {@snippet :\n+ * int x = 10;\n+ * int y = 20;\n+ * String s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n+ * }\n+ * When the template expression is evaluated, an instance of {@link StringTemplate} is\n+ * produced that returns the same lists from {@link StringTemplate#fragments()} and\n+ * {@link StringTemplate#values()} as shown above. The {@link StringTemplate#STR} template\n+ * processor uses these lists to yield an interpolated string. The value of {@code s} will\n+ * be equivalent to {@code \"10 + 20 = 30\"}.\n+ * <p>\n+ * The {@code interpolate()} method provides a direct way to perform string interpolation\n+ * of a {@link StringTemplate}. Template processors can use the following code pattern:\n+ * {@snippet :\n+ * List<String> fragments = st.fragments();\n+ * List<Object> values    = st.values();\n+ * ... check or manipulate the fragments and\/or values ...\n+ * String result = StringTemplate.interpolate(fragments, values);\n+ * }\n+ * The {@link StringTemplate#process(Processor)} method, in conjunction with\n+ * the {@link StringTemplate#RAW} processor, may be used to defer processing of a\n+ * {@link StringTemplate}.\n+ * {@snippet :\n+ * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+ * ...other steps...\n+ * String result = st.process(STR);\n+ * }\n+ * The factory methods {@link StringTemplate#of(String)} and\n+ * {@link StringTemplate#of(List, List)} can be used to construct a {@link StringTemplate}.\n+ *\n+ * @see Processor\n+ * @see SimpleProcessor\n+ * @see StringProcessor\n+ * @see java.util.FormatProcessor\n+ *\n+ * @implNote Implementations of {@link StringTemplate} must minimally implement the\n+ * methods {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n+ * Instances of {@link StringTemplate} are considered immutable. To preserve the\n+ * semantics of string templates and text block templates, the list returned by\n+ * {@link StringTemplate#fragments()} must be one element larger than the list returned\n+ * by {@link StringTemplate#values()}.\n+ *\n+ * @since 21\n+ *\n+ * @jls 15.8.6 Process Template Expressions\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+public interface StringTemplate {\n+    \/**\n+     * Returns a list of fragment literals for this {@link StringTemplate}.\n+     * The fragment literals are the character sequences preceding each of the embedded\n+     * expressions in source code, plus the character sequence following the last\n+     * embedded expression. Such character sequences may be zero-length if an embedded\n+     * expression appears at the beginning or end of a template, or if two embedded\n+     * expressions are directly adjacent in a template.\n+     * In the example: {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * List<String> fragments = st.fragments(); \/\/ @highlight substring=\"fragments()\"\n+     * }\n+     * {@code fragments} will be equivalent to\n+     * {@code List.of(\"The student \", \" is in \", \"'s classroom.\")}\n+     *\n+     * @return list of string fragments\n+     *\/\n+    List<String> fragments();\n+\n+    \/**\n+     * Returns a list of embedded expression results for this {@link StringTemplate}.\n+     * In the example:\n+     * {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * List<Object> values = st.values(); \/\/ @highlight substring=\"values()\"\n+     * }\n+     * {@code values} will be equivalent to {@code List.of(student, teacher)}\n+     *\n+     * @return list of expression values\n+     *\/\n+    List<Object> values();\n+\n+    \/**\n+     * Returns the string interpolation of the fragments and values for this\n+     * {@link StringTemplate}.\n+     * <p>\n+     * For better visibility and when practical, it is recommended to use the\n+     * {@link StringTemplate#STR} processor instead of invoking the\n+     * {@link StringTemplate#interpolate()} method.\n+     * {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * String result = st.interpolate(); \/\/ @highlight substring=\"interpolate()\"\n+     * }\n+     * In the above example, the value of  {@code result} will be\n+     * {@code \"The student Mary is in Johnson's classroom.\"}. This is\n+     * produced by the interleaving concatenation of fragments and values from the supplied\n+     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n+     * as if invoking {@link String#valueOf(Object)}.\n+     *\n+     * @return interpolation of this {@link StringTemplate}\n+     *\n+     * @implSpec The default implementation returns the result of invoking\n+     * {@code StringTemplate.interpolate(this.fragments(), this.values())}.\n+     *\/\n+    default String interpolate() {\n+        return StringTemplate.interpolate(fragments(), values());\n+    }\n+\n+    \/**\n+     * Returns the result of applying the specified processor to this {@link StringTemplate}.\n+     * This method can be used as an alternative to string template expressions. For example,\n+     * {@snippet :\n+     * String student = \"Mary\";\n+     * String teacher = \"Johnson\";\n+     * String result1 = STR.\"The student \\{student} is in \\{teacher}'s classroom.\";\n+     * String result2 = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\".process(STR); \/\/ @highlight substring=\"process\"\n+     * }\n+     * Produces an equivalent result for both {@code result1} and {@code result2}.\n+     *\n+     * @param processor the {@link Processor} instance to process\n+     *\n+     * @param <R>  Processor's process result type.\n+     * @param <E>  Exception thrown type.\n+     *\n+     * @return constructed object of type {@code R}\n+     *\n+     * @throws E exception thrown by the template processor when validation fails\n+     * @throws NullPointerException if processor is null\n+     *\n+     * @implSpec The default implementation returns the result of invoking\n+     * {@code processor.process(this)}. If the invocation throws an exception that\n+     * exception is forwarded to the caller.\n+     *\/\n+    default <R, E extends Throwable> R\n+    process(Processor<? extends R, ? extends E> processor) throws E {\n+        Objects.requireNonNull(processor, \"processor should not be null\");\n+\n+        return processor.process(this);\n+    }\n+\n+    \/**\n+     * Produces a diagnostic string that describes the fragments and values of the supplied\n+     * {@link StringTemplate}.\n+     *\n+     * @param stringTemplate  the {@link StringTemplate} to represent\n+     *\n+     * @return diagnostic string representing the supplied string template\n+     *\n+     * @throws NullPointerException if stringTemplate is null\n+     *\/\n+    static String toString(StringTemplate stringTemplate) {\n+        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n+        return \"StringTemplate{ fragments = [ \\\"\" +\n+                String.join(\"\\\", \\\"\", stringTemplate.fragments()) +\n+                \"\\\" ], values = \" +\n+                stringTemplate.values() +\n+                \" }\";\n+    }\n+\n+    \/**\n+     * Returns a {@link StringTemplate} as if constructed by invoking\n+     * {@code StringTemplate.of(List.of(string), List.of())}. That is, a {@link StringTemplate}\n+     * with one fragment and no values.\n+     *\n+     * @param string  single string fragment\n+     *\n+     * @return StringTemplate composed from string\n+     *\n+     * @throws NullPointerException if string is null\n+     *\/\n+    static StringTemplate of(String string) {\n+        Objects.requireNonNull(string, \"string must not be null\");\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.of(List.of(string), List.of());\n+    }\n+\n+    \/**\n+     * Returns a StringTemplate with the given fragments and values.\n+     *\n+     * @implSpec The {@code fragments} list size must be one more that the\n+     * {@code values} list size.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from string\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n+     *\n+     * @implNote Contents of both lists are copied to construct immutable lists.\n+     *\/\n+    static StringTemplate of(List<String> fragments, List<?> values) {\n+        Objects.requireNonNull(fragments, \"fragments must not be null\");\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        if (values.size() + 1 != fragments.size()) {\n+            throw new IllegalArgumentException(\n+                    \"fragments list size is not one more than values list size\");\n+        }\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.of(fragments, values);\n+    }\n+\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments. To accommodate interpolation, values are converted to strings\n+     * as if invoking {@link String#valueOf(Object)}.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n+     *\/\n+    static String interpolate(List<String> fragments, List<?> values) {\n+        Objects.requireNonNull(fragments, \"fragments must not be null\");\n+        Objects.requireNonNull(values, \"values must not be null\");\n+        int fragmentsSize = fragments.size();\n+        int valuesSize = values.size();\n+        if (fragmentsSize != valuesSize + 1) {\n+            throw new IllegalArgumentException(\"fragments must have one more element than values\");\n+        }\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.interpolate(fragments, values);\n+    }\n+\n+    \/**\n+     * Combine zero or more {@link StringTemplate StringTemplates} into a single\n+     * {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n+     * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n+     * }\n+     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n+     * end with the last fragment from each {@link StringTemplate} concatenated with the\n+     * first fragment of the next. To demonstrate, if we were to take two strings and we\n+     * combined them as follows: {@snippet lang = \"java\":\n+     * String s1 = \"abc\";\n+     * String s2 = \"xyz\";\n+     * String sc = s1 + s2;\n+     * assert Objects.equals(sc, \"abcxyz\");\n+     * }\n+     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n+     * character {@code \"x\"} of the second string. The same would be true of combining\n+     * {@link StringTemplate StringTemplates}.\n+     * {@snippet lang =\"java\":\n+     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n+     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n+     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n+     * StringTemplate stc = StringTemplate.combine(st1, st2);\n+     *\n+     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n+     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n+     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * }\n+     * Values lists are simply concatenated to produce a single values list.\n+     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n+     * n is the total of number of values across all the supplied\n+     * {@link StringTemplate StringTemplates}.\n+     *\n+     * @param stringTemplates  zero or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if stringTemplates is null or if any of the\n+     * {@code stringTemplates} are null\n+     *\n+     * @implNote If zero {@link StringTemplate} arguments are provided then a\n+     * {@link StringTemplate} with an empty fragment and no values is returned, as if invoking\n+     * <code>StringTemplate.of(\"\")<\/code> . If only one {@link StringTemplate} argument is provided\n+     * then it is returned unchanged.\n+     *\/\n+    static StringTemplate combine(StringTemplate... stringTemplates) {\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.combine(stringTemplates);\n+    }\n+\n+    \/**\n+     * Combine a list of {@link StringTemplate StringTemplates} into a single\n+     * {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(List.of(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\"));\n+     * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n+     * }\n+     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n+     * end with the last fragment from each {@link StringTemplate} concatenated with the\n+     * first fragment of the next. To demonstrate, if we were to take two strings and we\n+     * combined them as follows: {@snippet lang = \"java\":\n+     * String s1 = \"abc\";\n+     * String s2 = \"xyz\";\n+     * String sc = s1 + s2;\n+     * assert Objects.equals(sc, \"abcxyz\");\n+     * }\n+     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n+     * character {@code \"x\"} of the second string. The same would be true of combining\n+     * {@link StringTemplate StringTemplates}.\n+     * {@snippet lang =\"java\":\n+     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n+     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n+     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n+     * StringTemplate stc = StringTemplate.combine(st1, st2);\n+     *\n+     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n+     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n+     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n+     * }\n+     * Values lists are simply concatenated to produce a single values list.\n+     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n+     * n is the total of number of values across all the supplied\n+     * {@link StringTemplate StringTemplates}.\n+     *\n+     * @param stringTemplates  list of {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if stringTemplates is null or if any of the\n+     * its elements are null\n+     *\n+     * @implNote If {@code stringTemplates.size() == 0} then a {@link StringTemplate} with\n+     * an empty fragment and no values is returned, as if invoking\n+     * <code>StringTemplate.of(\"\")<\/code> . If {@code stringTemplates.size() == 1}\n+     * then the first element of the list is returned unchanged.\n+     *\/\n+    static StringTemplate combine(List<StringTemplate> stringTemplates) {\n+        JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n+        return JTA.combine(stringTemplates.toArray(new StringTemplate[0]));\n+    }\n+\n+    \/**\n+     * This {@link StringProcessor} instance is conventionally used for the string interpolation\n+     * of a supplied {@link StringTemplate}.\n+     * <p>\n+     * For better visibility and when practical, it is recommended that users use the\n+     * {@link StringTemplate#STR} processor instead of invoking the\n+     * {@link StringTemplate#interpolate()} method.\n+     * Example: {@snippet :\n+     * int x = 10;\n+     * int y = 20;\n+     * String result = STR.\"\\{x} + \\{y} = \\{x + y}\"; \/\/ @highlight substring=\"STR\"\n+     * }\n+     * In the above example, the value of {@code result} will be {@code \"10 + 20 = 30\"}. This is\n+     * produced by the interleaving concatenation of fragments and values from the supplied\n+     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n+     * as if invoking {@link String#valueOf(Object)}.\n+     * @implNote {@link StringTemplate#STR} is statically imported implicitly into every\n+     * Java compilation unit.<p>The result of interpolation is not interned.\n+     *\/\n+    static final StringProcessor STR = StringTemplate::interpolate;\n+\n+    \/**\n+     * This {@link SimpleProcessor} instance is conventionally used to indicate that the\n+     * processing of the {@link StringTemplate} is to be deferred to a later time. Deferred\n+     * processing can be resumed by invoking the\n+     * {@link StringTemplate#process(Processor)} or\n+     * {@link Processor#process(StringTemplate)} methods.\n+     * {@snippet :\n+     * import static java.lang.StringTemplate.RAW;\n+     * ...\n+     * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n+     * ...other steps...\n+     * String result = STR.process(st);\n+     * }\n+     * @implNote Unlike {@link StringTemplate#STR}, {@link StringTemplate#RAW} must be\n+     * statically imported explicitly.\n+     *\/\n+    static final SimpleProcessor<StringTemplate> RAW = st -> st;\n+\n+    \/**\n+     * This interface describes the methods provided by a generalized string template processor. The\n+     * primary method {@link Processor#process(StringTemplate)} is used to validate\n+     * and compose a result using a {@link StringTemplate StringTemplate's} fragments and values lists.\n+     *\n+     * For example:\n+     * {@snippet :\n+     * class MyProcessor implements Processor<String, IllegalArgumentException> {\n+     *     @Override\n+     *     public String process(StringTemplate st) throws IllegalArgumentException {\n+     *          StringBuilder sb = new StringBuilder();\n+     *          Iterator<String> fragmentsIter = st.fragments().iterator();\n+     *\n+     *          for (Object value : st.values()) {\n+     *              sb.append(fragmentsIter.next());\n+     *\n+     *              if (value instanceof Boolean) {\n+     *                  throw new IllegalArgumentException(\"I don't like Booleans\");\n+     *              }\n+     *\n+     *              sb.append(value);\n+     *          }\n+     *\n+     *          sb.append(fragmentsIter.next());\n+     *\n+     *          return sb.toString();\n+     *     }\n+     * }\n+     *\n+     * MyProcessor myProcessor = new MyProcessor();\n+     * try {\n+     *     int x = 10;\n+     *     int y = 20;\n+     *     String result = myProcessor.\"\\{x} + \\{y} = \\{x + y}\";\n+     *     ...\n+     * } catch (IllegalArgumentException ex) {\n+     *     ...\n+     * }\n+     * }\n+     * Implementations of this interface may provide, but are not limited to, validating\n+     * inputs, composing inputs into a result, and transforming an intermediate string\n+     * result to a non-string value before delivering the final result.\n+     * <p>\n+     * The user has the option of validating inputs used in composition. For example an SQL\n+     * processor could prevent injection vulnerabilities by sanitizing inputs or throwing an\n+     * exception of type {@code E} if an SQL statement is a potential vulnerability.\n+     * <p>\n+     * Composing allows user control over how the result is assembled. Most often, a\n+     * user will construct a new string from the string template, with placeholders\n+     * replaced by string representations of value list elements. These string\n+     * representations are created as if invoking {@link String#valueOf}.\n+     * <p>\n+     * Transforming allows the processor to return something other than a string. For\n+     * instance, a JSON processor could return a JSON object, by parsing the string created\n+     * by composition, instead of the composed string.\n+     * <p>\n+     * {@link Processor} is a {@link FunctionalInterface}. This permits\n+     * declaration of a processor using lambda expressions;\n+     * {@snippet :\n+     * Processor<String, RuntimeException> processor = st -> {\n+     *     List<String> fragments = st.fragments();\n+     *     List<Object> values = st.values();\n+     *     \/\/ check or manipulate the fragments and\/or values\n+     *     ...\n+     *     return StringTemplate.interpolate(fragments, values);\n+     * };\n+     * }\n+     * The {@link FunctionalInterface} {@link SimpleProcessor} is supplied to avoid\n+     * the use of checked exceptions;\n+     * {@snippet :\n+     * SimpleProcessor<String> processor = st -> {\n+     *     List<String> fragments = st.fragments();\n+     *     List<Object> values = st.values();\n+     *     \/\/ check or manipulate the fragments and\/or values\n+     *     ...\n+     *     return StringTemplate.interpolate(fragments, values);\n+     * };\n+     * }\n+     * The {@link FunctionalInterface} {@link StringProcessor} is supplied if\n+     * the processor returns {@link String};\n+     * {@snippet :\n+     * StringProcessor processor = st -> {\n+     *     List<String> fragments = st.fragments();\n+     *     List<Object> values = st.values();\n+     *     \/\/ check or manipulate the fragments and\/or values\n+     *     ...\n+     *     return StringTemplate.interpolate(fragments, values);\n+     * };\n+     * }\n+     * The {@link StringTemplate#interpolate()} method is available for those processors\n+     * that just need to work with the string interpolation;\n+     * {@snippet :\n+     * StringProcessor processor = StringTemplate::interpolate;\n+     * }\n+     * or simply transform the string interpolation into something other than\n+     * {@link String};\n+     * {@snippet :\n+     * SimpleProcessor<JSONObject> jsonProcessor = st -> new JSONObject(st.interpolate());\n+     * }\n+     * @implNote The Java compiler automatically imports {@link StringTemplate#STR}\n+     *\n+     * @param <R>  Processor's process result type\n+     * @param <E>  Exception thrown type\n+     *\n+     * @see SimpleProcessor\n+     * @see StringProcessor\n+     * @see StringTemplate\n+     * @see java.util.FormatProcessor\n+     *\n+     * @since 21\n+     *\n+     * @jls 15.8.6 Process Template Expressions\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    @FunctionalInterface\n+    public interface Processor<R, E extends Throwable> {\n+\n+        \/**\n+         * Constructs a result based on the template fragments and values in the\n+         * supplied {@link StringTemplate stringTemplate} object.\n+         *\n+         * @param stringTemplate  a {@link StringTemplate} instance\n+         *\n+         * @return constructed object of type R\n+         *\n+         * @throws E exception thrown by the template processor when validation fails\n+         *\/\n+        R process(StringTemplate stringTemplate) throws E;\n+\n+        \/**\n+         * Built-in policies using this additional interface have the flexibility to\n+         * specialize the composition of the templated string by returning a customized\n+         * {@link MethodHandle} from {@link Linkage#linkage linkage}.\n+         * These specializations are typically implemented to improve performance;\n+         * specializing value types or avoiding boxing and vararg arrays.\n+         *\n+         * @implNote This interface is sealed to only allow standard processors.\n+         *\n+         * @since 21\n+         *\/\n+        @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+        public sealed interface Linkage permits FormatProcessor {\n+            \/**\n+             * This method creates a {@link MethodHandle} that when invoked with arguments of\n+             * those specified in {@code type} returns a result that equals that returned by\n+             * the template processor's process method. The difference being that this method\n+             * can preview the template's fragments and value types in advance of usage and\n+             * thereby has the opportunity to produce a specialized implementation.\n+             *\n+             * @param fragments  string template fragments\n+             * @param type       method type, includes the StringTemplate receiver as\n+             * well as the value types\n+             *\n+             * @return {@link MethodHandle} for the processor applied to template\n+             *\n+             * @throws NullPointerException if any of the arguments are null\n+             *\/\n+            MethodHandle linkage(List<String> fragments, MethodType type);\n+        }\n+    }\n+\n+    \/**\n+     * This interface is used to implement template processors that do not throw checked\n+     * exceptions. Any implementation must supply a\n+     * {@link SimpleProcessor#process(StringTemplate)} method that constructs a result\n+     * from the information provided by the supplied {@link StringTemplate} instance.\n+     * <p>\n+     * For example:\n+     * {@snippet :\n+     * SimpleProcessor<Integer> processor = st -> {\n+     *     String interpolation = st.interpolate();\n+     *     return Integer.valueOf(interpolation);\n+     * };\n+     * }\n+     *\n+     * @param <R>  Processor's process result type.\n+     *\n+     * @see Processor\n+     * @see StringProcessor\n+     * @see StringTemplate\n+     *\n+     * @since 21\n+     *\n+     * @implNote It is recommended that {@link StringProcessor} be used instead of\n+     * {@code SimpleProcessor<String>} when the result type is {@link String}.\n+     *\n+     * @jls 15.8.6 Process Template Expressions\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    @FunctionalInterface\n+    public interface SimpleProcessor<R> extends Processor<R, RuntimeException> {\n+        \/**\n+         * Constructs a result based on the template fragments and values in the\n+         * supplied {@link StringTemplate stringTemplate} instance.\n+         *\n+         * @param stringTemplate  a {@link StringTemplate} instance\n+         *\n+         * @return constructed object of type R\n+         *\/\n+        @Override\n+        R process(StringTemplate stringTemplate);\n+    }\n+\n+    \/**\n+     * This interface is used to implement template processors that only produce {@link String}\n+     * results. Any implementation must supply a\n+     * {@link StringProcessor#process(StringTemplate)} method that constructs a result\n+     * from the information provided by the supplied {@link StringTemplate} instance.\n+     * <p>\n+     * For example:\n+     * {@snippet :\n+     * StringProcessor processor = st -> st.interpolate().toUpperCase();\n+     * }\n+     *\n+     * @see Processor\n+     * @see SimpleProcessor\n+     * @see StringTemplate\n+     *\n+     * @since 21\n+     *\n+     * @implNote Implementations using {@link StringProcessor} are equivalent to implementations using\n+     * {@code TemplateProcessor<String>} or {@code ValidatingProcessor<String, RuntimeException>}.\n+     * However, StringProcessor is cleaner and easier to understand.\n+     *\n+     * @jls 15.8.6 Process Template Expressions\n+     *\/\n+    @PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+    @FunctionalInterface\n+    public interface StringProcessor extends SimpleProcessor<String> {\n+        \/**\n+         * Constructs a {@link String} based on the template fragments and values in the\n+         * supplied {@code stringTemplate} object.\n+         *\n+         * @param stringTemplate  a {@link StringTemplate} instance\n+         *\n+         * @return constructed {@link String}\n+         *\/\n+        @Override\n+        String process(StringTemplate stringTemplate);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringTemplate.java","additions":692,"deletions":0,"binary":false,"changes":692,"status":"added"},{"patch":"@@ -36,1 +36,0 @@\n-import java.lang.template.StringTemplate;\n@@ -1070,1 +1069,1 @@\n-            throw new StringConcatException(\"fragments size not equal ptypes size plus one\");\n+            throw new IllegalArgumentException(\"fragments size not equal ptypes size plus one\");\n@@ -1204,1 +1203,1 @@\n-            throw new StringConcatException(\"maxSlots must be between 1 and \" +\n+            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n@@ -1280,1 +1279,1 @@\n-            throw new StringConcatException(\"maxSlots must be between 1 and \" +\n+            throw new IllegalArgumentException(\"maxSlots must be between 1 and \" +\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package java.lang.template;\n+package java.lang.runtime;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/Carriers.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/template\/Carriers.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package java.lang.template;\n+package java.lang.runtime;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferenceKey.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ReferenceKey.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package java.lang.template;\n+package java.lang.runtime;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/ReferencedKeyMap.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ReferencedKeyMap.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package java.lang.template;\n+package java.lang.runtime;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplateImpl.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n-package java.lang.template;\n+package java.lang.runtime;\n@@ -36,1 +36,0 @@\n-import jdk.internal.access.JavaTemplateAccess;\n@@ -43,1 +42,1 @@\n- * {@link java.lang.runtime.TemplateRuntime} via {@code SharedSecrets.getJavaTemplateAccess()}.\n+ * {@link java.lang.runtime.TemplateRuntime}.\n@@ -48,1 +47,1 @@\n-final class StringTemplateImplFactory implements JavaTemplateAccess {\n+final class StringTemplateImplFactory {\n@@ -56,0 +55,1 @@\n+        throw new AssertionError(\"private constructor\");\n@@ -93,2 +93,1 @@\n-    @Override\n-    public MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type) {\n+    static MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type) {\n@@ -158,2 +157,1 @@\n-    @Override\n-    public StringTemplate newStringTemplate(String[] fragments, Object[] values) {\n+    static StringTemplate newStringTemplate(String[] fragments, Object[] values) {\n@@ -171,2 +169,1 @@\n-    @Override\n-    public StringTemplate newStringTemplate(List<String> fragments, Object[] values) {\n+    static StringTemplate newStringTemplate(List<String> fragments, Object[] values) {\n@@ -184,2 +181,1 @@\n-    @Override\n-    public StringTemplate newStringTemplate(List<String> fragments, List<?> values) {\n+    static StringTemplate newStringTemplate(List<String> fragments, List<?> values) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/StringTemplateImplFactory.java","additions":9,"deletions":13,"binary":false,"changes":22,"previous_filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplateImplFactory.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,3 +33,2 @@\n-import java.lang.template.ProcessorLinkage;\n-import java.lang.template.StringTemplate;\n-import java.lang.template.ValidatingProcessor;\n+import java.lang.StringTemplate.Processor;\n+import java.lang.StringTemplate.Processor.Linkage;\n@@ -59,1 +58,1 @@\n- * to bind to specialized processors that implement {@link ProcessorLinkage}.\n+ * to bind to specialized processors that implement {@link Linkage}.\n@@ -85,1 +84,1 @@\n-                    List.class, ValidatingProcessor.class, Object[].class);\n+                    List.class, Processor.class, Object[].class);\n@@ -104,0 +103,1 @@\n+     * The non-static arguments are the fragments list and values list.\n@@ -126,0 +126,2 @@\n+     * The static arguments include the fragments list.\n+     * The non-static arguments are the values.\n@@ -146,1 +148,1 @@\n-        MethodHandle mh = JTA\n+        MethodHandle mh = StringTemplateImplFactory\n@@ -154,0 +156,3 @@\n+     * The static arguments include the fragments list  and a {@link MethodHandle}\n+     * to retrieve the value of the static final processor.\n+     * The non-static arguments are the values.\n@@ -177,3 +182,3 @@\n-        ValidatingProcessor<?, ?> processor = (ValidatingProcessor<?, ?>)processorGetter.invoke();\n-        MethodHandle mh = processor instanceof ProcessorLinkage processorLinkage\n-                ? processorLinkage.linkage(List.of(fragments), type)\n+        Processor<?, ?> processor = (Processor<?, ?>)processorGetter.invoke();\n+        MethodHandle mh = processor instanceof Linkage linkage\n+                ? linkage.linkage(List.of(fragments), type)\n@@ -189,1 +194,1 @@\n-     * @param processor {@link ValidatingProcessor} to process\n+     * @param processor {@link Processor} to process\n@@ -196,1 +201,1 @@\n-            ValidatingProcessor<?, ?> processor,\n+            Processor<?, ?> processor,\n@@ -211,1 +216,1 @@\n-            ValidatingProcessor<?, ?> processor,\n+            Processor<?, ?> processor,\n@@ -228,1 +233,1 @@\n-        return JTA.newStringTemplate(fragments, values);\n+        return StringTemplateImplFactory.newStringTemplate(fragments, values);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateRuntime.java","additions":19,"deletions":14,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -0,0 +1,152 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package java.lang.runtime;\n+\n+import java.lang.StringTemplate.StringProcessor;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.JavaTemplateAccess;\n+import jdk.internal.access.SharedSecrets;\n+import jdk.internal.javac.PreviewFeature;\n+\n+\/**\n+ * This class provides runtime support for string templates. The methods within\n+ * are intended for internal use only.\n+ *\n+ * @since 21\n+ *\/\n+@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n+final class TemplateSupport implements JavaTemplateAccess {\n+\n+    \/**\n+     * Private constructor.\n+     *\/\n+    private TemplateSupport() {\n+    }\n+\n+    static {\n+        SharedSecrets.setJavaTemplateAccess(new TemplateSupport());\n+    }\n+\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n+    \/**\n+     * Returns a StringTemplate composed from fragments and values.\n+     *\n+     * @implSpec The {@code fragments} list size must be one more that the\n+     * {@code values} list size.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from fragments and values\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n+     *\n+     * @implNote Contents of both lists are copied to construct immutable lists.\n+     *\/\n+    @Override\n+    public StringTemplate of(List<String> fragments, List<?> values) {\n+        return StringTemplateImplFactory.newStringTemplate(fragments, values);\n+    }\n+\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\/\n+    @Override\n+    public String interpolate(List<String> fragments, List<?> values) {\n+        int fragmentsSize = fragments.size();\n+        int valuesSize = values.size();\n+        if (fragmentsSize == 1) {\n+            return fragments.get(0);\n+        }\n+        int size = fragmentsSize + valuesSize;\n+        String[] strings = new String[size];\n+        int i = 0, j = 0;\n+        for (; j < valuesSize; j++) {\n+            strings[i++] = fragments.get(j);\n+            strings[i++] = String.valueOf(values.get(j));\n+        }\n+        strings[i] = fragments.get(j);\n+        return JLA.join(\"\", \"\", \"\", strings, size);\n+    }\n+\n+    \/**\n+     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n+     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n+     * }\n+     *\n+     * @param sts  zero or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if sts is null or if any element of sts is null\n+     *\/\n+    @Override\n+    public StringTemplate combine(StringTemplate... sts) {\n+        Objects.requireNonNull(sts, \"sts must not be null\");\n+        if (sts.length == 0) {\n+            return StringTemplate.of(\"\");\n+        } else if (sts.length == 1) {\n+            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n+        }\n+        int size = 0;\n+        for (StringTemplate st : sts) {\n+            Objects.requireNonNull(st, \"string templates should not be null\");\n+            size += st.values().size();\n+        }\n+        String[] combinedFragments = new String[size + 1];\n+        Object[] combinedValues = new Object[size];\n+        combinedFragments[0] = \"\";\n+        int fragmentIndex = 1;\n+        int valueIndex = 0;\n+        for (StringTemplate st : sts) {\n+            Iterator<String> iterator = st.fragments().iterator();\n+            combinedFragments[fragmentIndex - 1] += iterator.next();\n+            while (iterator.hasNext()) {\n+                combinedFragments[fragmentIndex++] = iterator.next();\n+            }\n+            for (Object value : st.values()) {\n+                combinedValues[valueIndex++] = value;\n+            }\n+        }\n+        return StringTemplateImplFactory.newStringTemplate(combinedFragments, combinedValues);\n+    }\n+\n+}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/TemplateSupport.java","additions":152,"deletions":0,"binary":false,"changes":152,"status":"added"},{"patch":"@@ -1,64 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import java.util.List;\n-import java.lang.invoke.CallSite;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodType;\n-import java.util.FormatProcessor;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * Built-in policies using this additional interface have the flexibility to\n- * specialize the composition of the templated string by returning a customized\n- * {@link MethodHandle} from {@link ProcessorLinkage#linkage linkage}.\n- * These specializations are typically implemented to improve performance;\n- * specializing value types or avoiding boxing and vararg arrays.\n- *\n- * @implNote This interface is sealed to only allow standard processors.\n- *\n- * @since 21\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public sealed interface ProcessorLinkage permits FormatProcessor {\n-    \/**\n-     * This method creates a {@link MethodHandle} that when invoked with arguments of\n-     * those specified in {@code type} returns a result that equals that returned by\n-     * the template processor's process method. The difference being that this method\n-     * can preview the template's fragments and value types in advance of usage and\n-     * thereby has the opportunity to produce a specialized implementation.\n-     *\n-     * @param fragments  string template fragments\n-     * @param type       method type\n-     *\n-     * @return {@link MethodHandle} for the processor applied to template\n-     *\n-     * @throws NullPointerException if any of the arguments are null\n-     *\/\n-    MethodHandle linkage(List<String> fragments, MethodType type);\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ProcessorLinkage.java","additions":0,"deletions":64,"binary":false,"changes":64,"status":"deleted"},{"patch":"@@ -1,66 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * This interface is used to implement template processors that only produce {@link String}\n- * results. Any implementation must supply a\n- * {@link StringProcessor#process(StringTemplate)} method that constructs a result\n- * from the information provided by the supplied {@link StringTemplate} instance.\n- * <p>\n- * For example:\n- * {@snippet :\n- * StringProcessor processor = st -> st.interpolate().toUpperCase();\n- * }\n- *\n- * @see java.lang.template.ValidatingProcessor\n- * @see java.lang.template.TemplateProcessor\n- * @see java.lang.template.StringTemplate\n- *\n- * @since 21\n- *\n- * @implNote Implementations using {@link StringProcessor} are equivalent to implementations using\n- * {@code TemplateProcessor<String>} or {@code ValidatingProcessor<String, RuntimeException>}.\n- * However, StringProcessor is cleaner and easier to understand.\n- *\n- * @jls 15.8.6 Process Template Expressions\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-@FunctionalInterface\n-public interface StringProcessor extends TemplateProcessor<String> {\n-    \/**\n-     * Constructs a {@link String} based on the template fragments and values in the\n-     * supplied {@code stringTemplate} object.\n-     *\n-     * @param stringTemplate  a {@link StringTemplate} instance\n-     *\n-     * @return constructed {@link String}\n-     *\/\n-    @Override\n-    String process(StringTemplate stringTemplate);\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringProcessor.java","additions":0,"deletions":66,"binary":false,"changes":66,"status":"deleted"},{"patch":"@@ -1,439 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import java.lang.Object;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * {@link StringTemplate} is the run-time representation of a string template or\n- * text block template in a template expression.\n- *\n- * <p>\n- * In the source code of a Java program, a string template or text block template\n- * contains an interleaved succession of <em>fragment literals<\/em> and <em>embedded\n- * expressions<\/em>. The {@link StringTemplate#fragments()} method returns the\n- * fragment literals, and the {@link StringTemplate#values()} method returns the\n- * results of evaluating the embedded expressions. {@link StringTemplate} does not\n- * provide access to the source code of the embedded expressions themselves; it is\n- * not a compile-time representation of a string template or text block template.\n- * <p>\n- * {@link StringTemplate} is primarily used in conjunction with a template processor\n- * to produce a string or other meaningful value. Evaluation of a template expression\n- * first produces an instance of {@link StringTemplate}, representing the template\n- * of the template expression, and then passes the instance to the template processor\n- * given by the template expression.\n- * <p>\n- * For example, the following code contains a template expression that uses the template\n- * processor {@code RAW}, which simply yields the {@link StringTemplate} passed to it:\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * List<String> fragments = st.fragments();\n- * List<Object> values = st.values();\n- * }\n- * The value of {@code fragments} will be equivalent to {@code List.of(\"\", \" + \", \" = \", \"\")},\n- * which includes the empty first and last fragments. The {@code values} will be the\n- * equivalent of {@code List.of(10, 20, 30)}.\n- * <p>\n- * The following code contains a template expression with the same template but with a\n- * different template processor, {@code STR}:\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * String s = STR.\"\\{x} + \\{y} = \\{x + y}\";\n- * }\n- * When the template expression is evaluated, an instance of {@link StringTemplate} is\n- * produced that returns the same lists from {@link StringTemplate#fragments()} and\n- * {@link StringTemplate#values()} as shown above. The {@link StringTemplate#STR} template\n- * processor uses these lists to yield an interpolated string. The value of {@code s} will\n- * be equivalent to {@code \"10 + 20 = 30\"}.\n- * <p>\n- * The {@code interpolate()} method provides a direct way to perform string interpolation\n- * of a {@link StringTemplate}. Template processors can use the following code pattern:\n- * {@snippet :\n- * List<String> fragments = st.fragments();\n- * List<Object> values    = st.values();\n- * ... check or manipulate the fragments and\/or values ...\n- * String result = StringTemplate.interpolate(fragments, values);\n- * }\n- * The {@link StringTemplate#process(ValidatingProcessor)} method, in conjunction with\n- * the {@link StringTemplate#RAW} processor, may be used to defer processing of a\n- * {@link StringTemplate}.\n- * {@snippet :\n- * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n- * ...other steps...\n- * String result = st.process(STR);\n- * }\n- * The factory methods {@link StringTemplate#of(String)} and\n- * {@link StringTemplate#of(List, List)} can be used to construct a {@link StringTemplate}.\n- *\n- * @see ValidatingProcessor\n- * @see TemplateProcessor\n- * @see StringProcessor\n- * @see java.util.FormatProcessor\n- *\n- * @implNote Implementations of {@link StringTemplate} must minimally implement the\n- * methods {@link StringTemplate#fragments()} and {@link StringTemplate#values()}.\n- * Instances of {@link StringTemplate} are considered immutable. To preserve the\n- * semantics of string templates and text block templates, the list returned by\n- * {@link StringTemplate#fragments()} must be one element larger than the list returned\n- * by {@link StringTemplate#values()}.\n- *\n- * @since 21\n- *\n- * @jls 15.8.6 Process Template Expressions\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-public interface StringTemplate {\n-    \/**\n-     * Returns a list of fragment literals for this {@link StringTemplate}.\n-     * The fragment literals are the character sequences preceding each of the embedded\n-     * expressions in source code, plus the character sequence following the last\n-     * embedded expression. Such character sequences may be zero-length if an embedded\n-     * expression appears at the beginning or end of a template, or if two embedded\n-     * expressions are directly adjacent in a template.\n-     * In the example: {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * List<String> fragments = st.fragments(); \/\/ @highlight substring=\"fragments()\"\n-     * }\n-     * {@code fragments} will be equivalent to\n-     * {@code List.of(\"The student \", \" is in \", \"'s classroom.\")}\n-     *\n-     * @return list of string fragments\n-     *\/\n-    List<String> fragments();\n-\n-    \/**\n-     * Returns a list of embedded expression results for this {@link StringTemplate}.\n-     * In the example:\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * List<Object> values = st.values(); \/\/ @highlight substring=\"values()\"\n-     * }\n-     * {@code values} will be equivalent to {@code List.of(student, teacher)}\n-     *\n-     * @return list of expression values\n-     *\/\n-    List<Object> values();\n-\n-    \/**\n-     * Returns the string interpolation of the fragments and values for this\n-     * {@link StringTemplate}.\n-     * <p>\n-     * For better visibility and when practical, it is recommended to use the\n-     * {@link StringTemplate#STR} processor instead of invoking the\n-     * {@link StringTemplate#interpolate()} method.\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * StringTemplate st = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * String result = st.interpolate(); \/\/ @highlight substring=\"interpolate()\"\n-     * }\n-     * In the above example, the value of  {@code result} will be\n-     * {@code \"The student Mary is in Johnson's classroom.\"}. This is\n-     * produced by the interleaving concatenation of fragments and values from the supplied\n-     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     *\n-     * @return interpolation of this {@link StringTemplate}\n-     *\n-     * @implSpec The default implementation returns the result of invoking\n-     * {@code StringTemplate.interpolate(this.fragments(), this.values())}.\n-     *\/\n-    default String interpolate() {\n-        return StringTemplate.interpolate(fragments(), values());\n-    }\n-\n-    \/**\n-     * Returns the result of applying the specified processor to this {@link StringTemplate}.\n-     * This method can be used as an alternative to string template expressions. For example,\n-     * {@snippet :\n-     * String student = \"Mary\";\n-     * String teacher = \"Johnson\";\n-     * String result1 = STR.\"The student \\{student} is in \\{teacher}'s classroom.\";\n-     * String result2 = RAW.\"The student \\{student} is in \\{teacher}'s classroom.\".process(STR); \/\/ @highlight substring=\"process\"\n-     * }\n-     * Produces an equivalent result for both {@code result1} and {@code result2}.\n-     *\n-     * @param processor the {@link ValidatingProcessor} instance to process\n-     *\n-     * @param <R>  Processor's process result type.\n-     * @param <E>  Exception thrown type.\n-     *\n-     * @return constructed object of type {@code R}\n-     *\n-     * @throws E exception thrown by the template processor when validation fails\n-     * @throws NullPointerException if processor is null\n-     *\n-     * @implSpec The default implementation returns the result of invoking\n-     * {@code processor.process(this)}. If the invocation throws an exception that\n-     * exception is forwarded to the caller.\n-     *\/\n-    default <R, E extends Throwable> R\n-    process(ValidatingProcessor<? extends R, ? extends E> processor) throws E {\n-        Objects.requireNonNull(processor, \"processor should not be null\");\n-\n-        return processor.process(this);\n-    }\n-\n-    \/**\n-     * Produces a diagnostic string that describes the fragments and values of the supplied\n-     * {@link StringTemplate}.\n-     *\n-     * @param stringTemplate  the {@link StringTemplate} to represent\n-     *\n-     * @return diagnostic string representing the supplied string template\n-     *\n-     * @throws NullPointerException if stringTemplate is null\n-     *\/\n-    static String toString(StringTemplate stringTemplate) {\n-        Objects.requireNonNull(stringTemplate, \"stringTemplate should not be null\");\n-        return \"StringTemplate{ fragments = [ \\\"\" +\n-                String.join(\"\\\", \\\"\", stringTemplate.fragments()) +\n-                \"\\\" ], values = \" +\n-                stringTemplate.values() +\n-                \" }\";\n-    }\n-\n-    \/**\n-     * Returns a {@link StringTemplate} as if constructed by invoking\n-     * {@code StringTemplate.of(List.of(string), List.of())}. That is, a {@link StringTemplate}\n-     * with one fragment and no values.\n-     *\n-     * @param string  single string fragment\n-     *\n-     * @return StringTemplate composed from string\n-     *\n-     * @throws NullPointerException if string is null\n-     *\/\n-    static StringTemplate of(String string) {\n-        Objects.requireNonNull(string, \"string must not be null\");\n-        return TemplateSupport.of(List.of(string), List.of());\n-    }\n-\n-    \/**\n-     * Returns a StringTemplate with the given fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from string\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    static StringTemplate of(List<String> fragments, List<?> values) {\n-        Objects.requireNonNull(fragments, \"fragments must not be null\");\n-        Objects.requireNonNull(values, \"values must not be null\");\n-        if (values.size() + 1 != fragments.size()) {\n-            throw new IllegalArgumentException(\n-                    \"fragments list size is not one more than values list size\");\n-        }\n-        return TemplateSupport.of(fragments, values);\n-    }\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments. To accommodate interpolation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException fragments or values is null or if any of the fragments is null\n-     *\/\n-    static String interpolate(List<String> fragments, List<?> values) {\n-        Objects.requireNonNull(fragments, \"fragments must not be null\");\n-        Objects.requireNonNull(values, \"values must not be null\");\n-        int fragmentsSize = fragments.size();\n-        int valuesSize = values.size();\n-        if (fragmentsSize != valuesSize + 1) {\n-            throw new IllegalArgumentException(\"fragments must have one more element than values\");\n-        }\n-        return TemplateSupport.interpolate(fragments, values);\n-    }\n-\n-    \/**\n-     * Combine zero or more {@link StringTemplate StringTemplates} into a single\n-     * {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\");\n-     * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n-     * }\n-     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n-     * end with the last fragment from each {@link StringTemplate} concatenated with the\n-     * first fragment of the next. To demonstrate, if we were to take two strings and we\n-     * combined them as follows: {@snippet lang = \"java\":\n-     * String s1 = \"abc\";\n-     * String s2 = \"xyz\";\n-     * String sc = s1 + s2;\n-     * assert Objects.equals(sc, \"abcxyz\");\n-     * }\n-     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n-     * character {@code \"x\"} of the second string. The same would be true of combining\n-     * {@link StringTemplate StringTemplates}.\n-     * {@snippet lang =\"java\":\n-     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n-     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n-     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n-     * StringTemplate stc = StringTemplate.combine(st1, st2);\n-     *\n-     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n-     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n-     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * }\n-     * Values lists are simply concatenated to produce a single values list.\n-     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n-     * n is the total of number of values across all the supplied\n-     * {@link StringTemplate StringTemplates}.\n-     *\n-     * @param stringTemplates  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if stringTemplates is null or if any of the\n-     * {@code stringTemplates} are null\n-     *\n-     * @implNote If zero {@link StringTemplate} arguments are provided then a\n-     * {@link StringTemplate} with an empty fragment and no values is returned, as if invoking\n-     * <code>StringTemplate.of(\"\")<\/code> . If only one {@link StringTemplate} argument is provided\n-     * then it is returned unchanged.\n-     *\/\n-    static StringTemplate combine(StringTemplate... stringTemplates) {\n-        return TemplateSupport.combine(stringTemplates);\n-    }\n-\n-    \/**\n-     * Combine a list of {@link StringTemplate StringTemplates} into a single\n-     * {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(List.of(RAW.\"\\{a}\", RAW.\"\\{b}\", RAW.\"\\{c}\"));\n-     * assert st.interpolate().equals(RAW.\"\\{a}\\{b}\\{c}\");\n-     * }\n-     * Fragment lists from the {@link StringTemplate StringTemplates} are combined end to\n-     * end with the last fragment from each {@link StringTemplate} concatenated with the\n-     * first fragment of the next. To demonstrate, if we were to take two strings and we\n-     * combined them as follows: {@snippet lang = \"java\":\n-     * String s1 = \"abc\";\n-     * String s2 = \"xyz\";\n-     * String sc = s1 + s2;\n-     * assert Objects.equals(sc, \"abcxyz\");\n-     * }\n-     * the last character {@code \"c\"} from the first string is juxtaposed with the first\n-     * character {@code \"x\"} of the second string. The same would be true of combining\n-     * {@link StringTemplate StringTemplates}.\n-     * {@snippet lang =\"java\":\n-     * StringTemplate st1 = RAW.\"a\\{}b\\{}c\";\n-     * StringTemplate st2 = RAW.\"x\\{}y\\{}z\";\n-     * StringTemplate st3 = RAW.\"a\\{}b\\{}cx\\{}y\\{}z\";\n-     * StringTemplate stc = StringTemplate.combine(st1, st2);\n-     *\n-     * assert Objects.equals(st1.fragments(), List.of(\"a\", \"b\", \"c\"));\n-     * assert Objects.equals(st2.fragments(), List.of(\"x\", \"y\", \"z\"));\n-     * assert Objects.equals(st3.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * assert Objects.equals(stc.fragments(), List.of(\"a\", \"b\", \"cx\", \"y\", \"z\"));\n-     * }\n-     * Values lists are simply concatenated to produce a single values list.\n-     * The result is a well-formed {@link StringTemplate} with n+1 fragments and n values, where\n-     * n is the total of number of values across all the supplied\n-     * {@link StringTemplate StringTemplates}.\n-     *\n-     * @param stringTemplates  list of {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if stringTemplates is null or if any of the\n-     * its elements are null\n-     *\n-     * @implNote If {@code stringTemplates.size() == 0} then a {@link StringTemplate} with\n-     * an empty fragment and no values is returned, as if invoking\n-     * <code>StringTemplate.of(\"\")<\/code> . If {@code stringTemplates.size() == 1}\n-     * then the first element of the list is returned unchanged.\n-     *\/\n-    static StringTemplate combine(List<StringTemplate> stringTemplates) {\n-        return TemplateSupport.combine(stringTemplates.toArray(new StringTemplate[0]));\n-    }\n-\n-    \/**\n-     * This {@link StringProcessor} instance is conventionally used for the string interpolation\n-     * of a supplied {@link StringTemplate}.\n-     * <p>\n-     * For better visibility and when practical, it is recommended that users use the\n-     * {@link StringTemplate#STR} processor instead of invoking the\n-     * {@link StringTemplate#interpolate()} method.\n-     * Example: {@snippet :\n-     * int x = 10;\n-     * int y = 20;\n-     * String result = STR.\"\\{x} + \\{y} = \\{x + y}\"; \/\/ @highlight substring=\"STR\"\n-     * }\n-     * In the above example, the value of {@code result} will be {@code \"10 + 20 = 30\"}. This is\n-     * produced by the interleaving concatenation of fragments and values from the supplied\n-     * {@link StringTemplate}. To accommodate concatenation, values are converted to strings\n-     * as if invoking {@link String#valueOf(Object)}.\n-     * @implNote {@link StringTemplate#STR} is statically imported implicitly into every\n-     * Java compilation unit.<p>The result of interpolation is not interned.\n-     *\/\n-    static final StringProcessor STR = StringTemplate::interpolate;\n-\n-    \/**\n-     * This {@link TemplateProcessor} instance is conventionally used to indicate that the\n-     * processing of the {@link StringTemplate} is to be deferred to a later time. Deferred\n-     * processing can be resumed by invoking the\n-     * {@link StringTemplate#process(ValidatingProcessor)} or\n-     * {@link ValidatingProcessor#process(StringTemplate)} methods.\n-     * {@snippet :\n-     * import static java.lang.template.StringTemplate.RAW;\n-     * ...\n-     * StringTemplate st = RAW.\"\\{x} + \\{y} = \\{x + y}\";\n-     * ...other steps...\n-     * String result = STR.process(st);\n-     * }\n-     * @implNote Unlike {@link StringTemplate#STR}, {@link StringTemplate#RAW} must be\n-     * statically imported explicitly.\n-     *\/\n-    static final TemplateProcessor<StringTemplate> RAW = st -> st;\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/StringTemplate.java","additions":0,"deletions":439,"binary":false,"changes":439,"status":"deleted"},{"patch":"@@ -1,70 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * This interface is used to implement template processors that do not throw checked\n- * exceptions. Any implementation must supply a\n- * {@link TemplateProcessor#process(StringTemplate)} method that constructs a result\n- * from the information provided by the supplied {@link StringTemplate} instance.\n- * <p>\n- * For example:\n- * {@snippet :\n- * TemplateProcessor<Integer> processor = st -> {\n- *     String interpolation = st.interpolate();\n- *     return Integer.valueOf(interpolation);\n- * };\n- * }\n- *\n- * @param <R>  Processor's process result type.\n- *\n- * @see java.lang.template.ValidatingProcessor\n- * @see java.lang.template.StringProcessor\n- * @see java.lang.template.StringTemplate\n- *\n- * @since 21\n- *\n- * @implNote It is recommended that {@link StringProcessor} be used instead of\n- * {@code TemplateProcessor<String>} when the result type is {@link String}.\n- *\n- * @jls 15.8.6 Process Template Expressions\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-@FunctionalInterface\n-public interface TemplateProcessor<R> extends ValidatingProcessor<R, RuntimeException> {\n-    \/**\n-     * Constructs a result based on the template fragments and values in the\n-     * supplied {@link StringTemplate stringTemplate} instance.\n-     *\n-     * @param stringTemplate  a {@link StringTemplate} instance\n-     *\n-     * @return constructed object of type R\n-     *\/\n-    @Override\n-    R process(StringTemplate stringTemplate);\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateProcessor.java","additions":0,"deletions":70,"binary":false,"changes":70,"status":"deleted"},{"patch":"@@ -1,160 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Objects;\n-\n-import jdk.internal.access.JavaLangAccess;\n-import jdk.internal.access.JavaTemplateAccess;\n-import jdk.internal.access.SharedSecrets;\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * This class provides runtime support for string templates. The methods within\n- * are intended for internal use only.\n- *\n- * @since 21\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-final class TemplateSupport {\n-\n-    \/**\n-     * Private constructor.\n-     *\/\n-    private TemplateSupport() {\n-        throw new AssertionError(\"private constructor\");\n-    }\n-\n-    static {\n-        SharedSecrets.setJavaTemplateAccess(new StringTemplateImplFactory());\n-    }\n-\n-    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n-    private static final JavaTemplateAccess JTA = SharedSecrets.getJavaTemplateAccess();\n-\n-    \/**\n-     * Returns a StringTemplate composed from fragments and values.\n-     *\n-     * @implSpec The {@code fragments} list size must be one more that the\n-     * {@code values} list size.\n-     *\n-     * @param fragments list of string fragments\n-     * @param values    list of expression values\n-     *\n-     * @return StringTemplate composed from fragments and values\n-     *\n-     * @throws IllegalArgumentException if fragments list size is not one more\n-     *         than values list size\n-     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n-     *\n-     * @implNote Contents of both lists are copied to construct immutable lists.\n-     *\/\n-    static StringTemplate of(List<String> fragments, List<?> values) {\n-        return JTA.newStringTemplate(fragments, values);\n-    }\n-\n-    \/**\n-     * Creates a string that interleaves the elements of values between the\n-     * elements of fragments.\n-     *\n-     * @param fragments  list of String fragments\n-     * @param values     list of expression values\n-     *\n-     * @return String interpolation of fragments and values\n-     *\/\n-    static String interpolate(List<String> fragments, List<?> values) {\n-        int fragmentsSize = fragments.size();\n-        int valuesSize = values.size();\n-        if (fragmentsSize == 1) {\n-            return fragments.get(0);\n-        }\n-        int size = fragmentsSize + valuesSize;\n-        String[] strings = new String[size];\n-        int i = 0, j = 0;\n-        for (; j < valuesSize; j++) {\n-            strings[i++] = fragments.get(j);\n-            strings[i++] = String.valueOf(values.get(j));\n-        }\n-        strings[i] = fragments.get(j);\n-        return JLA.join(\"\", \"\", \"\", strings, size);\n-    }\n-\n-    \/**\n-     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n-     * {@snippet :\n-     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n-     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n-     * }\n-     *\n-     * @param sts  zero or more {@link StringTemplate}\n-     *\n-     * @return combined {@link StringTemplate}\n-     *\n-     * @throws NullPointerException if sts is null or if any element of sts is null\n-     *\/\n-    static StringTemplate combine(StringTemplate... sts) {\n-        Objects.requireNonNull(sts, \"sts must not be null\");\n-        if (sts.length == 0) {\n-            return StringTemplate.of(\"\");\n-        } else if (sts.length == 1) {\n-            return Objects.requireNonNull(sts[0], \"string templates should not be null\");\n-        }\n-        int size = 0;\n-        for (StringTemplate st : sts) {\n-            Objects.requireNonNull(st, \"string templates should not be null\");\n-            size += st.values().size();\n-        }\n-        String[] combinedFragments = new String[size + 1];\n-        Object[] combinedValues = new Object[size];\n-        combinedFragments[0] = \"\";\n-        int fragmentIndex = 1;\n-        int valueIndex = 0;\n-        for (StringTemplate st : sts) {\n-            Iterator<String> iterator = st.fragments().iterator();\n-            combinedFragments[fragmentIndex - 1] += iterator.next();\n-            while (iterator.hasNext()) {\n-                combinedFragments[fragmentIndex++] = iterator.next();\n-            }\n-            for (Object value : st.values()) {\n-                combinedValues[valueIndex++] = value;\n-            }\n-        }\n-        return JTA.newStringTemplate(combinedFragments, combinedValues);\n-    }\n-\n-    \/**\n-     * Return the basic string interpolate process, and, initialize the SharedSecret.\n-     *\n-     * @return basic string interpolate process\n-     *\/\n-    static StringProcessor basicInterpolate() {\n-        SharedSecrets.setJavaTemplateAccess(new StringTemplateImplFactory());\n-        return StringTemplate::interpolate;\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/TemplateSupport.java","additions":0,"deletions":160,"binary":false,"changes":160,"status":"deleted"},{"patch":"@@ -1,161 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package java.lang.template;\n-\n-import java.util.function.Function;\n-\n-import jdk.internal.javac.PreviewFeature;\n-\n-\/**\n- * This interface describes the methods provided by a generalized string template processor. The\n- * primary method {@link ValidatingProcessor#process(StringTemplate)} is used to validate\n- * and compose a result using a {@link StringTemplate StringTemplate's} fragments and values lists.\n- *\n- * For example:\n- * {@snippet :\n- * class MyProcessor implements ValidatingProcessor<String, IllegalArgumentException> {\n- *     @Override\n- *     public String process(StringTemplate st) throws IllegalArgumentException {\n- *          StringBuilder sb = new StringBuilder();\n- *          Iterator<String> fragmentsIter = st.fragments().iterator();\n- *\n- *          for (Object value : st.values()) {\n- *              sb.append(fragmentsIter.next());\n- *\n- *              if (value instanceof Boolean) {\n- *                  throw new IllegalArgumentException(\"I don't like Booleans\");\n- *              }\n- *\n- *              sb.append(value);\n- *          }\n- *\n- *          sb.append(fragmentsIter.next());\n- *\n- *          return sb.toString();\n- *     }\n- * }\n- *\n- * MyProcessor myProcessor = new MyProcessor();\n- * try {\n- *     int x = 10;\n- *     int y = 20;\n- *     String result = myProcessor.\"\\{x} + \\{y} = \\{x + y}\";\n- *     ...\n- * } catch (IllegalArgumentException ex) {\n- *     ...\n- * }\n- * }\n- * Implementations of this interface may provide, but are not limited to, validating\n- * inputs, composing inputs into a result, and transforming an intermediate string\n- * result to a non-string value before delivering the final result.\n- * <p>\n- * The user has the option of validating inputs used in composition. For example an SQL\n- * processor could prevent injection vulnerabilities by sanitizing inputs or throwing an\n- * exception of type {@code E} if an SQL statement is a potential vulnerability.\n- * <p>\n- * Composing allows user control over how the result is assembled. Most often, a\n- * user will construct a new string from the string template, with placeholders\n- * replaced by string representations of value list elements. These string\n- * representations are created as if invoking {@link String#valueOf}.\n- * <p>\n- * Transforming allows the processor to return something other than a string. For\n- * instance, a JSON processor could return a JSON object, by parsing the string created\n- * by composition, instead of the composed string.\n- * <p>\n- * {@link ValidatingProcessor} is a {@link FunctionalInterface}. This permits\n- * declaration of a processor using lambda expressions;\n- * {@snippet :\n- * ValidatingProcessor<String, RuntimeException> processor = st -> {\n- *     List<String> fragments = st.fragments();\n- *     List<Object> values = st.values();\n- *     \/\/ check or manipulate the fragments and\/or values\n- *     ...\n- *     return StringTemplate.interpolate(fragments, values);\n- * };\n- * }\n- * The {@link FunctionalInterface} {@link TemplateProcessor} is supplied to avoid\n- * the use of checked exceptions;\n- * {@snippet :\n- * TemplateProcessor<String> processor = st -> {\n- *     List<String> fragments = st.fragments();\n- *     List<Object> values = st.values();\n- *     \/\/ check or manipulate the fragments and\/or values\n- *     ...\n- *     return StringTemplate.interpolate(fragments, values);\n- * };\n- * }\n- * The {@link FunctionalInterface} {@link StringProcessor} is supplied if\n- * the processor returns {@link String};\n- * {@snippet :\n- * StringProcessor processor = st -> {\n- *     List<String> fragments = st.fragments();\n- *     List<Object> values = st.values();\n- *     \/\/ check or manipulate the fragments and\/or values\n- *     ...\n- *     return StringTemplate.interpolate(fragments, values);\n- * };\n- * }\n- * The {@link StringTemplate#interpolate()} method is available for those processors\n- * that just need to work with the string interpolation;\n- * {@snippet :\n- * StringProcessor processor = StringTemplate::interpolate;\n- * }\n- * or simply transform the string interpolation into something other than\n- * {@link String};\n- * {@snippet :\n- * TemplateProcessor<JSONObject> jsonProcessor = st -> new JSONObject(st.interpolate());\n- * }\n- * @implNote The Java compiler automatically imports {@link StringTemplate#STR}\n- *\n- * @param <R>  Processor's process result type\n- * @param <E>  Exception thrown type\n- *\n- * @see java.lang.template.TemplateProcessor\n- * @see java.lang.template.StringProcessor\n- * @see java.lang.template.StringTemplate\n- * @see java.util.FormatProcessor\n- *\n- * @since 21\n- *\n- * @jls 15.8.6 Process Template Expressions\n- *\/\n-@PreviewFeature(feature=PreviewFeature.Feature.STRING_TEMPLATES)\n-@FunctionalInterface\n-public interface ValidatingProcessor<R, E extends Throwable> {\n-\n-    \/**\n-     * Constructs a result based on the template fragments and values in the\n-     * supplied {@link StringTemplate stringTemplate} object.\n-     *\n-     * @param stringTemplate  a {@link StringTemplate} instance\n-     *\n-     * @return constructed object of type R\n-     *\n-     * @throws E exception thrown by the template processor when validation fails\n-     *\/\n-    R process(StringTemplate stringTemplate) throws E;\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/ValidatingProcessor.java","additions":0,"deletions":161,"binary":false,"changes":161,"status":"deleted"},{"patch":"@@ -1,96 +0,0 @@\n-\/*\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * <em>String templates<\/em> and <em>template processors<\/em> provide a comprehensive\n- * system for combining literal text with the values from <em>embedded expressions<\/em>\n- * to produce a result. This result is often a {@link String} but is not limited to just\n- * {@link String Strings}.\n- * <p>\n- * Java string templates look like string literals or text blocks except they contain\n- * one or more embedded expressions bracketed by <code>\\{<\/code> and <code>}<\/code>.\n- * An embedded expression is usually positioned in the string where the value of that\n- * embedded expression might expect to be inserted.\n- * <p>\n- * <em>String interpolation<\/em> is the most general use of string templates. The\n- * standard {@link java.lang.template.StringTemplate#STR} template processor is statically\n- * imported into every Java compilation unit to facilitate the common use of string\n- * interpolation.\n- * {@snippet :\n- * int x = 10;\n- * int y = 20;\n- * String s = STR.\"The result of adding \\{x} and \\{y} is \\{x + y}.\";\n- * }\n- * The value {@code s} in the above example will be\n- * {@code \"The result of adding 10 and 20 is 30.\"}.\n- * <p>\n- * The expression {@code STR.\"The result of adding \\{x} and \\{y} is \\{x + y}.\"}\n- * above is an example of a <em>process template expression<\/em>. A process template\n- * expression consists of a <em>processor expression<\/em> and a <em>processor\n- * argument<\/em> separated by a dot (period). A processor expression evaluates\n- * to an instance of type {@link java.lang.template.ValidatingProcessor}. A\n- * processor argument is a string template that is represented by an instance of\n- * {@link java.lang.template.StringTemplate}. The end result of the process template\n- * expression is the value that is produced by invoking the processor's\n- * {@link java.lang.template.ValidatingProcessor#process(StringTemplate)}\n- * method of with the processor argument. Improper processor expressions or\n- * improper processor arguments result in compilation errors.\n- * <p>\n- * In the example above, {@code STR} is the processor that implements string\n- * interpolation with it\n- * {@link java.lang.template.ValidatingProcessor#process(StringTemplate)} method.\n- * <p>\n- * The string template in the example, represented by a\n- * {@link java.lang.template.StringTemplate}, contains the string fragments and\n- * embedded expression values expressed in\n- * {@code \"The result of adding \\{x} and \\{y} is \\{x + y}.\"}.\n- * In the example, the fragments are {@code \"The result of adding \"}, {@code \" and \"},\n- * {@code \" is \"} and {@code \".\"}. The values are {@code 10}, {@code 20} and {@code 30},\n- * which are the result of evaluating {@code x}, {@code y} and {@code x + y}.\n- * See {@link java.lang.template.StringTemplate} for examples and details.\n- * <p>\n- * String literals and text blocks can be used as proper processor arguments as\n- * well. This is automatically facilitated by the Java compiler converting the\n- * strings to {@link java.lang.template.StringTemplate StringTemplate} using the\n- * {@link java.lang.template.StringTemplate#of(String)} method.\n- * <p>\n- * Users can create their own template processors by implementing one of\n- * {@link java.lang.template.ValidatingProcessor},\n- * {@link java.lang.template.TemplateProcessor} or\n- * {@link java.lang.template.StringProcessor} interfaces.\n- * For more examples and details see {@link java.lang.template.StringTemplate} and\n- * {@link java.lang.template.ValidatingProcessor}.\n- *\n- * @see java.lang.template.StringTemplate\n- * @see java.lang.template.ValidatingProcessor\n- * @see java.lang.template.TemplateProcessor\n- *\n- * @see java.lang.template.StringTemplate\n- *\n- * @since 21\n- *\n- * @jls 15.8.6 Process Template Expressions\n- *\/\n-package java.lang.template;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/template\/package-info.java","additions":0,"deletions":96,"binary":false,"changes":96,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/util\/Digits.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,3 +31,2 @@\n-import java.lang.template.ProcessorLinkage;\n-import java.lang.template.StringProcessor;\n-import java.lang.template.StringTemplate;\n+import java.lang.StringTemplate.Processor.Linkage;\n+import java.lang.StringTemplate.StringProcessor;\n@@ -96,1 +95,1 @@\n- * @see java.lang.template.StringProcessor\n+ * @see StringProcessor\n@@ -99,1 +98,1 @@\n-public final class FormatProcessor implements StringProcessor, ProcessorLinkage {\n+public final class FormatProcessor implements StringProcessor, Linkage {\n@@ -172,1 +171,1 @@\n-     * of type {@link ProcessorLinkage} and fetched from a static constant as is\n+     * of type {@link Linkage} and fetched from a static constant as is\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":6,"deletions":7,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatterBuilder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import java.lang.template.StringTemplate;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import java.lang.template.StringTemplate;\n@@ -35,8 +34,18 @@\n-    \/\/ Create a new {@link StringTemplateImpl} constructor.\n-    \/\/\n-    \/\/ @param fragments  string template fragments\n-    \/\/ @param type       method type\n-    \/\/\n-    \/\/ @return {@link MethodHandle} that can construct a {@link StringTemplateImpl} with arguments\n-    \/\/ used as values.\n-    public MethodHandle createStringTemplateImplMH(List<String> fragments, MethodType type);\n+    \/**\n+     * Returns a StringTemplate composed from fragments and values.\n+     *\n+     * @implSpec The {@code fragments} list size must be one more that the\n+     * {@code values} list size.\n+     *\n+     * @param fragments list of string fragments\n+     * @param values    list of expression values\n+     *\n+     * @return StringTemplate composed from fragments and values\n+     *\n+     * @throws IllegalArgumentException if fragments list size is not one more\n+     *         than values list size\n+     * @throws NullPointerException if fragments is null or values is null or if any fragment is null.\n+     *\n+     * @implNote Contents of both lists are copied to construct immutable lists.\n+     *\/\n+    StringTemplate of(List<String> fragments, List<?> values);\n@@ -44,7 +53,10 @@\n-    \/\/ Returns a new StringTemplate composed from fragments and values.\n-    \/\/\n-    \/\/ @param fragments array of string fragments\n-    \/\/ @param values    array of expression values\n-    \/\/\n-    \/\/ @return StringTemplate composed from fragments and values\n-    public StringTemplate newStringTemplate(String[] fragments, Object[] values);\n+    \/**\n+     * Creates a string that interleaves the elements of values between the\n+     * elements of fragments.\n+     *\n+     * @param fragments  list of String fragments\n+     * @param values     list of expression values\n+     *\n+     * @return String interpolation of fragments and values\n+     *\/\n+    String interpolate(List<String> fragments, List<?> values);\n@@ -52,7 +64,14 @@\n-    \/\/ Returns a new StringTemplate composed from fragments and values.\n-    \/\/\n-    \/\/ @param fragments list of string fragments\n-    \/\/ @param values    array of expression values\n-    \/\/\n-    \/\/ @return StringTemplate composed from fragments and values\n-    public StringTemplate newStringTemplate(List<String> fragments, Object[] values);\n+    \/**\n+     * Combine one or more {@link StringTemplate StringTemplates} to produce a combined {@link StringTemplate}.\n+     * {@snippet :\n+     * StringTemplate st = StringTemplate.combine(\"\\{a}\", \"\\{b}\", \"\\{c}\");\n+     * assert st.interpolate().equals(\"\\{a}\\{b}\\{c}\");\n+     * }\n+     *\n+     * @param sts  zero or more {@link StringTemplate}\n+     *\n+     * @return combined {@link StringTemplate}\n+     *\n+     * @throws NullPointerException if sts is null or if any element of sts is null\n+     *\/\n+    StringTemplate combine(StringTemplate... sts);\n@@ -60,7 +79,0 @@\n-    \/\/ Returns a new StringTemplate composed from fragments and values.\n-    \/\/\n-    \/\/ @param fragments list of string fragments\n-    \/\/ @param values    list of expression values\n-    \/\/\n-    \/\/ @return StringTemplate composed from fragments and values\n-    public StringTemplate newStringTemplate(List<String> fragments, List<?> values);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaTemplateAccess.java","additions":43,"deletions":31,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import java.lang.template.StringTemplate;\n@@ -529,1 +528,1 @@\n-                Class.forName(\"java.lang.template.TemplateSupport\", true, null);\n+                Class.forName(\"java.lang.runtime.TemplateSupport\", true, null);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/FormatConcatItem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,1 +89,0 @@\n-    exports java.lang.template;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/ClassTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/source\/tree\/StringTemplateTree.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -241,2 +241,2 @@\n-    public final Type validatingProcessorType;\n-    public final Type processorLinkage;\n+    public final Type processorType;\n+    public final Type linkageType;\n@@ -631,1 +631,1 @@\n-        stringTemplateType = enterClass(\"java.lang.template.StringTemplate\");\n+        stringTemplateType = enterClass(\"java.lang.StringTemplate\");\n@@ -633,2 +633,2 @@\n-        validatingProcessorType = enterClass(\"java.lang.template.ValidatingProcessor\");\n-        processorLinkage = enterClass(\"java.lang.template.ProcessorLinkage\");\n+        processorType = enterClass(\"java.lang.StringTemplate$Processor\");\n+        linkageType = enterClass(\"java.lang.StringTemplate$Processor$Linkage\");\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Symtab.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -4319,1 +4319,1 @@\n-        Type interfaceType = types.asSuper(processorType, syms.validatingProcessorType.tsym);\n+        Type interfaceType = types.asSuper(processorType, syms.processorType.tsym);\n@@ -4328,1 +4328,1 @@\n-                        Errors.TemplateProcessorTypeCannotBeARawType(processorType.tsym));\n+                        Errors.ProcessorTypeCannotBeARawType(processorType.tsym));\n@@ -4332,1 +4332,1 @@\n-                    Errors.NotTemplateProcessorType(processorType.tsym));\n+                    Errors.NotAProcessorType(processorType.tsym));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Check.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1535,1 +1535,1 @@\n-                Type interfaceType = types.asSuper(processor.type, syms.validatingProcessorType.tsym);\n+                Type interfaceType = types.asSuper(processor.type, syms.processorType.tsym);\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Flow.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -196,1 +196,1 @@\n-            JCFieldAccess qualifier = make.Select(make.Type(syms.validatingProcessorType), dynSym.name);\n+            JCFieldAccess qualifier = make.Select(make.Type(syms.processorType), dynSym.name);\n@@ -206,1 +206,1 @@\n-                    syms.validatingProcessorType, List.of(syms.stringTemplateType));\n+                    syms.processorType, List.of(syms.stringTemplateType));\n@@ -270,1 +270,1 @@\n-                   types.isSubtype(processor.type, syms.processorLinkage) &&\n+                   types.isSubtype(processor.type, syms.linkageType) &&\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TransLiterals.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -350,1 +350,1 @@\n-                            import static java.lang.template.StringTemplate.STR;\n+                            import static java.lang.StringTemplate.STR;\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/TypeEnter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavaTokenizer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Lexer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Scanner.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/Tokens.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/UnicodeReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1322,2 +1322,2 @@\n-compiler.err.template.processor.type.cannot.be.a.raw.type=\\\n-    template processor type cannot be a raw type: {0}\n+compiler.err.processor.type.cannot.be.a.raw.type=\\\n+    processor type cannot be a raw type: {0}\n@@ -1326,2 +1326,2 @@\n-compiler.err.not.template.processor.type=\\\n-    not a template processor type: {0}\n+compiler.err.not.a.processor.type=\\\n+    not a processor type: {0}\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/String\/concat\/MakeConcatWithTemplate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/java.lang.template\n+ * @modules java.base\/java.lang.runtime\n@@ -30,1 +30,1 @@\n- * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.template.CarriersTest\n+ * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.runtime.CarriersTest\n@@ -33,1 +33,1 @@\n-package java.lang.template;\n+package java.lang.runtime;\n","filename":"test\/jdk\/java\/lang\/runtime\/CarriersTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/lang\/template\/CarriersTest.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @modules java.base\/java.lang.template\n+ * @modules java.base\/java.lang.runtime\n@@ -30,1 +30,1 @@\n- * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.template.ReferencedKeyTest\n+ * @run main\/othervm --patch-module java.base=${test.class.path} java.lang.runtime.ReferencedKeyTest\n@@ -33,1 +33,1 @@\n-package java.lang.template;\n+package java.lang.runtime;\n","filename":"test\/jdk\/java\/lang\/runtime\/ReferencedKeyTest.java","additions":4,"deletions":4,"binary":false,"changes":8,"previous_filename":"test\/jdk\/java\/lang\/template\/ReferencedKeyTest.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.lang.template.*;\n+import java.lang.StringTemplate.*;\n@@ -36,1 +36,1 @@\n-import static java.lang.template.StringTemplate.RAW;\n+import static java.lang.StringTemplate.RAW;\n@@ -46,1 +46,1 @@\n-        templateProcessorCoverage();\n+        simpleProcessorCoverage();\n@@ -378,1 +378,1 @@\n-    public static final TemplateProcessor<StringTemplate> STRINGIFY = st -> {\n+    public static final SimpleProcessor<StringTemplate> STRINGIFY = st -> {\n@@ -387,1 +387,1 @@\n-    public static final TemplateProcessor<StringTemplate> UPPER = st -> {\n+    public static final SimpleProcessor<StringTemplate> UPPER = st -> {\n@@ -433,1 +433,1 @@\n-     * TemplateProcessor coverage.\n+     * SimpleProcessor coverage.\n@@ -436,1 +436,1 @@\n-    static class Processor0 implements ValidatingProcessor<String, IllegalArgumentException> {\n+    static class Processor0 implements Processor<String, IllegalArgumentException> {\n@@ -460,1 +460,1 @@\n-    static ValidatingProcessor<String, RuntimeException> processor1 =\n+    static Processor<String, RuntimeException> processor1 =\n@@ -463,1 +463,1 @@\n-    static TemplateProcessor<String> processor2 = st -> st.interpolate();\n+    static SimpleProcessor<String> processor2 = st -> st.interpolate();\n@@ -471,1 +471,1 @@\n-    static void templateProcessorCoverage() {\n+    static void simpleProcessorCoverage() {\n","filename":"test\/jdk\/java\/lang\/template\/Basic.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,2 @@\n-import java.lang.template.StringTemplate;\n-import java.lang.template.StringProcessor;\n+import java.lang.StringTemplate;\n+import java.lang.StringTemplate.StringProcessor;\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/java\/lang\/template\/StringTemplateTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplate.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNoProcessor.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- \/\/ key: compiler.err.not.template.processor.type\n+ \/\/ key: compiler.err.not.a.processor.type\n@@ -29,1 +29,1 @@\n-import java.lang.template.*;\n+import java.lang.*;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateNotProcessor.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,3 @@\n- \/\/ key: compiler.err.template.processor.type.cannot.be.a.raw.type\n+ \/\/ key: compiler.err.cant.resolve.location\n+ \/\/ key: compiler.err.processor.type.cannot.be.a.raw.type\n+ \/\/ key: compiler.misc.location\n@@ -31,1 +33,1 @@\n-import java.lang.template.*;\n+import java.lang.*;\n@@ -35,1 +37,1 @@\n-        TemplateProcessor processor = ts -> ts.interpolate();\n+        SimpleProcessor processor = ts -> ts.interpolate();\n@@ -44,0 +46,1 @@\n+\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateRawProcessor.java","additions":7,"deletions":4,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-import java.lang.template.*;\n+import java.lang.*;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedString.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,1 @@\n-import java.lang.template.*;\n+import java.lang.*;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StringTemplateUnclosedTextBlock.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -188,1 +188,1 @@\n-            import java.lang.template.*;\n+            import java.lang.*;\n@@ -190,1 +190,1 @@\n-            import static java.lang.template.StringTemplate.RAW;\n+            import static java.lang.StringTemplate.RAW;\n@@ -217,1 +217,1 @@\n-            import java.lang.template.*;\n+            import java.lang.*;\n@@ -219,1 +219,1 @@\n-            import static java.lang.template.StringTemplate.RAW;\n+            import static java.lang.StringTemplate.RAW;\n","filename":"test\/langtools\/tools\/javac\/template\/Basic.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/langtools\/tools\/javac\/template\/TreeScannerTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,1 @@\n-package org.openjdk.bench.java.lang.template;\n+package org.openjdk.bench.java.lang;\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringTemplateFMT.java","additions":2,"deletions":2,"binary":false,"changes":4,"previous_filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/template\/StringTemplateFMT.java","status":"renamed"}]}