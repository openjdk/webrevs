{"files":[{"patch":"@@ -251,1 +251,1 @@\n-        \/\/ThreadReference   mainThread = debuggee.threadByNameOrThrow(\"main\");\n+        ThreadReference   mainThread = debuggee.threadByNameOrThrow(\"main\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/EventRequestManager\/accessWatchpointRequests\/accwtchpreq002.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,786 +0,0 @@\n-\/*\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package nsk.share.jpda;\n-\n-import nsk.share.*;\n-\n-import java.io.*;\n-import java.net.ServerSocket;\n-\n-\/**\n- * Parser for JPDA test's launching and connection arguments.\n- * <p>\n- * <Code>DebugeeArgumentHandler<\/code> handles specific JDI\/JDWP\/JDB tests\n- * command line arguments related to launching and connection parameters\n- * for debugee VM in addition to general arguments recognized by\n- * <code>ArgumentParser<\/code>.\n- * <p>\n- * Following is the list of specific options for\n- * <code>DebugeeAgrumentHandler<\/code>:\n- * <ul>\n- * <li> <code>-includevirtualthreads<\/code> -\n- *   launch debug agent with <code>includevirtualthreads=<\/code>\n- * <li> <code>-test.host=<\/code>&lt;<i>host<\/i>&gt; -\n- *   address of a host where test executes\n- * <li> <code>-debugee.host=<\/code>&lt;<i>host<\/i>&gt; -\n- *   address of a host where debugee VM executes\n- * <li> <code>-connector=[attaching|listening]<\/code> -\n- *   connector type to connect to debugee VM\n- * <li> <code>-transport=[socket|shmem]<\/code> -\n- *   transport type to connect to debugee VM\n- * <li> <code>-transport.port=<\/code>&lt;<i>port<\/i>&gt; -\n- *   port number for <code>socket<\/code> transport\n- * <li> <code>-transport.shname=<\/code>&lt;<i>name<\/i>&gt; -\n- *   shared memory name for <code>shmem<\/code> transport\n- * <li> <code>-transport.address=<\/code>&lt;<i>dynamic<\/i>&gt; -\n- *   use dynamically allocated unique transport address for JDWP connection\n- *   ignoring settings for <code>-transport.port<\/code> and <code>-transport.shname<\/code>\n- *   (this works only with <code>-connector=listening<\/code> and <code>-transport=socket<\/code>)\n- * <li> <code>-debugee.suspend=[yes|no|default]<\/code> -\n- *   should debugee start in suspend mode or not\n- * <li> <code>-debugee.vmhome=<\/code>&lt;<i>path<\/i>&gt; -\n- *   path to JDK used for launching debugee VM\n- * <li> <code>-debugee.vmkind=<\/code>&lt;<i>name<\/i>&gt; -\n- *   name of debugee VM launcher executable\n- * <li> <code>-debugee.vmkeys=<\/code>&lt;<i>string<\/i>&gt; -\n- *   additional options for launching debugee VM\n- * <li> <code>-jvmdi.strict=[yes|no|default]<\/code> -\n- *   using JVMDI strict mode\n- * <li> <code>-pipe.port=<\/code>&lt;<i>port<\/i>&gt; -\n- *   port number for internal IOPipe connection\n- * <li> <code>-bind.port=<\/code>&lt;<i>port<\/i>&gt; -\n- *   port number for BindServer connection\n- * <\/ul>\n- * <p>\n- * See also list of basic options recognized by\n- * <code>ArgumentParser<\/code>.\n- * <p>\n- * See also comments to <code>ArgumentParser<\/code> for list of general\n- * recognized options and how to work with command line arguments and options.\n- *\n- * @see ArgumentParser\n- * @see nsk.share.jdi.ArgumentHandler\n- * @see nsk.share.jdwp.ArgumentHandler\n- *\/\n-public class DebugeeArgumentHandler extends ArgumentParser {\n-\n-    public static final String DEFAULT_PIPE_PORT      = \"7123\";\n-    public static final String DEFAULT_TRANSPORT_PORT = \"8123\";\n-    public static final String DEFAULT_BIND_PORT      = \"9123\";\n-\n-\n-    \/**\n-     * Keep a copy of raw command-line arguments and parse them;\n-     * but throw an exception on parsing error.\n-     *\n-     * @param  args  Array of the raw command-line arguments.\n-     *\n-     * @throws  BadOption  If unknown option or illegal\n-     *                     option value found\n-     *\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public DebugeeArgumentHandler(String args[]) {\n-        super(args);\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if <code>-includevirtualthreads<\/code> command line option\n-     * is specified.\n-     *\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public boolean isIncludeVirtualThreads() {\n-        return options.getProperty(\"includevirtualthreads\") != null;\n-    }\n-\n-    \/**\n-     * Return name of the host where test executes, specified by\n-     * <code>-test.host<\/code> command line option or\n-     * empty string (represents an address of the loopback interface) by default.\n-     *\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getTestHost() {\n-        return options.getProperty(\"test.host\", \"\");\n-    }\n-\n-    \/**\n-     * Return name of host where the debugee VM is executed, specified by\n-     * <code>-debugee.host<\/code> command line option or value of\n-     * getTestHost() by default.\n-     *\n-     * @see #getTestHost()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getDebugeeHost() {\n-        return options.getProperty(\"debugee.host\", getTestHost());\n-    }\n-\n-    private boolean transportPortInited = false;\n-    \/**\n-     * Return string representation of port number for socket transport,\n-     * specified by <code>-tranport.port<\/code> command line option or\n-     * \"<code>DEFAULT_TRANSPORT_PORT<\/code>\" string by default.\n-     *\n-     * @see #getTransportPortIfNotDynamic()\n-     * @see #getTransportPortNumber()\n-     * @see #setTransportPortNumber(int)\n-     * @see #setRawArguments(String[])\n-     *\/\n-    synchronized public String getTransportPort() {\n-        String port = options.getProperty(\"transport.port\");\n-        if (port == null) {\n-            if (!transportPortInited) {\n-                port = findFreePort();\n-                if (port == null) {\n-                    port = DEFAULT_TRANSPORT_PORT;\n-                }\n-                options.setProperty(\"transport.port\", port);\n-                transportPortInited = true;\n-            }\n-        }\n-        return port;\n-    }\n-\n-    \/**\n-     * Return string representation of port number for socket transport,\n-     * specified by <code>-tranport.port<\/code> command line option or\n-     * \"<code>DEFAULT_TRANSPORT_PORT<\/code>\" string by default in case transport address is\n-     * not dynamic.\n-     * Otherwise null is returned.\n-     *\n-     * @see #getTransportPort()\n-     * @see #getTransportPortNumber()\n-     * @see #setTransportPortNumber(int)\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getTransportPortIfNotDynamic() {\n-        return ( isTransportAddressDynamic() ?\n-                    null : getTransportPort() );\n-    }\n-\n-    \/**\n-     * Return string port number for socket transport,\n-     * specified by <code>-debugee.port<\/code> command line option or\n-     * <code>DEFAULT_TRANSPORT_PORT<\/code> port number by default.\n-     *\n-     * @see #getTransportPort()\n-     * @see #getTransportPortIfNotDynamic()\n-     * @see #setTransportPortNumber(int)\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public int getTransportPortNumber() {\n-        String value = getTransportPort();\n-        try {\n-            return Integer.parseInt(value);\n-        } catch (NumberFormatException e) {\n-            throw new TestBug(\"Not integer value of \\\"-transport.port\\\" argument: \" + value);\n-        }\n-    }\n-\n-    \/**\n-     * Add or replace value of option <code>-transport.port<\/code> in options list\n-     * with the specified port number.\n-     *\n-     * @see #getTransportPortNumber()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public void setTransportPortNumber(int port) {\n-        String value = Integer.toString(port);\n-        setOption(\"-\", \"transport.port\", value);\n-    }\n-\n-    \/**\n-     * Return shared name for shmem transport, specified by\n-     * <code>-transport.shname<\/code> command line option, or\n-     * \"<i>nskjpdatestchannel<\/i>\" + a process unique string by default.\n-     *\n-     * @see #setTransportSharedName(String)\n-     * @see #setRawArguments(String[])\n-     *\/\n-    \/\/ Use a unique id for this process by default. This makes sure that\n-    \/\/ tests running concurrently do not use the same shared name.\n-    private static String defaultTransportSharedName\n-            = \"nskjpdatestchannel\" + ProcessHandle.current().pid();\n-    public String getTransportSharedName() {\n-        return options.getProperty(\"transport.shname\", defaultTransportSharedName);\n-    }\n-\n-    \/**\n-     * Add or replace value of option <code>-transport.shname<\/code> in options list\n-     * with the specified name.\n-     *\n-     * @see #getTransportSharedName()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public void setTransportSharedName(String name) {\n-        setOption(\"-\", \"transport.shname\", name);\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if <code>-transport.address=dynamic<\/code> command line option\n-     * is specified.\n-     *\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public boolean isTransportAddressDynamic() {\n-        String value = options.getProperty(\"transport.address\", null);\n-        if (value != null && value.equals(\"dynamic\"))\n-            return true;\n-        return false;\n-    }\n-\n-    \/**\n-     * Return suspend mode for launching debugee VM, specified by\n-     * <code>-debugee.suspend<\/code> command line option, or\n-     * \"<i>default<\/i>\" string by default.\n-     *\n-     * @see #isDefaultDebugeeSuspendMode()\n-     * @see #willDebugeeSuspended()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getDebugeeSuspendMode() {\n-        return options.getProperty(\"debugee.suspend\", \"default\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if default suspend mode is used\n-     * for launching debugee VM.\n-     *\n-     * @see #getDebugeeSuspendMode()\n-     * @see #willDebugeeSuspended()\n-     *\/\n-    public boolean isDefaultDebugeeSuspendMode() {\n-        String mode = getDebugeeSuspendMode();\n-        return mode.equals(\"default\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if debugee VM will be suspended after launching,\n-     * either according to specified suspend mode or by default.\n-     *\n-     * @see #getDebugeeSuspendMode()\n-     * @see #isDefaultDebugeeSuspendMode()\n-     *\/\n-    public boolean willDebugeeSuspended() {\n-        String mode = getDebugeeSuspendMode();\n-        return mode.equals(\"no\");\n-    }\n-\n-    private boolean pipePortInited = false;\n-    \/**\n-     * Return string representation of the port number for IOPipe connection,\n-     * specified by <code>-pipe.port<\/code> command line option, or\n-     * \"<i>DEFAULT_PIPE_PORT<\/i>\" string by default.\n-     *\n-     * @see #getPipePortNumber()\n-     * @see #setPipePortNumber(int)\n-     * @see #setRawArguments(String[])\n-     *\/\n-    synchronized public String getPipePort() {\n-        String port = options.getProperty(\"pipe.port\");\n-        if (port == null) {\n-            if (!pipePortInited) {\n-                port = findFreePort();\n-                if (port == null) {\n-                    port = DEFAULT_PIPE_PORT;\n-                }\n-                pipePortInited = true;\n-                options.setProperty(\"pipe.port\", port);\n-            }\n-        }\n-        return port;\n-    }\n-\n-    \/**\n-     * Return port number for IOPipe connection,\n-     * specified by <code>-pipe.port<\/code> command line option, or\n-     * <i>DEFAULT_PIPE_PORT<\/i> port number by default.\n-     *\n-     * @see #getPipePort()\n-     * @see #setPipePortNumber(int)\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public int getPipePortNumber() {\n-        String value = getPipePort();\n-        try {\n-            return Integer.parseInt(value);\n-        } catch (NumberFormatException e) {\n-            throw new TestBug(\"Not integer value of \\\"-pipe.port\\\" argument: \" + value);\n-        }\n-    }\n-\n-    \/**\n-     * Add or replace value of option <code>-pipe.port<\/code> in options list\n-     * with the specified port number.\n-     *\n-     * @see #getPipePortNumber()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public void setPipePortNumber(int port) {\n-        String value = Integer.toString(port);\n-        setOption(\"-\", \"pipe.port\", value);\n-    }\n-\n-\n-    \/**\n-     * Return additional options for launching debugee VM, specified by\n-     * <code>-launch.options<\/code> command line option, or\n-     * empty string by default.\n-     *\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getLaunchOptions() {\n-        String result = options.getProperty(\"debugee.vmkeys\", \"\").trim();\n-        if (result.startsWith(\"\\\"\") && result.endsWith(\"\\\"\")) {\n-            result = result.substring(1, result.length() - 1);\n-        }\n-        return result;\n-    }\n-\n-    \/**\n-     * Return name of debugee VM launcher executable, specified by\n-     * <code>-launch.vmexec<\/code> command line option, or\n-     * \"<i>java<\/i>\" string by default.\n-     *\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getLaunchExecName() {\n-        return options.getProperty(\"debugee.vmkind\", \"java\");\n-    }\n-\n-    \/**\n-     * Return full path to debugee VM launcher executable.\n-     *\n-     * @see #getLaunchExecName()\n-     * @see #getLaunchExecPath(String)\n-     * @see #getDebugeeJavaHome()\n-     *\/\n-    public String getLaunchExecPath() {\n-        String java_home = getDebugeeJavaHome();\n-        return getLaunchExecPath(java_home);\n-    }\n-\n-    \/**\n-     * Return full path to VM launcher executable using givet JAVA_HOME path.\n-     *\n-     * @see #getLaunchExecName()\n-     *\/\n-    public String getLaunchExecPath(String java_home) {\n-        String filesep = System.getProperty(\"file.separator\");\n-        return java_home + filesep + \"bin\" + filesep + getLaunchExecName();\n-    }\n-\n-    \/**\n-     * Return full JAVA_HOME path for debugee VM.\n-     *\n-     * @see #getLaunchExecName()\n-     *\/\n-    public String getDebugeeJavaHome() {\n-        String java_home = System.getProperty(\"java.home\");\n-        return options.getProperty(\"debugee.vmhome\", java_home);\n-    }\n-\n-    \/**\n-     * Return true if default debuggee VM launcher executable is used.\n-     *\n-     * @see #getLaunchExecName()\n-     *\/\n-    public boolean isDefaultLaunchExecName() {\n-        String vmkind = options.getProperty(\"debugee.vmkind\", null);\n-        return (vmkind == null);\n-    }\n-\n-    \/**\n-     * Return true if default JAVA_HOME path for debuggee VM is used.\n-     *\n-     * @see #getDebugeeJavaHome()\n-     *\/\n-    public boolean isDefaultDebugeeJavaHome() {\n-        String java_home = options.getProperty(\"debugee.vmhome\", null);\n-        return (java_home == null);\n-    }\n-\n-    private boolean bindPortInited = false;\n-    \/**\n-     * Return string representation of the port number for BindServer connection,\n-     * specified by <code>-bind.port<\/code> command line option, or\n-     * \"<i>DEFAULT_BIND_PORT<\/i>\" string by default.\n-     *\n-     * @see #getBindPortNumber()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getBindPort() {\n-        String port = options.getProperty(\"bind.port\");\n-        if (port == null) {\n-            if (!bindPortInited) {\n-                port = findFreePort();\n-                if (port == null) {\n-                    port = DEFAULT_BIND_PORT;\n-                }\n-                options.setProperty(\"bind.port\", port);\n-                bindPortInited = true;\n-            }\n-        }\n-        return port;\n-    }\n-\n-    \/**\n-     * Return port number for BindServer connection,\n-     * specified by <code>-bind.port<\/code> command line option, or\n-     * \"<i>DEFAULT_BIND_PORT<\/i>\" port number by default.\n-     *\n-     * @see #getBindPort()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public int getBindPortNumber() {\n-        String value = getBindPort();\n-        try {\n-            return Integer.parseInt(value);\n-        } catch (NumberFormatException e) {\n-            throw new TestBug(\"Not integer value of \\\"bind.port\\\" argument: \" + value);\n-        }\n-    }\n-\n-    \/**\n-     * Return JVMDI strict mode for launching debugee VM, specified by.\n-     * <code>-jvmdi.strict<\/code> command line option, or\n-     * \"<i>default<\/i>\" string by default.\n-     *\n-     * Possible values for this option are:\n-     * <ul>\n-     * <li> \"<code>yes<\/code>\"\n-     * <li> \"<code>no<\/code>\"\n-     * <li> \"<code>default<\/code>\"\n-     * <\/ul>\n-     *\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getJVMDIStrictMode() {\n-        return options.getProperty(\"jvmdi.strict\", \"default\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if JVMDI strict mode for launching debugeeVM is used\n-     * either by specifying in command line or by default.\n-     *\n-     * @see #getJVMDIStrictMode()\n-     * @see #isDefaultJVMDIStrictMode()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public boolean isJVMDIStrictMode() {\n-        String mode = getJVMDIStrictMode();\n-        return mode.equals(\"yes\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if JVMDI default strict mode for launching debugee VM is used.\n-     *\n-     * @see #getJVMDIStrictMode()\n-     * @see #isJVMDIStrictMode()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public boolean isDefaultJVMDIStrictMode() {\n-        String mode = getJVMDIStrictMode();\n-        return mode.equals(\"default\");\n-    }\n-\n-    \/**\n-     * Return type of JDI connector used for connecting to debugee VM, specified by\n-     * <code>-connector<\/code> command line option, or\n-     * \"<i>listening<\/i>\" string by default.\n-     *\n-     * Possible values for this option are:\n-     * <ul>\n-     * <li> \"<code>attaching<\/code>\"\n-     * <li> \"<code>listening<\/code>\"\n-     * <\/ul>\n-     *\n-     * @see #isAttachingConnector()\n-     * @see #isListeningConnector()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getConnectorType() {\n-        return options.getProperty(\"connector\", \"listening\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if type of the used JDI connector is <code>attaching<\/code>.\n-     *\n-     * @see #getConnectorType()\n-     *\/\n-    public boolean isAttachingConnector() {\n-        return getConnectorType().equals(\"attaching\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if type of the used JDI connector is <code>listening<\/code>.\n-     *\n-     * @see #getConnectorType()\n-     *\/\n-    public boolean isListeningConnector() {\n-        return getConnectorType().equals(\"listening\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if connector type is not actually specified.\n-     * In this case getConnectorType() returns some default connector type.\n-     *\n-     * @see #getConnectorType()\n-     *\/\n-    public boolean isDefaultConnector() {\n-        return options.getProperty(\"connector\") == null;\n-    }\n-\n-    \/**\n-     * Return type of JDWP transport for connecting to debugee VM, specified by\n-     * <code>-transport<\/code> command line option, or\n-     * \"<i>socket<\/i>\" string by default.\n-     *\n-     * Possible values for this option are:\n-     * <ul>\n-     * <li> \"<code>socket<\/code>\"\n-     * <li> \"<code>shmem<\/code>\"\n-     * <\/ul>\n-     *\n-     * @see #getTransportName()\n-     * @see #isSocketTransport()\n-     * @see #isShmemTransport()\n-     * @see #setRawArguments(String[])\n-     *\/\n-    public String getTransportType() {\n-        return options.getProperty(\"transport\", \"socket\");\n-    }\n-\n-    \/**\n-     * Return transport name corresponding to the used JDWP transport type.\n-     *\n-     * @see #getTransportType()\n-     *\/\n-    public String getTransportName() {\n-        if (isSocketTransport()) {\n-            return \"dt_socket\";\n-        } else if (isShmemTransport()) {\n-            return \"dt_shmem\";\n-        } else {\n-            throw new TestBug(\"Undefined transport type\");\n-        }\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if the used JDWP transport type is <code>socket<\/code>,\n-     * either by specifying in command line or as a platform default transport.\n-     *\n-     * @see #getTransportType()\n-     *\/\n-    public boolean isSocketTransport() {\n-        String transport = getTransportType();\n-        return transport.equals(\"socket\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if the used JDWP transport type is <code>shmem<\/code>,\n-     * either by specifying in command line or as a platform default transport.\n-     *\n-     * @see #getTransportType()\n-     *\/\n-    public boolean isShmemTransport() {\n-        String transport = getTransportType();\n-        return transport.equals(\"shmem\");\n-    }\n-\n-    \/**\n-     * Return <i>true<\/i> if transport type is not actually specified.\n-     * In this case getTransportType() returns some default transport kind.\n-     *\n-     * @see #getTransportType()\n-     *\/\n-    public boolean isDefaultTransport() {\n-        return options.getProperty(\"transport\") == null;\n-    }\n-\n-    \/**\n-     * Create <code>Log<\/code> for debugee application using command line options.\n-     *\/\n-    public Log createDebugeeLog() {\n-        return new Log(System.err, this);\n-    };\n-\n-    \/**\n-     * Create IOPipe for debugee application using command line options.\n-     *\/\n-    public IOPipe createDebugeeIOPipe() {\n-        return createDebugeeIOPipe(createDebugeeLog());\n-    };\n-\n-    \/**\n-     * Create IOPipe for debugee application using connection\n-     * parameters from the command line and specify Log.\n-     *\/\n-    public IOPipe createDebugeeIOPipe(Log log) {\n-        return new IOPipe(this, log);\n-    };\n-\n-    \/**\n-     * Check if an option is aloowed and has proper value.\n-     * This method is invoked by <code>parseArgumentss()<\/code>\n-     *\n-     * @param option option name\n-     * @param value string representation of value\n-     *                      (could be an empty string too)\n-     *              null if this option has no value\n-     * @return <i>true<\/i> if option is allowed and has proper value\n-     *         <i>false<\/i> if otion is not admissible\n-     *\n-     * @throws <i>BadOption<\/i> if option has an illegal value\n-     *\n-     * @see #parseArguments()\n-     *\/\n-    protected boolean checkOption(String option, String value) {\n-\n-        if (option.equals(\"traceAll\")\n-            || option.equals(\"includevirtualthreads\")) {\n-            if (!(value == null || value.length() == 0)) {\n-                throw new BadOption(option + \": no value must be specified\");\n-            }\n-           return true;\n-        }\n-\n-        \/\/ option with any string value\n-        if (option.equals(\"debugee.vmkeys\")) {\n-            return true;\n-        }\n-\n-        \/\/ option with any nonempty string value\n-        if (option.equals(\"debugee.vmkind\")\n-            || option.equals(\"debugee.vmhome\")\n-            || option.equals(\"transport.shname\")) {\n-            if (value.length() <= 0) {\n-                throw new BadOption(option + \": cannot be an empty string\");\n-            }\n-            return true;\n-        }\n-\n-        \/\/ option with positive integer port value\n-        if (option.equals(\"transport.port\")\n-            || option.equals(\"bind.port\")\n-            || option.equals(\"pipe.port\")) {\n-            try {\n-                int number = Integer.parseInt(value);\n-                if (number < 0) {\n-                    throw new BadOption(option + \": must be a positive integer\");\n-                }\n-            } catch (NumberFormatException e) {\n-                throw new BadOption(option + \": must be an integer\");\n-            }\n-            return true;\n-        }\n-\n-        \/\/ options with enumerated values\n-\n-        if (option.equals(\"debugee.suspend\")) {\n-            if ((!value.equals(\"yes\"))\n-                && (!value.equals(\"no\"))\n-                && (!value.equals(\"default\"))) {\n-                throw new BadOption(option + \": must be one of: \"\n-                                           + \"yes, no, default\");\n-            }\n-            return true;\n-        }\n-\n-        if (option.equals(\"debugee.launch\")\n-                || option.equals(\"debugee.host\")\n-                || option.equals(\"test.host\")) {\n-            throw new RuntimeException(\"option \" + option + \" is not supported.\");\n-        }\n-\n-        if (option.equals(\"jvmdi.strict\")) {\n-            if ((!value.equals(\"yes\"))\n-                && (!value.equals(\"no\"))\n-                && (!value.equals(\"default\"))) {\n-                throw new BadOption(option + \": must be one of: \"\n-                                           + \"yes, no, default\");\n-            }\n-            return true;\n-        }\n-\n-        if (option.equals(\"transport\")) {\n-            if ((!value.equals(\"socket\"))\n-                && (!value.equals(\"shmem\"))) {\n-                throw new BadOption(option + \": must be one of: \"\n-                                           + \"socket, shmem\");\n-            }\n-            return true;\n-        }\n-\n-        if (option.equals(\"connector\")) {\n-            if ((!value.equals(\"attaching\"))\n-                && (!value.equals(\"listening\"))) {\n-                throw new BadOption(option + \": value must be one of: \"\n-                                           + \"attaching, listening\");\n-            }\n-            return true;\n-        }\n-\n-        if (option.equals(\"transport.address\")) {\n-            if (!value.equals(\"dynamic\")) {\n-                throw new BadOption(option + \": must be only: \"\n-                                           + \"dynamic\");\n-            }\n-            return true;\n-        }\n-\n-        return super.checkOption(option, value);\n-    }\n-\n-    \/**\n-     * Check if the values of all options are consistent.\n-     * This method is invoked by <code>parseArguments()<\/code>\n-     *\n-     * @throws <i>BadOption<\/i> if options have inconsistent values\n-     *\n-     * @see #parseArguments()\n-     *\/\n-    protected void checkOptions() {\n-        super.checkOptions();\n-    }\n-\n-    private String findFreePort() {\n-        ServerSocket ss = null;\n-        try {\n-            ss = new ServerSocket(0);\n-            return String.valueOf(ss.getLocalPort());\n-        } catch (IOException e) {\n-            return null;\n-        } finally {\n-            try {\n-                ss.close();\n-            } catch (Throwable t) {\n-                \/\/ ignore\n-            }\n-        }\n-    }\n-\n-} \/\/ DebugeeArgumentHandler\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jpda\/DebugeeArgumentHandler.java.orig","additions":0,"deletions":786,"binary":false,"changes":786,"status":"deleted"}]}