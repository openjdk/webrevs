{"files":[{"patch":"@@ -761,0 +761,23 @@\n+    \/**\n+     * {@return the class body of an {@code enum} constant if the\n+     * argument is an {@code enum} constant declared with an optional\n+     * class body, {@code null} otherwise}\n+     *\n+     * @implSpec\n+     * The default implementation of this method throws {@code\n+     * UnsupportedOperationException} if the argument is an {@code\n+     * enum} constant and throws an {@code IllegalArgumentException}\n+     * if it is not.\n+     *\n+     * @param enumConstant an enum constant\n+     * @throws IllegalArgumentException if the argument is not an {@code enum} constant\n+     * @jls 8.9.1 Enum Constants\n+     * @since 22\n+     *\/\n+    default TypeElement getEnumConstantBody(VariableElement enumConstant) {\n+        switch(enumConstant.getKind()) {\n+        case ENUM_CONSTANT -> throw new UnsupportedOperationException();\n+        default            -> throw new IllegalArgumentException(\"Argument not an enum constant\");\n+        }\n+    }\n+\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Elements.java","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+import com.sun.tools.javac.comp.Attr;\n@@ -96,0 +97,1 @@\n+    private final Attr attr;\n@@ -117,0 +119,1 @@\n+        attr = Attr.instance(context);\n@@ -728,0 +731,31 @@\n+    @Override @DefinedBy(Api.LANGUAGE_MODEL)\n+    public TypeElement getEnumConstantBody(VariableElement enumConstant) {\n+        if (enumConstant.getKind() == ElementKind.ENUM_CONSTANT) {\n+            JCTree enumBodyTree = getTreeAlt(enumConstant);\n+            JCTree enclosingEnumTree = getTreeAlt(enumConstant.getEnclosingElement());\n+\n+            if (enumBodyTree instanceof JCVariableDecl decl\n+                && enclosingEnumTree instanceof JCClassDecl clazz\n+                && decl.init instanceof JCNewClass nc\n+                && nc.def != null) {\n+                if ((clazz.sym.flags_field & Flags.UNATTRIBUTED) != 0) {\n+                    attr.attribClass(clazz.pos(), clazz.sym);\n+                }\n+                return nc.def.sym; \/\/ ClassSymbol for enum constant body\n+            } else {\n+                return null;\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Argument not an enum constant\");\n+        }\n+    }\n+\n+    private JCTree getTreeAlt(Element e) {\n+        Symbol sym = cast(Symbol.class, e);\n+        Env<AttrContext> enterEnv = getEnterEnv(sym);\n+        if (enterEnv == null)\n+            return null;\n+        JCTree tree = TreeInfo.declarationFor(sym, enterEnv.tree);\n+        return tree;\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/model\/JavacElements.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -187,0 +187,10 @@\n+                \/\/ Print nothing for an anonymous class used for an\n+                \/\/ enum constant body.\n+                TypeMirror supertype = e.getSuperclass();\n+                if (supertype.getKind() != TypeKind.NONE) {\n+                    TypeElement superClass = (TypeElement)(((DeclaredType)supertype).asElement());\n+                    if (superClass.getKind() == ENUM) {\n+                        return this;\n+                    }\n+                }\n+\n@@ -696,0 +706,6 @@\n+            if (e.getKind() == ENUM) {\n+                \/\/ any permitted classes on an enum are anonymous\n+                \/\/ classes for enum bodies, elide.\n+                return;\n+            }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/processing\/PrintingProcessor.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,266 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8312418\n+ * @summary Test Elements.getEnumConstantBody\n+ * @library \/tools\/javac\/lib\n+ * @build   JavacTestingAbstractProcessor TestGetEnumConstantBody\n+ * @compile -processor TestGetEnumConstantBody -XDshould.stop-at=FLOW TestGetEnumConstantBody.java\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.*;\n+import java.util.function.*;\n+import javax.annotation.processing.*;\n+import javax.lang.model.element.*;\n+import javax.lang.model.util.*;\n+import javax.lang.model.type.*;\n+\n+\/**\n+ * Test basic workings of Elements.getEnumConstantBody\n+ *\/\n+public class TestGetEnumConstantBody extends JavacTestingAbstractProcessor {\n+    private Elements vacuousElements = new VacuousElements();\n+    private Set<Element> allElements = new HashSet<>();\n+    private int round;\n+\n+    public boolean process(Set<? extends TypeElement> annotations,\n+                           RoundEnvironment roundEnv) {\n+\n+        allElements.addAll(roundEnv.getRootElements());\n+\n+        \/\/ In the innermost loop, examine the fields defined by the the nested classes\n+        for (TypeElement typeRoot : ElementFilter.typesIn(allElements) ) {\n+            if (typeRoot.getQualifiedName().contentEquals(\"Gen\")) {\n+                continue;\n+            }\n+\n+            boolean elementSeen = false;\n+\n+            for (TypeElement typeElt : ElementFilter.typesIn(typeRoot.getEnclosedElements()) ) {\n+                System.out.println(\"Testing type \" + typeElt);\n+\n+                for (VariableElement field : ElementFilter.fieldsIn(typeElt.getEnclosedElements()) ) {\n+                    elementSeen = true;\n+                    System.out.println(field);\n+                    switch (field.getKind()) {\n+                    case FIELD         -> expectIAE(field);\n+                    case ENUM_CONSTANT -> testEnumConstant(field, typeElt);\n+                    default            -> throw new RuntimeException(\"Unexpected field kind seen\");\n+                    }\n+                }\n+            }\n+\n+            if (!elementSeen) {\n+                throw new RuntimeException(\"No elements seen.\");\n+            }\n+        }\n+        switch (round++) {\n+            case 0:\n+                try (Writer w = processingEnv.getFiler().createSourceFile(\"Cleaned\").openWriter()) {\n+                    w.write(\"\"\"\n+                            class Enclosing {\n+                                enum Cleaned {\n+                                    @TestGetEnumConstantBody.ExpectedBinaryName(\"Enclosing$Cleaned$2\")\n+                                    A(new Object() {}) {\n+                                        void test(Gen g) {\n+                                            g.run();\n+                                        }\n+                                    },\n+                                    B,\n+                                    @TestGetEnumConstantBody.ExpectedBinaryName(\"Enclosing$Cleaned$4\")\n+                                    C(new Object() {}) {\n+                                    };\n+\n+                                    private Cleaned() {}\n+\n+                                    private Cleaned(Object o) {}\n+                                }\n+                            }\n+                            \"\"\");\n+                } catch (IOException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+                break;\n+            case 1:\n+                try (Writer w = processingEnv.getFiler().createSourceFile(\"Gen\").openWriter()) {\n+                    w.write(\"\"\"\n+                            public class Gen {\n+                                public void run() {}\n+                            }\n+                            \"\"\");\n+                } catch (IOException ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+                break;\n+        }\n+        return true;\n+    }\n+\n+    private String computeExpectedBinaryName(VariableElement e) {\n+        ExpectedBinaryName ebn = e.getAnnotation(ExpectedBinaryName.class);\n+        return (ebn == null) ? null : ebn.value();\n+    }\n+\n+    private void expectIAE(VariableElement variable) {\n+        expectException0(() ->  elements.getEnumConstantBody(variable),\n+                         \"Expected exception not thrown\");\n+\n+        expectException0(() ->  vacuousElements.getEnumConstantBody(variable),\n+                         \"Expected vacuous exception not thrown\");\n+    }\n+\n+    private void expectException0(Supplier<TypeElement> supplier, String message) {\n+        try {\n+            var typeElement = supplier.get();\n+            messager.printError(message, typeElement);\n+        } catch (IllegalArgumentException iae) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    void expectUOE(VariableElement field) {\n+        try {\n+            var result = vacuousElements.getEnumConstantBody(field);\n+            messager.printError(\"Unexpected non-exceptional result returned\", field);\n+\n+        } catch(UnsupportedOperationException uoe) {\n+            ; \/\/ Expected\n+        }\n+    }\n+\n+    private void testEnumConstant(VariableElement field,\n+                                  TypeElement enclosingClass) {\n+        String expectedBinaryName = computeExpectedBinaryName(field);\n+        boolean expectEnumConstantBody = expectedBinaryName != null;\n+\n+        System.out.println(\"\\tTesting enum constant \" + field + \" expected \" + expectEnumConstantBody);\n+        expectUOE(field);\n+\n+        TypeElement enumConstantBody = elements.getEnumConstantBody(field);\n+\n+        if (Objects.nonNull(enumConstantBody) != expectEnumConstantBody) {\n+            messager.printError(\"Unexpected body value\", field);\n+        }\n+\n+        if (enumConstantBody != null) {\n+            testEnumConstantBody(enumConstantBody, expectedBinaryName, enclosingClass);\n+        }\n+\n+        System.out.println(\"\\t constant body \" + enumConstantBody);\n+    }\n+\n+    \/*\n+     * From JLS 8.9.1:\n+     *\n+     * \"The optional class body of an enum constant implicitly\n+     * declares an anonymous class (15.9.5) that (i) is a direct\n+     * subclass of the immediately enclosing enum class (8.1.4), and\n+     * (ii) is final (8.1.1.2). The class body is governed by the\n+     * usual rules of anonymous classes; in particular it cannot\n+     * contain any constructors. Instance methods declared in these\n+     * class bodies may be invoked outside the enclosing enum class\n+     * only if they override accessible methods in the enclosing enum\n+     * class (8.4.8).\"\n+     *\/\n+    private void testEnumConstantBody(TypeElement enumConstBody, String expectedBinaryName, TypeElement enumClass) {\n+        if (enumConstBody.getNestingKind() != NestingKind.ANONYMOUS) {\n+            messager.printError(\"Class body not an anonymous class\", enumConstBody);\n+        }\n+\n+        \/\/ Get the TypeElement for the direct superclass.\n+        TypeElement superClass =\n+            (TypeElement)(((DeclaredType)enumConstBody.getSuperclass()).asElement());\n+\n+        if (!superClass.equals(enumClass)) {\n+            messager.printError(\"Class body is not a direct subclass of the enum\", enumConstBody);\n+        }\n+\n+        if (!enumConstBody.getModifiers().contains(Modifier.FINAL)) {\n+            messager.printError(\"Modifier final missing on class body\", enumConstBody);\n+        }\n+\n+        if (!elements.getBinaryName(enumConstBody).contentEquals(expectedBinaryName)) {\n+            messager.printError(\"Unexpected binary name, expected: \" + expectedBinaryName +\n+                                                       \", but was: \" + elements.getBinaryName(enumConstBody), enumConstBody);\n+        }\n+\n+        return;\n+    }\n+\n+\n+    @interface ExpectedBinaryName {\n+        String value();\n+    }\n+\n+    \/\/ Nested classes hosting a variety of different kinds of fields.\n+\n+    private static enum Body {\n+        @ExpectedBinaryName(\"TestGetEnumConstantBody$Body$1\")\n+        GOLGI(true) {\n+            public boolean isOrganelle() {return true;}\n+        },\n+\n+        @ExpectedBinaryName(\"TestGetEnumConstantBody$Body$2\")\n+        HEAVENLY(true) {\n+            public boolean isCelestial() {return true;}\n+        };\n+\n+        private Body(boolean predicate) {\n+            this.predicate = predicate;\n+        }\n+\n+        private boolean predicate;\n+\n+        public static int field = 42;\n+\n+        public void method() {return;}\n+    }\n+\n+    private static enum MetaSyntaxVar {\n+        FOO(\"foo\"),\n+        BAR(\"bar\");\n+\n+        private String lower;\n+        private MetaSyntaxVar(String lower) {\n+            this.lower = lower;\n+        }\n+\n+        int   BAZ  = 0;\n+        float QUUX = 0.1f;\n+    }\n+\n+    \/\/ Instance and static fields.\n+    public static class FieldHolder {\n+        public static final int f1 = 1;\n+        public static final String s = \"s\";\n+\n+        private Object data;\n+        public FieldHolder(Object data) {\n+            this.data = data;\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/util\/elements\/TestGetEnumConstantBody.java","additions":266,"deletions":0,"binary":false,"changes":266,"status":"added"}]}