{"files":[{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -33,1 +34,0 @@\n-import java.util.regex.Matcher;\n@@ -221,2 +221,6 @@\n-        Matcher matcher = Formatter.FORMAT_SPECIFIER_PATTERN.matcher(fragment);\n-        String group;\n+        int max = fragment.length();\n+        for (int i = 0; i < max;) {\n+            int n = fragment.indexOf('%', i);\n+            if (n < 0) {\n+                return false;\n+            }\n@@ -224,2 +228,4 @@\n-        while (matcher.find()) {\n-            group = matcher.group();\n+            i = n + 1;\n+            if (i >= max) {\n+                return false;\n+            }\n@@ -227,2 +233,9 @@\n-            if (!group.equals(\"%%\") && !group.equals(\"%n\")) {\n-                if (matcher.end() == fragment.length() && needed) {\n+            char c = fragment.charAt(i);\n+            if (c == '%' || c == 'n') {\n+                i++;\n+                continue;\n+            }\n+            int off = new Formatter.FormatSpecifierParser(null, c, i, fragment, max)\n+                    .parse();\n+            if (off > 0) {\n+                if (i + off == max && needed) {\n@@ -231,3 +244,4 @@\n-\n-                throw new MissingFormatArgumentException(group +\n-                        \" is not immediately followed by an embedded expression\");\n+                String group = fragment.substring(i - 1, i + off);\n+                throw new MissingFormatArgumentException(group + \" is not immediately followed by an embedded expression\");\n+            } else {\n+                throw new UnknownFormatConversionException(String.valueOf(c));\n@@ -236,1 +250,0 @@\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/FormatProcessor.java","additions":24,"deletions":11,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2023, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -52,2 +53,0 @@\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n@@ -2807,6 +2806,0 @@\n-    \/\/ %[argument_index$][flags][width][.precision][t]conversion\n-    static final String FORMAT_SPECIFIER\n-        = \"%(\\\\d+\\\\$)?([-#+ 0,(\\\\<]*)?(\\\\d+)?(\\\\.\\\\d+)?([tT])?([a-zA-Z%])\";\n-\n-    static final Pattern FORMAT_SPECIFIER_PATTERN = Pattern.compile(FORMAT_SPECIFIER);\n-\n@@ -2817,0 +2810,1 @@\n+        FormatSpecifierParser parser = null;\n@@ -2820,1 +2814,0 @@\n-        Matcher m = null; \/\/ create if needed\n@@ -2843,3 +2836,0 @@\n-                if (m == null) {\n-                    m = FORMAT_SPECIFIER_PATTERN.matcher(s);\n-                }\n@@ -2848,3 +2838,8 @@\n-                if (m.find(n) && m.start() == n) {\n-                    al.add(new FormatSpecifier(s, m));\n-                    i = m.end();\n+                if (parser == null) {\n+                    parser = new FormatSpecifierParser(al, c, i, s, max);\n+                } else {\n+                    parser.reset(c, i);\n+                }\n+                int off = parser.parse();\n+                if (off > 0) {\n+                    i += off;\n@@ -2859,0 +2854,153 @@\n+    static final class FormatSpecifierParser {\n+        final ArrayList<FormatString> al;\n+        final String s;\n+        final int max;\n+        char first;\n+        int start;\n+        int off;\n+        char c;\n+        int argSize;\n+        int flagSize;\n+        int widthSize;\n+\n+        FormatSpecifierParser(ArrayList<FormatString> al, char first, int start, String s, int max) {\n+            this.al = al;\n+\n+            this.first = first;\n+            this.c = first;\n+            this.start = start;\n+            this.off = start;\n+\n+            this.s = s;\n+            this.max = max;\n+        }\n+\n+        void reset(char first, int start) {\n+            this.first = first;\n+            this.c = first;\n+            this.start = start;\n+            this.off = start;\n+\n+            argSize = 0;\n+            flagSize = 0;\n+            widthSize = 0;\n+        }\n+\n+        \/**\n+         * If a valid format specifier is found, construct a FormatString and add it to {@link #al}.\n+         * The format specifiers for general, character, and numeric types have\n+         * the following syntax:\n+         *\n+         * <blockquote><pre>\n+         *   %[argument_index$][flags][width][.precision]conversion\n+         * <\/pre><\/blockquote>\n+         *\n+         * As described by the following regular expression:\n+         *\n+         * <blockquote><pre>\n+         *    %(\\d+\\$)?([-#+ 0,(\\<]*)?(\\d+)?(\\.\\d+)?([tT])?([a-zA-Z%])\n+         * <\/pre><\/blockquote>\n+         *\n+         * @return the length of the format specifier. If no valid format specifier is found, 0 is returned.\n+         *\/\n+        int parse() {\n+            int precisionSize = 0;\n+\n+            \/\/ (\\d+\\$)?\n+            parseArgument();\n+\n+            \/\/ ([-#+ 0,(\\<]*)?\n+            parseFlag();\n+\n+            \/\/ (\\d+)?\n+            parseWidth();\n+\n+            if (c == '.') {\n+                \/\/ (\\.\\d+)?\n+                precisionSize = parsePrecision();\n+                if (precisionSize == -1) {\n+                    return 0;\n+                }\n+            }\n+\n+            \/\/ ([tT])?([a-zA-Z%])\n+            char t = '\\0', conversion = '\\0';\n+            if ((c == 't' || c == 'T') && off + 1 < max) {\n+                char c1 = s.charAt(off + 1);\n+                if (isConversion(c1)) {\n+                    t = c;\n+                    conversion = c1;\n+                    off += 2;\n+                }\n+            } else if (isConversion(c)) {\n+                conversion = c;\n+                ++off;\n+            } else {\n+                return 0;\n+            }\n+\n+            if (argSize + flagSize + widthSize + precisionSize + t + conversion != 0) {\n+                if (al != null) {\n+                    FormatSpecifier formatSpecifier\n+                            = new FormatSpecifier(s, start, argSize, flagSize, widthSize, precisionSize, t, conversion);\n+                    al.add(formatSpecifier);\n+                }\n+                return off - start;\n+            }\n+            return 0;\n+        }\n+\n+        private void parseArgument() {\n+            \/\/ (\\d+\\$)?\n+            int i = off;\n+            for (; i < max && isDigit(c = s.charAt(i)); ++i);  \/\/ empty body\n+            if (i == off || c != '$') {\n+                c = first;\n+                return;\n+            }\n+\n+            i++; \/\/ skip '$'\n+            if (i < max) {\n+                c = s.charAt(i);\n+            }\n+\n+            argSize = i - off;\n+            off = i;\n+        }\n+\n+        private void parseFlag() {\n+            \/\/ ([-#+ 0,(\\<]*)?\n+            int i = off;\n+            for (; i < max && Flags.isFlag(c = s.charAt(i)); ++i);  \/\/ empty body\n+            flagSize = i - off;\n+            off = i;\n+        }\n+\n+        private void parseWidth() {\n+            \/\/ (\\d+)?\n+            int i = off;\n+            for (; i < max && isDigit(c = s.charAt(i)); ++i);  \/\/ empty body\n+            widthSize = i - off;\n+            off = i;\n+        }\n+\n+        private int parsePrecision() {\n+            int i = ++off;\n+            for (; i < max && isDigit(c = s.charAt(i)); ++i);  \/\/ empty body\n+            if (i != off) {\n+                int size = i - off + 1;\n+                off = i;\n+                return size;\n+            }\n+            return -1;\n+        }\n+    }\n+\n+    static boolean isConversion(char c) {\n+        return (c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || c == '%';\n+    }\n+\n+    private static boolean isDigit(char c) {\n+        return c >= '0' && c <= '9';\n+    }\n+\n@@ -2981,8 +3129,28 @@\n-        FormatSpecifier(String s, Matcher m) {\n-            index(s, m.start(1), m.end(1));\n-            flags(s, m.start(2), m.end(2));\n-            width(s, m.start(3), m.end(3));\n-            precision(s, m.start(4), m.end(4));\n-\n-            int tTStart = m.start(5);\n-            if (tTStart >= 0) {\n+        FormatSpecifier(\n+                String s,\n+                int i,\n+                int argSize,\n+                int flagSize,\n+                int widthSize,\n+                int precisionSize,\n+                char t,\n+                char conversion\n+        ) {\n+            int argEnd = i + argSize;\n+            int flagEnd = argEnd + flagSize;\n+            int widthEnd = flagEnd + widthSize;\n+            int precisionEnd = widthEnd + precisionSize;\n+\n+            if (argSize > 0) {\n+                index(s, i, argEnd);\n+            }\n+            if (flagSize > 0) {\n+                flags(s, argEnd, flagEnd);\n+            }\n+            if (widthSize > 0) {\n+                width(s, flagEnd, widthEnd);\n+            }\n+            if (precisionSize > 0) {\n+                precision(s, widthEnd, precisionEnd);\n+            }\n+            if (t != '\\0') {\n@@ -2990,1 +3158,1 @@\n-                if (s.charAt(tTStart) == 'T') {\n+                if (t == 'T') {\n@@ -2994,1 +3162,3 @@\n-            conversion(s.charAt(m.start(6)));\n+            conversion(conversion);\n+            check();\n+        }\n@@ -2996,0 +3166,1 @@\n+        private void check() {\n@@ -4689,0 +4860,7 @@\n+        private static boolean isFlag(char c) {\n+            return switch (c) {\n+                case '-', '#', '+', ' ', '0', ',', '(', '<' -> true;\n+                default -> false;\n+            };\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":203,"deletions":25,"binary":false,"changes":228,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+import java.util.MissingFormatArgumentException;\n+import java.util.UnknownFormatConversionException;\n@@ -53,0 +55,22 @@\n+    public interface Executable {\n+        void execute() throws Throwable;\n+    }\n+\n+    static <T extends Throwable> void assertThrows(Class<T> expectedType, Executable executable, String message) {\n+        Throwable actualException = null;\n+        try {\n+            executable.execute();\n+        } catch (Throwable e) {\n+            actualException = e;\n+        }\n+        if (actualException == null) {\n+            throw new RuntimeException(\"Expected \" + expectedType + \" to be thrown, but nothing was thrown.\");\n+        }\n+        if (!expectedType.isInstance(actualException)) {\n+            throw new RuntimeException(\"Expected \" + expectedType + \" to be thrown, but was thrown \" + actualException.getClass());\n+        }\n+        if (message != null && !message.equals(actualException.getMessage())) {\n+            throw new RuntimeException(\"Expected \" + message + \" to be thrown, but was thrown \" + actualException.getMessage());\n+        }\n+    }\n+\n@@ -914,0 +938,22 @@\n+\n+        test(\"aaa%false\", fmt.\"aaa%%%b\\{false}\");\n+        test(\"aaa\" + System.lineSeparator() + \"false\", fmt.\"aaa%n%b\\{false}\");\n+\n+        assertThrows(\n+                MissingFormatArgumentException.class,\n+                () -> fmt. \"%10ba\\{ false }\",\n+                \"Format specifier '%10b is not immediately followed by an embedded expression'\");\n+\n+        assertThrows(\n+                MissingFormatArgumentException.class,\n+                () ->fmt. \"%ba\\{ false }\",\n+                \"Format specifier '%b is not immediately followed by an embedded expression'\");\n+\n+        assertThrows(\n+                MissingFormatArgumentException.class,\n+                () ->fmt. \"%b\",\n+                \"Format specifier '%b is not immediately followed by an embedded expression'\");\n+        assertThrows(\n+                UnknownFormatConversionException.class,\n+                () ->fmt. \"%0\",\n+                \"Conversion = '0'\");\n","filename":"test\/jdk\/java\/lang\/template\/FormatterBuilder.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.util.UnknownFormatConversionException;\n@@ -171,0 +172,2 @@\n+        common();\n+\n@@ -200,0 +203,8 @@\n+\n+    private static void common() {\n+        \/\/ non-conversion\n+        tryCatch(\"%12\", UnknownFormatConversionException.class);\n+        tryCatch(\"% \", UnknownFormatConversionException.class);\n+        tryCatch(\"%,\", UnknownFormatConversionException.class);\n+        tryCatch(\"%03.2\", UnknownFormatConversionException.class);\n+    }\n","filename":"test\/jdk\/java\/util\/Formatter\/Basic.java","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.math.BigDecimal;\n@@ -50,0 +51,6 @@\n+    public static final BigDecimal pi = new BigDecimal(Math.PI);\n+\n+    @Benchmark\n+    public String decimalFormat() {\n+        return \"%010.3f\".formatted(pi);\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringFormat.java","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"}]}