{"files":[{"patch":"@@ -0,0 +1,293 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.io.*;\n+import java.nio.channels.Channel;\n+import java.nio.channels.FileChannel;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.stream.Stream;\n+\n+import static jdk.test.lib.Asserts.assertNotNull;\n+import static jdk.test.lib.Asserts.assertTrue;\n+import static jdk.test.lib.util.OpenFiles.*;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @summary verify functionality of the OpenFilesAgent Java agent\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.OpenFilesAgent jdk.test.lib.util.OpenFiles\n+ * @run driver jdk.test.lib.util.OpenFilesAgent\n+ * @run junit\/othervm -javaagent:OpenFilesAgent.jar OpenFilesTest\n+ *\/\n+public class OpenFilesTest {\n+\n+    private Path file = Path.of(\"testfile.txt\");\n+\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        Files.createFile(file);\n+    }\n+\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.delete(file);\n+    }\n+\n+    \/\/ Provide file APIs to exercise tests on\n+    public static Stream<Arguments> arguments() {\n+        return Stream.of(\n+                Arguments.of(new FileInputStreamResource()),\n+                Arguments.of(new FileOutputStreamResource()),\n+                Arguments.of(new RandomAccessFileResource()),\n+                Arguments.of(new FilesNewByteChannelResource()),\n+                Arguments.of(new FilesNewInputStreamResource()),\n+                Arguments.of(new FilesNewOutputStreamResource()),\n+                Arguments.of(new FileChannelResource())\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"arguments\")\n+    public void shouldDetectOpenAndClose(Resource resource) throws IOException {\n+        \/\/ Sanity check\n+        assertClosed(file);\n+\n+        \/\/ Open the file\n+        resource.open(file);\n+\n+        \/\/ Verify open status\n+        assertOpen(file);\n+        assertOpen(file.toFile());\n+        assertOpen(file.toAbsolutePath());\n+        assertOpen(file.toString());\n+        assertOpenIf(true, file);\n+\n+        \/\/ Close the file\n+        resource.close();\n+\n+        \/\/ Verify closed status\n+        assertClosed(file);\n+        assertClosed(file.toFile());\n+        assertClosed(file.toAbsolutePath());\n+        assertClosed(file.toString());\n+        assertOpenIf(false, file);\n+\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"arguments\")\n+    public void shouldRejectOpenAndClose(Resource resource) throws IOException {\n+        \/\/ Sanity checks\n+        assertClosed(file);\n+\n+        \/\/ Open the file\n+        resource.open(file);\n+\n+        \/\/ Fail closed status\n+        assertThrows(AssertionError.class, () -> {\n+            assertClosed(file);\n+        });\n+        assertThrows(AssertionError.class, () -> {\n+            assertClosed(file.toFile());\n+        });\n+        assertThrows(AssertionError.class, () -> {\n+            assertClosed(file.toAbsolutePath());\n+        });\n+        assertThrows(AssertionError.class, () -> {\n+            assertClosed(file.toString());\n+        });\n+\n+        \/\/ Close the file\n+        resource.close();\n+\n+        \/\/ Fail open status\n+        assertThrows(AssertionError.class, () -> {\n+            assertOpen(file);\n+        });\n+        assertThrows(AssertionError.class, () -> {\n+            assertOpen(file.toFile());\n+        });\n+        assertThrows(AssertionError.class, () -> {\n+            assertOpen(file.toAbsolutePath());\n+        });\n+        assertThrows(AssertionError.class, () -> {\n+            assertOpen(file.toString());\n+        });\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"arguments\")\n+    public void shouldCaptureOpeningStackTrace(Resource resource) throws IOException {\n+\n+        \/\/ Open the file\n+        resource.open(file);\n+\n+        \/\/ Capture an AssertionError\n+        AssertionError e = assertThrows(AssertionError.class, () -> assertClosed(file));\n+\n+        \/\/ Close file up\n+        resource.close();\n+        assertClosed(file);\n+\n+        \/\/ The cause is the capture\n+        Throwable capture = e.getCause();\n+        assertNotNull(capture);\n+\n+        \/\/ Message should include a mention of the file path\n+        assertTrue(capture.getMessage().contains(file.toString()),\n+                \"Expected capture to mention file \" + file.toString());\n+\n+        \/\/ Stack trace should include this method\n+        assertStackTraceIncludes(capture, getClass(), \"shouldCaptureOpeningStackTrace\");\n+\n+        \/\/ Stack trace should include Resource.open\n+        assertStackTraceIncludes(capture, resource.getClass(), \"open\");\n+    }\n+\n+    \/\/ Assert that a method is found in the stack trace of the given Throwable\n+    private void assertStackTraceIncludes(Throwable capture, Class<?> clazz, String methodName) {\n+        for (StackTraceElement se : capture.getStackTrace()) {\n+            if (se.getClassName().equals(clazz.getName()) && se.getMethodName().equals(methodName)) {\n+                return;\n+            }\n+        }\n+        fail(\"Expected stack trace to include \" + clazz.getName() + \".\" + methodName);\n+    }\n+\n+    \/\/ Abstraction for APIs which can open and close files\n+    interface Resource {\n+        void open(Path path) throws IOException;\n+        void close() throws IOException;\n+    }\n+\n+    static class FileInputStreamResource implements Resource {\n+        private FileInputStream fis;\n+\n+        @Override\n+        public void open(Path path) throws IOException {\n+            this.fis = new FileInputStream(path.toFile());\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            fis.close();\n+        }\n+    }\n+\n+    static class FileOutputStreamResource implements Resource {\n+        private FileOutputStream fis;\n+\n+        @Override\n+        public void open(Path path) throws IOException {\n+            this.fis = new FileOutputStream(path.toFile());\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            fis.close();\n+        }\n+    }\n+\n+    static class RandomAccessFileResource implements Resource {\n+        private RandomAccessFile raf;\n+\n+        @Override\n+        public void open(Path path) throws IOException {\n+            this.raf = new RandomAccessFile(path.toFile(), \"r\");\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            raf.close();\n+        }\n+    }\n+\n+    private static class FileChannelResource implements Resource{\n+\n+        private Channel channel;\n+\n+        @Override\n+        public void open(Path path) throws IOException {\n+            channel = FileChannel.open(path);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            channel.close();\n+        }\n+    }\n+\n+    private static class FilesNewByteChannelResource implements Resource {\n+\n+        private Channel channel;\n+\n+        @Override\n+        public void open(Path path) throws IOException {\n+            channel = Files.newByteChannel(path);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            channel.close();\n+        }\n+    }\n+\n+    private static class FilesNewOutputStreamResource implements Resource {\n+\n+        private OutputStream stream;\n+\n+        @Override\n+        public void open(Path path) throws IOException {\n+            stream = Files.newOutputStream(path);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            stream.close();\n+        }\n+    }\n+\n+    private static class FilesNewInputStreamResource implements Resource {\n+\n+        private InputStream stream;\n+\n+        @Override\n+        public void open(Path path) throws IOException {\n+            stream = Files.newInputStream(path);\n+        }\n+\n+        @Override\n+        public void close() throws IOException {\n+            stream.close();\n+        }\n+    }\n+}\n","filename":"test\/lib-test\/jdk\/test\/lib\/util\/OpenFilesTest.java","additions":293,"deletions":0,"binary":false,"changes":293,"status":"added"},{"patch":"@@ -0,0 +1,195 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.util;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\/**\n+ * API for registering files as opened or closed (from code instrumented by agent)\n+ * and for asserting open status for a file (from tests).\n+ *\/\n+public class OpenFiles {\n+\n+    private static Map<String, Map<Object, Throwable>> paths = new HashMap<>();\n+    private static Map<Object, String> files = new HashMap<>();\n+\n+    \/**\n+     * Register a file path as being opened by the given Object\n+     *\n+     * @param file the file to register as opened\n+     * @param object the object opening the file\n+     *\/\n+    public static void openFile(String path, Object object) {\n+        openFile(Path.of(path), object);\n+    }\n+\n+    \/**\n+     * Register a file as being opened by the given Object\n+     *\n+     * @param file the file to register as opened\n+     * @param object the object opening the file\n+     *\/\n+    public static void openFile(File file,  Object object) {\n+        openFile(file.getAbsolutePath(), object);\n+    }\n+\n+    \/**\n+     * Register a file as being opened by the given Object\n+     *\n+     * @param file the file to register as opened\n+     * @param object the object opening the file\n+     *\/\n+    public static synchronized void openFile(Path file, Object object) {\n+        String path = file.toAbsolutePath().toString();\n+        if (!paths.containsKey(path)) {\n+            paths.put(path, new HashMap<>());\n+        }\n+        paths.get(path).put(object, new Throwable(\"Opening stack trace of \" + path));\n+        files.put(object, path);\n+    }\n+\n+    \/**\n+     * Close the file opened by the given object\n+     * @param object the object opening the file\n+     *\/\n+    public synchronized static void closeFile(Object object) {\n+        String path = files.get(object);\n+        if (path != null) {\n+            files.remove(object);\n+            Map<Object, Throwable> opens = paths.get(path);\n+            if (opens != null) {\n+                opens.remove(object);\n+                if (opens.isEmpty()) {\n+                    paths.remove(path);\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assert that the given {@code File} is closed\n+     *\n+     * @param file the {@code File} to check\n+     *\/\n+    public static void assertClosed(File file) {\n+        assertClosed(file.toPath());\n+    }\n+\n+    \/**\n+     * Assert that the given file path is closed\n+     *\n+     * @param file the file path to check\n+     *\/\n+    public static void assertClosed(String path) {\n+        assertClosed(Path.of(path));\n+    }\n+\n+    \/**\n+     * Assert that the given {@code Path} is closed\n+     *\n+     * @param file the {@code Path} to check\n+     *\/\n+    public static synchronized void assertClosed(Path file) {\n+        String path = file.toAbsolutePath().toString();\n+        Map<Object, Throwable> opens = paths.get(path);\n+        if (opens != null && !opens.isEmpty()) {\n+            for (var e : opens.entrySet()) {\n+                Object open = e.getKey();\n+                Throwable stacktrace = e.getValue();\n+                throw new AssertionError(\"Expected file to be closed: \" + path, stacktrace);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Assert that the given {@code File} is open\n+     *\n+     * @param file the {@code File} to check\n+     *\/\n+    public static void assertOpen(File file) {\n+        assertOpen(file.toPath());\n+    }\n+\n+    \/**\n+     * Assert that the given absolute file path is open\n+     *\n+     * @param file the path of the file to check\n+     *\/\n+    public  static void assertOpen(String path) {\n+        assertOpen(Path.of(path));\n+    }\n+\n+    \/**\n+     * Assert that the given {@code Path} is open\n+     *\n+     * @param file the {@code File} to check\n+     *\/\n+    public static synchronized void assertOpen(Path file) {\n+        String path = file.toAbsolutePath().toString();\n+        Map<Object, Throwable> opens = paths.get(path);\n+        if (opens == null || opens.isEmpty()) {\n+            throw new AssertionError(\"Expected file to be open: \" + path);\n+        }\n+    }\n+\n+    \/**\n+     * If {@code expectOpen} is true, assert that the given {@code File}\n+     * is open, otherwise assert that it is closed.\n+     *\n+     * @param expectOpen true if the file should be open\n+     * @param file the {@code File} to check\n+     *\/\n+    public static void assertOpenIf(boolean expectOpen, File file) {\n+        assertOpenIf(expectOpen, file.toPath());\n+    }\n+\n+    \/**\n+     * If {@code expectOpen} is true, assert that the given {@code Path}\n+     * is open, otherwise assert that it is closed.\n+     *\n+     * @param expectOpen true if the file should be open\n+     * @param file the {@code Path} to check\n+     *\/\n+    public static void assertOpenIf(boolean expectOpen, Path file) {\n+        assertOpenIf(expectOpen, file.toAbsolutePath().toString());\n+    }\n+\n+    \/**\n+     * If {@code expectOpen} is true, assert that the file with the given\n+     * absolute path is open, otherwise assert that it is closed.\n+     *\n+     * @param expectOpen true if the file should be open\n+     * @param file the path of the file to check\n+     *\/\n+    public static void assertOpenIf(boolean expectOpen, String path) {\n+        if (expectOpen) {\n+            assertOpen(path);\n+        } else {\n+            assertClosed(path);\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/util\/OpenFiles.java","additions":195,"deletions":0,"binary":false,"changes":195,"status":"added"},{"patch":"@@ -0,0 +1,410 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.test.lib.util;\n+\n+import java.io.*;\n+import java.lang.classfile.ClassFile;\n+import java.lang.classfile.ClassModel;\n+import java.lang.classfile.CodeBuilder;\n+import java.lang.classfile.CodeElement;\n+import java.lang.classfile.CodeTransform;\n+import java.lang.classfile.MethodModel;\n+import java.lang.classfile.MethodTransform;\n+import java.lang.classfile.Opcode;\n+import java.lang.classfile.TypeKind;\n+import java.lang.classfile.instruction.InvokeInstruction;\n+import java.lang.classfile.instruction.ReturnInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.lang.instrument.UnmodifiableClassException;\n+import java.net.URL;\n+import java.security.ProtectionDomain;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.jar.Attributes;\n+import java.util.jar.*;\n+\n+import static java.lang.constant.ConstantDescs.*;\n+\n+\/**\n+ * Java agent which instruments the opening and closing of files.\n+ * <p>\n+ * Supported file APIs include: java.io.FileInputStream, java.io.FileOutputStream,\n+ * java.io.RandomAccessFile, java.nio.file.Files and java.nio.channels.FileChannel\n+ * <p>\n+ * The main method in this class is used by tests as a driver to produce agent JAR files.\n+ * <p>\n+ * A typical jtreg configuration looks like:\n+ *\n+ * @library \/test\/lib\n+ * @run driver jdk.test.lib.util.OpenFilesAgent\n+ * @run junit\/othervm -javaagent:OpenFilesAgent.jar SomeTest\n+ * <p>\n+ * See {@link OpenFiles} for an assertion API to use in testing\n+ *\n+ * @see OpenFiles\n+ *\/\n+public class OpenFilesAgent {\n+\n+    \/\/ Run from jtreg tests as a driver to produce agent and registry JARs\n+    public static void main(String[] args) throws IOException {\n+\n+        Manifest man = new Manifest();\n+        Attributes attrs = man.getMainAttributes();\n+        attrs.put(Attributes.Name.MANIFEST_VERSION, \"1.0\");\n+\n+        createJar(\"OpenFiles.jar\", man, OpenFiles.class);\n+\n+        attrs.put(new Attributes.Name(\"Premain-Class\"), OpenFilesAgent.class.getName());\n+        attrs.putValue(\"Can-Retransform-Classes\", \"true\");\n+\n+        createJar(\"OpenFilesAgent.jar\", man, OpenFilesAgent.class);\n+    }\n+\n+\n+    \/\/ Initialize the agent\n+    public static void premain(String args, Instrumentation instrumentation) throws IOException, UnmodifiableClassException {\n+\n+        File registryJarFile = new File(\"OpenFiles.jar\");\n+        if (registryJarFile.exists()) {\n+            JarFile registryJar = new JarFile(registryJarFile);\n+            \/\/ OpenFiles must be visible to the boot class loader\n+            instrumentation.appendToBootstrapClassLoaderSearch(registryJar);\n+            \/\/ Register out class file transformer\n+            instrumentation.addTransformer(new TrackOpenFilesTransformer(), true);\n+\n+            \/\/ Check if any class we want to transform is already loaded\n+            Set<Class<?>> toRetransform = new HashSet<>();\n+            var names = Set.of(\"java.io.RandomAccessFile\",\n+                    \"java.io.FileInputStream\",\n+                    \"java.io.FileOutputStream\",\n+                    \"sun.nio.ch.FileChannelImpl\");\n+            for (Class clazz : instrumentation.getAllLoadedClasses()) {\n+                if (names.contains(clazz.getName())) {\n+                    toRetransform.add(clazz);\n+                }\n+            }\n+            instrumentation.retransformClasses(toRetransform.toArray(Class[]::new));\n+        } else {\n+            System.err.println(\"Registry JAR file not found: \" + registryJarFile.getAbsolutePath());\n+        }\n+    }\n+\n+    \/**\n+     * Create a JAR file containing the class file for the given class, including\n+     * any nested classes.\n+     *\n+     * @param filename name of the JAR file to produce\n+     * @param man      the Manifest for the JAR file\n+     * @param clazz    the class file to create a JAR file for\n+     * @throws IOException if an error occurs\n+     *\/\n+    private static void createJar(String filename, Manifest man, Class<?> clazz) throws IOException {\n+        URL classFileResource = clazz.getResource(clazz.getSimpleName() + \".class\");\n+\n+        File[] files = new File(classFileResource.getFile()).getParentFile().listFiles();\n+\n+        String dir = clazz.getPackage().getName().replace('.', '\/') + \"\/\";\n+\n+        try (var out = new BufferedOutputStream(new FileOutputStream(new File(filename)));\n+             var jo = new JarOutputStream(out, man)) {\n+            if (files != null) {\n+                for (File file : files) {\n+                    String name = file.getName();\n+                    if (name.equals(clazz.getSimpleName() + \".class\") ||\n+                            name.startsWith(clazz.getSimpleName() + \"$\")) {\n+                        jo.putNextEntry(new JarEntry(dir + name));\n+                        try (var in = new FileInputStream(file)) {\n+                            in.transferTo(jo);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class TrackOpenFilesTransformer implements ClassFileTransformer {\n+\n+        static final ClassDesc CD_Registry = ClassDesc.of(\"jdk.test.lib.util.OpenFiles\");\n+        static final ClassDesc CD_File = ClassDesc.of(\"java.io.File\");\n+        static final ClassDesc CD_FileDescriptor = ClassDesc.of(\"java.io.FileDescriptor\");\n+        static final ClassDesc CD_Closeable = ClassDesc.of(\"java.io.Closeable\");\n+        static final ClassDesc CD_FileChannel = ClassDesc.of(\"java.nio.channels.FileChannel\");\n+\n+        static final MethodTypeDesc MD_openFile = MethodTypeDesc.of(CD_void, CD_File, CD_Object);\n+        static final MethodTypeDesc MD_openString = MethodTypeDesc.of(CD_void, CD_String, CD_Object);\n+        static final MethodTypeDesc MD_closeFile = MethodTypeDesc.of(CD_void, CD_Object);\n+        static final MethodTypeDesc MD_fisOpen = MethodTypeDesc.of(CD_void, CD_String);\n+        static final MethodTypeDesc MD_fosOpen = MethodTypeDesc.of(CD_void, CD_String, CD_boolean);\n+        static final MethodTypeDesc MD_rafInit = MethodTypeDesc.of(CD_void, CD_File, CD_String, CD_boolean);\n+        static final MethodTypeDesc MD_fcImplOpen = MethodTypeDesc.of(CD_FileChannel,\n+                CD_FileDescriptor,\n+                CD_String,\n+                CD_boolean,\n+                CD_boolean,\n+                CD_boolean,\n+                CD_boolean,\n+                CD_Closeable);\n+\n+        @Override\n+        public byte[] transform(Module module,\n+                                ClassLoader loader,\n+                                String className,\n+                                Class<?> classBeingRedefined,\n+                                ProtectionDomain protectionDomain,\n+                                byte[] classfileBuffer) throws IllegalClassFormatException {\n+\n+            try {\n+                return switch (className) {\n+                    case \"java\/io\/RandomAccessFile\" ->\n+                            transformRandomAccessFile(classfileBuffer);\n+                    case \"java\/io\/FileInputStream\" ->\n+                            transformFileInputStream(classfileBuffer);\n+                    case \"java\/io\/FileOutputStream\" ->\n+                            transformFileOutputStream(classfileBuffer);\n+                    case \"sun\/nio\/ch\/FileChannelImpl\" ->\n+                            transformFileChannelImpl(classfileBuffer);\n+                    default -> null;\n+                };\n+            } catch (Throwable e) {\n+                System.err.println(\"Error transforming class \" + className);\n+                e.printStackTrace();\n+                return null;\n+            }\n+        }\n+\n+        \/\/ Instrument RandomAccessFile to call OpenFiles::openFile, OpenFiles::closeFile\n+        byte[] transformRandomAccessFile(byte[] classfileBuffer) {\n+            ClassFile cf = ClassFile.of();\n+            ClassModel mod = cf.parse(classfileBuffer);\n+            return cf.transformClass(mod, (cb, ce) -> {\n+                switch (ce) {\n+                    \/\/ Constructor RandomAccessFile(File, String, boolean)\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"<init>\")\n+                            && method.methodTypeSymbol().equals(MD_rafInit) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call openFile before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.aload(1) \/\/ File\n+                                                        .aload(0)        \/\/ RandomAccessFile (this)\n+                                                        .invokestatic(CD_Registry, \"openFile\", MD_openFile)\n+                                                        .with(ri);\n+                                            }\n+\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+                    \/\/ RandomAccessFile::close\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"close\")\n+                            && method.methodTypeSymbol().equals(MTD_void) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call close before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.aload(0)        \/\/ RandomAccessFile (this)\n+                                                        .invokestatic(CD_Registry, \"closeFile\", MD_closeFile)\n+                                                        .with(ri);\n+                                            }\n+\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+                    default -> cb.accept(ce);\n+                }\n+            });\n+        }\n+\n+\n+        \/\/ Instrument FileInputStream to call OpenFiles::openFile, OpenFiles::closeFile\n+        byte[] transformFileInputStream(byte[] classfileBuffer) {\n+            ClassFile cf = ClassFile.of();\n+            ClassModel mod = cf.parse(classfileBuffer);\n+            return cf.transformClass(mod, (cb, ce) -> {\n+                switch (ce) {\n+                    \/\/ FileInputStream::open(String)\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"open\")\n+                            && method.methodTypeSymbol().equals(MD_fisOpen) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call openFile before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.aload(1) \/\/ String\n+                                                        .aload(0)        \/\/ FileInputStream (this)\n+                                                        .invokestatic(CD_Registry, \"openFile\", MD_openString)\n+                                                        .with(ri);\n+                                            }\n+\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+                    \/\/ FileInputStream::close\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"close\")\n+                            && method.methodTypeSymbol().equals(MTD_void) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call close before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.aload(0)        \/\/ FileInputStream (this)\n+                                                        .invokestatic(CD_Registry, \"closeFile\", MD_closeFile)\n+                                                        .with(ri);\n+                                            }\n+\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+                    default -> cb.accept(ce);\n+                }\n+            });\n+        }\n+\n+        \/\/ Instrument FileOutputStream to call OpenFiles::openFile, OpenFiles::closeFile\n+        byte[] transformFileOutputStream(byte[] classfileBuffer) {\n+            ClassFile cf = ClassFile.of();\n+            ClassModel mod = cf.parse(classfileBuffer);\n+            return cf.transformClass(mod, (cb, ce) -> {\n+                switch (ce) {\n+                    \/\/ FileInputStream::open(String)\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"open\")\n+                            && method.methodTypeSymbol().equals(MD_fosOpen) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call openFile before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.aload(1) \/\/ String\n+                                                        .aload(0)        \/\/ FileOutputStream (this)\n+                                                        .invokestatic(CD_Registry, \"openFile\", MD_openString)\n+                                                        .with(ri);\n+                                            }\n+\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+                    \/\/ FileInputStream::close\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"close\")\n+                            && method.methodTypeSymbol().equals(MTD_void) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call close before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.aload(0)        \/\/ FileOutputStream (this)\n+                                                        .invokestatic(CD_Registry, \"closeFile\", MD_closeFile)\n+                                                        .with(ri);\n+                                            }\n+\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+                    default -> cb.accept(ce);\n+                }\n+            });\n+        }\n+\n+\n+        \/\/ Instrument FileChannelImpl::open and FileChannelImpl:closeImpl\n+        byte[] transformFileChannelImpl(byte[] classfileBuffer) {\n+            ClassFile cf = ClassFile.of();\n+            ClassModel mod = cf.parse(classfileBuffer);\n+            return cf.transformClass(mod, (cb, ce) -> {\n+                switch (ce) {\n+                    \/\/ FileChannelImpl::open(Path, Set, FileAttributes)\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"open\")\n+                            && method.methodTypeSymbol().equals(MD_fcImplOpen) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call openFile before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.dup() \/\/ FileChannel\n+                                                        .aload(1) \/\/ String path\n+                                                        .swap()\n+                                                        .invokestatic(CD_Registry, \"openFile\", MD_openString)\n+                                                        .with(ri);\n+                                            }\n+\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+\n+                    case MethodModel method\n+                            when method.methodName().equalsString(\"implCloseChannel\")\n+                            && method.methodTypeSymbol().equals(MTD_void) ->\n+\n+                            cb.transformMethod(method, MethodTransform.transformingCode(\n+                                    (builder, element) -> {\n+                                        switch (element) {\n+                                            \/\/ Call close before RETURN\n+                                            case ReturnInstruction ri -> {\n+                                                builder.aload(0)        \/\/ FileChannel (this)\n+                                                        .invokestatic(CD_Registry, \"closeFile\", MD_closeFile)\n+                                                        .with(ri);\n+                                            }\n+                                            default -> builder.with(element);\n+                                        }\n+\n+                                    }));\n+\n+                    default -> cb.accept(ce);\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/lib\/jdk\/test\/lib\/util\/OpenFilesAgent.java","additions":410,"deletions":0,"binary":false,"changes":410,"status":"added"}]}