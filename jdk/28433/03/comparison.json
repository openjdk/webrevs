{"files":[{"patch":"@@ -3309,1 +3309,1 @@\n-    if (Universe::is_fully_initialized()) {\n+    if (Universe::is_fully_initialized() && !AOTCodeCache::is_on_for_dump()) {\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -293,1 +293,1 @@\n-  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, (uint)BlobId::c2_exception_id, name);\n+  CodeBlob* blob = AOTCodeCache::load_code_blob(AOTCodeEntry::C2Blob, BlobId::c2_exception_id);\n","filename":"src\/hotspot\/cpu\/aarch64\/runtime_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -87,2 +87,1 @@\n-  do_stub(compiler, count_positives_long)                               \\\n-  do_arch_entry(aarch64, compiler, count_positives_long,                \\\n+  do_arch_entry(aarch64, compiler, count_positives,                     \\\n@@ -111,2 +110,3 @@\n-  \/* this uses the entry for ghash_processBlocks *\/                     \\\n-  do_stub(compiler, ghash_processBlocks_wide)                           \\\n+  do_stub(compiler, ghash_processBlocks_small)                          \\\n+  do_arch_entry(aarch64, compiler, ghash_processBlocks_small,           \\\n+           ghash_processBlocks_small, ghash_processBlocks_small)        \\\n@@ -142,1 +142,0 @@\n-  \/* stub only -- entries are not stored in StubRoutines::aarch64 *\/    \\\n@@ -145,0 +144,41 @@\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_fetch_add_4_impl, atomic_fetch_add_4_impl)       \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_fetch_add_8_impl, atomic_fetch_add_8_impl)       \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_fetch_add_4_relaxed_impl,                        \\\n+                atomic_fetch_add_4_relaxed_impl)                        \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_fetch_add_8_relaxed_impl,                        \\\n+                atomic_fetch_add_8_relaxed_impl)                        \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_xchg_4_impl, atomic_xchg_4_impl)                 \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_xchg_8_impl, atomic_xchg_8_impl)                 \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_1_impl, atomic_cmpxchg_1_impl)           \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_4_impl, atomic_cmpxchg_4_impl)           \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_8_impl, atomic_cmpxchg_8_impl)           \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_1_relaxed_impl,                          \\\n+                atomic_cmpxchg_1_relaxed_impl)                          \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_4_relaxed_impl,                          \\\n+                atomic_cmpxchg_4_relaxed_impl)                          \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_8_relaxed_impl,                          \\\n+                atomic_cmpxchg_8_relaxed_impl)                          \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_4_release_impl,                          \\\n+                atomic_cmpxchg_4_release_impl)                          \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_8_release_impl,                          \\\n+                atomic_cmpxchg_8_release_impl)                          \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_4_seq_cst_impl,                          \\\n+                atomic_cmpxchg_4_seq_cst_impl)                          \\\n+  do_arch_entry(aarch64, final, atomic_entry_points,                    \\\n+                atomic_cmpxchg_8_seq_cst_impl,                          \\\n+                atomic_cmpxchg_8_seq_cst_impl)                          \\\n","filename":"src\/hotspot\/cpu\/aarch64\/stubDeclarations_aarch64.hpp","additions":45,"deletions":5,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -82,0 +82,160 @@\n+\/\/ Constant data definitions\n+\n+static const uint32_t _sha256_round_consts[64] = {\n+  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n+  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n+  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n+  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n+  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n+  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n+  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n+  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n+  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n+  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n+  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n+  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n+  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n+  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n+  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n+  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n+};\n+\n+static const uint64_t _sha512_round_consts[80] = {\n+  0x428A2F98D728AE22L, 0x7137449123EF65CDL, 0xB5C0FBCFEC4D3B2FL,\n+  0xE9B5DBA58189DBBCL, 0x3956C25BF348B538L, 0x59F111F1B605D019L,\n+  0x923F82A4AF194F9BL, 0xAB1C5ED5DA6D8118L, 0xD807AA98A3030242L,\n+  0x12835B0145706FBEL, 0x243185BE4EE4B28CL, 0x550C7DC3D5FFB4E2L,\n+  0x72BE5D74F27B896FL, 0x80DEB1FE3B1696B1L, 0x9BDC06A725C71235L,\n+  0xC19BF174CF692694L, 0xE49B69C19EF14AD2L, 0xEFBE4786384F25E3L,\n+  0x0FC19DC68B8CD5B5L, 0x240CA1CC77AC9C65L, 0x2DE92C6F592B0275L,\n+  0x4A7484AA6EA6E483L, 0x5CB0A9DCBD41FBD4L, 0x76F988DA831153B5L,\n+  0x983E5152EE66DFABL, 0xA831C66D2DB43210L, 0xB00327C898FB213FL,\n+  0xBF597FC7BEEF0EE4L, 0xC6E00BF33DA88FC2L, 0xD5A79147930AA725L,\n+  0x06CA6351E003826FL, 0x142929670A0E6E70L, 0x27B70A8546D22FFCL,\n+  0x2E1B21385C26C926L, 0x4D2C6DFC5AC42AEDL, 0x53380D139D95B3DFL,\n+  0x650A73548BAF63DEL, 0x766A0ABB3C77B2A8L, 0x81C2C92E47EDAEE6L,\n+  0x92722C851482353BL, 0xA2BFE8A14CF10364L, 0xA81A664BBC423001L,\n+  0xC24B8B70D0F89791L, 0xC76C51A30654BE30L, 0xD192E819D6EF5218L,\n+  0xD69906245565A910L, 0xF40E35855771202AL, 0x106AA07032BBD1B8L,\n+  0x19A4C116B8D2D0C8L, 0x1E376C085141AB53L, 0x2748774CDF8EEB99L,\n+  0x34B0BCB5E19B48A8L, 0x391C0CB3C5C95A63L, 0x4ED8AA4AE3418ACBL,\n+  0x5B9CCA4F7763E373L, 0x682E6FF3D6B2B8A3L, 0x748F82EE5DEFB2FCL,\n+  0x78A5636F43172F60L, 0x84C87814A1F0AB72L, 0x8CC702081A6439ECL,\n+  0x90BEFFFA23631E28L, 0xA4506CEBDE82BDE9L, 0xBEF9A3F7B2C67915L,\n+  0xC67178F2E372532BL, 0xCA273ECEEA26619CL, 0xD186B8C721C0C207L,\n+  0xEADA7DD6CDE0EB1EL, 0xF57D4F7FEE6ED178L, 0x06F067AA72176FBAL,\n+  0x0A637DC5A2C898A6L, 0x113F9804BEF90DAEL, 0x1B710B35131C471BL,\n+  0x28DB77F523047D84L, 0x32CAAB7B40C72493L, 0x3C9EBE0A15C9BEBCL,\n+  0x431D67C49C100D4CL, 0x4CC5D4BECB3E42B6L, 0x597F299CFC657E2AL,\n+  0x5FCB6FAB3AD6FAECL, 0x6C44198C4A475817L\n+};\n+\n+static const uint64_t _sha3_round_consts[24] = {\n+  0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n+  0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n+  0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n+  0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n+  0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n+  0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n+  0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n+  0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n+};\n+\n+static const uint64_t _double_keccak_round_consts[24] = {\n+  0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n+  0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n+  0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n+  0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n+  0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n+  0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n+  0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n+  0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n+};\n+\n+static const char _encodeBlock_toBase64[64] = {\n+  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+  'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '\/'\n+};\n+\n+static const char _encodeBlock_toBase64URL[64] = {\n+  'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+  'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+  'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+  'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+  '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+};\n+\n+\/\/ Non-SIMD lookup tables are mostly dumped from fromBase64 array used in java.util.Base64,\n+\/\/ except the trailing character '=' is also treated illegal value in this intrinsic. That\n+\/\/ is java.util.Base64.fromBase64['='] = -2, while fromBase(URL)64ForNoSIMD['='] = 255 here.\n+static const uint8_t _decodeBlock_fromBase64ForNoSIMD[256] = {\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+  52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+  255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+};\n+\n+static const uint8_t _decodeBlock_fromBase64URLForNoSIMD[256] = {\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+  52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+  255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+};\n+\n+\/\/ A legal value of base64 code is in range [0, 127].  We need two lookups\n+\/\/ with tbl\/tbx and combine them to get the decode data. The 1st table vector\n+\/\/ lookup use tbl, out of range indices are set to 0 in destination. The 2nd\n+\/\/ table vector lookup use tbx, out of range indices are unchanged in\n+\/\/ destination. Input [64..126] is mapped to index [65, 127] in second lookup.\n+\/\/ The value of index 64 is set to 0, so that we know that we already get the\n+\/\/ decoded data with the 1st lookup.\n+static const uint8_t _decodeBlock_fromBase64ForSIMD[128] = {\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+  52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n+  14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n+  255u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n+  40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n+};\n+\n+static const uint8_t _decodeBlock_fromBase64URLForSIMD[128] = {\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+  52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+  0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n+  14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n+  63u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n+  40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n+};\n+\n+\n@@ -206,0 +366,9 @@\n+    GrowableArray<address> entries;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 2, \"sanity check\");\n+    address start = load_archive_data(stub_id, &entries);\n+    if (start != nullptr) {\n+      assert(entries.length() == 1, \"expected 1 extra entry\");\n+      return_address = entries.at(0);\n+      return start;\n+    }\n@@ -207,1 +376,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -326,0 +495,1 @@\n+    entries.append(return_address);\n@@ -409,0 +579,3 @@\n+    \/\/ record the stub entry and end plus the auxiliary entry\n+    store_archive_data(stub_id, start, __ pc(), &entries);\n+\n@@ -426,0 +599,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -427,1 +606,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -453,1 +632,3 @@\n-    __ mov(rscratch1, (address)__FILE__);\n+    \/\/ special case -- add file name string to AOT address table\n+    address file = (address)AOTCodeCache::add_C_string(__FILE__);\n+    __ lea(rscratch1, ExternalAddress(file));\n@@ -463,0 +644,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -482,0 +666,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -483,1 +673,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -554,0 +744,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -572,0 +765,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -573,1 +772,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -616,0 +815,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -621,0 +823,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -623,1 +831,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -642,0 +850,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -659,0 +871,8 @@\n+    StubId stub_id = StubId::stubgen_zero_blocks_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    StubCodeMark mark(this, stub_id);\n@@ -665,3 +885,1 @@\n-    StubId stub_id = StubId::stubgen_zero_blocks_id;\n-    StubCodeMark mark(this, stub_id);\n-    address start = __ pc();\n+    start = __ pc();\n@@ -710,0 +928,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -806,0 +1027,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -857,1 +1084,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -1157,0 +1384,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -1511,2 +1741,2 @@\n-  \/\/   entry - is assigned to the stub's post push entry point unless\n-  \/\/           it is null\n+  \/\/   nopush_entry - is assigned to the stub's post push entry point\n+  \/\/                  unless it is null\n@@ -1528,2 +1758,0 @@\n-    Register s = c_rarg0, d = c_rarg1, count = c_rarg2;\n-    RegSet saved_reg = RegSet::of(s, d, count);\n@@ -1610,0 +1838,28 @@\n+    \/\/ all stubs provide a 2nd entry which omits the frame push for\n+    \/\/ use when bailing out from a conjoint copy. However we may also\n+    \/\/ need some extra addressses for memory access protection.\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 2, \"sanity check\");\n+    assert(nopush_entry != nullptr, \"all disjoint copy stubs export a nopush entry\");\n+\n+    bool add_extras = !is_oop && (!aligned || sizeof(jlong) == size);\n+    int extra_count = ((add_extras ? 1 : 0) * 3);\n+    GrowableArray<address> entries;\n+    GrowableArray<address> extras;\n+    GrowableArray<address> *extras_ptr = (extra_count > 0 ? &extras : nullptr);\n+    address start = load_archive_data(stub_id, &entries, extras_ptr);\n+    if (start != nullptr) {\n+      assert(entries.length() == entry_count - 1,\n+             \"unexpected entries count %d\", entries.length());\n+      *nopush_entry = entries.at(0);\n+      assert(extras.length() == extra_count,\n+             \"unexpected extra count %d\", extras.length());\n+      if (add_extras) {\n+        \/\/ register one handler at offset 0\n+        register_unsafe_access_handlers(extras, 0, 1);\n+      }\n+      return start;\n+    }\n+\n+    Register s = c_rarg0, d = c_rarg1, count = c_rarg2;\n+    RegSet saved_reg = RegSet::of(s, d, count);\n@@ -1613,1 +1869,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -1616,5 +1872,5 @@\n-    if (nopush_entry != nullptr) {\n-      *nopush_entry = __ pc();\n-      \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n-      BLOCK_COMMENT(\"Entry:\");\n-    }\n+    *nopush_entry = __ pc();\n+    entries.append(*nopush_entry);\n+\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    BLOCK_COMMENT(\"Post-Push Entry:\");\n@@ -1639,2 +1895,1 @@\n-      bool add_entry = !is_oop && (!aligned || sizeof(jlong) == size);\n-      UnsafeMemoryAccessMark umam(this, add_entry, true);\n+      UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -1655,0 +1910,14 @@\n+\n+    address end = __ pc();\n+\n+    if (add_extras) {\n+      \/\/ retrieve the registered handler addresses\n+      retrieve_unsafe_access_handlers(start, end, extras);\n+      assert(extras.length() == extra_count\n+             , \"incorrect handlers count %d\", extras.length());\n+    }\n+\n+    \/\/ record the stub entry and end plus the no_push entry and any\n+    \/\/ extra handler addresses\n+    store_archive_data(stub_id, start, end, &entries, extras_ptr);\n+\n@@ -1666,2 +1935,2 @@\n-  \/\/   entry - is assigned to the stub's post push entry point unless\n-  \/\/           it is null\n+  \/\/   nopush_entry - is assigned to the stub's post push entry point\n+  \/\/                  unless it is null\n@@ -1684,2 +1953,0 @@\n-    Register s = c_rarg0, d = c_rarg1, count = c_rarg2;\n-    RegSet saved_regs = RegSet::of(s, d, count);\n@@ -1765,0 +2032,29 @@\n+    \/\/ only some conjoint stubs generate a 2nd entry\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    int expected_entry_count = (nopush_entry == nullptr ? 1 : 2);\n+    assert(entry_count == expected_entry_count,\n+           \"expected entry count %d does not match declared entry count %d for stub %s\",\n+           expected_entry_count, entry_count, StubInfo::name(stub_id));\n+\n+    \/\/ We need to protect memory accesses in certain cases\n+    bool add_extras = !is_oop && (!aligned || sizeof(jlong) == size);\n+    int extra_count = ((add_extras ? 1 : 0) * 3);\n+    GrowableArray<address> entries;\n+    GrowableArray<address> extras;\n+    GrowableArray<address> *entries_ptr = (nopush_entry != nullptr ? &entries : nullptr);\n+    GrowableArray<address> *extras_ptr = (extra_count > 0 ? &extras : nullptr);\n+    address start = load_archive_data(stub_id, entries_ptr, extras_ptr);\n+    if (start != nullptr) {\n+      assert(entries.length() == expected_entry_count - 1,\n+             \"unexpected entries count %d\", entries.length());\n+      assert(extras.length() == extra_count,\n+             \"unexpected extra count %d\", extras.length());\n+      if (nopush_entry != nullptr) {\n+        *nopush_entry = entries.at(0);\n+      }\n+      if (add_extras) {\n+        \/\/ register one handler at offset 0\n+        register_unsafe_access_handlers(extras, 0, 1);\n+      }\n+      return start;\n+    }\n@@ -1766,0 +2062,2 @@\n+    Register s = c_rarg0, d = c_rarg1, count = c_rarg2;\n+    RegSet saved_regs = RegSet::of(s, d, count);\n@@ -1767,1 +2065,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -1772,0 +2070,1 @@\n+      entries.append(*nopush_entry);\n@@ -1773,1 +2072,1 @@\n-      BLOCK_COMMENT(\"Entry:\");\n+      BLOCK_COMMENT(\"Post-Push Entry:\");\n@@ -1801,2 +2100,1 @@\n-      bool add_entry = !is_oop && (!aligned || sizeof(jlong) == size);\n-      UnsafeMemoryAccessMark umam(this, add_entry, true);\n+      UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -1814,0 +2112,17 @@\n+\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected entries count %d\", entries.length());\n+\n+    address end = __ pc();\n+\n+    if (add_extras) {\n+      \/\/ retrieve the registered handler addresses\n+      retrieve_unsafe_access_handlers(start, end, extras);\n+      assert(extras.length() == extra_count,\n+             \"incorrect handlers count %d\", extras.length());\n+    }\n+\n+    \/\/ record the stub entry and end plus any no_push entry and\/or\n+    \/\/ extra handler addresses\n+    store_archive_data(stub_id, start, end, entries_ptr, extras_ptr);\n+\n@@ -1867,0 +2182,21 @@\n+    \/\/ The normal stub provides a 2nd entry which omits the frame push\n+    \/\/ for use when bailing out from a disjoint copy.\n+    \/\/ Only some conjoint stubs generate a 2nd entry\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    int expected_entry_count = (nopush_entry == nullptr ? 1 : 2);\n+    GrowableArray<address> entries;\n+    GrowableArray<address> *entries_ptr = (expected_entry_count == 1 ? nullptr : &entries);\n+    assert(entry_count == expected_entry_count,\n+           \"expected entry count %d does not match declared entry count %d for stub %s\",\n+           expected_entry_count, entry_count, StubInfo::name(stub_id));\n+    address start = load_archive_data(stub_id, entries_ptr);\n+    if (start != nullptr) {\n+      assert(entries.length() + 1 == expected_entry_count,\n+             \"expected entry count %d does not match return entry count %d for stub %s\",\n+             expected_entry_count, entries.length() + 1, StubInfo::name(stub_id));\n+      if (nopush_entry != nullptr) {\n+        *nopush_entry = entries.at(0);\n+      }\n+      return start;\n+    }\n+\n@@ -1899,1 +2235,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -1916,0 +2252,1 @@\n+      entries.append(*nopush_entry);\n@@ -2013,0 +2350,2 @@\n+    \/\/ record the stub entry and end plus any no_push entry\n+    store_archive_data(stub_id, start, __ pc() , entries_ptr);\n@@ -2075,1 +2414,6 @@\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -2081,1 +2425,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -2107,0 +2451,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -2128,1 +2475,6 @@\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -2147,1 +2499,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -2386,0 +2738,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -2430,1 +2785,6 @@\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -2433,1 +2793,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -2566,0 +2926,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -2570,1 +2934,8 @@\n-    address start_pc = __ pc();\n+    StubId stub_id = StubId::stubgen_unsafecopy_common_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    start = __ pc();\n@@ -2574,1 +2945,5 @@\n-    return start_pc;\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n+    return start;\n@@ -2592,0 +2967,14 @@\n+    StubId stub_id = StubId::stubgen_unsafe_setmemory_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    \/\/ we expect one set of extra unsafememory access handler entries\n+    GrowableArray<address> extras;\n+    int extra_count = 3;\n+    address start = load_archive_data(stub_id, nullptr, &extras);\n+    if (start != nullptr) {\n+      assert(extras.length() == extra_count,\n+             \"unexpected extra entry count %d\", extras.length());\n+      register_unsafe_access_handlers(extras, 0, 1);\n+      return start;\n+    }\n+\n@@ -2593,2 +2982,2 @@\n-    StubCodeMark mark(this, StubId::stubgen_unsafe_setmemory_id);\n-    address start = __ pc();\n+    StubCodeMark mark(this, stub_id);\n+    start = __ pc();\n@@ -2599,0 +2988,1 @@\n+    {\n@@ -2682,0 +3072,11 @@\n+    \/\/ have to exit the block and destroy the UnsafeMemoryAccessMark\n+    \/\/ in order to retrieve the handler end address\n+    }\n+\n+    \/\/ install saved handler addresses in extras\n+    address end = __ pc();\n+    retrieve_unsafe_access_handlers(start, end, extras);\n+    assert(extras.length() == extra_count,\n+           \"incorrect handlers count %d\", extras.length());\n+    \/\/ record the stub entry and end plus the extras\n+    store_archive_data(stub_id, start, end, nullptr, &extras);\n@@ -2689,2 +3090,0 @@\n-    __ align(CodeEntryAlignment);\n-\n@@ -2692,0 +3091,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -2694,1 +3100,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -2700,0 +3106,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -2704,0 +3113,7 @@\n+    StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -2705,1 +3121,0 @@\n-\n@@ -2707,2 +3122,0 @@\n-\n-    StubId stub_id = StubId::stubgen_data_cache_writeback_sync_id;\n@@ -2715,1 +3128,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -2723,0 +3136,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -2885,1 +3301,1 @@\n-    __ align(CodeEntryAlignment);\n+    assert(UseAES, \"need AES cryptographic extension support\");\n@@ -2887,0 +3303,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -2894,1 +3317,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -2907,0 +3330,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -2919,1 +3345,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -2921,0 +3346,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -2929,1 +3361,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -2941,0 +3373,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -2958,1 +3393,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -2960,0 +3394,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -2972,1 +3413,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -3046,0 +3487,3 @@\n+      \/\/ record the stub entry and end\n+      store_archive_data(stub_id, start, __ pc());\n+\n@@ -3063,1 +3507,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -3065,0 +3508,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -3077,1 +3527,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -3155,0 +3605,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -3191,0 +3644,7 @@\n+    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -3251,1 +3711,0 @@\n-    StubId stub_id = StubId::stubgen_counterMode_AESCrypt_id;\n@@ -3253,1 +3712,1 @@\n-    const address start = __ pc();\n+    start = __ pc();\n@@ -3438,0 +3897,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -3454,2 +3916,0 @@\n-\n-   __ align(CodeEntryAlignment);\n@@ -3457,0 +3917,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -3458,1 +3925,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -3570,0 +4037,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -3688,0 +4158,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -3691,1 +4167,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -3818,0 +4294,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -3841,1 +4320,6 @@\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -3845,1 +4329,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -3922,0 +4406,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -3946,20 +4433,6 @@\n-\n-    static const uint32_t round_consts[64] = {\n-      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,\n-      0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n-      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,\n-      0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n-      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,\n-      0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n-      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,\n-      0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n-      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,\n-      0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n-      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,\n-      0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n-      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,\n-      0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n-      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,\n-      0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2,\n-    };\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -3967,1 +4440,0 @@\n-\n@@ -3969,1 +4441,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -3990,1 +4462,1 @@\n-    __ lea(rscratch1, ExternalAddress((address)round_consts));\n+    __ lea(rscratch1, ExternalAddress((address)_sha256_round_consts));\n@@ -4051,0 +4523,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -4102,31 +4577,6 @@\n-\n-    static const uint64_t round_consts[80] = {\n-      0x428A2F98D728AE22L, 0x7137449123EF65CDL, 0xB5C0FBCFEC4D3B2FL,\n-      0xE9B5DBA58189DBBCL, 0x3956C25BF348B538L, 0x59F111F1B605D019L,\n-      0x923F82A4AF194F9BL, 0xAB1C5ED5DA6D8118L, 0xD807AA98A3030242L,\n-      0x12835B0145706FBEL, 0x243185BE4EE4B28CL, 0x550C7DC3D5FFB4E2L,\n-      0x72BE5D74F27B896FL, 0x80DEB1FE3B1696B1L, 0x9BDC06A725C71235L,\n-      0xC19BF174CF692694L, 0xE49B69C19EF14AD2L, 0xEFBE4786384F25E3L,\n-      0x0FC19DC68B8CD5B5L, 0x240CA1CC77AC9C65L, 0x2DE92C6F592B0275L,\n-      0x4A7484AA6EA6E483L, 0x5CB0A9DCBD41FBD4L, 0x76F988DA831153B5L,\n-      0x983E5152EE66DFABL, 0xA831C66D2DB43210L, 0xB00327C898FB213FL,\n-      0xBF597FC7BEEF0EE4L, 0xC6E00BF33DA88FC2L, 0xD5A79147930AA725L,\n-      0x06CA6351E003826FL, 0x142929670A0E6E70L, 0x27B70A8546D22FFCL,\n-      0x2E1B21385C26C926L, 0x4D2C6DFC5AC42AEDL, 0x53380D139D95B3DFL,\n-      0x650A73548BAF63DEL, 0x766A0ABB3C77B2A8L, 0x81C2C92E47EDAEE6L,\n-      0x92722C851482353BL, 0xA2BFE8A14CF10364L, 0xA81A664BBC423001L,\n-      0xC24B8B70D0F89791L, 0xC76C51A30654BE30L, 0xD192E819D6EF5218L,\n-      0xD69906245565A910L, 0xF40E35855771202AL, 0x106AA07032BBD1B8L,\n-      0x19A4C116B8D2D0C8L, 0x1E376C085141AB53L, 0x2748774CDF8EEB99L,\n-      0x34B0BCB5E19B48A8L, 0x391C0CB3C5C95A63L, 0x4ED8AA4AE3418ACBL,\n-      0x5B9CCA4F7763E373L, 0x682E6FF3D6B2B8A3L, 0x748F82EE5DEFB2FCL,\n-      0x78A5636F43172F60L, 0x84C87814A1F0AB72L, 0x8CC702081A6439ECL,\n-      0x90BEFFFA23631E28L, 0xA4506CEBDE82BDE9L, 0xBEF9A3F7B2C67915L,\n-      0xC67178F2E372532BL, 0xCA273ECEEA26619CL, 0xD186B8C721C0C207L,\n-      0xEADA7DD6CDE0EB1EL, 0xF57D4F7FEE6ED178L, 0x06F067AA72176FBAL,\n-      0x0A637DC5A2C898A6L, 0x113F9804BEF90DAEL, 0x1B710B35131C471BL,\n-      0x28DB77F523047D84L, 0x32CAAB7B40C72493L, 0x3C9EBE0A15C9BEBCL,\n-      0x431D67C49C100D4CL, 0x4CC5D4BECB3E42B6L, 0x597F299CFC657E2AL,\n-      0x5FCB6FAB3AD6FAECL, 0x6C44198C4A475817L\n-    };\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -4134,1 +4584,0 @@\n-\n@@ -4136,1 +4585,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -4154,1 +4603,1 @@\n-    __ lea(rscratch1, ExternalAddress((address)round_consts));\n+    __ lea(rscratch1, ExternalAddress((address)_sha512_round_consts));\n@@ -4239,0 +4688,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -4352,12 +4804,6 @@\n-\n-    static const uint64_t round_consts[24] = {\n-      0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n-      0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n-      0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n-      0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n-      0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n-      0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n-      0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n-      0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n-    };\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -4365,1 +4811,0 @@\n-\n@@ -4367,1 +4812,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -4399,1 +4844,1 @@\n-    __ lea(rscratch1, ExternalAddress((address) round_consts));\n+    __ lea(rscratch1, ExternalAddress((address) _sha3_round_consts));\n@@ -4491,0 +4936,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -4498,11 +4946,7 @@\n-    static const uint64_t round_consts[24] = {\n-      0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n-      0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n-      0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n-      0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n-      0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n-      0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n-      0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n-      0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n-    };\n-\n+    StubId stub_id = StubId::stubgen_double_keccak_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -4512,2 +4956,2 @@\n-    StubCodeMark mark(this, \"StubRoutines\", \"double_keccak\");\n-    address start = __ pc();\n+    StubCodeMark mark(this, stub_id);\n+    start = __ pc();\n@@ -4549,1 +4993,1 @@\n-    __ lea(rscratch1, ExternalAddress((address) round_consts));\n+    __ lea(rscratch1, ExternalAddress((address) _double_keccak_round_consts));\n@@ -4581,0 +5025,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -4614,0 +5061,7 @@\n+    StubId stub_id = StubId::stubgen_chacha20Block_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -4616,1 +5070,0 @@\n-    StubId stub_id = StubId::stubgen_chacha20Block_id;\n@@ -4618,1 +5071,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -4773,0 +5226,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -5261,2 +5717,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -5264,0 +5718,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -5265,1 +5726,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -5489,0 +5950,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -5499,2 +5963,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -5502,0 +5964,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -5503,1 +5972,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -5773,0 +6242,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -5786,2 +6258,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -5789,0 +6259,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -5790,1 +6267,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -5892,0 +6369,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -5903,2 +6383,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -5906,0 +6384,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -5907,1 +6392,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -5976,0 +6461,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -5988,2 +6476,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -5991,0 +6477,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -5992,1 +6485,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -6075,0 +6568,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -6091,0 +6587,7 @@\n+    StubId stub_id = StubId::stubgen_kyber12To16_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -6092,1 +6595,0 @@\n-\n@@ -6094,1 +6596,0 @@\n-    StubId stub_id = StubId::stubgen_kyber12To16_id;\n@@ -6096,1 +6597,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -6291,0 +6792,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -6300,2 +6804,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -6303,0 +6805,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -6304,1 +6813,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -6384,0 +6893,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -6547,2 +7059,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -6550,0 +7060,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -6551,1 +7068,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -6662,0 +7179,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -6754,2 +7274,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -6757,0 +7275,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -6758,1 +7283,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -6854,0 +7379,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -6867,2 +7395,0 @@\n-\n-        __ align(CodeEntryAlignment);\n@@ -6870,0 +7396,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -6871,1 +7404,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -6920,0 +7453,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -6931,2 +7467,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -6934,0 +7468,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -6935,1 +7476,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -6981,0 +7522,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -6995,2 +7539,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -6998,0 +7540,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -6999,1 +7548,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7139,0 +7688,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7278,12 +7830,6 @@\n-\n-    static const uint64_t round_consts[24] = {\n-      0x0000000000000001L, 0x0000000000008082L, 0x800000000000808AL,\n-      0x8000000080008000L, 0x000000000000808BL, 0x0000000080000001L,\n-      0x8000000080008081L, 0x8000000000008009L, 0x000000000000008AL,\n-      0x0000000000000088L, 0x0000000080008009L, 0x000000008000000AL,\n-      0x000000008000808BL, 0x800000000000008BL, 0x8000000000008089L,\n-      0x8000000000008003L, 0x8000000000008002L, 0x8000000000000080L,\n-      0x000000000000800AL, 0x800000008000000AL, 0x8000000080008081L,\n-      0x8000000000008080L, 0x0000000080000001L, 0x8000000080008008L\n-    };\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -7292,1 +7838,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7444,1 +7990,1 @@\n-    __ lea(tmp3, ExternalAddress((address) round_consts));\n+    __ lea(tmp3, ExternalAddress((address) _sha3_round_consts));\n@@ -7499,0 +8045,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7515,2 +8064,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -7518,0 +8065,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -7520,1 +8074,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7540,0 +8094,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7557,2 +8114,0 @@\n-\n-    __ align(CodeEntryAlignment);\n@@ -7560,0 +8115,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -7562,1 +8124,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7582,0 +8144,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7597,1 +8162,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -7599,0 +8163,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -7600,1 +8171,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7768,0 +8339,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7819,1 +8393,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -7821,0 +8394,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -7823,1 +8403,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7845,0 +8425,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7852,1 +8435,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -7854,0 +8436,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -7855,1 +8444,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7882,0 +8471,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7886,1 +8479,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -7888,0 +8480,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -7890,1 +8489,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -7904,0 +8503,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -7917,1 +8519,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -7919,0 +8520,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -7920,1 +8528,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -8027,0 +8635,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -8042,0 +8653,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -8043,1 +8660,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -8138,0 +8755,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -8142,0 +8762,12 @@\n+    StubId stub_id = StubId::stubgen_count_positives_id;\n+    GrowableArray<address> entries;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    \/\/ We have an extra entry for count_positives_long.\n+    assert(entry_count == 2, \"sanity check\");\n+    address start = load_archive_data(stub_id, &entries);\n+    if (start != nullptr) {\n+      assert(entries.length() == 1,\n+             \"unexpected extra entry count %d\", entries.length());\n+      count_positives_long = entries.at(0);\n+      return start;\n+    }\n@@ -8149,2 +8781,0 @@\n-\n-    StubId stub_id = StubId::stubgen_count_positives_id;\n@@ -8193,0 +8823,1 @@\n+  entries.append(count_positives_long);\n@@ -8307,0 +8938,3 @@\n+    \/\/ record the stub entry and end plus the extra entry\n+    store_archive_data(stub_id, entry, __ pc(), &entries);\n+\n@@ -8397,0 +9031,7 @@\n+    StubId stub_id = StubId::stubgen_large_array_equals_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -8412,1 +9053,0 @@\n-    StubId stub_id = StubId::stubgen_large_array_equals_id;\n@@ -8487,0 +9127,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -8495,0 +9139,27 @@\n+    StubId stub_id;\n+    switch (eltype) {\n+    case T_BOOLEAN:\n+      stub_id = StubId::stubgen_large_arrays_hashcode_boolean_id;\n+      break;\n+    case T_BYTE:\n+      stub_id = StubId::stubgen_large_arrays_hashcode_byte_id;\n+      break;\n+    case T_CHAR:\n+      stub_id = StubId::stubgen_large_arrays_hashcode_char_id;\n+      break;\n+    case T_SHORT:\n+      stub_id = StubId::stubgen_large_arrays_hashcode_short_id;\n+      break;\n+    case T_INT:\n+      stub_id = StubId::stubgen_large_arrays_hashcode_int_id;\n+      break;\n+    default:\n+      stub_id = StubId::NO_STUBID;\n+      ShouldNotReachHere();\n+    };\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -8538,22 +9209,0 @@\n-    StubId stub_id;\n-    switch (eltype) {\n-    case T_BOOLEAN:\n-      stub_id = StubId::stubgen_large_arrays_hashcode_boolean_id;\n-      break;\n-    case T_BYTE:\n-      stub_id = StubId::stubgen_large_arrays_hashcode_byte_id;\n-      break;\n-    case T_CHAR:\n-      stub_id = StubId::stubgen_large_arrays_hashcode_char_id;\n-      break;\n-    case T_SHORT:\n-      stub_id = StubId::stubgen_large_arrays_hashcode_short_id;\n-      break;\n-    case T_INT:\n-      stub_id = StubId::stubgen_large_arrays_hashcode_int_id;\n-      break;\n-    default:\n-      stub_id = StubId::NO_STUBID;\n-      ShouldNotReachHere();\n-    };\n-\n@@ -8794,0 +9443,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -8798,1 +9450,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -8800,0 +9451,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -8801,1 +9459,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -8807,0 +9465,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -8850,1 +9512,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -8852,0 +9513,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -8953,1 +9621,5 @@\n-    return entry;\n+\n+      \/\/ record the stub entry and end\n+      store_archive_data(stub_id, entry, __ pc());\n+\n+      return entry;\n@@ -8960,1 +9632,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -8962,0 +9633,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -8967,0 +9645,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -8974,1 +9656,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -8976,0 +9657,5 @@\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -8981,0 +9667,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -8985,1 +9675,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -8987,0 +9676,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -8991,1 +9687,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -9040,0 +9736,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -9051,1 +9750,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -9053,0 +9751,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -9160,0 +9865,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -9191,1 +9900,6 @@\n-\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -9193,0 +9907,1 @@\n+    StubCodeMark mark(this, stub_id);\n@@ -9227,2 +9942,0 @@\n-    StubCodeMark mark(this, stub_id);\n-\n@@ -9272,0 +9985,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -9333,0 +10050,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -9601,0 +10324,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -9631,1 +10358,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -9633,0 +10359,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -9671,0 +10404,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, entry, __ pc());\n+\n@@ -9686,1 +10423,1 @@\n-  address generate_ghash_processBlocks() {\n+  address generate_ghash_processBlocks_small() {\n@@ -9698,1 +10435,7 @@\n-    StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_small_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -9702,1 +10445,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -9762,0 +10505,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -9765,5 +10511,8 @@\n-  address generate_ghash_processBlocks_wide() {\n-    address small = generate_ghash_processBlocks();\n-\n-    StubId stub_id = StubId::stubgen_ghash_processBlocks_wide_id;\n-    StubCodeMark mark(this, stub_id);\n+  address generate_ghash_processBlocks(address small) {\n+    StubId stub_id = StubId::stubgen_ghash_processBlocks_id;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -9772,1 +10521,2 @@\n-    address start = __ pc();\n+    StubCodeMark mark(this, stub_id);\n+    start = __ pc();\n@@ -9814,1 +10564,2 @@\n-    return start;\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n@@ -9816,0 +10567,1 @@\n+    return start;\n@@ -9866,17 +10618,0 @@\n-    static const char toBase64[64] = {\n-      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n-      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n-      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '\/'\n-    };\n-\n-    static const char toBase64URL[64] = {\n-      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n-      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n-      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n-      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n-      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n-    };\n-\n-    __ align(CodeEntryAlignment);\n@@ -9884,0 +10619,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -9885,1 +10627,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -9905,1 +10647,1 @@\n-    __ lea(codec, ExternalAddress((address) toBase64));\n+    __ lea(codec, ExternalAddress((address) _encodeBlock_toBase64));\n@@ -9907,1 +10649,1 @@\n-    __ lea(codec, ExternalAddress((address) toBase64URL));\n+    __ lea(codec, ExternalAddress((address) _encodeBlock_toBase64URL));\n@@ -9960,0 +10702,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10081,71 +10826,0 @@\n-    \/\/ Non-SIMD lookup tables are mostly dumped from fromBase64 array used in java.util.Base64,\n-    \/\/ except the trailing character '=' is also treated illegal value in this intrinsic. That\n-    \/\/ is java.util.Base64.fromBase64['='] = -2, while fromBase(URL)64ForNoSIMD['='] = 255 here.\n-    static const uint8_t fromBase64ForNoSIMD[256] = {\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n-       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n-       15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n-      255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n-       41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-    };\n-\n-    static const uint8_t fromBase64URLForNoSIMD[256] = {\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n-       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n-       15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n-      255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n-       41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-    };\n-\n-    \/\/ A legal value of base64 code is in range [0, 127].  We need two lookups\n-    \/\/ with tbl\/tbx and combine them to get the decode data. The 1st table vector\n-    \/\/ lookup use tbl, out of range indices are set to 0 in destination. The 2nd\n-    \/\/ table vector lookup use tbx, out of range indices are unchanged in\n-    \/\/ destination. Input [64..126] is mapped to index [65, 127] in second lookup.\n-    \/\/ The value of index 64 is set to 0, so that we know that we already get the\n-    \/\/ decoded data with the 1st lookup.\n-    static const uint8_t fromBase64ForSIMD[128] = {\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n-       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n-        0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n-       14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n-      255u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n-       40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n-    };\n-\n-    static const uint8_t fromBase64URLForSIMD[128] = {\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n-      255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n-       52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n-        0u, 255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,\n-       14u,  15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,\n-       63u, 255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,\n-       40u,  41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u,\n-    };\n-\n-    __ align(CodeEntryAlignment);\n@@ -10153,0 +10827,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -10154,1 +10835,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10181,1 +10862,1 @@\n-    __ lea(nosimd_codec, ExternalAddress((address) fromBase64ForNoSIMD));\n+    __ lea(nosimd_codec, ExternalAddress((address) _decodeBlock_fromBase64ForNoSIMD));\n@@ -10183,1 +10864,1 @@\n-    __ lea(nosimd_codec, ExternalAddress((address) fromBase64URLForNoSIMD));\n+    __ lea(nosimd_codec, ExternalAddress((address) _decodeBlock_fromBase64URLForNoSIMD));\n@@ -10228,1 +10909,1 @@\n-    __ lea(simd_codec, ExternalAddress((address) fromBase64ForSIMD));\n+    __ lea(simd_codec, ExternalAddress((address) _decodeBlock_fromBase64ForSIMD));\n@@ -10230,1 +10911,1 @@\n-    __ lea(simd_codec, ExternalAddress((address) fromBase64URLForSIMD));\n+    __ lea(simd_codec, ExternalAddress((address) _decodeBlock_fromBase64URLForSIMD));\n@@ -10263,0 +10944,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10268,1 +10952,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -10270,0 +10953,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -10271,1 +10961,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10276,0 +10966,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10281,0 +10974,14 @@\n+    GrowableArray<address> entries;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == Klass::SECONDARY_SUPERS_TABLE_SIZE, \"sanity check\");\n+    address start = load_archive_data(stub_id, &entries);\n+    if (start != nullptr) {\n+      assert(entries.length() == Klass::SECONDARY_SUPERS_TABLE_SIZE - 1,\n+             \"unexpected extra entry count %d\", entries.length());\n+      StubRoutines::_lookup_secondary_supers_table_stubs[0] = start;\n+      for (int slot = 1; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+        StubRoutines::_lookup_secondary_supers_table_stubs[0] = entries.at(slot - 1);\n+      }\n+      return;\n+    }\n+\n@@ -10295,1 +11002,7 @@\n-      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+      address next_entry = __ pc();\n+      StubRoutines::_lookup_secondary_supers_table_stubs[slot] = next_entry;\n+      if (slot == 0) {\n+        start = next_entry;\n+      } else {\n+        entries.append(next_entry);\n+      }\n@@ -10305,0 +11018,2 @@\n+    \/\/ record the stub entry and end plus all the auxiliary entries\n+    store_archive_data(stub_id, start, __ pc(), &entries);\n@@ -10310,0 +11025,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -10311,2 +11032,1 @@\n-\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10324,0 +11044,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10463,1 +11186,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -10465,2 +11187,26 @@\n-    StubCodeMark mark(this, stub_id);\n-    address first_entry = __ pc();\n+    GrowableArray<address> entries;\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    address start = load_archive_data(stub_id, &entries);\n+    if (start != nullptr) {\n+      assert(entries.length() == entry_count - 1,\n+             \"unexpected extra entry count %d\", entries.length());\n+      aarch64_atomic_fetch_add_4_impl = (aarch64_atomic_stub_t)start;\n+      int idx = 0;\n+      aarch64_atomic_fetch_add_8_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_fetch_add_4_relaxed_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_fetch_add_8_relaxed_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_xchg_4_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_xchg_8_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_1_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_4_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_8_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_1_relaxed_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_4_relaxed_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_8_relaxed_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_4_release_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_8_release_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_4_seq_cst_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      aarch64_atomic_cmpxchg_8_seq_cst_impl = (aarch64_atomic_stub_t)entries.at(idx++);\n+      assert(idx == entries.length(), \"sanity!\");\n+      return;\n+    }\n@@ -10468,0 +11214,5 @@\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, stub_id);\n+    start = __ pc();\n+    address end;\n+    {\n@@ -10471,0 +11222,1 @@\n+\n@@ -10478,0 +11230,1 @@\n+\n@@ -10485,1 +11238,2 @@\n-    AtomicStubMark mark_xchg_8_impl(_masm, &aarch64_atomic_xchg_8_impl);\n+\n+    AtomicStubMark mark_xchg_8(_masm, &aarch64_atomic_xchg_8_impl);\n@@ -10491,0 +11245,1 @@\n+\n@@ -10493,0 +11248,1 @@\n+\n@@ -10500,0 +11256,1 @@\n+\n@@ -10503,0 +11260,1 @@\n+\n@@ -10510,0 +11268,1 @@\n+\n@@ -10517,0 +11276,1 @@\n+\n@@ -10521,1 +11281,30 @@\n-    ICache::invalidate_range(first_entry, __ pc() - first_entry);\n+    end = __ pc();\n+\n+    ICache::invalidate_range(start, end - start);\n+    \/\/ exit block to force update of AtomicStubMark targets\n+    }\n+\n+    assert(start == (address)aarch64_atomic_fetch_add_4_impl,\n+           \"atomic stub should be at start of buffer\");\n+    \/\/ record the stub start and end plus all the entries saved by the\n+    \/\/ AtomicStubMark destructor\n+    entries.append((address)aarch64_atomic_fetch_add_8_impl);\n+    entries.append((address)aarch64_atomic_fetch_add_4_relaxed_impl);\n+    entries.append((address)aarch64_atomic_fetch_add_8_relaxed_impl);\n+    entries.append((address)aarch64_atomic_xchg_4_impl);\n+    entries.append((address)aarch64_atomic_xchg_8_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_1_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_4_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_8_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_1_relaxed_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_4_relaxed_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_8_relaxed_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_4_release_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_8_release_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_4_seq_cst_impl);\n+    entries.append((address)aarch64_atomic_cmpxchg_8_seq_cst_impl);\n+\n+    assert(entries.length() == entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+\n+    store_archive_data(stub_id, start, end, &entries);\n@@ -10625,0 +11414,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -10626,1 +11421,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10628,0 +11423,4 @@\n+\n+    \/\/ record the stub start and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10636,0 +11435,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -10637,1 +11442,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10641,0 +11446,3 @@\n+    \/\/ record the stub start and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10648,0 +11456,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -10649,1 +11463,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10653,0 +11467,3 @@\n+    \/\/ record the stub start and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10659,0 +11476,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -10660,1 +11483,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10685,0 +11508,3 @@\n+    \/\/ record the stub start and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10740,1 +11566,0 @@\n-    __ align(CodeEntryAlignment);\n@@ -10742,0 +11567,7 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n+    __ align(CodeEntryAlignment);\n@@ -10743,1 +11575,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10851,0 +11683,3 @@\n+    \/\/ record the stub start and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10857,0 +11692,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -10858,1 +11699,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10867,0 +11708,3 @@\n+    \/\/ record the stub start and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -10875,0 +11719,6 @@\n+    int entry_count = StubInfo::entry_count(stub_id);\n+    assert(entry_count == 1, \"sanity check\");\n+    address start = load_archive_data(stub_id);\n+    if (start != nullptr) {\n+      return start;\n+    }\n@@ -10876,1 +11726,1 @@\n-    address start = __ pc();\n+    start = __ pc();\n@@ -10890,0 +11740,3 @@\n+    \/\/ record the stub start and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -11918,1 +12771,2 @@\n-      StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks_wide();\n+      StubRoutines::aarch64::_ghash_processBlocks_small = generate_ghash_processBlocks_small();\n+      StubRoutines::_ghash_processBlocks = generate_ghash_processBlocks(StubRoutines::aarch64::_ghash_processBlocks_small);\n@@ -11965,1 +12819,1 @@\n-  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) : StubCodeGenerator(code, blob_id, stub_data) {\n@@ -11987,0 +12841,18 @@\n+\n+#if INCLUDE_CDS\n+  static void init_AOTAddressTable(GrowableArray<address>& external_addresses) {\n+    \/\/ external data defined in this file\n+#define ADD(addr) external_addresses.append((address)addr);\n+    ADD(_sha256_round_consts);\n+    ADD(_sha512_round_consts);\n+    ADD(_sha3_round_consts);\n+    ADD(_double_keccak_round_consts);\n+    ADD(_encodeBlock_toBase64);\n+    ADD(_encodeBlock_toBase64URL);\n+    ADD(_decodeBlock_fromBase64ForNoSIMD);\n+    ADD(_decodeBlock_fromBase64URLForNoSIMD);\n+    ADD(_decodeBlock_fromBase64ForSIMD);\n+    ADD(_decodeBlock_fromBase64URLForSIMD);\n+#undef ADD\n+  }\n+#endif \/\/ INCLUDE_CDS\n@@ -11989,2 +12861,2 @@\n-void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n-  StubGenerator g(code, blob_id);\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) {\n+  StubGenerator g(code, blob_id, stub_data);\n@@ -11993,0 +12865,5 @@\n+#if INCLUDE_CDS\n+void StubGenerator_init_AOTAddressTable(GrowableArray<address>& addresses) {\n+  StubGenerator::init_AOTAddressTable(addresses);\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1262,"deletions":385,"binary":false,"changes":1647,"status":"modified"},{"patch":"@@ -416,0 +416,35 @@\n+\n+#if INCLUDE_CDS\n+extern void StubGenerator_init_AOTAddressTable(GrowableArray<address>& addresses);\n+\n+void StubRoutines::init_AOTAddressTable() {\n+  ResourceMark rm;\n+  GrowableArray<address> external_addresses;\n+  \/\/ publish static addresses referred to by aarch64 generator\n+  \/\/ n.b. we have to use use an extern call here because class\n+  \/\/ StubGenerator, which provides the static method that knows how to\n+  \/\/ add the relevant addresses, is declared in a source file rather\n+  \/\/ than in a separately includeable header.\n+  StubGenerator_init_AOTAddressTable(external_addresses);\n+  \/\/ publish external data addresses defined in nested aarch64 class\n+  StubRoutines::aarch64::init_AOTAddressTable(external_addresses);\n+  AOTCodeCache::publish_external_addresses(external_addresses);\n+}\n+\n+\n+#define ADD(addr) external_addresses.append((address)addr);\n+\n+void StubRoutines::aarch64::init_AOTAddressTable(GrowableArray<address>& external_addresses) {\n+  ADD(_kyberConsts);\n+  ADD(_dilithiumConsts);\n+  ADD(_crc_table);\n+  ADD(_adler_table);\n+  ADD(_npio2_hw);\n+  ADD(_dsin_coef);\n+  ADD(_dcos_coef);\n+  ADD(_two_over_pi);\n+  ADD(_pio2);\n+}\n+\n+#undef ADD\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.cpp","additions":35,"deletions":0,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -113,0 +113,5 @@\n+#if INCLUDE_CDS\n+  static void init_AOTAddressTable(GrowableArray<address>& external_addresses);\n+#endif \/\/ INCLUDE_CDS\n+\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubRoutines_aarch64.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3214,1 +3214,1 @@\n-  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) : StubCodeGenerator(code, blob_id, stub_data) {\n@@ -3238,2 +3238,2 @@\n-void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n-  StubGenerator g(code, blob_id);\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) {\n+  StubGenerator g(code, blob_id, stub_data);\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -42,0 +42,6 @@\n+\n+#if INCLUDE_CDS\n+\/\/ nothing to do for arm\n+void StubRoutines::init_AOTAddressTable() {\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/arm\/stubRoutines_arm.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5098,1 +5098,1 @@\n-  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData *stub_data) : StubCodeGenerator(code, blob_id, stub_data) {\n@@ -5122,2 +5122,2 @@\n-void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n-  StubGenerator g(code, blob_id);\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData *stub_data) {\n+  StubGenerator g(code, blob_id, stub_data);\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -186,0 +186,6 @@\n+\n+#if INCLUDE_CDS\n+\/\/ nothing to do for ppc\n+void StubRoutines::init_AOTAddressTable() {\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/ppc\/stubRoutines_ppc_64.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7353,1 +7353,1 @@\n-  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) : StubCodeGenerator(code, blob_id, stub_data) {\n@@ -7377,2 +7377,2 @@\n-void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n-  StubGenerator g(code, blob_id);\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) {\n+  StubGenerator g(code, blob_id, stub_data);\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -504,0 +504,6 @@\n+\n+#if INCLUDE_CDS\n+\/\/ nothing to do for riscv\n+void StubRoutines::init_AOTAddressTable() {\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/riscv\/stubRoutines_riscv.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -3425,1 +3425,1 @@\n-  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) : StubCodeGenerator(code, blob_id, stub_data) {\n@@ -3482,2 +3482,2 @@\n-void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n-  StubGenerator g(code, blob_id);\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) {\n+  StubGenerator g(code, blob_id, stub_data);\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -739,0 +739,6 @@\n+\n+#if INCLUDE_CDS\n+\/\/ nothing to do for s390\n+void StubRoutines::init_AOTAddressTable() {\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/s390\/stubRoutines_s390.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -72,0 +72,11 @@\n+#if INCLUDE_CDS\n+\/\/ publish external addresses defined in this file\n+void LIR_Assembler::init_AOTAddressTable(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(float_signmask_pool);\n+  ADD(double_signmask_pool);\n+  ADD(float_signflip_pool);\n+  ADD(double_signflip_pool);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -61,0 +61,3 @@\n+#if INCLUDE_CDS\n+  void static init_AOTAddressTable(GrowableArray<address>& external_addresses);\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/c1_LIRAssembler_x86.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -5774,1 +5774,1 @@\n-    if (Universe::heap() != nullptr) {\n+    if (Universe::heap() != nullptr && !AOTCodeCache::is_on_for_dump()) {\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -245,1 +245,0 @@\n-  address pshuffle_byte_flip_mask = StubRoutines::x86::pshuffle_byte_flip_mask_addr();\n@@ -256,1 +255,1 @@\n-  movdqu(shuf_mask, ExternalAddress(pshuffle_byte_flip_mask));\n+  movdqu(shuf_mask, ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_addr()));\n@@ -664,2 +663,0 @@\n-  address pshuffle_byte_flip_mask = StubRoutines::x86::pshuffle_byte_flip_mask_addr();\n-  address pshuffle_byte_flip_mask_addr = nullptr;\n@@ -794,4 +791,8 @@\n-  pshuffle_byte_flip_mask_addr = pshuffle_byte_flip_mask;\n-  vmovdqu(BYTE_FLIP_MASK, ExternalAddress(pshuffle_byte_flip_mask_addr +  0)); \/\/ [PSHUFFLE_BYTE_FLIP_MASK wrt rip]\n-  vmovdqu(SHUF_00BA,      ExternalAddress(pshuffle_byte_flip_mask_addr + 32)); \/\/ [_SHUF_00BA wrt rip]\n-  vmovdqu(SHUF_DC00,      ExternalAddress(pshuffle_byte_flip_mask_addr + 64)); \/\/ [_SHUF_DC00 wrt rip]\n+  \/\/ the three successive pshuffle_byte_flip_mask stub entries should\n+  \/\/ be offset by 32 bytes\n+  assert(StubRoutines::x86::pshuffle_byte_flip_mask_addr() + 32 == StubRoutines::x86::pshuffle_byte_flip_mask_00ba_addr(), \"sanity\");\n+  assert(StubRoutines::x86::pshuffle_byte_flip_mask_addr() + 64 == StubRoutines::x86::pshuffle_byte_flip_mask_dc00_addr(), \"sanity\");\n+\n+  vmovdqu(BYTE_FLIP_MASK, ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_addr())); \/\/ [PSHUFFLE_BYTE_FLIP_MASK wrt rip]\n+  vmovdqu(SHUF_00BA,      ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_00ba_addr())); \/\/ [_SHUF_00BA wrt rip]\n+  vmovdqu(SHUF_DC00,      ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_dc00_addr())); \/\/ [_SHUF_DC00 wrt rip]\n@@ -956,5 +957,3 @@\n-\n-  pshuffle_byte_flip_mask_addr = pshuffle_byte_flip_mask;\n-  vmovdqu(BYTE_FLIP_MASK, ExternalAddress(pshuffle_byte_flip_mask_addr +  0)); \/\/ [PSHUFFLE_BYTE_FLIP_MASK wrt rip]\n-  vmovdqu(SHUF_00BA,      ExternalAddress(pshuffle_byte_flip_mask_addr + 32)); \/\/ [_SHUF_00BA wrt rip]\n-  vmovdqu(SHUF_DC00,      ExternalAddress(pshuffle_byte_flip_mask_addr + 64)); \/\/ [_SHUF_DC00 wrt rip]\n+  vmovdqu(BYTE_FLIP_MASK, ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_addr())); \/\/ [PSHUFFLE_BYTE_FLIP_MASK wrt rip]\n+  vmovdqu(SHUF_00BA,      ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_00ba_addr())); \/\/ [_SHUF_00BA wrt rip]\n+  vmovdqu(SHUF_DC00,      ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_dc00_addr())); \/\/ [_SHUF_DC00 wrt rip]\n@@ -1349,3 +1348,8 @@\n-    pshuffle_byte_flip_mask_addr = pshuffle_byte_flip_mask_sha512;\n-    vmovdqu(BYTE_FLIP_MASK, ExternalAddress(pshuffle_byte_flip_mask_addr +  0)); \/\/ PSHUFFLE_BYTE_FLIP_MASK wrt rip\n-    vmovdqu(YMM_MASK_LO,    ExternalAddress(pshuffle_byte_flip_mask_addr + 32));\n+    StubRoutines::x86::pshuffle_byte_flip_mask_addr_sha512();\n+\n+    \/\/ the two successive pshuffle_byte_flip_mask_sha512 stub entries should\n+    \/\/ be offset by 32 bytes\n+    assert(StubRoutines::x86::pshuffle_byte_flip_mask_addr_sha512() + 32 == StubRoutines::x86::pshuffle_byte_flip_mask_ymm_lo_addr_sha512(), \"sanity\");\n+\n+    vmovdqu(BYTE_FLIP_MASK, ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_addr_sha512())); \/\/ PSHUFFLE_BYTE_FLIP_MASK wrt rip\n+    vmovdqu(YMM_MASK_LO,    ExternalAddress(StubRoutines::x86::pshuffle_byte_flip_mask_ymm_lo_addr_sha512())); \/\/ MASK_YMM_LO wrt rip\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86_sha.cpp","additions":20,"deletions":16,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -164,0 +164,6 @@\n+  do_arch_entry(x86, compiler, pshuffle_byte_flip_mask,                 \\\n+                pshuffle_byte_flip_mask_00ba_addr,                      \\\n+                pshuffle_byte_flip_mask_00ba_addr)                      \\\n+  do_arch_entry(x86, compiler, pshuffle_byte_flip_mask,                 \\\n+                pshuffle_byte_flip_mask_dc00_addr,                      \\\n+                pshuffle_byte_flip_mask_dc00_addr)                      \\\n@@ -174,0 +180,3 @@\n+  do_arch_entry(x86, compiler, pshuffle_byte_flip_mask_sha512,          \\\n+                pshuffle_byte_flip_mask_ymm_lo_addr_sha512,             \\\n+                pshuffle_byte_flip_mask_ymm_lo_addr_sha512)             \\\n","filename":"src\/hotspot\/cpu\/x86\/stubDeclarations_x86.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -191,0 +191,10 @@\n+  GrowableArray<address> entries;\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 2, \"sanity check\");\n+  address start = load_archive_data(stub_id, &entries);\n+  if (start != nullptr) {\n+    assert(entries.length() == 1, \"expected 1 extra entry\");\n+    return_address = entries.at(0);\n+    return start;\n+  }\n+\n@@ -192,1 +202,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -301,0 +311,1 @@\n+  entries.append(return_address);\n@@ -397,0 +408,3 @@\n+  \/\/ record the stub entry and end plus the auxiliary entry\n+  store_archive_data(stub_id, start, __ pc(), &entries);\n+\n@@ -414,0 +428,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+\n@@ -415,1 +436,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -445,1 +466,3 @@\n-  __ lea(rscratch1, ExternalAddress((address)__FILE__));\n+  \/\/ special case -- add file name string to AOT address table\n+  address file = (address)AOTCodeCache::add_C_string(__FILE__);\n+  __ lea(rscratch1, ExternalAddress(file));\n@@ -454,0 +477,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -470,0 +496,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -471,1 +503,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -524,0 +556,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -534,0 +569,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -535,1 +576,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -540,0 +581,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -553,0 +597,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -554,1 +604,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -577,0 +627,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -582,0 +635,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -585,1 +644,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -616,0 +675,3 @@\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -621,0 +683,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -623,1 +691,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -654,0 +722,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -659,0 +730,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -662,1 +739,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -702,0 +779,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -707,0 +787,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -710,1 +796,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -750,0 +836,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -754,1 +843,0 @@\n-  __ align64();\n@@ -756,0 +844,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -757,1 +852,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -768,0 +863,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -772,1 +870,0 @@\n-  __ align64();\n@@ -774,0 +871,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -775,1 +879,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -786,0 +890,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -790,1 +897,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -792,0 +898,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -793,1 +906,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -848,0 +961,4 @@\n+\n+    \/\/ record the stub entry and end\n+    store_archive_data(stub_id, start, __ pc());\n+\n@@ -852,1 +969,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -854,0 +970,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -855,1 +978,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -866,0 +989,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -870,1 +996,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -872,0 +997,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -873,1 +1005,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -884,0 +1016,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -888,1 +1023,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -890,0 +1024,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -891,1 +1032,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -902,0 +1043,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -906,1 +1050,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -908,0 +1051,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -909,1 +1059,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -920,0 +1070,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -924,1 +1077,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -926,0 +1078,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -927,1 +1086,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -934,0 +1093,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -938,0 +1100,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -940,1 +1108,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -945,0 +1113,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -960,0 +1131,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -962,1 +1139,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1000,0 +1177,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1015,0 +1195,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1017,1 +1203,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1053,0 +1239,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1057,0 +1246,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1059,1 +1254,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1070,0 +1265,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1074,1 +1272,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1076,0 +1273,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1077,1 +1281,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1088,0 +1292,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1092,0 +1299,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1094,1 +1307,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1105,0 +1318,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1113,0 +1329,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1115,1 +1337,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1138,0 +1360,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1159,0 +1384,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1160,1 +1391,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1238,0 +1469,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1353,3 +1587,0 @@\n-\n-  __ align(CodeEntryAlignment);\n-\n@@ -1357,0 +1588,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1359,1 +1597,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1366,0 +1604,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1371,3 +1612,0 @@\n-\n-  __ align(CodeEntryAlignment);\n-\n@@ -1375,0 +1613,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1381,1 +1626,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1391,0 +1636,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1408,0 +1656,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1410,1 +1664,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1440,0 +1694,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1444,1 +1701,0 @@\n-  __ align64();\n@@ -1446,0 +1702,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -1447,1 +1710,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1452,0 +1715,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1456,1 +1722,0 @@\n-  __ align64();\n@@ -1458,0 +1723,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -1459,1 +1731,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1464,0 +1736,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1481,0 +1756,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1483,1 +1764,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1512,0 +1793,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1515,2 +1799,1 @@\n-address StubGenerator::generate_pshuffle_byte_flip_mask() {\n-  __ align64();\n+address StubGenerator::generate_pshuffle_byte_flip_mask(address& entry_00ba, address& entry_dc00) {\n@@ -1518,0 +1801,14 @@\n+  GrowableArray<address> entries;\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 3, \"sanity check\");\n+  address start = load_archive_data(stub_id, &entries);\n+  if (start != nullptr) {\n+    assert(entries.length() == entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    entry_00ba = entries.at(0);\n+    entry_dc00 = entries.at(1);\n+    assert(VM_Version::supports_avx2() == (entry_00ba != nullptr && entry_dc00 != nullptr),\n+           \"entries cannot be null when avx2 is enabled\");\n+    return start;\n+  }\n+  __ align64();\n@@ -1519,2 +1816,3 @@\n-  address start = __ pc();\n-\n+  start = __ pc();\n+  address entry2 = nullptr;\n+  address entry3 = nullptr;\n@@ -1528,0 +1826,1 @@\n+    entry2 = __ pc();\n@@ -1533,0 +1832,1 @@\n+    entry3 = __ pc();\n@@ -1538,0 +1838,8 @@\n+  \/\/ have to track the 2nd and 3rd entries even if they are null\n+  entry_00ba = entry2;\n+  entries.push(entry_00ba);\n+  entry_dc00 = entry3;\n+  entries.push(entry_dc00);\n+\n+  \/\/ record the stub entry and end plus all the auxiliary entries\n+  store_archive_data(stub_id, start, __ pc(), &entries);\n@@ -1543,2 +1851,1 @@\n-address StubGenerator::generate_pshuffle_byte_flip_mask_sha512() {\n-  __ align32();\n+address StubGenerator::generate_pshuffle_byte_flip_mask_sha512(address& entry_ymm_lo) {\n@@ -1546,0 +1853,13 @@\n+  GrowableArray<address> entries;\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 2, \"sanity check\");\n+  address start = load_archive_data(stub_id, &entries);\n+  if (start != nullptr) {\n+    assert(entries.length() == entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    entry_ymm_lo = entries.at(0);\n+    assert(VM_Version::supports_avx2() == (entry_ymm_lo != nullptr),\n+           \"entry cannot be null when avx2 is enabled\");\n+    return start;\n+  }\n+  __ align32();\n@@ -1547,2 +1867,2 @@\n-  address start = __ pc();\n-\n+  start = __ pc();\n+  address entry2 = nullptr;\n@@ -1554,0 +1874,2 @@\n+    \/\/ capture 2nd entry\n+    entry2 = __ pc();\n@@ -1559,0 +1881,5 @@\n+  \/\/ have to track the 2nd entry even if it is null\n+  entry_ymm_lo = entry2;\n+  entries.push(entry2);\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc(), &entries);\n@@ -1578,0 +1905,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1580,1 +1913,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1615,0 +1948,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1632,0 +1968,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1634,1 +1976,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1663,0 +2005,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1667,1 +2012,0 @@\n-  __ align64();\n@@ -1669,0 +2013,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -1670,1 +2021,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1683,0 +2034,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1687,1 +2041,0 @@\n-  __ align32();\n@@ -1689,0 +2042,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align32();\n@@ -1690,1 +2050,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1697,0 +2057,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1701,1 +2064,0 @@\n-  __ align32();\n@@ -1703,0 +2065,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align32();\n@@ -1704,1 +2073,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1711,0 +2080,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1715,1 +2087,0 @@\n-  __ align32();\n@@ -1717,0 +2088,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align32();\n@@ -1718,1 +2096,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1731,0 +2109,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1735,1 +2116,0 @@\n-  __ align64();\n@@ -1737,0 +2117,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -1738,1 +2125,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1760,0 +2147,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1769,1 +2159,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1771,0 +2160,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1772,1 +2168,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2147,0 +2543,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2152,1 +2551,0 @@\n-  __ align64();\n@@ -2154,0 +2552,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2155,1 +2560,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2168,0 +2573,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2172,1 +2580,0 @@\n-  __ align64();\n@@ -2174,0 +2581,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2175,1 +2589,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2188,0 +2602,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2191,1 +2608,0 @@\n-  __ align64();\n@@ -2193,0 +2609,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2194,1 +2617,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2207,0 +2630,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2211,1 +2637,0 @@\n-  __ align64();\n@@ -2213,0 +2638,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2214,1 +2646,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2227,0 +2659,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2231,1 +2666,0 @@\n-  __ align64();\n@@ -2233,0 +2667,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2234,1 +2675,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2247,0 +2688,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2251,1 +2695,0 @@\n-  __ align64();\n@@ -2253,0 +2696,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2254,1 +2704,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2267,0 +2717,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2271,1 +2724,0 @@\n-  __ align64();\n@@ -2273,0 +2725,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2274,1 +2733,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2287,0 +2746,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2291,1 +2753,0 @@\n-  __ align64();\n@@ -2293,0 +2754,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2294,1 +2762,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2307,0 +2775,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2311,1 +2782,0 @@\n-  __ align64();\n@@ -2313,0 +2783,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2314,1 +2791,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2342,0 +2819,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2346,1 +2826,0 @@\n-  __ align64();\n@@ -2348,0 +2827,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align64();\n@@ -2349,1 +2835,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2383,0 +2869,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2388,0 +2877,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -2389,1 +2884,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2458,0 +2953,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2469,1 +2967,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -2471,0 +2968,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -2472,1 +2976,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2985,0 +3489,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3003,1 +3510,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3005,0 +3511,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3007,1 +3520,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3042,0 +3555,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3060,1 +3576,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3062,0 +3577,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3063,1 +3585,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3123,0 +3645,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3141,1 +3666,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3143,0 +3667,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3144,1 +3675,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3182,0 +3713,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3198,1 +3732,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3200,0 +3733,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3201,1 +3741,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3235,0 +3775,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3250,1 +3793,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3252,0 +3794,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3253,1 +3802,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3282,0 +3831,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3286,1 +3838,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3288,0 +3839,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3289,1 +3847,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3359,0 +3917,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3376,1 +3937,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3378,0 +3938,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3379,1 +3946,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3414,0 +3981,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3418,1 +3988,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3420,0 +3989,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3421,1 +3997,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3537,0 +4113,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3554,1 +4133,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -3556,0 +4134,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -3557,1 +4142,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3662,0 +4247,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3711,0 +4299,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -3713,1 +4307,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3723,0 +4317,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3737,0 +4334,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -3739,1 +4342,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3749,0 +4352,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3778,0 +4384,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -3779,1 +4391,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3892,0 +4504,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3912,0 +4527,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -3913,1 +4534,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3937,0 +4558,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3943,0 +4567,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -3944,1 +4574,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3956,0 +4586,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -3964,0 +4597,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -3965,1 +4604,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3984,0 +4623,13 @@\n+  GrowableArray<address> entries;\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == Klass::SECONDARY_SUPERS_TABLE_SIZE, \"sanity check\");\n+  address start = load_archive_data(stub_id, &entries);\n+  if (start != nullptr) {\n+    assert(entries.length() == Klass::SECONDARY_SUPERS_TABLE_SIZE - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    StubRoutines::_lookup_secondary_supers_table_stubs[0] = start;\n+    for (int slot = 1; slot < Klass::SECONDARY_SUPERS_TABLE_SIZE; slot++) {\n+      StubRoutines::_lookup_secondary_supers_table_stubs[0] = entries.at(slot - 1);\n+    }\n+    return;\n+  }\n@@ -3992,1 +4644,7 @@\n-    StubRoutines::_lookup_secondary_supers_table_stubs[slot] = __ pc();\n+    address next_entry = __ pc();\n+    if (slot == 0) {\n+      start = next_entry;\n+    } else {\n+      entries.append(next_entry);\n+    }\n+    StubRoutines::_lookup_secondary_supers_table_stubs[slot] = next_entry;\n@@ -3999,0 +4657,3 @@\n+\n+  \/\/ record the stub entry and end plus all the auxiliary entries\n+  store_archive_data(stub_id, start, __ pc(), &entries);\n@@ -4004,0 +4665,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -4005,2 +4672,1 @@\n-\n-  address start = __ pc();\n+  start = __ pc();\n@@ -4028,0 +4694,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -4235,0 +4904,2 @@\n+    address entry2 = nullptr;\n+    address entry3 = nullptr;\n@@ -4243,1 +4914,3 @@\n-    StubRoutines::x86::_pshuffle_byte_flip_mask_addr = generate_pshuffle_byte_flip_mask();\n+    StubRoutines::x86::_pshuffle_byte_flip_mask_addr = generate_pshuffle_byte_flip_mask(entry2, entry3);\n+    StubRoutines::x86::_pshuffle_byte_flip_mask_00ba_addr = entry2;\n+    StubRoutines::x86::_pshuffle_byte_flip_mask_dc00_addr = entry3;\n@@ -4249,0 +4922,1 @@\n+    address entry2 = nullptr;\n@@ -4250,1 +4924,2 @@\n-    StubRoutines::x86::_pshuffle_byte_flip_mask_addr_sha512 = generate_pshuffle_byte_flip_mask_sha512();\n+    StubRoutines::x86::_pshuffle_byte_flip_mask_addr_sha512 = generate_pshuffle_byte_flip_mask_sha512(entry2);\n+    StubRoutines::x86::_pshuffle_byte_flip_mask_ymm_lo_addr_sha512 = entry2;\n@@ -4328,1 +5003,1 @@\n-StubGenerator::StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+StubGenerator::StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) : StubCodeGenerator(code, blob_id, stub_data) {\n@@ -4351,2 +5026,29 @@\n-void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n-  StubGenerator g(code, blob_id);\n+#if INCLUDE_CDS\n+\/\/ publish addresses of static data defined in this file and in other\n+\/\/ stubgen stub generator files\n+void StubGenerator::init_AOTAddressTable(GrowableArray<address>& external_addresses) {\n+  init_AOTAddressTable_adler(external_addresses);\n+  init_AOTAddressTable_aes(external_addresses);\n+  init_AOTAddressTable_cbrt(external_addresses);\n+  init_AOTAddressTable_chacha(external_addresses);\n+  \/\/ constants publishes for all of address use by cos and almost all of sin\n+  init_AOTAddressTable_constants(external_addresses);\n+  init_AOTAddressTable_dilithium(external_addresses);\n+  init_AOTAddressTable_exp(external_addresses);\n+  init_AOTAddressTable_fmod(external_addresses);\n+  init_AOTAddressTable_ghash(external_addresses);\n+  init_AOTAddressTable_kyber(external_addresses);\n+  init_AOTAddressTable_log(external_addresses);\n+  init_AOTAddressTable_poly1305(external_addresses);\n+  init_AOTAddressTable_poly_mont(external_addresses);\n+  init_AOTAddressTable_pow(external_addresses);\n+  init_AOTAddressTable_sha3(external_addresses);\n+  init_AOTAddressTable_sin(external_addresses);\n+  init_AOTAddressTable_sinh(external_addresses);\n+  init_AOTAddressTable_tan(external_addresses);\n+  init_AOTAddressTable_tanh(external_addresses);\n+}\n+#endif \/\/ INCLUDE_CDS\n+\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data) {\n+  StubGenerator g(code, blob_id, stub_data);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":828,"deletions":126,"binary":false,"changes":954,"status":"modified"},{"patch":"@@ -306,1 +306,1 @@\n-  address generate_pshuffle_byte_flip_mask_sha512();\n+  address generate_pshuffle_byte_flip_mask_sha512(address& entry_ymm_lo);\n@@ -310,1 +310,1 @@\n-  address generate_pshuffle_byte_flip_mask();\n+  address generate_pshuffle_byte_flip_mask(address& entry_00ba, address& entry_dc0);\n@@ -640,0 +640,23 @@\n+#if INCLUDE_CDS\n+  static void init_AOTAddressTable_adler(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_aes(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_cbrt(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_chacha(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_constants(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_dilithium(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_exp(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_fmod(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_ghash(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_kyber(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_log(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_poly1305(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_poly_mont(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_pow(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_sha3(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_sin(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_sinh(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_tan(GrowableArray<address>& external_addresses);\n+  static void init_AOTAddressTable_tanh(GrowableArray<address>& external_addresses);\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -641,1 +664,4 @@\n-  StubGenerator(CodeBuffer* code, BlobId blob_id);\n+  StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data);\n+#if INCLUDE_CDS\n+  static void init_AOTAddressTable(GrowableArray<address>& external_addresses);\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":29,"deletions":3,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -70,0 +70,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -71,1 +77,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -337,0 +343,2 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n@@ -341,0 +349,10 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_adler(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)(addr))\n+  ADD(ADLER32_ASCALE_TABLE);\n+  ADD(ADLER32_SHUF0_TABLE);\n+  ADD(ADLER32_SHUF1_TABLE);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_adler.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -251,1 +251,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -253,0 +252,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -254,1 +260,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -320,0 +326,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -338,1 +347,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -340,0 +348,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -341,1 +356,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -405,0 +420,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -410,1 +428,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -412,0 +429,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -413,1 +437,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -472,0 +496,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -499,1 +526,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -501,0 +527,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -502,1 +535,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -782,0 +815,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -787,1 +823,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -789,0 +824,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -790,1 +832,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1058,0 +1100,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1070,1 +1115,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1072,0 +1116,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1074,1 +1125,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1153,0 +1204,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1165,1 +1219,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1167,0 +1220,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1169,1 +1229,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1249,0 +1309,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1267,1 +1330,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1269,0 +1331,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1270,1 +1339,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1399,0 +1468,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1419,1 +1491,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1421,0 +1492,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1422,1 +1500,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1658,0 +1736,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1662,1 +1743,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1664,0 +1744,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1665,1 +1752,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1679,0 +1766,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1683,1 +1773,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1685,0 +1774,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1686,1 +1782,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1700,0 +1796,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -4099,0 +4198,24 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_aes(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)(addr))\n+  ADD(key_shuffle_mask_addr());\n+  ADD(counter_shuffle_mask_addr());\n+  ADD(counter_mask_linc0_addr());\n+  ADD(counter_mask_linc1_addr());\n+  ADD(counter_mask_linc1f_addr());\n+  ADD(counter_mask_linc2_addr());\n+  ADD(counter_mask_linc2f_addr());\n+  ADD(counter_mask_linc4_addr());\n+  ADD(counter_mask_linc8_addr());\n+  ADD(counter_mask_linc16_addr());\n+  ADD(counter_mask_linc32_addr());\n+  ADD(counter_mask_ones_addr());\n+  ADD(ghash_polynomial_reduction_addr());\n+  ADD(ghash_polynomial_two_one_addr());\n+  ADD(counter_mask_addbe_4444_addr());\n+  ADD(counter_mask_addbe_1234_addr());\n+  ADD(counter_mask_add_1234_addr());\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_aes.cpp","additions":145,"deletions":22,"binary":false,"changes":167,"status":"modified"},{"patch":"@@ -573,0 +573,27 @@\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  bool add_extras = !is_oop && !aligned;\n+  \/\/ The stub employs one unsafe handler region by default but has two\n+  \/\/ when MaxVectorSize == 64 So we may expect 0, 3 or 6 extras.\n+  int handlers_count = (MaxVectorSize == 64 ? 2 : 1);\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = 3 * (add_extras ? handlers_count : 0); \/\/ 0\/1\/2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  GrowableArray<address>* extras_ptr = (add_extras ? &extras : nullptr);\n+  address start = load_archive_data(stub_id, entries_ptr, extras_ptr);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    if (add_extras) {\n+      \/\/ restore 1 x UMAM {start,end,handler} addresses from extras\n+      register_unsafe_access_handlers(extras, 0, 1);\n+    }\n+    return start;\n+  }\n@@ -576,1 +603,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -599,0 +626,1 @@\n+    entries.append(*entry);\n@@ -797,0 +825,12 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  if (add_extras) {\n+    retrieve_unsafe_access_handlers(start, end, extras);\n+  }\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, extras_ptr);\n+\n@@ -911,1 +951,24 @@\n-\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  bool add_extras = !is_oop && !aligned;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = 3 * (add_extras ? 1 : 0); \/\/ 0\/1 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  GrowableArray<address>* extras_ptr = (add_extras ? &extras : nullptr);\n+  address start = load_archive_data(stub_id, entries_ptr, extras_ptr);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    if (add_extras) {\n+      \/\/ restore 1 x UMAM {start,end,handler} addresses from extras\n+      register_unsafe_access_handlers(extras, 0, 1);\n+    }\n+    return start;\n+  }\n@@ -914,1 +977,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -936,0 +999,1 @@\n+    entries.append(*entry);\n@@ -962,1 +1026,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -1076,0 +1140,12 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  if (add_extras) {\n+    retrieve_unsafe_access_handlers(start, end, extras);\n+  }\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, extras_ptr);\n+\n@@ -1390,0 +1466,20 @@\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = (2 * 3); \/\/ 2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  address start = load_archive_data(stub_id, entries_ptr, &extras);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+    register_unsafe_access_handlers(extras, 0, 2);\n+    return start;\n+  }\n@@ -1392,1 +1488,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1412,0 +1508,1 @@\n+    entries.append(*entry);\n@@ -1481,0 +1578,11 @@\n+\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  retrieve_unsafe_access_handlers(start, end, extras);\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, &extras);\n+\n@@ -1508,0 +1616,20 @@\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = (2 * 3); \/\/ 2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  address start = load_archive_data(stub_id, entries_ptr, &extras);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+    register_unsafe_access_handlers(extras, 0, 2);\n+    return start;\n+  }\n@@ -1510,1 +1638,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1525,0 +1653,1 @@\n+    entries.append(*entry);\n@@ -1591,0 +1720,10 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  retrieve_unsafe_access_handlers(start, end, extras);\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, &extras);\n+\n@@ -1621,1 +1760,20 @@\n-\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = (2 * 3); \/\/ 2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  address start = load_archive_data(stub_id, entries_ptr, &extras);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+    register_unsafe_access_handlers(extras, 0, 2);\n+    return start;\n+  }\n@@ -1624,1 +1782,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1643,0 +1801,1 @@\n+    entries.append(*entry);\n@@ -1706,0 +1865,10 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  retrieve_unsafe_access_handlers(start, end, extras);\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, &extras);\n+\n@@ -1713,1 +1882,6 @@\n-\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -1745,1 +1919,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1766,0 +1940,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1793,1 +1970,20 @@\n-\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = (2 * 3); \/\/ 2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  address start = load_archive_data(stub_id, entries_ptr, &extras);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+    register_unsafe_access_handlers(extras, 0, 2);\n+    return start;\n+  }\n@@ -1796,1 +1992,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1811,0 +2007,1 @@\n+    entries.append(*entry);\n@@ -1869,0 +2066,10 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  retrieve_unsafe_access_handlers(start, end, extras);\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, &extras);\n+\n@@ -1921,0 +2128,24 @@\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  bool add_extras = !is_oop && !aligned;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = 3 * (add_extras ? 2 : 0); \/\/ 0\/2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  GrowableArray<address>* extras_ptr = (add_extras ? &extras : nullptr);\n+  address start = load_archive_data(stub_id, entries_ptr, extras_ptr);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    if (add_extras) {\n+      \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+      register_unsafe_access_handlers(extras, 0, 2);\n+    }\n+    return start;\n+  }\n@@ -1924,1 +2155,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1942,0 +2173,1 @@\n+    entries.append(*entry);\n@@ -1962,1 +2194,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -1974,1 +2206,1 @@\n-  __ BIND(L_copy_8_bytes);\n+    __ BIND(L_copy_8_bytes);\n@@ -1981,1 +2213,1 @@\n-  __ BIND(L_copy_4_bytes);\n+    __ BIND(L_copy_4_bytes);\n@@ -1987,1 +2219,1 @@\n-__ BIND(L_exit);\n+  __ BIND(L_exit);\n@@ -1998,1 +2230,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, false, ucme_exit_pc);\n+    UnsafeMemoryAccessMark umam(this, add_extras, false, ucme_exit_pc);\n@@ -2004,0 +2236,12 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  if (add_extras) {\n+    retrieve_unsafe_access_handlers(start, end, extras);\n+  }\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, extras_ptr);\n+\n@@ -2052,0 +2296,24 @@\n+  bool add_extras = !is_oop && !aligned;\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = 3 * (add_extras ? 2 : 0); \/\/ 0\/2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  GrowableArray<address>* extras_ptr = (add_extras ? &extras : nullptr);\n+  address start = load_archive_data(stub_id, entries_ptr, extras_ptr);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    if (add_extras) {\n+      \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+      register_unsafe_access_handlers(extras, 0, 2);\n+    }\n+    return start;\n+  }\n@@ -2055,1 +2323,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2069,1 +2337,2 @@\n-     \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n+    entries.append(*entry);\n+    \/\/ caller can pass a 64-bit byte count here (from Unsafe.copyMemory)\n@@ -2092,1 +2361,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -2107,1 +2376,1 @@\n-  __ BIND(L_copy_8_bytes);\n+    __ BIND(L_copy_8_bytes);\n@@ -2125,1 +2394,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -2130,1 +2399,1 @@\n-__ BIND(L_exit);\n+  __ BIND(L_exit);\n@@ -2139,0 +2408,12 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  if (add_extras) {\n+    retrieve_unsafe_access_handlers(start, end, extras);\n+  }\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, extras_ptr);\n+\n@@ -2185,0 +2466,24 @@\n+  bool add_extras  = !is_oop && !aligned;\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = 3 * (add_extras ? 2 : 0); \/\/ 0\/2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  GrowableArray<address>* extras_ptr = (add_extras ? &extras : nullptr);\n+  address start = load_archive_data(stub_id, entries_ptr, extras_ptr);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    if (add_extras) {\n+      \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+      register_unsafe_access_handlers(extras, 0, 2);\n+    }\n+    return start;\n+  }\n@@ -2188,1 +2493,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2206,0 +2511,1 @@\n+    entries.append(*entry);\n@@ -2226,1 +2532,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -2258,1 +2564,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -2274,0 +2580,12 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  if (add_extras) {\n+    retrieve_unsafe_access_handlers(start, end, extras);\n+  }\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, extras_ptr);\n+\n@@ -2318,0 +2636,24 @@\n+  bool add_extras = !is_oop && !aligned;\n+  GrowableArray<address> entries;\n+  GrowableArray<address> extras;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int expected_extra_count = 3 * (add_extras ? 2 : 0); \/\/ 0\/2 x UMAM {start,end,handler}\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  GrowableArray<address>* extras_ptr = (add_extras ? &extras : nullptr);\n+  address start = load_archive_data(stub_id, entries_ptr, extras_ptr);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra addresses count %d\", extras.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    if (add_extras) {\n+      \/\/ restore 2 UMAM {start,end,handler} addresses from extras\n+      register_unsafe_access_handlers(extras, 0, 2);\n+    }\n+    return start;\n+  }\n@@ -2321,1 +2663,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2334,0 +2676,1 @@\n+    entries.append(*entry);\n@@ -2355,1 +2698,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -2382,1 +2725,1 @@\n-    UnsafeMemoryAccessMark umam(this, !is_oop && !aligned, true);\n+    UnsafeMemoryAccessMark umam(this, add_extras, true);\n@@ -2398,0 +2741,13 @@\n+\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  if (add_extras) {\n+    retrieve_unsafe_access_handlers(start, end, extras);\n+  }\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, entries_ptr, extras_ptr);\n+\n@@ -2453,0 +2809,15 @@\n+  GrowableArray<address> entries;\n+  int expected_entry_count = (entry != nullptr ? 2 : 1);\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == expected_entry_count, \"sanity check\");\n+  GrowableArray<address>* entries_ptr = (entry_count == 1 ? nullptr : &entries);\n+  address start = load_archive_data(stub_id, entries_ptr);\n+  if (start != nullptr) {\n+    assert(entries.length() == expected_entry_count - 1,\n+           \"unexpected extra entry count %d\", entries.length());\n+    if (entry != nullptr) {\n+      *entry = entries.at(0);\n+    }\n+    return start;\n+  }\n+\n@@ -2482,1 +2853,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2507,0 +2878,1 @@\n+    entries.append(*entry);\n@@ -2641,0 +3013,3 @@\n+  \/\/ record the stub entry and end plus the no_push entry\n+  store_archive_data(stub_id, start, __ pc(), entries_ptr);\n+\n@@ -2660,0 +3035,8 @@\n+  StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+\n@@ -2671,1 +3054,0 @@\n-  StubId stub_id = StubId::stubgen_unsafe_arraycopy_id;\n@@ -2673,1 +3055,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2705,0 +3087,3 @@\n+  \/\/ record the stub entry and end plus\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -2806,1 +3191,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -2808,0 +3192,14 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  \/\/ we expect one set of extra unsafememory access handler entries\n+  GrowableArray<address> extras;\n+  int expected_extra_count = 3 * 3;\n+  address start = load_archive_data(stub_id, nullptr, &extras);\n+  if (start != nullptr) {\n+    assert(extras.length() == expected_extra_count,\n+           \"unexpected extra entry count %d\", extras.length());\n+    register_unsafe_access_handlers(extras, 0, 3);\n+    return start;\n+  }\n+\n+  __ align(CodeEntryAlignment);\n@@ -2809,1 +3207,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -2899,0 +3297,10 @@\n+  \/\/ retrieve the registered handler addresses\n+  address end = __ pc();\n+  retrieve_unsafe_access_handlers(start, end, extras);\n+  assert(extras.length() == expected_extra_count,\n+         \"unexpected extra addresses count %d\", extras.length());\n+\n+  \/\/ record the stub entry and end plus the no_push entry and any\n+  \/\/ extra handler addresses\n+  store_archive_data(stub_id, start, end, nullptr, &extras);\n+\n@@ -2955,1 +3363,9 @@\n-  Label L_failed, L_failed_0, L_objArray;\n+  StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+\n+  Label L_failed, L_failed_0, L_skip_failed_0, L_objArray;\n@@ -2971,7 +3387,0 @@\n-  { int modulus = CodeEntryAlignment;\n-    int target  = modulus - 5; \/\/ 5 = sizeof jmp(L_failed)\n-    int advance = target - (__ offset() % modulus);\n-    if (advance < 0)  advance += modulus;\n-    if (advance > 0)  __ nop(advance);\n-  }\n-  StubId stub_id = StubId::stubgen_generic_arraycopy_id;\n@@ -2979,6 +3388,0 @@\n-\n-  \/\/ Short-hop target to L_failed.  Makes for denser prologue code.\n-  __ BIND(L_failed_0);\n-  __ jmp(L_failed);\n-  assert(__ offset() % CodeEntryAlignment == 0, \"no further alignment needed\");\n-\n@@ -2986,1 +3389,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -3027,1 +3430,2 @@\n-  __ jccb(Assembler::negative, L_failed_0);\n+  \/\/ skip over the failure trampoline\n+  __ jccb(Assembler::positive, L_skip_failed_0);\n@@ -3037,0 +3441,7 @@\n+  \/\/ Short-hop target to L_failed.  Makes for denser prologue code.\n+  __ BIND(L_failed_0);\n+  __ jmp(L_failed);\n+\n+  \/\/ continue here if first 4 checks pass\n+  __ bind(L_skip_failed_0);\n+\n@@ -3259,0 +3670,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":465,"deletions":51,"binary":false,"changes":516,"status":"modified"},{"patch":"@@ -194,0 +194,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -195,1 +201,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -338,0 +344,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -342,0 +351,24 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_cbrt(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)(addr))\n+  ADD(_ABS_MASK);\n+  ADD(_SIG_MASK);\n+  ADD(_EXP_MASK);\n+  ADD(_EXP_MSK2);\n+  ADD(_EXP_MSK3);\n+  ADD(_SCALE63);\n+  ADD(_ZERON);\n+  ADD(_INF);\n+  ADD(_NEG_INF);\n+  address coeff_table = (address)_coeff_table;\n+  ADD(coeff_table);\n+  ADD(coeff_table + 16);\n+  ADD(coeff_table + 32);\n+  ADD(coeff_table + 48);\n+  ADD(_rcp_table);\n+  ADD(_cbrt_table);\n+  ADD(_D_table);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cbrt.cpp","additions":34,"deletions":1,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -114,1 +114,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -116,0 +115,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -117,1 +123,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -298,0 +304,4 @@\n+\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -303,1 +313,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -305,0 +314,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -306,1 +322,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -469,0 +485,4 @@\n+\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -587,0 +607,10 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_chacha(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)(addr))\n+  ADD(CC20_COUNTER_ADD_AVX);\n+  ADD(CC20_COUNTER_ADD_AVX512);\n+  ADD(CC20_LROT_CONSTS);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_chacha.cpp","additions":34,"deletions":4,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -236,0 +236,26 @@\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_constants(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)(addr))\n+  ADD(_ONE);\n+  ADD(_ONEHALF);\n+  ADD(_SIGN_MASK);\n+  ADD(_TWO_POW_55);\n+  ADD(_TWO_POW_M55);\n+  ADD(_SHIFTER);\n+  ADD(_ZERO);\n+  ADD(_SC_1);\n+  ADD(_SC_2);\n+  ADD(_SC_3);\n+  ADD(_SC_4);\n+  ADD(_PI_4);\n+  ADD(((address)_PI_4+8));\n+  ADD(_PI32INV);\n+  ADD(_NEG_ZERO);\n+  ADD(_P_1);\n+  ADD(_P_2);\n+  ADD(_P_3);\n+  ADD(_PI_INV_TABLE);\n+  ADD(_Ctable);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_constants.cpp","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -177,0 +177,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -178,1 +184,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -622,0 +628,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_cos.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -404,1 +404,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -406,0 +405,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -407,1 +413,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -649,0 +655,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -660,1 +669,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -662,0 +670,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -663,1 +678,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -889,0 +904,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -903,1 +921,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -905,0 +922,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -906,1 +930,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -975,0 +999,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -987,1 +1014,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -989,0 +1015,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -990,1 +1023,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1062,0 +1095,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -1076,1 +1112,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -1078,0 +1113,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1079,1 +1121,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1321,0 +1363,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -1343,0 +1388,18 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_dilithium(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)(addr))\n+  \/\/ use accessors to correctly identify the relevant addresses\n+  ADD(unshufflePermsAddr(0));\n+  ADD(unshufflePermsAddr(1));\n+  ADD(unshufflePermsAddr(2));\n+  ADD(unshufflePermsAddr(3));\n+  ADD(unshufflePermsAddr(4));\n+  ADD(unshufflePermsAddr(5));\n+  ADD(dilithiumAvx512ConstsAddr(montQInvModRIdx));\n+  ADD(dilithiumAvx512ConstsAddr(dilithium_qIdx));\n+  ADD(dilithiumAvx512ConstsAddr(montRSquareModQIdx));\n+  ADD(dilithiumAvx512ConstsAddr(barrettAddendIdx));\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_dilithium.cpp","additions":73,"deletions":10,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -169,0 +169,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -170,1 +176,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -384,0 +390,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -388,0 +397,21 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_exp(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(_cv);\n+  ADD(((address)_cv+16));\n+  ADD(((address)_cv+32));\n+  ADD(((address)_cv+48));\n+  ADD(((address)_cv+64));\n+  ADD(((address)_cv+80));\n+  ADD(_mmask);\n+  ADD(_bias);\n+  ADD(_Tbl_addr);\n+  ADD(_ALLONES);\n+  ADD(_ebias);\n+  ADD(_XMAX);\n+  ADD(_XMIN);\n+  ADD(_INF);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_exp.cpp","additions":31,"deletions":1,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -75,1 +75,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -77,0 +76,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -78,1 +84,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -524,0 +530,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -528,0 +537,12 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_fmod(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(CONST_NaN);\n+  ADD(CONST_1p260);\n+  ADD(CONST_MAX);\n+  ADD(CONST_INF);\n+  ADD(CONST_e307);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_fmod.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -83,2 +83,0 @@\n-  __ align(CodeEntryAlignment);\n-  Label L_ghash_loop, L_exit;\n@@ -86,0 +84,8 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  Label L_ghash_loop, L_exit;\n+  __ align(CodeEntryAlignment);\n@@ -87,1 +93,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -214,0 +220,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -220,2 +229,0 @@\n-  __ align(CodeEntryAlignment);\n-\n@@ -223,0 +230,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -224,1 +238,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -240,0 +254,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -541,0 +558,11 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_ghash(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(GHASH_SHUFFLE_MASK);\n+  ADD(GHASH_LONG_SWAP_MASK);\n+  ADD(GHASH_BYTE_SWAP_MASK);\n+  ADD(GHASH_POLYNOMIAL);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_ghash.cpp","additions":34,"deletions":6,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -403,1 +403,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -405,0 +404,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -406,1 +412,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -490,0 +496,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -499,2 +508,0 @@\n-\n-  __ align(CodeEntryAlignment);\n@@ -502,0 +509,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -503,1 +517,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -613,0 +627,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -624,2 +641,0 @@\n-\n-  __ align(CodeEntryAlignment);\n@@ -627,0 +642,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -628,1 +650,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -734,0 +756,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -744,2 +769,0 @@\n-\n-  __ align(CodeEntryAlignment);\n@@ -747,0 +770,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -748,1 +778,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -779,0 +809,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -790,2 +823,0 @@\n-\n-  __ align(CodeEntryAlignment);\n@@ -793,0 +824,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -794,1 +832,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -833,0 +871,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -844,2 +885,0 @@\n-\n-  __ align(CodeEntryAlignment);\n@@ -847,0 +886,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -848,1 +894,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -987,0 +1033,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -996,2 +1045,0 @@\n-\n-  __ align(CodeEntryAlignment);\n@@ -999,0 +1046,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -1000,1 +1054,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1024,0 +1078,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -1041,0 +1098,21 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_kyber(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)(addr))\n+  \/\/ use accessors to correctly identify the relevant addresses\n+  ADD(kyberAvx512NttPermsAddr());\n+  ADD(kyberAvx512InverseNttPermsAddr());\n+  ADD(kyberAvx512_nttMultPermsAddr());\n+  ADD(kyberAvx512_12To16PermsAddr());\n+  ADD(kyberAvx512_12To16DupAddr());\n+  ADD(kyberAvx512_12To16ShiftAddr());\n+  ADD(kyberAvx512_12To16AndAddr());\n+  ADD(kyberAvx512ConstsAddr(qOffset));\n+  ADD(kyberAvx512ConstsAddr(qInvModROffset));\n+  ADD(kyberAvx512ConstsAddr(dimHalfInverseOffset));\n+  ADD(kyberAvx512ConstsAddr(barretMultiplierOffset));\n+  ADD(kyberAvx512ConstsAddr(montRSquareModqOffset));\n+  ADD(kyberAvx512ConstsAddr(f00Offset));\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_kyber.cpp","additions":98,"deletions":20,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -180,0 +180,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -181,1 +187,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -362,0 +368,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -519,0 +528,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -520,1 +535,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -707,0 +722,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -711,0 +729,22 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_log(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(_L_tbl);\n+  ADD(_log2);\n+  ADD(((address)_log2+8));\n+  ADD(_coeff);\n+  ADD(((address)_coeff+16));\n+  ADD(((address)_coeff+32));\n+  ADD(_HIGHSIGMASK_log10);\n+  ADD(_LOG10_E);\n+  ADD(((address)_LOG10_E+8));\n+  ADD(_L_tbl_log10);\n+  ADD(_log2_log10);\n+  ADD(((address)_log2_log10+8));\n+  ADD(_coeff_log10);\n+  ADD(((address)_coeff_log10+16));\n+  ADD(((address)_coeff_log10+32));\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_log.cpp","additions":42,"deletions":2,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -912,1 +912,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -914,0 +913,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -915,1 +921,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1031,0 +1037,4 @@\n+\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1698,0 +1708,11 @@\n+#undef __\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_poly1305(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(POLY1305_PAD_MSG);\n+  ADD(POLY1305_MASK42);\n+  ADD(POLY1305_MASK44);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly1305.cpp","additions":23,"deletions":2,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -561,1 +561,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -563,0 +562,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -564,1 +570,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -623,0 +629,4 @@\n+\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -683,1 +693,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -685,0 +694,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -686,1 +702,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -765,0 +781,4 @@\n+\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -767,0 +787,15 @@\n+#undef __\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_poly_mont(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  \/\/ use accessors to retrieve all correct addresses\n+  ADD(shift_1L());\n+  ADD(shift_1R());\n+  ADD(p256_mask52());\n+  ADD(mask_limb5());\n+  ADD(modulus_p256());\n+  ADD(modulus_p256(1));\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_poly_mont.cpp","additions":39,"deletions":4,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -763,0 +763,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -764,1 +770,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1862,0 +1868,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1866,0 +1875,30 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_pow(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(_HIGHSIGMASK);\n+  ADD(_LOG2_E);\n+  ADD(_HIGHMASK_Y);\n+  ADD((address)_HIGHMASK_Y+8);\n+  ADD(_T_exp);\n+  ADD(_e_coeff);\n+  ADD((address)_e_coeff+16);\n+  ADD((address)_e_coeff+32);\n+  ADD(_coeff_h);\n+  ADD((address)_coeff_h+8);\n+  ADD(_HIGHMASK_LOG_X);\n+  ADD(_HALFMASK);\n+  ADD(_coeff_pow);\n+  ADD((address)_coeff_pow+16);\n+  ADD((address)_coeff_pow+32);\n+  ADD((address)_coeff_pow+48);\n+  ADD((address)_coeff_pow+64);\n+  ADD((address)_coeff_pow+80);\n+  ADD(_L_tbl_pow);\n+  ADD(_log2_pow);\n+  ADD(_DOUBLE2);\n+  ADD(_DOUBLE0);\n+  ADD(_DOUBLE0DOT5);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_pow.cpp","additions":40,"deletions":1,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -107,1 +107,6 @@\n-\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -110,1 +115,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -319,0 +324,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -329,1 +337,0 @@\n-  __ align(CodeEntryAlignment);\n@@ -331,0 +338,7 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = stubgen->load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n+  __ align(CodeEntryAlignment);\n@@ -332,1 +346,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -498,0 +512,3 @@\n+  \/\/ record the stub entry and end\n+  stubgen->store_archive_data(stub_id, start, __ pc());\n+\n@@ -511,0 +528,11 @@\n+\n+#undef __\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_sha3(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(round_constsAddr());\n+  ADD(permsAndRotsAddr());\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sha3.cpp","additions":32,"deletions":4,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -184,0 +184,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -185,1 +191,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -648,0 +654,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -652,0 +661,8 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_sin(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(_ALL_ONES);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sin.cpp","additions":18,"deletions":1,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -293,0 +293,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -294,1 +300,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -522,0 +528,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -526,0 +535,22 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_sinh(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(_L2E);\n+  ADD(_L2E + 8);\n+  ADD(_HALFMASK);\n+  ADD(_Shifter);\n+  ADD(_cv);\n+  ADD(_cv + 16);\n+  ADD(_cv + 32);\n+  ADD(_cv + 48);\n+  ADD(_cv + 64);\n+  ADD(_T2f);\n+  ADD(_T2_neg_f);\n+  ADD(_pv);\n+  ADD(_pv + 16);\n+  ADD(_pv + 32);\n+  ADD(_MASK3);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_sinh.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -459,0 +459,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -460,1 +466,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -1028,0 +1034,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -1032,0 +1041,23 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_tan(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(_MUL16);\n+  ADD(_sign_mask_tan);\n+  ADD(_PI32INV_tan);\n+  ADD(_P_1_tan);\n+  ADD(_P_2_tan);\n+  ADD(_P_3_tan);\n+  ADD(_Ctable_tan);\n+  ADD(_MASK_35_tan);\n+  ADD(_Q_11_tan);\n+  ADD(_Q_9_tan);\n+  ADD(_Q_7_tan);\n+  ADD(_Q_5_tan);\n+  ADD(_Q_3_tan);\n+  ADD(_PI_4_tan);\n+  ADD(((address)_PI_4_tan+8));\n+  ADD(_QQ_2_tan);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tan.cpp","additions":33,"deletions":1,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -306,0 +306,6 @@\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  assert(entry_count == 1, \"sanity check\");\n+  address start = load_archive_data(stub_id);\n+  if (start != nullptr) {\n+    return start;\n+  }\n@@ -307,1 +313,1 @@\n-  address start = __ pc();\n+  start = __ pc();\n@@ -498,0 +504,3 @@\n+  \/\/ record the stub entry and end\n+  store_archive_data(stub_id, start, __ pc());\n+\n@@ -502,0 +511,22 @@\n+\n+#if INCLUDE_CDS\n+void StubGenerator::init_AOTAddressTable_tanh(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(_L2E);\n+  ADD(_L2E + 8);\n+  ADD(_HALFMASK);\n+  ADD(_ONEMASK);\n+  ADD(_TWOMASK);\n+  ADD(_Shifter);\n+  ADD(_cv);\n+  ADD(_cv + 16);\n+  ADD(_cv + 32);\n+  ADD(_T2_neg_f);\n+  ADD(_pv);\n+  ADD(_pv + 16);\n+  ADD(_pv + 32);\n+  ADD(_MASK3);\n+  ADD(_RMASK);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_tanh.cpp","additions":32,"deletions":1,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+#include \"stubGenerator_x86_64.hpp\"\n+#ifdef COMPILER1\n+#include \"c1\/c1_LIRAssembler.hpp\"\n+#endif\n@@ -414,0 +418,42 @@\n+\n+#if INCLUDE_CDS\n+\n+void StubRoutines::init_AOTAddressTable() {\n+  ResourceMark rm;\n+  GrowableArray<address> external_addresses;\n+  \/\/ publish static addresses referred to by main x86 generator and\n+  \/\/ auxiliary x86 generators\n+  StubGenerator::init_AOTAddressTable(external_addresses);\n+  \/\/ publish external data addresses defined in nested x86 class\n+  StubRoutines::x86::init_AOTAddressTable(external_addresses);\n+#ifdef COMPILER1\n+  LIR_Assembler::init_AOTAddressTable(external_addresses);\n+#endif\n+  AOTCodeCache::publish_external_addresses(external_addresses);\n+}\n+\n+\/\/ publish addresses of external data defined in this file which may\n+\/\/ be referenced from stub or code\n+void StubRoutines::x86::init_AOTAddressTable(GrowableArray<address>& external_addresses) {\n+#define ADD(addr) external_addresses.append((address)addr);\n+  ADD(&_mxcsr_std);\n+  ADD(&_mxcsr_rz);\n+  ADD(crc_by128_masks_addr());\n+  ADD(crc_by128_masks_addr() + 16);\n+  ADD(crc_by128_masks_addr() + 32);\n+  ADD(_crc_table);\n+  ADD(crc_by128_masks_avx512_addr());\n+  ADD(crc_by128_masks_avx512_addr() + 16);\n+  ADD(crc_by128_masks_avx512_addr() + 32);\n+  ADD(_crc_table_avx512);\n+  ADD(_crc32c_table_avx512);\n+  ADD(_shuf_table_crc32_avx512);\n+  \/\/ n.b. call accessor for this one to ensure the table is generated\n+  ADD(crc32c_table_addr());\n+  ADD(_arrays_hashcode_powers_of_31);\n+  ADD(_k256);\n+  ADD(_k256_W);\n+  ADD(_k512_W);\n+#undef ADD\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.cpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -115,0 +115,2 @@\n+\n+  static void init_AOTAddressTable(GrowableArray<address>& external_addresses);\n","filename":"src\/hotspot\/cpu\/x86\/stubRoutines_x86.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-  StubGenerator(CodeBuffer* code, BlobId blob_id) : StubCodeGenerator(code, blob_id) {\n+  StubGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData *stub_data) : StubCodeGenerator(code, blob_id, stub_data) {\n@@ -240,2 +240,2 @@\n-void StubGenerator_generate(CodeBuffer* code, BlobId blob_id) {\n-  StubGenerator g(code, blob_id);\n+void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData *stub_data) {\n+  StubGenerator g(code, blob_id, stub_data);\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -33,0 +33,6 @@\n+\n+#if INCLUDE_CDS\n+\/\/ nothing to do for zero\n+void StubRoutines::init_AOTAddressTable() {\n+}\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/cpu\/zero\/stubRoutines_zero.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -281,4 +281,0 @@\n-    if (id == StubId::c1_forward_exception_id) {\n-      \/\/ publish early c1 stubs at this point so later stubs can refer to them\n-      AOTCodeCache::init_early_c1_table();\n-    }\n@@ -286,0 +282,2 @@\n+  \/\/ disallow any further c1 stub generation\n+  AOTCodeCache::set_c1_stubs_complete();\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/barrierSetNMethod.hpp\"\n@@ -38,0 +39,2 @@\n+#include \"prims\/jvmtiThreadState.hpp\"\n+#include \"prims\/upcallLinker.hpp\"\n@@ -156,2 +159,1 @@\n-  } else {\n-    \/\/ kind must be AOTCodeEntry::C2Blob\n+  } else if (kind == AOTCodeEntry::C2Blob) {\n@@ -160,0 +162,4 @@\n+  } else {\n+    \/\/ kind must be AOTCodeEntry::StubGenBlob\n+    assert(StubInfo::is_stubgen(static_cast<BlobId>(id)), \"not a stubgen blob id %d\", id);\n+    return id;\n@@ -185,1 +191,1 @@\n-  FLAG_SET_ERGO(AOTStubCaching, false);\n+  \/\/ FLAG_SET_ERGO(AOTStubCaching, false);\n@@ -281,0 +287,13 @@\n+\/\/ Called after continuations_init() when continuation stub callouts\n+\/\/ have been initialized\n+void AOTCodeCache::init3() {\n+  if (opened_cache == nullptr) {\n+    return;\n+  }\n+  \/\/ initialize external routines for continuations so we can save\n+  \/\/ generated continuation blob that references them\n+  AOTCodeAddressTable* table = opened_cache->_table;\n+  assert(table != nullptr, \"should be initialized already\");\n+  table->init_extrs2();\n+}\n+\n@@ -340,0 +359,1 @@\n+    log_debug(aot, codecache, init)(\"  StubGen Blobs:  total=%d\", _load_header->stubgen_blobs_count());\n@@ -357,1 +377,36 @@\n-void AOTCodeCache::init_early_stubs_table() {\n+void AOTCodeCache::add_stub_entries(StubId stub_id, address start, GrowableArray<address> *entries, int begin_idx) {\n+  EntryId entry_id = StubInfo::entry_base(stub_id);\n+  add_stub_entry(entry_id, start);\n+  \/\/ skip past first entry\n+  entry_id = StubInfo::next_in_stub(stub_id, entry_id);\n+  \/\/ now check for any more entries\n+  int count = StubInfo::entry_count(stub_id) - 1;\n+  assert(start != nullptr, \"invalid start address for stub %s\", StubInfo::name(stub_id));\n+  assert(entries == nullptr || begin_idx + count <= entries->length(), \"sanity\");\n+  \/\/ write any extra entries\n+  for (int i = 0; i < count; i++) {\n+    assert(entry_id != EntryId::NO_ENTRYID, \"not enough entries for stub %s\", StubInfo::name(stub_id));\n+    address a = entries->at(begin_idx + i);\n+    add_stub_entry(entry_id, a);\n+    entry_id = StubInfo::next_in_stub(stub_id, entry_id);\n+  }\n+  assert(entry_id == EntryId::NO_ENTRYID, \"too many entries for stub %s\", StubInfo::name(stub_id));\n+}\n+\n+void AOTCodeCache::add_stub_entry(EntryId entry_id, address a) {\n+  if (a != nullptr) {\n+    if (_table != nullptr) {\n+      log_trace(aot, codecache, stubs)(\"Publishing stub entry %s at address \" INTPTR_FORMAT, StubInfo::name(entry_id), p2i(a));\n+      return _table->add_stub_entry(entry_id, a);\n+    }\n+  }\n+}\n+\n+void AOTCodeCache::set_shared_stubs_complete() {\n+  AOTCodeAddressTable* table = addr_table();\n+  if (table != nullptr) {\n+    table->set_shared_stubs_complete();\n+  }\n+}\n+\n+void AOTCodeCache::set_c1_stubs_complete() {\n@@ -360,1 +415,1 @@\n-    table->init_early_stubs();\n+    table->set_c1_stubs_complete();\n@@ -364,1 +419,1 @@\n-void AOTCodeCache::init_shared_blobs_table() {\n+void AOTCodeCache::set_c2_stubs_complete() {\n@@ -367,1 +422,1 @@\n-    table->init_shared_blobs();\n+    table->set_c2_stubs_complete();\n@@ -371,1 +426,1 @@\n-void AOTCodeCache::init_early_c1_table() {\n+void AOTCodeCache::set_stubgen_stubs_complete() {\n@@ -374,1 +429,1 @@\n-    table->init_early_c1();\n+    table->set_stubgen_stubs_complete();\n@@ -721,0 +776,1 @@\n+    uint stubgen_blobs_count = 0;\n@@ -748,0 +804,2 @@\n+      } else if (kind == AOTCodeEntry::StubGenBlob) {\n+        stubgen_blobs_count++;\n@@ -784,0 +842,1 @@\n+    log_debug(aot, codecache, exit)(\"  StubGen Blobs:  total=%d\", stubgen_blobs_count);\n@@ -793,1 +852,2 @@\n-                 C1_blobs_count, C2_blobs_count);\n+                 stubgen_blobs_count, C1_blobs_count,\n+                 C2_blobs_count);\n@@ -802,1 +862,32 @@\n-bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, uint id, const char* name) {\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, uint id, const char* name, AOTStubData* stub_data, CodeBuffer* code_buffer) {\n+  assert(AOTCodeEntry::is_valid_entry_kind(entry_kind), \"invalid entry_kind %d\", entry_kind);\n+\n+  \/\/ we only expect stub data and a code buffer for a multi stub blob\n+  assert(AOTCodeEntry::is_multi_stub_blob(entry_kind) == (stub_data != nullptr),\n+         \"entry_kind %d does not match stub_data pointer %p\",\n+         entry_kind, stub_data);\n+\n+  assert((stub_data == nullptr) == (code_buffer == nullptr),\n+         \"stub data and code buffer must both be null or both non null\");\n+\n+  \/\/ If this is a stub and the cache is on for either load or dump we\n+  \/\/ need to insert the stub entries into the AOTCacheAddressTable so\n+  \/\/ that relocs which refer to entries defined by this blob get\n+  \/\/ translated correctly.\n+  \/\/\n+  \/\/ Entry insertion needs to be be done up front before writing the\n+  \/\/ blob because some blobs rely on internal daisy-chain references\n+  \/\/ from one entry to another.\n+  \/\/\n+  \/\/ Entry insertion also needs to be done even if the cache is open\n+  \/\/ for use but not for dump. This may be needed when an archived\n+  \/\/ blob omits some entries -- either because of a config change or a\n+  \/\/ load failure -- with the result that the entries end up being\n+  \/\/ generated. These generated entry addresses may be needed to\n+  \/\/ resolve references from subsequently loaded blobs (for either\n+  \/\/ stubs or nmethods).\n+\n+  if (is_on() && AOTCodeEntry::is_blob(entry_kind)) {\n+    publish_stub_addresses(blob, (BlobId)id, stub_data);\n+  }\n+\n@@ -807,2 +898,0 @@\n-  assert(AOTCodeEntry::is_valid_entry_kind(entry_kind), \"invalid entry_kind %d\", entry_kind);\n-\n@@ -854,2 +943,38 @@\n-  uint reloc_data_size = blob.relocation_size();\n-  n = cache->write_bytes((address)blob.relocation_begin(), reloc_data_size);\n+  \/\/ For a relocatable code blob its relocations are linked from the\n+  \/\/ blob. However, for a non-relocatable (stubgen) blob we only have\n+  \/\/ transient relocations attached to the code buffer that are added\n+  \/\/ in order to support AOT-load time patching. in either case, we\n+  \/\/ need to explicitly save these relocs when storing the blob to the\n+  \/\/ archive so we can then reload them and reattach them to either\n+  \/\/ the blob or to a code buffer when we reload the blob into a\n+  \/\/ production JVM.\n+  \/\/\n+  \/\/ Either way we are then in a position to iterate over the relocs\n+  \/\/ and AOT patch the ones that refer to code that may move between\n+  \/\/ assembly and production time. We also need to save and restore\n+  \/\/ AOT address table indexes for the target addresses of affected\n+  \/\/ relocs. That happens below.\n+\n+  int reloc_count;\n+  address reloc_data;\n+  if (AOTCodeEntry::is_multi_stub_blob(entry_kind)) {\n+    CodeSection* cs = code_buffer->code_section(CodeBuffer::SECT_INSTS);\n+    reloc_count = (cs->has_locs() ? cs->locs_count() : 0);\n+    reloc_data = (reloc_count > 0 ? (address)cs->locs_start() : nullptr);\n+  } else {\n+    reloc_count = blob.relocation_size() \/ sizeof(relocInfo);\n+    reloc_data = (address)blob.relocation_begin();\n+  }\n+  n = cache->write_bytes(&reloc_count, sizeof(int));\n+  if (n != sizeof(int)) {\n+    return false;\n+  }\n+  if (AOTCodeEntry::is_multi_stub_blob(entry_kind)) {\n+    \/\/ align to heap word size before writing the relocs so we can\n+    \/\/ install them into a code buffer when they get restored\n+    if (!cache->align_write()) {\n+      return false;\n+    }\n+  }\n+  uint reloc_data_size = (uint)(reloc_count * sizeof(relocInfo));\n+  n = cache->write_bytes(reloc_data, reloc_data_size);\n@@ -878,1 +1003,23 @@\n-  if (!cache->write_relocations(blob)) {\n+  \/\/ In the case of a multi-stub blob we need to write start, end,\n+  \/\/ secondary entries and extras. For any other blob entry addresses\n+  \/\/ beyond the blob start will be stored in the blob as offsets.\n+  if (stub_data != nullptr) {\n+    if (!cache->write_stub_data(blob, stub_data)) {\n+      return false;\n+    }\n+  }\n+\n+  \/\/ now we have added all the other data we can write the AOT\n+  \/\/ relocations\n+\n+  bool write_ok;\n+  if (AOTCodeEntry::is_multi_stub_blob(entry_kind)) {\n+    CodeSection* cs = code_buffer->code_section(CodeBuffer::SECT_INSTS);\n+    RelocIterator iter(cs);\n+    write_ok = cache->write_relocations(blob, iter);\n+  } else {\n+    RelocIterator iter(&blob);\n+    write_ok = cache->write_relocations(blob, iter);\n+  }\n+\n+  if (!write_ok) {\n@@ -887,0 +1034,1 @@\n+\n@@ -894,0 +1042,6 @@\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, uint id, const char* name) {\n+  assert(!AOTCodeEntry::is_blob(entry_kind),\n+         \"wrong entry kind for numeric id %d\", id);\n+  return store_code_blob(blob, entry_kind, (uint)id, name, nullptr, nullptr);\n+}\n+\n@@ -895,1 +1049,1 @@\n-  assert(AOTCodeEntry::is_blob(entry_kind),\n+  assert(AOTCodeEntry::is_single_stub_blob(entry_kind),\n@@ -897,1 +1051,1 @@\n-  return store_code_blob(blob, entry_kind, (uint)id, StubInfo::name(id));\n+  return store_code_blob(blob, entry_kind, (uint)id, StubInfo::name(id), nullptr, nullptr);\n@@ -900,1 +1054,102 @@\n-CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, uint id, const char* name) {\n+bool AOTCodeCache::store_code_blob(CodeBlob& blob, AOTCodeEntry::Kind entry_kind, BlobId id, AOTStubData* stub_data, CodeBuffer* code_buffer) {\n+  assert(AOTCodeEntry::is_multi_stub_blob(entry_kind),\n+         \"wrong entry kind for multi stub blob id %s\", StubInfo::name(id));\n+  return store_code_blob(blob, entry_kind, (uint)id, StubInfo::name(id), stub_data, code_buffer);\n+}\n+\n+bool AOTCodeCache::write_stub_data(CodeBlob &blob, AOTStubData *stub_data) {\n+  BlobId blob_id = stub_data->blob_id();\n+  StubId stub_id = StubInfo::stub_base(blob_id);\n+  address blob_base = blob.code_begin();\n+  int stub_cnt = StubInfo::stub_count(blob_id);\n+  int n;\n+\n+  LogStreamHandle(Trace, aot, codecache, stubs) log;\n+\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== Stub data starts at offset %d\", _write_position);\n+  }\n+\n+  for (int i = 0; i < stub_cnt; i++, stub_id = StubInfo::next_in_blob(blob_id, stub_id)) {\n+    \/\/ for each stub we find in the ranges list we write an int\n+    \/\/ sequence <stubid,start,end,N,offset1, ... offsetN> where\n+    \/\/\n+    \/\/ - start_pos is the stub start address encoded as a code section offset\n+    \/\/\n+    \/\/ - end is the stub end address encoded as an offset from start\n+    \/\/\n+    \/\/ - N counts the number of stub-local entries\/extras\n+    \/\/\n+    \/\/ - offseti is a stub-local entry\/extra address encoded as len for\n+    \/\/ a null address otherwise as an offset in range [1,len-1]\n+\n+    StubAddrRange& range = stub_data->get_range(i);\n+    GrowableArray<address>& addresses = stub_data->address_array();\n+    int base = range.start_index();\n+    if (base >= 0) {\n+      n = write_bytes(&stub_id, sizeof(StubId));\n+      if (n != sizeof(StubId)) {\n+        return false;\n+      }\n+      address start = addresses.at(base);\n+      assert (blob_base <= start, \"sanity\");\n+      uint offset = (uint)(start - blob_base);\n+      n = write_bytes(&offset, sizeof(uint));\n+      if (n != sizeof(int)) {\n+        return false;\n+      }\n+      address end = addresses.at(base + 1);\n+      assert (start < end, \"sanity\");\n+      offset = (uint)(end - start);\n+      n = write_bytes(&offset, sizeof(uint));\n+      if (n != sizeof(int)) {\n+        return false;\n+      }\n+      \/\/ write number of secondary and extra entries\n+      int count =  range.count() - 2;\n+      n = write_bytes(&count, sizeof(int));\n+      if (n != sizeof(int)) {\n+        return false;\n+      }\n+      for (int j = 0; j < count; j++) {\n+        address next = addresses.at(base + 2 + j);\n+        if (next != nullptr) {\n+          \/\/ n.b. This maps next == end to the stub length which\n+          \/\/ means we will reconstitute the address as nullptr. That\n+          \/\/ happens when we have a handler range covers the end of\n+          \/\/ a stub and needs to be handled specially by the client\n+          \/\/ that restores the extras.\n+          assert(start <= next && next <= end, \"sanity\");\n+          offset = (uint)(next - start);\n+        } else {\n+          \/\/ this can happen when a stub is not generated or an\n+          \/\/ extra is the common handler target\n+          offset = NULL_ADDRESS_MARKER;\n+        }\n+        n = write_bytes(&offset, sizeof(uint));\n+        if (n != sizeof(int)) {\n+          return false;\n+        }\n+      }\n+      if (log.is_enabled()) {\n+        log.print_cr(\"======== wrote stub %s and %d addresses up to offset %d\",\n+                     StubInfo::name(stub_id), range.count(), _write_position);\n+      }\n+    }\n+  }\n+  \/\/ we should have exhausted all stub ids in the blob\n+  assert(stub_id == StubId::NO_STUBID, \"sanity\");\n+  \/\/ write NO_STUBID as an end marker\n+  n = write_bytes(&stub_id, sizeof(StubId));\n+  if (n != sizeof(StubId)) {\n+    return false;\n+  }\n+\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== Stub data ends at offset %d\", _write_position);\n+  }\n+\n+  return true;\n+}\n+\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, uint id, const char* name, AOTStubData* stub_data) {\n@@ -907,0 +1162,4 @@\n+  assert(AOTCodeEntry::is_multi_stub_blob(entry_kind) == (stub_data != nullptr),\n+         \"entry_kind %d does not match stub_data pointer %p\",\n+         entry_kind, stub_data);\n+\n@@ -920,1 +1179,1 @@\n-  CodeBlob* blob = reader.compile_code_blob(name);\n+  CodeBlob* blob = reader.compile_code_blob(name, entry_kind, id, stub_data);\n@@ -927,0 +1186,6 @@\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, uint id, const char* name) {\n+  assert(!AOTCodeEntry::is_blob(entry_kind),\n+         \"wrong entry kind for numeric id %d\", id);\n+  return load_code_blob(entry_kind, (uint)id, name, nullptr);\n+}\n+\n@@ -928,1 +1193,1 @@\n-  assert(AOTCodeEntry::is_blob(entry_kind),\n+  assert(AOTCodeEntry::is_single_stub_blob(entry_kind),\n@@ -930,1 +1195,1 @@\n-  return load_code_blob(entry_kind, (uint)id, StubInfo::name(id));\n+  return load_code_blob(entry_kind, (uint)id, StubInfo::name(id), nullptr);\n@@ -933,1 +1198,7 @@\n-CodeBlob* AOTCodeReader::compile_code_blob(const char* name) {\n+CodeBlob* AOTCodeCache::load_code_blob(AOTCodeEntry::Kind entry_kind, BlobId id, AOTStubData* stub_data) {\n+  assert(AOTCodeEntry::is_multi_stub_blob(entry_kind),\n+         \"wrong entry kind for blob id %s\", StubInfo::name(id));\n+  return load_code_blob(entry_kind, (uint)id, StubInfo::name(id), stub_data);\n+}\n+\n+CodeBlob* AOTCodeReader::compile_code_blob(const char* name, AOTCodeEntry::Kind entry_kind, int id, AOTStubData* stub_data) {\n@@ -948,1 +1219,1 @@\n-  \/\/ Read archived code blob\n+  \/\/ Read archived code blob and related info\n@@ -953,0 +1224,6 @@\n+  int reloc_count = *(int*)addr(offset); offset += sizeof(int);\n+  if (AOTCodeEntry::is_multi_stub_blob(entry_kind)) {\n+    \/\/ position of relocs will have been aligned to heap word size so\n+    \/\/ we can install them into a code buffer\n+    offset = align_up(offset, DATA_ALIGNMENT);\n+  }\n@@ -954,1 +1231,1 @@\n-  offset += archived_blob->relocation_size();\n+  offset += reloc_count * sizeof(relocInfo);\n@@ -962,0 +1239,3 @@\n+  \/\/ Note that for a non-relocatable blob reloc_data will not be\n+  \/\/ restored into the blob. We fix that later.\n+\n@@ -965,2 +1245,1 @@\n-                                         oop_maps\n-                                        );\n+                                         oop_maps);\n@@ -978,1 +1257,43 @@\n-  fix_relocations(code_blob);\n+  if (AOTCodeEntry::is_blob(entry_kind)) {\n+    BlobId blob_id = static_cast<BlobId>(id);\n+    if (StubInfo::is_stubgen(blob_id)) {\n+      assert(stub_data != nullptr, \"sanity\");\n+      read_stub_data(code_blob, stub_data);\n+    }\n+    \/\/ publish entries found either in stub_data or as offsets in blob\n+    AOTCodeCache::publish_stub_addresses(*code_blob, blob_id, stub_data);\n+  }\n+\n+  \/\/ Now that all the entry points are in the address table we can\n+  \/\/ read all the extra reloc info and fix up any addresses that need\n+  \/\/ patching to adjust for a new location in a new JVM. We can be\n+  \/\/ sure to correctly update all runtime references, including\n+  \/\/ cross-linked stubs that are internally daisy-chained. If\n+  \/\/ relocation fails and we have to re-generate any of the stubs then\n+  \/\/ the entry points for newly generated stubs will get updated,\n+  \/\/ ensuring that any other stubs or nmethods we need to relocate\n+  \/\/ will use the correct address.\n+\n+  \/\/ if we have a relocatable code blob then the relocs are already\n+  \/\/ attached to the blob and we can iterate over it to find the ones\n+  \/\/ we need to patch. With a non-relocatable code blob we need to\n+  \/\/ wrap it with a CodeBuffer and then reattach the relocs to the\n+  \/\/ code buffer.\n+\n+  if (AOTCodeEntry::is_multi_stub_blob(entry_kind)) {\n+    \/\/ the blob doesn't have any proper runtime relocs but we can\n+    \/\/ reinstate the AOT-load time relocs we saved from the code\n+    \/\/ buffer that generated this blob in a new code buffer and use\n+    \/\/ the latter to iterate over them\n+    CodeBuffer code_buffer(code_blob);\n+    relocInfo* locs = (relocInfo*)reloc_data;\n+    code_buffer.insts()->initialize_shared_locs(locs, reloc_count);\n+    code_buffer.insts()->set_locs_end(locs + reloc_count);\n+    CodeSection *cs = code_buffer.code_section(CodeBuffer::SECT_INSTS);\n+    RelocIterator reloc_iter(cs);\n+    fix_relocations(code_blob, reloc_iter);\n+  } else {\n+    \/\/ the AOT-load time relocs will be in the blob's restored relocs\n+    RelocIterator reloc_iter(code_blob);\n+    fix_relocations(code_blob, reloc_iter);\n+  }\n@@ -990,1 +1311,137 @@\n-\/\/ ------------ process code and data --------------\n+void AOTCodeReader::read_stub_data(CodeBlob* code_blob, AOTStubData* stub_data) {\n+  GrowableArray<address>& addresses = stub_data->address_array();\n+  \/\/ Read the list of stub ids and associated start, end, secondary\n+  \/\/ and extra addresses and install them in the stub data.\n+  \/\/\n+  \/\/ Also insert all start and secondary addresses into the AOTCache\n+  \/\/ address table so we correctly relocate this blob and any followng\n+  \/\/ blobs\/nmethods.\n+  \/\/\n+  \/\/ n.b. if an error occurs and we need to regenerate any of these\n+  \/\/ stubs the address table will be updated as a side-effect of\n+  \/\/ regeneration.\n+\n+  address blob_base = code_blob->code_begin();\n+  uint blob_size = (uint)(code_blob->code_end() - blob_base);\n+  int offset = read_position();\n+  LogStreamHandle(Trace, aot, codecache, stubs) log;\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== Stub data starts at offset %d\", offset);\n+  }\n+  \/\/ read stub and entries until we see NO_STUBID\n+  StubId stub_id = *(StubId*)addr(offset); offset += sizeof(StubId);\n+  \/\/ we ought to have at least one saved stub in the blob\n+  assert(stub_id != StubId::NO_STUBID, \"blob %s contains no stubs!\", StubInfo::name(stub_data->blob_id()));\n+  while (stub_id != StubId::NO_STUBID) {\n+    assert(StubInfo::blob(stub_id) == stub_data->blob_id(), \"sanity\");\n+    int idx = StubInfo::stubgen_offset_in_blob(stub_data->blob_id(), stub_id);\n+    StubAddrRange& range = stub_data->get_range(idx);\n+    \/\/ we should only see a stub once\n+    assert(range.start_index() < 0, \"repeated entry for stub %s\", StubInfo::name(stub_id));\n+    int address_base = addresses.length();\n+    \/\/ start is an offset from the blob base\n+    uint start = *(uint*)addr(offset); offset += sizeof(uint);\n+    assert(start < blob_size, \"stub %s start offset %d exceeds buffer length %d\", StubInfo::name(stub_id), start, blob_size);\n+    address stub_start = blob_base + start;\n+    addresses.append(stub_start);\n+    \/\/ end is an offset from the stub start\n+    uint end = *(uint*)addr(offset); offset += sizeof(uint);\n+    assert(start + end <= blob_size, \"stub %s end offset %d exceeds remaining buffer length %d\", StubInfo::name(stub_id), end, blob_size - start);\n+    addresses.append(stub_start + end);\n+    \/\/ read count of secondary entries plus extras\n+    int entries_count = *(int*)addr(offset); offset += sizeof(int);\n+    assert(entries_count >= (StubInfo::entry_count(stub_id) - 1), \"not enough entries for %s\", StubInfo::name(stub_id));\n+    for (int i = 0; i < entries_count; i++) {\n+      \/\/ entry offset is an offset from the stub start less than or\n+      \/\/ equal to end\n+      uint entry = *(uint*)addr(offset); offset += sizeof(uint);\n+      if (entry <= end) {\n+        \/\/ entry addresses may not address end but extras can\n+        assert(entry < end || i >= StubInfo::entry_count(stub_id),\n+               \"entry offset 0x%x exceeds stub length 0x%x for stub %s\",\n+               entry, end, StubInfo::name(stub_id));\n+        addresses.append(stub_start + entry);\n+      } else {\n+        \/\/ special case: entry encodes a nullptr\n+        assert(entry == AOTCodeCache::NULL_ADDRESS_MARKER, \"stub %s entry offset %d lies beyond stub end %d and does not equal NULL_ADDRESS_MARKER\", StubInfo::name(stub_id), entry, end);\n+        addresses.append(nullptr);\n+      }\n+    }\n+    if (log.is_enabled()) {\n+      log.print_cr(\"======== read stub %s and %d addresses up to offset %d\",\n+                   StubInfo::name(stub_id),  2 + entries_count, offset);\n+    }\n+    range.init_entry(address_base, 2 + entries_count);\n+    \/\/ move on to next stub or NO_STUBID\n+    stub_id = *(StubId*)addr(offset); offset += sizeof(StubId);\n+  }\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== Stub data ends at offset %d\", offset);\n+  }\n+\n+  set_read_position(offset);\n+}\n+\n+void AOTCodeCache::publish_external_addresses(GrowableArray<address>& addresses) {\n+  DEBUG_ONLY( _passed_init2 = true; )\n+  if (opened_cache == nullptr) {\n+    return;\n+  }\n+\n+  cache()->_table->add_external_addresses(addresses);\n+}\n+\n+void AOTCodeCache::publish_stub_addresses(CodeBlob &code_blob, BlobId blob_id, AOTStubData *stub_data) {\n+  if (stub_data != nullptr) {\n+    \/\/ register all entries in stub\n+    assert(StubInfo::stub_count(blob_id) > 1,\n+           \"multiple stub data provided for single stub blob %s\",\n+           StubInfo::name(blob_id));\n+    assert(blob_id == stub_data->blob_id(),\n+           \"blob id %s does not match id in stub data %s\",\n+           StubInfo::name(blob_id),\n+           StubInfo::name(stub_data->blob_id()));\n+    \/\/ iterate over all stubs in the blob\n+    StubId stub_id = StubInfo::stub_base(blob_id);\n+    int stub_cnt = StubInfo::stub_count(blob_id);\n+    GrowableArray<address>& addresses = stub_data->address_array();\n+    for (int i = 0; i < stub_cnt; i++) {\n+      assert(stub_id != StubId::NO_STUBID, \"sanity\");\n+      StubAddrRange& range = stub_data->get_range(i);\n+      int base = range.start_index();\n+      if (base >= 0) {\n+        cache()->add_stub_entries(stub_id, addresses.at(base), &addresses, base + 2);\n+      }\n+      stub_id = StubInfo::next_in_blob(blob_id, stub_id);\n+    }\n+    \/\/ we should have exhausted all stub ids in the blob\n+    assert(stub_id == StubId::NO_STUBID, \"sanity\");\n+  } else {\n+    \/\/ register entry or entries for a single stub blob\n+    StubId stub_id = StubInfo::stub_base(blob_id);\n+    assert(StubInfo::stub_count(blob_id) == 1,\n+           \"multiple stub blob %s provided without stub data\",\n+           StubInfo::name(blob_id));\n+    address start = code_blob.code_begin();\n+    if (StubInfo::entry_count(stub_id) == 1) {\n+      assert(!code_blob.is_deoptimization_stub(), \"expecting multiple entries for stub %s\", StubInfo::name(stub_id));\n+      \/\/ register the blob base address as the only entry\n+      cache()->add_stub_entries(stub_id, start);\n+    } else {\n+      assert(code_blob.is_deoptimization_stub(), \"only expecting one entry for stub %s\", StubInfo::name(stub_id));\n+      DeoptimizationBlob *deopt_blob = code_blob.as_deoptimization_blob();\n+      assert(deopt_blob->unpack() == start, \"unexpected offset 0x%x for deopt stub entry\", (int)(deopt_blob->unpack() - start));\n+      GrowableArray<address> addresses;\n+      addresses.append(deopt_blob->unpack_with_exception());\n+      addresses.append(deopt_blob->unpack_with_reexecution());\n+      addresses.append(deopt_blob->unpack_with_exception_in_tls());\n+#if INCLUDE_JVMCI\n+      addresses.append(deopt_blob->uncommon_trap());\n+      addresses.append(deopt_blob->implicit_exception_uncommon_trap());\n+#endif \/\/ INCLUDE_JVMCI\n+      cache()->add_stub_entries(stub_id, start, &addresses, 0);\n+    }\n+  }\n+}\n+\n+  \/\/ ------------ process code and data --------------\n@@ -996,1 +1453,1 @@\n-bool AOTCodeCache::write_relocations(CodeBlob& code_blob) {\n+bool AOTCodeCache::write_relocations(CodeBlob& code_blob, RelocIterator& iter) {\n@@ -998,1 +1455,0 @@\n-  RelocIterator iter(&code_blob);\n@@ -1052,0 +1508,5 @@\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== extra relocations count=%d\", count);\n+    log.print(   \"  {\");\n+  }\n+  bool first = true;\n@@ -1059,0 +1520,8 @@\n+    if (log.is_enabled()) {\n+      if (first) {\n+        first = false;\n+        log.print(\"%d\", value);\n+      } else {\n+        log.print(\", %d\", value);\n+      }\n+    }\n@@ -1060,0 +1529,1 @@\n+  log.print_cr(\"}\");\n@@ -1063,2 +1533,1 @@\n-void AOTCodeReader::fix_relocations(CodeBlob* code_blob) {\n-  LogStreamHandle(Trace, aot, reloc) log;\n+void AOTCodeReader::fix_relocations(CodeBlob *code_blob, RelocIterator& iter) {\n@@ -1066,1 +1535,1 @@\n-  int count = *(int*)addr(offset);\n+  int reloc_count = *(int*)addr(offset);\n@@ -1068,3 +1537,0 @@\n-  if (log.is_enabled()) {\n-    log.print_cr(\"======== extra relocations count=%d\", count);\n-  }\n@@ -1072,1 +1538,1 @@\n-  offset += (count * sizeof(uint));\n+  offset += (reloc_count * sizeof(uint));\n@@ -1075,1 +1541,16 @@\n-  RelocIterator iter(code_blob);\n+  LogStreamHandle(Trace, aot, codecache, reloc) log;\n+  if (log.is_enabled()) {\n+    log.print_cr(\"======== extra relocations count=%d\", reloc_count);\n+  }\n+  if (log.is_enabled()) {\n+    log.print(\"  {\");\n+    for(int i = 0; i < reloc_count; i++) {\n+      if (i == 0) {\n+        log.print(\"%d\", reloc_data[i]);\n+      } else {\n+        log.print(\", %d\", reloc_data[i]);\n+      }\n+    }\n+    log.print_cr(\"}\");\n+  }\n+\n@@ -1124,1 +1605,1 @@\n-  assert(j == count, \"sanity\");\n+  assert(j == reloc_count, \"sanity\");\n@@ -1234,7 +1715,6 @@\n-\/\/ address table ids for generated routines, external addresses and C\n-\/\/ string addresses are partitioned into positive integer ranges\n-\/\/ defined by the following positive base and max values\n-\/\/ i.e. [_extrs_base, _extrs_base + _extrs_max -1],\n-\/\/      [_blobs_base, _blobs_base + _blobs_max -1],\n-\/\/      ...\n-\/\/      [_c_str_base, _c_str_base + _c_str_max -1],\n+\/\/ address table ids for generated routine entry adresses, external\n+\/\/ addresses and C string addresses are partitioned into positive\n+\/\/ integer ranges defined by the following positive base and max\n+\/\/ values i.e. [_extrs_base, _extrs_base + _extrs_max -1],\n+\/\/ [_stubs_base, _stubs_base + _stubs_max -1], [_c_str_base,\n+\/\/ _c_str_base + _c_str_max -1],\n@@ -1242,7 +1722,2 @@\n-#define _extrs_max 100\n-#define _stubs_max 3\n-\n-#define _shared_blobs_max 20\n-#define _C1_blobs_max 10\n-#define _blobs_max (_shared_blobs_max+_C1_blobs_max)\n-#define _all_max (_extrs_max+_stubs_max+_blobs_max)\n+#define _extrs_max 350\n+#define _stubs_max static_cast<int>(EntryId::NUM_ENTRYIDS)\n@@ -1252,3 +1727,5 @@\n-#define _shared_blobs_base (_stubs_base + _stubs_max)\n-#define _C1_blobs_base (_shared_blobs_base + _shared_blobs_max)\n-#define _blobs_end  (_shared_blobs_base + _blobs_max)\n+#define _all_max    (_stubs_base + _stubs_max)\n+\n+\/\/ setter for external addresses and string addresses inserts new\n+\/\/ addresses in the order they are encountered them which must remain\n+\/\/ th esame across an assembly run and subsequent production run\n@@ -1267,2 +1744,0 @@\n-  assert(_blobs_end <= _all_max, \"AOTCodeAddress table ranges need adjusting\");\n-\n@@ -1274,0 +1749,9 @@\n+  {\n+    \/\/ Required by initial stubs\n+    SET_ADDRESS(_extrs, SharedRuntime::exception_handler_for_return_address); \/\/ used by forward_exception\n+    SET_ADDRESS(_extrs, CompressedOops::base_addr()); \/\/ used by call_stub\n+    SET_ADDRESS(_extrs, Thread::current); \/\/ used by call_stub\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_StackOverflowError);\n+    SET_ADDRESS(_extrs, SharedRuntime::throw_delayed_StackOverflowError);\n+  }\n+\n@@ -1282,0 +1766,70 @@\n+\n+#ifndef PRODUCT\n+  SET_ADDRESS(_extrs, &SharedRuntime::_jbyte_array_copy_ctr); \/\/ used by arraycopy stub on arm32 and x86_64\n+  SET_ADDRESS(_extrs, &SharedRuntime::_jshort_array_copy_ctr); \/\/ used by arraycopy stub\n+  SET_ADDRESS(_extrs, &SharedRuntime::_jint_array_copy_ctr); \/\/ used by arraycopy stub\n+  SET_ADDRESS(_extrs, &SharedRuntime::_jlong_array_copy_ctr); \/\/ used by arraycopy stub\n+  SET_ADDRESS(_extrs, &SharedRuntime::_oop_array_copy_ctr); \/\/ used by arraycopy stub\n+  SET_ADDRESS(_extrs, &SharedRuntime::_checkcast_array_copy_ctr); \/\/ used by arraycopy stub\n+  SET_ADDRESS(_extrs, &SharedRuntime::_unsafe_array_copy_ctr); \/\/ used by arraycopy stub\n+  SET_ADDRESS(_extrs, &SharedRuntime::_generic_array_copy_ctr); \/\/ used by arraycopy stub\n+  SET_ADDRESS(_extrs, &SharedRuntime::_unsafe_set_memory_ctr); \/\/ used by arraycopy stub\n+#endif \/* PRODUCT *\/\n+\n+  SET_ADDRESS(_extrs, SharedRuntime::enable_stack_reserved_zone);\n+\n+#if defined(AMD64) && !defined(ZERO)\n+  SET_ADDRESS(_extrs, SharedRuntime::montgomery_multiply);\n+  SET_ADDRESS(_extrs, SharedRuntime::montgomery_square);\n+#endif \/\/ defined(AMD64) && !defined(ZERO)\n+\n+  SET_ADDRESS(_extrs, SharedRuntime::d2f);\n+  SET_ADDRESS(_extrs, SharedRuntime::d2i);\n+  SET_ADDRESS(_extrs, SharedRuntime::d2l);\n+  SET_ADDRESS(_extrs, SharedRuntime::dcos);\n+  SET_ADDRESS(_extrs, SharedRuntime::dexp);\n+  SET_ADDRESS(_extrs, SharedRuntime::dlog);\n+  SET_ADDRESS(_extrs, SharedRuntime::dlog10);\n+  SET_ADDRESS(_extrs, SharedRuntime::dpow);\n+#ifndef ZERO\n+  SET_ADDRESS(_extrs, SharedRuntime::drem);\n+#endif\n+  SET_ADDRESS(_extrs, SharedRuntime::dsin);\n+  SET_ADDRESS(_extrs, SharedRuntime::dtan);\n+  SET_ADDRESS(_extrs, SharedRuntime::f2i);\n+  SET_ADDRESS(_extrs, SharedRuntime::f2l);\n+#ifndef ZERO\n+  SET_ADDRESS(_extrs, SharedRuntime::frem);\n+#endif\n+  SET_ADDRESS(_extrs, SharedRuntime::l2d);\n+  SET_ADDRESS(_extrs, SharedRuntime::l2f);\n+  SET_ADDRESS(_extrs, SharedRuntime::ldiv);\n+  SET_ADDRESS(_extrs, SharedRuntime::lmul);\n+  SET_ADDRESS(_extrs, SharedRuntime::lrem);\n+\n+#if INCLUDE_JVMTI\n+  SET_ADDRESS(_extrs, &JvmtiExport::_should_notify_object_alloc);\n+#endif \/* INCLUDE_JVMTI *\/\n+\n+  SET_ADDRESS(_extrs, ThreadIdentifier::unsafe_offset());\n+  SET_ADDRESS(_extrs, Thread::current);\n+\n+  SET_ADDRESS(_extrs, os::javaTimeMillis);\n+  SET_ADDRESS(_extrs, os::javaTimeNanos);\n+#ifndef PRODUCT\n+  SET_ADDRESS(_extrs, os::breakpoint);\n+#endif\n+\n+  SET_ADDRESS(_extrs, StubRoutines::crc_table_addr());\n+#ifndef PRODUCT\n+  SET_ADDRESS(_extrs, &SharedRuntime::_partial_subtype_ctr);\n+  SET_ADDRESS(_extrs, JavaThread::verify_cross_modify_fence_failure);\n+#endif\n+\n+#if INCLUDE_JFR\n+  SET_ADDRESS(_extrs, JfrIntrinsicSupport::write_checkpoint);\n+  SET_ADDRESS(_extrs, JfrIntrinsicSupport::return_lease);\n+#endif\n+\n+  SET_ADDRESS(_extrs, UpcallLinker::handle_uncaught_exception); \/\/ used by upcall_stub_exception_handler\n+\n@@ -1290,1 +1844,0 @@\n-    SET_ADDRESS(_extrs, SharedRuntime::throw_StackOverflowError);\n@@ -1301,1 +1854,0 @@\n-    SET_ADDRESS(_extrs, SharedRuntime::exception_handler_for_return_address);\n@@ -1318,1 +1870,0 @@\n-    SET_ADDRESS(_extrs, Runtime1::is_instance_of);\n@@ -1330,3 +1881,0 @@\n-#ifndef PRODUCT\n-    SET_ADDRESS(_extrs, os::breakpoint);\n-#endif\n@@ -1367,0 +1915,5 @@\n+  SET_ADDRESS(_extrs, G1BarrierSetRuntime::write_ref_array_pre_narrow_oop_entry); \/\/ used by arraycopy stubs\n+  SET_ADDRESS(_extrs, G1BarrierSetRuntime::write_ref_array_pre_oop_entry); \/\/ used by arraycopy stubs\n+  SET_ADDRESS(_extrs, G1BarrierSetRuntime::write_ref_array_post_entry); \/\/ used by arraycopy stubs\n+  SET_ADDRESS(_extrs, BarrierSetNMethod::nmethod_stub_entry_barrier); \/\/ used by method_entry_barrier\n+\n@@ -1386,2 +1939,4 @@\n-  _extrs_complete = true;\n-  log_debug(aot, codecache, init)(\"External addresses recorded\");\n+  log_debug(aot, codecache, init)(\"External addresses opened and recorded\");\n+  \/\/ allocate storage for stub entries\n+  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n+  log_debug(aot, codecache, init)(\"Stub addresses opened\");\n@@ -1390,8 +1945,3 @@\n-static bool initializing_early_stubs = false;\n-\n-void AOTCodeAddressTable::init_early_stubs() {\n-  if (_complete || initializing_early_stubs) return; \/\/ Done already\n-  initializing_early_stubs = true;\n-  _stubs_addr = NEW_C_HEAP_ARRAY(address, _stubs_max, mtCode);\n-  _stubs_length = 0;\n-  SET_ADDRESS(_stubs, StubRoutines::forward_exception_entry());\n+void AOTCodeAddressTable::init_extrs2() {\n+  assert(initializing_extrs && !_extrs_complete,\n+         \"invalid sequence for init_extrs2\");\n@@ -1400,5 +1950,3 @@\n-    \/\/ Required by C1 blobs\n-#if defined(AMD64) && !defined(ZERO)\n-    SET_ADDRESS(_stubs, StubRoutines::x86::double_sign_flip());\n-    SET_ADDRESS(_stubs, StubRoutines::x86::d2l_fixup());\n-#endif \/\/ AMD64\n+  SET_ADDRESS(_extrs, Continuation::prepare_thaw); \/\/ used by cont_thaw\n+  SET_ADDRESS(_extrs, Continuation::thaw_entry()); \/\/ used by cont_thaw\n+  SET_ADDRESS(_extrs, ContinuationEntry::thaw_call_pc_address()); \/\/ used by cont_preempt_stub\n@@ -1406,3 +1954,3 @@\n-\n-  _early_stubs_complete = true;\n-  log_info(aot, codecache, init)(\"Early stubs recorded\");\n+  _extrs_complete = true;\n+  initializing_extrs = false;\n+  log_debug(aot, codecache, init)(\"External addresses recorded and closed\");\n@@ -1411,13 +1959,9 @@\n-static bool initializing_shared_blobs = false;\n-\n-void AOTCodeAddressTable::init_shared_blobs() {\n-  if (_complete || initializing_shared_blobs) return; \/\/ Done already\n-  initializing_shared_blobs = true;\n-  address* blobs_addr = NEW_C_HEAP_ARRAY(address, _blobs_max, mtCode);\n-\n-  \/\/ Divide _shared_blobs_addr array to chunks because they could be initialized in parrallel\n-  _shared_blobs_addr = blobs_addr;\n-  _C1_blobs_addr = _shared_blobs_addr + _shared_blobs_max;\n-\n-  _shared_blobs_length = 0;\n-  _C1_blobs_length = 0;\n+void AOTCodeAddressTable::add_external_addresses(GrowableArray<address>& addresses) {\n+  assert(initializing_extrs && !_extrs_complete,\n+         \"invalid sequence for add_external_addresses\");\n+  for (int i = 0; i < addresses.length(); i++) {\n+    SET_ADDRESS(_extrs, addresses.at(i));\n+  }\n+  log_debug(aot, codecache, init)(\"Recorded %d additional external addresses\",\n+                                  addresses.length());\n+}\n@@ -1425,2 +1969,11 @@\n-  \/\/ clear the address table\n-  memset(blobs_addr, 0, sizeof(address)* _blobs_max);\n+void AOTCodeAddressTable::add_stub_entry(EntryId entry_id, address a) {\n+  assert(_extrs_complete || initializing_extrs,\n+         \"recording stub entry address before external addresses complete\");\n+  assert(!(StubInfo::is_shared(StubInfo::stub(entry_id)) && _shared_stubs_complete), \"too late to add shared entry\");\n+  assert(!(StubInfo::is_stubgen(StubInfo::stub(entry_id)) && _stubgen_stubs_complete), \"too late to add stubgen entry\");\n+  assert(!(StubInfo::is_c1(StubInfo::stub(entry_id)) && _c1_stubs_complete), \"too late to add c1 entry\");\n+  assert(!(StubInfo::is_c2(StubInfo::stub(entry_id)) && _c2_stubs_complete), \"too late to add c2 entry\");\n+  log_debug(aot, stubs)(\"Recording address 0x%p for %s entry %s\", a, StubInfo::name(StubInfo::stubgroup(entry_id)), StubInfo::name(entry_id));\n+  int idx = static_cast<int>(entry_id);\n+  _stubs_addr[idx] = a;\n+}\n@@ -1428,13 +1981,5 @@\n-  \/\/ Record addresses of generated code blobs\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::get_handle_wrong_method_stub());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::get_ic_miss_stub());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_reexecution());\n-  SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->unpack_with_exception_in_tls());\n-#if INCLUDE_JVMCI\n-  if (EnableJVMCI) {\n-    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->uncommon_trap());\n-    SET_ADDRESS(_shared_blobs, SharedRuntime::deopt_blob()->implicit_exception_uncommon_trap());\n-  }\n-#endif\n+void AOTCodeAddressTable::set_shared_stubs_complete() {\n+  assert(!_shared_stubs_complete, \"repeated close for shared stubs!\");\n+  _shared_stubs_complete = true;\n+  log_debug(aot, codecache, init)(\"Shared stubs closed\");\n+}\n@@ -1442,3 +1987,4 @@\n-  _shared_blobs_complete = true;\n-  log_debug(aot, codecache, init)(\"Early shared blobs recorded\");\n-  _complete = true;\n+void AOTCodeAddressTable::set_c1_stubs_complete() {\n+  assert(!_c1_stubs_complete, \"repeated close for c1 stubs!\");\n+  _c1_stubs_complete = true;\n+  log_debug(aot, codecache, init)(\"C1 stubs closed\");\n@@ -1447,21 +1993,4 @@\n-void AOTCodeAddressTable::init_early_c1() {\n-#ifdef COMPILER1\n-  \/\/ Runtime1 Blobs\n-  StubId id = StubInfo::stub_base(StubGroup::C1);\n-  \/\/ include forward_exception in range we publish\n-  StubId limit = StubInfo::next(StubId::c1_forward_exception_id);\n-  for (; id != limit; id = StubInfo::next(id)) {\n-    if (Runtime1::blob_for(id) == nullptr) {\n-      log_info(aot, codecache, init)(\"C1 blob %s is missing\", Runtime1::name_for(id));\n-      continue;\n-    }\n-    if (Runtime1::entry_for(id) == nullptr) {\n-      log_info(aot, codecache, init)(\"C1 blob %s is missing entry\", Runtime1::name_for(id));\n-      continue;\n-    }\n-    address entry = Runtime1::entry_for(id);\n-    SET_ADDRESS(_C1_blobs, entry);\n-  }\n-#endif \/\/ COMPILER1\n-  assert(_C1_blobs_length <= _C1_blobs_max, \"increase _C1_blobs_max to %d\", _C1_blobs_length);\n-  _early_c1_complete = true;\n+void AOTCodeAddressTable::set_c2_stubs_complete() {\n+  assert(!_c2_stubs_complete, \"repeated close for c2 stubs!\");\n+  _c2_stubs_complete = true;\n+  log_debug(aot, codecache, init)(\"C2 stubs closed\");\n@@ -1470,1 +1999,5 @@\n-#undef SET_ADDRESS\n+void AOTCodeAddressTable::set_stubgen_stubs_complete() {\n+  assert(!_stubgen_stubs_complete, \"repeated close for stubgen stubs!\");\n+  _stubgen_stubs_complete = true;\n+  log_debug(aot, codecache, init)(\"StubGen stubs closed\");\n+}\n@@ -1479,3 +2012,0 @@\n-  if (_shared_blobs_addr != nullptr) {\n-    FREE_C_HEAP_ARRAY(address, _shared_blobs_addr);\n-  }\n@@ -1566,1 +2096,1 @@\n-  if (_extrs_complete) {\n+  if (_extrs_complete || initializing_extrs) {\n@@ -1629,1 +2159,1 @@\n-  assert(_extrs_complete, \"AOT Code Cache VM runtime addresses table is not complete\");\n+  assert(_extrs_complete || initializing_extrs, \"AOT Code Cache VM runtime addresses table is not complete\");\n@@ -1646,1 +2176,1 @@\n-  if (id >= _stubs_base && id < _stubs_base + _stubs_length) {\n+  if (id >= _stubs_base && id < _c_str_base) {\n@@ -1649,6 +2179,0 @@\n-  if (id >= _shared_blobs_base && id < _shared_blobs_base + _shared_blobs_length) {\n-    return _shared_blobs_addr[id - _shared_blobs_base];\n-  }\n-  if (id >= _C1_blobs_base && id < _C1_blobs_base + _C1_blobs_length) {\n-    return _C1_blobs_addr[id - _C1_blobs_base];\n-  }\n@@ -1663,1 +2187,1 @@\n-  assert(_extrs_complete, \"AOT Code Cache VM runtime addresses table is not complete\");\n+  assert(_extrs_complete || initializing_extrs, \"AOT Code Cache VM runtime addresses table is not complete\");\n@@ -1673,3 +2197,3 @@\n-  if (StubRoutines::contains(addr)) {\n-    \/\/ Search in stubs\n-    id = search_address(addr, _stubs_addr, _stubs_length);\n+  if (StubRoutines::contains(addr) || CodeCache::find_blob(addr) != nullptr) {\n+    \/\/ Search for a matching stub entry\n+    id = search_address(addr, _stubs_addr, _stubs_max);\n@@ -1687,27 +2211,16 @@\n-    CodeBlob* cb = CodeCache::find_blob(addr);\n-    if (cb != nullptr) {\n-      \/\/ Search in code blobs\n-      int id_base = _shared_blobs_base;\n-      id = search_address(addr, _shared_blobs_addr, _blobs_max);\n-      if (id < 0) {\n-        assert(false, \"Address \" INTPTR_FORMAT \" for Blob:%s is missing in AOT Code Cache addresses table\", p2i(addr), cb->name());\n-      } else {\n-        return id_base + id;\n-      }\n-    } else {\n-      \/\/ Search in runtime functions\n-      id = search_address(addr, _extrs_addr, _extrs_length);\n-      if (id < 0) {\n-        ResourceMark rm;\n-        const int buflen = 1024;\n-        char* func_name = NEW_RESOURCE_ARRAY(char, buflen);\n-        int offset = 0;\n-        if (os::dll_address_to_function_name(addr, func_name, buflen, &offset)) {\n-          if (offset > 0) {\n-            \/\/ Could be address of C string\n-            uint dist = (uint)pointer_delta(addr, (address)os::init, 1);\n-            log_debug(aot, codecache)(\"Address \" INTPTR_FORMAT \" (offset %d) for runtime target '%s' is missing in AOT Code Cache addresses table\",\n-                                      p2i(addr), dist, (const char*)addr);\n-            assert(dist > (uint)(_all_max + MAX_STR_COUNT), \"change encoding of distance\");\n-            return dist;\n-          }\n+    \/\/ Search in runtime functions\n+    id = search_address(addr, _extrs_addr, _extrs_length);\n+    if (id < 0) {\n+      ResourceMark rm;\n+      const int buflen = 1024;\n+      char* func_name = NEW_RESOURCE_ARRAY(char, buflen);\n+      int offset = 0;\n+      if (os::dll_address_to_function_name(addr, func_name, buflen, &offset)) {\n+        if (offset > 0) {\n+          \/\/ Could be address of C string\n+          uint dist = (uint)pointer_delta(addr, (address)os::init, 1);\n+          log_debug(aot, codecache)(\"Address \" INTPTR_FORMAT \" (offset %d) for runtime target '%s' is missing in AOT Code Cache addresses table\",\n+                                    p2i(addr), dist, (const char*)addr);\n+          assert(dist > (uint)(_all_max + MAX_STR_COUNT), \"change encoding of distance\");\n+          return dist;\n+        }\n@@ -1715,4 +2228,4 @@\n-          reloc.print_current_on(tty);\n-          code_blob->print_on(tty);\n-          code_blob->print_code_on(tty);\n-          assert(false, \"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n+        reloc.print_current_on(tty);\n+        code_blob->print_on(tty);\n+        code_blob->print_code_on(tty);\n+        assert(false, \"Address \" INTPTR_FORMAT \" for runtime target '%s+%d' is missing in AOT Code Cache addresses table\", p2i(addr), func_name, offset);\n@@ -1720,1 +2233,1 @@\n-        } else {\n+      } else {\n@@ -1722,5 +2235,5 @@\n-          reloc.print_current_on(tty);\n-          code_blob->print_on(tty);\n-          code_blob->print_code_on(tty);\n-          os::find(addr, tty);\n-          assert(false, \"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n+        reloc.print_current_on(tty);\n+        code_blob->print_on(tty);\n+        code_blob->print_code_on(tty);\n+        os::find(addr, tty);\n+        assert(false, \"Address \" INTPTR_FORMAT \" for <unknown>\/('%s') is missing in AOT Code Cache addresses table\", p2i(addr), (const char*)addr);\n@@ -1728,3 +2241,0 @@\n-        }\n-      } else {\n-        return _extrs_base + id;\n@@ -1732,0 +2242,2 @@\n+    } else {\n+      return _extrs_base + id;\n@@ -1760,0 +2272,159 @@\n+\n+\/\/ methods for managing entries in multi-stub blobs\n+\n+\n+AOTStubData::AOTStubData(BlobId blob_id) :\n+  _blob_id(blob_id),\n+  _cached_blob(nullptr),\n+  _stub_cnt(0),\n+  _ranges(nullptr),\n+  _flags(0) {\n+  assert(StubInfo::is_stubgen(blob_id),\n+         \"AOTStubData expects a multi-stub blob not %s\",\n+         StubInfo::name(blob_id));\n+\n+  \/\/ we cannot save or restore preuniversestubs because the cache\n+  \/\/ cannot be accessed before initialising the universe\n+  if (blob_id == BlobId::stubgen_preuniverse_id) {\n+    \/\/ invalidate any attempt to use this\n+    _flags |= INVALID;\n+    return;\n+  }\n+  if (AOTCodeCache::is_on()) {\n+    \/\/ allow update of stub entry addresses\n+    _flags |= OPEN;\n+    if (AOTCodeCache::is_using_stub()) {\n+      \/\/ allow stub loading\n+      _flags |= USING;\n+    }\n+    if (AOTCodeCache::is_dumping_stub()) {\n+      \/\/ allow stub saving\n+      _flags |= DUMPING;\n+    }\n+    \/\/ we need to track all the blob's entries\n+    _stub_cnt = StubInfo::stub_count(_blob_id);\n+    _ranges = NEW_C_HEAP_ARRAY(StubAddrRange, _stub_cnt, mtCode);\n+    for (int i = 0; i < _stub_cnt; i++) {\n+      _ranges[i].default_init();\n+    }\n+  }\n+}\n+\n+bool AOTStubData::load_code_blob() {\n+  assert(is_using(), \"should not call\");\n+  assert(!is_invalid() && _cached_blob == nullptr, \"repeated init\");\n+  _cached_blob = AOTCodeCache::load_code_blob(AOTCodeEntry::StubGenBlob,\n+                                              _blob_id,\n+                                              this);\n+  if (_cached_blob == nullptr) {\n+    set_invalid();\n+    return false;\n+  } else {\n+    return true;\n+  }\n+}\n+\n+bool AOTStubData::store_code_blob(CodeBlob& new_blob, CodeBuffer *code_buffer) {\n+  assert(is_dumping(), \"should not call\");\n+  assert(_cached_blob == nullptr, \"should not be loading and storing!\");\n+  if (!AOTCodeCache::store_code_blob(new_blob,\n+                                     AOTCodeEntry::StubGenBlob,\n+                                     _blob_id, this, code_buffer)) {\n+    set_invalid();\n+    return false;\n+  } else {\n+    return true;\n+  }\n+}\n+\n+address AOTStubData::load_archive_data(StubId stub_id, address& end, GrowableArray<address>* entries, GrowableArray<address>* extras) {\n+  assert(StubInfo::blob(stub_id) == _blob_id, \"sanity check\");\n+  if (is_invalid()) {\n+    return nullptr;\n+  }\n+  int idx = StubInfo::stubgen_offset_in_blob(_blob_id, stub_id);\n+  assert(idx >= 0 && idx < _stub_cnt, \"invalid index %d for stub count %d\", idx, _stub_cnt);\n+  \/\/ ensure we have a valid associated range\n+  StubAddrRange &range = _ranges[idx];\n+  int base = range.start_index();\n+  if (base < 0) {\n+#ifdef DEBUG\n+    \/\/ reset index so we can idenitfy which ones we failed to find\n+    range.init_entry(-2, 0);\n+#endif\n+    return nullptr;\n+  }\n+  int count = range.count();\n+  assert(base >= 0, \"sanity\");\n+  assert(count >= 2, \"sanity\");\n+  \/\/ first two saved addresses are start and end\n+  address start = _address_array.at(base);\n+  end = _address_array.at(base + 1);\n+  assert(start != nullptr, \"failed to load start address of stub %s\", StubInfo::name(stub_id));\n+  assert(end != nullptr, \"failed to load end address of stub %s\", StubInfo::name(stub_id));\n+  assert(start < end, \"start address %p should be less than end %p address for stub %s\", start, end, StubInfo::name(stub_id));\n+\n+  int entry_count = StubInfo::entry_count(stub_id);\n+  \/\/ the address count must at least include the stub start, end\n+  \/\/ and secondary addresses\n+  assert(count >= entry_count + 1, \"stub %s requires %d saved addresses but only has %d\", StubInfo::name(stub_id), entry_count + 1, count);\n+\n+  \/\/ caller must retrieve secondary entries if and only if they exist\n+  assert((entry_count == 1) == (entries == nullptr), \"trying to retrieve wrong number of entries for stub %s\", StubInfo::name(stub_id));\n+  int index = 2;\n+  if (entries != nullptr) {\n+    assert(entries->length() == 0, \"non-empty array when retrieving entries for stub %s!\", StubInfo::name(stub_id));\n+    while (index < entry_count + 1) {\n+      address entry = _address_array.at(base + index++);\n+      assert(entry == nullptr || (start < entry && entry < end), \"entry address %p not in range (%p, %p) for stub %s\", entry, start, end, StubInfo::name(stub_id));\n+      entries->append(entry);\n+    }\n+  }\n+  \/\/ caller must retrieve extras if and only if they exist\n+  assert((index < count) == (extras != nullptr), \"trying to retrieve wrong number of extras for stub %s\", StubInfo::name(stub_id));\n+  if (extras != nullptr) {\n+    assert(extras->length() == 0, \"non-empty array when retrieving extras for stub %s!\", StubInfo::name(stub_id));\n+    while (index < count) {\n+      address extra = _address_array.at(base + index++);\n+      assert(extra == nullptr || (start <= extra && extra <= end), \"extra address %p not in range (%p, %p) for stub %s\", extra, start, end, StubInfo::name(stub_id));\n+      extras->append(extra);\n+    }\n+  }\n+\n+  return start;\n+}\n+\n+void AOTStubData::store_archive_data(StubId stub_id, address start, address end, GrowableArray<address>* entries, GrowableArray<address>* extras) {\n+  assert(StubInfo::blob(stub_id) == _blob_id, \"sanity check\");\n+  assert(start != nullptr, \"start address cannot be null\");\n+  assert(end != nullptr, \"end address cannot be null\");\n+  assert(start < end, \"start address %p should be less than end %p address for stub %s\", start, end, StubInfo::name(stub_id));\n+  int idx = StubInfo::stubgen_offset_in_blob(_blob_id, stub_id);\n+  StubAddrRange& range = _ranges[idx];\n+  assert(range.start_index() == -1, \"sanity\");\n+  int base = _address_array.length();\n+  assert(base >= 0, \"sanity\");\n+  \/\/ first two saved addresses are start and end\n+  _address_array.append(start);\n+  _address_array.append(end);\n+  \/\/ caller must save secondary entries if and only if they exist\n+  assert((StubInfo::entry_count(stub_id) == 1) == (entries == nullptr), \"trying to save wrong number of entries for stub %s\", StubInfo::name(stub_id));\n+  if (entries != nullptr) {\n+    assert(entries->length() == StubInfo::entry_count(stub_id) - 1, \"incorrect entry count %d when saving entries for stub %s!\", entries->length(), StubInfo::name(stub_id));\n+    for (int i = 0; i < entries->length(); i++) {\n+      address entry = entries->at(i);\n+      assert(entry == nullptr || (start < entry && entry < end), \"entry address %p not in range (%p, %p) for stub %s\", entry, start, end, StubInfo::name(stub_id));\n+      _address_array.append(entry);\n+    }\n+  }\n+  \/\/ caller may wish to save extra addresses\n+  if (extras != nullptr) {\n+    for (int i = 0; i < extras->length(); i++) {\n+      address extra = extras->at(i);\n+      \/\/ handler range end may be end -- it gets restored as nullptr\n+      assert(extra == nullptr || (start <= extra && extra <= end), \"extra address %p not in range (%p, %p) for stub %s\", extra, start, end, StubInfo::name(stub_id));\n+      _address_array.append(extra);\n+    }\n+  }\n+  range.init_entry(base, _address_array.length() - base);\n+}\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.cpp","additions":863,"deletions":192,"binary":false,"changes":1055,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class AOTCodeReader;\n@@ -55,0 +56,1 @@\n+  Fn(StubGenBlob) \\\n@@ -116,1 +118,3 @@\n-  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob; }\n+  static bool is_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob || kind == StubGenBlob; }\n+  static bool is_single_stub_blob(Kind kind) { return kind == SharedBlob || kind == C1Blob || kind == C2Blob || kind == StubGenBlob; }\n+  static bool is_multi_stub_blob(Kind kind) { return kind == StubGenBlob; }\n@@ -125,2 +129,0 @@\n-  address* _shared_blobs_addr;\n-  address* _C1_blobs_addr;\n@@ -128,3 +130,0 @@\n-  uint     _stubs_length;\n-  uint     _shared_blobs_length;\n-  uint     _C1_blobs_length;\n@@ -133,3 +132,4 @@\n-  bool _early_stubs_complete;\n-  bool _shared_blobs_complete;\n-  bool _early_c1_complete;\n+  bool _shared_stubs_complete;\n+  bool _c1_stubs_complete;\n+  bool _c2_stubs_complete;\n+  bool _stubgen_stubs_complete;\n@@ -142,2 +142,0 @@\n-    _shared_blobs_addr(nullptr),\n-    _C1_blobs_addr(nullptr),\n@@ -145,3 +143,0 @@\n-    _stubs_length(0),\n-    _shared_blobs_length(0),\n-    _C1_blobs_length(0),\n@@ -149,3 +144,4 @@\n-    _early_stubs_complete(false),\n-    _shared_blobs_complete(false),\n-    _early_c1_complete(false),\n+    _shared_stubs_complete(false),\n+    _c1_stubs_complete(false),\n+    _c2_stubs_complete(false),\n+    _stubgen_stubs_complete(false),\n@@ -156,3 +152,7 @@\n-  void init_early_stubs();\n-  void init_shared_blobs();\n-  void init_early_c1();\n+  void init_extrs2();\n+  void add_stub_entry(EntryId entry_id, address entry);\n+  void add_external_addresses(GrowableArray<address>& addresses) NOT_CDS_RETURN;\n+  void set_shared_stubs_complete();\n+  void set_c1_stubs_complete();\n+  void set_c2_stubs_complete();\n+  void set_stubgen_stubs_complete();\n@@ -166,0 +166,95 @@\n+\/\/ Auxiliary class used by AOTStubData to locate addresses owned by a\n+\/\/ stub in the _address_array.\n+\n+class StubAddrRange {\n+private:\n+  \/\/ Index of the first address owned by a stub or -1 if none present\n+  int _start_index;\n+  \/\/ Total number of addresses owned by a stub, including in order:\n+  \/\/ start address for stub code and first entry, (exclusive) end\n+  \/\/ address for stub code, all secondary entry addresses, any\n+  \/\/ auxiliary addresses\n+  uint _naddr;\n+ public:\n+  StubAddrRange() : _start_index(-1), _naddr(0) {}\n+  int start_index() { return _start_index; }\n+  int count() { return _naddr; }\n+\n+  void default_init() {\n+    _start_index = -1;\n+    _naddr = 0;\n+  }\n+\n+  void init_entry(int start_index, int naddr) {\n+    _start_index = start_index;\n+    _naddr = naddr;\n+  }\n+};\n+\n+\/\/ class used to save and restore details of stubs embedded in a\n+\/\/ multi-stub (StubGen) blob\n+\n+class AOTStubData : public StackObj {\n+  friend class AOTCodeCache;\n+  friend class AOTCodeReader;\n+private:\n+  BlobId _blob_id; \/\/ must be a stubgen blob id\n+  \/\/ whatever buffer blob was successfully loaded from the AOT cache\n+  \/\/ following a call to load_code_blob or nullptr\n+  CodeBlob *_cached_blob;\n+  \/\/ Array of addresses owned by stubs. Each stub appends addresses to\n+  \/\/ this array as a block, whether at the end of generation or at the\n+  \/\/ end of restoration from the cache. The first two addresses in\n+  \/\/ each block are the \"start\" and \"end2 address of the stub. Any\n+  \/\/ other visible addresses located within the range [start,end)\n+  \/\/ follow, either extra entries, data addresses or SEGV-protected\n+  \/\/ subrange start, end and handler addresses. In the special case\n+  \/\/ that the SEGV handler address is the (external) common address\n+  \/\/ handler the array will hold value nullptr.\n+  GrowableArray<address> _address_array;\n+  \/\/ count of how many stubs exist in the current blob (not all of\n+  \/\/ which may actually be generated)\n+  int _stub_cnt;\n+  \/\/ array identifying range of entries in _address_array for each stub\n+  \/\/ indexed by offset of stub in blob\n+  StubAddrRange* _ranges;\n+\n+  \/\/ flags indicating whether the AOT code cache is open and, if so,\n+  \/\/ whether we are loading or storing stubs.the first of those\n+  \/\/ cases whether we have encountered any invalid stubs or failed to\n+  \/\/ find a stub that was being generated\n+  enum Flags {\n+    OPEN    = 1 << 0,            \/\/ cache is open for use\n+    USING   = 1 << 1,            \/\/ open and loading stubs\n+    DUMPING = 1 << 2,            \/\/ open and storing stubs\n+    INVALID = 1 << 3,            \/\/ found invalid stub when loading\n+  };\n+\n+  uint32_t _flags;\n+\n+  void set_invalid() { _flags |= INVALID; }\n+\n+  StubAddrRange& get_range(int idx) const { return _ranges[idx]; }\n+  GrowableArray<address>& address_array() { return _address_array; }\n+  \/\/ accessor for entry\/auxiliary addresses defaults to start entry\n+public:\n+  AOTStubData(BlobId blob_id) NOT_CDS({});\n+\n+  ~AOTStubData()    CDS_ONLY({FREE_C_HEAP_ARRAY(StubAddrRange, _ranges);}) NOT_CDS({})\n+\n+  bool is_open()    CDS_ONLY({ return (_flags & OPEN) != 0; }) NOT_CDS_RETURN_(false);\n+  bool is_using()   CDS_ONLY({ return (_flags & USING) != 0; }) NOT_CDS_RETURN_(false);\n+  bool is_dumping() CDS_ONLY({ return (_flags & DUMPING) != 0; }) NOT_CDS_RETURN_(false);\n+  bool is_aot()     CDS_ONLY({ return is_using() || is_dumping(); }) NOT_CDS_RETURN_(false);\n+  bool is_invalid() CDS_ONLY({ return (_flags & INVALID) != 0; }) NOT_CDS_RETURN_(false);\n+\n+  BlobId blob_id() { return _blob_id; }\n+  bool load_code_blob() NOT_CDS_RETURN_(true);\n+  bool store_code_blob(CodeBlob& new_blob, CodeBuffer *code_buffer) NOT_CDS_RETURN_(true);\n+\n+  address load_archive_data(StubId stub_id, address &end, GrowableArray<address>* entries = nullptr, GrowableArray<address>* extras = nullptr) NOT_CDS_RETURN_(nullptr);\n+  void store_archive_data(StubId stub_id, address start, address end, GrowableArray<address>* entries = nullptr, GrowableArray<address>* extras = nullptr) NOT_CDS_RETURN;\n+\n+  const AOTStubData* as_const() { return (const AOTStubData*)this; }\n+};\n+\n@@ -207,0 +302,1 @@\n+    uint   _stubgen_blobs_count;\n@@ -213,4 +309,5 @@\n-              uint strings_count,  uint strings_offset,\n-              uint entries_count,  uint entries_offset,\n-              uint adapters_count, uint shared_blobs_count,\n-              uint C1_blobs_count, uint C2_blobs_count) {\n+              uint strings_count,       uint strings_offset,\n+              uint entries_count,       uint entries_offset,\n+              uint adapters_count,      uint shared_blobs_count,\n+              uint stubgen_blobs_count, uint C1_blobs_count,\n+              uint C2_blobs_count) {\n@@ -225,0 +322,1 @@\n+      _stubgen_blobs_count = stubgen_blobs_count;\n@@ -237,0 +335,1 @@\n+    uint stubgen_blobs_count()   const { return _stubgen_blobs_count; }\n@@ -287,0 +386,1 @@\n+  void add_stub_entry(EntryId entry_id, address entry) NOT_CDS_RETURN;\n@@ -303,3 +403,6 @@\n-  static void init_early_stubs_table() NOT_CDS_RETURN;\n-  static void init_shared_blobs_table() NOT_CDS_RETURN;\n-  static void init_early_c1_table() NOT_CDS_RETURN;\n+  static void set_shared_stubs_complete() NOT_CDS_RETURN;\n+  static void set_c1_stubs_complete() NOT_CDS_RETURN ;\n+  static void set_c2_stubs_complete() NOT_CDS_RETURN;\n+  static void set_stubgen_stubs_complete() NOT_CDS_RETURN;\n+\n+  void add_stub_entries(StubId stub_id, address start, GrowableArray<address> *entries = nullptr, int offset = -1) NOT_CDS_RETURN;\n@@ -325,1 +428,1 @@\n-  bool write_relocations(CodeBlob& code_blob);\n+  bool write_relocations(CodeBlob& code_blob, RelocIterator& iter);\n@@ -327,0 +430,1 @@\n+  bool write_stub_data(CodeBlob& blob, AOTStubData *stub_data);\n@@ -332,0 +436,15 @@\n+private:\n+  \/\/ internal private API to save and restore blobs\n+  static bool store_code_blob(CodeBlob& blob,\n+                              AOTCodeEntry::Kind entry_kind,\n+                              uint id,\n+                              const char* name,\n+                              AOTStubData* stub_data,\n+                              CodeBuffer* code_buffer) NOT_CDS_RETURN_(false);\n+\n+  static CodeBlob* load_code_blob(AOTCodeEntry::Kind kind,\n+                                  uint id,\n+                                  const char* name,\n+                                  AOTStubData* stub_data) NOT_CDS_RETURN_(nullptr);\n+\n+public:\n@@ -335,1 +454,2 @@\n-                              uint id, const char* name) NOT_CDS_RETURN_(false);\n+                              uint id,\n+                              const char* name) NOT_CDS_RETURN_(false);\n@@ -341,0 +461,2 @@\n+\n+  \/\/ API for single-stub blobs\n@@ -348,0 +470,16 @@\n+  \/\/ API for multi-stub blobs -- for use by class StubGenerator.\n+\n+  static bool store_code_blob(CodeBlob& blob,\n+                              AOTCodeEntry::Kind kind,\n+                              BlobId id,\n+                              AOTStubData* stub_data,\n+                              CodeBuffer *code_buffer) NOT_CDS_RETURN_(false);\n+\n+  static CodeBlob* load_code_blob(AOTCodeEntry::Kind kind,\n+                                  BlobId id,\n+                                  AOTStubData* stub_data) NOT_CDS_RETURN_(nullptr);\n+\n+  static void publish_external_addresses(GrowableArray<address>& addresses) NOT_CDS_RETURN;\n+  \/\/ publish all entries for a code blob in code cache address table\n+  static void publish_stub_addresses(CodeBlob &code_blob, BlobId id, AOTStubData *stub_data) NOT_CDS_RETURN;\n+\n@@ -369,0 +507,4 @@\n+  \/\/ marker used where an address offset needs to be stored for later\n+  \/\/ retrieval and the address turns out to be null\n+  static const uint NULL_ADDRESS_MARKER = UINT_MAX;\n+\n@@ -372,0 +514,1 @@\n+  static void init3() NOT_CDS_RETURN;\n@@ -392,1 +535,1 @@\n-  const AOTCodeCache*  _cache;\n+  AOTCodeCache*  _cache;\n@@ -409,1 +552,1 @@\n-  CodeBlob* compile_code_blob(const char* name);\n+  CodeBlob* compile_code_blob(const char* name, AOTCodeEntry::Kind entry_kind, int id, AOTStubData* stub_data = nullptr);\n@@ -412,0 +555,3 @@\n+  void read_stub_data(CodeBlob* code_blob, AOTStubData *stub_data);\n+  void publish_stub_addresses(CodeBlob &code_blob, BlobId id, AOTStubData *stub_data);\n+\n@@ -413,1 +559,1 @@\n-  void fix_relocations(CodeBlob* code_blob);\n+  void fix_relocations(CodeBlob* code_blob, RelocIterator& iter);\n","filename":"src\/hotspot\/share\/code\/aotCodeCache.hpp","additions":178,"deletions":32,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -157,1 +158,2 @@\n-\n+  \/\/ disallow any further c1 stub generation\n+  AOTCodeCache::set_c2_stubs_complete();\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-    : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n+      : StubCodeGenerator(buffer, PrintMethodHandleStubs),\n","filename":"src\/hotspot\/share\/prims\/downcallLinker.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -73,0 +73,4 @@\n+\n+#if INCLUDE_CDS\n+void stubs_AOTAddressTable_init();\n+#endif \/\/ INCLUDE_CDS\n@@ -152,0 +156,4 @@\n+#if INCLUDE_CDS\n+  stubs_AOTAddressTable_init(); \/\/ publish external addresses used by stubs\n+                                \/\/ depends on AOTCodeCache::init2\n+#endif \/\/ INCLUDE_CDS\n@@ -154,1 +162,0 @@\n-  AOTCodeCache::init_early_stubs_table();  \/\/ need this after stubgen initial stubs and before shared runtime initial stubs\n@@ -158,1 +165,4 @@\n-  continuation_stubs_init(); \/\/ depends on continuations_init\n+  AOTCodeCache::init3();     \/\/ depends on stubs_AOTAddressTable_init\n+                             \/\/ and continuations_init and must\n+                             \/\/ precede continuation stub generation\n+  continuation_stubs_init(); \/\/ depends on continuations_init and AOTCodeCache::init3\n@@ -167,1 +177,0 @@\n-  AOTCodeCache::init_shared_blobs_table();  \/\/ need this after generate_stubs\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -177,0 +177,5 @@\n+\n+#if INCLUDE_CDS\n+  \/\/ disallow any further generation of runtime stubs\n+  AOTCodeCache::set_shared_stubs_complete();\n+#endif \/\/ INCLUDE_CDS\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -72,0 +73,1 @@\n+  _stub_data = nullptr;\n@@ -75,1 +77,1 @@\n-StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, BlobId blob_id, bool print_code) {\n+StubCodeGenerator::StubCodeGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data, bool print_code) {\n@@ -80,0 +82,1 @@\n+  _stub_data = stub_data;\n@@ -94,0 +97,45 @@\n+void StubCodeGenerator::setup_code_desc(const char* name, address start, address end, bool loaded_from_cache) {\n+  StubCodeDesc* cdesc = new StubCodeDesc(\"StubRoutines\", name, start, end);\n+  cdesc->set_disp(uint(start - _masm->code_section()->outer()->insts_begin()));\n+  if (loaded_from_cache) {\n+    cdesc->set_loaded_from_cache();\n+  }\n+  print_stub_code_desc(cdesc);\n+  \/\/ copied from ~StubCodeMark()\n+  Forte::register_stub(cdesc->name(), cdesc->begin(), cdesc->end());\n+  if (JvmtiExport::should_post_dynamic_code_generated()) {\n+    JvmtiExport::post_dynamic_code_generated(cdesc->name(), cdesc->begin(), cdesc->end());\n+  }\n+}\n+\n+\/\/ Helper used to restore ranges and handler addresses restored from\n+\/\/ AOT cache. Expects entries to contain 3 * count addresses beginning\n+\/\/ at offset begin which identify start of range, end of range and\n+\/\/ address of handler pc. start and end of range may not be null.\n+\/\/ handler pc may be null in which case it defaults to the\n+\/\/ default_handler.\n+\n+void StubCodeGenerator::register_unsafe_access_handlers(GrowableArray<address> &entries, int begin, int count) {\n+  for (int i = 0; i < count; i++) {\n+    int offset = begin + 3 * i;\n+    address start = entries.at(offset);\n+    address end = entries.at(offset + 1);\n+    address handler = entries.at(offset + 2);\n+    assert(start != nullptr, \"sanity\");\n+    assert(end != nullptr, \"sanity\");\n+    if (handler == nullptr) {\n+      assert(UnsafeMemoryAccess::common_exit_stub_pc() != nullptr,\n+             \"default unsafe handler must be set before registering unsafe rgeionwiht no handler!\");\n+      handler = UnsafeMemoryAccess::common_exit_stub_pc();\n+    }\n+    UnsafeMemoryAccess::add_to_table(start, end, handler);\n+  }\n+}\n+\n+\/\/ Helper used to retrieve ranges and handler addresses registered\n+\/\/ during generation of the stub which spans [start, end) in order to\n+\/\/ allow them to be saved to an AOT cache.\n+void StubCodeGenerator::retrieve_unsafe_access_handlers(address start, address end, GrowableArray<address> &entries) {\n+  UnsafeMemoryAccess::collect_entries(start, end, entries);\n+}\n+\n@@ -99,0 +147,4 @@\n+  print_stub_code_desc(cdesc);\n+}\n+\n+void StubCodeGenerator::print_stub_code_desc(StubCodeDesc* cdesc) {\n@@ -122,0 +174,46 @@\n+address StubCodeGenerator::load_archive_data(StubId stub_id, GrowableArray<address> *entries, GrowableArray<address>* extras) {\n+  \/\/ punt to stub data if it exists and is not for dumping\n+  if (_stub_data == nullptr || _stub_data->is_dumping()) {\n+    return nullptr;\n+  }\n+  \/\/ punt to stub data\n+  address start, end;\n+  start = _stub_data->load_archive_data(stub_id, end, entries, extras);\n+\n+  if (start != nullptr) {\n+    setup_code_desc(StubInfo::name(stub_id), start, end, true);\n+  }\n+\n+  return start;\n+}\n+\n+void StubCodeGenerator::store_archive_data(StubId stub_id, address start, address end, GrowableArray<address>* entries, GrowableArray<address>* extras) {\n+  \/\/ punt to stub data if we have any\n+  if (_stub_data != nullptr) {\n+    _stub_data->store_archive_data(stub_id, start, end, entries, extras);\n+  }\n+}\n+\n+void StubCodeGenerator::print_statistics_on(outputStream* st) {\n+  st->print_cr(\"StubRoutines Stubs:\");\n+  st->print_cr(\"  Initial stubs:         %d\", StubInfo::stub_count(BlobId::stubgen_initial_id));\n+  st->print_cr(\"  Continuation stubs:    %d\", StubInfo::stub_count(BlobId::stubgen_continuation_id));\n+  st->print_cr(\"  Compiler stubs:        %d\", StubInfo::stub_count(BlobId::stubgen_compiler_id));\n+  st->print_cr(\"  Final stubs:           %d\", StubInfo::stub_count(BlobId::stubgen_final_id));\n+\n+  int emitted = 0;\n+  int loaded_from_cache = 0;\n+\n+  StubCodeDesc* scd = StubCodeDesc::first();\n+  while (scd != nullptr) {\n+    if (!strcmp(scd->group(), \"StubRoutines\")) {\n+      emitted += 1;\n+      if (scd->loaded_from_cache()) {\n+        loaded_from_cache += 1;\n+      }\n+    }\n+    scd = StubCodeDesc::next(scd);\n+  }\n+  st->print_cr(\"Total stubroutines stubs emitted: %d (generated=%d, loaded from cache=%d)\", emitted, emitted - loaded_from_cache, loaded_from_cache);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.cpp","additions":99,"deletions":1,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"code\/aotCodeCache.hpp\"\n@@ -51,0 +52,1 @@\n+  bool                 _loaded_from_cache;\n@@ -68,0 +70,2 @@\n+  void set_loaded_from_cache() { _loaded_from_cache = true; }\n+\n@@ -84,0 +88,1 @@\n+    _loaded_from_cache = false;\n@@ -96,0 +101,1 @@\n+  bool        loaded_from_cache() const          { return _loaded_from_cache; }\n@@ -100,2 +106,0 @@\n-\/\/ forward declare blob and stub id enums\n-\n@@ -111,0 +115,6 @@\n+  AOTStubData* _stub_data;\n+\n+  void setup_code_desc(const char* name, address start, address end, bool loaded_from_cache);\n+  \/\/ unsafe handler management\n+  void register_unsafe_access_handlers(GrowableArray<address> &entries, int begin, int count);\n+  void retrieve_unsafe_access_handlers(address start, address end, GrowableArray<address> &entries);\n@@ -114,1 +124,1 @@\n-  StubCodeGenerator(CodeBuffer* code, BlobId blob_id, bool print_code = false);\n+  StubCodeGenerator(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data = nullptr, bool print_code = false);\n@@ -123,0 +133,49 @@\n+  void print_stub_code_desc(StubCodeDesc* cdesc);\n+\n+  static void print_statistics_on(outputStream* st);\n+\n+  \/\/ load_archive_data should be called before generating the stub\n+  \/\/ identified by stub_id. If AOT caching of stubs is enabled and the\n+  \/\/ stubis found then the address of the stub's first and, possibly,\n+  \/\/ only entry is returned and the caller should use it instead of\n+  \/\/ generating thestub. Otherwise a null address is returned and the\n+  \/\/ caller should proceed to generate the stub.\n+  \/\/\n+  \/\/ store_archive_data should be called when a stub has been\n+  \/\/ successfully generated into the current blob irrespctive of\n+  \/\/ whether the current JVM is generating or consuming an AOT archive\n+  \/\/ (the caller should not check for either case). When generating an\n+  \/\/ archive the stub entry and end addresses are recorded for storage\n+  \/\/ along with the current blob and also to allow rences to the stub\n+  \/\/ from other stubs or from compiled Java methods can be detected\n+  \/\/ and marked as requiring relocation. When consuming an archive the\n+  \/\/ stub entry address is still inorer to identify it as a relocation\n+  \/\/ target. When no archive is in use the call has no side effects.\n+  \/\/\n+  \/\/ start and end identify the inclusive start and exclusive end\n+  \/\/ address for stub code and must lie in the current blob's code\n+  \/\/ range. Stubs presented via this interface must declare at least\n+  \/\/ one entry and start is always taken to be the first entry.\n+  \/\/\n+  \/\/ Optional arrays entries and extras store other addresses of\n+  \/\/ interest all of which must either lie in the interval (start,\n+  \/\/ end) or be nullptr (verified by load and store methods).\n+  \/\/\n+  \/\/ entries lists secondary entries for the stub each of which must\n+  \/\/ match a corresponding entry declaration for the stub (entry count\n+  \/\/ verified by load and store methods). Null entry addresses are\n+  \/\/ allowed when an architecture does not require a specific entry\n+  \/\/ but may not vary from one run to the next. If the cache is in use\n+  \/\/ at a store (for loading or saving code) then non-null entry\n+  \/\/ addresses are entered into the AOT cache stub address table\n+  \/\/ allowing references to them from other stubs or nmethods to be\n+  \/\/ relocated.\n+  \/\/\n+  \/\/ extras lists other non-entry stub addresses of interest such as\n+  \/\/ memory protection ranges and associated handler addresses\n+  \/\/ (potentially including a null address). These do do not need to\n+  \/\/ be declared as entries and their number and meaning may vary\n+  \/\/ according to the architecture.\n+\n+  address load_archive_data(StubId stub_id, GrowableArray<address> *entries = nullptr, GrowableArray<address>* extras = nullptr);\n+  void store_archive_data(StubId stub_id, address start, address end, GrowableArray<address> *entries = nullptr, GrowableArray<address>* extras = nullptr);\n@@ -126,0 +185,1 @@\n+\n","filename":"src\/hotspot\/share\/runtime\/stubCodeGenerator.hpp","additions":63,"deletions":3,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -965,0 +965,3 @@\n+  do_entry(final, arrayof_jlong_arraycopy,                             \\\n+            arrayof_jlong_arraycopy_nopush,                             \\\n+            arrayof_jlong_arraycopy_nopush)                             \\\n@@ -968,0 +971,3 @@\n+  do_entry(final, arrayof_oop_arraycopy,                                \\\n+           arrayof_oop_arraycopy_nopush,                                \\\n+           arrayof_oop_arraycopy_nopush)                                \\\n","filename":"src\/hotspot\/share\/runtime\/stubDeclarations.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1090,0 +1090,9 @@\n+int StubInfo::stubgen_offset_in_blob(BlobId blob_id, StubId id) {\n+  assert(blob(id) == blob_id, \"sanity!\");\n+  StubGroup group = StubGroup::STUBGEN;\n+  assert(stubgroup(blob_id) == group, \"sanity\");\n+  StubId base_id = stub_base(blob_id);\n+  assert(base_id != StubId::NO_STUBID, \"sanity\");\n+  return local_offset(group, id) - local_offset(group, base_id);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -672,0 +672,5 @@\n+\n+  \/\/ Convert a stub id to a unique, zero-based offset in the range of\n+  \/\/ stub ids for a given blob in the stubgen stub group.\n+\n+  static int  stubgen_offset_in_blob(BlobId blob_id, StubId id);\n","filename":"src\/hotspot\/share\/runtime\/stubInfo.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -105,2 +105,1 @@\n-extern void StubGenerator_generate(CodeBuffer* code, BlobId blob_id); \/\/ only interface to generators\n-\n+extern void StubGenerator_generate(CodeBuffer* code, BlobId blob_id, AOTStubData* stub_data); \/\/ only interface to generators\n@@ -157,1 +156,2 @@\n-        \/\/ an address outside the stub must be the common exit stub address\n+        \/\/ an address outside the stub must be the common exit stub\n+        \/\/ address which is marked with a null address\n@@ -172,0 +172,27 @@\n+  \/\/ If we are loading stubs we need to check if we can retrieve a\n+  \/\/ blob and\/or an associated archived stub descriptor from the\n+  \/\/ AOTCodeCache. If we are storing stubs we need to create a blob\n+  \/\/ but we still need a stub data descriptor to fill in during\n+  \/\/ generation.\n+  AOTStubData stub_data(blob_id);\n+  AOTStubData* stub_data_p = nullptr;\n+  LogTarget(Info, stubs) lt;\n+\n+  if (code_size > 0 && stub_data.is_using()) {\n+    \/\/ AOTCodeEntry tracks and logs status of any cached blob\n+    bool loaded = stub_data.load_code_blob();\n+    if (loaded) {\n+      if (lt.is_enabled()) {\n+        LogStream ls(lt);\n+        ls.print_cr(\"Found blob %s in AOT cache\", StubInfo::name(blob_id));\n+      }\n+      stub_data_p = &stub_data;\n+    }\n+  } else if (stub_data.is_dumping()) {\n+    stub_data_p = &stub_data;\n+  }\n+\n+  \/\/ Even if we managed to load a blob from the AOT cache we still\n+  \/\/ need to allocate a code blob and associated buffer. The AOT blob\n+  \/\/ may not include all the stubs we need for this runtime.\n+\n@@ -181,0 +208,4 @@\n+    \/\/ TODO: Ideally we would still like to try to use any AOT cached\n+    \/\/ blob here but we don't have a fallback if we find that it is\n+    \/\/ missing stubs we need so for now we exit. This should only\n+    \/\/ happen in cases where we have a very small code cache.\n@@ -190,1 +221,4 @@\n-  StubGenerator_generate(&buffer, blob_id);\n+  short buffer_locs[20];\n+  buffer.insts()->initialize_shared_locs((relocInfo*)buffer_locs,\n+                                         sizeof(buffer_locs)\/sizeof(relocInfo));\n+  StubGenerator_generate(&buffer, blob_id, stub_data_p);\n@@ -193,1 +227,0 @@\n-    LogTarget(Info, stubs) lt;\n@@ -206,1 +239,29 @@\n-  LogTarget(Info, stubs) lt;\n+  if (stub_data.is_using()) {\n+    \/\/ we generated some new entries so republish all entries TODO -\n+    \/\/ ensure we publish collect and publish the preuniverse stubs but\n+    \/\/ don't try to save them\n+    AOTCodeCache::publish_stub_addresses(*stubs_code, blob_id, &stub_data);\n+    if (lt.is_enabled()) {\n+      LogStream ls(lt);\n+      ls.print_cr(\"Republished entries for blob '%s'\", buffer_name);\n+    }\n+  } else if (stub_data.is_dumping()) {\n+    \/\/ save the blob and publihs the entry addresses\n+    if (stub_data.store_code_blob(*stubs_code, &buffer)) {\n+      if (lt.is_enabled()) {\n+        LogStream ls(lt);\n+        ls.print_cr(\"Stored blob '%s' to Startup Code Cache\", buffer_name);\n+      }\n+    } else {\n+      if (lt.is_enabled()) {\n+        LogStream ls(lt);\n+        ls.print_cr(\"Failed to store blob '%s' to Startup Code Cache\", buffer_name);\n+      }\n+    }\n+  }\n+\n+  \/\/ close off recording of any further stubgen generation\n+  if (blob_id == BlobId::stubgen_final_id) {\n+    AOTCodeCache::set_stubgen_stubs_complete();\n+  }\n+\n@@ -217,0 +278,2 @@\n+\/\/ per blob initializer methods StubRoutines::initialize_xxx_stubs()\n+\n@@ -237,0 +300,1 @@\n+\/\/ external driver API functions for per blob init: xxx_stubs_init()\n@@ -247,0 +311,7 @@\n+\n+#if INCLUDE_CDS\n+\/\/ non-generated external API init driver function\n+\n+void stubs_AOTAddressTable_init() { StubRoutines::init_AOTAddressTable(); }\n+#endif \/\/ INCLUDE_CDS\n+\n@@ -248,4 +319,4 @@\n- * we generate the underlying driver method but this wrapper is needed\n- * to perform special handling depending on where the compiler init\n- * gets called from. it ought to be possible to remove this at some\n- * point and have a determinate ordered init.\n+ * we generate the underlying driver function compiler_stubs_init()\n+ * but this wrapper is needed to perform special handling depending on\n+ * where the compiler init gets called from. it ought to be possible\n+ * to remove this at some point and have a determinate ordered init.\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":81,"deletions":10,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+    assert(start_pc != nullptr, \"invalid start address\");\n@@ -286,0 +287,5 @@\n+#if INCLUDE_CDS\n+  \/\/ AOT Initalization -- implementation is arch-specific\n+  static void    init_AOTAddressTable();\n+#endif \/\/ INCLUDE_CDS\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-        for (int mode = 0; mode < 2; mode++) {\n+        for (int mode = 0; mode < 4; mode++) {\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/aotCode\/AOTCodeFlags.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}