{"files":[{"patch":"@@ -1122,0 +1122,77 @@\n+oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n+    \/\/ This thread went through the OOM during evac protocol and it is safe to return\n+    \/\/ the forward pointer. It must not attempt to evacuate any more.\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  assert(ShenandoahThreadLocalData::is_evac_allowed(thread), \"must be enclosed in oom-evac scope\");\n+\n+  size_t size = p->size();\n+\n+  assert(!heap_region_containing(p)->is_humongous(), \"never evacuate humongous objects\");\n+\n+  bool alloc_from_gclab = true;\n+  HeapWord* copy = nullptr;\n+\n+#ifdef ASSERT\n+  if (ShenandoahOOMDuringEvacALot &&\n+      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n+    copy = nullptr;\n+  } else {\n+#endif\n+    if (UseTLAB) {\n+      copy = allocate_from_gclab(thread, size);\n+    }\n+    if (copy == nullptr) {\n+      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);\n+      copy = allocate_memory(req);\n+      alloc_from_gclab = false;\n+    }\n+#ifdef ASSERT\n+  }\n+#endif\n+\n+  if (copy == nullptr) {\n+    control_thread()->handle_alloc_failure_evac(size);\n+\n+    _oom_evac_handler.handle_out_of_memory_during_evacuation();\n+\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  \/\/ Copy the object:\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n+\n+  \/\/ Try to install the new forwarding pointer.\n+  oop copy_val = cast_to_oop(copy);\n+  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+\n+  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n+  if (result == copy_val) {\n+    \/\/ Successfully evacuated. Our copy is now the public one!\n+    shenandoah_assert_correct(nullptr, copy_val);\n+    return copy_val;\n+  }  else {\n+    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n+    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n+    \/\/ But if it happens to contain references to evacuated regions, those references would\n+    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n+    \/\/ it the next cycle.\n+    \/\/\n+    \/\/ For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next\n+    \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n+    \/\/ do this. For non-GCLAB allocations, we have no way to retract the allocation, and\n+    \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n+    \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n+    if (alloc_from_gclab) {\n+      ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n+    } else {\n+      fill_with_object(copy, size);\n+      shenandoah_assert_correct(nullptr, copy_val);\n+    }\n+    shenandoah_assert_correct(nullptr, result);\n+    return result;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":77,"deletions":0,"binary":false,"changes":77,"status":"modified"},{"patch":"@@ -642,1 +642,1 @@\n-  inline oop evacuate_object(oop src, Thread* thread);\n+  oop evacuate_object(oop src, Thread* thread);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -290,77 +290,0 @@\n-inline oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {\n-  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n-    \/\/ This thread went through the OOM during evac protocol and it is safe to return\n-    \/\/ the forward pointer. It must not attempt to evacuate any more.\n-    return ShenandoahBarrierSet::resolve_forwarded(p);\n-  }\n-\n-  assert(ShenandoahThreadLocalData::is_evac_allowed(thread), \"must be enclosed in oom-evac scope\");\n-\n-  size_t size = p->size();\n-\n-  assert(!heap_region_containing(p)->is_humongous(), \"never evacuate humongous objects\");\n-\n-  bool alloc_from_gclab = true;\n-  HeapWord* copy = nullptr;\n-\n-#ifdef ASSERT\n-  if (ShenandoahOOMDuringEvacALot &&\n-      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n-        copy = nullptr;\n-  } else {\n-#endif\n-    if (UseTLAB) {\n-      copy = allocate_from_gclab(thread, size);\n-    }\n-    if (copy == nullptr) {\n-      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);\n-      copy = allocate_memory(req);\n-      alloc_from_gclab = false;\n-    }\n-#ifdef ASSERT\n-  }\n-#endif\n-\n-  if (copy == nullptr) {\n-    control_thread()->handle_alloc_failure_evac(size);\n-\n-    _oom_evac_handler.handle_out_of_memory_during_evacuation();\n-\n-    return ShenandoahBarrierSet::resolve_forwarded(p);\n-  }\n-\n-  \/\/ Copy the object:\n-  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n-\n-  \/\/ Try to install the new forwarding pointer.\n-  oop copy_val = cast_to_oop(copy);\n-  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n-\n-  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n-  if (result == copy_val) {\n-    \/\/ Successfully evacuated. Our copy is now the public one!\n-    shenandoah_assert_correct(nullptr, copy_val);\n-    return copy_val;\n-  }  else {\n-    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n-    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n-    \/\/ But if it happens to contain references to evacuated regions, those references would\n-    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n-    \/\/ it the next cycle.\n-    \/\/\n-    \/\/ For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next\n-    \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n-    \/\/ do this. For non-GCLAB allocations, we have no way to retract the allocation, and\n-    \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n-    \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n-    if (alloc_from_gclab) {\n-      ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n-    } else {\n-      fill_with_object(copy, size);\n-      shenandoah_assert_correct(nullptr, copy_val);\n-    }\n-    shenandoah_assert_correct(nullptr, result);\n-    return result;\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.inline.hpp","additions":0,"deletions":77,"binary":false,"changes":77,"status":"modified"}]}