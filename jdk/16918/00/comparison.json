{"files":[{"patch":"@@ -626,1 +626,1 @@\n-  const GrowableArray<int>* mapping = os::Linux::numa_nindex_to_node();\n+  const GrowableArrayCHeap<int, mtInternal>* mapping = os::Linux::numa_nindex_to_node();\n","filename":"src\/hotspot\/os\/linux\/gc\/x\/xPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -630,1 +630,1 @@\n-  const GrowableArray<int>* mapping = os::Linux::numa_nindex_to_node();\n+  const GrowableArrayCHeap<int, mtInternal>* mapping = os::Linux::numa_nindex_to_node();\n","filename":"src\/hotspot\/os\/linux\/gc\/z\/zPhysicalMemoryBacking_linux.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3148,1 +3148,1 @@\n-        _nindex_to_node = new (mtInternal) GrowableArray<int>(0, mtInternal);\n+        _nindex_to_node = new GrowableArrayCHeap<int, mtInternal>(0);\n@@ -3151,1 +3151,1 @@\n-        _cpu_to_node = new (mtInternal) GrowableArray<int>(0, mtInternal);\n+        _cpu_to_node = new GrowableArrayCHeap<int, mtInternal>(0);\n@@ -3310,2 +3310,2 @@\n-GrowableArray<int>* os::Linux::_cpu_to_node;\n-GrowableArray<int>* os::Linux::_nindex_to_node;\n+GrowableArrayCHeap<int, mtInternal>* os::Linux::_cpu_to_node;\n+GrowableArrayCHeap<int, mtInternal>* os::Linux::_nindex_to_node;\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-  static GrowableArray<int>* _cpu_to_node;\n-  static GrowableArray<int>* _nindex_to_node;\n+  static GrowableArrayCHeap<int, mtInternal>* _cpu_to_node;\n+  static GrowableArrayCHeap<int, mtInternal>* _nindex_to_node;\n@@ -74,2 +74,2 @@\n-  static GrowableArray<int>* cpu_to_node()    { return _cpu_to_node; }\n-  static GrowableArray<int>* nindex_to_node()  { return _nindex_to_node; }\n+  static GrowableArrayCHeap<int, mtInternal>* cpu_to_node() { return _cpu_to_node; }\n+  static GrowableArrayCHeap<int, mtInternal>* nindex_to_node() { return _nindex_to_node; }\n@@ -387,1 +387,1 @@\n-  static const GrowableArray<int>* numa_nindex_to_node() {\n+  static const GrowableArrayCHeap<int, mtInternal>* numa_nindex_to_node() {\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-  _objs = new (mtClassShared) GrowableArray<SourceObjInfo*>(128 * K, mtClassShared);\n+  _objs = new GrowableArrayCHeap<SourceObjInfo*, mtClassShared>(128 * K);\n@@ -169,2 +169,2 @@\n-  _klasses = new (mtClassShared) GrowableArray<Klass*>(4 * K, mtClassShared);\n-  _symbols = new (mtClassShared) GrowableArray<Symbol*>(256 * K, mtClassShared);\n+  _klasses = new GrowableArrayCHeap<Klass*, mtClassShared>(4 * K);\n+  _symbols = new GrowableArrayCHeap<Symbol*, mtClassShared>(256 * K);\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-    GrowableArray<SourceObjInfo*>* _objs;     \/\/ Source objects to be archived\n+    GrowableArrayCHeap<SourceObjInfo*, mtClassShared>* _objs; \/\/ Source objects to be archived\n@@ -187,1 +187,1 @@\n-    GrowableArray<SourceObjInfo*>* objs() const { return _objs; }\n+    GrowableArrayCHeap<SourceObjInfo*, mtClassShared>* objs() const { return _objs; }\n@@ -213,2 +213,2 @@\n-  GrowableArray<Klass*>* _klasses;\n-  GrowableArray<Symbol*>* _symbols;\n+  GrowableArrayCHeap<Klass*, mtClassShared>* _klasses;\n+  GrowableArrayCHeap<Symbol*, mtClassShared>* _symbols;\n@@ -404,2 +404,2 @@\n-  GrowableArray<Klass*>*  klasses() const { return _klasses; }\n-  GrowableArray<Symbol*>* symbols() const { return _symbols; }\n+  GrowableArrayCHeap<Klass*, mtClassShared>*  klasses() const { return _klasses; }\n+  GrowableArrayCHeap<Symbol*, mtClassShared>* symbols() const { return _symbols; }\n","filename":"src\/hotspot\/share\/cds\/archiveBuilder.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -77,2 +77,2 @@\n-  _interfaces = new (mtClass) GrowableArray<int>(10, mtClass);\n-  _indy_items = new (mtClass) GrowableArray<const char*>(9, mtClass);\n+  _interfaces = new GrowableArrayCHeap<int, mtClass>(10);\n+  _indy_items = new GrowableArrayCHeap<const char*, mtClass>(9);\n","filename":"src\/hotspot\/share\/cds\/classListParser.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -110,1 +110,1 @@\n-  GrowableArray<const char*>* _indy_items;    \/\/ items related to invoke dynamic for archiving lambda proxy classes\n+  GrowableArrayCHeap<const char*, mtClass>* _indy_items; \/\/ items related to invoke dynamic for archiving lambda proxy classes\n@@ -113,1 +113,1 @@\n-  GrowableArray<int>* _interfaces;\n+  GrowableArrayCHeap<int, mtClass>* _interfaces;\n","filename":"src\/hotspot\/share\/cds\/classListParser.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    _verifier_constraints = new (mtClass) GrowableArray<DTVerifierConstraint>(4, mtClass);\n+    _verifier_constraints = new GrowableArrayCHeap<DTVerifierConstraint, mtClass>(4);\n@@ -57,1 +57,1 @@\n-    _verifier_constraint_flags = new (mtClass) GrowableArray<char>(4, mtClass);\n+    _verifier_constraint_flags = new GrowableArrayCHeap<char, mtClass>(4);\n@@ -59,1 +59,1 @@\n-  GrowableArray<DTVerifierConstraint>* vc_array = _verifier_constraints;\n+  GrowableArrayCHeap<DTVerifierConstraint, mtClass>* vc_array = _verifier_constraints;\n@@ -68,1 +68,1 @@\n-  GrowableArray<char>* vcflags_array = _verifier_constraint_flags;\n+  GrowableArrayCHeap<char, mtClass>* vcflags_array = _verifier_constraint_flags;\n@@ -99,1 +99,1 @@\n-    _loader_constraints = new (mtClass) GrowableArray<DTLoaderConstraint>(4, mtClass);\n+    _loader_constraints = new GrowableArrayCHeap<DTLoaderConstraint, mtClass>(4);\n@@ -131,1 +131,1 @@\n-    _enum_klass_static_fields = new (mtClass) GrowableArray<int>(20, mtClass);\n+    _enum_klass_static_fields = new GrowableArrayCHeap<int, mtClass>(20);\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -129,4 +129,4 @@\n-  GrowableArray<DTVerifierConstraint>* _verifier_constraints;\n-  GrowableArray<char>*                 _verifier_constraint_flags;\n-  GrowableArray<DTLoaderConstraint>*   _loader_constraints;\n-  GrowableArray<int>*                  _enum_klass_static_fields;\n+  GrowableArrayCHeap<DTVerifierConstraint, mtClass>* _verifier_constraints;\n+  GrowableArrayCHeap<char, mtClass>*                 _verifier_constraint_flags;\n+  GrowableArrayCHeap<DTLoaderConstraint, mtClass>*   _loader_constraints;\n+  GrowableArrayCHeap<int, mtClass>*                  _enum_klass_static_fields;\n@@ -162,1 +162,1 @@\n-  static int array_length_or_zero(GrowableArray<T>* array) {\n+  static int array_length_or_zero(GrowableArrayCHeap<T, mtClass>* array) {\n","filename":"src\/hotspot\/share\/cds\/dumpTimeClassInfo.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -402,1 +402,1 @@\n-GrowableArray<ObjArrayKlass*>* DynamicArchive::_array_klasses = nullptr;\n+GrowableArrayCHeap<ObjArrayKlass*, mtClassShared>* DynamicArchive::_array_klasses = nullptr;\n@@ -407,1 +407,1 @@\n-    _array_klasses = new (mtClassShared) GrowableArray<ObjArrayKlass*>(50, mtClassShared);\n+    _array_klasses = new GrowableArrayCHeap<ObjArrayKlass*, mtClassShared>(50);\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-  static GrowableArray<ObjArrayKlass*>* _array_klasses;\n+  static GrowableArrayCHeap<ObjArrayKlass*, mtClassShared>* _array_klasses;\n","filename":"src\/hotspot\/share\/cds\/dynamicArchive.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-    _non_existent_class_paths = new (mtClass) GrowableArray<const char*>(10, mtClass);\n+    _non_existent_class_paths = new GrowableArrayCHeap<const char*, mtClass>(10);\n@@ -2249,1 +2249,1 @@\n-GrowableArray<const char*>* FileMapInfo::_non_existent_class_paths = nullptr;\n+GrowableArrayCHeap<const char*, mtClass>* FileMapInfo::_non_existent_class_paths = nullptr;\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -52,0 +52,3 @@\n+template<class E> class GrowableArray;\n+template<class E, MEMFLAGS F> class GrowableArrayCHeap;\n+\n@@ -345,1 +348,1 @@\n-  static GrowableArray<const char*>* _non_existent_class_paths;\n+  static GrowableArrayCHeap<const char*, mtClass>* _non_existent_class_paths;\n","filename":"src\/hotspot\/share\/cds\/filemap.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-  GrowableArray<Klass*>* klasses = ArchiveBuilder::current()->klasses();\n+  GrowableArrayCHeap<Klass*, mtClassShared>* klasses = ArchiveBuilder::current()->klasses();\n@@ -624,2 +624,1 @@\n-    _subgraph_entry_fields =\n-      new (mtClass) GrowableArray<int>(10, mtClass);\n+    _subgraph_entry_fields = new GrowableArrayCHeap<int, mtClass>(10);\n@@ -638,2 +637,1 @@\n-    _subgraph_object_klasses =\n-      new (mtClass) GrowableArray<Klass*>(50, mtClass);\n+    _subgraph_object_klasses = new GrowableArrayCHeap<Klass*, mtClass>(50);\n@@ -754,1 +752,1 @@\n-  GrowableArray<int>* entry_fields = info->subgraph_entry_fields();\n+  GrowableArrayCHeap<int, mtClass>* entry_fields = info->subgraph_entry_fields();\n@@ -766,1 +764,1 @@\n-  GrowableArray<Klass*>* subgraph_object_klasses = info->subgraph_object_klasses();\n+  GrowableArrayCHeap<Klass*, mtClass>* subgraph_object_klasses = info->subgraph_object_klasses();\n@@ -1344,1 +1342,1 @@\n-  GrowableArray<Klass*>* klasses = _default_subgraph_info->subgraph_object_klasses();\n+  GrowableArrayCHeap<Klass*, mtClass>* klasses = _default_subgraph_info->subgraph_object_klasses();\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-  GrowableArray<Klass*>* _subgraph_object_klasses;\n+  GrowableArrayCHeap<Klass*, mtClass>* _subgraph_object_klasses;\n@@ -69,1 +69,1 @@\n-  GrowableArray<int>* _subgraph_entry_fields;\n+  GrowableArrayCHeap<int, mtClass>* _subgraph_entry_fields;\n@@ -97,1 +97,1 @@\n-  GrowableArray<Klass*>* subgraph_object_klasses() {\n+  GrowableArrayCHeap<Klass*, mtClass>* subgraph_object_klasses() {\n@@ -100,1 +100,1 @@\n-  GrowableArray<int>* subgraph_entry_fields() {\n+  GrowableArrayCHeap<int, mtClass>* subgraph_entry_fields() {\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  GrowableArray<InstanceKlass*>* _proxy_klasses;\n+  GrowableArrayCHeap<InstanceKlass*, mtClassShared>* _proxy_klasses;\n@@ -122,1 +122,1 @@\n-      _proxy_klasses = new (mtClassShared) GrowableArray<InstanceKlass*>(5, mtClassShared);\n+      _proxy_klasses = new GrowableArrayCHeap<InstanceKlass*, mtClassShared>(5);\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -440,2 +440,2 @@\n-  void dump_java_heap_objects(GrowableArray<Klass*>* klasses) NOT_CDS_JAVA_HEAP_RETURN;\n-  void dump_shared_symbol_table(GrowableArray<Symbol*>* symbols) {\n+  void dump_java_heap_objects(GrowableArrayCHeap<Klass*, mtClassShared>* klasses) NOT_CDS_JAVA_HEAP_RETURN;\n+  void dump_shared_symbol_table(GrowableArrayView<Symbol*>* symbols) {\n@@ -840,1 +840,1 @@\n-void VM_PopulateDumpSharedSpace::dump_java_heap_objects(GrowableArray<Klass*>* klasses) {\n+void VM_PopulateDumpSharedSpace::dump_java_heap_objects(GrowableArrayCHeap<Klass*, mtClassShared>* klasses) {\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -38,2 +38,0 @@\n-template<class E> class GrowableArray;\n-\n","filename":"src\/hotspot\/share\/cds\/metaspaceShared.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,2 +123,2 @@\n-GrowableArray<ModuleClassPathList*>* ClassLoader::_patch_mod_entries = nullptr;\n-GrowableArray<ModuleClassPathList*>* ClassLoader::_exploded_entries = nullptr;\n+GrowableArrayCHeap<ModuleClassPathList*, mtModule>* ClassLoader::_patch_mod_entries = nullptr;\n+GrowableArrayCHeap<ModuleClassPathList*, mtModule>* ClassLoader::_exploded_entries = nullptr;\n@@ -564,1 +564,1 @@\n-  GrowableArray<ModulePatchPath*>* patch_mod_args = Arguments::get_patch_mod_prefix();\n+  GrowableArrayCHeap<ModulePatchPath*, mtArguments>* patch_mod_args = Arguments::get_patch_mod_prefix();\n@@ -568,1 +568,1 @@\n-  _patch_mod_entries = new (mtModule) GrowableArray<ModuleClassPathList*>(num_of_entries, mtModule);\n+  _patch_mod_entries = new GrowableArrayCHeap<ModuleClassPathList*, mtModule>(num_of_entries);\n@@ -857,1 +857,1 @@\n-static void print_module_entry_table(const GrowableArray<ModuleClassPathList*>* const module_list) {\n+static void print_module_entry_table(const GrowableArrayCHeap<ModuleClassPathList*, mtModule>* const module_list) {\n@@ -1013,1 +1013,1 @@\n-                                      const GrowableArray<ModuleClassPathList*>* const module_list) {\n+                                      const GrowableArrayCHeap<ModuleClassPathList*, mtModule>* const module_list) {\n@@ -1033,1 +1033,1 @@\n-                                                    const GrowableArray<ModuleClassPathList*>* const module_list,\n+                                                    const GrowableArrayCHeap<ModuleClassPathList*, mtModule>* const module_list,\n@@ -1499,2 +1499,1 @@\n-    _exploded_entries = new (mtModule)\n-      GrowableArray<ModuleClassPathList*>(EXPLODED_ENTRY_SIZE, mtModule);\n+    _exploded_entries = new GrowableArrayCHeap<ModuleClassPathList*, mtModule>(EXPLODED_ENTRY_SIZE);\n","filename":"src\/hotspot\/share\/classfile\/classLoader.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+template <typename T, MEMFLAGS F> class GrowableArrayCHeap;\n@@ -184,1 +185,1 @@\n-  static GrowableArray<ModuleClassPathList*>* _patch_mod_entries;\n+  static GrowableArrayCHeap<ModuleClassPathList*, mtModule>* _patch_mod_entries;\n@@ -191,1 +192,1 @@\n-  static GrowableArray<ModuleClassPathList*>* _exploded_entries;\n+  static GrowableArrayCHeap<ModuleClassPathList*, mtModule>* _exploded_entries;\n@@ -297,1 +298,1 @@\n-                                                const GrowableArray<ModuleClassPathList*>* const module_list,\n+                                                const GrowableArrayCHeap<ModuleClassPathList*, mtModule>* const module_list,\n","filename":"src\/hotspot\/share\/classfile\/classLoader.hpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -865,1 +865,1 @@\n-      _deallocate_list = new (mtClass) GrowableArray<Metadata*>(100, mtClass);\n+      _deallocate_list = new GrowableArrayCHeap<Metadata*, mtClass>(100);\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -153,1 +153,1 @@\n-  GrowableArray<Metadata*>*      _deallocate_list;\n+  GrowableArrayCHeap<Metadata*, mtClass>* _deallocate_list;\n","filename":"src\/hotspot\/share\/classfile\/classLoaderData.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-  _buckets = NEW_C_HEAP_ARRAY(GrowableArray<Entry>*, _num_buckets, mtSymbol);\n+  _buckets = NEW_C_HEAP_ARRAY(EntryBucket*, _num_buckets, mtSymbol);\n@@ -56,1 +56,1 @@\n-    _buckets[i] = new (mtSymbol) GrowableArray<Entry>(0, mtSymbol);\n+    _buckets[i] = new EntryBucket(0);\n@@ -69,1 +69,1 @@\n-    GrowableArray<Entry>* bucket = _buckets[index];\n+    EntryBucket* bucket = _buckets[index];\n@@ -73,1 +73,1 @@\n-  FREE_C_HEAP_ARRAY(GrowableArray<Entry>*, _buckets);\n+  FREE_C_HEAP_ARRAY(EntryBucket*, _buckets);\n@@ -99,1 +99,1 @@\n-    GrowableArray<Entry>* bucket = _buckets[index];\n+    EntryBucket* bucket = _buckets[index];\n@@ -128,1 +128,1 @@\n-    GrowableArray<Entry>* bucket = _buckets[index];\n+    EntryBucket* bucket = _buckets[index];\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -114,1 +114,2 @@\n-  GrowableArray<Entry>** _buckets;\n+  typedef GrowableArrayCHeap<Entry, mtSymbol> EntryBucket;\n+  EntryBucket** _buckets;\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -412,1 +412,1 @@\n-void Dictionary::clean_cached_protection_domains(GrowableArray<ProtectionDomainEntry*>* delete_list) {\n+void Dictionary::clean_cached_protection_domains(GrowableArrayCHeap<ProtectionDomainEntry*, mtClass>* delete_list) {\n","filename":"src\/hotspot\/share\/classfile\/dictionary.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  void clean_cached_protection_domains(GrowableArray<ProtectionDomainEntry*>* delete_list);\n+  void clean_cached_protection_domains(GrowableArrayCHeap<ProtectionDomainEntry*, mtClass>* delete_list);\n","filename":"src\/hotspot\/share\/classfile\/dictionary.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -798,2 +798,2 @@\n-GrowableArray<Klass*>* java_lang_Class::_fixup_mirror_list = nullptr;\n-GrowableArray<Klass*>* java_lang_Class::_fixup_module_field_list = nullptr;\n+GrowableArrayCHeap<Klass*, mtClass>* java_lang_Class::_fixup_mirror_list = nullptr;\n+GrowableArrayCHeap<Klass*, mtModule>* java_lang_Class::_fixup_module_field_list = nullptr;\n@@ -965,7 +965,2 @@\n-  GrowableArray<Klass*>* mirror_list =\n-    new (mtClass) GrowableArray<Klass*>(40, mtClass);\n-  set_fixup_mirror_list(mirror_list);\n-\n-  GrowableArray<Klass*>* module_list =\n-    new (mtModule) GrowableArray<Klass*>(500, mtModule);\n-  set_fixup_module_field_list(module_list);\n+  set_fixup_mirror_list(new GrowableArrayCHeap<Klass*, mtClass>(40));\n+  set_fixup_module_field_list(new GrowableArrayCHeap<Klass*, mtModule>(500));\n@@ -1781,2 +1776,2 @@\n-    GrowableArray<Method*>* _methods;\n-    GrowableArray<int>*     _bcis;\n+    GrowableArrayCHeap<Method*, mtInternal>* _methods;\n+    GrowableArrayCHeap<int, mtInternal>*     _bcis;\n@@ -1829,2 +1824,2 @@\n-      _methods = new (mtInternal) GrowableArray<Method*>(init_length, mtInternal);\n-      _bcis = new (mtInternal) GrowableArray<int>(init_length, mtInternal);\n+      _methods = new GrowableArrayCHeap<Method*, mtInternal>(init_length);\n+      _bcis = new GrowableArrayCHeap<int, mtInternal>(init_length);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -240,2 +240,2 @@\n-  static GrowableArray<Klass*>* _fixup_mirror_list;\n-  static GrowableArray<Klass*>* _fixup_module_field_list;\n+  static GrowableArrayCHeap<Klass*, mtClass>* _fixup_mirror_list;\n+  static GrowableArrayCHeap<Klass*, mtModule>* _fixup_module_field_list;\n@@ -317,1 +317,1 @@\n-  static GrowableArray<Klass*>* fixup_mirror_list() {\n+  static GrowableArrayCHeap<Klass*, mtClass>* fixup_mirror_list() {\n@@ -320,1 +320,1 @@\n-  static void set_fixup_mirror_list(GrowableArray<Klass*>* v) {\n+  static void set_fixup_mirror_list(GrowableArrayCHeap<Klass*, mtClass>* v) {\n@@ -324,1 +324,1 @@\n-  static GrowableArray<Klass*>* fixup_module_field_list() {\n+  static GrowableArrayCHeap<Klass*, mtModule>* fixup_module_field_list() {\n@@ -327,1 +327,1 @@\n-  static void set_fixup_module_field_list(GrowableArray<Klass*>* v) {\n+  static void set_fixup_module_field_list(GrowableArrayCHeap<Klass*, mtModule>* v) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -87,1 +87,1 @@\n-  GrowableArray<ClassLoaderData*>*  _loaders;                \/\/ initiating loaders\n+  GrowableArrayCHeap<ClassLoaderData*, mtClass>* _loaders; \/\/ initiating loaders\n@@ -91,1 +91,1 @@\n-    _loaders = new (mtClass) GrowableArray<ClassLoaderData*>(10, mtClass);\n+    _loaders = new GrowableArrayCHeap<ClassLoaderData*, mtClass>(10);\n@@ -118,1 +118,1 @@\n-  GrowableArray<LoaderConstraint*>*  _constraints;   \/\/ loader constraints for this class name.\n+  GrowableArrayCHeap<LoaderConstraint*, mtClass>* _constraints; \/\/ loader constraints for this class name.\n@@ -126,1 +126,1 @@\n-    _constraints = new (mtClass) GrowableArray<LoaderConstraint*>(5, mtClass);\n+    _constraints = new GrowableArrayCHeap<LoaderConstraint*, mtClass>(5);\n","filename":"src\/hotspot\/share\/classfile\/loaderConstraints.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-      _reads = new (mtModule) GrowableArray<ModuleEntry*>(MODULE_READS_SIZE, mtModule);\n+      _reads = new GrowableArrayCHeap<ModuleEntry*, mtModule>(MODULE_READS_SIZE);\n@@ -433,1 +433,1 @@\n-Array<ModuleEntry*>* ModuleEntry::write_growable_array(GrowableArray<ModuleEntry*>* array) {\n+Array<ModuleEntry*>* ModuleEntry::write_growable_array(GrowableArrayCHeap<ModuleEntry*, mtModule>* array) {\n@@ -448,2 +448,2 @@\n-GrowableArray<ModuleEntry*>* ModuleEntry::restore_growable_array(Array<ModuleEntry*>* archived_array) {\n-  GrowableArray<ModuleEntry*>* array = nullptr;\n+GrowableArrayCHeap<ModuleEntry*, mtModule>* ModuleEntry::restore_growable_array(Array<ModuleEntry*>* archived_array) {\n+  GrowableArrayCHeap<ModuleEntry*, mtModule>* array = nullptr;\n@@ -452,1 +452,1 @@\n-    array = new (mtModule) GrowableArray<ModuleEntry*>(length, mtModule);\n+    array = new GrowableArrayCHeap<ModuleEntry*, mtModule>(length);\n@@ -477,1 +477,2 @@\n-  _reads = (GrowableArray<ModuleEntry*>*)archived_reads;\n+  \/\/ TODO investigate, this looks like a terrible hack!\n+  _reads = (GrowableArrayCHeap<ModuleEntry*, mtModule>*)archived_reads;\n@@ -690,1 +691,1 @@\n-  GrowableArray <Klass*>* list = java_lang_Class::fixup_module_field_list();\n+  GrowableArrayCHeap <Klass*, mtModule>* list = java_lang_Class::fixup_module_field_list();\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-  GrowableArray<ModuleEntry*>* _reads; \/\/ list of modules that are readable by this module\n+  GrowableArrayCHeap<ModuleEntry*, mtModule>* _reads; \/\/ list of modules that are readable by this module\n@@ -180,2 +180,2 @@\n-  static Array<ModuleEntry*>* write_growable_array(GrowableArray<ModuleEntry*>* array);\n-  static GrowableArray<ModuleEntry*>* restore_growable_array(Array<ModuleEntry*>* archived_array);\n+  static Array<ModuleEntry*>* write_growable_array(GrowableArrayCHeap<ModuleEntry*, mtModule>* array);\n+  static GrowableArrayCHeap<ModuleEntry*, mtModule>* restore_growable_array(Array<ModuleEntry*>* archived_array);\n","filename":"src\/hotspot\/share\/classfile\/moduleEntry.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-    _qualified_exports = new (mtModule) GrowableArray<ModuleEntry*>(QUAL_EXP_SIZE, mtModule);\n+    _qualified_exports = new GrowableArrayCHeap<ModuleEntry*, mtModule>(QUAL_EXP_SIZE);\n@@ -253,1 +253,2 @@\n-  _qualified_exports = (GrowableArray<ModuleEntry*>*)archived_qualified_exports;\n+  \/\/ TODO this looks like a terrible hack\n+  _qualified_exports = (GrowableArrayCHeap<ModuleEntry*, mtModule>*)archived_qualified_exports;\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  GrowableArray<ModuleEntry*>* _qualified_exports;\n+  GrowableArrayCHeap<ModuleEntry*, mtModule>* _qualified_exports;\n","filename":"src\/hotspot\/share\/classfile\/packageEntry.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  GrowableArray<ProtectionDomainEntry*>* _delete_list;\n+  GrowableArrayCHeap<ProtectionDomainEntry*, mtClass>* _delete_list;\n@@ -74,1 +74,1 @@\n-  CleanProtectionDomainEntries(GrowableArray<ProtectionDomainEntry*>* delete_list) :\n+  CleanProtectionDomainEntries(GrowableArrayCHeap<ProtectionDomainEntry*, mtClass>* delete_list) :\n@@ -85,1 +85,1 @@\n-static GrowableArray<ProtectionDomainEntry*>* _delete_list = nullptr;\n+static GrowableArrayCHeap<ProtectionDomainEntry*, mtClass>* _delete_list = nullptr;\n@@ -123,2 +123,1 @@\n-    _delete_list = new (mtClass)\n-                       GrowableArray<ProtectionDomainEntry*>(20, mtClass);\n+    _delete_list = new GrowableArrayCHeap<ProtectionDomainEntry*, mtClass>(20);\n","filename":"src\/hotspot\/share\/classfile\/protectionDomainCache.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -652,1 +652,1 @@\n-void SymbolTable::copy_shared_symbol_table(GrowableArray<Symbol*>* symbols,\n+void SymbolTable::copy_shared_symbol_table(const GrowableArrayView<Symbol*>* symbols,\n@@ -673,1 +673,1 @@\n-void SymbolTable::write_to_archive(GrowableArray<Symbol*>* symbols) {\n+void SymbolTable::write_to_archive(const GrowableArrayView<Symbol*>* symbols) {\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-template <typename T> class GrowableArray;\n+template <typename T> class GrowableArrayView;\n@@ -166,1 +166,1 @@\n-  static void copy_shared_symbol_table(GrowableArray<Symbol*>* symbols,\n+  static void copy_shared_symbol_table(const GrowableArrayView<Symbol*>* symbols,\n@@ -170,1 +170,1 @@\n-  static void write_to_archive(GrowableArray<Symbol*>* symbols) NOT_CDS_RETURN;\n+  static void write_to_archive(const GrowableArrayView<Symbol*>* symbols) NOT_CDS_RETURN;\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -176,4 +176,4 @@\n-GrowableArray<CodeHeap*>* CodeCache::_heaps = new(mtCode) GrowableArray<CodeHeap*> (static_cast<int>(CodeBlobType::All), mtCode);\n-GrowableArray<CodeHeap*>* CodeCache::_compiled_heaps = new(mtCode) GrowableArray<CodeHeap*> (static_cast<int>(CodeBlobType::All), mtCode);\n-GrowableArray<CodeHeap*>* CodeCache::_nmethod_heaps = new(mtCode) GrowableArray<CodeHeap*> (static_cast<int>(CodeBlobType::All), mtCode);\n-GrowableArray<CodeHeap*>* CodeCache::_allocable_heaps = new(mtCode) GrowableArray<CodeHeap*> (static_cast<int>(CodeBlobType::All), mtCode);\n+CodeCache::CodeHeapArray* CodeCache::_heaps           = new CodeHeapArray(static_cast<int>(CodeBlobType::All));\n+CodeCache::CodeHeapArray* CodeCache::_compiled_heaps  = new CodeHeapArray(static_cast<int>(CodeBlobType::All));\n+CodeCache::CodeHeapArray* CodeCache::_nmethod_heaps   = new CodeHeapArray(static_cast<int>(CodeBlobType::All));\n+CodeCache::CodeHeapArray* CodeCache::_allocable_heaps = new CodeHeapArray(static_cast<int>(CodeBlobType::All));\n@@ -1304,1 +1304,1 @@\n-static GrowableArray<CompiledMethod*>* old_compiled_method_table = nullptr;\n+static GrowableArrayCHeap<CompiledMethod*, mtCode>* old_compiled_method_table = nullptr;\n@@ -1308,1 +1308,1 @@\n-    old_compiled_method_table = new (mtCode) GrowableArray<CompiledMethod*>(100, mtCode);\n+    old_compiled_method_table = new GrowableArrayCHeap<CompiledMethod*, mtCode>(100);\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -92,4 +92,5 @@\n-  static GrowableArray<CodeHeap*>* _heaps;\n-  static GrowableArray<CodeHeap*>* _compiled_heaps;\n-  static GrowableArray<CodeHeap*>* _nmethod_heaps;\n-  static GrowableArray<CodeHeap*>* _allocable_heaps;\n+  typedef GrowableArrayCHeap<CodeHeap*, mtCode> CodeHeapArray;\n+  static CodeHeapArray* _heaps;\n+  static CodeHeapArray* _compiled_heaps;\n+  static CodeHeapArray* _nmethod_heaps;\n+  static CodeHeapArray* _allocable_heaps;\n@@ -146,3 +147,3 @@\n-  static const GrowableArray<CodeHeap*>* heaps() { return _heaps; }\n-  static const GrowableArray<CodeHeap*>* compiled_heaps() { return _compiled_heaps; }\n-  static const GrowableArray<CodeHeap*>* nmethod_heaps() { return _nmethod_heaps; }\n+  static const GrowableArrayCHeap<CodeHeap*, mtCode>* heaps() { return _heaps; }\n+  static const GrowableArrayCHeap<CodeHeap*, mtCode>* compiled_heaps() { return _compiled_heaps; }\n+  static const GrowableArrayCHeap<CodeHeap*, mtCode>* nmethod_heaps() { return _nmethod_heaps; }\n@@ -445,1 +446,1 @@\n-  static const GrowableArray<CodeHeap*>* heaps() { return CodeCache::compiled_heaps(); }\n+  static const GrowableArrayCHeap<CodeHeap*, mtCode>* heaps() { return CodeCache::compiled_heaps(); }\n@@ -451,1 +452,1 @@\n-  static const GrowableArray<CodeHeap*>* heaps() { return CodeCache::nmethod_heaps(); }\n+  static const GrowableArrayCHeap<CodeHeap*, mtCode>* heaps() { return CodeCache::nmethod_heaps(); }\n@@ -456,1 +457,1 @@\n-  static const GrowableArray<CodeHeap*>* heaps() { return CodeCache::heaps(); }\n+  static const GrowableArrayCHeap<CodeHeap*, mtCode>* heaps() { return CodeCache::heaps(); }\n","filename":"src\/hotspot\/share\/code\/codeCache.hpp","additions":11,"deletions":10,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-static GrowableArray<const char*>* phase_names = nullptr;\n+static GrowableArrayCHeap<const char*, mtCompiler>* phase_names = nullptr;\n@@ -93,1 +93,2 @@\n-      phase_names = new (mtInternal) GrowableArray<const char*>(100, mtCompiler);\n+      \/\/ TODO mtInternal or mtCompiler?\n+      phase_names = new GrowableArrayCHeap<const char*, mtCompiler>(100);\n","filename":"src\/hotspot\/share\/compiler\/compilerEvent.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -199,1 +199,1 @@\n-  static GrowableArray<const char*>* _cached_src_lines;\n+  static GrowableArrayCHeap<const char*, mtCode>* _cached_src_lines;\n@@ -233,1 +233,1 @@\n-GrowableArray<const char*>* decode_env::_cached_src_lines = nullptr;\n+GrowableArrayCHeap<const char*, mtCode>* decode_env::_cached_src_lines = nullptr;\n@@ -268,1 +268,1 @@\n-          _cached_src_lines = new (mtCode) GrowableArray<const char*>(0, mtCode);\n+          _cached_src_lines = new GrowableArrayCHeap<const char*, mtCode>(0);\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-G1CollectionCandidateList::G1CollectionCandidateList() : _candidates(2, mtGC) { }\n+G1CollectionCandidateList::G1CollectionCandidateList() : _candidates(2) { }\n@@ -61,1 +61,1 @@\n-  GrowableArray<G1CollectionSetCandidateInfo> new_list(new_length, mtGC);\n+  GrowableArrayCHeap<G1CollectionSetCandidateInfo, mtGC> new_list(new_length);\n@@ -121,1 +121,1 @@\n-G1CollectionCandidateRegionList::G1CollectionCandidateRegionList() : _regions(2, mtGC) { }\n+G1CollectionCandidateRegionList::G1CollectionCandidateRegionList() : _regions(2) { }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-  GrowableArray<HeapRegion*> _regions;\n+  GrowableArrayCHeap<HeapRegion*, mtGC> _regions;\n@@ -102,1 +102,1 @@\n-  GrowableArray<G1CollectionSetCandidateInfo> _candidates;\n+  GrowableArrayCHeap<G1CollectionSetCandidateInfo, mtGC> _candidates;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSetCandidates.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  GrowableArray<HeapRegion*>* compaction_queue = collector()->compaction_point(worker_id)->regions();\n+  GrowableArrayCHeap<HeapRegion*, mtGC>* compaction_queue = collector()->compaction_point(worker_id)->regions();\n@@ -100,1 +100,1 @@\n-  GrowableArray<HeapRegion*>* compaction_queue = collector()->serial_compaction_point()->regions();\n+  GrowableArrayCHeap<HeapRegion*, mtGC>* compaction_queue = collector()->serial_compaction_point()->regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactTask.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  _compaction_regions = new (mtGC) GrowableArray<HeapRegion*>(32, mtGC);\n+  _compaction_regions = new GrowableArrayCHeap<HeapRegion*, mtGC>(32);\n@@ -78,1 +78,1 @@\n-GrowableArray<HeapRegion*>* G1FullGCCompactionPoint::regions() {\n+GrowableArrayCHeap<HeapRegion*, mtGC>* G1FullGCCompactionPoint::regions() {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  GrowableArray<HeapRegion*>* _compaction_regions;\n+  GrowableArrayCHeap<HeapRegion*, mtGC>* _compaction_regions;\n@@ -65,1 +65,1 @@\n-  GrowableArray<HeapRegion*>* regions();\n+  GrowableArrayCHeap<HeapRegion*, mtGC>* regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullGCCompactionPoint.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -510,1 +510,1 @@\n-  const GrowableArray<HeapRegion*>* survivor_regions = _g1h->survivor()->regions();\n+  const GrowableArrayCHeap<HeapRegion*, mtGC>* survivor_regions = _g1h->survivor()->regions();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-  _regions(new (mtGC) GrowableArray<HeapRegion*>(8, mtGC)),\n+  _regions(new GrowableArrayCHeap<HeapRegion*, mtGC>(8)),\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,2 +31,1 @@\n-template <typename T>\n-class GrowableArray;\n+template <typename T, MEMFLAGS F> class GrowableArrayCHeap;\n@@ -37,3 +36,3 @@\n-  GrowableArray<HeapRegion*>* _regions;\n-  volatile size_t             _used_bytes;\n-  G1RegionsOnNodes            _regions_on_node;\n+  GrowableArrayCHeap<HeapRegion*, mtGC>* _regions;\n+  volatile size_t                        _used_bytes;\n+  G1RegionsOnNodes                       _regions_on_node;\n@@ -53,1 +52,1 @@\n-  const GrowableArray<HeapRegion*>* regions() const {\n+  const GrowableArrayCHeap<HeapRegion*, mtGC>* regions() const {\n","filename":"src\/hotspot\/share\/gc\/g1\/g1SurvivorRegions.hpp","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-  _lgrp_spaces = new (mtGC) GrowableArray<LGRPSpace*>(0, mtGC);\n+  _lgrp_spaces = new GrowableArrayCHeap<LGRPSpace*, mtGC>(0);\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  GrowableArray<LGRPSpace*>* _lgrp_spaces;\n+  GrowableArrayCHeap<LGRPSpace*, mtGC>* _lgrp_spaces;\n@@ -160,1 +160,1 @@\n-  GrowableArray<LGRPSpace*>* lgrp_spaces() const     { return _lgrp_spaces;       }\n+  GrowableArrayCHeap<LGRPSpace*, mtGC>* lgrp_spaces() const { return _lgrp_spaces; }\n","filename":"src\/hotspot\/share\/gc\/parallel\/mutableNUMASpace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-GrowableArray<size_t >* ParCompactionManager::_shadow_region_array = nullptr;\n+GrowableArrayCHeap<size_t, mtGC>* ParCompactionManager::_shadow_region_array = nullptr;\n@@ -63,1 +63,1 @@\n-  _deferred_obj_array = new (mtGC) GrowableArray<HeapWord*>(10, mtGC);\n+  _deferred_obj_array = new GrowableArrayCHeap<HeapWord*, mtGC>(10);\n@@ -92,1 +92,1 @@\n-  _shadow_region_array = new (mtGC) GrowableArray<size_t >(10, mtGC);\n+  _shadow_region_array = new GrowableArrayCHeap<size_t, mtGC>(10);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -78,1 +78,1 @@\n-  GrowableArray<HeapWord*>*    _deferred_obj_array;\n+  GrowableArrayCHeap<HeapWord*, mtGC>* _deferred_obj_array;\n@@ -84,1 +84,1 @@\n-  static GrowableArray<size_t>* _shadow_region_array;\n+  static GrowableArrayCHeap<size_t, mtGC>* _shadow_region_array;\n","filename":"src\/hotspot\/share\/gc\/parallel\/psCompactionManager.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -117,1 +117,1 @@\n-  _phases = new (mtGC) GrowableArray<GCPhase>(INITIAL_CAPACITY, mtGC);\n+  _phases = new GrowableArrayCHeap<GCPhase, mtGC>(INITIAL_CAPACITY);\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTimer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-template <class E> class GrowableArray;\n+template <class E, MEMFLAGS F> class GrowableArrayCHeap;\n@@ -102,1 +102,1 @@\n-  GrowableArray<GCPhase>* _phases;\n+  GrowableArrayCHeap<GCPhase, mtGC>* _phases;\n","filename":"src\/hotspot\/share\/gc\/shared\/gcTimer.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1291,2 +1291,2 @@\n-  _fingerprints = new (mtCode) GrowableArray<uint64_t>(32, mtCode);\n-  _handlers     = new (mtCode) GrowableArray<address>(32, mtCode);\n+  _fingerprints = new GrowableArrayCHeap<uint64_t, mtCode>(32);\n+  _handlers     = new GrowableArrayCHeap<address, mtCode>(32);\n@@ -1442,5 +1442,5 @@\n-BufferBlob*              SignatureHandlerLibrary::_handler_blob = nullptr;\n-address                  SignatureHandlerLibrary::_handler      = nullptr;\n-GrowableArray<uint64_t>* SignatureHandlerLibrary::_fingerprints = nullptr;\n-GrowableArray<address>*  SignatureHandlerLibrary::_handlers     = nullptr;\n-address                  SignatureHandlerLibrary::_buffer       = nullptr;\n+BufferBlob*                           SignatureHandlerLibrary::_handler_blob = nullptr;\n+address                               SignatureHandlerLibrary::_handler      = nullptr;\n+GrowableArrayCHeap<uint64_t, mtCode>* SignatureHandlerLibrary::_fingerprints = nullptr;\n+GrowableArrayCHeap<address, mtCode>*  SignatureHandlerLibrary::_handlers     = nullptr;\n+address                               SignatureHandlerLibrary::_buffer       = nullptr;\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -169,5 +169,5 @@\n-  static BufferBlob*              _handler_blob; \/\/ the current buffer blob containing the generated handlers\n-  static address                  _handler;      \/\/ next available address within _handler_blob;\n-  static GrowableArray<uint64_t>* _fingerprints; \/\/ the fingerprint collection\n-  static GrowableArray<address>*  _handlers;     \/\/ the corresponding handlers\n-  static address                  _buffer;       \/\/ the temporary code buffer\n+  static BufferBlob*                           _handler_blob; \/\/ the current buffer blob containing the generated handlers\n+  static address                               _handler;      \/\/ next available address within _handler_blob;\n+  static GrowableArrayCHeap<uint64_t, mtCode>* _fingerprints; \/\/ the fingerprint collection\n+  static GrowableArrayCHeap<address, mtCode>*  _handlers;     \/\/ the corresponding handlers\n+  static address                               _buffer;       \/\/ the temporary code buffer\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1666,1 +1666,1 @@\n-  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n+  const GrowableArrayCHeap<Klass*, mtClass>* const redef_klasses = state->get_classes_being_redefined();\n","filename":"src\/hotspot\/share\/jfr\/instrumentation\/jfrEventClassTransformer.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -220,1 +220,1 @@\n-static GrowableArray<const StoredEdge*>* _leak_context_edges = nullptr;\n+static GrowableArrayCHeap<const StoredEdge*, mtTracing>* _leak_context_edges = nullptr;\n@@ -287,1 +287,1 @@\n-    _leak_context_edges = new (mtTracing) GrowableArray<const StoredEdge*>(initial_size, mtTracing);\n+    _leak_context_edges = new GrowableArrayCHeap<const StoredEdge*, mtTracing>(initial_size);\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/chains\/edgeStore.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,2 +54,2 @@\n-static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {\n-  return new (mtTracing) GrowableArray<T>(size, mtTracing);\n+static GrowableArrayCHeap<T, mtTracing>* c_heap_allocate_array(int size = initial_array_size) {\n+  return new GrowableArrayCHeap<T, mtTracing>(size);\n@@ -58,1 +58,1 @@\n-static GrowableArray<traceid>* unloaded_thread_id_set = nullptr;\n+static GrowableArrayCHeap<traceid, mtTracing>* unloaded_thread_id_set = nullptr;\n","filename":"src\/hotspot\/share\/jfr\/leakprofiler\/checkpoint\/objectSampleCheckpoint.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-static GrowableArray<InterfaceEntry>* _interfaces = nullptr;\n+static GrowableArrayCHeap<InterfaceEntry, mtTracing>* _interfaces = nullptr;\n@@ -57,1 +57,1 @@\n-static InterfaceEntry& new_entry(const NetworkInterface* iface, GrowableArray<InterfaceEntry>* interfaces) {\n+static InterfaceEntry& new_entry(const NetworkInterface* iface, GrowableArrayCHeap<InterfaceEntry, mtTracing>* interfaces) {\n@@ -78,1 +78,1 @@\n-static GrowableArray<InterfaceEntry>* get_interfaces() {\n+static GrowableArrayCHeap<InterfaceEntry, mtTracing>* get_interfaces() {\n@@ -80,1 +80,1 @@\n-    _interfaces = new (mtTracing) GrowableArray<InterfaceEntry>(10, mtTracing);\n+    _interfaces = new GrowableArrayCHeap<InterfaceEntry, mtTracing>(10);\n@@ -90,1 +90,1 @@\n-  GrowableArray<InterfaceEntry>* interfaces = get_interfaces();\n+  GrowableArrayCHeap<InterfaceEntry, mtTracing>* interfaces = get_interfaces();\n","filename":"src\/hotspot\/share\/jfr\/periodic\/jfrNetworkUtilization.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -266,1 +266,1 @@\n-  _list(new (mtTracing) GrowableArray<JfrThreadGroupEntry*>(initial_array_size, mtTracing)) {}\n+  _list(new GrowableArrayCHeap<JfrThreadGroupEntry*, mtTracing>(initial_array_size)) {}\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadGroup.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-  GrowableArray<JfrThreadGroupEntry*>* _list;\n+  GrowableArrayCHeap<JfrThreadGroupEntry*, mtTracing>* _list;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadGroup.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -130,1 +130,1 @@\n-  const GrowableArray<Klass*>* const redef_klasses = state->get_classes_being_redefined();\n+  const GrowableArrayCHeap<Klass*, mtClass>* const redef_klasses = state->get_classes_being_redefined();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/traceid\/jfrTraceId.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-static GrowableArray<JfrStartFlightRecordingDCmd*>* dcmd_recordings_array = nullptr;\n+static GrowableArrayCHeap<JfrStartFlightRecordingDCmd*, mtTracing>* dcmd_recordings_array = nullptr;\n@@ -144,1 +144,1 @@\n-  const GrowableArray<const char*>* options = JfrOptionSet::start_flight_recording_options();\n+  const GrowableArrayCHeap<const char*, mtTracing>* options = JfrOptionSet::start_flight_recording_options();\n@@ -151,1 +151,1 @@\n-  dcmd_recordings_array = new (mtTracing) GrowableArray<JfrStartFlightRecordingDCmd*>(length, mtTracing);\n+  dcmd_recordings_array = new GrowableArrayCHeap<JfrStartFlightRecordingDCmd*, mtTracing>(length);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/jfrRecorder.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -253,1 +253,1 @@\n-  GrowableArray<const char*>* _file_names;\n+  GrowableArrayCHeap<const char*, mtTracing>* _file_names;\n@@ -331,1 +331,1 @@\n-    _file_names = new (mtTracing) GrowableArray<const char*>(10, mtTracing);\n+    _file_names = new GrowableArrayCHeap<const char*, mtTracing>(10);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/repository\/jfrEmergencyDump.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -761,1 +761,1 @@\n-static GrowableArray<const char*>* start_flight_recording_options_array = nullptr;\n+static GrowableArrayCHeap<const char*, mtTracing>* start_flight_recording_options_array = nullptr;\n@@ -785,1 +785,1 @@\n-    start_flight_recording_options_array = new (mtTracing) GrowableArray<const char*>(8, mtTracing);\n+    start_flight_recording_options_array = new GrowableArrayCHeap<const char*, mtTracing>(8);\n@@ -795,1 +795,1 @@\n-const GrowableArray<const char*>* JfrOptionSet::start_flight_recording_options() {\n+const GrowableArrayCHeap<const char*, mtTracing>* JfrOptionSet::start_flight_recording_options() {\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrOptionSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -32,2 +32,1 @@\n-template <typename>\n-class GrowableArray;\n+template <typename E, MEMFLAGS F> class GrowableArrayCHeap;\n@@ -80,1 +79,1 @@\n-  static const GrowableArray<const char*>* start_flight_recording_options();\n+  static const GrowableArrayCHeap<const char*, mtTracing>* start_flight_recording_options();\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrOptionSet.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -52,4 +52,5 @@\n-template <typename T>\n-static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {\n-  return new (mtTracing) GrowableArray<T>(size, mtTracing);\n-}\n+\/\/ TODO remove?\n+\/\/template <typename T>\n+\/\/static GrowableArrayCHeap<T, mtTracing>* c_heap_allocate_array(int size = initial_array_size) {\n+\/\/  return new GrowableArrayCHeap<T, mtTracing>(size);\n+\/\/}\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrJdkJfrEvent.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -38,2 +38,2 @@\n-static GrowableArray<T>* c_heap_allocate_array(int size = initial_array_size) {\n-  return new (mtTracing) GrowableArray<T>(size, mtTracing);\n+static GrowableArrayCHeap<T, mtTracing>* c_heap_allocate_array(int size = initial_array_size) {\n+  return new GrowableArrayCHeap<T, mtTracing>(size);\n@@ -43,2 +43,2 @@\n-static GrowableArray<traceid>* _unload_set_epoch_0 = nullptr;\n-static GrowableArray<traceid>* _unload_set_epoch_1 = nullptr;\n+static GrowableArrayCHeap<traceid, mtTracing>* _unload_set_epoch_0 = nullptr;\n+static GrowableArrayCHeap<traceid, mtTracing>* _unload_set_epoch_1 = nullptr;\n@@ -48,1 +48,1 @@\n-static GrowableArray<traceid>* unload_set_epoch_0() {\n+static GrowableArrayCHeap<traceid, mtTracing>* unload_set_epoch_0() {\n@@ -55,1 +55,1 @@\n-static GrowableArray<traceid>* unload_set_epoch_1() {\n+static GrowableArrayCHeap<traceid, mtTracing>* unload_set_epoch_1() {\n@@ -62,1 +62,1 @@\n-static GrowableArray<traceid>* get_unload_set(u1 epoch) {\n+static GrowableArrayCHeap<traceid, mtTracing>* get_unload_set(u1 epoch) {\n@@ -66,1 +66,1 @@\n-static GrowableArray<traceid>* get_unload_set() {\n+static GrowableArrayCHeap<traceid, mtTracing>* get_unload_set() {\n@@ -70,1 +70,1 @@\n-static GrowableArray<traceid>* get_unload_set_previous_epoch() {\n+static GrowableArrayCHeap<traceid, mtTracing>* get_unload_set_previous_epoch() {\n@@ -74,1 +74,1 @@\n-static void sort_set(GrowableArray<traceid>* set) {\n+static void sort_set(GrowableArrayCHeap<traceid, mtTracing>* set) {\n@@ -106,1 +106,1 @@\n-  GrowableArray<traceid>* const unload_set = current_epoch ? get_unload_set() : get_unload_set_previous_epoch();\n+  GrowableArrayCHeap<traceid, mtTracing>* const unload_set = current_epoch ? get_unload_set() : get_unload_set_previous_epoch();\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrKlassUnloading.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  static bool test(GrowableArray<T>* set, T value) {\n+  static bool test(GrowableArrayView<T>* set, T value) {\n@@ -51,0 +51,10 @@\n+  static bool test(GrowableArrayCHeap<T, mtTracing>* set, T value) {\n+    assert(set != nullptr, \"invariant\");\n+    bool found = false;\n+    const int location = set->template find_sorted<T, cmp>(value, found);\n+    if (!found) {\n+      set->insert_before(location, value);\n+    }\n+    return found;\n+  }\n+  \/\/ TODO can we unify this somehow? But we need insert_before, and how do I do the WithAllocator?\n","filename":"src\/hotspot\/share\/jfr\/utilities\/jfrPredicate.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -922,7 +922,0 @@\n-\/\/ Swaps the elements in `array` at index `a` and index `b`\n-static void swap(GrowableArray<oop*>* array, int a, int b) {\n-  oop* tmp = array->at(a);\n-  array->at_put(a, array->at(b));\n-  array->at_put(b, tmp);\n-}\n-\n@@ -952,1 +945,1 @@\n-          swap(&_oop_handles, next, i);\n+          _oop_handles.at_swap(next, i);\n@@ -970,1 +963,1 @@\n-          swap(&_oop_handles, next, i);\n+          _oop_handles.at_swap(next, i);\n@@ -1048,1 +1041,1 @@\n-  _oop_handles(100, mtJVMCI),\n+  _oop_handles(100),\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.cpp","additions":3,"deletions":10,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  GrowableArray<oop*> _oop_handles;\n+  GrowableArrayCHeap<oop*, mtJVMCI> _oop_handles;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciRuntime.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -360,0 +360,6 @@\n+\n+#ifdef ASSERT\n+bool Arena_contains(const Arena* arena, const void* ptr) {\n+  return arena->contains(ptr);\n+}\n+#endif \/\/ ASSERT\n","filename":"src\/hotspot\/share\/memory\/arena.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -208,0 +208,4 @@\n+#ifdef ASSERT\n+bool Arena_contains(const Arena* arena, const void* ptr);\n+#endif \/\/ ASSERT\n+\n","filename":"src\/hotspot\/share\/memory\/arena.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-    _subclasses = new (mtServiceability) GrowableArray<KlassInfoEntry*>(4, mtServiceability);\n+    _subclasses = new GrowableArrayCHeap<KlassInfoEntry*, mtServiceability>(4);\n@@ -282,1 +282,1 @@\n-  _elements = new (mtServiceability) GrowableArray<KlassInfoEntry*>(_histo_initial_size, mtServiceability);\n+  _elements = new GrowableArrayCHeap<KlassInfoEntry*, mtServiceability>(_histo_initial_size);\n@@ -617,1 +617,1 @@\n-  GrowableArray<oop>* _result;\n+  GrowableArrayCHeap<oop, mtServiceability>* _result;\n@@ -620,1 +620,2 @@\n-  FindInstanceClosure(Klass* k, GrowableArray<oop>* result) : _klass(k), _result(result) {};\n+  FindInstanceClosure(Klass* k, GrowableArrayCHeap<oop, mtServiceability>* result) :\n+    _klass(k), _result(result) {};\n@@ -633,1 +634,1 @@\n-void HeapInspection::find_instances_at_safepoint(Klass* k, GrowableArray<oop>* result) {\n+void HeapInspection::find_instances_at_safepoint(Klass* k, GrowableArrayCHeap<oop, mtServiceability>* result) {\n","filename":"src\/hotspot\/share\/memory\/heapInspection.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-  GrowableArray<KlassInfoEntry*>* _subclasses;\n+  GrowableArrayCHeap<KlassInfoEntry*, mtServiceability>* _subclasses;\n@@ -78,1 +78,1 @@\n-  GrowableArray<KlassInfoEntry*>* subclasses() const { return _subclasses; }\n+  GrowableArrayCHeap<KlassInfoEntry*, mtServiceability>* subclasses() const { return _subclasses; }\n@@ -150,2 +150,2 @@\n-  GrowableArray<KlassInfoEntry*>* _elements;\n-  GrowableArray<KlassInfoEntry*>* elements() const { return _elements; }\n+  GrowableArrayCHeap<KlassInfoEntry*, mtServiceability>* _elements;\n+  GrowableArrayCHeap<KlassInfoEntry*, mtServiceability>* elements() const { return _elements; }\n@@ -205,1 +205,1 @@\n-  static void find_instances_at_safepoint(Klass* k, GrowableArray<oop>* result) NOT_SERVICES_RETURN;\n+  static void find_instances_at_safepoint(Klass* k, GrowableArrayCHeap<oop, mtServiceability>* result) NOT_SERVICES_RETURN;\n","filename":"src\/hotspot\/share\/memory\/heapInspection.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n","filename":"src\/hotspot\/share\/memory\/resourceArea.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -506,1 +506,1 @@\n-  GrowableArray <Klass*>* list = java_lang_Class::fixup_mirror_list();\n+  GrowableArrayCHeap<Klass*, mtClass>* list = java_lang_Class::fixup_mirror_list();\n","filename":"src\/hotspot\/share\/memory\/universe.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,2 +64,2 @@\n-  GrowableArray<JvmtiCodeBlobDesc*>* _code_blobs;   \/\/ collected blobs\n-  int _pos;                                         \/\/ iterator position\n+  GrowableArrayCHeap<JvmtiCodeBlobDesc*, mtServiceability>* _code_blobs; \/\/ collected blobs\n+  int _pos; \/\/ iterator position\n@@ -68,1 +68,1 @@\n-  static GrowableArray<JvmtiCodeBlobDesc*>* _global_code_blobs;\n+  static GrowableArrayCHeap<JvmtiCodeBlobDesc*, mtServiceability>* _global_code_blobs;\n@@ -110,1 +110,1 @@\n-GrowableArray<JvmtiCodeBlobDesc*>* CodeBlobCollector::_global_code_blobs;\n+GrowableArrayCHeap<JvmtiCodeBlobDesc*, mtServiceability>* CodeBlobCollector::_global_code_blobs;\n@@ -176,1 +176,1 @@\n-  _global_code_blobs = new (mtServiceability) GrowableArray<JvmtiCodeBlobDesc*>(50, mtServiceability);\n+  _global_code_blobs = new GrowableArrayCHeap<JvmtiCodeBlobDesc*, mtServiceability>(50);\n","filename":"src\/hotspot\/share\/prims\/jvmtiCodeBlobEvents.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    GrowableArray<jvmtiDeferredLocalVariableSet*>* list = updates->deferred_locals();\n+    GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, mtCompiler>* list = updates->deferred_locals();\n","filename":"src\/hotspot\/share\/prims\/jvmtiDeferredUpdates.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariable*>* _locals;\n+  GrowableArrayCHeap<jvmtiDeferredLocalVariable*, mtCompiler>* _locals;\n@@ -119,1 +119,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*> _deferred_locals_updates;\n+  GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, mtCompiler> _deferred_locals_updates;\n@@ -131,1 +131,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals() { return &_deferred_locals_updates; }\n+  GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, mtCompiler>* deferred_locals() { return &_deferred_locals_updates; }\n@@ -135,2 +135,2 @@\n-    _deferred_locals_updates((AnyObj::set_allocation_type((address) &_deferred_locals_updates,\n-                             AnyObj::C_HEAP), 1), mtCompiler) { }\n+    \/\/ TODO ok to remove the set_allocation_type?\n+    _deferred_locals_updates(1) { }\n@@ -143,1 +143,1 @@\n-  static GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred_locals(JavaThread* jt) {\n+  static GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, MEMFLAGS::mtCompiler>* deferred_locals(JavaThread* jt) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiDeferredUpdates.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1357,2 +1357,2 @@\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n-      new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+  GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list =\n+    new GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>(1);\n@@ -1430,2 +1430,2 @@\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list =\n-         new (mtServiceability) GrowableArray<jvmtiMonitorStackDepthInfo*>(1, mtServiceability);\n+  GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list =\n+    new GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>(1);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -955,1 +955,1 @@\n-                                 GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list) {\n+                                 GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list) {\n@@ -1002,1 +1002,1 @@\n-                                 GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list) {\n+                                 GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability> *owned_monitors_list) {\n@@ -1030,1 +1030,2 @@\n-                                 javaVFrame *jvf, GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitors_list, jint stack_depth) {\n+                                 javaVFrame *jvf,\n+                                 GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list, jint stack_depth) {\n@@ -1817,1 +1818,1 @@\n-  _allocations = new (mtServiceability) GrowableArray<unsigned char*>(20, mtServiceability);\n+  _allocations = new GrowableArrayCHeap<unsigned char*, mtServiceability>(20);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -362,1 +362,1 @@\n-                                   GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitors_list,\n+                                   GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list,\n@@ -423,1 +423,1 @@\n-                                GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list);\n+                                GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list);\n@@ -425,1 +425,1 @@\n-                                GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors_list);\n+                                GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list);\n@@ -546,1 +546,1 @@\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *_owned_monitors_list;\n+  GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* _owned_monitors_list;\n@@ -550,1 +550,1 @@\n-                             GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitor_list)\n+                             GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitor_list)\n@@ -772,1 +772,1 @@\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *_owned_monitors_list;\n+  GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* _owned_monitors_list;\n@@ -778,1 +778,1 @@\n-                                          GrowableArray<jvmtiMonitorStackDepthInfo*>* owned_monitors_list)\n+                                          GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors_list)\n@@ -845,1 +845,1 @@\n-  GrowableArray<unsigned char*> *_allocations;\n+  GrowableArrayCHeap<unsigned char*, mtServiceability> *_allocations;\n@@ -860,1 +860,1 @@\n-  GrowableArray<jvmtiMonitorStackDepthInfo*> *_owned_monitors_list;\n+  GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* _owned_monitors_list;\n@@ -866,1 +866,1 @@\n-                      GrowableArray<jvmtiMonitorStackDepthInfo*> *owned_monitors,\n+                      GrowableArrayCHeap<jvmtiMonitorStackDepthInfo*, mtServiceability>* owned_monitors,\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.hpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -98,1 +98,1 @@\n-  _pops = new (mtServiceability) GrowableArray<int> (2, mtServiceability);\n+  _pops = new GrowableArrayCHeap<int, mtServiceability> (2);\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  GrowableArray<int>* _pops;\n+  GrowableArrayCHeap<int, mtServiceability>* _pops;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvThreadState.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+class JvmtiThreadState;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3056,1 +3056,1 @@\n-   _code_blobs = new (mtServiceability) GrowableArray<JvmtiCodeBlobDesc*>(1, mtServiceability);\n+   _code_blobs = new GrowableArrayCHeap<JvmtiCodeBlobDesc*, mtServiceability>(1);\n@@ -3085,1 +3085,1 @@\n-    _allocated = new (mtServiceability) GrowableArray<OopHandle>(1, mtServiceability);\n+    _allocated = new GrowableArrayCHeap<OopHandle, mtServiceability>(1);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -505,1 +505,1 @@\n-  GrowableArray<JvmtiCodeBlobDesc*>* _code_blobs;           \/\/ collected code blob events\n+  GrowableArrayCHeap<JvmtiCodeBlobDesc*, mtServiceability>* _code_blobs; \/\/ collected code blob events\n@@ -522,1 +522,1 @@\n-  GrowableArray<OopHandle>* _allocated;      \/\/ field to record collected allocated object oop.\n+  GrowableArrayCHeap<OopHandle, mtServiceability>* _allocated; \/\/ field to record collected allocated object oop.\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-GrowableArray<jvmtiExtensionFunctionInfo*>* JvmtiExtensions::_ext_functions;\n+GrowableArrayCHeap<jvmtiExtensionFunctionInfo*, mtServiceability>* JvmtiExtensions::_ext_functions;\n@@ -38,1 +38,1 @@\n-GrowableArray<jvmtiExtensionEventInfo*>* JvmtiExtensions::_ext_events;\n+GrowableArrayCHeap<jvmtiExtensionEventInfo*, mtServiceability>* JvmtiExtensions::_ext_events;\n@@ -173,2 +173,2 @@\n-  _ext_functions = new (mtServiceability) GrowableArray<jvmtiExtensionFunctionInfo*>(1, mtServiceability);\n-  _ext_events = new (mtServiceability) GrowableArray<jvmtiExtensionEventInfo*>(1, mtServiceability);\n+  _ext_functions = new GrowableArrayCHeap<jvmtiExtensionFunctionInfo*, mtServiceability>(1);\n+  _ext_events = new GrowableArrayCHeap<jvmtiExtensionEventInfo*, mtServiceability>(1);\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-  static GrowableArray<jvmtiExtensionFunctionInfo*>* _ext_functions;\n-  static GrowableArray<jvmtiExtensionEventInfo*>* _ext_events;\n+  static GrowableArrayCHeap<jvmtiExtensionFunctionInfo*, mtServiceability>* _ext_functions;\n+  static GrowableArrayCHeap<jvmtiExtensionEventInfo*, mtServiceability>* _ext_events;\n","filename":"src\/hotspot\/share\/prims\/jvmtiExtensions.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -142,1 +142,1 @@\n-  _elements       = new (mtServiceability) GrowableArray<GrowableElement*>(5, mtServiceability);\n+  _elements       = new GrowableArrayCHeap<GrowableElement*, mtServiceability>(5);\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-  GrowableArray<GrowableElement *> *_elements;\n+  GrowableArrayCHeap<GrowableElement*, mtServiceability> *_elements;\n","filename":"src\/hotspot\/share\/prims\/jvmtiImpl.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,2 +39,2 @@\n-GrowableArray<JvmtiRawMonitor*>* JvmtiPendingMonitors::_monitors =\n-  new (mtServiceability) GrowableArray<JvmtiRawMonitor*>(1, mtServiceability);\n+GrowableArrayCHeap<JvmtiRawMonitor*, mtServiceability>* JvmtiPendingMonitors::_monitors =\n+  new GrowableArrayCHeap<JvmtiRawMonitor*, mtServiceability>(1);\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -136,1 +136,2 @@\n-  static GrowableArray<JvmtiRawMonitor*>* _monitors; \/\/ Cache raw monitor enter\n+  \/\/ Cache raw monitor enter\n+  static GrowableArrayCHeap<JvmtiRawMonitor*, mtServiceability>* _monitors;\n@@ -138,1 +139,1 @@\n-  inline static GrowableArray<JvmtiRawMonitor*>* monitors() { return _monitors; }\n+  inline static GrowableArrayCHeap<JvmtiRawMonitor*, mtServiceability>* monitors() { return _monitors; }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRawMonitor.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-  GrowableArray<Klass*>* redef_classes = state->get_classes_being_redefined();\n+  GrowableArrayCHeap<Klass*, mtClass>* redef_classes = state->get_classes_being_redefined();\n@@ -108,1 +108,1 @@\n-    redef_classes = new (mtClass) GrowableArray<Klass*>(1, mtClass);\n+    redef_classes = new GrowableArrayCHeap<Klass*, mtClass>(1);\n@@ -144,1 +144,1 @@\n-  GrowableArray<Klass*>* redef_classes = state->get_classes_being_redefined();\n+  GrowableArrayCHeap<Klass*, mtClass>* redef_classes = state->get_classes_being_redefined();\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -395,1 +395,1 @@\n-  GrowableArray<ClassFieldDescriptor*>* _fields;\n+  GrowableArrayCHeap<ClassFieldDescriptor*, mtServiceability>* _fields;\n@@ -416,2 +416,1 @@\n-  _fields = new (mtServiceability)\n-    GrowableArray<ClassFieldDescriptor*>(initial_field_count, mtServiceability);\n+  _fields = new GrowableArrayCHeap<ClassFieldDescriptor*, mtServiceability>(initial_field_count);\n@@ -498,1 +497,1 @@\n-  static GrowableArray<InstanceKlass*>* _class_list;\n+  static GrowableArrayCHeap<InstanceKlass*, mtServiceability>* _class_list;\n@@ -514,1 +513,1 @@\n-GrowableArray<InstanceKlass*>* JvmtiCachedClassFieldMap::_class_list;\n+GrowableArrayCHeap<InstanceKlass*, mtServiceability>* JvmtiCachedClassFieldMap::_class_list;\n@@ -550,2 +549,1 @@\n-    _class_list = new (mtServiceability)\n-      GrowableArray<InstanceKlass*>(initial_class_count, mtServiceability);\n+    _class_list = new GrowableArrayCHeap<InstanceKlass*, mtServiceability>(initial_class_count);\n@@ -1219,2 +1217,2 @@\n-  GrowableArray<jobject>* _object_results;  \/\/ collected objects (JNI weak refs)\n-  GrowableArray<uint64_t>* _tag_results;    \/\/ collected tags\n+  GrowableArrayCHeap<jobject, mtServiceability>* _object_results;  \/\/ collected objects (JNI weak refs)\n+  GrowableArrayCHeap<uint64_t, mtServiceability>* _tag_results;    \/\/ collected tags\n@@ -1229,2 +1227,2 @@\n-    _object_results(new (mtServiceability) GrowableArray<jobject>(1, mtServiceability)),\n-    _tag_results(new (mtServiceability) GrowableArray<uint64_t>(1, mtServiceability)) { }\n+    _object_results(new GrowableArrayCHeap<jobject, mtServiceability>(1)),\n+    _tag_results(new GrowableArrayCHeap<uint64_t, mtServiceability>(1)) { }\n@@ -1452,1 +1450,1 @@\n-  static GrowableArray<oop>* _visit_stack;\n+  static GrowableArrayCHeap<oop, mtServiceability>* _visit_stack;\n@@ -1456,3 +1454,3 @@\n-  static JvmtiTagMap* tag_map()                        { return _tag_map; }\n-  static const void* user_data()                       { return _user_data; }\n-  static GrowableArray<oop>* visit_stack()             { return _visit_stack; }\n+  static JvmtiTagMap* tag_map()                                   { return _tag_map; }\n+  static const void* user_data()                                  { return _user_data; }\n+  static GrowableArrayCHeap<oop, mtServiceability>* visit_stack() { return _visit_stack; }\n@@ -1492,1 +1490,1 @@\n-                                             GrowableArray<oop>* visit_stack,\n+                                             GrowableArrayCHeap<oop, mtServiceability>* visit_stack,\n@@ -1499,1 +1497,1 @@\n-                                                GrowableArray<oop>* visit_stack,\n+                                                GrowableArrayCHeap<oop, mtServiceability>* visit_stack,\n@@ -1534,1 +1532,1 @@\n-GrowableArray<oop>* CallbackInvoker::_visit_stack;\n+GrowableArrayCHeap<oop, mtServiceability>* CallbackInvoker::_visit_stack;\n@@ -1539,1 +1537,1 @@\n-                                                     GrowableArray<oop>* visit_stack,\n+                                                     GrowableArrayCHeap<oop, mtServiceability>* visit_stack,\n@@ -1554,1 +1552,1 @@\n-                                                        GrowableArray<oop>* visit_stack,\n+                                                        GrowableArrayCHeap<oop, mtServiceability>* visit_stack,\n@@ -2388,1 +2386,1 @@\n-  GrowableArray<oop>* _visit_stack;                 \/\/ the visit stack\n+  GrowableArrayCHeap<oop, mtServiceability>* _visit_stack; \/\/ the visit stack\n@@ -2401,2 +2399,2 @@\n-  GrowableArray<oop>* create_visit_stack() {\n-    return new (mtServiceability) GrowableArray<oop>(initial_visit_stack_size, mtServiceability);\n+  GrowableArrayCHeap<oop, mtServiceability>* create_visit_stack() {\n+    return new GrowableArrayCHeap<oop, mtServiceability>(initial_visit_stack_size);\n@@ -2416,1 +2414,1 @@\n-  GrowableArray<oop>* visit_stack() const          { return _visit_stack; }\n+  GrowableArrayCHeap<oop, mtServiceability>* visit_stack() const { return _visit_stack; }\n","filename":"src\/hotspot\/share\/prims\/jvmtiTagMap.cpp","additions":22,"deletions":24,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-  GrowableArray<Klass*>* _classes_being_redefined;\n+  GrowableArrayCHeap<Klass*, mtClass>* _classes_being_redefined;\n@@ -385,1 +385,1 @@\n-  inline GrowableArray<Klass*>* get_classes_being_redefined() {\n+  inline GrowableArrayCHeap<Klass*, mtClass>* get_classes_being_redefined() {\n@@ -389,1 +389,1 @@\n-  inline void set_classes_being_redefined(GrowableArray<Klass*>* redef_classes) {\n+  inline void set_classes_being_redefined(GrowableArrayCHeap<Klass*, mtClass>* redef_classes) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiThreadState.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -121,1 +121,1 @@\n-GrowableArray<ModulePatchPath*> *Arguments::_patch_mod_prefix = nullptr;\n+GrowableArrayCHeap<ModulePatchPath*, mtArguments> *Arguments::_patch_mod_prefix = nullptr;\n@@ -2840,1 +2840,1 @@\n-    _patch_mod_prefix = new (mtArguments) GrowableArray<ModulePatchPath*>(10, mtArguments);\n+    _patch_mod_prefix = new GrowableArrayCHeap<ModulePatchPath*, mtArguments>(10);\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -214,1 +214,1 @@\n-  static GrowableArray<ModulePatchPath*>* _patch_mod_prefix;\n+  static GrowableArrayCHeap<ModulePatchPath*, mtArguments>* _patch_mod_prefix;\n@@ -484,1 +484,1 @@\n-  static GrowableArray<ModulePatchPath*>* get_patch_mod_prefix() { return _patch_mod_prefix; }\n+  static GrowableArrayCHeap<ModulePatchPath*, mtArguments>* get_patch_mod_prefix() { return _patch_mod_prefix; }\n","filename":"src\/hotspot\/share\/runtime\/arguments.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1251,4 +1251,4 @@\n-  GrowableArray<oop*>* _oops;\n-  GrowableArray<narrowOop*>* _narrow_oops;\n-  GrowableArray<derived_base*>* _base;\n-  GrowableArray<derived_pointer*>* _derived;\n+  GrowableArrayCHeap<oop*, mtThread>* _oops;\n+  GrowableArrayCHeap<narrowOop*, mtThread>* _narrow_oops;\n+  GrowableArrayCHeap<derived_base*, mtThread>* _base;\n+  GrowableArrayCHeap<derived_pointer*, mtThread>* _derived;\n@@ -1259,4 +1259,4 @@\n-    _oops = new (mtThread) GrowableArray<oop*>(100, mtThread);\n-    _narrow_oops = new (mtThread) GrowableArray<narrowOop*>(100, mtThread);\n-    _base = new (mtThread) GrowableArray<derived_base*>(100, mtThread);\n-    _derived = new (mtThread) GrowableArray<derived_pointer*>(100, mtThread);\n+    _oops = new GrowableArrayCHeap<oop*, mtThread>(100);\n+    _narrow_oops = new GrowableArrayCHeap<narrowOop*, mtThread>(100);\n+    _base = new GrowableArrayCHeap<derived_base*, mtThread>(100);\n+    _derived = new GrowableArrayCHeap<derived_pointer*, mtThread>(100);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -1367,1 +1367,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(this);\n+  GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, mtCompiler>* list = JvmtiDeferredUpdates::deferred_locals(this);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -118,0 +118,1 @@\n+template<class E, MEMFLAGS F> class GrowableArrayCHeap;\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -495,1 +495,1 @@\n-  _set = new (mtInternal) PerfDataArray(length, mtInternal);\n+  _set = new PerfDataArray(length);\n@@ -500,1 +500,1 @@\n-  _set = new (mtInternal) PerfDataArray(p->length(), mtInternal);\n+  _set = new PerfDataArray(p->length());\n","filename":"src\/hotspot\/share\/runtime\/perfData.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-template <typename T> class GrowableArray;\n+template <typename T, MEMFLAGS F> class GrowableArrayCHeap;\n@@ -578,1 +578,1 @@\n-    typedef GrowableArray<PerfData*> PerfDataArray;\n+    typedef GrowableArrayCHeap<PerfData*, mtInternal> PerfDataArray;\n","filename":"src\/hotspot\/share\/runtime\/perfData.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -74,2 +74,2 @@\n-GrowableArray<FilteredField*> *FilteredFieldsMap::_filtered_fields =\n-  new (mtServiceability) GrowableArray<FilteredField*>(3, mtServiceability);\n+GrowableArrayCHeap<FilteredField*, mtServiceability> *FilteredFieldsMap::_filtered_fields =\n+  new GrowableArrayCHeap<FilteredField*, mtServiceability>(3);\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -176,1 +176,1 @@\n-  static GrowableArray<FilteredField *> *_filtered_fields;\n+  static GrowableArrayCHeap<FilteredField*, mtServiceability> *_filtered_fields;\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -82,1 +82,1 @@\n-  set_metadata_handles(new (mtClass) GrowableArray<Metadata*>(30, mtClass));\n+  set_metadata_handles(new GrowableArrayCHeap<Metadata*, mtClass>(30));\n","filename":"src\/hotspot\/share\/runtime\/thread.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -412,2 +412,2 @@\n-  GrowableArray<Metadata*>* metadata_handles() const          { return _metadata_handles; }\n-  void set_metadata_handles(GrowableArray<Metadata*>* handles){ _metadata_handles = handles; }\n+  GrowableArrayCHeap<Metadata*, mtClass>* metadata_handles() const { return _metadata_handles; }\n+  void set_metadata_handles(GrowableArrayCHeap<Metadata*, mtClass>* handles){ _metadata_handles = handles; }\n@@ -532,1 +532,1 @@\n-  GrowableArray<Metadata*>* _metadata_handles;\n+  GrowableArrayCHeap<Metadata*, mtClass>* _metadata_handles;\n","filename":"src\/hotspot\/share\/runtime\/thread.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class ObjectMonitor;\n","filename":"src\/hotspot\/share\/runtime\/threads.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,2 +38,1 @@\n-  _oop_list = new (mtThread)\n-                    GrowableArray<UnhandledOopEntry>(free_list_size, mtThread);\n+  _oop_list = new GrowableArrayCHeap<UnhandledOopEntry, mtThread>(free_list_size);\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-  GrowableArray<UnhandledOopEntry> *_oop_list;\n+  GrowableArrayCHeap<UnhandledOopEntry, mtThread> *_oop_list;\n","filename":"src\/hotspot\/share\/runtime\/unhandledOops.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -72,1 +72,1 @@\n-    GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n+    GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, mtCompiler>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -113,1 +113,1 @@\n-  GrowableArray<jvmtiDeferredLocalVariableSet*>* deferred = JvmtiDeferredUpdates::deferred_locals(thread());\n+  GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, mtCompiler>* deferred = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -205,1 +205,1 @@\n-    GrowableArray<jvmtiDeferredLocalVariableSet*>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n+    GrowableArrayCHeap<jvmtiDeferredLocalVariableSet*, mtCompiler>* list = JvmtiDeferredUpdates::deferred_locals(thread());\n@@ -416,1 +416,1 @@\n-  _locals = new(mtCompiler) GrowableArray<jvmtiDeferredLocalVariable*> (1, mtCompiler);\n+  _locals = new GrowableArrayCHeap<jvmtiDeferredLocalVariable*, mtCompiler>(1);\n","filename":"src\/hotspot\/share\/runtime\/vframe_hp.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -501,1 +501,1 @@\n-     static_field(CodeCache,                   _heaps,                                        GrowableArray<CodeHeap*>*)             \\\n+     static_field(CodeCache,                   _heaps,                                        CodeCache::CodeHeapArray*)             \\\n@@ -1240,0 +1240,1 @@\n+  declare_toplevel_type(CodeCache::CodeHeapArray)                         \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-  _array = new (mtServiceability) GrowableArray<char *>(32, mtServiceability);\n+  _array = new GrowableArrayCHeap<char*, mtServiceability>(32);\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,1 +36,1 @@\n-  GrowableArray<char*>* _array;\n+  GrowableArrayCHeap<char*, mtServiceability>* _array;\n@@ -43,1 +43,1 @@\n-  GrowableArray<char*>* array() {\n+  GrowableArrayCHeap<char*, mtServiceability>* array() {\n","filename":"src\/hotspot\/share\/services\/diagnosticArgument.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1626,1 +1626,1 @@\n-  GrowableArray<StackFrameInfo*>* _frames;\n+  GrowableArrayCHeap<StackFrameInfo*, mtServiceability>* _frames;\n@@ -1676,1 +1676,1 @@\n-  void dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map);\n+  void dump_stack_traces(AbstractDumpWriter* writer, GrowableArrayCHeap<Klass*, mtServiceability>* klass_map);\n@@ -1702,1 +1702,1 @@\n-  _frames = new (mtServiceability) GrowableArray<StackFrameInfo*>(10, mtServiceability);\n+  _frames = new GrowableArrayCHeap<StackFrameInfo*, mtServiceability>(10);\n@@ -1723,1 +1723,1 @@\n-void ThreadDumper::dump_stack_traces(AbstractDumpWriter* writer, GrowableArray<Klass*>* klass_map) {\n+void ThreadDumper::dump_stack_traces(AbstractDumpWriter* writer, GrowableArrayCHeap<Klass*, mtServiceability>* klass_map) {\n@@ -2176,1 +2176,1 @@\n-  GrowableArray<Klass*>*  _klass_map;\n+  GrowableArrayCHeap<Klass*, mtServiceability>*  _klass_map;\n@@ -2241,1 +2241,1 @@\n-    _klass_map = new (mtServiceability) GrowableArray<Klass*>(INITIAL_CLASS_COUNT, mtServiceability);\n+    _klass_map = new GrowableArrayCHeap<Klass*, mtServiceability>(INITIAL_CLASS_COUNT);\n","filename":"src\/hotspot\/share\/services\/heapDumper.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1261,1 +1261,1 @@\n-        GrowableArray<OopHandle>* locked_monitors = frame->locked_monitors();\n+        GrowableArrayCHeap<OopHandle, mtServiceability>* locked_monitors = frame->locked_monitors();\n@@ -1271,1 +1271,1 @@\n-      GrowableArray<OopHandle>* jni_locked_monitors = stacktrace->jni_locked_monitors();\n+      GrowableArrayCHeap<OopHandle, mtServiceability>* jni_locked_monitors = stacktrace->jni_locked_monitors();\n@@ -1287,1 +1287,1 @@\n-      GrowableArray<OopHandle>* locks = (tcl != nullptr ? tcl->owned_locks() : nullptr);\n+      GrowableArrayCHeap<OopHandle, mtServiceability>* locks = (tcl != nullptr ? tcl->owned_locks() : nullptr);\n@@ -1762,1 +1762,1 @@\n-    GrowableArray<JavaThread*>* deadlock_threads = cycle->threads();\n+    GrowableArrayCHeap<JavaThread*, mtServiceability>* deadlock_threads = cycle->threads();\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,4 +46,4 @@\n-GrowableArray<MemoryPool*>* MemoryService::_pools_list =\n-  new (mtServiceability) GrowableArray<MemoryPool*>(init_pools_list_size, mtServiceability);\n-GrowableArray<MemoryManager*>* MemoryService::_managers_list =\n-  new (mtServiceability) GrowableArray<MemoryManager*>(init_managers_list_size, mtServiceability);\n+GrowableArrayCHeap<MemoryPool*, mtServiceability>* MemoryService::_pools_list =\n+  new GrowableArrayCHeap<MemoryPool*, mtServiceability>(init_pools_list_size);\n+GrowableArrayCHeap<MemoryManager*, mtServiceability>* MemoryService::_managers_list =\n+  new GrowableArrayCHeap<MemoryManager*, mtServiceability>(init_managers_list_size);\n@@ -52,2 +52,2 @@\n-GrowableArray<MemoryPool*>* MemoryService::_code_heap_pools =\n-    new (mtServiceability) GrowableArray<MemoryPool*>(init_code_heap_pools_size, mtServiceability);\n+GrowableArrayCHeap<MemoryPool*, mtServiceability>* MemoryService::_code_heap_pools =\n+  new GrowableArrayCHeap<MemoryPool*, mtServiceability>(init_code_heap_pools_size);\n","filename":"src\/hotspot\/share\/services\/memoryService.cpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -52,2 +52,2 @@\n-  static GrowableArray<MemoryPool*>*    _pools_list;\n-  static GrowableArray<MemoryManager*>* _managers_list;\n+  static GrowableArrayCHeap<MemoryPool*, mtServiceability>*    _pools_list;\n+  static GrowableArrayCHeap<MemoryManager*, mtServiceability>* _managers_list;\n@@ -56,2 +56,2 @@\n-  static MemoryManager*                 _code_cache_manager;\n-  static GrowableArray<MemoryPool*>*    _code_heap_pools;\n+  static MemoryManager*                                        _code_cache_manager;\n+  static GrowableArrayCHeap<MemoryPool*, mtServiceability>*    _code_heap_pools;\n@@ -59,2 +59,2 @@\n-  static MemoryPool*                    _metaspace_pool;\n-  static MemoryPool*                    _compressed_class_pool;\n+  static MemoryPool*                                           _metaspace_pool;\n+  static MemoryPool*                                           _compressed_class_pool;\n","filename":"src\/hotspot\/share\/services\/memoryService.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -612,1 +612,1 @@\n-      _locked_monitors = new (mtServiceability) GrowableArray<OopHandle>(length, mtServiceability);\n+      _locked_monitors = new GrowableArrayCHeap<OopHandle, mtServiceability>(length);\n@@ -664,1 +664,1 @@\n-  _frames = new (mtServiceability) GrowableArray<StackFrameInfo*>(INITIAL_ARRAY_SIZE, mtServiceability);\n+  _frames = new GrowableArrayCHeap<StackFrameInfo*, mtServiceability>(INITIAL_ARRAY_SIZE);\n@@ -668,1 +668,1 @@\n-    _jni_locked_monitors = new (mtServiceability) GrowableArray<OopHandle>(INITIAL_ARRAY_SIZE, mtServiceability);\n+    _jni_locked_monitors = new GrowableArrayCHeap<OopHandle, mtServiceability>(INITIAL_ARRAY_SIZE);\n@@ -740,1 +740,1 @@\n-    GrowableArray<OopHandle>* locked_monitors = frame->locked_monitors();\n+    GrowableArrayCHeap<OopHandle, mtServiceability>* locked_monitors = frame->locked_monitors();\n@@ -799,1 +799,1 @@\n-  GrowableArray<oop>* aos_objects = new (mtServiceability) GrowableArray<oop>(INITIAL_ARRAY_SIZE, mtServiceability);\n+  GrowableArrayCHeap<oop, mtServiceability>* aos_objects = new GrowableArrayCHeap<oop, mtServiceability>(INITIAL_ARRAY_SIZE);\n@@ -812,1 +812,1 @@\n-void ConcurrentLocksDump::build_map(GrowableArray<oop>* aos_objects) {\n+void ConcurrentLocksDump::build_map(GrowableArrayCHeap<oop, mtServiceability>* aos_objects) {\n@@ -857,1 +857,1 @@\n-  GrowableArray<OopHandle>* locks = (tcl != nullptr ? tcl->owned_locks() : nullptr);\n+  GrowableArrayCHeap<OopHandle, mtServiceability>* locks = (tcl != nullptr ? tcl->owned_locks() : nullptr);\n@@ -873,1 +873,1 @@\n-  _owned_locks = new (mtServiceability) GrowableArray<OopHandle>(INITIAL_ARRAY_SIZE, mtServiceability);\n+  _owned_locks = new GrowableArrayCHeap<OopHandle, mtServiceability>(INITIAL_ARRAY_SIZE);\n@@ -996,1 +996,1 @@\n-  _threads = new (mtServiceability) GrowableArray<JavaThread*>(INITIAL_ARRAY_SIZE, mtServiceability);\n+  _threads = new GrowableArrayCHeap<JavaThread*, mtServiceability>(INITIAL_ARRAY_SIZE);\n","filename":"src\/hotspot\/share\/services\/threadService.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -274,5 +274,5 @@\n-  JavaThread*                     _thread;\n-  int                             _depth;  \/\/ number of stack frames added\n-  bool                            _with_locked_monitors;\n-  GrowableArray<StackFrameInfo*>* _frames;\n-  GrowableArray<OopHandle>*       _jni_locked_monitors;\n+  JavaThread*                                            _thread;\n+  int                                                    _depth;  \/\/ number of stack frames added\n+  bool                                                   _with_locked_monitors;\n+  GrowableArrayCHeap<StackFrameInfo*, mtServiceability>* _frames;\n+  GrowableArrayCHeap<OopHandle, mtServiceability>*       _jni_locked_monitors;\n@@ -293,1 +293,1 @@\n-  GrowableArray<OopHandle>* jni_locked_monitors() { return _jni_locked_monitors; }\n+  GrowableArrayCHeap<OopHandle, mtServiceability>* jni_locked_monitors() { return _jni_locked_monitors; }\n@@ -307,1 +307,2 @@\n-  GrowableArray<OopHandle>* _locked_monitors; \/\/ list of object monitors locked by this frame\n+  \/\/ list of object monitors locked by this frame\n+  GrowableArrayCHeap<OopHandle, mtServiceability>* _locked_monitors;\n@@ -321,1 +322,1 @@\n-  GrowableArray<OopHandle>* locked_monitors() { return _locked_monitors; }\n+  GrowableArrayCHeap<OopHandle, mtServiceability>* locked_monitors() { return _locked_monitors; }\n@@ -328,1 +329,1 @@\n-  GrowableArray<OopHandle>*   _owned_locks;\n+  GrowableArrayCHeap<OopHandle, mtServiceability>* _owned_locks;\n@@ -345,1 +346,1 @@\n-  GrowableArray<OopHandle>*   owned_locks()                      { return _owned_locks; }\n+  GrowableArrayCHeap<OopHandle, mtServiceability>* owned_locks() { return _owned_locks; }\n@@ -354,1 +355,1 @@\n-  void build_map(GrowableArray<oop>* aos_objects);\n+  void build_map(GrowableArrayCHeap<oop, mtServiceability>* aos_objects);\n@@ -404,2 +405,2 @@\n-  GrowableArray<JavaThread*>* _threads;\n-  DeadlockCycle*              _next;\n+  GrowableArrayCHeap<JavaThread*, mtServiceability>* _threads;\n+  DeadlockCycle* _next;\n@@ -415,1 +416,1 @@\n-  GrowableArray<JavaThread*>* threads()     { return _threads; }\n+  GrowableArrayCHeap<JavaThread*, mtServiceability>* threads() { return _threads; }\n","filename":"src\/hotspot\/share\/services\/threadService.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -191,1 +191,0 @@\n-  ~BitMap() {}\n","filename":"src\/hotspot\/share\/utilities\/bitMap.hpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/thread.hpp\"\n@@ -31,7 +31,0 @@\n-void* GrowableArrayResourceAllocator::allocate(int max, int elementSize) {\n-  assert(max >= 0, \"integer overflow\");\n-  size_t byte_size = elementSize * (size_t) max;\n-\n-  return (void*)resource_allocate_bytes(byte_size);\n-}\n-\n@@ -59,1 +52,0 @@\n-\n@@ -61,2 +53,2 @@\n-    _nesting(on_resource_area ? Thread::current()->resource_area()->nesting() : 0) {\n-}\n+    _nesting(on_resource_area ? Thread::current()->resource_area()->nesting() : 0),\n+    _on_resource_area(on_resource_area) {}\n@@ -64,1 +56,1 @@\n-void GrowableArrayNestingCheck::on_resource_area_alloc() const {\n+void GrowableArrayNestingCheck::on_allocate() const {\n@@ -68,1 +60,2 @@\n-  if (_nesting != Thread::current()->resource_area()->nesting()) {\n+  if (_on_resource_area &&\n+      _nesting != Thread::current()->resource_area()->nesting()) {\n@@ -72,20 +65,0 @@\n-\n-void GrowableArrayMetadata::init_checks(const GrowableArrayBase* array) const {\n-  \/\/ Stack allocated arrays support all three element allocation locations\n-  if (array->allocated_on_stack_or_embedded()) {\n-    return;\n-  }\n-\n-  \/\/ Otherwise there's a strict one-to-one mapping\n-  assert(on_C_heap() == array->allocated_on_C_heap(),\n-         \"growable array must be C heap allocated if elements are\");\n-  assert(on_resource_area() == array->allocated_on_res_area(),\n-         \"growable array must be resource allocated if elements are\");\n-  assert(on_arena() == array->allocated_on_arena(),\n-         \"growable array must be arena allocated if elements are\");\n-}\n-\n-void GrowableArrayMetadata::on_resource_area_alloc_check() const {\n-  _nesting_check.on_resource_area_alloc();\n-}\n-\n","filename":"src\/hotspot\/share\/utilities\/growableArray.cpp","additions":6,"deletions":33,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -30,0 +30,2 @@\n+#include \"memory\/resourceArea.hpp\"\n+#include \"runtime\/thread.hpp\"\n@@ -35,0 +37,1 @@\n+\n@@ -61,1 +64,1 @@\n-\/* If the GrowableArrays you are creating is C_Heap allocated then it    *\/\n+\/* If you are using a GrowableArraysCHeap (allocates on CHeap) then it   *\/\n@@ -69,3 +72,1 @@\n-\/\/ Non-template base class responsible for handling the length and max.\n-\n-\n+\/\/ Non-template base class responsible for handling the length and capacity.\n@@ -87,2 +88,0 @@\n-  ~GrowableArrayBase() {}\n-\n@@ -96,6 +95,0 @@\n-\n-  void  clear()                 { _len = 0; }\n-  void  trunc_to(int length)    {\n-    assert(length <= _len,\"cannot increase length\");\n-    _len = length;\n-  }\n@@ -105,1 +98,0 @@\n-template <typename E, typename UnaryPredicate> class GrowableArrayFilterIterator;\n@@ -124,2 +116,0 @@\n-  ~GrowableArrayView() {}\n-\n@@ -127,1 +117,11 @@\n-  const static GrowableArrayView EMPTY;\n+  void clear() { trunc_to(0); }\n+\n+  void trunc_to(int length)    {\n+    assert(length <= _len,\"cannot increase length\");\n+    assert(length >= 0,\"positive length\");\n+    \/\/ Destruct all elements from new length to old length\n+    for (int i = length; i < _len; i++) {\n+      this->_data[i].~E();\n+    }\n+    _len = length;\n+  }\n@@ -183,1 +183,7 @@\n-    return _data[--_len];\n+    int new_len = _len - 1;\n+    \/\/ copy-construct the return value\n+    E elem(_data[new_len]);\n+    \/\/ destruct the old value\n+    this->_data[new_len].~E();\n+    _len = new_len;\n+    return elem;\n@@ -191,0 +197,6 @@\n+  void at_swap(int i, int j) {\n+    E tmp = this->at(i);\n+    this->at_put(i, this->at(j));\n+    this->at_put(j, tmp);\n+  }\n+\n@@ -261,0 +273,5 @@\n+\n+    \/\/ destruct old element\n+    this->_data[index].~E();\n+\n+    \/\/ copy-construct, and destruct all the way up. This simulates the move.\n@@ -262,1 +279,2 @@\n-      _data[j-1] = _data[j];\n+      ::new ((void*)&this->_data[j-1]) E(_data[j]);\n+      this->_data[j].~E();\n@@ -264,0 +282,1 @@\n+\n@@ -277,0 +296,6 @@\n+    \/\/ Destruct old elements\n+    for (int i = start; i < end; i++) {\n+      this->_data[i].~E();\n+    }\n+\n+    \/\/ Move down the high elements\n@@ -278,1 +303,2 @@\n-      at_put(i, at(j));\n+      ::new ((void*)&this->_data[i]) E(_data[j]);\n+      this->_data[j].~E();\n@@ -280,1 +306,1 @@\n-    trunc_to(length() - (end - start));\n+    _len -= (end - start);\n@@ -286,4 +312,8 @@\n-    if (index < --_len) {\n-      \/\/ Replace removed element with last one.\n-      _data[index] = _data[_len];\n-    }\n+\n+    _len--;\n+    \/\/ Destruct old\n+    this->_data[index].~E();\n+    \/\/ Copy-construct last element to deleted slot\n+    ::new ((void*)&this->_data[index]) E(_data[_len]);\n+    \/\/ Destruct last element\n+    this->_data[_len].~E();\n@@ -300,1 +330,2 @@\n-  template <typename K, int compare(const K&, const E&)> int find_sorted(const K& key, bool& found) const {\n+  template <typename K, int compare(const K&, const E&)>\n+  int find_sorted(const K& key, bool& found) const {\n@@ -321,22 +352,0 @@\n-  template <typename K>\n-  int find_sorted(CompareClosure<E>* cc, const K& key, bool& found) {\n-    found = false;\n-    int min = 0;\n-    int max = length() - 1;\n-\n-    while (max >= min) {\n-      int mid = (int)(((uint)max + min) \/ 2);\n-      E value = at(mid);\n-      int diff = cc->do_compare(key, value);\n-      if (diff > 0) {\n-        min = mid + 1;\n-      } else if (diff < 0) {\n-        max = mid - 1;\n-      } else {\n-        found = true;\n-        return mid;\n-      }\n-    }\n-    return min;\n-  }\n-\n@@ -353,3 +362,0 @@\n-template<typename E>\n-const GrowableArrayView<E> GrowableArrayView<E>::EMPTY(nullptr, 0, 0);\n-\n@@ -376,0 +382,1 @@\n+private:\n@@ -382,3 +389,2 @@\n-    for (int i = 0; i < capacity; i++) {\n-      ::new ((void*)&data[i]) E();\n-    }\n+    \/\/ Allocate for \"capacity\" many elements, but do not yet\n+    \/\/ initialize \/ construct any elements.\n@@ -390,0 +396,2 @@\n+    \/\/ We initialize \/ construct (with placement new, copy constructor),\n+    \/\/ for \"initial_len\" many elements.\n@@ -393,3 +401,2 @@\n-    for (; i < capacity; i++) {\n-      ::new ((void*)&data[i]) E();\n-    }\n+    \/\/ The \"capacity\" may be larger, but we leave the rest\n+    \/\/ of the space uninitialized \/ no construction.\n@@ -398,2 +405,0 @@\n-  ~GrowableArrayWithAllocator() {}\n-\n@@ -404,1 +409,7 @@\n-    this->_data[idx] = elem;\n+\n+    \/\/ The destination element on _data is not yet initialized.\n+    \/\/ Hence, we need to use placement new, with copy-construct.\n+    \/\/ Assignment would be wrong, as it assumes the destination\n+    \/\/ was already initialized.\n+    ::new ((void*)&this->_data[idx]) E(elem);\n+\n@@ -421,2 +432,7 @@\n-      for (int j = this->_len; j <= i; j++)\n-        this->_data[j] = fill;\n+      \/\/ The elements from old len to new len are not yet\n+      \/\/ initialized. We use placement new with copy-construct.\n+      \/\/ Assignment would be wrong, as it assumes the destination\n+      \/\/ was already initialized.\n+      for (int j = this->_len; j <= i; j++) {\n+        ::new ((void*)&this->_data[j]) E(fill);\n+      }\n@@ -432,2 +448,8 @@\n-      for (int j = this->_len; j < i; j++)\n-        this->_data[j] = fill;\n+      \/\/ The elements from old len to new len are not yet\n+      \/\/ initialized. We use placement new with copy-construct.\n+      \/\/ Assignment would be wrong, as it assumes the destination\n+      \/\/ was already initialized.\n+      for (int j = this->_len; j < i; j++) {\n+        ::new ((void*)&this->_data[j]) E(fill);\n+      }\n+      ::new ((void*)&this->_data[i]) E(elem);\n@@ -435,0 +457,3 @@\n+    } else {\n+      \/\/ Destination is already initialized, so use assignment.\n+      this->_data[i] = elem;\n@@ -436,1 +461,0 @@\n-    this->_data[i] = elem;\n@@ -442,1 +466,6 @@\n-    if (this->_len == this->_capacity) grow(this->_len);\n+\n+    if (this->_len == this->_capacity) {\n+      grow(this->_len);\n+    }\n+\n+    \/\/ Move up the high elements (copy-construct \/ deconstruct)\n@@ -444,1 +473,2 @@\n-      this->_data[j + 1] = this->_data[j];\n+      ::new ((void*)&this->_data[j + 1]) E(this->_data[j]);\n+      this->_data[j].~E();\n@@ -446,0 +476,4 @@\n+\n+    \/\/ Place the new element\n+    ::new ((void*)&this->_data[idx]) E(elem);\n+\n@@ -447,1 +481,0 @@\n-    this->_data[idx] = elem;\n@@ -451,0 +484,1 @@\n+    assert(this != array, \"cannot insert itself to itself\");\n@@ -452,0 +486,1 @@\n+\n@@ -454,1 +489,0 @@\n-    if (new_len >= this->_capacity) grow(new_len);\n@@ -456,0 +490,5 @@\n+    if (new_len >= this->_capacity) {\n+      grow(new_len);\n+    }\n+\n+    \/\/ Move up the high elements (copy-construct \/ deconstruct)\n@@ -457,1 +496,2 @@\n-      this->_data[j + array_len] = this->_data[j];\n+      ::new ((void*)&this->_data[j + array_len]) E(this->_data[j]);\n+      this->_data[j].~E();\n@@ -460,0 +500,1 @@\n+    \/\/ Place all new elements\n@@ -461,1 +502,1 @@\n-      this->_data[idx + j] = array->at(j);\n+      ::new ((void*)&this->_data[idx + j]) E(array->at(j));\n@@ -468,3 +509,1 @@\n-    for (int i = 0; i < l->length(); i++) {\n-      this->at_put_grow(this->_len, l->at(i), E());\n-    }\n+    insert_before(this->_len, l);\n@@ -477,1 +516,2 @@\n-  template <int compare(const E&, const E&)> E insert_sorted(const E& key) {\n+  template <int compare(const E&, const E&)>\n+  E insert_sorted(const E& key) {\n@@ -486,15 +526,0 @@\n-  E insert_sorted(CompareClosure<E>* cc, const E& key) {\n-    bool found;\n-    int location = find_sorted(cc, key, found);\n-    if (!found) {\n-      insert_before(location, key);\n-    }\n-    return this->at(location);\n-  }\n-\n-  void swap(GrowableArrayWithAllocator<E, Derived>* other) {\n-    ::swap(this->_data, other->_data);\n-    ::swap(this->_len, other->_len);\n-    ::swap(this->_capacity, other->_capacity);\n-  }\n-\n@@ -503,5 +528,0 @@\n-\n-  \/\/ Reduce capacity to length.\n-  void shrink_to_fit();\n-\n-  void clear_and_deallocate();\n@@ -515,0 +535,2 @@\n+\n+  \/\/ Allocate the new data with new capacity\n@@ -516,1 +538,3 @@\n-  E* newData = static_cast<Derived*>(this)->allocate();\n+  E* new_data = static_cast<Derived*>(this)->allocate();\n+\n+  \/\/ Copy-construct old->new (using placement new)\n@@ -518,3 +542,15 @@\n-  for (     ; i < this->_len; i++) ::new ((void*)&newData[i]) E(this->_data[i]);\n-  for (     ; i < this->_capacity; i++) ::new ((void*)&newData[i]) E();\n-  for (i = 0; i < old_capacity; i++) this->_data[i].~E();\n+  for (     ; i < this->_len; i++) {\n+    ::new ((void*)&new_data[i]) E(this->_data[i]);\n+  }\n+\n+  \/\/ Leave rest of space up to \"new_capacity\" uninitialized,\n+  \/\/ no construction\n+\n+  \/\/ Remove the old elements, calling the destructor\n+  \/\/ (on initialized elements only)\n+  for (i = 0; i < this->_len; i++) {\n+    this->_data[i].~E();\n+  }\n+\n+  \/\/ Now that we have destructed all elements on the old\n+  \/\/ data, we can deallocate it.\n@@ -524,1 +560,3 @@\n-  this->_data = newData;\n+\n+  \/\/ swap in the new data\n+  this->_data = new_data;\n@@ -540,39 +578,0 @@\n-template <typename E, typename Derived>\n-void GrowableArrayWithAllocator<E, Derived>::shrink_to_fit() {\n-  int old_capacity = this->_capacity;\n-  int len = this->_len;\n-  assert(len <= old_capacity, \"invariant\");\n-\n-  \/\/ If already at full capacity, nothing to do.\n-  if (len == old_capacity) {\n-    return;\n-  }\n-\n-  \/\/ If not empty, allocate new, smaller, data, and copy old data to it.\n-  E* old_data = this->_data;\n-  E* new_data = nullptr;\n-  this->_capacity = len;        \/\/ Must preceed allocate().\n-  if (len > 0) {\n-    new_data = static_cast<Derived*>(this)->allocate();\n-    for (int i = 0; i < len; ++i) ::new (&new_data[i]) E(old_data[i]);\n-  }\n-  \/\/ Destroy contents of old data, and deallocate it.\n-  for (int i = 0; i < old_capacity; ++i) old_data[i].~E();\n-  if (old_data != nullptr) {\n-    static_cast<Derived*>(this)->deallocate(old_data);\n-  }\n-  \/\/ Install new data, which might be nullptr.\n-  this->_data = new_data;\n-}\n-\n-template <typename E, typename Derived>\n-void GrowableArrayWithAllocator<E, Derived>::clear_and_deallocate() {\n-  this->clear();\n-  this->shrink_to_fit();\n-}\n-\n-class GrowableArrayResourceAllocator {\n-public:\n-  static void* allocate(int max, int element_size);\n-};\n-\n@@ -593,1 +592,0 @@\n-\n@@ -598,0 +596,1 @@\n+  bool _on_resource_area;\n@@ -602,1 +601,2 @@\n-  void on_resource_area_alloc() const;\n+  int nesting() const { return _nesting; }\n+  void on_allocate() const;\n@@ -604,65 +604,0 @@\n-\n-#endif \/\/ ASSERT\n-\n-\/\/ Encodes where the backing array is allocated\n-\/\/ and performs necessary checks.\n-class GrowableArrayMetadata {\n-  uintptr_t _bits;\n-\n-  \/\/ resource area nesting at creation\n-  debug_only(GrowableArrayNestingCheck _nesting_check;)\n-\n-  \/\/ Resource allocation\n-  static uintptr_t bits() {\n-    return 0;\n-  }\n-\n-  \/\/ CHeap allocation\n-  static uintptr_t bits(MEMFLAGS memflags) {\n-    assert(memflags != mtNone, \"Must provide a proper MEMFLAGS\");\n-    return (uintptr_t(memflags) << 1) | 1;\n-  }\n-\n-  \/\/ Arena allocation\n-  static uintptr_t bits(Arena* arena) {\n-    assert((uintptr_t(arena) & 1) == 0, \"Required for on_C_heap() to work\");\n-    return uintptr_t(arena);\n-  }\n-\n-public:\n-  \/\/ Resource allocation\n-  GrowableArrayMetadata() :\n-      _bits(bits())\n-      debug_only(COMMA _nesting_check(true)) {\n-  }\n-\n-  \/\/ Arena allocation\n-  GrowableArrayMetadata(Arena* arena) :\n-      _bits(bits(arena))\n-      debug_only(COMMA _nesting_check(false)) {\n-  }\n-\n-  \/\/ CHeap allocation\n-  GrowableArrayMetadata(MEMFLAGS memflags) :\n-      _bits(bits(memflags))\n-      debug_only(COMMA _nesting_check(false)) {\n-  }\n-\n-#ifdef ASSERT\n-  GrowableArrayMetadata(const GrowableArrayMetadata& other) :\n-      _bits(other._bits),\n-      _nesting_check(other._nesting_check) {\n-    assert(!on_C_heap(), \"Copying of CHeap arrays not supported\");\n-    assert(!other.on_C_heap(), \"Copying of CHeap arrays not supported\");\n-  }\n-\n-  GrowableArrayMetadata& operator=(const GrowableArrayMetadata& other) {\n-    _bits = other._bits;\n-    _nesting_check = other._nesting_check;\n-    assert(!on_C_heap(), \"Assignment of CHeap arrays not supported\");\n-    assert(!other.on_C_heap(), \"Assignment of CHeap arrays not supported\");\n-    return *this;\n-  }\n-\n-  void init_checks(const GrowableArrayBase* array) const;\n-  void on_resource_area_alloc_check() const;\n@@ -671,7 +606,0 @@\n-  bool on_C_heap() const        { return (_bits & 1) == 1; }\n-  bool on_resource_area() const { return _bits == 0; }\n-  bool on_arena() const         { return (_bits & 1) == 0 && _bits != 0; }\n-\n-  Arena* arena() const      { return (Arena*)_bits; }\n-  MEMFLAGS memflags() const { return MEMFLAGS(_bits >> 1); }\n-};\n@@ -679,1 +607,3 @@\n-\/\/ THE GrowableArray.\n+\/\/ The GrowableArray internal data is allocated from either:\n+\/\/  - Resrouce area (default)\n+\/\/  - Arena\n@@ -681,10 +611,1 @@\n-\/\/ Supports multiple allocation strategies:\n-\/\/  - Resource stack allocation: if no extra argument is provided\n-\/\/  - CHeap allocation: if memflags is provided\n-\/\/  - Arena allocation: if an arena is provided\n-\/\/\n-\/\/ There are some drawbacks of using GrowableArray, that are removed in some\n-\/\/ of the other implementations of GrowableArrayWithAllocator sub-classes:\n-\/\/\n-\/\/ Memory overhead: The multiple allocation strategies uses extra metadata\n-\/\/  embedded in the instance.\n+\/\/ Itself, it can be embedded, on stack, resource_arena or arena allocated.\n@@ -695,1 +616,13 @@\n-\n+\/\/\n+\/\/ For C-Heap allocation use GrowableArrayCHeap.\n+\/\/\n+\/\/ Note, that with GrowableArray does not deallocate the allocated memory from\n+\/\/ the arena \/ resource area, but rather just abandons it until the memory is\n+\/\/ released by the arena or by the ResourceMark from the resource area.\n+\/\/ Because GrowableArrays are often just abandoned rather than properly destructed,\n+\/\/ we have decided to require that elements are trivially destructible, so that\n+\/\/ it makes no difference if the destructors are called or not.\n+\/\/\n+\/\/ GrowableArray is copyable, but it only creates a shallow copy. Hence, one has\n+\/\/ to be careful not to duplicate the state and then diverge while sharing the\n+\/\/ underlying data.\n@@ -698,33 +631,11 @@\n-  friend class GrowableArrayWithAllocator<E, GrowableArray<E> >;\n-  friend class GrowableArrayTest;\n-\n-  static E* allocate(int max) {\n-    return (E*)GrowableArrayResourceAllocator::allocate(max, sizeof(E));\n-  }\n-\n-  static E* allocate(int max, MEMFLAGS memflags) {\n-    return (E*)GrowableArrayCHeapAllocator::allocate(max, sizeof(E), memflags);\n-  }\n-\n-  static E* allocate(int max, Arena* arena) {\n-    return (E*)GrowableArrayArenaAllocator::allocate(max, sizeof(E), arena);\n-  }\n-\n-  GrowableArrayMetadata _metadata;\n-\n-  void init_checks() const { debug_only(_metadata.init_checks(this);) }\n-\n-  \/\/ Where are we going to allocate memory?\n-  bool on_C_heap() const        { return _metadata.on_C_heap(); }\n-  bool on_resource_area() const { return _metadata.on_resource_area(); }\n-  bool on_arena() const         { return _metadata.on_arena(); }\n-\n-  E* allocate() {\n-    if (on_resource_area()) {\n-      debug_only(_metadata.on_resource_area_alloc_check());\n-      return allocate(this->_capacity);\n-    }\n-\n-    if (on_C_heap()) {\n-      return allocate(this->_capacity, _metadata.memflags());\n-    }\n+  \/\/ Since GrowableArray is arena \/ resource area allocated, it is a custom to\n+  \/\/ simply abandon the array and hence not destruct the elements. Therefore,\n+  \/\/ we only allow elements where the destruction does nothing anyway. That\n+  \/\/ way there is no difference between abandoning elements or destructing them.\n+#ifndef ASSERT\n+  \/\/ Sadly, we can only verify this in non-ASSERT mode, because AnyObj has a\n+  \/\/ destructor in ASSERT mode. Hence, we now allow non-trivial destructors\n+  \/\/ in ASSERT mode, but forbid them in product mode.\n+  static_assert(std::is_trivially_destructible<E>::value,\n+                \"GrowableArray only allows trivially destructible elements\");\n+#endif \/\/ ASSERT\n@@ -732,3 +643,2 @@\n-    assert(on_arena(), \"Sanity\");\n-    return allocate(this->_capacity, _metadata.arena());\n-  }\n+private:\n+  Arena* _arena;\n@@ -736,5 +646,4 @@\n-  void deallocate(E* mem) {\n-    if (on_C_heap()) {\n-      GrowableArrayCHeapAllocator::deallocate(mem);\n-    }\n-  }\n+  \/\/ Check for insidious allocation bug: if a GrowableArray reallocates _data,\n+  \/\/ this must be done under the same ResourceMark as the original.\n+  \/\/ Otherwise, the _data array will be deallocated too early.\n+  DEBUG_ONLY(GrowableArrayNestingCheck _nesting_check;)\n@@ -743,1 +652,5 @@\n-  GrowableArray() : GrowableArray(2 \/* initial_capacity *\/) {}\n+  GrowableArray() :\n+      GrowableArray(Thread::current()->resource_area()) {}\n+\n+  explicit GrowableArray(Arena* arena) :\n+      GrowableArray(arena, 2 \/* initial_capacity *\/) {}\n@@ -746,6 +659,1 @@\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n-          allocate(initial_capacity),\n-          initial_capacity),\n-      _metadata() {\n-    init_checks();\n-  }\n+    GrowableArray(Thread::current()->resource_area(), initial_capacity) {}\n@@ -753,1 +661,1 @@\n-  GrowableArray(int initial_capacity, MEMFLAGS memflags) :\n+  GrowableArray(Arena* arena, int initial_capacity) :\n@@ -755,1 +663,1 @@\n-          allocate(initial_capacity, memflags),\n+          allocate(arena, initial_capacity),\n@@ -757,2 +665,4 @@\n-      _metadata(memflags) {\n-    init_checks();\n+      _arena(arena)\n+      DEBUG_ONLY(COMMA _nesting_check(on_resource_area()))\n+  {\n+    DEBUG_ONLY( init_checks(); )\n@@ -762,0 +672,3 @@\n+      GrowableArray(Thread::current()->resource_area(), initial_capacity, initial_len, filler) {}\n+\n+  GrowableArray(Arena* arena, int initial_capacity, int initial_len, const E& filler) :\n@@ -763,1 +676,1 @@\n-          allocate(initial_capacity),\n+          allocate(arena, initial_capacity),\n@@ -765,2 +678,4 @@\n-      _metadata() {\n-    init_checks();\n+      _arena(arena)\n+      DEBUG_ONLY(COMMA _nesting_check(on_resource_area()))\n+  {\n+    DEBUG_ONLY( init_checks(); )\n@@ -769,6 +684,13 @@\n-  GrowableArray(int initial_capacity, int initial_len, const E& filler, MEMFLAGS memflags) :\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n-          allocate(initial_capacity, memflags),\n-          initial_capacity, initial_len, filler),\n-      _metadata(memflags) {\n-    init_checks();\n+#ifdef ASSERT\n+  bool on_resource_area() const {\n+    return _arena == (Arena*)Thread::current()->resource_area();\n+  };\n+#endif\n+\n+  void swap(GrowableArray<E>* other) {\n+    assert(_arena == other->_arena, \"must have same arena\");\n+    assert(_nesting_check.nesting() == other->_nesting_check.nesting(),\n+           \"same nesting if using resource area\");\n+    ::swap(this->_data, other->_data);\n+    ::swap(this->_len, other->_len);\n+    ::swap(this->_capacity, other->_capacity);\n@@ -777,6 +699,7 @@\n-  GrowableArray(Arena* arena, int initial_capacity, int initial_len, const E& filler) :\n-      GrowableArrayWithAllocator<E, GrowableArray<E> >(\n-          allocate(initial_capacity, arena),\n-          initial_capacity, initial_len, filler),\n-      _metadata(arena) {\n-    init_checks();\n+  E* allocate() {\n+    DEBUG_ONLY(_nesting_check.on_allocate(); )\n+    return allocate(_arena, this->_capacity);\n+  }\n+\n+  void deallocate(E* mem) {\n+    \/\/ We have arena allocation, so we just abandon the memory.\n@@ -785,3 +708,22 @@\n-  ~GrowableArray() {\n-    if (on_C_heap()) {\n-      this->clear_and_deallocate();\n+private:\n+  E* allocate(Arena* arena, int capacity) {\n+    return (E*)GrowableArrayArenaAllocator::allocate(capacity, sizeof(E), arena);\n+  }\n+\n+#ifdef ASSERT\n+  void init_checks() const {\n+    if (this->allocated_on_stack_or_embedded()) {\n+      return;\n+    } else if (this->allocated_on_res_area()) {\n+      assert(on_resource_area(),\n+             \"The elements must be resource area allocated if the GrowableArray itself is\");\n+    } else if (this->allocated_on_arena()) {\n+      assert(Arena_contains(_arena, this),\n+             \"if GrowableArray is arena allocated, then the elements must be from the same arena\");\n+    } else if (this->allocated_on_C_heap()) {\n+      \/\/ We should not allocate GrowableArray on the C-Heap, while the internal\n+      \/\/ memory is allocated on an Arena. Otherwise, the data pointer can outlive\n+      \/\/ the arena scope.\n+      assert(false, \"GrowableArray cannot be C heap allocated\");\n+    } else {\n+      assert(false, \"GrowableArray has unhandled allocation state\");\n@@ -790,0 +732,1 @@\n+#endif \/\/ ASSERT\n@@ -792,1 +735,10 @@\n-\/\/ Leaner GrowableArray for CHeap backed data arrays, with compile-time decided MEMFLAGS.\n+\/\/ The GrowableArrayCHeap internal data is allocated from C-Heap,\n+\/\/ with compile-time decided MEMFLAGS.\n+\/\/\n+\/\/ The GrowableArrayCHeap itself can be stack allocated, embedded\n+\/\/ or C heap allocated. It is up to the user to ensure that the\n+\/\/ array is eventually destructed \/ deallocated.\n+\/\/\n+\/\/ When the array is destructed, then all the remaining elements\n+\/\/ are first destructed. Hence, we allow elements with non-trivial\n+\/\/ destructors.\n@@ -842,0 +794,16 @@\n+\n+  \/\/ Reduce capacity to length.\n+  void shrink_to_fit();\n+\n+  void clear_and_deallocate() {\n+    this->clear();\n+    this->shrink_to_fit();\n+  }\n+\n+  \/\/ The template argument F ensures the MEMFLAGS are the\n+  \/\/ same for both arrays.\n+  void swap(GrowableArrayCHeap<E, F>* other) {\n+    ::swap(this->_data, other->_data);\n+    ::swap(this->_len, other->_len);\n+    ::swap(this->_capacity, other->_capacity);\n+  }\n@@ -844,0 +812,31 @@\n+template <typename E, MEMFLAGS F>\n+void GrowableArrayCHeap<E, F>::shrink_to_fit() {\n+  int old_capacity = this->_capacity;\n+  int len = this->_len;\n+  assert(len <= old_capacity, \"invariant\");\n+\n+  \/\/ If already at full capacity, nothing to do.\n+  if (len == old_capacity) {\n+    return;\n+  }\n+\n+  \/\/ If not empty, allocate new, smaller, data, and copy old data to it.\n+  E* old_data = this->_data;\n+  E* new_data = nullptr;\n+  this->_capacity = len;        \/\/ Must preceed allocate().\n+  if (len > 0) {\n+    new_data = this->allocate();\n+    \/\/ copy-construct old->new\n+    for (int i = 0; i < len; ++i) ::new (&new_data[i]) E(old_data[i]);\n+  }\n+\n+  \/\/ destruct old\n+  for (int i = 0; i < len; ++i) old_data[i].~E();\n+\n+  if (old_data != nullptr) {\n+    this->deallocate(old_data);\n+  }\n+  \/\/ Install new data, which might be nullptr.\n+  this->_data = new_data;\n+}\n+\n@@ -849,1 +848,0 @@\n-  template <typename F, typename UnaryPredicate> friend class GrowableArrayFilterIterator;\n@@ -863,41 +861,1 @@\n-  E operator*()                          { return _array->at(_position); }\n-\n-  bool operator==(const GrowableArrayIterator<E>& rhs)  {\n-    assert(_array == rhs._array, \"iterator belongs to different array\");\n-    return _position == rhs._position;\n-  }\n-\n-  bool operator!=(const GrowableArrayIterator<E>& rhs)  {\n-    assert(_array == rhs._array, \"iterator belongs to different array\");\n-    return _position != rhs._position;\n-  }\n-};\n-\n-\/\/ Custom STL-style iterator to iterate over elements of a GrowableArray that satisfy a given predicate\n-template <typename E, class UnaryPredicate>\n-class GrowableArrayFilterIterator : public StackObj {\n-  friend class GrowableArrayView<E>;\n-\n- private:\n-  const GrowableArrayView<E>* _array; \/\/ GrowableArray we iterate over\n-  int _position;                      \/\/ Current position in the GrowableArray\n-  UnaryPredicate _predicate;          \/\/ Unary predicate the elements of the GrowableArray should satisfy\n-\n- public:\n-  GrowableArrayFilterIterator(const GrowableArrayIterator<E>& begin, UnaryPredicate filter_predicate) :\n-      _array(begin._array), _position(begin._position), _predicate(filter_predicate) {\n-    \/\/ Advance to first element satisfying the predicate\n-    while(_position != _array->length() && !_predicate(_array->at(_position))) {\n-      ++_position;\n-    }\n-  }\n-\n-  GrowableArrayFilterIterator<E, UnaryPredicate>& operator++() {\n-    do {\n-      \/\/ Advance to next element satisfying the predicate\n-      ++_position;\n-    } while(_position != _array->length() && !_predicate(_array->at(_position)));\n-    return *this;\n-  }\n-\n-  E operator*() { return _array->at(_position); }\n+  const E& operator*()                   { return _array->at(_position); }\n@@ -914,10 +872,0 @@\n-\n-  bool operator==(const GrowableArrayFilterIterator<E, UnaryPredicate>& rhs)  {\n-    assert(_array == rhs._array, \"iterator belongs to different array\");\n-    return _position == rhs._position;\n-  }\n-\n-  bool operator!=(const GrowableArrayFilterIterator<E, UnaryPredicate>& rhs)  {\n-    assert(_array == rhs._array, \"iterator belongs to different array\");\n-    return _position != rhs._position;\n-  }\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":295,"deletions":347,"binary":false,"changes":642,"status":"modified"},{"patch":"@@ -29,14 +29,40 @@\n-struct WithEmbeddedArray {\n-  \/\/ Array embedded in another class\n-  GrowableArray<int> _a;\n-\n-  \/\/ Resource allocated data array\n-  WithEmbeddedArray(int initial_max) : _a(initial_max) {}\n-  \/\/ Arena allocated data array\n-  WithEmbeddedArray(Arena* arena, int initial_max) : _a(arena, initial_max, 0, 0) {}\n-  \/\/ CHeap allocated data array\n-  WithEmbeddedArray(int initial_max, MEMFLAGS memflags) : _a(initial_max, memflags) {\n-    assert(memflags != mtNone, \"test requirement\");\n-  }\n-  WithEmbeddedArray(const GrowableArray<int>& other) : _a(other) {}\n-};\n+\/\/ We have a list of each:\n+\/\/  - ModifyClosure\n+\/\/  - TestClosure\n+\/\/  - AllocatorClosure\n+\/\/  - AllocatorArgs\n+\/\/\n+\/\/ For each AllocationClosure and AllocatorArgs, we call dispatch\n+\/\/ with each of the ModifyClosuresi and each TestClosures. The\n+\/\/ allocation cosure allocates its array (with initial size and\n+\/\/ capacity specified by the AllocatorArgs), and then passes itself\n+\/\/ into the ModifyClosure which does some first modificaions and\n+\/\/ subsequently into the TestClosure, which runs the test.\n+\/\/\n+\/\/ For one test and allocator we do:\n+\/\/   test.reset()\n+\/\/   allocator.dispatch(modification, test);\n+\/\/   -> allocate GrowableArray\n+\/\/      modification.do_modify(allocator)\n+\/\/      test.do_test(allocator)\n+\/\/      -> call read \/ write ops on allocator which forwards\n+\/\/         that to the allocated GrowableArray\n+\/\/      de-allocate GrowableAray\n+\/\/   test.finish()\n+\/\/\n+\/\/ We test the arrays with different element types. Hence, the test\n+\/\/ is heavily templated. The idea is to ensure GrowableArray works\n+\/\/ for basic types, pointers, but also classes: for example with or\n+\/\/ without a default-constructor, or copy-assign operator. Of course\n+\/\/ if the copy-assign operator is deleted, then we cannot use certain\n+\/\/ write operations (such as at_put). With a special CtorDtor type we\n+\/\/ verify that constructor and destructor counts are as expected,\n+\/\/ for example we can verify the expected number of \"live\" elements.\n+\/\/\n+\/\/ ------------  Array Elements  -------------\n+\n+\/\/ Used to get an ith element of any type E.\n+template<typename E>\n+E value_factory(int i) {\n+  return E(i);\n+}\n@@ -44,16 +70,5 @@\n-\/\/ Test fixture to work with TEST_VM_F\n-class GrowableArrayTest : public ::testing::Test {\n-protected:\n-  \/\/ friend -> private accessors\n-  template <typename E>\n-  static bool elements_on_C_heap(const GrowableArray<E>* array) {\n-    return array->on_C_heap();\n-  }\n-  template <typename E>\n-  static bool elements_on_resource_area(const GrowableArray<E>* array) {\n-    return array->on_resource_area();\n-  }\n-  template <typename E>\n-  static bool elements_on_arena(const GrowableArray<E>* array) {\n-    return array->on_arena();\n-  }\n+\/\/ Used for sorting of any type E\n+template<typename E>\n+int value_compare_ptr(E* e1, E* e2) {\n+  return (*e1) - (*e2);\n+}\n@@ -61,6 +76,5 @@\n-  template <typename ArrayClass>\n-  static void test_append(ArrayClass* a) {\n-    \/\/ Add elements\n-    for (int i = 0; i < 10; i++) {\n-      a->append(i);\n-    }\n+\/\/ Used for sorting of any type E\n+template<typename E>\n+int value_compare_ref(const E& e1, const E& e2) {\n+  return e1 - e2;\n+}\n@@ -68,2 +82,14 @@\n-    \/\/ Check size\n-    ASSERT_EQ(a->length(), 10);\n+class Point {\n+private:\n+  int _x;\n+  int _y;\n+public:\n+  \/\/ On purpose, we have no default constructor\n+  \/\/ This is to test that it is not needed for\n+  \/\/ GrowableArray.\n+  Point() = delete;\n+  Point(int x, int y) : _x(x), _y(y) {}\n+\n+  bool operator==(const Point& other) const {\n+    return _x == other._x && _y == other._y;\n+  }\n@@ -71,4 +97,2 @@\n-    \/\/ Check elements\n-    for (int i = 0; i < 10; i++) {\n-      EXPECT_EQ(a->at(i), i);\n-    }\n+  bool operator!=(const Point& other) const {\n+    return !(*this == other);\n@@ -77,5 +101,6 @@\n-  template <typename ArrayClass>\n-  static void test_clear(ArrayClass* a) {\n-    \/\/ Add elements\n-    for (int i = 0; i < 10; i++) {\n-      a->append(i);\n+  int operator-(const Point& other) const {\n+    int i = _x - other._x;\n+    if (i == 0) {\n+      return _y - other._y;\n+    } else {\n+      return i;\n@@ -83,0 +108,2 @@\n+  }\n+};\n@@ -84,17 +111,7 @@\n-    \/\/ Check size\n-    ASSERT_EQ(a->length(), 10);\n-    ASSERT_EQ(a->is_empty(), false);\n-\n-    \/\/ Clear elements\n-    a->clear();\n-\n-    \/\/ Check size\n-    ASSERT_EQ(a->length(), 0);\n-    ASSERT_EQ(a->is_empty(), true);\n-\n-    \/\/ Add element\n-    a->append(11);\n-\n-    \/\/ Check size\n-    ASSERT_EQ(a->length(), 1);\n-    ASSERT_EQ(a->is_empty(), false);\n+class PointWithDefault {\n+private:\n+  int _x;\n+  int _y;\n+public:\n+  PointWithDefault(int x, int y) : _x(x), _y(y + 1) {}\n+  PointWithDefault() : PointWithDefault(0, 0) {}\n@@ -102,2 +119,3 @@\n-    \/\/ Clear elements\n-    a->clear();\n+  bool operator==(const PointWithDefault& other) const {\n+    return _x == other._x && _y == other._y;\n+  }\n@@ -105,3 +123,2 @@\n-    \/\/ Check size\n-    ASSERT_EQ(a->length(), 0);\n-    ASSERT_EQ(a->is_empty(), true);\n+  bool operator!=(const PointWithDefault& other) const {\n+    return !(*this == other);\n@@ -110,5 +127,6 @@\n-  template <typename ArrayClass>\n-  static void test_iterator(ArrayClass* a) {\n-    \/\/ Add elements\n-    for (int i = 0; i < 10; i++) {\n-      a->append(i);\n+  int operator-(const PointWithDefault& other) const {\n+    int i = _x - other._x;\n+    if (i == 0) {\n+      return _y - other._y;\n+    } else {\n+      return i;\n@@ -116,0 +134,2 @@\n+  }\n+};\n@@ -117,5 +137,17 @@\n-    \/\/ Iterate\n-    int counter = 0;\n-    for (GrowableArrayIterator<int> i = a->begin(); i != a->end(); ++i) {\n-      ASSERT_EQ(*i, counter++);\n-    }\n+class PointNoAssign {\n+private:\n+  int _x;\n+  int _y;\n+public:\n+  \/\/ No default constructor\n+  \/\/ No copy assign\n+  PointNoAssign(int x, int y) : _x(x), _y(y) {}\n+  PointNoAssign& operator=(PointNoAssign& other) = delete;\n+  \/\/ Now we have to explicitly define the copy constructor, so that\n+  \/\/ some compilers do not complain about:\n+  \/\/ \"error: definition of implicit copy constructor for 'PointNoAssign' is deprecated because it has a user-declared copy assignment operator\"\n+  PointNoAssign(PointNoAssign const&) = default;\n+\n+  bool operator==(const PointNoAssign& other) const {\n+    return _x == other._x && _y == other._y;\n+  }\n@@ -123,2 +155,2 @@\n-    \/\/ Check count\n-    ASSERT_EQ(counter, 10);\n+  bool operator!=(const PointNoAssign& other) const {\n+    return !(*this == other);\n@@ -127,17 +159,6 @@\n-  template <typename ArrayClass>\n-  static void test_capacity(ArrayClass* a) {\n-    ASSERT_EQ(a->length(), 0);\n-    a->reserve(50);\n-    ASSERT_EQ(a->length(), 0);\n-    ASSERT_EQ(a->capacity(), 50);\n-    for (int i = 0; i < 50; ++i) {\n-      a->append(i);\n-    }\n-    ASSERT_EQ(a->length(), 50);\n-    ASSERT_EQ(a->capacity(), 50);\n-    a->append(50);\n-    ASSERT_EQ(a->length(), 51);\n-    int capacity = a->capacity();\n-    ASSERT_GE(capacity, 51);\n-    for (int i = 0; i < 30; ++i) {\n-      a->pop();\n+  int operator-(const PointNoAssign& other) const {\n+    int i = _x - other._x;\n+    if (i == 0) {\n+      return _y - other._y;\n+    } else {\n+      return i;\n@@ -145,17 +166,0 @@\n-    ASSERT_EQ(a->length(), 21);\n-    ASSERT_EQ(a->capacity(), capacity);\n-    a->shrink_to_fit();\n-    ASSERT_EQ(a->length(), 21);\n-    ASSERT_EQ(a->capacity(), 21);\n-\n-    a->reserve(50);\n-    ASSERT_EQ(a->length(), 21);\n-    ASSERT_EQ(a->capacity(), 50);\n-\n-    a->clear();\n-    ASSERT_EQ(a->length(), 0);\n-    ASSERT_EQ(a->capacity(), 50);\n-\n-    a->shrink_to_fit();\n-    ASSERT_EQ(a->length(), 0);\n-    ASSERT_EQ(a->capacity(), 0);\n@@ -163,0 +167,1 @@\n+};\n@@ -164,4 +169,4 @@\n-  template <typename ArrayClass>\n-  static void test_copy1(ArrayClass* a) {\n-    ASSERT_EQ(a->length(), 1);\n-    ASSERT_EQ(a->at(0), 1);\n+template<>\n+Point value_factory<Point>(int i) {\n+  return Point(i, i+1);\n+}\n@@ -169,1 +174,8 @@\n-    \/\/ Only allowed to copy to stack and embedded ResourceObjs\n+template<>\n+PointWithDefault value_factory<PointWithDefault>(int i) {\n+  return PointWithDefault(i, i+1);\n+}\n+template<>\n+PointNoAssign value_factory<PointNoAssign>(int i) {\n+  return PointNoAssign(i, i+1);\n+}\n@@ -171,3 +183,8 @@\n-    \/\/ Copy to stack\n-    {\n-      GrowableArray<int> c(*a);\n+template<>\n+int* value_factory<int*>(int i) {\n+  \/\/ cast int to int ptr, just for sake of test\n+  \/\/ multiply i by 4, so that pointer subtract can count\n+  \/\/ the distance in integers, and get different results\n+  \/\/ for the comparison.\n+  return (int*)(0x100000000L + (long)i*4);\n+}\n@@ -175,3 +192,27 @@\n-      ASSERT_EQ(c.length(), 1);\n-      ASSERT_EQ(c.at(0), 1);\n-    }\n+class CtorDtor {\n+private:\n+  static int _constructed;\n+  static int _destructed;\n+  int _i;\n+public:\n+  \/\/ Since this class has a non-trivial destructor, we can only use it with\n+  \/\/ arena \/ resource area allocated arrays in ASSERT mode. In PRODUCT mode\n+  \/\/ non-trivial destructors are forbidden for GrowableArray.\n+#ifdef ASSERT\n+  static const bool is_enabled_for_arena = true;\n+#endif \/\/ ASSERT\n+#ifndef ASSERT\n+  static const bool is_enabled_for_arena = false;\n+#endif \/\/ ASSERT\n+\n+  CtorDtor() : _i(-1) { _constructed++; };\n+  explicit CtorDtor(int i) : _i(i) { _constructed++; }\n+  CtorDtor(const CtorDtor& t) : _i(t._i) { _constructed++; }\n+  CtorDtor& operator =(const CtorDtor& t) = default;\n+  CtorDtor(CtorDtor&& t) : _i(t._i) { \/* not counted, as t never destructed *\/ }\n+  CtorDtor& operator =(CtorDtor&& t) = default;\n+  ~CtorDtor() { _destructed++; }\n+\n+  bool operator==(const CtorDtor& other) const {\n+    return _i == other._i;\n+  }\n@@ -179,3 +220,3 @@\n-    \/\/ Copy to embedded\n-    {\n-      WithEmbeddedArray c(*a);\n+  bool operator!=(const CtorDtor& other) const {\n+    return !(*this == other);\n+  }\n@@ -183,3 +224,2 @@\n-      ASSERT_EQ(c._a.length(), 1);\n-      ASSERT_EQ(c._a.at(0), 1);\n-    }\n+  int operator-(const CtorDtor& other) const {\n+    return _i - other._i;\n@@ -188,4 +228,9 @@\n-  template <typename ArrayClass>\n-  static void test_assignment1(ArrayClass* a) {\n-    ASSERT_EQ(a->length(), 1);\n-    ASSERT_EQ(a->at(0), 1);\n+  static int constructed() { return _constructed; }\n+  static int destructed() { return _destructed; }\n+  static void reset() {\n+    _constructed = 0;\n+    _destructed = 0;\n+  }\n+};\n+int CtorDtor::_constructed = 0;\n+int CtorDtor::_destructed = 0;\n@@ -193,1 +238,2 @@\n-    \/\/ Only allowed to assign to stack and embedded ResourceObjs\n+template<typename E>\n+void reset_type() {}\n@@ -195,5 +241,4 @@\n-    \/\/ Copy to embedded\/resource\n-    {\n-      ResourceMark rm;\n-      GrowableArray<int> c(1);\n-      c = *a;\n+template<>\n+void reset_type<CtorDtor>() {\n+  CtorDtor::reset();\n+}\n@@ -201,3 +246,4 @@\n-      ASSERT_EQ(c.length(), 1);\n-      ASSERT_EQ(c.at(0), 1);\n-    }\n+template<typename E>\n+void check_constructor_count_for_type(int i) {\n+  \/\/ default no check because no count\n+}\n@@ -205,5 +251,4 @@\n-    \/\/ Copy to embedded\/arena\n-    {\n-      Arena arena(mtTest);\n-      GrowableArray<int> c(&arena, 1, 0, 0);\n-      c = *a;\n+template<>\n+void check_constructor_count_for_type<CtorDtor>(int i) {\n+  ASSERT_EQ(CtorDtor::constructed(), 0);\n+}\n@@ -211,3 +256,4 @@\n-      ASSERT_EQ(c.length(), 1);\n-      ASSERT_EQ(c.at(0), 1);\n-    }\n+template<typename E>\n+void check_alive_elements_for_type(int i) {\n+  \/\/ default no check because no count\n+}\n@@ -215,5 +261,4 @@\n-    \/\/ Copy to embedded\/resource\n-    {\n-      ResourceMark rm;\n-      WithEmbeddedArray c(1);\n-      c._a = *a;\n+template<>\n+void check_alive_elements_for_type<CtorDtor>(int i) {\n+  ASSERT_EQ(CtorDtor::constructed(), CtorDtor::destructed() + i);\n+}\n@@ -221,3 +266,1 @@\n-      ASSERT_EQ(c._a.length(), 1);\n-      ASSERT_EQ(c._a.at(0), 1);\n-    }\n+\/\/ -------------- Basic Definitions -------------\n@@ -225,5 +268,2 @@\n-    \/\/ Copy to embedded\/arena\n-    {\n-      Arena arena(mtTest);\n-      WithEmbeddedArray c(&arena, 1);\n-      c._a = *a;\n+template<typename E> class TestClosure;\n+template<typename E> class ModifyClosure;\n@@ -231,4 +271,7 @@\n-      ASSERT_EQ(c._a.length(), 1);\n-      ASSERT_EQ(c._a.at(0), 1);\n-    }\n-  }\n+enum AllocatorArgs {\n+  CAP2,\n+  CAP0,\n+  CAP100,\n+  CAP100LEN100,\n+  CAP200LEN50,\n+};\n@@ -236,6 +279,9 @@\n-  \/\/ Supported by all GrowableArrays\n-  enum TestEnum {\n-    Append,\n-    Clear,\n-    Capacity,\n-    Iterator\n+template<typename E>\n+class AllocatorClosure {\n+private:\n+  GrowableArrayView<E>* _view;\n+public:\n+  void dispatch(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) {\n+    test->reset();\n+    dispatch_impl(modify, test, args);\n+    test->finish(this);\n@@ -244,10 +290,1 @@\n-  template <typename ArrayClass>\n-  static void do_test(ArrayClass* a, TestEnum test) {\n-    switch (test) {\n-      case Append:\n-        test_append(a);\n-        break;\n-\n-      case Clear:\n-        test_clear(a);\n-        break;\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) = 0;\n@@ -255,3 +292,4 @@\n-      case Capacity:\n-        test_capacity(a);\n-        break;\n+  void dispatch_inner(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) {\n+    modify->do_modify(this, args);\n+    test->do_test(this);\n+  }\n@@ -259,3 +297,63 @@\n-      case Iterator:\n-        test_iterator(a);\n-        break;\n+  virtual bool is_C_heap() const = 0;\n+\n+  \/\/ at least set the view so that we do not have to repeat\n+  \/\/ forwarding in the subclasses of AllocatorClosure too\n+  \/\/ much.\n+  void set_view(GrowableArrayView<E>* view) { _view = view; }\n+  GrowableArrayView<E>& view() const { return *_view; }\n+\n+  \/\/ forwarding to underlying array view\n+  int length() const     { return _view->length(); };\n+  int capacity() const   { return _view->capacity(); };\n+  bool is_empty() const  { return _view->is_empty(); }\n+  void clear()           { _view->clear(); }\n+  void trunc_to(int length) { _view->trunc_to(length); }\n+\n+  E& at(int i)           { return _view->at(i); }\n+  E* adr_at(int i) const { return _view->adr_at(i); }\n+  E first() const        { return _view->first(); }\n+  E top() const          { return _view->top(); }\n+  E last() const         { return _view->last(); }\n+  GrowableArrayIterator<E> begin() const { return _view->begin(); }\n+  GrowableArrayIterator<E> end() const   { return _view->end(); }\n+  E pop()                { return _view->pop(); }\n+\n+  void at_put(int i, const E& elem) { _view->at_put(i, elem); }\n+  void at_swap(int i, int j) { _view->at_swap(i, j); }\n+  bool contains(const E& elem) const { return _view->contains(elem); }\n+  int find(const E& elem) const { return _view->find(elem); }\n+  int find_from_end(const E& elem) const { return _view->find_from_end(elem); }\n+\n+  template<typename Predicate>\n+  int find_if(Predicate predicate) const { return _view->find_if(predicate); }\n+\n+  template<typename Predicate>\n+  int find_from_end_if(Predicate predicate) const { return _view->find_from_end_if(predicate); }\n+\n+  void remove(const E& elem) { _view->remove(elem); }\n+  bool remove_if_existing(const E& elem) { return _view->remove_if_existing(elem); }\n+  void remove_at(int i) { _view->remove_at(i); }\n+  void remove_till(int i) { _view->remove_till(i); }\n+  void remove_range(int start, int end) { _view->remove_range(start, end); }\n+  void delete_at(int i) { _view->delete_at(i); }\n+\n+  \/\/ forwarding to underlying array with allocation\n+  virtual void append(const E& e) = 0;\n+  virtual bool append_if_missing(const E& e) = 0;\n+  virtual void push(const E& e) = 0;\n+  virtual void reserve(int new_capacity) = 0;\n+  virtual E at_grow(int i, const E& fill) = 0;\n+  virtual void at_put_grow (int i, const E& e, const E& fill) = 0;\n+  virtual void insert_before(int idx, const E& e) = 0;\n+  virtual void insert_before(int idx, const GrowableArrayView<E>* array) = 0;\n+  virtual void appendAll(const GrowableArrayView<E>* array) = 0;\n+  virtual E insert_sorted(const E& e) = 0;\n+\n+  \/\/ Only defined for CHeap:\n+  virtual void clear_and_deallocate() {\n+    ASSERT_TRUE(false);\n+  }\n+  virtual void shrink_to_fit() {;\n+    ASSERT_TRUE(false);\n+  }\n+};\n@@ -263,3 +361,15 @@\n-      default:\n-        fatal(\"Missing dispatch\");\n-        break;\n+template<typename E>\n+class TestClosure {\n+public:\n+  virtual void reset() {\n+    reset_type<E>();\n+  }\n+  virtual void do_test(AllocatorClosure<E>* a) = 0;\n+  virtual void finish(const AllocatorClosure<E>* a) {\n+    \/\/ After the array is destructed, all constructed elements\n+    \/\/ should again be destructed. But this only holds for\n+    \/\/ the CHeap version. The Arena \/ Resource Area allocated\n+    \/\/ array can simply be abandoned and the destructions\n+    \/\/ are not guaranteed for the elements.\n+    if (a->is_C_heap()) {\n+      check_alive_elements_for_type<E>(0);\n@@ -268,0 +378,1 @@\n+};\n@@ -269,5 +380,5 @@\n-  \/\/ Only supported by GrowableArrays without CHeap data arrays\n-  enum TestNoCHeapEnum {\n-    Copy1,\n-    Assignment1,\n-  };\n+template<typename E>\n+class ModifyClosure {\n+public:\n+  virtual void do_modify(AllocatorClosure<E>* a, AllocatorArgs args) = 0;\n+};\n@@ -275,6 +386,1 @@\n-  template <typename ArrayClass>\n-  static void do_test(ArrayClass* a, TestNoCHeapEnum test) {\n-    switch (test) {\n-      case Copy1:\n-        test_copy1(a);\n-        break;\n+\/\/ ------------ AllocationClosures ------------\n@@ -282,3 +388,4 @@\n-      case Assignment1:\n-        test_assignment1(a);\n-        break;\n+template<typename E>\n+class AllocatorClosureGrowableArray : public AllocatorClosure<E> {\n+private:\n+  GrowableArray<E>* _array;\n@@ -286,4 +393,4 @@\n-      default:\n-        fatal(\"Missing dispatch\");\n-        break;\n-    }\n+public:\n+  void set_array(GrowableArray<E>* array) {\n+    this->set_view(array);\n+    _array = array;\n@@ -292,23 +399,1 @@\n-  enum ModifyEnum {\n-    Append1,\n-    Append1Clear,\n-    Append1ClearAndDeallocate,\n-    NoModify\n-  };\n-\n-  template <typename ArrayClass>\n-  static void do_modify(ArrayClass* a, ModifyEnum modify) {\n-    switch (modify) {\n-      case Append1:\n-        a->append(1);\n-        break;\n-\n-      case Append1Clear:\n-        a->append(1);\n-        a->clear();\n-        break;\n-\n-      case Append1ClearAndDeallocate:\n-        a->append(1);\n-        a->clear_and_deallocate();\n-        break;\n+  virtual bool is_C_heap() const override final { return false; };\n@@ -316,3 +401,3 @@\n-      case NoModify:\n-        \/\/ Nothing to do\n-        break;\n+  virtual void append(const E& e) override final {\n+    _array->append(e);\n+  }\n@@ -320,4 +405,2 @@\n-      default:\n-        fatal(\"Missing dispatch\");\n-        break;\n-    }\n+  virtual bool append_if_missing(const E& e) override final {\n+    return _array->append_if_missing(e);\n@@ -326,2 +409,3 @@\n-  static const int Max0 = 0;\n-  static const int Max1 = 1;\n+  virtual void push(const E& e) override final {\n+    _array->push(e);\n+  }\n@@ -329,4 +413,2 @@\n-  template <typename ArrayClass, typename T>\n-  static void modify_and_test(ArrayClass* array, ModifyEnum modify, T test) {\n-    do_modify(array, modify);\n-    do_test(array, test);\n+  virtual void reserve(int new_capacity) override final {\n+    _array->reserve(new_capacity);\n@@ -335,8 +417,3 @@\n-  template <typename T>\n-  static void with_no_cheap_array(int max, ModifyEnum modify, T test) {\n-    \/\/ Resource\/Resource allocated\n-    {\n-      ResourceMark rm;\n-      GrowableArray<int>* a = new GrowableArray<int>(max);\n-      modify_and_test(a, modify, test);\n-    }\n+  virtual E at_grow(int i, const E& fill) override final {\n+    return _array->at_grow(i, fill);\n+  }\n@@ -344,2 +421,6 @@\n-    \/\/ Resource\/Arena allocated\n-    \/\/  Combination not supported\n+  \/\/ The implementation of at_put_grow uses assignment. We should\n+  \/\/ only instantiate a call to it if assignment is allowed.\n+  \/\/ I have to do this workaround because the method is virtual.\n+  virtual void at_put_grow (int i, const E& e, const E& fill) override final {\n+    at_put_grow_impl<E>(i, e, fill);\n+  }\n@@ -347,2 +428,4 @@\n-    \/\/ CHeap\/Resource allocated\n-    \/\/  Combination not supported\n+  template<typename E2, ENABLE_IF(std::is_copy_assignable<E2>::value)>\n+  void at_put_grow_impl(int i, const E& e, const E& fill) {\n+    _array->at_put_grow(i, e, fill);\n+  }\n@@ -350,2 +433,5 @@\n-    \/\/ CHeap\/Arena allocated\n-    \/\/  Combination not supported\n+  template<typename E2, ENABLE_IF(!std::is_copy_assignable<E2>::value)>\n+  void at_put_grow_impl(int i, const E& e, const E& fill) {\n+    \/\/ do not call if copy-assign not implemented for elements\n+    ASSERT_TRUE(false);\n+  }\n@@ -353,6 +439,3 @@\n-    \/\/ Stack\/Resource allocated\n-    {\n-      ResourceMark rm;\n-      GrowableArray<int> a(max);\n-      modify_and_test(&a, modify, test);\n-    }\n+  virtual void insert_before(int idx, const E& e) override final{\n+    _array->insert_before(idx, e);\n+  }\n@@ -360,6 +443,3 @@\n-    \/\/ Stack\/Arena allocated\n-    {\n-      Arena arena(mtTest);\n-      GrowableArray<int> a(&arena, max, 0, 0);\n-      modify_and_test(&a, modify, test);\n-    }\n+  virtual void insert_before(int idx, const GrowableArrayView<E>* array) override final {\n+    _array->insert_before(idx, array);\n+  }\n@@ -367,6 +447,3 @@\n-    \/\/ Embedded\/Resource allocated\n-    {\n-      ResourceMark rm;\n-      WithEmbeddedArray w(max);\n-      modify_and_test(&w._a, modify, test);\n-    }\n+  virtual void appendAll(const GrowableArrayView<E>* array) override final {\n+    _array->appendAll(array);\n+  }\n@@ -374,6 +451,3 @@\n-    \/\/ Embedded\/Arena allocated\n-    {\n-      Arena arena(mtTest);\n-      WithEmbeddedArray w(&arena, max);\n-      modify_and_test(&w._a, modify, test);\n-    }\n+  virtual E insert_sorted(const E& e) override final {\n+    \/\/ virtual function cannot have template, so we just fill in the template here\n+    return _array->template insert_sorted<value_compare_ref<E>>(e);\n@@ -381,0 +455,1 @@\n+};\n@@ -382,3 +457,11 @@\n-  static void with_cheap_array(int max, ModifyEnum modify, TestEnum test) {\n-    \/\/ Resource\/CHeap allocated\n-    \/\/  Combination not supported\n+template<typename E>\n+class EmbeddedGrowableArray {\n+private:\n+  GrowableArray<E> _array;\n+public:\n+  explicit EmbeddedGrowableArray(int cap) : _array(cap) {}\n+  EmbeddedGrowableArray(int cap, int len, const E& filler) : _array(cap, len, filler) {}\n+  EmbeddedGrowableArray(Arena* a, int cap) : _array(a, cap) {}\n+  EmbeddedGrowableArray(Arena* a, int cap, int len, const E& filler) : _array(a, cap, len, filler) {}\n+  GrowableArray<E>* array() { return &_array; }\n+};\n@@ -386,6 +469,11 @@\n-    \/\/ CHeap\/CHeap allocated\n-    {\n-      GrowableArray<int>* a = new (mtTest) GrowableArray<int>(max, mtTest);\n-      modify_and_test(a, modify, test);\n-      delete a;\n-    }\n+#define ARGS_CASES(CASE) {                                        \\\n+  switch (args) {                                                 \\\n+    CASE(CAP2, 2)                                                 \\\n+    CASE(CAP0, 0)                                                 \\\n+    CASE(CAP100, 100)                                             \\\n+    CASE(CAP100LEN100, 100 COMMA 100 COMMA value_factory<E>(-42)) \\\n+    CASE(CAP200LEN50, 200 COMMA 50 COMMA value_factory<E>(-42))   \\\n+    default:                                                      \\\n+      ASSERT_TRUE(false);                                         \\\n+  }                                                               \\\n+}\n@@ -393,5 +481,9 @@\n-    \/\/ Stack\/CHeap allocated\n-    {\n-      GrowableArray<int> a(max, mtTest);\n-      modify_and_test(&a, modify, test);\n-    }\n+#define CASE(args, init) {                            \\\n+  case args:                                          \\\n+  {                                                   \\\n+    ResourceMark rm;                                  \\\n+    GrowableArray<E> array(init);                     \\\n+    dispatch_impl_helper(modify, test, &array, args); \\\n+    break;                                            \\\n+  }                                                   \\\n+}\n@@ -399,5 +491,6 @@\n-    \/\/ Embedded\/CHeap allocated\n-    {\n-      WithEmbeddedArray w(max, mtTest);\n-      modify_and_test(&w._a, modify, test);\n-    }\n+template<typename E>\n+class AllocatorClosureStackResourceArea : public AllocatorClosureGrowableArray<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ implicit destructor\n@@ -406,3 +499,7 @@\n-  static void with_all_types(int max, ModifyEnum modify, TestEnum test) {\n-    with_no_cheap_array(max, modify, test);\n-    with_cheap_array(max, modify, test);\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArray<E>* array, AllocatorArgs args) {\n+#ifdef ASSERT\n+    ASSERT_TRUE(array->allocated_on_stack_or_embedded()); \/\/ itself: stack\n+    ASSERT_TRUE(array->on_resource_area()); \/\/ data: resource area\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n@@ -410,0 +507,1 @@\n+};\n@@ -411,3 +509,11 @@\n-  static void with_all_types_empty(TestEnum test) {\n-    with_all_types(Max0, NoModify, test);\n-  }\n+#undef CASE\n+#define CASE(args, init) {                           \\\n+  case args:                                         \\\n+  {                                                  \\\n+    ResourceMark rm;                                 \\\n+    EmbeddedGrowableArray<E> embedded(init);         \\\n+    GrowableArray<E>* array = embedded.array();      \\\n+    dispatch_impl_helper(modify, test, array, args); \\\n+    break;                                           \\\n+  }                                                  \\\n+}\n@@ -415,3 +521,7 @@\n-  static void with_all_types_max_set(TestEnum test) {\n-    with_all_types(Max1, NoModify, test);\n-  }\n+template<typename E>\n+class AllocatorClosureEmbeddedResourceArea : public AllocatorClosureGrowableArray<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ implicit destructor\n+  };\n@@ -419,2 +529,7 @@\n-  static void with_all_types_cleared(TestEnum test) {\n-    with_all_types(Max1, Append1Clear, test);\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArray<E>* array, AllocatorArgs args) {\n+#ifdef ASSERT\n+    ASSERT_TRUE(array->allocated_on_stack_or_embedded()); \/\/ itself: embedded\n+    ASSERT_TRUE(array->on_resource_area()); \/\/ data: resource area\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n@@ -422,0 +537,1 @@\n+};\n@@ -423,3 +539,10 @@\n-  static void with_all_types_clear_and_deallocated(TestEnum test) {\n-    with_all_types(Max1, Append1ClearAndDeallocate, test);\n-  }\n+#undef CASE\n+#define CASE(args, init) {                            \\\n+  case args:                                          \\\n+  {                                                   \\\n+    ResourceMark rm;                                  \\\n+    GrowableArray<E>* array = new GrowableArray<E>(init); \\\n+    dispatch_impl_helper(modify, test, array, args);  \\\n+    break;                                            \\\n+  }                                                   \\\n+}\n@@ -427,6 +550,7 @@\n-  static void with_all_types_all_0(TestEnum test) {\n-    with_all_types_empty(test);\n-    with_all_types_max_set(test);\n-    with_all_types_cleared(test);\n-    with_all_types_clear_and_deallocated(test);\n-  }\n+template<typename E>\n+class AllocatorClosureResourceAreaResourceArea : public AllocatorClosureGrowableArray<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ no destructors called, array just abandoned\n+  };\n@@ -434,2 +558,7 @@\n-  static void with_no_cheap_array_append1(TestNoCHeapEnum test) {\n-    with_no_cheap_array(Max0, Append1, test);\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArray<E>* array, AllocatorArgs args) {\n+#ifdef ASSERT\n+    ASSERT_TRUE(array->allocated_on_res_area()); \/\/ itself: resource arena\n+    ASSERT_TRUE(array->on_resource_area()); \/\/ data: resource area\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n@@ -439,2 +568,9 @@\n-TEST_VM_F(GrowableArrayTest, append) {\n-  with_all_types_all_0(Append);\n+#undef CASE\n+#define CASE(args, init) {                            \\\n+  case args:                                          \\\n+  {                                                   \\\n+    Arena arena(mtTest);                              \\\n+    GrowableArray<E> array(&arena, init);             \\\n+    dispatch_impl_helper(modify, test, &array, args); \\\n+    break;                                            \\\n+  }                                                   \\\n@@ -443,3 +579,7 @@\n-TEST_VM_F(GrowableArrayTest, clear) {\n-  with_all_types_all_0(Clear);\n-}\n+template<typename E>\n+class AllocatorClosureStackArena : public AllocatorClosureGrowableArray<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ implicit destructor\n+  };\n@@ -447,3 +587,9 @@\n-TEST_VM_F(GrowableArrayTest, capacity) {\n-  with_all_types_all_0(Capacity);\n-}\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArray<E>* array, AllocatorArgs args) {\n+#ifdef ASSERT\n+    ASSERT_TRUE(array->allocated_on_stack_or_embedded()); \/\/ itself: stack\n+    ASSERT_TRUE(!array->on_resource_area()); \/\/ data: arena\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n+  }\n+};\n@@ -451,2 +597,10 @@\n-TEST_VM_F(GrowableArrayTest, iterator) {\n-  with_all_types_all_0(Iterator);\n+#undef CASE\n+#define CASE(args, init) {                           \\\n+  case args:                                         \\\n+  {                                                  \\\n+    Arena arena(mtTest);                             \\\n+    EmbeddedGrowableArray<E> embedded(&arena, init); \\\n+    GrowableArray<E>* array = embedded.array();      \\\n+    dispatch_impl_helper(modify, test, array, args); \\\n+    break;                                           \\\n+  }                                                  \\\n@@ -455,3 +609,0 @@\n-TEST_VM_F(GrowableArrayTest, copy) {\n-  with_no_cheap_array_append1(Copy1);\n-}\n@@ -459,2 +610,27 @@\n-TEST_VM_F(GrowableArrayTest, assignment) {\n-  with_no_cheap_array_append1(Assignment1);\n+template<typename E>\n+class AllocatorClosureEmbeddedArena : public AllocatorClosureGrowableArray<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ implicit destructor\n+  };\n+\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArray<E>* array, AllocatorArgs args) {\n+#ifdef ASSERT\n+    ASSERT_TRUE(array->allocated_on_stack_or_embedded()); \/\/ itself: embedded\n+    ASSERT_TRUE(!array->on_resource_area()); \/\/ data: arena\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n+  }\n+};\n+\n+#undef CASE\n+#define CASE(args, init) {                       \\\n+  case args:                                     \\\n+  {                                              \\\n+    Arena arena(mtTest);                         \\\n+    GrowableArray<E>* array = new (&arena) GrowableArray<E>(&arena, init); \\\n+    dispatch_impl_helper(modify, test, array, args); \\\n+    break;                                       \\\n+  }                                              \\\n@@ -463,0 +639,10 @@\n+\n+template<typename E>\n+class AllocatorClosureArenaArena : public AllocatorClosureGrowableArray<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ no destructors called, array just abandoned\n+  };\n+\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArray<E>* array, AllocatorArgs args) {\n@@ -464,4 +650,12 @@\n-TEST_VM_F(GrowableArrayTest, where) {\n-  WithEmbeddedArray s(1, mtTest);\n-  ASSERT_FALSE(s._a.allocated_on_C_heap());\n-  ASSERT_TRUE(elements_on_C_heap(&s._a));\n+    ASSERT_TRUE(array->allocated_on_arena()); \/\/ itself: arena\n+    ASSERT_TRUE(!array->on_resource_area()); \/\/ data: arena\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n+  }\n+};\n+\n+template<typename E>\n+class AllocatorClosureGrowableArrayCHeap : public AllocatorClosure<E> {\n+private:\n+  GrowableArrayCHeap<E, mtTest>* _array;\n@@ -469,6 +663,4 @@\n-  \/\/ Resource\/Resource allocated\n-  {\n-    ResourceMark rm;\n-    GrowableArray<int>* a = new GrowableArray<int>();\n-    ASSERT_TRUE(a->allocated_on_res_area());\n-    ASSERT_TRUE(elements_on_resource_area(a));\n+public:\n+  void set_array(GrowableArrayCHeap<E, mtTest>* array) {\n+    this->set_view(array);\n+    _array = array;\n@@ -477,2 +669,1 @@\n-  \/\/ Resource\/CHeap allocated\n-  \/\/  Combination not supported\n+  virtual bool is_C_heap() const override final { return true; };\n@@ -480,2 +671,3 @@\n-  \/\/ Resource\/Arena allocated\n-  \/\/  Combination not supported\n+  virtual void append(const E& e) override final {\n+    _array->append(e);\n+  }\n@@ -483,2 +675,3 @@\n-  \/\/ CHeap\/Resource allocated\n-  \/\/  Combination not supported\n+  virtual bool append_if_missing(const E& e) override final {\n+    return _array->append_if_missing(e);\n+  }\n@@ -486,6 +679,2 @@\n-  \/\/ CHeap\/CHeap allocated\n-  {\n-    GrowableArray<int>* a = new (mtTest) GrowableArray<int>(0, mtTest);\n-    ASSERT_TRUE(a->allocated_on_C_heap());\n-    ASSERT_TRUE(elements_on_C_heap(a));\n-    delete a;\n+  virtual void push(const E& e) override final {\n+    _array->push(e);\n@@ -494,2 +683,3 @@\n-  \/\/ CHeap\/Arena allocated\n-  \/\/  Combination not supported\n+  virtual void reserve(int new_capacity) override final {\n+    _array->reserve(new_capacity);\n+  }\n@@ -497,6 +687,2 @@\n-  \/\/ Stack\/Resource allocated\n-  {\n-    ResourceMark rm;\n-    GrowableArray<int> a(0);\n-    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n-    ASSERT_TRUE(elements_on_resource_area(&a));\n+  virtual void shrink_to_fit() override final {\n+    _array->shrink_to_fit();\n@@ -505,5 +691,2 @@\n-  \/\/ Stack\/CHeap allocated\n-  {\n-    GrowableArray<int> a(0, mtTest);\n-    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n-    ASSERT_TRUE(elements_on_C_heap(&a));\n+  virtual void clear_and_deallocate() override final {\n+    _array->clear_and_deallocate();\n@@ -512,6 +695,2 @@\n-  \/\/ Stack\/Arena allocated\n-  {\n-    Arena arena(mtTest);\n-    GrowableArray<int> a(&arena, 0, 0, 0);\n-    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n-    ASSERT_TRUE(elements_on_arena(&a));\n+  virtual E at_grow(int i, const E& fill) override final {\n+    return _array->at_grow(i, fill);\n@@ -520,6 +699,5 @@\n-  \/\/ Embedded\/Resource allocated\n-  {\n-    ResourceMark rm;\n-    WithEmbeddedArray w(0);\n-    ASSERT_TRUE(w._a.allocated_on_stack_or_embedded());\n-    ASSERT_TRUE(elements_on_resource_area(&w._a));\n+  \/\/ The implementation of at_put_grow uses assignment. We should\n+  \/\/ only instantiate a call to it if assignment is allowed.\n+  \/\/ I have to do this workaround because the method is virtual.\n+  virtual void at_put_grow (int i, const E& e, const E& fill) override final {\n+    at_put_grow_impl<E>(i, e, fill);\n@@ -528,5 +706,3 @@\n-  \/\/ Embedded\/CHeap allocated\n-  {\n-    WithEmbeddedArray w(0, mtTest);\n-    ASSERT_TRUE(w._a.allocated_on_stack_or_embedded());\n-    ASSERT_TRUE(elements_on_C_heap(&w._a));\n+  template<typename E2, ENABLE_IF(std::is_copy_assignable<E2>::value)>\n+  void at_put_grow_impl(int i, const E& e, const E& fill) {\n+    _array->at_put_grow(i, e, fill);\n@@ -535,6 +711,4 @@\n-  \/\/ Embedded\/Arena allocated\n-  {\n-    Arena arena(mtTest);\n-    WithEmbeddedArray w(&arena, 0);\n-    ASSERT_TRUE(w._a.allocated_on_stack_or_embedded());\n-    ASSERT_TRUE(elements_on_arena(&w._a));\n+  template<typename E2, ENABLE_IF(!std::is_copy_assignable<E2>::value)>\n+  void at_put_grow_impl(int i, const E& e, const E& fill) {\n+    \/\/ do not call if copy-assign not implemented for elements\n+    ASSERT_TRUE(false);\n@@ -542,1 +716,0 @@\n-}\n@@ -544,6 +717,7 @@\n-TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, copy_with_embedded_cheap,\n-    \"assert.!on_C_heap... failed: Copying of CHeap arrays not supported\") {\n-  WithEmbeddedArray s(1, mtTest);\n-  \/\/ Intentionally asserts that copy of CHeap arrays are not allowed\n-  WithEmbeddedArray c(s);\n-}\n+  virtual void insert_before(int idx, const E& e) override final{\n+    _array->insert_before(idx, e);\n+  }\n+\n+  virtual void insert_before(int idx, const GrowableArrayView<E>* array) override final {\n+    _array->insert_before(idx, array);\n+  }\n@@ -551,4 +725,9 @@\n-TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, assignment_with_embedded_cheap,\n-    \"assert.!on_C_heap... failed: Assignment of CHeap arrays not supported\") {\n-  WithEmbeddedArray s(1, mtTest);\n-  WithEmbeddedArray c(1, mtTest);\n+  virtual void appendAll(const GrowableArrayView<E>* array) override final {\n+    _array->appendAll(array);\n+  }\n+\n+  virtual E insert_sorted(const E& e) override final {\n+    \/\/ virtual function cannot have template, so we just fill in the template here\n+    return _array->template insert_sorted<value_compare_ref<E>>(e);\n+  }\n+};\n@@ -556,2 +735,18 @@\n-  \/\/ Intentionally asserts that assignment of CHeap arrays are not allowed\n-  c = s;\n+template<typename E>\n+class EmbeddedGrowableArrayCHeap {\n+private:\n+  GrowableArrayCHeap<E, mtTest> _array;\n+public:\n+  explicit EmbeddedGrowableArrayCHeap(int cap) : _array(cap) {}\n+  EmbeddedGrowableArrayCHeap(int cap, int len, const E& filler) : _array(cap, len, filler) {}\n+  GrowableArrayCHeap<E, mtTest>* array() { return &_array; }\n+};\n+\n+#undef CASE\n+#define CASE(args, init) {                       \\\n+  case args:                                     \\\n+  {                                              \\\n+    GrowableArrayCHeap<E, mtTest> array(init);   \\\n+    dispatch_impl_helper(modify, test, &array, args); \\\n+    break;                                       \\\n+  }                                              \\\n@@ -560,1 +755,7 @@\n-#endif\n+template<typename E>\n+class AllocatorClosureStackCHeap : public AllocatorClosureGrowableArrayCHeap<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ destructor called implicitly, and it first destructs all elements.\n+  };\n@@ -562,4 +763,1 @@\n-TEST(GrowableArrayCHeap, sanity) {\n-  \/\/ Stack\/CHeap\n-  {\n-    GrowableArrayCHeap<int, mtTest> a(0);\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArrayCHeap<E,mtTest>* array, AllocatorArgs args) {\n@@ -567,1 +765,1 @@\n-    ASSERT_TRUE(a.allocated_on_stack_or_embedded());\n+    ASSERT_TRUE(array->allocated_on_stack_or_embedded()); \/\/ itself: stack\n@@ -569,5 +767,2 @@\n-    ASSERT_TRUE(a.is_empty());\n-\n-    a.append(1);\n-    ASSERT_FALSE(a.is_empty());\n-    ASSERT_EQ(a.at(0), 1);\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n@@ -575,0 +770,1 @@\n+};\n@@ -576,7 +772,10 @@\n-  \/\/ CHeap\/CHeap\n-  {\n-    GrowableArrayCHeap<int, mtTest>* a = new GrowableArrayCHeap<int, mtTest>(0);\n-#ifdef ASSERT\n-    ASSERT_TRUE(a->allocated_on_C_heap());\n-#endif\n-    ASSERT_TRUE(a->is_empty());\n+#undef CASE\n+#define CASE(args, init) {                        \\\n+  case args:                                      \\\n+  {                                               \\\n+    EmbeddedGrowableArrayCHeap<E> embedded(init); \\\n+    GrowableArrayCHeap<E, mtTest>* array = embedded.array(); \\\n+    dispatch_impl_helper(modify, test, array, args); \\\n+    break;                                        \\\n+  }                                               \\\n+}\n@@ -584,5 +783,7 @@\n-    a->append(1);\n-    ASSERT_FALSE(a->is_empty());\n-    ASSERT_EQ(a->at(0), 1);\n-    delete a;\n-  }\n+template<typename E>\n+class AllocatorClosureEmbeddedCHeap : public AllocatorClosureGrowableArrayCHeap<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ destructor called implicitly, and it first destructs all elements.\n+  };\n@@ -590,3 +791,1 @@\n-  \/\/ CHeap\/CHeap - nothrow new operator\n-  {\n-    GrowableArrayCHeap<int, mtTest>* a = new (std::nothrow) GrowableArrayCHeap<int, mtTest>(0);\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArrayCHeap<E,mtTest>* array, AllocatorArgs args) {\n@@ -594,1 +793,1 @@\n-    ASSERT_TRUE(a->allocated_on_C_heap());\n+    ASSERT_TRUE(array->allocated_on_stack_or_embedded()); \/\/ itself: embedded\n@@ -596,6 +795,2 @@\n-    ASSERT_TRUE(a->is_empty());\n-\n-    a->append(1);\n-    ASSERT_FALSE(a->is_empty());\n-    ASSERT_EQ(a->at(0), 1);\n-    delete a;\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n@@ -603,0 +798,11 @@\n+};\n+\n+#undef CASE\n+#define CASE(args, init) {                       \\\n+  case args:                                     \\\n+  {                                              \\\n+    GrowableArrayCHeap<E, mtTest>* array = new GrowableArrayCHeap<E, mtTest>(init); \\\n+    dispatch_impl_helper(modify, test, array, args); \\\n+    delete array;                                \\\n+    break;                                       \\\n+  }                                              \\\n@@ -605,3 +811,6 @@\n-TEST(GrowableArrayCHeap, find_if) {\n-  struct Element {\n-    int value;\n+template<typename E>\n+class AllocatorClosureCHeapCHeap : public AllocatorClosureGrowableArrayCHeap<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ destruction explicit, recursively destructs all elements\n@@ -609,11 +818,0 @@\n-  GrowableArrayCHeap<Element, mtTest> array;\n-  array.push({1});\n-  array.push({2});\n-  array.push({3});\n-\n-  {\n-    int index = array.find_if([&](const Element& elem) {\n-      return elem.value == 1;\n-    });\n-    ASSERT_EQ(index, 0);\n-  }\n@@ -621,5 +819,6 @@\n-  {\n-    int index = array.find_if([&](const Element& elem) {\n-      return elem.value > 1;\n-    });\n-    ASSERT_EQ(index, 1);\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArrayCHeap<E,mtTest>* array, AllocatorArgs args) {\n+#ifdef ASSERT\n+    ASSERT_TRUE(array->allocated_on_C_heap()); \/\/ itself: cheap\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n@@ -627,0 +826,1 @@\n+};\n@@ -628,6 +828,9 @@\n-  {\n-    int index = array.find_if([&](const Element& elem) {\n-      return elem.value == 4;\n-    });\n-    ASSERT_EQ(index, -1);\n-  }\n+#undef CASE\n+#define CASE(args, init) {                       \\\n+  case args:                                     \\\n+  {                                              \\\n+    GrowableArrayCHeap<E, mtTest>* array = new (std::nothrow) GrowableArrayCHeap<E, mtTest>(init); \\\n+    dispatch_impl_helper(modify, test, array, args);   \\\n+    delete array;                                \\\n+    break;                                       \\\n+  }                                              \\\n@@ -636,3 +839,6 @@\n-TEST(GrowableArrayCHeap, find_from_end_if) {\n-  struct Element {\n-    int value;\n+template<typename E>\n+class AllocatorClosureCHeapCHeapNoThrow : public AllocatorClosureGrowableArrayCHeap<E> {\n+public:\n+  virtual void dispatch_impl(ModifyClosure<E>* modify, TestClosure<E>* test, AllocatorArgs args) override final {\n+    ARGS_CASES(CASE)\n+    \/\/ destruction explicit, recursively destructs all elements\n@@ -640,4 +846,0 @@\n-  GrowableArrayCHeap<Element, mtTest> array;\n-  array.push({1});\n-  array.push({2});\n-  array.push({3});\n@@ -645,5 +847,6 @@\n-  {\n-    int index = array.find_from_end_if([&](const Element& elem) {\n-      return elem.value == 1;\n-    });\n-    ASSERT_EQ(index, 0);\n+  void dispatch_impl_helper(ModifyClosure<E>* modify, TestClosure<E>* test, GrowableArrayCHeap<E,mtTest>* array, AllocatorArgs args) {\n+#ifdef ASSERT\n+    ASSERT_TRUE(array->allocated_on_C_heap()); \/\/ itself: cheap\n+#endif\n+    this->set_array(array);\n+    this->dispatch_inner(modify, test, args);\n@@ -651,0 +854,1 @@\n+};\n@@ -652,5 +856,62 @@\n-  {\n-    int index = array.find_from_end_if([&](const Element& elem) {\n-      return elem.value > 1;\n-    });\n-    ASSERT_EQ(index, 2);\n+\/\/ ------------ ModifyClosures ------------\n+\n+template<typename E>\n+class ModifyClosureEmpty : public ModifyClosure<E> {\n+public:\n+  virtual void do_modify(AllocatorClosure<E>* a, AllocatorArgs args) override final {\n+    \/\/ array is freshly initialized. Verify initialization:\n+    switch(args) {\n+      case CAP2:\n+      {\n+        ASSERT_TRUE(a->is_empty());\n+        ASSERT_EQ(a->length(), 0);\n+        ASSERT_EQ(a->capacity(), 2);\n+        check_constructor_count_for_type<E>(0);\n+        break;\n+      }\n+      case CAP0:\n+      {\n+        ASSERT_TRUE(a->is_empty());\n+        ASSERT_EQ(a->length(), 0);\n+        ASSERT_EQ(a->capacity(), 0);\n+        check_constructor_count_for_type<E>(0);\n+        break;\n+      }\n+      case CAP100:\n+      {\n+        ASSERT_TRUE(a->is_empty());\n+        ASSERT_EQ(a->length(), 0);\n+        ASSERT_EQ(a->capacity(), 100);\n+        check_constructor_count_for_type<E>(0);\n+        break;\n+      }\n+      case CAP100LEN100:\n+      {\n+        ASSERT_TRUE(!a->is_empty());\n+        ASSERT_EQ(a->length(), 100);\n+        ASSERT_EQ(a->capacity(), 100);\n+        check_alive_elements_for_type<E>(100);\n+        \/\/ Check elements\n+        for (int i = 0; i < 100; i++) {\n+          EXPECT_EQ(a->at(i), value_factory<E>(-42));\n+        }\n+        break;\n+      }\n+      case CAP200LEN50:\n+      {\n+        ASSERT_TRUE(!a->is_empty());\n+        ASSERT_EQ(a->length(), 50);\n+        ASSERT_EQ(a->capacity(), 200);\n+        check_alive_elements_for_type<E>(50);\n+        \/\/ Check elements\n+        for (int i = 0; i < 50; i++) {\n+          EXPECT_EQ(a->at(i), value_factory<E>(-42));\n+        }\n+        break;\n+      }\n+      default:\n+      {\n+        ASSERT_TRUE(false);\n+        break;\n+      }\n+    }\n@@ -658,0 +919,1 @@\n+};\n@@ -659,5 +921,1408 @@\n-  {\n-    int index = array.find_from_end_if([&](const Element& elem) {\n-      return elem.value == 4;\n-    });\n-    ASSERT_EQ(index, -1);\n+template<typename E>\n+class ModifyClosureAppend : public ModifyClosure<E> {\n+public:\n+  virtual void do_modify(AllocatorClosure<E>* a, AllocatorArgs args) override final {\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Test append\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(i * 100));\n+    }\n+    ASSERT_FALSE(a->is_empty());\n+\n+    ASSERT_EQ(a->length(), 1000);\n+    check_alive_elements_for_type<E>(1000);\n+\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i * 100));\n+    }\n+\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Test push\n+    for (int i = 0; i < 1000; i++) {\n+      a->push(value_factory<E>(i * 100));\n+    }\n+\n+    ASSERT_EQ(a->length(), 1000);\n+    check_alive_elements_for_type<E>(1000);\n+\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i * 100));\n+    }\n+\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Test append_if_missing\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_TRUE(a->append_if_missing(value_factory<E>(i * 3)));\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->append_if_missing(value_factory<E>(i)), i % 3 != 0);\n+    }\n+    check_alive_elements_for_type<E>(1666);\n+\n+    int j = 0;\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i * 3));\n+      if (i % 3 != 0) {\n+        ASSERT_EQ(a->at(1000 + j), value_factory<E>(i));\n+        j++;\n+      }\n+    }\n+\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Test insert_before, single element\n+    a->insert_before(0, value_factory<E>(3));\n+    a->insert_before(1, value_factory<E>(5));\n+    a->insert_before(0, value_factory<E>(0));\n+    a->insert_before(1, value_factory<E>(1));\n+    a->insert_before(2, value_factory<E>(2));\n+    a->insert_before(4, value_factory<E>(4));\n+\n+    for (int i = 0; i < 6; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+    ASSERT_EQ(a->length(), 6);\n+    check_alive_elements_for_type<E>(6);\n+\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Test insert_before, with array\n+    GrowableArrayCHeap<E,mtTest> array;\n+\n+    for (int i = 0; i < 100; i++) {\n+      array.append(value_factory<E>(i));\n+    }\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(array.length(), 100);\n+    check_alive_elements_for_type<E>(100);\n+\n+    a->insert_before(0, &array);\n+\n+    ASSERT_EQ(a->length(), 100);\n+    ASSERT_EQ(array.length(), 100);\n+    check_alive_elements_for_type<E>(200);\n+\n+    array.clear();\n+    check_alive_elements_for_type<E>(100);\n+\n+    array.append(value_factory<E>(42));\n+    array.append(value_factory<E>(42));\n+\n+    a->insert_before(100, &array);\n+    a->insert_before(0, &array);\n+\n+    ASSERT_EQ(a->at(0), value_factory<E>(42));\n+    ASSERT_EQ(a->at(1), value_factory<E>(42));\n+    for (int i = 0; i < 100; i++) {\n+      ASSERT_EQ(a->at(i + 2), value_factory<E>(i));\n+    }\n+    ASSERT_EQ(a->at(102), value_factory<E>(42));\n+    ASSERT_EQ(a->at(103), value_factory<E>(42));\n+\n+    a->clear();\n+\n+    for (int i = 0; i < 10; i++) {\n+      array.clear();\n+      for (int j = 0; j < 10; j++) {\n+        array.append(value_factory<E>(i*10 + j));\n+      }\n+      a->appendAll(&array);\n+    }\n+    array.clear();\n+\n+    for (int i = 0; i < 100; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+    ASSERT_EQ(a->length(), 100);\n+    ASSERT_EQ(array.length(), 0);\n+    check_alive_elements_for_type<E>(100);\n+  }\n+};\n+\n+template<typename E>\n+class ModifyClosureClear : public ModifyClosure<E> {\n+public:\n+  virtual void do_modify(AllocatorClosure<E>* a, AllocatorArgs args) override final {\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(i * 100));\n+    }\n+\n+    ASSERT_EQ(a->length(), 1000);\n+    check_alive_elements_for_type<E>(1000);\n+\n+    int old_capacity = a->capacity();\n+\n+    \/\/ Clear\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->capacity(), old_capacity);\n+  }\n+};\n+\n+template<typename E>\n+class ModifyClosureClearAndDeallocate : public ModifyClosure<E> {\n+public:\n+  virtual void do_modify(AllocatorClosure<E>* a, AllocatorArgs args) override final {\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(i * 100));\n+    }\n+\n+    ASSERT_EQ(a->length(), 1000);\n+    check_alive_elements_for_type<E>(1000);\n+\n+    \/\/ Clear\n+    if (a->is_C_heap()) {\n+      a->clear_and_deallocate();\n+      ASSERT_EQ(a->capacity(), 0);\n+    } else {\n+      a->clear();\n+    }\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+  }\n+};\n+\n+template<typename E>\n+class ModifyClosureAccess : public ModifyClosure<E> {\n+public:\n+  virtual void do_modify(AllocatorClosure<E>* a, AllocatorArgs args) override final {\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ write\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(3*i));\n+    }\n+    ASSERT_EQ(a->length(), 1000);\n+    check_alive_elements_for_type<E>(1000);\n+\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(3*i));\n+      ASSERT_EQ(*a->adr_at(i), value_factory<E>(3*i));\n+    }\n+\n+    for (int i = 0; i < 1000; i++) {\n+      if (i % 3 == 0) {\n+        ASSERT_TRUE(a->contains(value_factory<E>(i)));\n+        ASSERT_EQ(a->find(value_factory<E>(i)), i\/3);\n+        ASSERT_EQ(a->find_from_end(value_factory<E>(i)), i\/3);\n+      } else {\n+        ASSERT_FALSE(a->contains(value_factory<E>(i)));\n+        ASSERT_EQ(a->find(value_factory<E>(i)), -1);\n+        ASSERT_EQ(a->find_from_end(value_factory<E>(i)), -1);\n+      }\n+    }\n+\n+    a->append(value_factory<E>(7));\n+    a->append(value_factory<E>(31));\n+    a->append(value_factory<E>(7));\n+\n+    ASSERT_EQ(a->find(value_factory<E>(7)), 1000);\n+    ASSERT_EQ(a->find_from_end(value_factory<E>(7)), 1002);\n+\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ write\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+\n+    \/\/ remove all even numbers:\n+    for (int i = 0; i < 500; i++) {\n+      a->remove(value_factory<E>(2*i));\n+      check_alive_elements_for_type<E>(1000 - i - 1);\n+      ASSERT_EQ(a->length(), 1000 - i - 1);\n+    }\n+\n+    \/\/ remove rest:\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->remove_if_existing(value_factory<E>(i)), i % 2 == 1);\n+      ASSERT_EQ(a->length(), 500 - (i+1)\/2);\n+    }\n+    ASSERT_TRUE(a->is_empty());\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ write\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+\n+    \/\/ Test remove_range\n+    for (int i = 0; i < 10; i++) {\n+      ASSERT_EQ(a->length(), 1000 - i*50);\n+      check_alive_elements_for_type<E>(1000 - i*50);\n+      int start = i * 50 + 50;\n+      a->remove_range(start, start + 50);\n+    }\n+    check_alive_elements_for_type<E>(500);\n+    ASSERT_EQ(a->length(), 500);\n+\n+    for (int i = 0; i < 10; i++) {\n+      for (int j = 0; j < 50; j++) {\n+        ASSERT_EQ(a->at(i * 50 + j), value_factory<E>(i * 100 + j));\n+      }\n+    }\n+\n+    \/\/ Test remove_till\n+    for (int i = 0; i < 10; i++) {\n+      check_alive_elements_for_type<E>(500 - i*50);\n+      ASSERT_EQ(a->length(), 500 - i*50);\n+      a->remove_till(50);\n+      if (i < 9) {\n+        ASSERT_EQ(a->at(0), value_factory<E>(i*100+100));\n+      }\n+    }\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ write\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+    ASSERT_EQ(a->length(), 1000);\n+    check_alive_elements_for_type<E>(1000);\n+\n+    for (int i = 0; i < 100; i++) {\n+      a->delete_at(100 + i);\n+    }\n+    ASSERT_EQ(a->length(), 900);\n+    check_alive_elements_for_type<E>(900);\n+\n+    for (int i = 0; i < 100; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+    for (int i = 0; i < 100; i++) {\n+      ASSERT_EQ(a->at(100 + i), value_factory<E>(999 - i));\n+    }\n+    for (int i = 200; i < 900; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+  }\n+};\n+\n+\/\/ ------------ TestClosures ------------\n+\n+template<typename E>\n+class TestClosureAppend : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 10; i++) {\n+      a->append(value_factory<E>(i));\n+      EXPECT_EQ(a->top(), value_factory<E>(i));\n+      EXPECT_EQ(a->last(), value_factory<E>(i));\n+      EXPECT_EQ(a->first(), value_factory<E>(0));\n+      EXPECT_EQ(a->at(i), value_factory<E>(i));\n+      EXPECT_EQ(*a->adr_at(i), value_factory<E>(i));\n+    }\n+\n+    \/\/ Check size\n+    ASSERT_EQ(a->length(), 10);\n+    check_alive_elements_for_type<E>(10);\n+\n+    \/\/ Check elements\n+    for (int i = 0; i < 10; i++) {\n+      EXPECT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureAssign : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    a->at_grow(999, value_factory<E>(-1));\n+    ASSERT_EQ(a->length(), 1000);\n+    check_alive_elements_for_type<E>(1000);\n+\n+    \/\/ write over at\n+    for (int i = 0; i < 1000; i++) {\n+      a->at(i) = value_factory<E>(i);\n+    }\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+      ASSERT_EQ(*a->adr_at(i), value_factory<E>(i));\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+\n+    \/\/ write over adr_at\n+    for (int i = 0; i < 1000; i++) {\n+      *a->adr_at(i) = value_factory<E>(2*i);\n+    }\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(2*i));\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+\n+    \/\/ write\n+    for (int i = 0; i < 1000; i++) {\n+      a->at_put(i, value_factory<E>(3*i));\n+    }\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(3*i));\n+      ASSERT_EQ(*a->adr_at(i), value_factory<E>(3*i));\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+\n+    \/\/ all zero\n+    for (int i = 0; i < 1000; i++) {\n+      a->at_put(i, value_factory<E>(0));\n+    }\n+    a->at_put(42,  value_factory<E>(1));\n+    a->at_put(666, value_factory<E>(2));\n+\n+    for (int i = 0; i < 1000; i++) {\n+      if (i == 42) {\n+        ASSERT_EQ(a->at(i), value_factory<E>(1));\n+      } else if (i == 666) {\n+        ASSERT_EQ(a->at(i), value_factory<E>(2));\n+      } else {\n+        ASSERT_EQ(a->at(i), value_factory<E>(0));\n+      }\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+\n+    a->at_swap(42, 666);\n+\n+    for (int i = 0; i < 1000; i++) {\n+      if (i == 42) {\n+        ASSERT_EQ(a->at(i), value_factory<E>(2));\n+      } else if (i == 666) {\n+        ASSERT_EQ(a->at(i), value_factory<E>(1));\n+      } else {\n+        ASSERT_EQ(a->at(i), value_factory<E>(0));\n+      }\n+    }\n+    check_alive_elements_for_type<E>(1000);\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureClear : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Check size\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->is_empty(), true);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 10; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+\n+    \/\/ Check size\n+    ASSERT_EQ(a->length(), 10);\n+    ASSERT_EQ(a->is_empty(), false);\n+    check_alive_elements_for_type<E>(10);\n+\n+    \/\/ Clear elements\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Check size\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->is_empty(), true);\n+\n+    \/\/ Add element\n+    a->append(value_factory<E>(11));\n+\n+    \/\/ Check size\n+    ASSERT_EQ(a->length(), 1);\n+    ASSERT_EQ(a->is_empty(), false);\n+    check_alive_elements_for_type<E>(1);\n+\n+    \/\/ Clear elements\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Check size\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->is_empty(), true);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 100; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+    ASSERT_EQ(a->length(), 100);\n+    check_alive_elements_for_type<E>(100);\n+\n+    int old_capacity = a->capacity();\n+    a->trunc_to(50);\n+    ASSERT_EQ(a->length(), 50);\n+    ASSERT_EQ(a->capacity(), old_capacity);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 50; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureIterator : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 10; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+    check_alive_elements_for_type<E>(10);\n+\n+    \/\/ Iterate\n+    int counter = 0;\n+    for (GrowableArrayIterator<E> i = a->begin(); i != a->end(); ++i) {\n+      ASSERT_EQ(*i, value_factory<E>(counter++));\n+    }\n+\n+    \/\/ Check count\n+    ASSERT_EQ(counter, 10);\n+    check_alive_elements_for_type<E>(10);\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureCapacity : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+\n+    int old_capacity = a->capacity();\n+    ASSERT_EQ(a->length(), 0);\n+    a->reserve(50);\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(a->capacity(), MAX2(50, old_capacity));\n+    check_alive_elements_for_type<E>(0);\n+\n+    for (int i = 0; i < 50; ++i) {\n+      a->append(value_factory<E>(i));\n+    }\n+    ASSERT_EQ(a->length(), 50);\n+    ASSERT_EQ(a->capacity(), MAX2(50, old_capacity));\n+    check_alive_elements_for_type<E>(50);\n+\n+    a->append(value_factory<E>(50));\n+    ASSERT_EQ(a->length(), 51);\n+    check_alive_elements_for_type<E>(51);\n+\n+    int capacity = a->capacity();\n+    ASSERT_GE(capacity, 51);\n+    for (int i = 0; i < 30; ++i) {\n+      a->pop();\n+    }\n+    ASSERT_EQ(a->length(), 21);\n+    ASSERT_EQ(a->capacity(), capacity);\n+    check_alive_elements_for_type<E>(21);\n+\n+    if (a->is_C_heap()) {\n+      \/\/ shrink_to_fit only implemented on CHeap\n+      a->shrink_to_fit();\n+      ASSERT_EQ(a->length(), 21);\n+      ASSERT_EQ(a->capacity(), 21);\n+      check_alive_elements_for_type<E>(21);\n+\n+      a->reserve(50);\n+      ASSERT_EQ(a->length(), 21);\n+      ASSERT_EQ(a->capacity(), 50);\n+      check_alive_elements_for_type<E>(21);\n+\n+      a->clear();\n+      ASSERT_EQ(a->length(), 0);\n+      ASSERT_EQ(a->capacity(), 50);\n+      check_alive_elements_for_type<E>(0);\n+\n+      a->shrink_to_fit();\n+      ASSERT_EQ(a->length(), 0);\n+      ASSERT_EQ(a->capacity(), 0);\n+      check_alive_elements_for_type<E>(0);\n+    }\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureCompare : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    GrowableArrayCHeap<E,mtTest> array;\n+    check_alive_elements_for_type<E>(0);\n+\n+    ASSERT_TRUE(a->view() == array);\n+    ASSERT_FALSE(a->view() != array);\n+\n+    for (int i = 0; i < 100; i++) {\n+      array.append(value_factory<E>(i));\n+    }\n+\n+    ASSERT_EQ(a->length(), 0);\n+    ASSERT_EQ(array.length(), 100);\n+    check_alive_elements_for_type<E>(100);\n+\n+    ASSERT_FALSE(a->view() == array);\n+    ASSERT_TRUE(a->view() != array);\n+\n+    for (int i = 0; i < 100; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+\n+    ASSERT_EQ(a->length(), 100);\n+    ASSERT_EQ(array.length(), 100);\n+    check_alive_elements_for_type<E>(200);\n+\n+    ASSERT_TRUE(a->view() == array);\n+    ASSERT_FALSE(a->view() != array);\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureFindIf : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    ASSERT_EQ(a->length(), 0);\n+    check_alive_elements_for_type<E>(0);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 10; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+    a->append(value_factory<E>(20));\n+    a->append(value_factory<E>(20));\n+    a->append(value_factory<E>(42));\n+    check_alive_elements_for_type<E>(13);\n+\n+    for (int i = 0; i < 10; i++) {\n+      int index = a->find_if([&](const E& elem) {\n+        return elem == value_factory<E>(i);\n+      });\n+      ASSERT_EQ(index, i);\n+    }\n+\n+    {\n+      int index = a->find_if([&](const E& elem) {\n+        return elem == value_factory<E>(20);\n+      });\n+      ASSERT_EQ(index, 10);\n+    }\n+\n+    {\n+      int index = a->find_if([&](const E& elem) {\n+        return elem == value_factory<E>(100);\n+      });\n+      ASSERT_EQ(index, -1);\n+    }\n+\n+    {\n+      int index = a->find_if([&](const E& elem) {\n+        return elem == value_factory<E>(-100);\n+      });\n+      ASSERT_EQ(index, -1);\n+    }\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureFindFromEndIf : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Add elements\n+    for (int i = 0; i < 10; i++) {\n+      a->append(value_factory<E>(i));\n+    }\n+    a->append(value_factory<E>(20));\n+    a->append(value_factory<E>(20));\n+    a->append(value_factory<E>(42));\n+    check_alive_elements_for_type<E>(13);\n+\n+    for (int i = 0; i < 10; i++) {\n+      int index = a->find_from_end_if([&](const E& elem) {\n+        return elem == value_factory<E>(i);\n+      });\n+      ASSERT_EQ(index, i);\n+    }\n+\n+    {\n+      int index = a->find_from_end_if([&](const E& elem) {\n+        return elem == value_factory<E>(20);\n+      });\n+      ASSERT_EQ(index, 11);\n+    }\n+\n+    {\n+      int index = a->find_from_end_if([&](const E& elem) {\n+        return elem == value_factory<E>(100);\n+      });\n+      ASSERT_EQ(index, -1);\n+    }\n+\n+    {\n+      int index = a->find_from_end_if([&](const E& elem) {\n+        return elem == value_factory<E>(-100);\n+      });\n+      ASSERT_EQ(index, -1);\n+    }\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureAtGrow : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    a->reserve(100);\n+\n+    for (int j = 1; j < 100; j++) {\n+      int new_len = j * 7;\n+      a->at_grow(new_len - 1, value_factory<E>(j));\n+      ASSERT_EQ(a->length(), new_len);\n+      check_alive_elements_for_type<E>(new_len);\n+\n+      \/\/ Check elements\n+      for (int k = 0; k < new_len; k++) {\n+        EXPECT_EQ(a->at_grow(k, value_factory<E>(-1)), value_factory<E>(k \/ 7 + 1));\n+      }\n+      ASSERT_EQ(a->length(), new_len);\n+    }\n+\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    int old_capacity = a->capacity();\n+    a->at_grow(old_capacity - 1, value_factory<E>(0));\n+    ASSERT_EQ(a->length(), old_capacity);\n+    ASSERT_EQ(a->capacity(), old_capacity);\n+    check_alive_elements_for_type<E>(old_capacity);\n+\n+    for (int j = 1; j < 100; j++) {\n+      int target = j * 31;\n+      a->at_put_grow(target, value_factory<E>(target), value_factory<E>(-2));\n+      int new_length = MAX2(target + 1, old_capacity);\n+      ASSERT_EQ(a->length(), new_length);\n+\n+      \/\/ Check elements\n+      for (int k = 0; k < new_length; k++) {\n+        if (k != 0 && (k % 31) == 0 && k <= target) {\n+          EXPECT_EQ(a->at(k), value_factory<E>(k));\n+        } else if (k < old_capacity) {\n+          EXPECT_EQ(a->at(k), value_factory<E>(0));\n+        } else {\n+          EXPECT_EQ(a->at(k), value_factory<E>(-2));\n+        }\n+      }\n+    }\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureAtGrowDefault : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    a->reserve(100);\n+\n+    for (int j = 1; j < 100; j++) {\n+      int new_len = j * 7;\n+      a->at_grow(new_len - 1, E()); \/\/ simulate default argument\n+      ASSERT_EQ(a->length(), new_len);\n+      check_alive_elements_for_type<E>(new_len);\n+\n+      \/\/ Check elements\n+      for (int k = 0; k < new_len; k++) {\n+        EXPECT_EQ(a->at_grow(k, value_factory<E>(-1)), E());\n+      }\n+      ASSERT_EQ(a->length(), new_len);\n+    }\n+\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    int old_capacity = a->capacity();\n+    a->at_grow(old_capacity - 1, value_factory<E>(-3));\n+    ASSERT_EQ(a->length(), old_capacity);\n+    ASSERT_EQ(a->capacity(), old_capacity);\n+    check_alive_elements_for_type<E>(old_capacity);\n+\n+    for (int j = 1; j < 100; j++) {\n+      int target = j * 31;\n+      a->at_put_grow(target, value_factory<E>(target), E()); \/\/ simulate default argument\n+      int new_length = MAX2(target + 1, old_capacity);\n+      ASSERT_EQ(a->length(), new_length);\n+\n+      \/\/ Check elements\n+      for (int k = 0; k < new_length; k++) {\n+        if (k != 0 && (k % 31) == 0 && k <= target) {\n+          EXPECT_EQ(a->at(k), value_factory<E>(k));\n+        } else if (k < old_capacity) {\n+          EXPECT_EQ(a->at(k), value_factory<E>(-3));\n+        } else {\n+          EXPECT_EQ(a->at(k), E());\n+        }\n+      }\n+    }\n+  };\n+};\n+\n+template<typename E>\n+class TestClosureSort : public TestClosure<E> {\n+  virtual void do_test(AllocatorClosure<E>* a) override final {\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Test sort\n+    for (int i = 0; i < 997; i++) {\n+      a->append(value_factory<E>((i * 31) % 997));\n+    }\n+    check_alive_elements_for_type<E>(997);\n+    ASSERT_EQ(a->length(), 997);\n+\n+    a->view().sort(value_compare_ptr<E>);\n+\n+    check_alive_elements_for_type<E>(997);\n+    ASSERT_EQ(a->length(), 997);\n+    for (int i = 0; i < 977; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Test sort, strided\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(-i));\n+      a->append(value_factory<E>(i));\n+      a->append(value_factory<E>(-i));\n+    }\n+    check_alive_elements_for_type<E>(3000);\n+    ASSERT_EQ(a->length(), 3000);\n+\n+    a->view().sort(value_compare_ptr<E>, 3);\n+\n+    check_alive_elements_for_type<E>(3000);\n+    ASSERT_EQ(a->length(), 3000);\n+    for (int i = 0; i < 1000; i++) {\n+      ASSERT_EQ(a->at(3 * i + 0), value_factory<E>(-999 + i));\n+      ASSERT_EQ(a->at(3 * i + 1), value_factory<E>(999 - i));\n+      ASSERT_EQ(a->at(3 * i + 2), value_factory<E>(-999 + i));\n+    }\n+\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Test find_sorted\n+    for (int i = 0; i < 1000; i++) {\n+      a->append(value_factory<E>(7 * i));\n+    }\n+\n+    for (int i = 0; i < 1000; i++) {\n+      bool found = (i % 2 == 0); \/\/ init random\n+      int j = a->view().template find_sorted<E,value_compare_ref<E>>(value_factory<E>(i), found);\n+      if (i % 7 == 0) {\n+        ASSERT_TRUE(found);\n+        ASSERT_EQ(j, i \/ 7);\n+      } else {\n+        ASSERT_FALSE(found);\n+      }\n+    }\n+\n+    a->clear();\n+    check_alive_elements_for_type<E>(0);\n+    ASSERT_EQ(a->length(), 0);\n+\n+    \/\/ Test insert_sorted\n+    for (int i = 0; i < 997; i++) {\n+      a->insert_sorted(value_factory<E>((i * 31) % 997));\n+    }\n+\n+    check_alive_elements_for_type<E>(997);\n+    ASSERT_EQ(a->length(), 997);\n+    for (int i = 0; i < 977; i++) {\n+      ASSERT_EQ(a->at(i), value_factory<E>(i));\n+    }\n+  };\n+};\n+\n+\/\/ Test fixture to work with TEST_VM_F\n+class GrowableArrayTest : public ::testing::Test {\n+protected:\n+  template<typename E, bool do_arena, ENABLE_IF(do_arena)>\n+  static void run_test_modify_allocate_arena(TestClosure<E>* test, ModifyClosure<E>* modify, AllocatorArgs args) {\n+    AllocatorClosureStackResourceArea<E> allocator_s_r;\n+    allocator_s_r.dispatch(modify, test, args);\n+\n+    AllocatorClosureEmbeddedResourceArea<E> allocator_e_r;\n+    allocator_e_r.dispatch(modify, test, args);\n+\n+    AllocatorClosureResourceAreaResourceArea<E> allocator_r_r;\n+    allocator_r_r.dispatch(modify, test, args);\n+\n+    AllocatorClosureStackArena<E> allocator_s_a;\n+    allocator_s_a.dispatch(modify, test, args);\n+\n+    AllocatorClosureEmbeddedArena<E> allocator_e_a;\n+    allocator_e_a.dispatch(modify, test, args);\n+\n+    AllocatorClosureArenaArena<E> allocator_a_a;\n+    allocator_a_a.dispatch(modify, test, args);\n+  }\n+\n+  template<typename E, bool do_arena, ENABLE_IF(!do_arena)>\n+  static void run_test_modify_allocate_arena(TestClosure<E>* test, ModifyClosure<E>* modify, AllocatorArgs args) {\n+    \/\/ not enabled\n+  }\n+\n+  template<typename E, bool do_cheap, ENABLE_IF(do_cheap)>\n+  static void run_test_modify_allocate_cheap(TestClosure<E>* test, ModifyClosure<E>* modify, AllocatorArgs args) {\n+    AllocatorClosureStackCHeap<E> allocator_s_c;\n+    allocator_s_c.dispatch(modify, test, args);\n+\n+    AllocatorClosureEmbeddedCHeap<E> allocator_e_c;\n+    allocator_e_c.dispatch(modify, test, args);\n+\n+    AllocatorClosureCHeapCHeap<E> allocator_c_c;\n+    allocator_c_c.dispatch(modify, test, args);\n+\n+    AllocatorClosureCHeapCHeapNoThrow<E> allocator_c_c_nt;\n+    allocator_c_c_nt.dispatch(modify, test, args);\n+  }\n+\n+  template<typename E, bool do_cheap, ENABLE_IF(!do_cheap)>\n+  static void run_test_modify_allocate_cheap(TestClosure<E>* test, ModifyClosure<E>* modify, AllocatorArgs args) {\n+    \/\/ not enabled\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_modify_allocate_args(TestClosure<E>* test, ModifyClosure<E>* modify, AllocatorArgs args) {\n+    run_test_modify_allocate_arena<E,do_arena>(test, modify, args);\n+    run_test_modify_allocate_cheap<E,do_cheap>(test, modify, args);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_modify_allocate(TestClosure<E>* test, ModifyClosure<E>* modify) {\n+    run_test_modify_allocate_args<E,do_cheap,do_arena>(test, modify, CAP2);\n+    run_test_modify_allocate_args<E,do_cheap,do_arena>(test, modify, CAP0);\n+    run_test_modify_allocate_args<E,do_cheap,do_arena>(test, modify, CAP100);\n+    run_test_modify_allocate_args<E,do_cheap,do_arena>(test, modify, CAP100LEN100);\n+    run_test_modify_allocate_args<E,do_cheap,do_arena>(test, modify, CAP200LEN50);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_modify(TestClosure<E>* test) {\n+    ModifyClosureEmpty<E> modify_empty;\n+    run_test_modify_allocate<E,do_cheap,do_arena>(test, &modify_empty);\n+\n+    ModifyClosureAppend<E> modify_append;\n+    run_test_modify_allocate<E,do_cheap,do_arena>(test, &modify_append);\n+\n+    ModifyClosureAccess<E> modify_access;\n+    run_test_modify_allocate<E,do_cheap,do_arena>(test, &modify_access);\n+\n+    ModifyClosureClear<E> modify_clear;\n+    run_test_modify_allocate<E,do_cheap,do_arena>(test, &modify_clear);\n+\n+    ModifyClosureClearAndDeallocate<E> modify_deallocate;\n+    run_test_modify_allocate<E,do_cheap,do_arena>(test, &modify_deallocate);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_append() {\n+    TestClosureAppend<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_assign() {\n+    TestClosureAssign<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_clear() {\n+    TestClosureClear<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_iterator() {\n+    TestClosureIterator<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_capacity() {\n+    TestClosureCapacity<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_compare() {\n+    TestClosureCompare<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_find_if() {\n+    TestClosureFindIf<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_find_from_end_if() {\n+    TestClosureFindFromEndIf<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_at_grow() {\n+    TestClosureAtGrow<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_at_grow_default() {\n+    TestClosureAtGrowDefault<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+\n+  template<typename E, bool do_cheap, bool do_arena>\n+  static void run_test_sort() {\n+    TestClosureSort<E> test;\n+    run_test_modify<E,do_cheap,do_arena>(&test);\n+  }\n+};\n+\n+TEST_VM_F(GrowableArrayTest, append_int) {\n+  run_test_append<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, append_ptr) {\n+  run_test_append<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, append_point) {\n+  run_test_append<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, append_point_with_default) {\n+  run_test_append<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, append_point_no_assign) {\n+  run_test_append<PointNoAssign,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, append_ctor_dtor) {\n+  run_test_append<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, assign_int) {\n+  run_test_assign<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, assign_ptr) {\n+  run_test_assign<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, assign_point) {\n+  run_test_assign<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, assign_point_with_default) {\n+  run_test_assign<PointWithDefault,true,true>();\n+}\n+\n+\/\/ No assign test for PointNoAssign\n+\n+TEST_VM_F(GrowableArrayTest, assign_ctor_dtor) {\n+  run_test_append<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, clear_int) {\n+  run_test_clear<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, clear_ptr) {\n+  run_test_clear<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, clear_point) {\n+  run_test_clear<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, clear_point_with_default) {\n+  run_test_clear<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, clear_point_no_assign) {\n+  run_test_clear<PointNoAssign,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, clear_ctor_dtor) {\n+  run_test_clear<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, iterator_int) {\n+  run_test_iterator<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, iterator_ptr) {\n+  run_test_iterator<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, iterator_point) {\n+  run_test_iterator<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, iterator_point_with_default) {\n+  run_test_iterator<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, iterator_point_no_assign) {\n+  run_test_iterator<PointNoAssign,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, iterator_ctor_dtor) {\n+  run_test_iterator<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, capacity_int) {\n+  run_test_capacity<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, capacity_ptr) {\n+  run_test_capacity<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, capacity_point) {\n+  run_test_capacity<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, capacity_point_with_default) {\n+  run_test_capacity<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, capacity_point_no_assign) {\n+  run_test_capacity<PointNoAssign,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, capacity_ctor_dtor) {\n+  run_test_capacity<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, compare_int) {\n+  run_test_compare<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, compare_ptr) {\n+  run_test_compare<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, compare_point) {\n+  run_test_compare<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, compare_point_with_default) {\n+  run_test_compare<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, compare_point_no_assign) {\n+  run_test_compare<PointNoAssign,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, compare_ctor_dtor) {\n+  run_test_compare<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_if_int) {\n+  run_test_find_if<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_if_ptr) {\n+  run_test_find_if<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_if_point) {\n+  run_test_find_if<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_if_point_with_default) {\n+  run_test_find_if<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_if_point_no_assign) {\n+  run_test_find_if<PointNoAssign,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_if_ctor_dtor) {\n+  run_test_find_if<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_from_end_if_int) {\n+  run_test_find_from_end_if<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_from_end_if_ptr) {\n+  run_test_find_from_end_if<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_from_end_if_point) {\n+  run_test_find_from_end_if<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_from_end_if_point_with_default) {\n+  run_test_find_from_end_if<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_from_end_if_point_no_assign) {\n+  run_test_find_from_end_if<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, find_from_end_if_ctor_dtor) {\n+  run_test_find_from_end_if<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_int) {\n+  run_test_at_grow<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_ptr) {\n+  run_test_at_grow<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_point) {\n+  run_test_at_grow<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_point_with_default) {\n+  run_test_at_grow<PointWithDefault,true,true>();\n+}\n+\n+\/\/ PointNoAssign: assign not implemented, cannot test at_put_grow\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_ctor_dtor) {\n+  run_test_at_grow<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_default_int) {\n+  run_test_at_grow_default<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_default_ptr) {\n+  run_test_at_grow_default<int*,true,true>();\n+}\n+\n+\/\/ Point: default not implemented, so cannot test!\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_default_point_with_default) {\n+  run_test_at_grow_default<PointWithDefault,true,true>();\n+}\n+\n+\/\/ PointNoAssign: default not implemented, so cannot test!\n+\/\/ PointNoAssign: assign not implemented, cannot test at_put_grow\n+\n+TEST_VM_F(GrowableArrayTest, at_grow_default_ctor_dtor) {\n+  run_test_at_grow_default<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, sort_int) {\n+  run_test_sort<int,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, sort_ptr) {\n+  run_test_sort<int*,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, sort_point) {\n+  run_test_sort<Point,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, sort_point_with_default) {\n+  run_test_sort<PointWithDefault,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, sort_point_no_assign) {\n+  run_test_sort<PointNoAssign,true,true>();\n+}\n+\n+TEST_VM_F(GrowableArrayTest, sort_ctor_dtor) {\n+  run_test_sort<CtorDtor,true,CtorDtor::is_enabled_for_arena>();\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, unallowed_alloc_cheap_res_area,\n+    \".*GrowableArray cannot be C heap allocated\") {\n+  GrowableArray<int>* array = new (mtTest) GrowableArray<int>();\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, unallowed_alloc_cheap_arena,\n+    \".*GrowableArray cannot be C heap allocated\") {\n+  Arena arena(mtTest);\n+  GrowableArray<int>* array = new (mtTest) GrowableArray<int>(&arena);\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, unallowed_alloc_arena_res_area,\n+    \".*if GrowableArray is arena allocated, then the elements must be from the same arena\") {\n+  Arena arena(mtTest);\n+  GrowableArray<int>* array = new (&arena) GrowableArray<int>();\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, unallowed_alloc_res_area_arena_leak,\n+    \".*memory leak: allocating without ResourceMark\") {\n+  \/\/ Missing ResourceMark\n+  Arena arena(mtTest);\n+  GrowableArray<int>* array = new GrowableArray<int>(&arena);\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, unallowed_alloc_res_area_arena,\n+    \".*The elements must be resource area allocated if the GrowableArray itself is\") {\n+  ResourceMark rm;\n+  Arena arena(mtTest);\n+  GrowableArray<int>* array = new GrowableArray<int>(&arena);\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, unallowed_alloc_arena_arena,\n+    \".*if GrowableArray is arena allocated, then the elements must be from the same arena\") {\n+  Arena arena1(mtTest);\n+  Arena arena2(mtTest);\n+  GrowableArray<int>* array = new (&arena1) GrowableArray<int>(&arena2);\n+}\n+#endif\n+\n+#define TEST_SWAP(a1, a2) {                           \\\n+  int* a1_adr = a1.adr_at(0);                         \\\n+  int* a2_adr = a2.adr_at(0);                         \\\n+  a1.swap(&a2);                                       \\\n+  ASSERT_EQ(a1.adr_at(0), a2_adr);                    \\\n+  ASSERT_EQ(a2.adr_at(0), a1_adr);                    \\\n+  ASSERT_EQ(a1.capacity(), 300);                      \\\n+  ASSERT_EQ(a1.length(),   150);                      \\\n+  ASSERT_EQ(a2.capacity(), 200);                      \\\n+  ASSERT_EQ(a2.length(),   100);                      \\\n+}\n+\n+TEST_VM_F(GrowableArrayTest, swap_s_ra_s_ra) {\n+  ResourceMark rm;\n+  GrowableArray<int> a1(200, 100, 1);\n+  GrowableArray<int> a2(300, 150, 2);\n+  TEST_SWAP(a1, a2)\n+}\n+\n+TEST_VM_F(GrowableArrayTest, swap_ra_ra_s_ra) {\n+  ResourceMark rm;\n+  GrowableArray<int>* a1 = new GrowableArray<int>(200, 100, 1);\n+  GrowableArray<int> a2(300, 150, 2);\n+  TEST_SWAP((*a1), a2)\n+}\n+\n+TEST_VM_F(GrowableArrayTest, swap_s_a_s_a) {\n+  Arena arena(mtTest);\n+  GrowableArray<int> a1(&arena, 200, 100, 1);\n+  GrowableArray<int> a2(&arena, 300, 150, 2);\n+  TEST_SWAP(a1, a2)\n+}\n+\n+TEST_VM_F(GrowableArrayTest, swap_a_a_s_a) {\n+  Arena arena(mtTest);\n+  GrowableArray<int> *a1 = new (&arena) GrowableArray<int>(&arena, 200, 100, 1);\n+  GrowableArray<int> a2(&arena, 300, 150, 2);\n+  TEST_SWAP((*a1), a2)\n+}\n+\n+TEST_VM_F(GrowableArrayTest, swap_s_c_s_c) {\n+  GrowableArrayCHeap<int,mtTest> a1(200, 100, 1);\n+  GrowableArrayCHeap<int,mtTest> a2(300, 150, 2);\n+  TEST_SWAP(a1, a2)\n+}\n+\n+TEST_VM_F(GrowableArrayTest, swap_c_c_s_c) {\n+  GrowableArrayCHeap<int,mtTest>* a1 = new GrowableArrayCHeap<int,mtTest>(200, 100, 1);\n+  GrowableArrayCHeap<int,mtTest> a2(300, 150, 2);\n+  TEST_SWAP((*a1), a2)\n+}\n+\n+#ifdef ASSERT\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, swap_s_ra_s_a,\n+    \".*must have same arena\") {\n+  Arena arena(mtTest);\n+  GrowableArray<int> a1(100, 100, 1);\n+  GrowableArray<int> a2(&arena, 100, 100, 1);\n+  a1.swap(&a2);\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, swap_s_a1_s_a2,\n+    \".*must have same arena\") {\n+  Arena arena1(mtTest);\n+  Arena arena2(mtTest);\n+  GrowableArray<int> a1(&arena1, 100, 100, 1);\n+  GrowableArray<int> a2(&arena2, 100, 100, 1);\n+  a1.swap(&a2);\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, swap_s_ra_s_ra,\n+    \".*same nesting if using resource area\") {\n+  ResourceMark rm1;\n+  GrowableArray<int> a1(100, 100, 1);\n+  ResourceMark rm2;\n+  GrowableArray<int> a2(100, 100, 1);\n+  a1.swap(&a2);\n+}\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, resource_area_realloc_scopes,\n+    \".*allocation bug: GrowableArray could grow within nested ResourceMark\") {\n+  ResourceMark rm1;\n+  GrowableArray<int> a(10, 10, 1);\n+  ResourceMark rm2;\n+  for (int i = 0; i < 1000; i++) {\n+    a.append(i);\n@@ -666,0 +2331,57 @@\n+\n+TEST_VM_ASSERT_MSG(GrowableArrayAssertingTest, insert_before_with_itself,\n+    \".*cannot insert itself to itself\") {\n+  ResourceMark rm1;\n+  GrowableArray<int> a(10, 10, 1);\n+  a.insert_before(5, &a);\n+}\n+#endif\n+\n+#define TEST_SHALLOW_ASSIGN(a1, a2) {                 \\\n+  int* a1_adr = a1.adr_at(0);                         \\\n+  int* a2_adr = a2.adr_at(0);                         \\\n+  a2 = a1;                                            \\\n+  ASSERT_EQ(a1.adr_at(0), a1_adr);                    \\\n+  ASSERT_EQ(a2.adr_at(0), a1_adr);                    \\\n+  ASSERT_EQ(a1.capacity(), 200);                      \\\n+  ASSERT_EQ(a1.length(),   100);                      \\\n+  ASSERT_EQ(a2.capacity(), 200);                      \\\n+  ASSERT_EQ(a2.length(),   100);                      \\\n+}\n+\n+#define TEST_SHALLOW_COPY(a1) {                       \\\n+  int* a1_adr = a1.adr_at(0);                         \\\n+  GrowableArray<int> a2(a1);                          \\\n+  ASSERT_EQ(a1.adr_at(0), a1_adr);                    \\\n+  ASSERT_EQ(a2.adr_at(0), a1_adr);                    \\\n+  ASSERT_EQ(a1.capacity(), 200);                      \\\n+  ASSERT_EQ(a1.length(),   100);                      \\\n+  ASSERT_EQ(a2.capacity(), 200);                      \\\n+  ASSERT_EQ(a2.length(),   100);                      \\\n+}\n+\n+TEST_VM_F(GrowableArrayTest, shallow_assign_s_ra_s_ra) {\n+  ResourceMark rm;\n+  GrowableArray<int> a1(200, 100, 1);\n+  GrowableArray<int> a2(300, 150, 2);\n+  TEST_SHALLOW_ASSIGN(a1, a2);\n+}\n+\n+TEST_VM_F(GrowableArrayTest, shallow_assign_s_a_s_a) {\n+  Arena arena(mtTest);\n+  GrowableArray<int> a1(&arena, 200, 100, 1);\n+  GrowableArray<int> a2(&arena, 300, 150, 2);\n+  TEST_SHALLOW_ASSIGN(a1, a2);\n+}\n+\n+TEST_VM_F(GrowableArrayTest, shallow_copy_s_ra_s_ra) {\n+  ResourceMark rm;\n+  GrowableArray<int> a1(200, 100, 1);\n+  TEST_SHALLOW_COPY(a1);\n+}\n+\n+TEST_VM_F(GrowableArrayTest, shallow_copy_s_a_s_a) {\n+  Arena arena(mtTest);\n+  GrowableArray<int> a1(&arena, 200, 100, 1);\n+  TEST_SHALLOW_COPY(a1);\n+}\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":2216,"deletions":494,"binary":false,"changes":2710,"status":"modified"}]}