{"files":[{"patch":"@@ -28,2 +28,3 @@\n- * @modules java.base\/jdk.internal.util\n- * @run main TestUtfLen\n+ * @modules java.base\/jdk.internal.classfile.impl\n+ *          java.base\/jdk.internal.util\n+ * @run main\/othervm -Xmx4g --add-opens java.base\/jdk.internal.classfile.impl=ALL-UNNAMED TestUtfLen\n@@ -32,0 +33,13 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.reflect.Method;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.UTFDataFormatException;\n+\n+import jdk.internal.classfile.impl.BufWriterImpl;\n+import jdk.internal.classfile.impl.ClassFileImpl;\n@@ -35,21 +49,24 @@\n-    private static final String ONE_BYTE   = \"A\";        \/\/ 1-byte UTF-8\n-    private static final String TWO_BYTE   = \"\\u0100\";   \/\/ 2-byte UTF-8\n-    private static final String THREE_BYTE = \"\\u2600\";   \/\/ 3-byte UTF-8\n-\n-    public static void main(String[] args) {\n-        String chunk = ONE_BYTE + TWO_BYTE + THREE_BYTE;\n-        long perChunkLen = ModifiedUtf.utfLen(chunk, 0);\n-        if (perChunkLen != 6L) {\n-            throw new RuntimeException(\"Expected perChunkLen=6 but got \" + perChunkLen);\n-        }\n-\n-        int iterations = (Integer.MAX_VALUE \/ 6) + 1;\n-        long total = 0L;\n-        for (int i = 0; i < iterations; i++) {\n-            total += ModifiedUtf.utfLen(chunk, 0);\n-        }\n-        long expected = perChunkLen * iterations;\n-        if (total != expected) {\n-            throw new RuntimeException(\"Expected total=\" + expected + \" but got \" + total);\n-        }\n-        System.out.println(\"PASSED\");\n+  private static final String THREE_BYTE = \"\\u2600\";   \/\/ 3-byte UTF-8\n+\n+  public static void main(String[] args) {\n+    int count = Integer.MAX_VALUE \/ 3 + 1;\n+    long expected = 3L * count;\n+    String largeString = THREE_BYTE.repeat(count);\n+\n+    long total = ModifiedUtf.utfLen(largeString, 0);\n+    if (total != expected) {\n+      throw new RuntimeException(\"Expected total=\" + expected + \" but got \" + total);\n+    }\n+\n+    \/**\n+     * Verifies that the following three methods that call ModifiedUtf.utfLen()\n+     * correctly handle overflow:\n+     * - DataOutputStream.writeUTF(String)\n+     * - BufWriterImpl.writeUtfEntry(String)\n+     * - ObjectOutputStream.writeUTF(String)\n+     *\/\n+    try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+         DataOutputStream dataOut = new DataOutputStream(byteOut)) {\n+      dataOut.writeUTF(largeString);\n+      throw new RuntimeException(\"Expected UTFDataFormatException was not thrown.\");\n+    } catch (UTFDataFormatException e) {\n@@ -57,1 +74,24 @@\n-}\n\\ No newline at end of file\n+\n+    BufWriterImpl bufWriter = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n+    Method writeUtfEntry = bufWriter.getClass().getDeclaredMethod(\"writeUtfEntry\", String.class);\n+    writeUtfEntry.setAccessible(true);\n+    try {\n+      writeUtfEntry.invoke(bufWriter, largeString);\n+      throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+    } catch (InvocationTargetException e) {\n+      Throwable cause = e.getCause();\n+      if (!(cause instanceof IllegalArgumentException)) {\n+        throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+      }\n+    }\n+\n+    File tempFile = File.createTempFile(\"utfLenOverflow\", \".dat\");\n+    tempFile.deleteOnExit();\n+    try (FileOutputStream fos = new FileOutputStream(tempFile);\n+      ObjectOutputStream objOut = new ObjectOutputStream(fos)){\n+      objOut.writeUTF(largeString);\n+    }\n+\n+    System.out.println(\"PASSED\");\n+  }\n+}\n","filename":"test\/jdk\/jdk\/internal\/util\/TestUtfLen.java","additions":64,"deletions":24,"binary":false,"changes":88,"status":"modified"}]}