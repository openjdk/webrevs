{"files":[{"patch":"@@ -33,4 +33,0 @@\n-import java.lang.classfile.constantpool.ConstantPoolBuilder;\n-import java.lang.classfile.ClassFile;\n-import java.lang.reflect.Method;\n-\n@@ -39,2 +35,0 @@\n-import java.io.File;\n-import java.io.FileOutputStream;\n@@ -42,0 +36,1 @@\n+import java.io.OutputStream;\n@@ -44,0 +39,8 @@\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n@@ -49,0 +52,24 @@\n+\n+  \/**\n+   * Keep only a fixed-length output and stop writing further data\n+   * by throwing an exception when the limit is exceeded.\n+   * For testing purposes only.\n+   *\/\n+  static class HeaderCaptureOutputStream extends OutputStream {\n+    private byte[] head;\n+    private int count;\n+\n+    public HeaderCaptureOutputStream(int headSize) {\n+      this.head = new byte[headSize];\n+    }\n+\n+    @Override\n+    public void write(int b) {\n+      head[count] = (byte) b;\n+      count += 1;\n+    }\n+    public byte[] get(){\n+      return head;\n+    }\n+  }\n+\n@@ -88,4 +115,12 @@\n-    File tempFile = File.createTempFile(\"utfLenOverflow\", \".dat\");\n-    tempFile.deleteOnExit();\n-    try (FileOutputStream fos = new FileOutputStream(tempFile);\n-      ObjectOutputStream objOut = new ObjectOutputStream(fos)){\n+    \/**\n+     * In the writeUTF function, utfLen is used to calculate the length of the string to be written\n+     * and store it in the stream header. This test uses the HeaderCaptureOutputStream inner class\n+     * to capture the header bytes and compare them with the expected length,\n+     * verifying that utfLen returns the correct value.\n+     *\/\n+    int lengthFieldSize = 8;\n+    \/\/ Offset to UTF length field: 2 bytes STREAM_MAGIC + 2 bytes STREAM_VERSION + 5 bytes block data header\n+    int lengthFieldOffset = 9;\n+    int headerSize = 20; \/\/ greater than lengthFieldSize + lengthFieldOffset\n+    HeaderCaptureOutputStream headerOut = new HeaderCaptureOutputStream(headerSize);\n+    try (ObjectOutputStream objOut = new ObjectOutputStream(headerOut)) {\n@@ -93,0 +128,9 @@\n+    } catch (Exception e) {\n+    } finally {\n+      byte[] header = headerOut.get();\n+      ByteBuffer bf = ByteBuffer.wrap(header, lengthFieldOffset, lengthFieldSize);\n+      bf.order(ByteOrder.BIG_ENDIAN);\n+      long lenInHeader = bf.getLong();\n+      if ( lenInHeader != expected ) {\n+        throw new RuntimeException(\"Header length mismatch: expected=\" + expected + \", found=\" + lenInHeader);\n+      }\n","filename":"test\/jdk\/jdk\/internal\/util\/TestUtfLen.java","additions":54,"deletions":10,"binary":false,"changes":64,"status":"modified"}]}