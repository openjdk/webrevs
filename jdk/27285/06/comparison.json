{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.lang.runtime.ExactConversionsSupport;\n+\n@@ -367,1 +369,1 @@\n-        int utflen = utfLen(str, countNonZeroAscii);\n+        long utflenLong = utfLen(str, countNonZeroAscii);\n@@ -369,2 +371,2 @@\n-        if (utflen > 65535 || \/* overflow *\/ utflen < strlen)\n-            throw new UTFDataFormatException(tooLongMsg(str, utflen));\n+        if (!ExactConversionsSupport.isLongToCharExact(utflenLong))\n+            throw new UTFDataFormatException(tooLongMsg(str, utflenLong));\n@@ -372,0 +374,1 @@\n+        int utflen = (int)utflenLong;\n@@ -394,1 +397,1 @@\n-    private static String tooLongMsg(String s, int bits32) {\n+    private static String tooLongMsg(String s, long utflen) {\n@@ -398,2 +401,0 @@\n-        \/\/ handle int overflow with max 3x expansion\n-        long actualLength = (long)slen + Integer.toUnsignedLong(bits32 - slen);\n@@ -401,1 +402,1 @@\n-            + actualLength + \" bytes\";\n+            + utflen + \" bytes\";\n","filename":"src\/java.base\/share\/classes\/java\/io\/DataOutputStream.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+import java.lang.runtime.ExactConversionsSupport;\n+\n@@ -1902,2 +1904,2 @@\n-            int utflen = utfLen(str, countNonZeroAscii);\n-            if (utflen <= 0xFFFF) {\n+            long utflen = utfLen(str, countNonZeroAscii);\n+            if (ExactConversionsSupport.isLongToCharExact(utflen)) {\n@@ -1907,1 +1909,1 @@\n-                writeShort(utflen);\n+                writeShort((short)utflen);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import java.lang.runtime.ExactConversionsSupport;\n@@ -278,2 +279,5 @@\n-        int utflen = utfLen(str, countNonZeroAscii);\n-        Util.checkU2(utflen, \"utf8 length\");\n+        long utflenLong = utfLen(str, countNonZeroAscii);\n+        if (!ExactConversionsSupport.isLongToCharExact(utflenLong)) {\n+            throw new IllegalArgumentException(\"utf8 length out of range of u2: \" + utflenLong);\n+        }\n+        int utflen = (int)utflenLong;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,0 +2,1 @@\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,3 +67,3 @@\n-    public static int utfLen(String str, int countNonZeroAscii) {\n-        int utflen = str.length();\n-        for (int i = utflen - 1; i >= countNonZeroAscii; i--) {\n+    public static long utfLen(String str, int countNonZeroAscii) {\n+        long utflen = str.length();\n+        for (int i = (int)utflen - 1; i >= countNonZeroAscii; i--) {\n@@ -71,1 +72,1 @@\n-                utflen += (c >= 0x800) ? 2 : 1;\n+                utflen += (c >= 0x800) ? 2L : 1L;\n@@ -93,2 +94,1 @@\n-        \/\/ The check strLen > CONSTANT_POOL_UTF8_MAX_BYTES above ensures that utfLen can't overflow here.\n-        int utfLen = utfLen(str, 0);\n+        long utfLen = utfLen(str, 0);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ModifiedUtf.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8366421\n+ * @summary Test for ModifiedUtf.utfLen() return type change from int to long to avoid overflow\n+ * @modules java.base\/jdk.internal.classfile.impl:+open\n+ *          java.base\/jdk.internal.util\n+ * @run main\/othervm -Xmx4g ModifiedUtfTest\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataOutputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.OutputStream;\n+import java.io.UTFDataFormatException;\n+\n+import java.lang.classfile.constantpool.ConstantPoolBuilder;\n+import java.lang.classfile.ClassFile;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+\n+import jdk.internal.classfile.impl.BufWriterImpl;\n+import jdk.internal.classfile.impl.ClassFileImpl;\n+import jdk.internal.util.ModifiedUtf;\n+\n+public class ModifiedUtfTest {\n+\n+    static class HeaderCapturedException extends RuntimeException {\n+    }\n+    \/**\n+     * Keep only a fixed-length output and stop writing further data\n+     * by throwing an exception when the limit is exceeded.\n+     * For testing purposes only.\n+     *\/\n+    static class HeaderCaptureOutputStream extends OutputStream {\n+        private byte[] head;\n+        private int count;\n+\n+        public HeaderCaptureOutputStream(int headSize) {\n+            this.head = new byte[headSize];\n+        }\n+\n+        @Override\n+        public void write(int b) {\n+            if (count >= head.length) {\n+                \/\/ Only reserve a fixed-length header and throw an exception to stop writing.\n+                throw new HeaderCapturedException();\n+            }\n+            head[count++] = (byte) b;\n+        }\n+        public byte[] get(){\n+            return head;\n+        }\n+    }\n+\n+    private static final String THREE_BYTE = \"\\u2600\";   \/\/ 3-byte UTF-8\n+\n+    public static void main(String[] args) throws Exception{\n+        int count = Integer.MAX_VALUE \/ 3 + 1;\n+        long expected = 3L * count;\n+        String largeString = THREE_BYTE.repeat(count);\n+\n+        long total = ModifiedUtf.utfLen(largeString, 0);\n+        if (total != expected) {\n+            throw new RuntimeException(\"Expected total=\" + expected + \" but got \" + total);\n+        }\n+\n+        \/**\n+         * Verifies that the following three methods that call ModifiedUtf.utfLen()\n+         * correctly handle overflow:\n+         * - DataOutputStream.writeUTF(String)\n+         * - BufWriterImpl.writeUtfEntry(String)\n+         * - ObjectOutputStream.writeUTF(String)\n+         *\/\n+        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+             DataOutputStream dataOut = new DataOutputStream(byteOut)) {\n+            dataOut.writeUTF(largeString);\n+            throw new RuntimeException(\"Expected UTFDataFormatException was not thrown.\");\n+        } catch (UTFDataFormatException e) {\n+        }\n+\n+        BufWriterImpl bufWriter = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n+        Method writeUtfEntry = bufWriter.getClass().getDeclaredMethod(\"writeUtfEntry\", String.class);\n+        writeUtfEntry.setAccessible(true);\n+        try {\n+            writeUtfEntry.invoke(bufWriter, largeString);\n+            throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (!(cause instanceof IllegalArgumentException)) {\n+                throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+            }\n+        }\n+\n+        \/**\n+         * In the writeUTF function, utfLen is used to calculate the length of the string to be written\n+         * and store it in the stream header. This test uses the HeaderCaptureOutputStream inner class\n+         * to capture the header bytes and compare them with the expected length,\n+         * verifying that utfLen returns the correct value.\n+         *\/\n+        int lengthFieldSize = 8;\n+        \/\/ Offset to UTF length field: 2 bytes STREAM_MAGIC + 2 bytes STREAM_VERSION + 5 bytes block data header\n+        int lengthFieldOffset = 9;\n+        int headerSize = 20; \/\/ greater than lengthFieldSize + lengthFieldOffset\n+        HeaderCaptureOutputStream headerOut = new HeaderCaptureOutputStream(headerSize);\n+        try (ObjectOutputStream objOut = new ObjectOutputStream(headerOut)) {\n+            objOut.writeUTF(largeString);\n+        } catch (HeaderCapturedException  e) {\n+        }\n+        byte[] header = headerOut.get();\n+        ByteBuffer bf = ByteBuffer.wrap(header, lengthFieldOffset, lengthFieldSize);\n+        bf.order(ByteOrder.BIG_ENDIAN);\n+        long lenInHeader = bf.getLong();\n+        if ( lenInHeader != expected ) {\n+            throw new RuntimeException(\"Header length mismatch: expected=\" + expected + \", found=\" + lenInHeader);\n+        }\n+\n+        System.out.println(\"PASSED\");\n+    }\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/util\/ModifiedUtfTest.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"}]}