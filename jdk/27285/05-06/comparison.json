{"files":[{"patch":"@@ -1909,1 +1909,1 @@\n-                writeShort((int)utflen);\n+                writeShort((short)utflen);\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n- * @modules java.base\/jdk.internal.classfile.impl\n+ * @modules java.base\/jdk.internal.classfile.impl:+open\n@@ -30,1 +30,1 @@\n- * @run main\/othervm -Xmx4g --add-opens java.base\/jdk.internal.classfile.impl=ALL-UNNAMED ModifiedUtfTest\n+ * @run main\/othervm -Xmx4g ModifiedUtfTest\n@@ -53,11 +53,1 @@\n-  \/**\n-   * Keep only a fixed-length output and stop writing further data\n-   * by throwing an exception when the limit is exceeded.\n-   * For testing purposes only.\n-   *\/\n-  static class HeaderCaptureOutputStream extends OutputStream {\n-    private byte[] head;\n-    private int count;\n-\n-    public HeaderCaptureOutputStream(int headSize) {\n-      this.head = new byte[headSize];\n+    static class HeaderCapturedException extends RuntimeException {\n@@ -65,23 +55,0 @@\n-\n-    @Override\n-    public void write(int b) {\n-      head[count] = (byte) b;\n-      count += 1;\n-    }\n-    public byte[] get(){\n-      return head;\n-    }\n-  }\n-\n-  private static final String THREE_BYTE = \"\\u2600\";   \/\/ 3-byte UTF-8\n-\n-  public static void main(String[] args) throws Exception{\n-    int count = Integer.MAX_VALUE \/ 3 + 1;\n-    long expected = 3L * count;\n-    String largeString = THREE_BYTE.repeat(count);\n-\n-    long total = ModifiedUtf.utfLen(largeString, 0);\n-    if (total != expected) {\n-      throw new RuntimeException(\"Expected total=\" + expected + \" but got \" + total);\n-    }\n-\n@@ -89,5 +56,3 @@\n-     * Verifies that the following three methods that call ModifiedUtf.utfLen()\n-     * correctly handle overflow:\n-     * - DataOutputStream.writeUTF(String)\n-     * - BufWriterImpl.writeUtfEntry(String)\n-     * - ObjectOutputStream.writeUTF(String)\n+     * Keep only a fixed-length output and stop writing further data\n+     * by throwing an exception when the limit is exceeded.\n+     * For testing purposes only.\n@@ -95,18 +60,19 @@\n-    try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n-         DataOutputStream dataOut = new DataOutputStream(byteOut)) {\n-      dataOut.writeUTF(largeString);\n-      throw new RuntimeException(\"Expected UTFDataFormatException was not thrown.\");\n-    } catch (UTFDataFormatException e) {\n-    }\n-\n-    BufWriterImpl bufWriter = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n-    Method writeUtfEntry = bufWriter.getClass().getDeclaredMethod(\"writeUtfEntry\", String.class);\n-    writeUtfEntry.setAccessible(true);\n-    try {\n-      writeUtfEntry.invoke(bufWriter, largeString);\n-      throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n-    } catch (InvocationTargetException e) {\n-      Throwable cause = e.getCause();\n-      if (!(cause instanceof IllegalArgumentException)) {\n-        throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n-      }\n+    static class HeaderCaptureOutputStream extends OutputStream {\n+        private byte[] head;\n+        private int count;\n+\n+        public HeaderCaptureOutputStream(int headSize) {\n+            this.head = new byte[headSize];\n+        }\n+\n+        @Override\n+        public void write(int b) {\n+            if (count >= head.length) {\n+                \/\/ Only reserve a fixed-length header and throw an exception to stop writing.\n+                throw new HeaderCapturedException();\n+            }\n+            head[count++] = (byte) b;\n+        }\n+        public byte[] get(){\n+            return head;\n+        }\n@@ -115,22 +81,63 @@\n-    \/**\n-     * In the writeUTF function, utfLen is used to calculate the length of the string to be written\n-     * and store it in the stream header. This test uses the HeaderCaptureOutputStream inner class\n-     * to capture the header bytes and compare them with the expected length,\n-     * verifying that utfLen returns the correct value.\n-     *\/\n-    int lengthFieldSize = 8;\n-    \/\/ Offset to UTF length field: 2 bytes STREAM_MAGIC + 2 bytes STREAM_VERSION + 5 bytes block data header\n-    int lengthFieldOffset = 9;\n-    int headerSize = 20; \/\/ greater than lengthFieldSize + lengthFieldOffset\n-    HeaderCaptureOutputStream headerOut = new HeaderCaptureOutputStream(headerSize);\n-    try (ObjectOutputStream objOut = new ObjectOutputStream(headerOut)) {\n-      objOut.writeUTF(largeString);\n-    } catch (Exception e) {\n-    } finally {\n-      byte[] header = headerOut.get();\n-      ByteBuffer bf = ByteBuffer.wrap(header, lengthFieldOffset, lengthFieldSize);\n-      bf.order(ByteOrder.BIG_ENDIAN);\n-      long lenInHeader = bf.getLong();\n-      if ( lenInHeader != expected ) {\n-        throw new RuntimeException(\"Header length mismatch: expected=\" + expected + \", found=\" + lenInHeader);\n-      }\n+    private static final String THREE_BYTE = \"\\u2600\";   \/\/ 3-byte UTF-8\n+\n+    public static void main(String[] args) throws Exception{\n+        int count = Integer.MAX_VALUE \/ 3 + 1;\n+        long expected = 3L * count;\n+        String largeString = THREE_BYTE.repeat(count);\n+\n+        long total = ModifiedUtf.utfLen(largeString, 0);\n+        if (total != expected) {\n+            throw new RuntimeException(\"Expected total=\" + expected + \" but got \" + total);\n+        }\n+\n+        \/**\n+         * Verifies that the following three methods that call ModifiedUtf.utfLen()\n+         * correctly handle overflow:\n+         * - DataOutputStream.writeUTF(String)\n+         * - BufWriterImpl.writeUtfEntry(String)\n+         * - ObjectOutputStream.writeUTF(String)\n+         *\/\n+        try (ByteArrayOutputStream byteOut = new ByteArrayOutputStream();\n+             DataOutputStream dataOut = new DataOutputStream(byteOut)) {\n+            dataOut.writeUTF(largeString);\n+            throw new RuntimeException(\"Expected UTFDataFormatException was not thrown.\");\n+        } catch (UTFDataFormatException e) {\n+        }\n+\n+        BufWriterImpl bufWriter = new BufWriterImpl(ConstantPoolBuilder.of(), (ClassFileImpl) ClassFile.of());\n+        Method writeUtfEntry = bufWriter.getClass().getDeclaredMethod(\"writeUtfEntry\", String.class);\n+        writeUtfEntry.setAccessible(true);\n+        try {\n+            writeUtfEntry.invoke(bufWriter, largeString);\n+            throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+        } catch (InvocationTargetException e) {\n+            Throwable cause = e.getCause();\n+            if (!(cause instanceof IllegalArgumentException)) {\n+                throw new RuntimeException(\"Expected IllegalArgumentException was not thrown.\");\n+            }\n+        }\n+\n+        \/**\n+         * In the writeUTF function, utfLen is used to calculate the length of the string to be written\n+         * and store it in the stream header. This test uses the HeaderCaptureOutputStream inner class\n+         * to capture the header bytes and compare them with the expected length,\n+         * verifying that utfLen returns the correct value.\n+         *\/\n+        int lengthFieldSize = 8;\n+        \/\/ Offset to UTF length field: 2 bytes STREAM_MAGIC + 2 bytes STREAM_VERSION + 5 bytes block data header\n+        int lengthFieldOffset = 9;\n+        int headerSize = 20; \/\/ greater than lengthFieldSize + lengthFieldOffset\n+        HeaderCaptureOutputStream headerOut = new HeaderCaptureOutputStream(headerSize);\n+        try (ObjectOutputStream objOut = new ObjectOutputStream(headerOut)) {\n+            objOut.writeUTF(largeString);\n+        } catch (HeaderCapturedException  e) {\n+        }\n+        byte[] header = headerOut.get();\n+        ByteBuffer bf = ByteBuffer.wrap(header, lengthFieldOffset, lengthFieldSize);\n+        bf.order(ByteOrder.BIG_ENDIAN);\n+        long lenInHeader = bf.getLong();\n+        if ( lenInHeader != expected ) {\n+            throw new RuntimeException(\"Header length mismatch: expected=\" + expected + \", found=\" + lenInHeader);\n+        }\n+\n+        System.out.println(\"PASSED\");\n@@ -138,4 +145,1 @@\n-\n-    System.out.println(\"PASSED\");\n-  }\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/jdk\/internal\/util\/ModifiedUtfTest.java","additions":89,"deletions":85,"binary":false,"changes":174,"status":"modified"}]}