{"files":[{"patch":"@@ -79,3 +79,0 @@\n-  \/\/ reads a request from the given connected socket\n-  static PosixAttachOperation* read_request(int s);\n-\n@@ -83,7 +80,0 @@\n-  enum {\n-    ATTACH_PROTOCOL_VER = 1                     \/\/ protocol version\n-  };\n-  enum {\n-    ATTACH_ERROR_BADVERSION     = 101           \/\/ error codes\n-  };\n-\n@@ -110,3 +100,0 @@\n-  \/\/ write the given buffer to a socket\n-  static int write_fully(int s, char* buf, size_t len);\n-\n@@ -116,0 +103,39 @@\n+class SocketChannel : public AttachOperation::RequestReader, public AttachOperation::ReplyWriter {\n+private:\n+  int _socket;\n+public:\n+  SocketChannel(int socket) : _socket(socket) {}\n+  ~SocketChannel() {\n+    close();\n+  }\n+\n+  bool opened() const {\n+    return _socket != -1;\n+  }\n+\n+  void close() {\n+    if (opened()) {\n+      ::close(_socket);\n+      _socket = -1;\n+    }\n+  }\n+\n+  \/\/ RequestReader\n+  int read(void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::read(_socket, buffer, (size_t)size), n);\n+    return checked_cast<int>(n);\n+  }\n+\n+  \/\/ ReplyWriter\n+  int write(const void* buffer, int size) override {\n+    ssize_t n;\n+    RESTARTABLE(::write(_socket, buffer, size), n);\n+    return checked_cast<int>(n);\n+  }\n+  \/\/ called after writing all data\n+  void flush() override {\n+    ::shutdown(_socket, SHUT_RDWR);\n+  }\n+};\n+\n@@ -119,1 +145,1 @@\n-  int _socket;\n+  SocketChannel _socket_channel;\n@@ -122,1 +148,1 @@\n-  void complete(jint res, bufferedStream* st);\n+  void complete(jint res, bufferedStream* st) override;\n@@ -124,2 +150,2 @@\n-  void set_socket(int s)                                { _socket = s; }\n-  int socket() const                                    { return _socket; }\n+  PosixAttachOperation(int socket) : AttachOperation(), _socket_channel(socket) {\n+  }\n@@ -127,2 +153,2 @@\n-  PosixAttachOperation(char* name) : AttachOperation(name) {\n-    set_socket(-1);\n+  bool read_request() {\n+    return AttachOperation::read_request(&_socket_channel, &_socket_channel);\n@@ -138,29 +164,0 @@\n-\/\/ Supporting class to help split a buffer into individual components\n-class ArgumentIterator : public StackObj {\n- private:\n-  char* _pos;\n-  char* _end;\n- public:\n-  ArgumentIterator(char* arg_buffer, size_t arg_size) {\n-    _pos = arg_buffer;\n-    _end = _pos + arg_size - 1;\n-  }\n-  char* next() {\n-    if (*_pos == '\\0') {\n-      \/\/ advance the iterator if possible (null arguments)\n-      if (_pos < _end) {\n-        _pos += 1;\n-      }\n-      return nullptr;\n-    }\n-    char* res = _pos;\n-    char* next_pos = strchr(_pos, '\\0');\n-    if (next_pos < _end)  {\n-      next_pos++;\n-    }\n-    _pos = next_pos;\n-    return res;\n-  }\n-};\n-\n-\n@@ -252,97 +249,0 @@\n-\/\/ Given a socket that is connected to a peer we read the request and\n-\/\/ create an AttachOperation. As the socket is blocking there is potential\n-\/\/ for a denial-of-service if the peer does not response. However this happens\n-\/\/ after the peer credentials have been checked and in the worst case it just\n-\/\/ means that the attach listener thread is blocked.\n-\/\/\n-PosixAttachOperation* PosixAttachListener::read_request(int s) {\n-  char ver_str[8];\n-  os::snprintf_checked(ver_str, sizeof(ver_str), \"%d\", ATTACH_PROTOCOL_VER);\n-\n-  \/\/ The request is a sequence of strings so we first figure out the\n-  \/\/ expected count and the maximum possible length of the request.\n-  \/\/ The request is:\n-  \/\/   <ver>0<cmd>0<arg>0<arg>0<arg>0\n-  \/\/ where <ver> is the protocol version (1), <cmd> is the command\n-  \/\/ name (\"load\", \"datadump\", ...), and <arg> is an argument\n-  int expected_str_count = 2 + AttachOperation::arg_count_max;\n-  const size_t max_len = (sizeof(ver_str) + 1) + (AttachOperation::name_length_max + 1) +\n-    AttachOperation::arg_count_max*(AttachOperation::arg_length_max + 1);\n-\n-  char buf[max_len];\n-  int str_count = 0;\n-\n-  \/\/ Read until all (expected) strings have been read, the buffer is\n-  \/\/ full, or EOF.\n-\n-  size_t off = 0;\n-  size_t left = max_len;\n-\n-  do {\n-    ssize_t n;\n-    RESTARTABLE(read(s, buf+off, left), n);\n-    assert(n <= checked_cast<ssize_t>(left), \"buffer was too small, impossible!\");\n-    buf[max_len - 1] = '\\0';\n-    if (n == -1) {\n-      return nullptr;      \/\/ reset by peer or other error\n-    }\n-    if (n == 0) {\n-      break;\n-    }\n-    for (ssize_t i=0; i<n; i++) {\n-      if (buf[off+i] == 0) {\n-        \/\/ EOS found\n-        str_count++;\n-\n-        \/\/ The first string is <ver> so check it now to\n-        \/\/ check for protocol mismatch\n-        if (str_count == 1) {\n-          if ((strlen(buf) != strlen(ver_str)) ||\n-              (atoi(buf) != ATTACH_PROTOCOL_VER)) {\n-            char msg[32];\n-            os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", ATTACH_ERROR_BADVERSION);\n-            write_fully(s, msg, strlen(msg));\n-            return nullptr;\n-          }\n-        }\n-      }\n-    }\n-    off += n;\n-    left -= n;\n-  } while (left > 0 && str_count < expected_str_count);\n-\n-  if (str_count != expected_str_count) {\n-    return nullptr;        \/\/ incomplete request\n-  }\n-\n-  \/\/ parse request\n-\n-  ArgumentIterator args(buf, (max_len)-left);\n-\n-  \/\/ version already checked\n-  char* v = args.next();\n-\n-  char* name = args.next();\n-  if (name == nullptr || strlen(name) > AttachOperation::name_length_max) {\n-    return nullptr;\n-  }\n-\n-  PosixAttachOperation* op = new PosixAttachOperation(name);\n-\n-  for (int i=0; i<AttachOperation::arg_count_max; i++) {\n-    char* arg = args.next();\n-    if (arg == nullptr) {\n-      op->set_arg(i, nullptr);\n-    } else {\n-      if (strlen(arg) > AttachOperation::arg_length_max) {\n-        delete op;\n-        return nullptr;\n-      }\n-      op->set_arg(i, arg);\n-    }\n-  }\n-\n-  op->set_socket(s);\n-  return op;\n-}\n-\n@@ -403,3 +303,3 @@\n-    PosixAttachOperation* op = read_request(s);\n-    if (op == nullptr) {\n-      ::close(s);\n+    PosixAttachOperation* op = new PosixAttachOperation(s);\n+    if (!op->read_request()) {\n+      delete op;\n@@ -413,15 +313,0 @@\n-\/\/ write the given buffer to the socket\n-int PosixAttachListener::write_fully(int s, char* buf, size_t len) {\n-  do {\n-    ssize_t n = ::write(s, buf, len);\n-    if (n == -1) {\n-      if (errno != EINTR) return -1;\n-    } else {\n-      buf += n;\n-      len -= n;\n-    }\n-  }\n-  while (len > 0);\n-  return 0;\n-}\n-\n@@ -440,13 +325,1 @@\n-  \/\/ write operation result\n-  char msg[32];\n-  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  int rc = PosixAttachListener::write_fully(this->socket(), msg, strlen(msg));\n-\n-  \/\/ write any result data\n-  if (rc == 0) {\n-    PosixAttachListener::write_fully(this->socket(), (char*) st->base(), st->size());\n-    ::shutdown(this->socket(), 2);\n-  }\n-\n-  \/\/ done\n-  ::close(this->socket());\n+  write_reply(&_socket_channel, result, st);\n@@ -493,0 +366,2 @@\n+  AttachListener::set_supported_version(ATTACH_API_V2);\n+\n","filename":"src\/hotspot\/os\/posix\/attachListener_posix.cpp","additions":51,"deletions":176,"binary":false,"changes":227,"status":"modified"},{"patch":"@@ -155,1 +155,1 @@\n-    return AttachOperation::read_request(&_pipe);\n+    return AttachOperation::read_request(&_pipe, &_pipe);\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -528,1 +528,1 @@\n-int AttachOperation::RequestReader::read_uint() {\n+int AttachOperation::RequestReader::read_uint(bool may_be_empty) {\n@@ -537,1 +537,3 @@\n-        log_error(attach)(\"Failed to read int value: EOF\");\n+        if (!may_be_empty || value != 0) { \/\/ value != 0 means this is not the 1st read\n+          log_error(attach)(\"Failed to read int value: EOF\");\n+        }\n@@ -618,2 +620,5 @@\n-bool AttachOperation::read_request(RequestReader* reader) {\n-  uint ver = reader->read_uint();\n+bool AttachOperation::read_request(RequestReader* reader, ReplyWriter* error_writer) {\n+  int ver = reader->read_uint(true); \/\/ do not log error if this is \"empty\" connection\n+  if (ver < 0) {\n+    return false;\n+  }\n@@ -634,0 +639,1 @@\n+        write_reply(error_writer, ATTACH_ERROR_BADVERSION, \"v2 is unsupported or disabled\");\n@@ -655,0 +661,1 @@\n+    write_reply(error_writer, ATTACH_ERROR_BADVERSION, \"unknown version\");\n@@ -658,1 +665,16 @@\n-  return read_request_data(reader, buffer_size, min_str_count, min_read_size);\n+  bool result = read_request_data(reader, buffer_size, min_str_count, min_read_size);\n+  if (result && ver == ATTACH_API_V1) {\n+    \/\/ We know the whole request does not exceed buffer_size,\n+    \/\/ for v1 also name\/arguments should not exceed name_length_max\/arg_length_max.\n+    if (strlen(name()) > AttachOperation::name_length_max) {\n+      log_error(attach)(\"Failed to read request: name is too long\");\n+      return false;\n+    }\n+    for (int i = 0; i < arg_count(); i++) {\n+      if (strlen(arg(i)) > AttachOperation::arg_length_max) {\n+        log_error(attach)(\"Failed to read request: argument is too long\");\n+        return false;\n+      }\n+    }\n+  }\n+  return result;\n@@ -674,4 +696,7 @@\n-bool AttachOperation::write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream) {\n-  char msg[32];\n-  os::snprintf_checked(msg, sizeof(msg), \"%d\\n\", result);\n-  if (!writer->write_fully(msg, (int)strlen(msg))) {\n+bool AttachOperation::write_reply(ReplyWriter * writer, jint result, const char* message, int message_len) {\n+  if (message_len < 0) {\n+    message_len = (int)strlen(message);\n+  }\n+  char buf[32];\n+  os::snprintf_checked(buf, sizeof(buf), \"%d\\n\", result);\n+  if (!writer->write_fully(buf, (int)strlen(buf))) {\n@@ -680,1 +705,1 @@\n-  if (!writer->write_fully(result_stream->base(), (int)result_stream->size())) {\n+  if (!writer->write_fully(message, message_len)) {\n@@ -687,0 +712,4 @@\n+bool AttachOperation::write_reply(ReplyWriter* writer, jint result, bufferedStream* result_stream) {\n+  return write_reply(writer, result, result_stream->base(), (int)result_stream->size());\n+}\n+\n","filename":"src\/hotspot\/share\/services\/attachListener.cpp","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -73,2 +73,2 @@\n-    ATTACH_API_V1 = 1,\n-    ATTACH_API_V2 = 2\n+  ATTACH_API_V1 = 1,\n+  ATTACH_API_V2 = 2\n@@ -167,0 +167,4 @@\n+  \/\/ error codes (reported as status to clients)\n+  enum {\n+    ATTACH_ERROR_BADVERSION = 101\n+  };\n@@ -234,0 +238,2 @@\n+  class ReplyWriter; \/\/forward declaration\n+\n@@ -242,1 +248,5 @@\n-    int read_uint();\n+    \/\/\n+    \/\/ Attach client can make sanity connect\/disconnect.\n+    \/\/ In the case we get \"premature EOF\" error.\n+    \/\/ If may_be_empty is true, the error is not logged.\n+    int read_uint(bool may_be_empty = false);\n@@ -246,1 +256,2 @@\n-  bool read_request(RequestReader* reader);\n+  \/\/ Some errors known by clients are reported to error_writer.\n+  bool read_request(RequestReader* reader, ReplyWriter* error_writer);\n@@ -259,0 +270,1 @@\n+  bool write_reply(ReplyWriter* writer, jint result, const char* message, int message_len = -1);\n","filename":"src\/hotspot\/share\/services\/attachListener.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+    private int ver = VERSION_1;        \/\/ updated in ctor depending on detectVersion result\n@@ -137,8 +138,12 @@\n-        \/\/ Check that we can connect to the process\n-        \/\/ - this ensures we throw the permission denied error now rather than\n-        \/\/ later when we attempt to enqueue a command.\n-        int s = socket();\n-        try {\n-            connect(s, socket_path);\n-        } finally {\n-            close(s);\n+        if (isAPIv2Enabled()) {\n+            ver = detectVersion();\n+        } else {\n+            \/\/ Check that we can connect to the process\n+            \/\/ - this ensures we throw the permission denied error now rather than\n+            \/\/ later when we attempt to enqueue a command.\n+            int s = socket();\n+            try {\n+                connect(s, socket_path);\n+            } finally {\n+                close(s);\n+            }\n@@ -159,3 +164,0 @@\n-    \/\/ protocol version\n-    private static final String PROTOCOL_VERSION = \"1\";\n-\n@@ -166,1 +168,0 @@\n-        assert args.length <= 3;                \/\/ includes null\n@@ -190,1 +191,0 @@\n-        \/\/ <ver> <cmd> <args...>\n@@ -192,10 +192,2 @@\n-            writeString(s, PROTOCOL_VERSION);\n-            writeString(s, cmd);\n-\n-            for (int i = 0; i < 3; i++) {\n-                if (i < args.length && args[i] != null) {\n-                    writeString(s, (String)args[i]);\n-                } else {\n-                    writeString(s, \"\");\n-                }\n-            }\n+            SocketOutputStream writer = new SocketOutputStream(s);\n+            writeCommand(writer, ver, cmd, args);\n@@ -217,0 +209,11 @@\n+    private static class SocketOutputStream implements AttachOutputStream {\n+        private int fd;\n+        public SocketOutputStream(int fd) {\n+            this.fd = fd;\n+        }\n+        @Override\n+        public void write(byte[] buffer, int offset, int length) throws IOException {\n+            VirtualMachineImpl.write(fd, buffer, offset, length);\n+        }\n+    }\n+\n@@ -335,14 +338,0 @@\n-    \/*\n-     * Write\/sends the given to the target VM. String is transmitted in\n-     * UTF-8 encoding.\n-     *\/\n-    private void writeString(int fd, String s) throws IOException {\n-        if (s.length() > 0) {\n-            byte[] b = s.getBytes(UTF_8);\n-            VirtualMachineImpl.write(fd, b, 0, b.length);\n-        }\n-        byte b[] = new byte[1];\n-        b[0] = 0;\n-        write(fd, b, 0, 1);\n-    }\n-\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":26,"deletions":37,"binary":false,"changes":63,"status":"modified"}]}