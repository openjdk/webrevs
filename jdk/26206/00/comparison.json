{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8206929 8212885\n+ * @bug 8206929 8212885 8333857\n@@ -50,0 +50,3 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n@@ -59,0 +62,1 @@\n+    static TestMode testMode;\n@@ -61,1 +65,2 @@\n-        new ResumeChecksClient(TestMode.valueOf(args[0])).run();\n+        testMode = TestMode.valueOf(args[0]);\n+        new ResumeChecksClient().test();\n@@ -64,8 +69,2 @@\n-    private final TestMode testMode;\n-    public ResumeChecksClient(TestMode mode) {\n-        this.testMode = mode;\n-    }\n-\n-    private void run() throws Exception {\n-        Server server = startServer();\n-        server.signal();\n+    private void test() throws Exception {\n+        Server server = new Server();\n@@ -73,4 +72,7 @@\n-        while (!server.started) {\n-            Thread.yield();\n-        }\n-        SSLSession firstSession = connect(sslContext, server.port, testMode, false);\n+        HexFormat hex = HexFormat.of();\n+        long firstStartTime = System.currentTimeMillis();\n+        SSLSession firstSession = connect(sslContext, server.port, true);\n+        System.err.println(\"firstStartTime = \" + firstStartTime);\n+        System.err.println(\"firstId = \" + hex.formatHex(firstSession.getId()));\n+        System.err.println(\"firstSession.getCreationTime() = \" +\n+            firstSession.getCreationTime());\n@@ -78,1 +80,0 @@\n-        server.signal();\n@@ -80,5 +81,6 @@\n-        Thread.sleep(10);\n-        SSLSession secondSession = connect(sslContext, server.port, testMode, true);\n-\n-        server.go = false;\n-        server.signal();\n+        SSLSession secondSession = connect(sslContext, server.port, false);\n+        System.err.println(\"secondStartTime = \" + secondStartTime);\n+        \/\/ Note: Ids will never match with TLS 1.3 due to spec\n+        System.err.println(\"secondId = \" + hex.formatHex(secondSession.getId()));\n+        System.err.println(\"secondSession.getCreationTime() = \" +\n+            secondSession.getCreationTime());\n@@ -90,0 +92,1 @@\n+            System.out.println(\"secondSession used resumption: PASS\");\n@@ -96,2 +99,8 @@\n-            if (secondSession.getCreationTime() <= secondStartTime) {\n-                throw new RuntimeException(\"Existing session was used\");\n+            try {\n+                checkResumedSession(firstSession, secondSession);\n+                System.err.println(\"firstSession  = \" + firstSession);\n+                System.err.println(\"secondSession = \" + secondSession);\n+                throw new RuntimeException(\"Second connection should not \" +\n+                    \"have resumed first session.\");\n+            } catch (RuntimeException e) {\n+                System.out.println(\"secondSession didn't use resumption: PASS\");\n@@ -101,1 +110,1 @@\n-            throw new RuntimeException(\"unknown mode: \" + testMode);\n+            throw new AssertionError(\"unknown mode: \" + testMode);\n@@ -137,1 +146,1 @@\n-        TestMode mode, boolean second) {\n+        boolean first) {\n@@ -144,38 +153,16 @@\n-            switch (mode) {\n-            case BASIC:\n-                \/\/ do nothing to ensure resumption works\n-                break;\n-            case VERSION_2_TO_3:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                }\n-                break;\n-            case VERSION_3_TO_2:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                }\n-                break;\n-            case CIPHER_SUITE:\n-                if (second) {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_256_GCM_SHA384\"});\n-                } else {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_128_GCM_SHA256\"});\n-                }\n-                break;\n-            case SIGNATURE_SCHEME:\n-                AlgorithmConstraints constraints =\n-                    params.getAlgorithmConstraints();\n-                if (second) {\n-                    params.setAlgorithmConstraints(new NoSig(\"ecdsa\"));\n-                } else {\n-                    params.setAlgorithmConstraints(new NoSig(\"rsa\"));\n-                }\n-                break;\n-            default:\n-                throw new RuntimeException(\"unknown mode: \" + mode);\n+            switch (testMode) {\n+                case BASIC -> {}  \/\/ do nothing\n+                case VERSION_2_TO_3 -> params.setProtocols(new String[]{\n+                    first ? \"TLSv1.2\" : \"TLSv1.3\"});\n+                case VERSION_3_TO_2 -> params.setProtocols(new String[]{\n+                    first ? \"TLSv1.3\" : \"TLSv1.2\"});\n+                case CIPHER_SUITE -> params.setCipherSuites(\n+                    new String[]{\n+                        first ? \"TLS_AES_128_GCM_SHA256\" :\n+                            \"TLS_AES_256_GCM_SHA384\"});\n+                case SIGNATURE_SCHEME ->\n+                    params.setAlgorithmConstraints(new NoSig(\n+                        first ? \"rsa\" : \"ecdsa\"));\n+                default ->\n+                    throw new AssertionError(\"unknown mode: \" +\n+                        testMode);\n@@ -277,27 +264,5 @@\n-    private static Server startServer() {\n-        Server server = new Server();\n-        new Thread(server).start();\n-        return server;\n-    }\n-\n-    private static class Server extends SSLContextTemplate implements Runnable {\n-\n-        public volatile boolean go = true;\n-        private boolean signal = false;\n-        public volatile int port = 0;\n-        public volatile boolean started = false;\n-\n-        private synchronized void waitForSignal() {\n-            while (!signal) {\n-                try {\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    \/\/ do nothing\n-                }\n-            }\n-            signal = false;\n-        }\n-        public synchronized void signal() {\n-            signal = true;\n-            notify();\n-        }\n+    private static class Server extends SSLContextTemplate {\n+        public int port;\n+        private final SSLServerSocket ssock;\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1);\n+        CountDownLatch serverLatch = new CountDownLatch(1);\n@@ -305,2 +270,1 @@\n-        @Override\n-        public void run() {\n+        Server() {\n@@ -308,1 +272,0 @@\n-\n@@ -311,3 +274,2 @@\n-                SSLServerSocket ssock = (SSLServerSocket)\n-                    fac.createServerSocket(0);\n-                this.port = ssock.getLocalPort();\n+                ssock = (SSLServerSocket) fac.createServerSocket(0);\n+                port = ssock.getLocalPort();\n@@ -315,3 +277,2 @@\n-                waitForSignal();\n-                started = true;\n-                while (go) {\n+                \/\/ Thread to allow multiple clients to connect\n+                new Thread(() -> {\n@@ -319,11 +280,6 @@\n-                        System.out.println(\"Waiting for connection\");\n-                        Socket sock = ssock.accept();\n-                        BufferedReader reader = new BufferedReader(\n-                            new InputStreamReader(sock.getInputStream()));\n-                        String line = reader.readLine();\n-                        System.out.println(\"server read: \" + line);\n-                        PrintWriter out = new PrintWriter(\n-                            new OutputStreamWriter(sock.getOutputStream()));\n-                        out.println(line);\n-                        out.flush();\n-                        waitForSignal();\n+                        System.err.println(\"Server starting to accept\");\n+                        serverLatch.countDown();\n+                        do {\n+                            threadPool.submit(\n+                                new ServerThread((SSLSocket) ssock.accept()));\n+                        } while (true);\n@@ -331,1 +287,3 @@\n-                        ex.printStackTrace();\n+                        throw new AssertionError(\"Server Down\", ex);\n+                    } finally {\n+                        threadPool.close();\n@@ -333,0 +291,29 @@\n+                }).start();\n+\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        static class ServerThread extends Thread {\n+            SSLSocket sock;\n+\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"(Server) client connection on port \" +\n+                    sock.getPort());\n+            }\n+\n+            public void run() {\n+                try {\n+                    BufferedReader reader = new BufferedReader(\n+                        new InputStreamReader(sock.getInputStream()));\n+                    String line = reader.readLine();\n+                    System.out.println(\"server read: \" + line);\n+                    PrintWriter out = new PrintWriter(\n+                        new OutputStreamWriter(sock.getOutputStream()));\n+                    out.println(line);\n+                    out.flush();\n+                    out.close();\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"Server thread error\", e);\n@@ -334,2 +321,0 @@\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksClient.java","additions":98,"deletions":113,"binary":false,"changes":211,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8206929\n+ * @bug 8206929 8333857\n@@ -52,0 +52,4 @@\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+\n@@ -66,5 +70,3 @@\n-    public static void main(String[] args) throws Exception {\n-\n-        new ResumeChecksServer(TestMode.valueOf(args[0])).run();\n-    }\n-    private final TestMode testMode;\n+    static CountDownLatch latch = new CountDownLatch(1);\n+    static TestMode testMode;\n+    static int serverPort;\n@@ -72,2 +74,3 @@\n-    public ResumeChecksServer(TestMode testMode) {\n-        this.testMode = testMode;\n+    public static void main(String[] args) throws Exception {\n+        testMode = TestMode.valueOf(args[0]);\n+        new ResumeChecksServer().test();\n@@ -76,3 +79,3 @@\n-    private void run() throws Exception {\n-        SSLSession firstSession;\n-        SSLSession secondSession = null;\n+    private void test() throws Exception {\n+        SSLSession firstSession, secondSession;\n+        HexFormat hex = HexFormat.of();\n@@ -80,4 +83,3 @@\n-        SSLContext sslContext = createServerSSLContext();\n-        ServerSocketFactory fac = sslContext.getServerSocketFactory();\n-        SSLServerSocket ssock = (SSLServerSocket)\n-            fac.createServerSocket(0);\n+        serverPort = new Server().port;\n+        latch.await();\n+        Client c = new Client(serverPort);\n@@ -85,1 +87,3 @@\n-        Client client = startClient(ssock.getLocalPort());\n+        System.out.println(\"Waiting for connection\");\n+        long firstStartTime = System.currentTimeMillis();\n+        firstSession = c.test();\n@@ -87,5 +91,4 @@\n-        try {\n-            firstSession = connect(client, ssock, testMode, null);\n-        } catch (Exception ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        System.err.println(\"firstStartTime = \" + firstStartTime);\n+        System.err.println(\"firstId = \" + hex.formatHex(firstSession.getId()));\n+        System.err.println(\"firstSession.getCreationTime() = \" +\n+            firstSession.getCreationTime());\n@@ -94,8 +97,1 @@\n-        Thread.sleep(10);\n-        try {\n-            secondSession = connect(client, ssock, testMode, firstSession);\n-        } catch (SSLHandshakeException ex) {\n-            \/\/ this is expected\n-        } catch (Exception ex) {\n-            throw new RuntimeException(ex);\n-        }\n+        secondSession = c.test();\n@@ -103,2 +99,5 @@\n-        client.go = false;\n-        client.signal();\n+        System.err.println(\"secondStartTime = \" + secondStartTime);\n+        \/\/ Note: Ids will never match with TLS 1.3 due to spec\n+        System.err.println(\"secondId = \" + hex.formatHex(secondSession.getId()));\n+        System.err.println(\"secondSession.getCreationTime() = \" +\n+            secondSession.getCreationTime());\n@@ -109,1 +108,2 @@\n-            if (secondSession.getCreationTime() > secondStartTime) {\n+            if (firstSession.getCreationTime() !=\n+                secondSession.getCreationTime()) {\n@@ -114,1 +114,1 @@\n-            if (!java.util.Arrays.equals(\n+            if (!Arrays.equals(\n@@ -131,1 +131,1 @@\n-            if (secondSession.getCreationTime() <= secondStartTime) {\n+            if (secondSession.getCreationTime() < secondStartTime) {\n@@ -136,1 +136,1 @@\n-            throw new RuntimeException(\"unknown mode: \" + testMode);\n+            throw new AssertionError(\"unknown mode: \" + testMode);\n@@ -141,1 +141,0 @@\n-\n@@ -148,1 +147,0 @@\n-\n@@ -156,0 +154,1 @@\n+\n@@ -158,1 +157,0 @@\n-\n@@ -161,0 +159,1 @@\n+\n@@ -163,1 +162,0 @@\n-\n@@ -168,4 +166,4 @@\n-    private static SSLSession connect(Client client, SSLServerSocket ssock,\n-            TestMode mode, SSLSession firstSession) throws Exception {\n-\n-        boolean second = firstSession != null;\n+    private static class Client extends SSLContextTemplate {\n+        private final int port;\n+        private final SSLContext sc;\n+        public SSLSession session;\n@@ -173,5 +171,4 @@\n-        try {\n-            client.signal();\n-            System.out.println(\"Waiting for connection\");\n-            SSLSocket sock = (SSLSocket) ssock.accept();\n-            SSLParameters params = sock.getSSLParameters();\n+        Client(int port) throws Exception {\n+            sc = createClientSSLContext();\n+            this.port = port;\n+        }\n@@ -179,55 +176,10 @@\n-            switch (mode) {\n-            case BASIC:\n-                \/\/ do nothing to ensure resumption works\n-                break;\n-            case CLIENT_AUTH:\n-                if (second) {\n-                    params.setNeedClientAuth(true);\n-                } else {\n-                    params.setNeedClientAuth(false);\n-                }\n-                break;\n-            case VERSION_2_TO_3:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                }\n-                break;\n-            case VERSION_3_TO_2:\n-                if (second) {\n-                    params.setProtocols(new String[] {\"TLSv1.2\"});\n-                } else {\n-                    params.setProtocols(new String[] {\"TLSv1.3\"});\n-                }\n-                break;\n-            case CIPHER_SUITE:\n-                if (second) {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_128_GCM_SHA256\"});\n-                } else {\n-                    params.setCipherSuites(\n-                        new String[] {\"TLS_AES_256_GCM_SHA384\"});\n-                }\n-                break;\n-            case SIGNATURE_SCHEME:\n-                params.setNeedClientAuth(true);\n-                AlgorithmConstraints constraints =\n-                    params.getAlgorithmConstraints();\n-                if (second) {\n-                    params.setAlgorithmConstraints(\n-                            new NoSig(\"ecdsa_secp384r1_sha384\"));\n-                } else {\n-                    params.setAlgorithmConstraints(\n-                            new NoSig(\"ecdsa_secp521r1_sha512\"));\n-                }\n-                break;\n-            case LOCAL_CERTS:\n-                if (second) {\n-                    \/\/ Add first session's certificate signature\n-                    \/\/ algorithm to constraints so local certificates\n-                    \/\/ can't be restored from the session ticket.\n-                    params.setAlgorithmConstraints(\n-                            new NoSig(X509CertImpl.toImpl((X509CertImpl)\n-                                            firstSession.getLocalCertificates()[0])\n-                                    .getSigAlgName()));\n+        public SSLSession test() throws Exception {\n+            SSLSocket sock = null;\n+            latch.await();\n+            do {\n+                try {\n+                    sock = (SSLSocket) sc.getSocketFactory().createSocket();\n+                } catch (IOException e) {\n+                    \/\/ If the server never starts, test will time out.\n+                    System.err.println(\"client trying again to connect\");\n+                    Thread.sleep(500);\n@@ -235,9 +187,2 @@\n-                break;\n-            default:\n-                throw new RuntimeException(\"unknown mode: \" + mode);\n-            }\n-            sock.setSSLParameters(params);\n-            BufferedReader reader = new BufferedReader(\n-                new InputStreamReader(sock.getInputStream()));\n-            String line = reader.readLine();\n-            System.out.println(\"server read: \" + line);\n+            } while (sock == null);\n+            sock.connect(new InetSocketAddress(\"localhost\", port));\n@@ -246,1 +191,1 @@\n-            out.println(line);\n+            out.println(\"message\");\n@@ -248,0 +193,4 @@\n+            BufferedReader reader = new BufferedReader(\n+                new InputStreamReader(sock.getInputStream()));\n+            String inMsg = reader.readLine();\n+            System.out.println(\"Client received: \" + inMsg);\n@@ -249,1 +198,1 @@\n-            SSLSession result = sock.getSession();\n+            session = sock.getSession();\n@@ -251,5 +200,1 @@\n-            return result;\n-        } catch (SSLHandshakeException ex) {\n-            if (!second) {\n-                throw ex;\n-            }\n+            return session;\n@@ -257,7 +202,0 @@\n-        return null;\n-    }\n-\n-    private static Client startClient(int port) {\n-        Client client = new Client(port);\n-        new Thread(client).start();\n-        return client;\n@@ -266,12 +204,17 @@\n-    private static class Client extends SSLContextTemplate implements Runnable {\n-\n-        public volatile boolean go = true;\n-        private boolean signal = false;\n-        private final int port;\n-\n-        Client(int port) {\n-            this.port = port;\n-        }\n-\n-        private synchronized void waitForSignal() {\n-            while (!signal) {\n+    \/\/ The server will only have two connections each tests\n+    private static class Server extends SSLContextTemplate {\n+        public int port;\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1);\n+        \/\/ Stores the certs from the first connection in mode LOCAL_CERTS\n+        static X509CertImpl localCerts;\n+        \/\/ first connection to the server\n+        static boolean first = true;\n+\n+        Server() throws Exception {\n+            SSLContext sc = createServerSSLContext();\n+            ServerSocketFactory fac = sc.getServerSocketFactory();\n+            SSLServerSocket ssock = (SSLServerSocket) fac.createServerSocket(0);\n+            port = ssock.getLocalPort();\n+\n+            \/\/ Thread to allow multiple clients to connect\n+            new Thread(() -> {\n@@ -279,3 +222,9 @@\n-                    wait();\n-                } catch (InterruptedException ex) {\n-                    \/\/ do nothing\n+                    System.err.println(\"Server starting to accept\");\n+                    latch.countDown();\n+                    do {\n+                        threadPool.submit(new ServerThread(ssock.accept()));\n+                    } while (true);\n+                } catch (Exception ex) {\n+                    throw new AssertionError(\"Server Down\", ex);\n+                } finally {\n+                    threadPool.close();\n@@ -283,12 +232,1 @@\n-            }\n-            signal = false;\n-\n-            try {\n-                Thread.sleep(1000);\n-            } catch (InterruptedException ex) {\n-                \/\/ do nothing\n-            }\n-        }\n-        public synchronized void signal() {\n-            signal = true;\n-            notify();\n+            }).start();\n@@ -297,2 +235,2 @@\n-        public void run() {\n-            try {\n+        static class ServerThread implements Runnable {\n+            final SSLSocket sock;\n@@ -300,1 +238,5 @@\n-                SSLContext sc = createClientSSLContext();\n+            ServerThread(Socket s) {\n+                this.sock = (SSLSocket) s;\n+                System.err.println(\"(Server) client connection on port \" +\n+                    sock.getPort());\n+            }\n@@ -302,19 +244,48 @@\n-                waitForSignal();\n-                while (go) {\n-                    try {\n-                        SSLSocket sock = (SSLSocket)\n-                            sc.getSocketFactory().createSocket();\n-                        sock.connect(new InetSocketAddress(\"localhost\", port));\n-                        PrintWriter out = new PrintWriter(\n-                            new OutputStreamWriter(sock.getOutputStream()));\n-                        out.println(\"message\");\n-                        out.flush();\n-                        BufferedReader reader = new BufferedReader(\n-                            new InputStreamReader(sock.getInputStream()));\n-                        String inMsg = reader.readLine();\n-                        System.out.println(\"Client received: \" + inMsg);\n-                        out.close();\n-                        sock.close();\n-                        waitForSignal();\n-                    } catch (Exception ex) {\n-                        ex.printStackTrace();\n+            public void run() {\n+                try {\n+                    SSLParameters params = sock.getSSLParameters();\n+                    switch (testMode) {\n+                        case BASIC -> {}  \/\/ do nothing\n+                        case CLIENT_AUTH -> params.setNeedClientAuth(!first);\n+                        case VERSION_2_TO_3 -> params.setProtocols(new String[]{\n+                            first ? \"TLSv1.2\" : \"TLSv1.3\"});\n+                        case VERSION_3_TO_2 -> params.setProtocols(new String[]{\n+                            first ? \"TLSv1.3\" : \"TLSv1.2\"});\n+                        case CIPHER_SUITE -> params.setCipherSuites(\n+                            new String[]{\n+                                first ? \"TLS_AES_256_GCM_SHA384\" :\n+                                    \"TLS_AES_128_GCM_SHA256\"});\n+                        case SIGNATURE_SCHEME -> {\n+                            params.setNeedClientAuth(true);\n+                            params.setAlgorithmConstraints(new NoSig(\n+                                first ? \"ecdsa_secp521r1_sha512\" :\n+                                    \"ecdsa_secp384r1_sha384\"));\n+                        }\n+                        case LOCAL_CERTS -> {\n+                            if (!first) {\n+                                \/\/ Add first session's certificate signature\n+                                \/\/ algorithm to constraints so local certificates\n+                                \/\/ can't be restored from the session ticket.\n+                                params.setAlgorithmConstraints(\n+                                    new NoSig(X509CertImpl.toImpl(localCerts)\n+                                        .getSigAlgName()));\n+                            }\n+                        }\n+                        default ->\n+                            throw new AssertionError(\"unknown mode: \" +\n+                                testMode);\n+                    }\n+                    sock.setSSLParameters(params);\n+                    BufferedReader reader = new BufferedReader(\n+                        new InputStreamReader(sock.getInputStream()));\n+                    String line = reader.readLine();\n+                    System.err.println(\"server read: \" + line);\n+                    PrintWriter out = new PrintWriter(\n+                        new OutputStreamWriter(sock.getOutputStream()));\n+                    out.println(line);\n+                    out.flush();\n+                    out.close();\n+                    SSLSession session = sock.getSession();\n+                    if (testMode == TestMode.LOCAL_CERTS && first) {\n+                        localCerts = (X509CertImpl) session.\n+                            getLocalCertificates()[0];\n@@ -322,0 +293,4 @@\n+                    first = false;\n+                    System.err.println(\"server socket closed: \" + session);\n+                } catch (Exception e) {\n+                    throw new AssertionError(\"Server error\", e);\n@@ -323,2 +298,0 @@\n-            } catch (Exception ex) {\n-                throw new RuntimeException(ex);\n@@ -328,1 +301,1 @@\n-}\n+}\n\\ No newline at end of file\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/ResumeChecksServer.java","additions":151,"deletions":178,"binary":false,"changes":329,"status":"modified"}]}