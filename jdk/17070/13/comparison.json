{"files":[{"patch":"@@ -258,2 +258,3 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an implicitly ({@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED mandated}) declared parameter in addition to\n+     * explicitly declared ones.  Also note that compact constructors\n+     * of a record class may have implicitly ({@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED mandated}) declared parameters.\n@@ -264,0 +265,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -283,2 +285,3 @@\n-     * Also note that as a <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">modeling\n+     * Also note that compact constructors of a record class may have\n+     * implicitly ({@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED mandated}) declared parameters.\n+     * Finally note that as a <a href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">modeling\n@@ -288,2 +291,4 @@\n-     * present in the source will be returned; if generic information\n-     * is not present, implicit and synthetic parameters may be\n+     * present in the source will be returned. Note that for compact\n+     * constructors of a record class, its parameters which are implicitly\n+     * ({@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED mandated}) will be returned.\n+     * If generic information is not present, implicit and synthetic parameters may be\n@@ -294,1 +299,3 @@\n-     * the actual type arguments used in the source code.\n+     * the actual type arguments used in the source code. This assertion also\n+     * applies to the parameters of compact constructors of a record class\n+     * which are ({@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED mandated}).\n@@ -312,0 +319,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -340,2 +348,2 @@\n-                int fromidx = 0;\n-                for (int i = 0; i < out.length; i++) {\n+                int fromidx = genericParamTypes.length - 1;\n+                for (int i = out.length - 1; i >= 0; i--) {\n@@ -343,2 +351,2 @@\n-                    if (param.isSynthetic() || param.isImplicit()) {\n-                        \/\/ If we hit a synthetic or mandated parameter,\n+                    if (param.isSynthetic() || fromidx < 0) {\n+                        \/\/ If we hit a synthetic parameter or if we have already read all the elements from `genericParamTypes`,\n@@ -350,1 +358,1 @@\n-                        fromidx++;\n+                        fromidx--;\n@@ -751,2 +759,3 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an implicitly ({@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED mandated}) declared parameter in addition to\n+     * explicitly declared ones.  Also note that compact constructors of a\n+     * record class may have implicitly ({@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED mandated}) declared parameters.\n@@ -758,0 +767,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":24,"deletions":14,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320575\n+ * @summary reflection test for local classes constructors\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+import java.util.List;\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+public class LocalClassesTest {\n+    class LocalTest1 {\n+        void test() {\n+            class Local {\n+                public Local(List<String> ls) {}\n+                void t() {\n+                    System.err.println(LocalTest1.this);\n+                }\n+                void doTest() {\n+                    System.out.println(\"invoking test now\");\n+                    try {\n+                        LocalClassesTest.this.testReflection(\n+                                this,\n+                                new String[]{\"class LocalClassesTest$LocalTest1\", \"java.util.List<java.lang.String>\"},\n+                                new String[]{\"java.util.List<java.lang.String>\"}\n+                        );\n+                    } catch (Throwable t) {\n+                        throw new AssertionError(\"test failure: \" + t.getMessage());\n+                    }\n+                }\n+            }\n+            Local local = new Local(List.of(\"1\"));\n+            local.doTest();\n+            var anonymous = new Local(List.of(\"1\")) {\n+                @Override\n+                void doTest() {\n+                    System.out.println(\"invoking test now\");\n+                    try {\n+                        LocalClassesTest.this.testReflection(\n+                                this,\n+                                \/\/ there is no generic information generated for anonymous classes\n+                                new String[]{\"class LocalClassesTest$LocalTest1\", \"interface java.util.List\"},\n+                                new String[]{\"class LocalClassesTest$LocalTest1\", \"interface java.util.List\"}\n+                        );\n+                    } catch (Throwable t) {\n+                        throw new AssertionError(\"test failure: \" + t.getMessage());\n+                    }\n+                }\n+            };\n+            anonymous.doTest();\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        LocalClassesTest testClass = new LocalClassesTest();\n+        LocalTest1 localTest1 = testClass.new LocalTest1();\n+        localTest1.test();\n+    }\n+\n+    public void testReflection(Object object,\n+                               String[] allParamTypes,\n+                               String[] genericParamTypes)\n+            throws ReflectiveOperationException\n+    {\n+        System.out.println(\"at testReflection\");\n+        Class<?> klass = object.getClass();\n+        int i = 0;\n+        \/\/ let's check constructors\n+        var constructor = klass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for (var p: constructor.getParameters()) {\n+            System.out.println(\"got parameter \" + p.getParameterizedType().toString());\n+            Assert.check(p.getParameterizedType().toString().equals(allParamTypes[i]),\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), allParamTypes[i]));\n+            i++;\n+        }\n+        \/\/ similar as above but testing another API, only for generic params\n+        i = 0;\n+        for (var t : constructor.getGenericParameterTypes()) {\n+            System.out.println(\"got generic parameter \" + t.toString());\n+            Assert.check(t.toString().equals(genericParamTypes[i]),\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            t.toString(), genericParamTypes[i]));\n+            i++;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Constructor\/LocalClassesTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,259 @@\n+class R10 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Record\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"R10\"; \/\/ #10\n+    Utf8 \"ls\"; \/\/ #11\n+    Utf8 \"Ljava\/util\/List;\"; \/\/ #12\n+    InvokeDynamic 0s #14; \/\/ #13\n+    NameAndType #15 #16; \/\/ #14\n+    Utf8 \"toString\"; \/\/ #15\n+    Utf8 \"(LR10;)Ljava\/lang\/String;\"; \/\/ #16\n+    InvokeDynamic 0s #18; \/\/ #17\n+    NameAndType #19 #20; \/\/ #18\n+    Utf8 \"hashCode\"; \/\/ #19\n+    Utf8 \"(LR10;)I\"; \/\/ #20\n+    InvokeDynamic 0s #22; \/\/ #21\n+    NameAndType #23 #24; \/\/ #22\n+    Utf8 \"equals\"; \/\/ #23\n+    Utf8 \"(LR10;Ljava\/lang\/Object;)Z\"; \/\/ #24\n+    Utf8 \"Signature\"; \/\/ #25\n+    Utf8 \"Ljava\/util\/List<Ljava\/lang\/String;>;\"; \/\/ #26\n+    Utf8 \"(Ljava\/util\/List;)V\"; \/\/ #27\n+    Utf8 \"Code\"; \/\/ #28\n+    Utf8 \"LineNumberTable\"; \/\/ #29\n+    Utf8 \"MethodParameters\"; \/\/ #30\n+    Utf8 \"(Ljava\/util\/List<Ljava\/lang\/String;>;)V\"; \/\/ #31\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32\n+    Utf8 \"()I\"; \/\/ #33\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #34\n+    Utf8 \"()Ljava\/util\/List;\"; \/\/ #35\n+    Utf8 \"()Ljava\/util\/List<Ljava\/lang\/String;>;\"; \/\/ #36\n+    Utf8 \"SourceFile\"; \/\/ #37\n+    Utf8 \"R10.java\"; \/\/ #38\n+    Utf8 \"Record\"; \/\/ #39\n+    Utf8 \"BootstrapMethods\"; \/\/ #40\n+    MethodHandle 6b #42; \/\/ #41\n+    Method #43 #44; \/\/ #42\n+    class #45; \/\/ #43\n+    NameAndType #46 #47; \/\/ #44\n+    Utf8 \"java\/lang\/runtime\/ObjectMethods\"; \/\/ #45\n+    Utf8 \"bootstrap\"; \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/TypeDescriptor;Ljava\/lang\/Class;Ljava\/lang\/String;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/Object;\"; \/\/ #47\n+    String #11; \/\/ #48\n+    MethodHandle 1b #7; \/\/ #49\n+    Utf8 \"InnerClasses\"; \/\/ #50\n+    class #52; \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #52\n+    class #54; \/\/ #53\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #54\n+    Utf8 \"Lookup\"; \/\/ #55\n+  } \/\/ Constant Pool\n+\n+  0x0030; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0012; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Signature\n+          #26;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #27; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A2BB500;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#30) { \/\/ MethodParameters\n+          []b { \/\/ MethodParameters\n+            #11  0x0000; \/\/ the parameter is not mandated, flag should be 0x8000 for it to be mandated\n+          }\n+        } \/\/ end MethodParameters\n+        ;\n+        Attr(#25) { \/\/ Signature\n+          #31;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #15; \/\/ name_index\n+      #32; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA000D0000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #19; \/\/ name_index\n+      #33; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00110000AC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #23; \/\/ name_index\n+      #34; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2A2BBA00150000AC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #35; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#25) { \/\/ Signature\n+          #36;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#37) { \/\/ SourceFile\n+      #38;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#39) { \/\/ Record\n+      [] { \/\/ components\n+        {  \/\/ component\n+          #11; \/\/ name_index\n+          #12; \/\/ descriptor_index\n+          [] { \/\/ Attributes\n+            Attr(#25) { \/\/ Signature\n+              #26;\n+            } \/\/ end Signature\n+          } \/\/ Attributes\n+        }\n+      }\n+    } \/\/ end Record\n+    ;\n+    Attr(#40) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #41; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+            #8;\n+            #48;\n+            #49;\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#50) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #51 #53 #55 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class R10\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/R10.jcod","additions":259,"deletions":0,"binary":false,"changes":259,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8235369 8235550 8247444\n+ * @bug 8235369 8235550 8247444 8320575\n@@ -28,0 +28,1 @@\n+ * @build R10\n@@ -60,0 +61,4 @@\n+    record R9(List<String> ls) {\n+        R9 {} \/\/ compact constructor, will contain a mandated parameter\n+    }\n+\n@@ -69,1 +74,3 @@\n-                       R8.class)\n+                       R8.class,\n+                       R9.class,\n+                       R10.class)\n@@ -127,0 +134,13 @@\n+            new Object[] { new R9(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            \/* R10 has exactly the same definition as R9 but the parameter of the compact constructor doesn't have\n+             * the mandated flag, nevertheless we should be able to load the same generic information\n+             *\/\n+            new Object[] { new R10(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n@@ -152,0 +172,17 @@\n+        \/\/ now let's check constructors\n+        var constructor = recordClass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for (var p: constructor.getParameters()) {\n+            assertEquals(p.getParameterizedType().toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), signatures[i]));\n+            i++;\n+        }\n+        \/\/ similar as above but testing another API\n+        i = 0;\n+        for (var p : constructor.getGenericParameterTypes()) {\n+            assertEquals(p.toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.toString(), signatures[i]));\n+            i++;\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"}]}