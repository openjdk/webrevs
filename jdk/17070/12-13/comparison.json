{"files":[{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8320575\n+ * @summary reflection test for local classes constructors\n+ * @modules jdk.compiler\/com.sun.tools.javac.util\n+ *\/\n+\n+import java.lang.annotation.*;\n+import java.lang.reflect.*;\n+import java.util.List;\n+\n+import com.sun.tools.javac.util.Assert;\n+\n+public class LocalClassesTest {\n+    class LocalTest1 {\n+        void test() {\n+            class Local {\n+                public Local(List<String> ls) {}\n+                void t() {\n+                    System.err.println(LocalTest1.this);\n+                }\n+                void doTest() {\n+                    System.out.println(\"invoking test now\");\n+                    try {\n+                        LocalClassesTest.this.testReflection(\n+                                this,\n+                                new String[]{\"class LocalClassesTest$LocalTest1\", \"java.util.List<java.lang.String>\"},\n+                                new String[]{\"java.util.List<java.lang.String>\"}\n+                        );\n+                    } catch (Throwable t) {\n+                        throw new AssertionError(\"test failure: \" + t.getMessage());\n+                    }\n+                }\n+            }\n+            Local local = new Local(List.of(\"1\"));\n+            local.doTest();\n+            var anonymous = new Local(List.of(\"1\")) {\n+                @Override\n+                void doTest() {\n+                    System.out.println(\"invoking test now\");\n+                    try {\n+                        LocalClassesTest.this.testReflection(\n+                                this,\n+                                \/\/ there is no generic information generated for anonymous classes\n+                                new String[]{\"class LocalClassesTest$LocalTest1\", \"interface java.util.List\"},\n+                                new String[]{\"class LocalClassesTest$LocalTest1\", \"interface java.util.List\"}\n+                        );\n+                    } catch (Throwable t) {\n+                        throw new AssertionError(\"test failure: \" + t.getMessage());\n+                    }\n+                }\n+            };\n+            anonymous.doTest();\n+        }\n+    }\n+\n+    public static void main(String... args) {\n+        LocalClassesTest testClass = new LocalClassesTest();\n+        LocalTest1 localTest1 = testClass.new LocalTest1();\n+        localTest1.test();\n+    }\n+\n+    public void testReflection(Object object,\n+                               String[] allParamTypes,\n+                               String[] genericParamTypes)\n+            throws ReflectiveOperationException\n+    {\n+        System.out.println(\"at testReflection\");\n+        Class<?> klass = object.getClass();\n+        int i = 0;\n+        \/\/ let's check constructors\n+        var constructor = klass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for (var p: constructor.getParameters()) {\n+            System.out.println(\"got parameter \" + p.getParameterizedType().toString());\n+            Assert.check(p.getParameterizedType().toString().equals(allParamTypes[i]),\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), allParamTypes[i]));\n+            i++;\n+        }\n+        \/\/ similar as above but testing another API, only for generic params\n+        i = 0;\n+        for (var t : constructor.getGenericParameterTypes()) {\n+            System.out.println(\"got generic parameter \" + t.toString());\n+            Assert.check(t.toString().equals(genericParamTypes[i]),\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            t.toString(), genericParamTypes[i]));\n+            i++;\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Constructor\/LocalClassesTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -181,0 +181,8 @@\n+        \/\/ similar as above but testing another API\n+        i = 0;\n+        for (var p : constructor.getGenericParameterTypes()) {\n+            assertEquals(p.toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.toString(), signatures[i]));\n+            i++;\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}