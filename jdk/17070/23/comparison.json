{"files":[{"patch":"@@ -258,2 +258,6 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameter in addition to explicitly\n+     * declared ones.\n+     * Also note that compact constructors of a record class may have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters.\n@@ -264,0 +268,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -283,3 +288,7 @@\n-     * Also note that as a <a\n-     * href=\"{@docRoot}\/java.base\/java\/lang\/reflect\/package-summary.html#LanguageJvmModel\">modeling\n-     * artifact<\/a>, the number of returned parameters can differ\n+     * Compact constructors of a record class may also have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters,\n+     * but they are a special case and thus considered as if they had\n+     * been explicitly declared in the source.\n+     * Finally note that as a {@link java.lang.reflect##LanguageJvmModel\n+     * modeling artifact}, the number of returned parameters can differ\n@@ -287,3 +296,9 @@\n-     * generic information is present, only parameters explicitly\n-     * present in the source will be returned; if generic information\n-     * is not present, implicit and synthetic parameters may be\n+     * generic information is present, parameters explicitly\n+     * present in the source or parameters of compact constructors\n+     * of a record class will be returned.\n+     * Note that parameters of compact constructors of a record class are a special case,\n+     * as they are not explicitly present in the source, and its type will be returned\n+     * regardless of the parameters being\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} or not.\n+     * If generic information is not present, implicit and synthetic parameters may be\n@@ -294,1 +309,5 @@\n-     * the actual type arguments used in the source code.\n+     * the actual type arguments used in the source code. This assertion also\n+     * applies to the parameters of compact constructors of a record class,\n+     * independently of them being\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} or not.\n@@ -312,0 +331,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n@@ -338,9 +358,7 @@\n-                final Type[] out = new Type[nonGenericParamTypes.length];\n-                final Parameter[] params = getParameters();\n-                int fromidx = 0;\n-                for (int i = 0; i < out.length; i++) {\n-                    final Parameter param = params[i];\n-                    if (param.isSynthetic() || param.isImplicit()) {\n-                        \/\/ If we hit a synthetic or mandated parameter,\n-                        \/\/ use the non generic parameter info.\n-                        out[i] = nonGenericParamTypes[i];\n+                if (getDeclaringClass().isRecord() && this instanceof Constructor) {\n+                    \/* we could be seeing a compact constructor of a record class\n+                     * its parameters are mandated but we should be able to retrieve\n+                     * its generic information if present\n+                     *\/\n+                    if (genericParamTypes.length == nonGenericParamTypes.length) {\n+                        return genericParamTypes;\n@@ -348,3 +366,1 @@\n-                        \/\/ Otherwise, use the generic parameter info.\n-                        out[i] = genericParamTypes[fromidx];\n-                        fromidx++;\n+                        return nonGenericParamTypes.clone();\n@@ -352,0 +368,17 @@\n+                } else {\n+                    final Type[] out = new Type[nonGenericParamTypes.length];\n+                    final Parameter[] params = getParameters();\n+                    int fromidx = 0;\n+                    for (int i = 0; i < out.length; i++) {\n+                        final Parameter param = params[i];\n+                        if (param.isSynthetic() || param.isImplicit()) {\n+                            \/\/ If we hit a synthetic or mandated parameter,\n+                            \/\/ use the non generic parameter info.\n+                            out[i] = nonGenericParamTypes[i];\n+                        } else {\n+                            \/\/ Otherwise, use the generic parameter info.\n+                            out[i] = genericParamTypes[fromidx];\n+                            fromidx++;\n+                        }\n+                    }\n+                    return out;\n@@ -353,1 +386,0 @@\n-                return out;\n@@ -751,2 +783,6 @@\n-     * may have an implicitly declared parameter in addition to\n-     * explicitly declared ones.\n+     * may have an\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameter in addition to explicitly declared ones.\n+     * Also note that compact constructors of a record class may have\n+     * {@linkplain java.compiler\/javax.lang.model.util.Elements.Origin#MANDATED\n+     * implicitly declared} parameters.\n@@ -758,0 +794,1 @@\n+    @SuppressWarnings(\"doclint:reference\") \/\/ cross-module links\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":61,"deletions":24,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -0,0 +1,262 @@\n+\/\/ this record is defined as:\n+\/\/     record R10(List<String> ls) { \/\/ there is no compact constructor and thus there is no mandated param\n+\/\/     }\n+class R10 {\n+  0xCAFEBABE;\n+  0; \/\/ minor version\n+  64; \/\/ version\n+  [] { \/\/ Constant Pool\n+    ; \/\/ first element is empty\n+    Method #2 #3; \/\/ #1\n+    class #4; \/\/ #2\n+    NameAndType #5 #6; \/\/ #3\n+    Utf8 \"java\/lang\/Record\"; \/\/ #4\n+    Utf8 \"<init>\"; \/\/ #5\n+    Utf8 \"()V\"; \/\/ #6\n+    Field #8 #9; \/\/ #7\n+    class #10; \/\/ #8\n+    NameAndType #11 #12; \/\/ #9\n+    Utf8 \"R10\"; \/\/ #10\n+    Utf8 \"ls\"; \/\/ #11\n+    Utf8 \"Ljava\/util\/List;\"; \/\/ #12\n+    InvokeDynamic 0s #14; \/\/ #13\n+    NameAndType #15 #16; \/\/ #14\n+    Utf8 \"toString\"; \/\/ #15\n+    Utf8 \"(LR10;)Ljava\/lang\/String;\"; \/\/ #16\n+    InvokeDynamic 0s #18; \/\/ #17\n+    NameAndType #19 #20; \/\/ #18\n+    Utf8 \"hashCode\"; \/\/ #19\n+    Utf8 \"(LR10;)I\"; \/\/ #20\n+    InvokeDynamic 0s #22; \/\/ #21\n+    NameAndType #23 #24; \/\/ #22\n+    Utf8 \"equals\"; \/\/ #23\n+    Utf8 \"(LR10;Ljava\/lang\/Object;)Z\"; \/\/ #24\n+    Utf8 \"Signature\"; \/\/ #25\n+    Utf8 \"Ljava\/util\/List<Ljava\/lang\/String;>;\"; \/\/ #26\n+    Utf8 \"(Ljava\/util\/List;)V\"; \/\/ #27\n+    Utf8 \"Code\"; \/\/ #28\n+    Utf8 \"LineNumberTable\"; \/\/ #29\n+    Utf8 \"MethodParameters\"; \/\/ #30\n+    Utf8 \"(Ljava\/util\/List<Ljava\/lang\/String;>;)V\"; \/\/ #31\n+    Utf8 \"()Ljava\/lang\/String;\"; \/\/ #32\n+    Utf8 \"()I\"; \/\/ #33\n+    Utf8 \"(Ljava\/lang\/Object;)Z\"; \/\/ #34\n+    Utf8 \"()Ljava\/util\/List;\"; \/\/ #35\n+    Utf8 \"()Ljava\/util\/List<Ljava\/lang\/String;>;\"; \/\/ #36\n+    Utf8 \"SourceFile\"; \/\/ #37\n+    Utf8 \"R10.java\"; \/\/ #38\n+    Utf8 \"Record\"; \/\/ #39\n+    Utf8 \"BootstrapMethods\"; \/\/ #40\n+    MethodHandle 6b #42; \/\/ #41\n+    Method #43 #44; \/\/ #42\n+    class #45; \/\/ #43\n+    NameAndType #46 #47; \/\/ #44\n+    Utf8 \"java\/lang\/runtime\/ObjectMethods\"; \/\/ #45\n+    Utf8 \"bootstrap\"; \/\/ #46\n+    Utf8 \"(Ljava\/lang\/invoke\/MethodHandles$Lookup;Ljava\/lang\/String;Ljava\/lang\/invoke\/TypeDescriptor;Ljava\/lang\/Class;Ljava\/lang\/String;[Ljava\/lang\/invoke\/MethodHandle;)Ljava\/lang\/Object;\"; \/\/ #47\n+    String #11; \/\/ #48\n+    MethodHandle 1b #7; \/\/ #49\n+    Utf8 \"InnerClasses\"; \/\/ #50\n+    class #52; \/\/ #51\n+    Utf8 \"java\/lang\/invoke\/MethodHandles$Lookup\"; \/\/ #52\n+    class #54; \/\/ #53\n+    Utf8 \"java\/lang\/invoke\/MethodHandles\"; \/\/ #54\n+    Utf8 \"Lookup\"; \/\/ #55\n+  } \/\/ Constant Pool\n+\n+  0x0030; \/\/ access\n+  #8;\/\/ this_cpx\n+  #2;\/\/ super_cpx\n+\n+  [] { \/\/ Interfaces\n+  } \/\/ Interfaces\n+\n+  [] { \/\/ Fields\n+    {  \/\/ field\n+      0x0012; \/\/ access\n+      #11; \/\/ name_index\n+      #12; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#25) { \/\/ Signature\n+          #26;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Fields\n+\n+  [] { \/\/ Methods\n+    {  \/\/ method\n+      0x0000; \/\/ access\n+      #5; \/\/ name_index\n+      #27; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB700012A2BB500;\n+            0x07B1;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  4;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#30) { \/\/ MethodParameters\n+          []b { \/\/ MethodParameters\n+            #11  0x0000; \/\/ the parameter is not mandated, flag should be 0x8000 for it to be mandated\n+          }\n+        } \/\/ end MethodParameters\n+        ;\n+        Attr(#25) { \/\/ Signature\n+          #31;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #15; \/\/ name_index\n+      #32; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA000D0000B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #19; \/\/ name_index\n+      #33; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2ABA00110000AC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0011; \/\/ access\n+      #23; \/\/ name_index\n+      #34; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          2; \/\/ max_stack\n+          2; \/\/ max_locals\n+          Bytes[]{\n+            0x2A2BBA00150000AC;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+      } \/\/ Attributes\n+    }\n+    ;\n+    {  \/\/ method\n+      0x0001; \/\/ access\n+      #11; \/\/ name_index\n+      #35; \/\/ descriptor_index\n+      [] { \/\/ Attributes\n+        Attr(#28) { \/\/ Code\n+          1; \/\/ max_stack\n+          1; \/\/ max_locals\n+          Bytes[]{\n+            0x2AB40007B0;\n+          }\n+          [] { \/\/ Traps\n+          } \/\/ end Traps\n+          [] { \/\/ Attributes\n+            Attr(#29) { \/\/ LineNumberTable\n+              [] { \/\/ line_number_table\n+                0  3;\n+              }\n+            } \/\/ end LineNumberTable\n+          } \/\/ Attributes\n+        } \/\/ end Code\n+        ;\n+        Attr(#25) { \/\/ Signature\n+          #36;\n+        } \/\/ end Signature\n+      } \/\/ Attributes\n+    }\n+  } \/\/ Methods\n+\n+  [] { \/\/ Attributes\n+    Attr(#37) { \/\/ SourceFile\n+      #38;\n+    } \/\/ end SourceFile\n+    ;\n+    Attr(#39) { \/\/ Record\n+      [] { \/\/ components\n+        {  \/\/ component\n+          #11; \/\/ name_index\n+          #12; \/\/ descriptor_index\n+          [] { \/\/ Attributes\n+            Attr(#25) { \/\/ Signature\n+              #26;\n+            } \/\/ end Signature\n+          } \/\/ Attributes\n+        }\n+      }\n+    } \/\/ end Record\n+    ;\n+    Attr(#40) { \/\/ BootstrapMethods\n+      [] { \/\/ bootstrap_methods\n+        {  \/\/  bootstrap_method\n+          #41; \/\/ bootstrap_method_ref\n+          [] { \/\/ bootstrap_arguments\n+            #8;\n+            #48;\n+            #49;\n+          }  \/\/  bootstrap_arguments\n+        }  \/\/  bootstrap_method\n+      }\n+    } \/\/ end BootstrapMethods\n+    ;\n+    Attr(#50) { \/\/ InnerClasses\n+      [] { \/\/ classes\n+        #51 #53 #55 25;\n+      }\n+    } \/\/ end InnerClasses\n+  } \/\/ Attributes\n+} \/\/ end class R10\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/R10.jcod","additions":262,"deletions":0,"binary":false,"changes":262,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8235369 8235550 8247444\n+ * @bug 8235369 8235550 8247444 8320575\n@@ -28,0 +28,1 @@\n+ * @build R10\n@@ -60,0 +61,21 @@\n+    record R9(List<String> ls) {\n+        R9 {} \/\/ compact constructor, will contain a mandated parameter\n+    }\n+\n+    \/* record R10 is defined in an accompaning jcod file, defined as:\n+    record R10(List<String> ls) { \/\/ in this case there wasn't be any compact constructor and thus no mandated param\n+    }\n+    *\/\n+\n+    record R11(int i, List<String> ls) {\n+        R11 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R12(List<String> ls, int i) {\n+        R12 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n+    record R13(List<String> ls1, int i, List<String> ls2) {\n+        R13 {} \/\/ compact constructor, will contain mandated parameters\n+    }\n+\n@@ -69,2 +91,7 @@\n-                       R8.class)\n-                   .stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n+                       R8.class,\n+                       R9.class,\n+                       R10.class,\n+                       R11.class,\n+                       R12.class,\n+                       R13.class\n+        ).stream().map(c -> new Object[] {c}).toArray(Object[][]::new);\n@@ -127,0 +154,28 @@\n+            new Object[] { new R9(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            \/* R10 has exactly the same definition as R9 but the parameter of the compact constructor doesn't have\n+             * the mandated flag, nevertheless we should be able to load the same generic information\n+             *\/\n+            new Object[] { new R10(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R11(1, List.of(\"1\")),\n+                        2,\n+                        new Object[]{ 1, List.of(\"1\") },\n+                        new String[]{ \"i\", \"ls\" },\n+                        new String[]{ \"int\", \"java.util.List<java.lang.String>\"} },\n+            new Object[] { new R12(List.of(\"1\"), 1),\n+                        2,\n+                        new Object[]{ List.of(\"1\"), 1 },\n+                        new String[]{ \"ls\", \"i\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\"} },\n+            new Object[] { new R13(List.of(\"1\"), 1, List.of(\"2\")),\n+                        3,\n+                        new Object[]{ List.of(\"1\"), 1, List.of(\"2\") },\n+                        new String[]{ \"ls1\", \"i\", \"ls2\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\", \"int\", \"java.util.List<java.lang.String>\"} },\n@@ -152,0 +207,17 @@\n+        \/\/ now let's check constructors\n+        var constructor = recordClass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for (var p: constructor.getParameters()) {\n+            assertEquals(p.getParameterizedType().toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), signatures[i]));\n+            i++;\n+        }\n+        \/\/ similar as above but testing another API\n+        i = 0;\n+        for (var p : constructor.getGenericParameterTypes()) {\n+            assertEquals(p.toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.toString(), signatures[i]));\n+            i++;\n+        }\n@@ -204,1 +276,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":76,"deletions":5,"binary":false,"changes":81,"status":"modified"}]}