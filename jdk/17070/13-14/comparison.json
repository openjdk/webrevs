{"files":[{"patch":"@@ -348,11 +348,30 @@\n-                int fromidx = genericParamTypes.length - 1;\n-                for (int i = out.length - 1; i >= 0; i--) {\n-                    final Parameter param = params[i];\n-                    if (param.isSynthetic() || fromidx < 0) {\n-                        \/\/ If we hit a synthetic parameter or if we have already read all the elements from `genericParamTypes`,\n-                        \/\/ use the non generic parameter info.\n-                        out[i] = nonGenericParamTypes[i];\n-                    } else {\n-                        \/\/ Otherwise, use the generic parameter info.\n-                        out[i] = genericParamTypes[fromidx];\n-                        fromidx--;\n+                if (getDeclaringClass().isRecord() && this instanceof Constructor) {\n+                    \/* we could be seeing a compact constructor of a record class\n+                     * its parameters are mandated but we should be able to retrieve\n+                     * its generic information if present\n+                     *\/\n+                    int fromidx = genericParamTypes.length - 1;\n+                    for (int i = out.length - 1; i >= 0; i--) {\n+                        if (fromidx < 0) {\n+                            \/\/ If we hit a synthetic parameter or if we have already read all the elements from `genericParamTypes`,\n+                            \/\/ use the non generic parameter info.\n+                            out[i] = nonGenericParamTypes[i];\n+                        } else {\n+                            \/\/ Otherwise, use the generic parameter info.\n+                            out[i] = genericParamTypes[fromidx];\n+                            fromidx--;\n+                        }\n+                    }\n+                } else {\n+                    int fromidx = 0;\n+                    for (int i = 0; i < out.length; i++) {\n+                        final Parameter param = params[i];\n+                        if (param.isSynthetic() || param.isImplicit()) {\n+                            \/\/ If we hit a synthetic or mandated parameter,\n+                            \/\/ use the non generic parameter info.\n+                            out[i] = nonGenericParamTypes[i];\n+                        } else {\n+                            \/\/ Otherwise, use the generic parameter info.\n+                            out[i] = genericParamTypes[fromidx];\n+                            fromidx++;\n+                        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":30,"deletions":11,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -1,114 +0,0 @@\n-\/*\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8320575\n- * @summary reflection test for local classes constructors\n- * @modules jdk.compiler\/com.sun.tools.javac.util\n- *\/\n-\n-import java.lang.annotation.*;\n-import java.lang.reflect.*;\n-import java.util.List;\n-\n-import com.sun.tools.javac.util.Assert;\n-\n-public class LocalClassesTest {\n-    class LocalTest1 {\n-        void test() {\n-            class Local {\n-                public Local(List<String> ls) {}\n-                void t() {\n-                    System.err.println(LocalTest1.this);\n-                }\n-                void doTest() {\n-                    System.out.println(\"invoking test now\");\n-                    try {\n-                        LocalClassesTest.this.testReflection(\n-                                this,\n-                                new String[]{\"class LocalClassesTest$LocalTest1\", \"java.util.List<java.lang.String>\"},\n-                                new String[]{\"java.util.List<java.lang.String>\"}\n-                        );\n-                    } catch (Throwable t) {\n-                        throw new AssertionError(\"test failure: \" + t.getMessage());\n-                    }\n-                }\n-            }\n-            Local local = new Local(List.of(\"1\"));\n-            local.doTest();\n-            var anonymous = new Local(List.of(\"1\")) {\n-                @Override\n-                void doTest() {\n-                    System.out.println(\"invoking test now\");\n-                    try {\n-                        LocalClassesTest.this.testReflection(\n-                                this,\n-                                \/\/ there is no generic information generated for anonymous classes\n-                                new String[]{\"class LocalClassesTest$LocalTest1\", \"interface java.util.List\"},\n-                                new String[]{\"class LocalClassesTest$LocalTest1\", \"interface java.util.List\"}\n-                        );\n-                    } catch (Throwable t) {\n-                        throw new AssertionError(\"test failure: \" + t.getMessage());\n-                    }\n-                }\n-            };\n-            anonymous.doTest();\n-        }\n-    }\n-\n-    public static void main(String... args) {\n-        LocalClassesTest testClass = new LocalClassesTest();\n-        LocalTest1 localTest1 = testClass.new LocalTest1();\n-        localTest1.test();\n-    }\n-\n-    public void testReflection(Object object,\n-                               String[] allParamTypes,\n-                               String[] genericParamTypes)\n-            throws ReflectiveOperationException\n-    {\n-        System.out.println(\"at testReflection\");\n-        Class<?> klass = object.getClass();\n-        int i = 0;\n-        \/\/ let's check constructors\n-        var constructor = klass.getDeclaredConstructors()[0];\n-        i = 0;\n-        for (var p: constructor.getParameters()) {\n-            System.out.println(\"got parameter \" + p.getParameterizedType().toString());\n-            Assert.check(p.getParameterizedType().toString().equals(allParamTypes[i]),\n-                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n-                            p.getType().toString(), allParamTypes[i]));\n-            i++;\n-        }\n-        \/\/ similar as above but testing another API, only for generic params\n-        i = 0;\n-        for (var t : constructor.getGenericParameterTypes()) {\n-            System.out.println(\"got generic parameter \" + t.toString());\n-            Assert.check(t.toString().equals(genericParamTypes[i]),\n-                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n-                            t.toString(), genericParamTypes[i]));\n-            i++;\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Constructor\/LocalClassesTest.java","additions":0,"deletions":114,"binary":false,"changes":114,"status":"deleted"}]}