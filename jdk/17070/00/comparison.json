{"files":[{"patch":"@@ -259,1 +259,2 @@\n-     * explicitly declared ones.\n+     * explicitly declared ones.  Also compact constructors of a\n+     * record class may have implicitly declared parameters.\n@@ -280,4 +281,1 @@\n-     * underlying executable takes no parameters.  Note that the\n-     * constructors of some inner classes may have an implicitly\n-     * declared parameter in addition to explicitly declared ones.\n-     * Also note that as a <a\n+     * underlying executable takes no parameters.  Note that as a <a\n@@ -288,2 +286,2 @@\n-     * present in the source will be returned; if generic information\n-     * is not present, implicit and synthetic parameters may be\n+     * present in the source and mandated parameters will be returned;\n+     * if generic information is not present, synthetic parameters may be\n@@ -294,1 +292,1 @@\n-     * the actual type arguments used in the source code.\n+     * the actual type arguments used, explicitly or implicitly, in the source code.\n@@ -340,2 +338,2 @@\n-                int fromidx = 0;\n-                for (int i = 0; i < out.length; i++) {\n+                int fromidx = genericParamTypes.length - 1;\n+                for (int i = out.length - 1; i >= 0; i--) {\n@@ -343,2 +341,2 @@\n-                    if (param.isSynthetic() || param.isImplicit()) {\n-                        \/\/ If we hit a synthetic or mandated parameter,\n+                    if (param.isSynthetic()) {\n+                        \/\/ If we hit a synthetic parameter,\n@@ -347,0 +345,7 @@\n+                    } else if (param.isImplicit()) { \/\/ mandated\n+                        if (fromidx >= 0) {\n+                            out[i] = genericParamTypes[fromidx]; \/\/ I think that this array will have to have nulls for the spaces for which there is no info\n+                            fromidx--;\n+                        } else {\n+                            out[i] = nonGenericParamTypes[i];\n+                        }\n@@ -350,1 +355,1 @@\n-                        fromidx++;\n+                        fromidx--;\n@@ -752,1 +757,2 @@\n-     * explicitly declared ones.\n+     * explicitly declared ones.  Also compact constructors of a\n+     * record class may have implicitly declared parameters.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Executable.java","additions":20,"deletions":14,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8235369 8235550 8247444\n+ * @bug 8235369 8235550 8247444 8320575\n@@ -60,0 +60,4 @@\n+    record R9(List<String> ls) {\n+        R9 {} \/\/ compact constructor, will contain a mandated parameter\n+    }\n+\n@@ -69,1 +73,2 @@\n-                       R8.class)\n+                       R8.class,\n+                       R9.class)\n@@ -127,0 +132,5 @@\n+            new Object[] { new R9(List.of(\"1\")),\n+                        1,\n+                        new Object[]{ List.of(\"1\") },\n+                        new String[]{ \"ls\" },\n+                        new String[]{ \"java.util.List<java.lang.String>\"} },\n@@ -152,0 +162,9 @@\n+        \/\/ now let's check constructors\n+        var constructor = recordClass.getDeclaredConstructors()[0];\n+        i = 0;\n+        for(var p: constructor.getParameters()) {\n+            assertEquals(p.getParameterizedType().toString(), signatures[i],\n+                    String.format(\"signature of method \\\"%s\\\" different from expected signature \\\"%s\\\"\",\n+                            p.getType().toString(), signatures[i]));\n+            i++;\n+        }\n","filename":"test\/jdk\/java\/lang\/reflect\/records\/RecordReflectionTest.java","additions":22,"deletions":3,"binary":false,"changes":25,"status":"modified"}]}