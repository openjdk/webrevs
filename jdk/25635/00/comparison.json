{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -63,0 +63,4 @@\n+\n+    \/\/ entry's LOC offset as noted in the entry's central header, -1 implies undetermined\n+    long locOffset = -1;\n+\n@@ -141,0 +145,1 @@\n+        locOffset = e.locOffset;\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipEntry.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -344,1 +344,1 @@\n-            in = new ZipFileInputStream(zsrc.cen, pos);\n+            in = new ZipFileInputStream(zsrc.cen, pos, entry.locOffset);\n@@ -656,0 +656,1 @@\n+        e.locOffset = CENOFF(cen, pos);\n@@ -850,1 +851,8 @@\n-        ZipFileInputStream(byte[] cen, int cenpos) {\n+        \/**\n+         * @param cen       the ZIP's CEN\n+         * @param cenpos    the entry's offset within the CEN\n+         * @param locOffset the entry's LOC offset in the ZIP stream. If -1 is passed\n+         *                  then the LOC offset for the entry will be read from the\n+         *                  entry's central header\n+         *\/\n+        ZipFileInputStream(byte[] cen, int cenpos, long locOffset) {\n@@ -853,1 +861,5 @@\n-            pos = CENOFF(cen, cenpos);\n+            if (locOffset == -1) {\n+                pos = CENOFF(cen, cenpos);\n+            } else {\n+                pos = locOffset;\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/zip\/ZipFile.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,216 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HexFormat;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+import java.util.zip.ZipOutputStream;\n+\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.nio.ByteOrder.LITTLE_ENDIAN;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+\n+\/*\n+ * @test\n+ * @bug 8349914\n+ * @summary Validate ZipFile::getFileInputStream returns the correct data when\n+ *          there are multiple entries with the same filename\n+ * @run junit DupEntriesGetInputStream\n+ *\/\n+class DupEntriesGetInputStream {\n+\n+    \/\/ created through a call to createNormalZIP()\n+    private static final String NORMAL_ZIP_CONTENT_HEX = \"\"\"\n+            504b03041400080808009195c35a00000000000000000000000006000000456e747279310bc9c8\n+            2c560022d7bc92a24a054300504b07089bc0e55b0f0000000f000000504b030414000808080091\n+            95c35a00000000000000000000000006000000456e747279320bc9c82c560022d7bc92a24a85bc\n+            d2dca4d4228590f27c00504b0708ebda8deb1800000018000000504b03041400080808009195c3\n+            5a00000000000000000000000006000000456e747279330bc9c82c560022d7bc92a24a05650563\n+            00504b0708d1eafe7d1100000011000000504b010214001400080808009195c35a9bc0e55b0f00\n+            00000f000000060000000000000000000000000000000000456e74727931504b01021400140008\n+            0808009195c35aebda8deb1800000018000000060000000000000000000000000043000000456e\n+            74727932504b010214001400080808009195c35ad1eafe7d110000001100000006000000000000\n+            000000000000008f000000456e74727933504b050600000000030003009c000000d40000000000\n+            \"\"\";\n+\n+    \/\/ intentionally unused but left here to allow for constructing newer\/updated\n+    \/\/ NORMAL_ZIP_CONTENT_HEX, when necessary\n+    private static String createNormalZIP() throws IOException {\n+        final ByteArrayOutputStream zipContent = new ByteArrayOutputStream();\n+        try (ZipOutputStream zos = new ZipOutputStream(zipContent)) {\n+            zos.putNextEntry(new ZipEntry(ENTRY1_NAME));\n+            zos.write(ENTRY1.getBytes(US_ASCII));\n+            zos.putNextEntry(new ZipEntry(ENTRY2_NAME));\n+            zos.write(ENTRY2.getBytes(US_ASCII));\n+            zos.putNextEntry(new ZipEntry(ENTRY3_NAME));\n+            zos.write(ENTRY3.getBytes(US_ASCII));\n+        }\n+        return HexFormat.of().formatHex(zipContent.toByteArray());\n+    }\n+\n+    \/\/ Entry Names and their data to be added to the ZIP File\n+    private static final String ENTRY1_NAME = \"Entry1\";\n+    private static final String ENTRY1 = \"This is Entry 1\";\n+\n+    private static final String ENTRY2_NAME = \"Entry2\";\n+    private static final String ENTRY2 = \"This is Entry number Two\";\n+\n+    private static final String ENTRY3_NAME = \"Entry3\";\n+    private static final String ENTRY3 = \"This is Entry # 3\";\n+\n+    \/\/ ZIP entry and its expected data\n+    record ZIP_ENTRY(String entryName, String data) {\n+    }\n+\n+    private static final ZIP_ENTRY[] ZIP_ENTRIES = new ZIP_ENTRY[]{\n+            new ZIP_ENTRY(ENTRY1_NAME, ENTRY1),\n+            new ZIP_ENTRY(ENTRY2_NAME, ENTRY2),\n+            new ZIP_ENTRY(ENTRY1_NAME, ENTRY3)\n+    };\n+\n+    private static Path dupEntriesZipFile;\n+\n+    \/\/ 008F LOCAL HEADER #3       04034B50\n+    \/\/ ...\n+    \/\/ 00A1 Compressed Length     00000000\n+    \/\/ 00A5 Uncompressed Length   00000000\n+    \/\/ 00A9 Filename Length       0006\n+    \/\/ ...\n+    \/\/ 00AD Filename              'Entry3'\n+    private static final int ENTRY3_FILENAME_LOC_OFFSET = 0x00AD;\n+\n+    \/\/ 013C CENTRAL HEADER #3     02014B50\n+    \/\/ ...\n+    \/\/ 0150 Compressed Length     00000011\n+    \/\/ 0154 Uncompressed Length   00000011\n+    \/\/ 0158 Filename Length       0006\n+    \/\/ ...\n+    \/\/ 016A Filename              'Entry3'\n+    private static final int ENTRY3_FILENAME_CEN_OFFSET = 0x016A;\n+\n+    @BeforeAll\n+    static void createDupEntriesZIP() throws Exception {\n+        final byte[] originalZIPContent = HexFormat.of().parseHex(\n+                NORMAL_ZIP_CONTENT_HEX.replace(\"\\n\", \"\"));\n+        final ByteBuffer buf = ByteBuffer.wrap(originalZIPContent).order(LITTLE_ENDIAN);\n+        \/\/ replace the file name literal \"Entry3\" with the literal \"Entry1\", both in the\n+        \/\/ LOC header and the CEN of Entry3\n+        final int locEntry3LastCharOffset = ENTRY3_FILENAME_LOC_OFFSET + ENTRY3_NAME.length() - 1;\n+        buf.put(locEntry3LastCharOffset, (byte) 49); \/\/ 49 represents the character \"1\"\n+        final int cenEntry3LastCharOffset = ENTRY3_FILENAME_CEN_OFFSET + ENTRY3_NAME.length() - 1;\n+        buf.put(cenEntry3LastCharOffset, (byte) 49); \/\/ 49 represents the character \"1\"\n+        buf.rewind();\n+        \/\/ write out the manipulated ZIP content, containing duplicate entries, into a file\n+        \/\/ so that it can be read using ZipFile\n+        dupEntriesZipFile = Files.createTempFile(Path.of(\".\"), \"8349914-\", \".zip\");\n+        Files.write(dupEntriesZipFile, buf.array());\n+        System.out.println(\"created ZIP file with duplicate entries at \" + dupEntriesZipFile);\n+    }\n+\n+    \/*\n+     * Validate that the correct ZipEntry data is returned when a List is used\n+     * to access entries returned from ZipFile::entries\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void testUsingListEntries() throws IOException {\n+        System.out.println(\"Processing entries via Collections.list()\");\n+        try (ZipFile zf = new ZipFile(dupEntriesZipFile.toFile())) {\n+            var entryNumber = 0;\n+            for (var e : Collections.list(zf.entries())) {\n+                verifyEntry(entryNumber++, zf, e);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Validate that the correct ZipEntry data is returned when a ZipEntryIterator\n+     * is used to access entries returned from ZipFile::entries\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void testUsingZipEntryIterator() throws IOException {\n+        System.out.println(\"Processing entries via a ZipEntryIterator\");\n+        try (ZipFile zf = new ZipFile(dupEntriesZipFile.toFile())) {\n+            Enumeration<? extends ZipEntry> entries = zf.entries();\n+            var entryNumber = 0;\n+            while (entries.hasMoreElements()) {\n+                ZipEntry entry = entries.nextElement();\n+                verifyEntry(entryNumber++, zf, entry);\n+            }\n+        }\n+    }\n+\n+    \/*\n+     * Validate that the correct ZipEntry data is returned when a EntrySpliterator\n+     * is used to access entries returned from ZipFile::stream\n+     *\n+     * @throws IOException if an error occurs\n+     *\/\n+    @Test\n+    public void testUsingEntrySpliterator() throws IOException {\n+        System.out.println(\"Processing entries via a EntrySpliterator\");\n+        AtomicInteger eNumber = new AtomicInteger(0);\n+        try (ZipFile zf = new ZipFile(dupEntriesZipFile.toFile())) {\n+            zf.stream().forEach(e -> {\n+                try {\n+                    verifyEntry(eNumber.getAndIncrement(), zf, e);\n+                } catch (Exception ex) {\n+                    throw new RuntimeException(ex);\n+                }\n+            });\n+        }\n+    }\n+\n+    \/*\n+     * Verify the ZipEntry returned matches what is expected\n+     *\n+     * @param entryNumber offset into ZIP_ENTRIES containing the expected value\n+     *                    to be returned\n+     * @param zf          ZipFile containing the entry\n+     * @param e           ZipEntry to validate\n+     * @throws IOException\n+     *\/\n+    private static void verifyEntry(int entryNumber, ZipFile zf, ZipEntry e) throws IOException {\n+        System.out.println(\"Validating Entry: \" + entryNumber);\n+        assertEquals(ZIP_ENTRIES[entryNumber].entryName(), e.getName());\n+        try (var in = zf.getInputStream(e)) {\n+            var entryData = new String(in.readAllBytes(), StandardCharsets.UTF_8);\n+            assertEquals(ZIP_ENTRIES[entryNumber].data(), entryData);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/zip\/ZipFile\/DupEntriesGetInputStream.java","additions":216,"deletions":0,"binary":false,"changes":216,"status":"added"}]}