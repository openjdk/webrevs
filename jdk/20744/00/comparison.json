{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,6 @@\n-   @bug 4028605 4109069 4234207 4401122\n-   @summary Make sure ZipInputStream\/InflaterInputStream.available() will\n-            return 0 after EOF has reached and 1 otherwise.\n-   *\/\n+ * @bug 4028605 4109069 4234207 4401122 8339154\n+ * @summary Verify that ZipInputStream, InflaterInputStream, ZipFileInputStream,\n+ *          ZipFileInflaterInputStream.available() return values according\n+ *          to their specification or long-standing behavior\n+ * @run junit Available\n+ *\/\n@@ -30,0 +32,3 @@\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n@@ -32,0 +37,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +42,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n@@ -36,5 +47,27 @@\n-    public static void main(String[] args) throws Exception {\n-        \/\/ 4028605 4109069 4234207\n-        test1();\n-        \/\/ test 4401122\n-        test2();\n+    \/\/ ZIP file produced in this test\n+    private final Path zip = Path.of(\"available.jar\");\n+\n+    \/**\n+     * Create the ZIP file used in this test, containing\n+     * one deflated and one stored entry.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        byte[] contents = \"contents\".repeat(10).getBytes(StandardCharsets.UTF_8);\n+\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            \/\/ First entry uses DEFLATE method\n+            zo.putNextEntry(new ZipEntry(\"deflated.txt\"));\n+            zo.write(contents);\n+\n+            \/\/ Second entry uses STORED method\n+            ZipEntry stored = new ZipEntry(\"stored.txt\");\n+            stored.setSize(contents.length);\n+            CRC32 crc32 = new CRC32();\n+            crc32.update(contents);\n+            stored.setCrc(crc32.getValue());\n+            zo.putNextEntry(stored);\n+            zo.write(contents);\n+        }\n@@ -43,2 +76,9 @@\n-    private static void test1() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n+    \/**\n+     * Delete the ZIP file created by this test\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n@@ -46,4 +86,10 @@\n-        \/\/ test ZipInputStream\n-        try (FileInputStream fis = new FileInputStream(f);\n-             ZipInputStream z = new ZipInputStream(fis))\n-        {\n+    \/**\n+     * Verify that ZipInputStream.available() returns 0 after EOF or\n+     * closeEntry, otherwise 1, as specified in the API description.\n+     * This tests 4028605 4109069 4234207\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void testZipInputStream() throws IOException {\n+        try (InputStream in = Files.newInputStream(zip)) {\n+            ZipInputStream z = new ZipInputStream(in);\n@@ -51,1 +97,10 @@\n-            tryAvail(z);\n+            assertEquals(1, z.available());\n+            z.read();\n+            assertEquals(1, z.available());\n+            z.transferTo(OutputStream.nullOutputStream());\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after EOF\");\n+\n+            z.close();\n+            assertThrows(IOException.class, () -> z.available(),\n+                    \"Expected an IOException when calling available on a closed stream\");\n@@ -54,3 +109,6 @@\n-        \/\/ test InflaterInputStream\n-        try (ZipFile zfile = new ZipFile(f)) {\n-            tryAvail(zfile.getInputStream(zfile.getEntry(\"Available.java\")));\n+        try (InputStream in = Files.newInputStream(zip);\n+             ZipInputStream z = new ZipInputStream(in)) {\n+            z.getNextEntry();\n+            z.closeEntry();\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after closeEntry\");\n@@ -60,3 +118,14 @@\n-    static void tryAvail(InputStream in) throws Exception {\n-        byte[] buf = new byte[1024];\n-        int n;\n+    \/**\n+     * Verify that ZipFileInputStream.available() returns\n+     * the number of remaining uncompressed bytes.\n+     *\n+     * This verifies unspecified, but long-standing behavior. See 4401122.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void testZipFileInputStream() throws IOException {\n+        try (ZipFile zfile = new ZipFile(zip.toFile())) {\n+            assertRemainingUncompressedBytes(zfile, \"stored.txt\");\n+        }\n+    }\n@@ -64,3 +133,12 @@\n-        while ((n = in.read(buf)) != -1);\n-        if (in.available() != 0) {\n-            throw new Exception(\"available should return 0 after EOF\");\n+    \/**\n+     * Verify that ZipFileInflaterInputStream.available() returns\n+     * the number of remaining uncompressed bytes.\n+     *\n+     * This verifies unspecified, but long-standing behavior. See 4401122.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void testZipFileInflaterInputStream() throws IOException {\n+        try (ZipFile zfile = new ZipFile(zip.toFile())) {\n+            assertRemainingUncompressedBytes(zfile, \"deflated.txt\");\n@@ -70,5 +148,17 @@\n-    \/\/ To reproduce 4401122\n-    private static void test2() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n-        try (ZipFile zf = new ZipFile(f)) {\n-            InputStream in = zf.getInputStream(zf.getEntry(\"Available.java\"));\n+    \/**\n+     * Assert that calling available() on a an InputStream obtained\n+     * from ZipFile.getInputStream for the given entry\n+     * returns the number of remaining uncompressed bytes in the stream.\n+     *\n+     * @param zfile the ZipFile to read an entry from\n+     * @param name the name of the entry to read\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    private void assertRemainingUncompressedBytes(ZipFile zfile, String name) throws IOException {\n+        ZipEntry entry = zfile.getEntry(name);\n+        InputStream in = zfile.getInputStream(entry);\n+\n+        int initialAvailable = in.available();\n+\n+        \/\/ Initally, the number of remaining uncompressed bytes is the entry size\n+        assertEquals(entry.getSize(), in.available());\n@@ -76,1 +166,7 @@\n-            int initialAvailable = in.available();\n+        \/\/ Reading a single byte should decrement available by 1\n+        in.read();\n+        assertEquals(initialAvailable - 1, in.available(),\n+                \"Available not decremented\");\n+\n+        \/\/ Read all bytes one by one\n+        for (int i=0; i < initialAvailable-1; i++) {\n@@ -78,9 +174,0 @@\n-            if (in.available() != initialAvailable - 1)\n-                throw new RuntimeException(\"Available not decremented.\");\n-            for(int j=0; j<initialAvailable-1; j++)\n-                in.read();\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n-            in.close();\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n@@ -88,1 +175,0 @@\n-    }\n@@ -90,0 +176,7 @@\n+        \/\/ No remaining uncompressed bytes\n+        assertEquals(0, in.available());\n+\n+        \/\/ available() should still return 0 after close\n+        in.close();\n+        assertEquals(0, in.available());\n+    }\n","filename":"test\/jdk\/java\/util\/zip\/Available.java","additions":135,"deletions":42,"binary":false,"changes":177,"status":"modified"}]}