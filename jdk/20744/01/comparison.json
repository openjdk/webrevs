{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,6 @@\n-   @bug 4028605 4109069 4234207 4401122\n-   @summary Make sure ZipInputStream\/InflaterInputStream.available() will\n-            return 0 after EOF has reached and 1 otherwise.\n-   *\/\n+ * @bug 4028605 4109069 4234207 4401122 8339154\n+ * @summary Verify that ZipInputStream, InflaterInputStream, ZipFileInputStream,\n+ *          ZipFileInflaterInputStream.available() return values according\n+ *          to their specification or long-standing behavior\n+ * @run junit Available\n+ *\/\n@@ -30,0 +32,5 @@\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -32,0 +39,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +44,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n@@ -36,6 +49,2 @@\n-    public static void main(String[] args) throws Exception {\n-        \/\/ 4028605 4109069 4234207\n-        test1();\n-        \/\/ test 4401122\n-        test2();\n-    }\n+    \/\/ ZIP file produced in this test\n+    private final Path zip = Path.of(\"available.jar\");\n@@ -43,2 +52,9 @@\n-    private static void test1() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n+    \/**\n+     * Create the ZIP file used in this test, containing\n+     * one deflated and one stored entry.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        byte[] contents = \"contents\".repeat(10).getBytes(StandardCharsets.UTF_8);\n@@ -46,7 +62,4 @@\n-        \/\/ test ZipInputStream\n-        try (FileInputStream fis = new FileInputStream(f);\n-             ZipInputStream z = new ZipInputStream(fis))\n-        {\n-            z.getNextEntry();\n-            tryAvail(z);\n-        }\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            \/\/ First entry uses DEFLATE method\n+            zo.putNextEntry(new ZipEntry(\"deflated.txt\"));\n+            zo.write(contents);\n@@ -54,3 +67,8 @@\n-        \/\/ test InflaterInputStream\n-        try (ZipFile zfile = new ZipFile(f)) {\n-            tryAvail(zfile.getInputStream(zfile.getEntry(\"Available.java\")));\n+            \/\/ Second entry uses STORED method\n+            ZipEntry stored = new ZipEntry(\"stored.txt\");\n+            stored.setSize(contents.length);\n+            CRC32 crc32 = new CRC32();\n+            crc32.update(contents);\n+            stored.setCrc(crc32.getValue());\n+            zo.putNextEntry(stored);\n+            zo.write(contents);\n@@ -60,3 +78,32 @@\n-    static void tryAvail(InputStream in) throws Exception {\n-        byte[] buf = new byte[1024];\n-        int n;\n+    \/**\n+     * Delete the ZIP file created by this test\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Verify that ZipInputStream.available() returns 0 after EOF or\n+     * closeEntry, otherwise 1, as specified in the API description.\n+     * This tests 4028605 4109069 4234207\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void testZipInputStream() throws IOException {\n+        try (InputStream in = Files.newInputStream(zip)) {\n+            ZipInputStream z = new ZipInputStream(in);\n+            z.getNextEntry();\n+            assertEquals(1, z.available());\n+            z.read();\n+            assertEquals(1, z.available());\n+            z.transferTo(OutputStream.nullOutputStream());\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after EOF\");\n+\n+            z.close();\n+            assertThrows(IOException.class, () -> z.available(),\n+                    \"Expected an IOException when calling available on a closed stream\");\n+        }\n@@ -64,3 +111,6 @@\n-        while ((n = in.read(buf)) != -1);\n-        if (in.available() != 0) {\n-            throw new Exception(\"available should return 0 after EOF\");\n+        try (InputStream in = Files.newInputStream(zip);\n+             ZipInputStream z = new ZipInputStream(in)) {\n+            z.getNextEntry();\n+            z.closeEntry();\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after closeEntry\");\n@@ -70,5 +120,15 @@\n-    \/\/ To reproduce 4401122\n-    private static void test2() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n-        try (ZipFile zf = new ZipFile(f)) {\n-            InputStream in = zf.getInputStream(zf.getEntry(\"Available.java\"));\n+    \/**\n+     * Verify that ZipFileInputStream|ZipFileInflaterInputStream.available()\n+     * return the number of remaining uncompressed bytes.\n+     *\n+     * This verifies unspecified, but long-standing behavior. See 4401122.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"stored.txt\", \"deflated.txt\" })\n+    public void testZipFileStreamsRemainingBytes(String entryName) throws IOException {\n+        try (ZipFile zfile = new ZipFile(zip.toFile())) {\n+            ZipEntry entry = zfile.getEntry(entryName);\n+            \/\/ Could be ZipFileInputStream or ZipFileInflaterInputStream\n+            InputStream in = zfile.getInputStream(entry);\n@@ -77,4 +137,7 @@\n-            in.read();\n-            if (in.available() != initialAvailable - 1)\n-                throw new RuntimeException(\"Available not decremented.\");\n-            for(int j=0; j<initialAvailable-1; j++)\n+\n+            \/\/ Initally, the number of remaining uncompressed bytes is the entry size\n+            assertEquals(entry.getSize(), initialAvailable);\n+\n+            \/\/ Read all bytes one by one\n+            for (int i = initialAvailable; i > 0; i--) {\n+                \/\/ Reading a single byte should decrement available by 1\n@@ -82,2 +145,7 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+                assertEquals(i - 1, in.available(), \"Available not decremented\");\n+            }\n+\n+            \/\/ No remaining uncompressed bytes\n+            assertEquals(0, in.available());\n+\n+            \/\/ available() should still return 0 after close\n@@ -85,2 +153,1 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+            assertEquals(0, in.available());\n@@ -89,1 +156,0 @@\n-\n","filename":"test\/jdk\/java\/util\/zip\/Available.java","additions":109,"deletions":43,"binary":false,"changes":152,"status":"modified"}]}