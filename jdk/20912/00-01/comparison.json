{"files":[{"patch":"@@ -77,0 +77,10 @@\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n","filename":"src\/hotspot\/cpu\/riscv\/interpreterRT_riscv.cpp","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -5529,4 +5529,10 @@\n-\/\/ On 64 bit we will store integer like items to the stack as\n-\/\/ 64 bits items (riscv64 abi) even though java would only store\n-\/\/ 32bits for a parameter. On 32bit it will simply be 32 bits\n-\/\/ So this routine will do 32->32 on 32bit and 32->64 on 64bit\n+\/\/ The C ABI specifies:\n+\/\/ \"integer scalars narrower than XLEN bits are widened according to the sign\n+\/\/ of their type up to 32 bits, then sign-extended to XLEN bits.\"\n+\/\/ Applies for both passed in register and stack.\n+\/\/\n+\/\/ Java uses 32-bit stack slots; jint, jshort, jchar, jbyte uses one slot.\n+\/\/ Native uses 64-bit stack slots for all integer scalar types.\n+\/\/\n+\/\/ lw loads the Java stack slot, sign-extends and\n+\/\/ sd store this widened integer into a 64 bit native stack slot.\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"}]}