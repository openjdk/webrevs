{"files":[{"patch":"@@ -5290,10 +5290,0 @@\n-  \/\/ Move UnorderedReduction out of counted loop. Can be introduced by AutoVectorization.\n-  if (C->has_loops() && !C->major_progress()) {\n-    for (LoopTreeIterator iter(_ltree_root); !iter.done(); iter.next()) {\n-      IdealLoopTree* lpt = iter.current();\n-      if (lpt->is_counted() && lpt->is_innermost()) {\n-        move_unordered_reduction_out_of_loop(lpt);\n-      }\n-    }\n-  }\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1553,3 +1553,0 @@\n-  \/\/ Move an unordered Reduction out of loop if possible\n-  void move_unordered_reduction_out_of_loop(IdealLoopTree* loop);\n-\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -4551,205 +4551,0 @@\n-\/\/ Returns true if the Reduction node is unordered.\n-static bool is_unordered_reduction(Node* n) {\n-  return n->is_Reduction() && !n->as_Reduction()->requires_strict_order();\n-}\n-\n-\/\/ Having ReductionNodes in the loop is expensive. They need to recursively\n-\/\/ fold together the vector values, for every vectorized loop iteration. If\n-\/\/ we encounter the following pattern, we can vector accumulate the values\n-\/\/ inside the loop, and only have a single UnorderedReduction after the loop.\n-\/\/\n-\/\/ Note: UnorderedReduction represents a ReductionNode which does not require\n-\/\/ calculating in strict order.\n-\/\/\n-\/\/ CountedLoop     init\n-\/\/          |        |\n-\/\/          +------+ | +-----------------------+\n-\/\/                 | | |                       |\n-\/\/                PhiNode (s)                  |\n-\/\/                  |                          |\n-\/\/                  |          Vector          |\n-\/\/                  |            |             |\n-\/\/               UnorderedReduction (first_ur) |\n-\/\/                  |                          |\n-\/\/                 ...         Vector          |\n-\/\/                  |            |             |\n-\/\/               UnorderedReduction (last_ur)  |\n-\/\/                       |                     |\n-\/\/                       +---------------------+\n-\/\/\n-\/\/ We patch the graph to look like this:\n-\/\/\n-\/\/ CountedLoop   identity_vector\n-\/\/         |         |\n-\/\/         +-------+ | +---------------+\n-\/\/                 | | |               |\n-\/\/                PhiNode (v)          |\n-\/\/                   |                 |\n-\/\/                   |         Vector  |\n-\/\/                   |           |     |\n-\/\/                 VectorAccumulator   |\n-\/\/                   |                 |\n-\/\/                  ...        Vector  |\n-\/\/                   |           |     |\n-\/\/      init       VectorAccumulator   |\n-\/\/        |          |     |           |\n-\/\/     UnorderedReduction  +-----------+\n-\/\/\n-\/\/ We turned the scalar (s) Phi into a vectorized one (v). In the loop, we\n-\/\/ use vector_accumulators, which do the same reductions, but only element\n-\/\/ wise. This is a single operation per vector_accumulator, rather than many\n-\/\/ for a UnorderedReduction. We can then reduce the last vector_accumulator\n-\/\/ after the loop, and also reduce the init value into it.\n-\/\/\n-\/\/ We can not do this with all reductions. Some reductions do not allow the\n-\/\/ reordering of operations (for example float addition\/multiplication require\n-\/\/ strict order).\n-void PhaseIdealLoop::move_unordered_reduction_out_of_loop(IdealLoopTree* loop) {\n-  assert(!C->major_progress() && loop->is_counted() && loop->is_innermost(), \"sanity\");\n-\n-  \/\/ Find all Phi nodes with an unordered Reduction on backedge.\n-  CountedLoopNode* cl = loop->_head->as_CountedLoop();\n-  for (DUIterator_Fast jmax, j = cl->fast_outs(jmax); j < jmax; j++) {\n-    Node* phi = cl->fast_out(j);\n-    \/\/ We have a phi with a single use, and an unordered Reduction on the backedge.\n-    if (!phi->is_Phi() || phi->outcnt() != 1 || !is_unordered_reduction(phi->in(2))) {\n-      continue;\n-    }\n-\n-    ReductionNode* last_ur = phi->in(2)->as_Reduction();\n-    assert(!last_ur->requires_strict_order(), \"must be\");\n-\n-    \/\/ Determine types\n-    const TypeVect* vec_t = last_ur->vect_type();\n-    uint vector_length    = vec_t->length();\n-    BasicType bt          = vec_t->element_basic_type();\n-\n-    \/\/ Convert opcode from vector-reduction -> scalar -> normal-vector-op\n-    const int sopc        = VectorNode::scalar_opcode(last_ur->Opcode(), bt);\n-    const int vopc        = VectorNode::opcode(sopc, bt);\n-    if (!Matcher::match_rule_supported_vector(vopc, vector_length, bt)) {\n-        DEBUG_ONLY( last_ur->dump(); )\n-        assert(false, \"do not have normal vector op for this reduction\");\n-        continue; \/\/ not implemented -> fails\n-    }\n-\n-    \/\/ Traverse up the chain of unordered Reductions, checking that it loops back to\n-    \/\/ the phi. Check that all unordered Reductions only have a single use, except for\n-    \/\/ the last (last_ur), which only has phi as a use in the loop, and all other uses\n-    \/\/ are outside the loop.\n-    ReductionNode* current = last_ur;\n-    ReductionNode* first_ur = nullptr;\n-    while (true) {\n-      assert(!current->requires_strict_order(), \"sanity\");\n-\n-      \/\/ Expect no ctrl and a vector_input from within the loop.\n-      Node* ctrl = current->in(0);\n-      Node* vector_input = current->in(2);\n-      if (ctrl != nullptr || get_ctrl(vector_input) != cl) {\n-        DEBUG_ONLY( current->dump(1); )\n-        assert(false, \"reduction has ctrl or bad vector_input\");\n-        break; \/\/ Chain traversal fails.\n-      }\n-\n-      assert(current->vect_type() != nullptr, \"must have vector type\");\n-      if (current->vect_type() != last_ur->vect_type()) {\n-        \/\/ Reductions do not have the same vector type (length and element type).\n-        break; \/\/ Chain traversal fails.\n-      }\n-\n-      \/\/ Expect single use of an unordered Reduction, except for last_ur.\n-      if (current == last_ur) {\n-        \/\/ Expect all uses to be outside the loop, except phi.\n-        for (DUIterator_Fast kmax, k = current->fast_outs(kmax); k < kmax; k++) {\n-          Node* use = current->fast_out(k);\n-          if (use != phi && ctrl_or_self(use) == cl) {\n-            DEBUG_ONLY( current->dump(-1); )\n-            assert(false, \"reduction has use inside loop\");\n-            \/\/ Should not be allowed by SuperWord::mark_reductions\n-            return; \/\/ bail out of optimization\n-          }\n-        }\n-      } else {\n-        if (current->outcnt() != 1) {\n-          break; \/\/ Chain traversal fails.\n-        }\n-      }\n-\n-      \/\/ Expect another unordered Reduction or phi as the scalar input.\n-      Node* scalar_input = current->in(1);\n-      if (is_unordered_reduction(scalar_input) &&\n-          scalar_input->Opcode() == current->Opcode()) {\n-        \/\/ Move up the unordered Reduction chain.\n-        current = scalar_input->as_Reduction();\n-        assert(!current->requires_strict_order(), \"must be\");\n-      } else if (scalar_input == phi) {\n-        \/\/ Chain terminates at phi.\n-        first_ur = current;\n-        current = nullptr;\n-        break; \/\/ Success.\n-      } else {\n-        \/\/ scalar_input is neither phi nor a matching reduction\n-        \/\/ Can for example be scalar reduction when we have\n-        \/\/ partial vectorization.\n-        break; \/\/ Chain traversal fails.\n-      }\n-    }\n-    if (current != nullptr) {\n-      \/\/ Chain traversal was not successful.\n-      continue;\n-    }\n-    assert(first_ur != nullptr, \"must have successfully terminated chain traversal\");\n-\n-    Node* identity_scalar = ReductionNode::make_identity_con_scalar(_igvn, sopc, bt);\n-    set_root_as_ctrl(identity_scalar);\n-    VectorNode* identity_vector = VectorNode::scalar2vector(identity_scalar, vector_length, bt);\n-    register_new_node(identity_vector, C->root());\n-    assert(vec_t == identity_vector->vect_type(), \"matching vector type\");\n-    VectorNode::trace_new_vector(identity_vector, \"Unordered Reduction\");\n-\n-    \/\/ Turn the scalar phi into a vector phi.\n-    _igvn.rehash_node_delayed(phi);\n-    Node* init = phi->in(1); \/\/ Remember init before replacing it.\n-    phi->set_req_X(1, identity_vector, &_igvn);\n-    phi->as_Type()->set_type(vec_t);\n-    _igvn.set_type(phi, vec_t);\n-\n-    \/\/ Traverse down the chain of unordered Reductions, and replace them with vector_accumulators.\n-    current = first_ur;\n-    while (true) {\n-      \/\/ Create vector_accumulator to replace current.\n-      Node* last_vector_accumulator = current->in(1);\n-      Node* vector_input            = current->in(2);\n-      VectorNode* vector_accumulator = VectorNode::make(vopc, last_vector_accumulator, vector_input, vec_t);\n-      register_new_node(vector_accumulator, cl);\n-      _igvn.replace_node(current, vector_accumulator);\n-      VectorNode::trace_new_vector(vector_accumulator, \"Unordered Reduction\");\n-      if (current == last_ur) {\n-        break;\n-      }\n-      current = vector_accumulator->unique_out()->as_Reduction();\n-      assert(!current->requires_strict_order(), \"must be\");\n-    }\n-\n-    \/\/ Create post-loop reduction.\n-    Node* last_accumulator = phi->in(2);\n-    Node* post_loop_reduction = ReductionNode::make(sopc, nullptr, init, last_accumulator, bt);\n-\n-    \/\/ Take over uses of last_accumulator that are not in the loop.\n-    for (DUIterator i = last_accumulator->outs(); last_accumulator->has_out(i); i++) {\n-      Node* use = last_accumulator->out(i);\n-      if (use != phi && use != post_loop_reduction) {\n-        assert(ctrl_or_self(use) != cl, \"use must be outside loop\");\n-        use->replace_edge(last_accumulator, post_loop_reduction,  &_igvn);\n-        --i;\n-      }\n-    }\n-    register_new_node(post_loop_reduction, get_late_ctrl(post_loop_reduction, cl));\n-    VectorNode::trace_new_vector(post_loop_reduction, \"Unordered Reduction\");\n-\n-    assert(last_accumulator->outcnt() == 2, \"last_accumulator has 2 uses: phi and post_loop_reduction\");\n-    assert(post_loop_reduction->outcnt() > 0, \"should have taken over all non loop uses of last_accumulator\");\n-    assert(phi->outcnt() == 1, \"accumulator is the only use of phi\");\n-  }\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":0,"deletions":205,"binary":false,"changes":205,"status":"modified"},{"patch":"@@ -1609,1 +1609,1 @@\n-      \/\/ PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+      \/\/ See: VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop\n@@ -1785,1 +1785,1 @@\n-      \/\/ See: PhaseIdealLoop::move_unordered_reduction_out_of_loop\n+      \/\/ See: VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop\n@@ -1950,0 +1950,2 @@\n+  vtransform.optimize();\n+\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -48,0 +48,2 @@\n+  flags(VTRANSFORM,                 \"Trace VTransform Graph\") \\\n+  flags(OPTIMIZATION,               \"Trace VTransform::optimize\") \\\n@@ -51,1 +53,0 @@\n-  flags(VTRANSFORM,                 \"Trace VTransform Graph\") \\\n","filename":"src\/hotspot\/share\/opto\/traceAutoVectorizationTag.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -208,0 +208,4 @@\n+  bool is_trace_optimization() const {\n+    return _vtrace.is_trace(TraceAutoVectorizationTag::OPTIMIZATION);\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/vectorization.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -295,115 +295,0 @@\n-\/\/ Return the scalar opcode for the specified vector opcode\n-\/\/ and basic type.\n-int VectorNode::scalar_opcode(int sopc, BasicType bt) {\n-  switch (sopc) {\n-    case Op_AddReductionVI:\n-    case Op_AddVI:\n-      return Op_AddI;\n-    case Op_AddReductionVL:\n-    case Op_AddVL:\n-      return Op_AddL;\n-    case Op_MulReductionVI:\n-    case Op_MulVI:\n-      return Op_MulI;\n-    case Op_MulReductionVL:\n-    case Op_MulVL:\n-      return Op_MulL;\n-    case Op_AndReductionV:\n-    case Op_AndV:\n-      switch (bt) {\n-        case T_BOOLEAN:\n-        case T_CHAR:\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_INT:\n-          return Op_AndI;\n-        case T_LONG:\n-          return Op_AndL;\n-        default:\n-          assert(false, \"basic type not handled\");\n-          return 0;\n-      }\n-    case Op_OrReductionV:\n-    case Op_OrV:\n-      switch (bt) {\n-        case T_BOOLEAN:\n-        case T_CHAR:\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_INT:\n-          return Op_OrI;\n-        case T_LONG:\n-          return Op_OrL;\n-        default:\n-          assert(false, \"basic type not handled\");\n-          return 0;\n-      }\n-    case Op_XorReductionV:\n-    case Op_XorV:\n-      switch (bt) {\n-        case T_BOOLEAN:\n-        case T_CHAR:\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_INT:\n-          return Op_XorI;\n-        case T_LONG:\n-          return Op_XorL;\n-        default:\n-          assert(false, \"basic type not handled\");\n-          return 0;\n-      }\n-    case Op_MinReductionV:\n-    case Op_MinV:\n-      switch (bt) {\n-        case T_BOOLEAN:\n-        case T_CHAR:\n-          assert(false, \"boolean and char are signed, not implemented for Min\");\n-          return 0;\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_INT:\n-          return Op_MinI;\n-        case T_LONG:\n-          return Op_MinL;\n-        case T_FLOAT:\n-          return Op_MinF;\n-        case T_DOUBLE:\n-          return Op_MinD;\n-        default:\n-          assert(false, \"basic type not handled\");\n-          return 0;\n-      }\n-    case Op_MaxReductionV:\n-    case Op_MaxV:\n-      switch (bt) {\n-        case T_BOOLEAN:\n-        case T_CHAR:\n-          assert(false, \"boolean and char are signed, not implemented for Max\");\n-          return 0;\n-        case T_BYTE:\n-        case T_SHORT:\n-        case T_INT:\n-          return Op_MaxI;\n-        case T_LONG:\n-          return Op_MaxL;\n-        case T_FLOAT:\n-          return Op_MaxF;\n-        case T_DOUBLE:\n-          return Op_MaxD;\n-        default:\n-          assert(false, \"basic type not handled\");\n-          return 0;\n-      }\n-    case Op_MinVHF:\n-      return Op_MinHF;\n-    case Op_MaxVHF:\n-      return Op_MaxHF;\n-    default:\n-      assert(false,\n-             \"Vector node %s is not handled in VectorNode::scalar_opcode\",\n-             NodeClassNames[sopc]);\n-      return 0; \/\/ Unimplemented\n-  }\n-}\n-\n@@ -1730,0 +1615,28 @@\n+bool ReductionNode::auto_vectorization_requires_strict_order(int vopc) {\n+  switch (vopc) {\n+    case Op_AddReductionVI:\n+    case Op_AddReductionVL:\n+    case Op_MulReductionVI:\n+    case Op_MulReductionVL:\n+    case Op_MinReductionV:\n+    case Op_MaxReductionV:\n+    case Op_AndReductionV:\n+    case Op_OrReductionV:\n+    case Op_XorReductionV:\n+      \/\/ These are cases that all have associative operations, which can\n+      \/\/ thus be reordered, allowing non-strict order reductions.\n+      return false;\n+    case Op_AddReductionVF:\n+    case Op_MulReductionVF:\n+    case Op_AddReductionVD:\n+    case Op_MulReductionVD:\n+      \/\/ Floating-point addition and multiplication are non-associative,\n+      \/\/ so AddReductionVF\/D and MulReductionVF\/D require strict ordering\n+      \/\/ in auto-vectorization.\n+      return true;\n+    default:\n+      assert(false, \"not handled: %s\", NodeClassNames[vopc]);\n+      return true;\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.cpp","additions":28,"deletions":115,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -98,1 +98,0 @@\n-  static int scalar_opcode(int vopc, BasicType bt);  \/\/ vector_opc -> scalar_opc\n@@ -286,0 +285,2 @@\n+  static bool auto_vectorization_requires_strict_order(int vopc);\n+\n","filename":"src\/hotspot\/share\/opto\/vectornode.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"opto\/rootnode.hpp\"\n@@ -35,0 +36,39 @@\n+#define TRACE_OPTIMIZE(code)                          \\\n+  NOT_PRODUCT(                                        \\\n+    if (vtransform.vloop().is_trace_optimization()) { \\\n+      code                                            \\\n+    }                                                 \\\n+  )\n+\n+\/\/ This is similar to IGVN optimization. But we are a bit lazy, and don't care about\n+\/\/ notification \/ worklist, since the list of nodes is rather small, and we don't\n+\/\/ expect optimizations that trickle over the whole graph.\n+void VTransformGraph::optimize(VTransform& vtransform) {\n+  TRACE_OPTIMIZE( tty->print_cr(\"\\nVTransformGraph::optimize\"); )\n+\n+  bool progress = true;\n+  DEBUG_ONLY(int pass_count = 0;)\n+  while (progress) {\n+    progress = false;\n+    assert(++pass_count < 10, \"ensure we do not have endless loops\");\n+    for (int i = 0; i < _vtnodes.length(); i++) {\n+      VTransformNode* vtn = _vtnodes.at(i);\n+      if (!vtn->is_alive()) { continue; }\n+      progress |= vtn->optimize(_vloop_analyzer, vtransform);\n+\n+      \/\/ Nodes that have no use any more are dead.\n+      if (vtn->out_strong_edges() == 0 &&\n+          \/\/ There are some exceptions:\n+          \/\/ 1. Memory phi uses are not modeled, so they appear to have no use here, but must be kept alive.\n+          \/\/ 2. Similarly, some stores may not have their memory uses modeled, but need to be kept alive.\n+          \/\/ 3. Outer node with strong inputs: is a use after the loop that we must keep alive.\n+          !(vtn->isa_LoopPhi() != nullptr ||\n+            vtn->is_load_or_store_in_loop() ||\n+            (vtn->isa_Outer() != nullptr && vtn->has_strong_in_edge()))) {\n+        vtn->mark_dead();\n+        progress = true;\n+      }\n+    }\n+  }\n+}\n+\n@@ -62,0 +102,1 @@\n+  const int num_alive_nodes = count_alive_vtnodes();\n@@ -65,1 +106,1 @@\n-  int rpo_idx = _vtnodes.length() - 1;\n+  int rpo_idx = num_alive_nodes - 1;\n@@ -82,0 +123,3 @@\n+        \/\/ Skip dead nodes\n+        if (!use->is_alive()) { continue; }\n+\n@@ -124,0 +168,1 @@\n+    if (!vtn->is_alive()) { continue; }\n@@ -135,0 +180,9 @@\n+int VTransformGraph::count_alive_vtnodes() const {\n+  int count = 0;\n+  for (int i = 0; i < _vtnodes.length(); i++) {\n+    VTransformNode* vtn = _vtnodes.at(i);\n+    if (vtn->is_alive()) { count++; }\n+  }\n+  return count;\n+}\n+\n@@ -804,0 +858,7 @@\n+\n+  \/\/ The Phi's inputs may have been modified, and the types changes,\n+  \/\/ e.g. from scalar to vector.\n+  const Type* t = in1->bottom_type();\n+  _node->as_Type()->set_type(t);\n+  phase->igvn().set_type(_node, t);\n+\n@@ -942,0 +1003,221 @@\n+bool VTransformReductionVectorNode::optimize(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) {\n+  return optimize_move_non_strict_order_reductions_out_of_loop(vloop_analyzer, vtransform);\n+}\n+\n+int VTransformReductionVectorNode::vector_reduction_opcode() const {\n+  return ReductionNode::opcode(scalar_opcode(), element_basic_type());\n+}\n+\n+bool VTransformReductionVectorNode::requires_strict_order() const {\n+  int vopc = vector_reduction_opcode();\n+  return ReductionNode::auto_vectorization_requires_strict_order(vopc);\n+}\n+\n+\/\/ Having ReductionNodes in the loop is expensive. They need to recursively\n+\/\/ fold together the vector values, for every vectorized loop iteration. If\n+\/\/ we encounter the following pattern, we can vector accumulate the values\n+\/\/ inside the loop, and only have a single UnorderedReduction after the loop.\n+\/\/\n+\/\/ Note: UnorderedReduction represents a ReductionNode which does not require\n+\/\/ calculating in strict order.\n+\/\/\n+\/\/ CountedLoop     init\n+\/\/          |        |\n+\/\/          +------+ | +------------------------+\n+\/\/                 | | |                        |\n+\/\/                PhiNode (s)                   |\n+\/\/                  |                           |\n+\/\/                  |          Vector           |\n+\/\/                  |            |              |\n+\/\/               UnorderedReduction (first_red) |\n+\/\/                  |                           |\n+\/\/                 ...         Vector           |\n+\/\/                  |            |              |\n+\/\/               UnorderedReduction (last_red)  |\n+\/\/                       |                      |\n+\/\/                       +----------------------+\n+\/\/\n+\/\/ We patch the graph to look like this:\n+\/\/\n+\/\/ CountedLoop   identity_vector\n+\/\/         |         |\n+\/\/         +-------+ | +---------------+\n+\/\/                 | | |               |\n+\/\/                PhiNode (v)          |\n+\/\/                   |                 |\n+\/\/                   |         Vector  |\n+\/\/                   |           |     |\n+\/\/                 VectorAccumulator   |\n+\/\/                   |                 |\n+\/\/                  ...        Vector  |\n+\/\/                   |           |     |\n+\/\/      init       VectorAccumulator   |\n+\/\/        |          |     |           |\n+\/\/     UnorderedReduction  +-----------+\n+\/\/\n+\/\/ We turned the scalar (s) Phi into a vectorized one (v). In the loop, we\n+\/\/ use vector_accumulators, which do the same reductions, but only element\n+\/\/ wise. This is a single operation per vector_accumulator, rather than many\n+\/\/ for a UnorderedReduction. We can then reduce the last vector_accumulator\n+\/\/ after the loop, and also reduce the init value into it.\n+\/\/\n+\/\/ We can not do this with all reductions. Some reductions do not allow the\n+\/\/ reordering of operations (for example float addition\/multiplication require\n+\/\/ strict order).\n+\/\/\n+\/\/ Note: we must perform this optimization already during auto vectorization,\n+\/\/       before we evaluate the cost-model. Without this optimization, we may\n+\/\/       still have expensive reduction nodes in the loop which can make\n+\/\/       vectorization unprofitable. Only with the optimization does vectorization\n+\/\/       become profitable, since the expensive reduction node is moved\n+\/\/       outside the loop, and instead cheaper element-wise vector accumulations\n+\/\/       are performed inside the loop.\n+bool VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) {\n+  \/\/ We have a phi with a single use.\n+  VTransformLoopPhiNode* phi = in_req(1)->isa_LoopPhi();\n+  if (phi == nullptr) {\n+    return false;\n+  }\n+  if (phi->out_strong_edges() != 1) {\n+    TRACE_OPTIMIZE(\n+      tty->print(\"  Cannot move out of loop, phi has multiple uses:\");\n+      print();\n+      tty->print(\"  phi: \");\n+      phi->print();\n+    )\n+    return false;\n+  }\n+\n+  if (requires_strict_order()) {\n+    TRACE_OPTIMIZE(\n+      tty->print(\"  Cannot move out of loop, strict order required: \");\n+      print();\n+    )\n+    return false;\n+  }\n+\n+  const int sopc     = scalar_opcode();\n+  const uint vlen    = vector_length();\n+  const BasicType bt = element_basic_type();\n+  const int ropc     = vector_reduction_opcode();\n+  const int vopc     = VectorNode::opcode(sopc, bt);\n+  if (!Matcher::match_rule_supported_vector(vopc, vlen, bt)) {\n+    DEBUG_ONLY( this->print(); )\n+    assert(false, \"do not have normal vector op for this reduction\");\n+    return false; \/\/ not implemented\n+  }\n+\n+  \/\/ Traverse up the chain of non strict order reductions, checking that it loops\n+  \/\/ back to the phi. Check that all non strict order reductions only have a single\n+  \/\/ use, except for the last (last_red), which only has phi as a use in the loop,\n+  \/\/ and all other uses are outside the loop.\n+  VTransformReductionVectorNode* first_red   = this;\n+  VTransformReductionVectorNode* last_red    = phi->in_req(2)->isa_ReductionVector();\n+  VTransformReductionVectorNode* current_red = last_red;\n+  while (true) {\n+    if (current_red == nullptr ||\n+        current_red->vector_reduction_opcode() != ropc ||\n+        current_red->element_basic_type() != bt ||\n+        current_red->vector_length() != vlen) {\n+      TRACE_OPTIMIZE(\n+        tty->print(\"  Cannot move out of loop, other reduction node does not match:\");\n+        print();\n+        tty->print(\"  other: \");\n+        current_red->print();\n+      )\n+      return false; \/\/ not compatible\n+    }\n+\n+    VTransformVectorNode* vector_input = current_red->in_req(2)->isa_Vector();\n+    if (vector_input == nullptr) {\n+      assert(false, \"reduction has a bad vector input\");\n+      return false;\n+    }\n+\n+    \/\/ Expect single use of the non strict order reduction. Except for the last_red.\n+    if (current_red == last_red) {\n+      \/\/ All uses must be outside loop body, except for the phi.\n+      for (uint i = 0; i < current_red->out_strong_edges(); i++) {\n+        VTransformNode* use = current_red->out_strong_edge(i);\n+        if (use->isa_LoopPhi() == nullptr &&\n+            use->isa_Outer() == nullptr) {\n+          \/\/ Should not be allowed by SuperWord::mark_reductions\n+          assert(false, \"reduction has use inside loop\");\n+          return false;\n+        }\n+      }\n+    } else {\n+      if (current_red->out_strong_edges() != 1) {\n+        TRACE_OPTIMIZE(\n+          tty->print(\"  Cannot move out of loop, other reduction node has use outside loop:\");\n+          print();\n+          tty->print(\"  other: \");\n+          current_red->print();\n+        )\n+        return false; \/\/ Only single use allowed\n+      }\n+    }\n+\n+    \/\/ If the scalar input is a phi, we passed all checks.\n+    VTransformNode* scalar_input = current_red->in_req(1);\n+    if (scalar_input == phi) {\n+      break;\n+    }\n+\n+    \/\/ We expect another non strict reduction, verify it in the next iteration.\n+    current_red = scalar_input->isa_ReductionVector();\n+  }\n+\n+  \/\/ All checks were successful. Edit the vtransform graph now.\n+  PhaseIdealLoop* phase = vloop_analyzer.vloop().phase();\n+  TRACE_OPTIMIZE(\n+    tty->print_cr(\"VTransformReductionVectorNode::optimize_move_non_strict_order_reductions_out_of_loop\");\n+  )\n+\n+  \/\/ Create a vector of identity values.\n+  Node* identity = ReductionNode::make_identity_con_scalar(phase->igvn(), sopc, bt);\n+  phase->set_ctrl(identity, phase->C->root());\n+  VTransformNode* vtn_identity = new (vtransform.arena()) VTransformOuterNode(vtransform, identity);\n+\n+  VTransformNode* vtn_identity_vector = new (vtransform.arena()) VTransformReplicateNode(vtransform, vlen, bt);\n+  vtn_identity_vector->init_req(1, vtn_identity);\n+\n+  \/\/ Turn the scalar phi into a vector phi.\n+  VTransformNode* init = phi->in_req(1);\n+  phi->set_req(1, vtn_identity_vector);\n+\n+  \/\/ Traverse down the chain of reductions, and replace them with vector_accumulators.\n+  VTransformNode* current_vector_accumulator = phi;\n+  current_red = first_red;\n+  while (true) {\n+    VTransformNode* vector_input = current_red->in_req(2);\n+    VTransformVectorNode* vector_accumulator = new (vtransform.arena()) VTransformElementWiseVectorNode(vtransform, 3, current_red->properties(), vopc);\n+    vector_accumulator->init_req(1, current_vector_accumulator);\n+    vector_accumulator->init_req(2, vector_input);\n+    TRACE_OPTIMIZE(\n+      tty->print(\"  replace    \");\n+      current_red->print();\n+      tty->print(\"  with       \");\n+      vector_accumulator->print();\n+    )\n+    current_vector_accumulator = vector_accumulator;\n+    if (current_red == last_red) { break; }\n+    current_red = current_red->unique_out_strong_edge()->isa_ReductionVector();\n+  }\n+\n+  \/\/ Feed vector accumulator into the backedge.\n+  phi->set_req(2, current_vector_accumulator);\n+\n+  \/\/ Create post-loop reduction. last_red keeps all uses outside the loop.\n+  last_red->set_req(1, init);\n+  last_red->set_req(2, current_vector_accumulator);\n+\n+  TRACE_OPTIMIZE(\n+    tty->print(\"  phi        \");\n+    phi->print();\n+    tty->print(\"  after loop \");\n+    last_red->print();\n+  )\n+  return true; \/\/ success\n+}\n+\n@@ -1044,1 +1326,1 @@\n-  tty->print(\") [\");\n+  tty->print(\") %s[\", _is_alive ? \"\" : \"dead \");\n","filename":"src\/hotspot\/share\/opto\/vtransform.cpp","additions":284,"deletions":2,"binary":false,"changes":286,"status":"modified"},{"patch":"@@ -44,1 +44,5 @@\n-\/\/ - Future Plans: optimize, if-conversion, etc.\n+\/\/ - Optimize:\n+\/\/   - Move non-strict order reductions out of the loop. This means we have\n+\/\/     only element-wise operations inside the loop, rather than the much\n+\/\/     more expensive lane-crossing reductions. We need to do this before\n+\/\/     assessing profitability with the cost-model.\n@@ -65,1 +69,0 @@\n-\/\/ - Optimizations: moving unordered reductions out of the loop, whih decreases cost.\n@@ -71,0 +74,1 @@\n+class VTransform;\n@@ -186,0 +190,1 @@\n+  void optimize(VTransform& vtransform);\n@@ -197,0 +202,1 @@\n+  int count_alive_vtnodes() const;\n@@ -242,0 +248,1 @@\n+  const VLoop& vloop() const { return _vloop; }\n@@ -246,0 +253,1 @@\n+  void optimize() { return _graph.optimize(*this); }\n@@ -375,0 +383,2 @@\n+  bool _is_alive;\n+\n@@ -392,0 +402,1 @@\n+    _is_alive(true),\n@@ -408,0 +419,8 @@\n+  void set_req(uint i, VTransformNode* n) {\n+    assert(i < _req, \"must be a req\");\n+    VTransformNode* old = _in.at(i);\n+    if (old != nullptr) { old->del_out_strong_edge(this); }\n+    _in.at_put(i, n);\n+    if (n != nullptr) { n->add_out_strong_edge(this); }\n+  }\n+\n@@ -455,0 +474,17 @@\n+  void del_out_strong_edge(VTransformNode* n) {\n+    int i = _out.find(n);\n+    assert(0 <= i && i < (int)_out_end_strong_edges, \"must be in strong edges\");\n+\n+    \/\/ Replace n with the last strong edge.\n+    VTransformNode* last_strong = _out.at(_out_end_strong_edges - 1);\n+    _out.at_put(i, last_strong);\n+\n+    if (_out_end_strong_edges < (uint)_out.length()) {\n+      \/\/ Now replace where last_strong was with the last weak edge.\n+      VTransformNode* last_weak = _out.top();\n+      _out.at_put(_out_end_strong_edges - 1, last_weak);\n+    }\n+    _out.pop();\n+    _out_end_strong_edges--;\n+  }\n+\n@@ -482,0 +518,15 @@\n+  VTransformNode* unique_out_strong_edge() const {\n+    assert(out_strong_edges() == 1, \"must be unique\");\n+    return _out.at(0);\n+  }\n+\n+  bool is_alive() const { return _is_alive; }\n+\n+  void mark_dead() {\n+    _is_alive = false;\n+    \/\/ Remove all inputs\n+    for (uint i = 0; i < req(); i++) {\n+      set_req(i, nullptr);\n+    }\n+  }\n+\n@@ -499,0 +550,2 @@\n+  virtual bool optimize(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) { return false; }\n+\n@@ -704,0 +757,1 @@\n+  const VTransformVectorNodeProperties& properties() const { return _properties; }\n@@ -783,0 +837,1 @@\n+  virtual bool optimize(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform) override;\n@@ -785,0 +840,5 @@\n+\n+private:\n+  int vector_reduction_opcode() const;\n+  bool requires_strict_order() const;\n+  bool optimize_move_non_strict_order_reductions_out_of_loop(const VLoopAnalyzer& vloop_analyzer, VTransform& vtransform);\n","filename":"src\/hotspot\/share\/opto\/vtransform.hpp","additions":62,"deletions":2,"binary":false,"changes":64,"status":"modified"}]}