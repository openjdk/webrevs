{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -354,1 +354,1 @@\n-  JfrMutexTryLock threads_lock(Threads_lock);\n+  JfrMutexTryLock lock(Threads_lock);\n@@ -356,1 +356,1 @@\n-  if (!threads_lock.acquired() || !jt->has_last_Java_frame()) {\n+  if (!lock.acquired()) {\n@@ -362,1 +362,8 @@\n-  if (jt->thread_state() != _thread_in_native) {\n+  \/\/ If UseSystemMemoryBarrier, the OrderAccess::fence(), part of the try_lock attempt for the\n+  \/\/ Threads_lock above, is inadequate to prevent the next load of the thread state from floating up.\n+  \/\/ To prevent this, an explicit system memory barrier is needed.\n+  if (UseSystemMemoryBarrier) {\n+    SystemMemoryBarrier::emit();\n+  }\n+\n+  if (jt->thread_state() != _thread_in_native || !jt->has_last_Java_frame()) {\n","filename":"src\/hotspot\/share\/jfr\/periodic\/sampling\/jfrThreadSampler.cpp","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"}]}