{"files":[{"patch":"@@ -60,2 +60,0 @@\n-  _visited(arena()),                                        \/\/ visited node set\n-  _post_visited(arena()),                                   \/\/ post visited node set\n@@ -63,1 +61,0 @@\n-  _stk(arena(), 8, 0, nullptr),                             \/\/ scratch stack of nodes\n@@ -1062,1 +1059,0 @@\n-  \/\/  assert(s1->Opcode() == s2->Opcode(), \"check isomorphic first\");\n@@ -1065,1 +1061,9 @@\n-  if (d1 == d2) return s1 != s2;\n+\n+  if (d1 == d2) {\n+    \/\/ Same depth:\n+    \/\/  1) same node       -> dependent\n+    \/\/  2) different nodes -> same level implies there is no path\n+    return s1 != s2;\n+  }\n+\n+  \/\/ Traversal starting at the deeper node to find the shallower one.\n@@ -1068,0 +1072,1 @@\n+  int min_d = MIN2(d1, d2); \/\/ prune traversal at min_d\n@@ -1069,3 +1074,16 @@\n-  visited_clear();\n-\n-  return independent_path(shallow, deep);\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(deep);\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+      Node* pred = preds.current();\n+      if (in_bb(pred) && depth(pred) >= min_d) {\n+        if (pred == shallow) {\n+          return false; \/\/ found it -> dependent\n+        }\n+        worklist.push(pred);\n+      }\n+    }\n+  }\n+  return true; \/\/ not found -> independent\n@@ -1074,2 +1092,1 @@\n-\/\/------------------------------find_dependence---------------------\n-\/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+\/\/ Are all nodes in nodes list mutually independent?\n@@ -1077,10 +1094,7 @@\n-\/\/ in O(p.size * p.size) graph traversals. We can do it all in one BFS!\n-\/\/ Start the BFS traversal at all nodes from the pack. Traverse DepPreds\n-\/\/ recursively, for nodes that have at least depth min_d, which is the\n-\/\/ smallest depth of all nodes from the pack. Once we have traversed all\n-\/\/ those nodes, and have not found another node from the pack, we know\n-\/\/ that all nodes in the pack are independent.\n-Node* SuperWord::find_dependence(Node_List* p) {\n-  if (is_marked_reduction(p->at(0))) {\n-    return nullptr; \/\/ ignore reductions\n-  }\n+\/\/ in O(size * size) graph traversals. We can do it all in one BFS!\n+\/\/ Start the BFS traversal at all nodes from the nodes list. Traverse\n+\/\/ Preds recursively, for nodes that have at least depth min_d, which\n+\/\/ is the smallest depth of all nodes from the nodes list. Once we have\n+\/\/ traversed all those nodes, and have not found another node from the\n+\/\/ nodes list, we know that all nodes in the nodes list are independent.\n+bool SuperWord::mutually_independent(Node_List* nodes) const {\n@@ -1088,5 +1102,5 @@\n-  Unique_Node_List worklist; \/\/ traversal queue\n-  int min_d = depth(p->at(0));\n-  visited_clear();\n-  for (uint k = 0; k < p->size(); k++) {\n-    Node* n = p->at(k);\n+  Unique_Node_List worklist;\n+  VectorSet nodes_set;\n+  int min_d = depth(nodes->at(0));\n+  for (uint k = 0; k < nodes->size(); k++) {\n+    Node* n = nodes->at(k);\n@@ -1094,2 +1108,2 @@\n-    worklist.push(n); \/\/ start traversal at all nodes in p\n-    visited_set(n); \/\/ mark node\n+    worklist.push(n); \/\/ start traversal at all nodes in nodes list\n+    nodes_set.set(bb_idx(n));\n@@ -1102,2 +1116,2 @@\n-        if (visited_test(pred)) { \/\/ marked as in p?\n-          return pred;\n+        if (nodes_set.test(bb_idx(pred))) {\n+          return false; \/\/ found one -> dependent\n@@ -1109,1 +1123,1 @@\n-  return nullptr;\n+  return true; \/\/ not found -> independent\n@@ -1157,21 +1171,0 @@\n-\/\/------------------------------independent_path------------------------------\n-\/\/ Helper for independent\n-bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {\n-  if (dp >= 1000) return false; \/\/ stop deep recursion\n-  visited_set(deep);\n-  int shal_depth = depth(shallow);\n-  assert(shal_depth <= depth(deep), \"must be\");\n-  for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {\n-    Node* pred = preds.current();\n-    if (in_bb(pred) && !visited_test(pred)) {\n-      if (shallow == pred) {\n-        return false;\n-      }\n-      if (shal_depth < depth(pred) && !independent_path(shallow, pred, dp+1)) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1570,2 +1563,3 @@\n-      Node* dependence = find_dependence(p);\n-      if (dependence != nullptr) {\n+      \/\/ reductions are trivially connected\n+      if (!is_marked_reduction(p->at(0)) &&\n+          !mutually_independent(p)) {\n@@ -1576,1 +1570,0 @@\n-          dependence->dump();\n@@ -1959,12 +1952,3 @@\n-    Node* dependence = find_dependence(p);\n-    if (dependence != nullptr) {\n-      tty->print_cr(\"Other nodes in pack have dependence on:\");\n-      dependence->dump();\n-      tty->print_cr(\"The following nodes are not independent:\");\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        if (!independent(n, dependence)) {\n-          n->dump();\n-        }\n-      }\n-      tty->print_cr(\"They are all from pack[%d]\", i);\n+    if (!is_marked_reduction(p->at(0)) &&\n+        !mutually_independent(p)) {\n+      tty->print_cr(\"FAILURE: nodes not mutually independent in pack[%d]\", i);\n@@ -1972,0 +1956,1 @@\n+      assert(false, \"pack nodes not mutually independent\");\n@@ -1973,1 +1958,0 @@\n-    assert(dependence == nullptr, \"all nodes in pack must be mutually independent\");\n@@ -1977,0 +1961,1 @@\n+  ResourceMark rm;\n@@ -2947,1 +2932,0 @@\n-  assert(_stk.length() == 0,            \"stk is empty\");\n@@ -3004,2 +2988,4 @@\n-  visited_clear();\n-  post_visited_clear();\n+  ResourceMark rm;\n+  GrowableArray<Node*> stack;\n+  VectorSet visited;\n+  VectorSet post_visited;\n@@ -3010,2 +2996,2 @@\n-    visited_set(n);\n-    _stk.push(n);\n+    visited.set(bb_idx(n));\n+    stack.push(n);\n@@ -3013,2 +2999,2 @@\n-  visited_set(entry);\n-  _stk.push(entry);\n+  visited.set(bb_idx(entry));\n+  stack.push(entry);\n@@ -3020,3 +3006,3 @@\n-  while ((size = _stk.length()) > 0) {\n-    Node* n = _stk.top(); \/\/ Leave node on stack\n-    if (!visited_test_set(n)) {\n+  while ((size = stack.length()) > 0) {\n+    Node* n = stack.top(); \/\/ Leave node on stack\n+    if (!visited.test_set(bb_idx(n))) {\n@@ -3024,1 +3010,1 @@\n-    } else if (!post_visited_test(n)) {\n+    } else if (!post_visited.test(bb_idx(n))) {\n@@ -3028,1 +3014,1 @@\n-        if (in_bb(use) && !visited_test(use) &&\n+        if (in_bb(use) && !visited.test(bb_idx(use)) &&\n@@ -3039,1 +3025,1 @@\n-          _stk.push(use);\n+          stack.push(use);\n@@ -3042,1 +3028,1 @@\n-      if (_stk.length() == size) {\n+      if (stack.length() == size) {\n@@ -3044,1 +3030,1 @@\n-        _stk.pop(); \/\/ Remove node from stack\n+        stack.pop(); \/\/ Remove node from stack\n@@ -3048,2 +3034,2 @@\n-        post_visited_set(n);\n-        assert(rpo_idx >= 0 || _stk.is_empty(), \"\");\n+        post_visited.set(bb_idx(n));\n+        assert(rpo_idx >= 0 || stack.is_empty(), \"\");\n@@ -3052,1 +3038,1 @@\n-      _stk.pop(); \/\/ Remove post-visited node from stack\n+      stack.pop(); \/\/ Remove post-visited node from stack\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":71,"deletions":85,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -227,2 +227,0 @@\n-  VectorSet    _visited;       \/\/ Visited set\n-  VectorSet    _post_visited;  \/\/ Post-visited set\n@@ -230,1 +228,0 @@\n-  GrowableArray<Node*> _stk;   \/\/ Stack of nodes\n@@ -309,9 +306,0 @@\n-  \/\/ visited set accessors\n-  void visited_clear()           { _visited.clear(); }\n-  void visited_set(Node* n)      { return _visited.set(bb_idx(n)); }\n-  int visited_test(Node* n)      { return _visited.test(bb_idx(n)); }\n-  int visited_test_set(Node* n)  { return _visited.test_set(bb_idx(n)); }\n-  void post_visited_clear()      { _post_visited.clear(); }\n-  void post_visited_set(Node* n) { return _post_visited.set(bb_idx(n)); }\n-  int post_visited_test(Node* n) { return _post_visited.test(bb_idx(n)); }\n-\n@@ -329,1 +317,1 @@\n-  int depth(Node* n)                         { return _node_info.adr_at(bb_idx(n))->_depth; }\n+  int depth(Node* n) const                   { return _node_info.adr_at(bb_idx(n))->_depth; }\n@@ -432,2 +420,2 @@\n-  \/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n-  Node* find_dependence(Node_List* p);\n+  \/\/ Are all nodes in nodes list mutually independent?\n+  bool mutually_independent(Node_List* nodes) const;\n@@ -439,2 +427,0 @@\n-  \/\/ Helper for independent\n-  bool independent_path(Node* shallow, Node* deep, uint dp=0);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":17,"binary":false,"changes":20,"status":"modified"}]}