{"files":[{"patch":"@@ -61,2 +61,0 @@\n-  _visited(arena()),                                        \/\/ visited node set\n-  _post_visited(arena()),                                   \/\/ post visited node set\n@@ -65,1 +63,0 @@\n-  _stk(arena(), 8, 0, nullptr),                             \/\/ scratch stack of nodes\n@@ -1080,1 +1077,0 @@\n-  \/\/  assert(s1->Opcode() == s2->Opcode(), \"check isomorphic first\");\n@@ -1083,1 +1079,9 @@\n-  if (d1 == d2) return s1 != s2;\n+\n+  if (d1 == d2) {\n+    \/\/ Same depth:\n+    \/\/  1) same node       -> dependent\n+    \/\/  2) different nodes -> same level implies there is no path\n+    return s1 != s2;\n+  }\n+\n+  \/\/ Traversal starting at the deeper node to find the shallower one.\n@@ -1086,0 +1090,1 @@\n+  int min_d = MIN2(d1, d2); \/\/ prune traversal at min_d\n@@ -1087,3 +1092,16 @@\n-  visited_clear();\n-\n-  return independent_path(shallow, deep);\n+  ResourceMark rm;\n+  Unique_Node_List worklist;\n+  worklist.push(deep);\n+  for (uint i = 0; i < worklist.size(); i++) {\n+    Node* n = worklist.at(i);\n+    for (DepPreds preds(n, _dg); !preds.done(); preds.next()) {\n+      Node* pred = preds.current();\n+      if (in_bb(pred) && depth(pred) >= min_d) {\n+        if (pred == shallow) {\n+          return false; \/\/ found it -> dependent\n+        }\n+        worklist.push(pred);\n+      }\n+    }\n+  }\n+  return true; \/\/ not found -> independent\n@@ -1092,2 +1110,1 @@\n-\/\/------------------------------find_dependence---------------------\n-\/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n+\/\/ Are all nodes in nodes list mutually independent?\n@@ -1095,10 +1112,7 @@\n-\/\/ in O(p.size * p.size) graph traversals. We can do it all in one BFS!\n-\/\/ Start the BFS traversal at all nodes from the pack. Traverse DepPreds\n-\/\/ recursively, for nodes that have at least depth min_d, which is the\n-\/\/ smallest depth of all nodes from the pack. Once we have traversed all\n-\/\/ those nodes, and have not found another node from the pack, we know\n-\/\/ that all nodes in the pack are independent.\n-Node* SuperWord::find_dependence(Node_List* p) {\n-  if (is_marked_reduction(p->at(0))) {\n-    return nullptr; \/\/ ignore reductions\n-  }\n+\/\/ in O(size * size) graph traversals. We can do it all in one BFS!\n+\/\/ Start the BFS traversal at all nodes from the nodes list. Traverse\n+\/\/ Preds recursively, for nodes that have at least depth min_d, which\n+\/\/ is the smallest depth of all nodes from the nodes list. Once we have\n+\/\/ traversed all those nodes, and have not found another node from the\n+\/\/ nodes list, we know that all nodes in the nodes list are independent.\n+bool SuperWord::mutually_independent(Node_List* nodes) const {\n@@ -1106,5 +1120,5 @@\n-  Unique_Node_List worklist; \/\/ traversal queue\n-  int min_d = depth(p->at(0));\n-  visited_clear();\n-  for (uint k = 0; k < p->size(); k++) {\n-    Node* n = p->at(k);\n+  Unique_Node_List worklist;\n+  VectorSet nodes_set;\n+  int min_d = depth(nodes->at(0));\n+  for (uint k = 0; k < nodes->size(); k++) {\n+    Node* n = nodes->at(k);\n@@ -1112,2 +1126,2 @@\n-    worklist.push(n); \/\/ start traversal at all nodes in p\n-    visited_set(n); \/\/ mark node\n+    worklist.push(n); \/\/ start traversal at all nodes in nodes list\n+    nodes_set.set(bb_idx(n));\n@@ -1120,2 +1134,2 @@\n-        if (visited_test(pred)) { \/\/ marked as in p?\n-          return pred;\n+        if (nodes_set.test(bb_idx(pred))) {\n+          return false; \/\/ found one -> dependent\n@@ -1127,1 +1141,1 @@\n-  return nullptr;\n+  return true; \/\/ not found -> independent\n@@ -1175,21 +1189,0 @@\n-\/\/------------------------------independent_path------------------------------\n-\/\/ Helper for independent\n-bool SuperWord::independent_path(Node* shallow, Node* deep, uint dp) {\n-  if (dp >= 1000) return false; \/\/ stop deep recursion\n-  visited_set(deep);\n-  int shal_depth = depth(shallow);\n-  assert(shal_depth <= depth(deep), \"must be\");\n-  for (DepPreds preds(deep, _dg); !preds.done(); preds.next()) {\n-    Node* pred = preds.current();\n-    if (in_bb(pred) && !visited_test(pred)) {\n-      if (shallow == pred) {\n-        return false;\n-      }\n-      if (shal_depth < depth(pred) && !independent_path(shallow, pred, dp+1)) {\n-        return false;\n-      }\n-    }\n-  }\n-  return true;\n-}\n-\n@@ -1588,2 +1581,3 @@\n-      Node* dependence = find_dependence(p);\n-      if (dependence != nullptr) {\n+      \/\/ reductions are trivially connected\n+      if (!is_marked_reduction(p->at(0)) &&\n+          !mutually_independent(p)) {\n@@ -1594,1 +1588,0 @@\n-          dependence->dump();\n@@ -1977,12 +1970,3 @@\n-    Node* dependence = find_dependence(p);\n-    if (dependence != nullptr) {\n-      tty->print_cr(\"Other nodes in pack have dependence on:\");\n-      dependence->dump();\n-      tty->print_cr(\"The following nodes are not independent:\");\n-      for (uint k = 0; k < p->size(); k++) {\n-        Node* n = p->at(k);\n-        if (!independent(n, dependence)) {\n-          n->dump();\n-        }\n-      }\n-      tty->print_cr(\"They are all from pack[%d]\", i);\n+    if (!is_marked_reduction(p->at(0)) &&\n+        !mutually_independent(p)) {\n+      tty->print_cr(\"FAILURE: nodes not mutually independent in pack[%d]\", i);\n@@ -1990,0 +1974,1 @@\n+      assert(false, \"pack nodes not mutually independent\");\n@@ -1991,1 +1976,0 @@\n-    assert(dependence == nullptr, \"all nodes in pack must be mutually independent\");\n@@ -1995,0 +1979,1 @@\n+  ResourceMark rm;\n@@ -2988,1 +2973,0 @@\n-  assert(_stk.length() == 0,            \"stk is empty\");\n@@ -3045,2 +3029,4 @@\n-  visited_clear();\n-  post_visited_clear();\n+  ResourceMark rm;\n+  GrowableArray<Node*> stack;\n+  VectorSet visited;\n+  VectorSet post_visited;\n@@ -3051,2 +3037,2 @@\n-    visited_set(n);\n-    _stk.push(n);\n+    visited.set(bb_idx(n));\n+    stack.push(n);\n@@ -3054,2 +3040,2 @@\n-  visited_set(entry);\n-  _stk.push(entry);\n+  visited.set(bb_idx(entry));\n+  stack.push(entry);\n@@ -3061,3 +3047,3 @@\n-  while ((size = _stk.length()) > 0) {\n-    Node* n = _stk.top(); \/\/ Leave node on stack\n-    if (!visited_test_set(n)) {\n+  while ((size = stack.length()) > 0) {\n+    Node* n = stack.top(); \/\/ Leave node on stack\n+    if (!visited.test_set(bb_idx(n))) {\n@@ -3065,1 +3051,1 @@\n-    } else if (!post_visited_test(n)) {\n+    } else if (!post_visited.test(bb_idx(n))) {\n@@ -3069,1 +3055,1 @@\n-        if (in_bb(use) && !visited_test(use) &&\n+        if (in_bb(use) && !visited.test(bb_idx(use)) &&\n@@ -3080,1 +3066,1 @@\n-          _stk.push(use);\n+          stack.push(use);\n@@ -3083,1 +3069,1 @@\n-      if (_stk.length() == size) {\n+      if (stack.length() == size) {\n@@ -3085,1 +3071,1 @@\n-        _stk.pop(); \/\/ Remove node from stack\n+        stack.pop(); \/\/ Remove node from stack\n@@ -3089,2 +3075,2 @@\n-        post_visited_set(n);\n-        assert(rpo_idx >= 0 || _stk.is_empty(), \"\");\n+        post_visited.set(bb_idx(n));\n+        assert(rpo_idx >= 0 || stack.is_empty(), \"\");\n@@ -3093,1 +3079,1 @@\n-      _stk.pop(); \/\/ Remove post-visited node from stack\n+      stack.pop(); \/\/ Remove post-visited node from stack\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":71,"deletions":85,"binary":false,"changes":156,"status":"modified"},{"patch":"@@ -257,2 +257,0 @@\n-  VectorSet    _visited;       \/\/ Visited set\n-  VectorSet    _post_visited;  \/\/ Post-visited set\n@@ -340,9 +338,0 @@\n-  \/\/ visited set accessors\n-  void visited_clear()           { _visited.clear(); }\n-  void visited_set(Node* n)      { return _visited.set(bb_idx(n)); }\n-  int visited_test(Node* n)      { return _visited.test(bb_idx(n)); }\n-  int visited_test_set(Node* n)  { return _visited.test_set(bb_idx(n)); }\n-  void post_visited_clear()      { _post_visited.clear(); }\n-  void post_visited_set(Node* n) { return _post_visited.set(bb_idx(n)); }\n-  int post_visited_test(Node* n) { return _post_visited.test(bb_idx(n)); }\n-\n@@ -360,1 +349,1 @@\n-  int depth(Node* n)                         { return _node_info.adr_at(bb_idx(n))->_depth; }\n+  int depth(Node* n) const                   { return _node_info.adr_at(bb_idx(n))->_depth; }\n@@ -463,2 +452,2 @@\n-  \/\/ Is any s1 in p dependent on any s2 in p? Yes: return such a s2. No: return nullptr.\n-  Node* find_dependence(Node_List* p);\n+  \/\/ Are all nodes in nodes list mutually independent?\n+  bool mutually_independent(Node_List* nodes) const;\n@@ -470,2 +459,0 @@\n-  \/\/ Helper for independent\n-  bool independent_path(Node* shallow, Node* deep, uint dp=0);\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":3,"deletions":16,"binary":false,"changes":19,"status":"modified"}]}