{"files":[{"patch":"@@ -85,3 +85,0 @@\n-#undef KELVIN_VISIBLE\n-#undef KELVIN_DEBUG\n-\n@@ -134,1 +131,0 @@\n-#undef KELVIN_VISIBLE\n@@ -136,3 +132,0 @@\n-#ifdef KELVIN_VISIBLE\n-  log_info(gc)(\"post_initialize() sets _free_set to \" PTR_FORMAT, p2i(_free_set));\n-#endif\n@@ -143,3 +136,0 @@\n-#ifdef KELVIN_VISIBLE\n-    log_info(gc)(\"post_initialize() to recalculate young trigger with: %zu\", young_available);\n-#endif\n@@ -151,3 +141,0 @@\n-#ifdef KELVIN_VISIBLE\n-    log_info(gc)(\"post_initialize() to recalculate global trigger with: %zu\", global_available);\n-#endif\n@@ -159,4 +146,0 @@\n-#ifdef KELVIN_VISIBLE\n-  log_info(gc)(\"get_most_recent_wake_time(), regulator_thread: \" PTR_FORMAT \", control_thread: \" PTR_FORMAT,\n-               p2i(_regulator_thread), p2i(_control_thread));\n-#endif\n@@ -167,4 +150,0 @@\n-#ifdef KELVIN_VISIBLE\n-  log_info(gc)(\"get_most_recent_wake_time(), regulator_thread: \" PTR_FORMAT \", control_thread: \" PTR_FORMAT,\n-               p2i(_regulator_thread), p2i(_control_thread));\n-#endif\n@@ -174,4 +153,0 @@\n-#undef KELVIN_VERBOSE\n-\n-#undef KELVIN_IDLE_SPAN\n-\n@@ -184,5 +159,0 @@\n-#undef KELVIN_IDLE_SPAN\n-#ifdef KELVIN_IDLE_SPAN\n-  log_info(gc)(\"@recalculate_trigger_threshold(mutator_available: %zu) for _space_info: %s\",\n-               mutator_available, _space_info->name());\n-#endif\n@@ -195,4 +165,0 @@\n-#ifdef KELVIN_IDLE_SPAN\n-  size_t original_mutator_available = mutator_available;\n-#endif\n-\n@@ -201,4 +167,0 @@\n-#ifdef KELVIN_IDLE_SPAN\n-  log_info(gc)(\"@recalculate_trigger_threshold(mutator_available: %zu), spike_headroom: %zu\"\n-               \", penalties: %zu\", mutator_available, spike_headroom, penalties);\n-#endif\n@@ -224,9 +186,0 @@\n-\n-#ifdef KELVIN_IDLE_SPAN\n-  log_info(gc)(\"%s: recalculate trigger, capacity: %zu, original_mutator_available: %zu\"\n-               \", spike_headroom: %zu, penalties: %zu\"\n-               \", used: %zu, reserved: %zu, final answer: %zu\",\n-               _space_info->name(), capacity, original_mutator_available, spike_headroom, penalties, _space_info->used(),\n-               _free_set->reserved(), _trigger_threshold);\n-#endif\n-#undef KELVIN_IDLE_SPAN\n@@ -236,5 +189,0 @@\n-#undef KELVIN_IDLE_SPAN\n-#ifdef KELVIN_IDLE_SPAN\n-  log_info(gc)(\"Made it to ShenanoahAdaptiveHeuristics:start_idle_span(), _free_set: \" PTR_FORMAT \", _space_info: \" PTR_FORMAT,\n-               p2i(_free_set), p2i(_space_info));\n-#endif\n@@ -242,10 +190,0 @@\n-\n-#ifdef KELVIN_IDLE_SPAN\n-  log_info(gc)(\"Made it to ShenanoahAdaptiveHeuristics:%s::start_idle_span() with available %zu\",\n-               _space_info->name(), mutator_available);\n-#endif\n-\n-#ifdef KELVIN_VISIBLE\n-  log_info(gc)(\"start_idle_span() is recalculating %s trigger threshold with available: %zu\",\n-               _space_info->name(), mutator_available);\n-#endif\n@@ -253,1 +191,0 @@\n-#undef KELVIN_IDLE_SPAN\n@@ -258,3 +195,0 @@\n-#ifdef KELVIN_VISIBLE\n-  log_info(gc)(\"resume_idle_span() is recalculating trigger threshold with available: %zu\", mutator_available);\n-#endif\n@@ -268,3 +202,0 @@\n-#ifdef KELVIN_VISIBLE\n-  log_info(gc)(\"start_evac_span() is setting (pacing) trigger threshold with available: %zu\", mutator_available);\n-#endif\n@@ -339,5 +270,0 @@\n-#undef KELVIN_VERBOSITY\n-#ifdef KELVIN_VERBOSITY\n-  log_info(gc)(\"add_degen_gc_time(%0.3fs, %0.3fs) if > predict_gc_time: %0.3f\",\n-               timestamp, gc_time, predict_gc_time(timestamp));\n-#endif\n@@ -374,8 +300,0 @@\n-#ifdef KELVIN_VERBOSITY\n-  log_info(gc)(\"add_gc_time(%0.6f, %0.6f), samples: %u\", timestamp, gc_time, _gc_time_num_samples);\n-  for (uint i = 0; i < _gc_time_num_samples; i++) {\n-    uint index = (_gc_time_first_sample_index + i) % GC_TIME_SAMPLE_SIZE;\n-    log_info(gc)(\" @%0.6fs, GC time: %0.6fs\", _gc_time_timestamps[index], _gc_time_samples[index]);\n-  }\n-#endif\n-\n@@ -408,4 +326,0 @@\n-#ifdef KELVIN_VERBOSITY\n-      log_info(gc)(\"predicted_y: %0.3f, deviation: %0.3f, sum_of_squareds: %0.3f\",\n-                   predicted_y, deviation, sum_of_squared_deviations);\n-#endif\n@@ -415,4 +329,0 @@\n-\n-#ifdef KELVIN_VERBOSITY\n-  log_info(gc)(\" GC(t) = %0.3f * t + %0.3f, with stdev: %0.3f\", _gc_time_m, _gc_time_b, _gc_time_sd);\n-#endif\n@@ -422,9 +332,1 @@\n-  double result = _gc_time_m * timestamp_at_start + _gc_time_b + _gc_time_sd * _margin_of_error_sd;;\n-\n-#ifdef KELVIN_VERBOSITY\n-  log_info(gc)(\"predict_gc_time(_gc_time_m: %0.3f, @start: %0.3f, _gc_time_b: %0.3f, _gc_time_sd: %0.3f, \"\n-               \"margin_of_error: %0.3f => result: %0.3f\",\n-               _gc_time_m, timestamp_at_start, _gc_time_b, _gc_time_sd, _margin_of_error_sd, result);\n-#endif\n-\n-  return result;\n+  return _gc_time_m * timestamp_at_start + _gc_time_b + _gc_time_sd * _margin_of_error_sd;;\n@@ -526,2 +428,0 @@\n-#undef KELVIN_NEEDS_TO_SEE\n-\n@@ -532,97 +432,0 @@\n-#ifdef KELVIN_VERBOSE\n-static size_t _global_allocatable_words;\n-static size_t _global_available_bytes;\n-static size_t _global_min_threshold;\n-#endif\n-\n-#undef KELVIN_START_GC\n-#ifdef KELVIN_START_GC\n-const size_t MaxRejectedTriggers = 256;\n-typedef struct gc_start_info {\n-  double time_stamp;\n-  size_t capacity;\n-  size_t available;\n-  size_t allocated;\n-  size_t min_threshold;\n-  size_t learned_steps;\n-  double avg_alloc_rate;\n-  size_t allocatable_words;\n-  double avg_cycle_time;\n-  double predicted_future_accelerated_gc_time;\n-  size_t allocated_bytes_since_last_sample;\n-  double instantaneous_rate_words_per_second;\n-  double current_rate_by_acceleration;;\n-  size_t consumption_accelerated;\n-  double acceleration;\n-  double predicted_future_gc_time;\n-  double future_planned_gc_time;\n-  double avg_time_to_deplete_available;\n-  bool is_spiking;\n-  double spike_rate;\n-  double spike_time_to_deplete_available;\n-} TriggerInfo;\n-\n-\/\/ Most recently logged data represents the accepted trigger\n-static void dumpTriggerInfo(size_t first_trigger, size_t rejected_triggers, TriggerInfo* trigger_log) {\n-  static const char* const header[] = {\n-    \"\\n\",\n-    \"TimeStamp, Capacity (Bytes), Available (Bytes), Allocated (Bytes), \"\n-    \"Min Threshold (Bytes), Learned Steps, Average Allocation Rate (MB\/s), \"\n-    \"Allocatable (Words), Average Cycle Time (seconds), \"\n-    \"Predicted Accelerated GC Time (seconds), \"\n-    \"Allocated Since Last Sample (bytes), \"\n-    \"Instantaneous Allocation Rate (MB\/s), \"\n-    \"Current Allocation Rate by Acceleration (MB\/s), \"\n-    \"Accelerated Consumption (bytes), \"\n-    \"Acceleration (MB\/s\/s), Predicted Future GC Time (seconds), \"\n-    \"Future Planned GC Time (seconds), \"\n-    \"Average Time to Deplete Available (seconds), \"\n-    \"Is Spiking, Spike Rate (MB\/s), \"\n-    \"Spike Time to Deplete Available (s)\",\n-    \"                                                Min         Learned      Allocatable        Predicted                     Current                              Planned                   Spike\",\n-    \"TimeStamp Capacity     Available    Allocated   Threshold   Steps        (bytes)            Accelerated                   Rate by                              GC     Avg                Time\",\n-    \"|         (Bytes)      (Bytes)      (Bytes)     (Bytes)     |  Avg       |           Avg    GC     Allocated              Accel      Accelerated               Time   Time               to\",\n-    \"|         |            |            |           |           |  Alloc     |           Cycle  Time   Since                  (MB\/s)     Consumption               (s)    to                 Deplete\",\n-    \"|         |            |            |           |           |  Rate      |           Time   (s)    Last                   |          (bytes)                   |      Deplete            Available\",\n-    \"|         |            |            |           |           |  (MB\/s)    |           (s)    |      Sample                 |          |           Accel         |      Avail   Is         (s)\",\n-    \"|         |            |            |           |           |  |         |           |      |      (bytes)                |          |           MB\/s^2)       |      (s)     Spiking    |\",\n-    \"|         |            |            |           |           |  |         |           |      |      |           Spike      |          |           |      Future |      |       |   Spike  |\",\n-    \"|         |            |            |           |           |  |         |           |      |      |           Alloc      |          |           |      GC     |      |       |   Rate   |\",\n-    \"|         |            |            |           |           |  |         |           |      |      |           Rate       |          |           |      Time   |      |       |   (MB\/s) |\",\n-    \"|         |            |            |           |           |  |         |           |      |      |           (MB\/s)     |          |           |      (s)    |      |       |   |      |\",\n-    \"|         |            |            |           |           |  |         |           |      |      |           |          |          |           |      |      |      |       |   |      |\",\n-    \"v         v            v            v           v           v  v         v           v      v      v           v          v          v           v      v      v      v       v   v      v\"\n-  };\n-  for (unsigned int i = 0; i < sizeof(header) \/ sizeof(void*); i++) {\n-    log_info(gc)(\"%s\", header[i]);\n-  }\n-  for (unsigned int i = 0; i < rejected_triggers; i++) {\n-    size_t __index = (first_trigger + i) % MaxRejectedTriggers;\n-    log_info(gc)(\"%.6f, %zu, %zu, %zu, %zu, %zu, \"\n-                 \"%.3f, %zu, %.3f, %.3f, %zu, %.3f, %.3f, %zu, %.3f, %.3f, %.3f, %.3f, \"\n-                 \"%s, %.3f, %.3f\",\n-                 trigger_log[__index].time_stamp,\n-                 trigger_log[__index].capacity,\n-                 trigger_log[__index].available,\n-                 trigger_log[__index].allocated,\n-                 trigger_log[__index].min_threshold,\n-                 trigger_log[__index].learned_steps,\n-                 trigger_log[__index].avg_alloc_rate \/ (1024*1024),\n-                 trigger_log[__index].allocatable_words * HeapWordSize,\n-                 trigger_log[__index].avg_cycle_time,\n-                 trigger_log[__index].predicted_future_accelerated_gc_time,\n-                 trigger_log[__index].allocated_bytes_since_last_sample,\n-                 (trigger_log[__index].instantaneous_rate_words_per_second * HeapWordSize) \/ (1024*1024),\n-                 (trigger_log[__index].current_rate_by_acceleration * HeapWordSize) \/ (1024*1024),\n-                 trigger_log[__index].consumption_accelerated * HeapWordSize,\n-                 (trigger_log[__index].acceleration * HeapWordSize) \/ (1024*1024),\n-                 trigger_log[__index].predicted_future_gc_time,\n-                 trigger_log[__index].future_planned_gc_time,\n-                 trigger_log[__index].avg_time_to_deplete_available,\n-                 trigger_log[__index].is_spiking? \"yes\": \"no\",\n-                 trigger_log[__index].spike_rate \/ (1024*1024),\n-                 trigger_log[__index].spike_time_to_deplete_available);\n-  }\n-}\n-#endif\n-\n@@ -658,60 +461,0 @@\n-\n-#ifdef KELVIN_START_GC\n-  static TriggerInfo rejected_trigger_log[MaxRejectedTriggers];\n-  static size_t rejected_trigger_count = 0;\n-  static size_t first_rejected_trigger = 0;\n-\n-#define AppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,      \\\n-                          irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda)         \\\n-  if (rejected_trigger_count >= MaxRejectedTriggers) {                                      \\\n-    first_rejected_trigger++;                                                               \\\n-    if (first_rejected_trigger >= MaxRejectedTriggers)  {                                   \\\n-      first_rejected_trigger = 0;                                                           \\\n-    }                                                                                       \\\n-  } else {                                                                                  \\\n-    rejected_trigger_count++;                                                               \\\n-  }                                                                                         \\\n-  log_info(gc)(\"AppendTrigger(first_rejected: %zu, rejected_count: %zu) @%.6f\",             \\\n-               first_rejected_trigger, rejected_trigger_count, ts);                         \\\n-  {                                                                                         \\\n-    size_t __j;                                                                             \\\n-    __j = (first_rejected_trigger + rejected_trigger_count - 1) % MaxRejectedTriggers;      \\\n-    rejected_trigger_log[__j].time_stamp = ts;                                              \\\n-    rejected_trigger_log[__j].capacity = cap;                                               \\\n-    rejected_trigger_log[__j].available = avail;                                            \\\n-    rejected_trigger_log[__j].allocated = alloced;                                          \\\n-    rejected_trigger_log[__j].min_threshold = mt;                                           \\\n-    rejected_trigger_log[__j].learned_steps = ls;                                           \\\n-    rejected_trigger_log[__j].avg_alloc_rate = aar;                                         \\\n-    rejected_trigger_log[__j].allocatable_words = aw;                                       \\\n-    rejected_trigger_log[__j].avg_cycle_time = act;                                         \\\n-    rejected_trigger_log[__j].predicted_future_accelerated_gc_time = pfagt;                 \\\n-    rejected_trigger_log[__j].allocated_bytes_since_last_sample = absls;                    \\\n-    rejected_trigger_log[__j].instantaneous_rate_words_per_second = irwps;                  \\\n-    rejected_trigger_log[__j].current_rate_by_acceleration = crba;                          \\\n-    rejected_trigger_log[__j].consumption_accelerated = ca;                                 \\\n-    rejected_trigger_log[__j].acceleration = accel;                                         \\\n-    rejected_trigger_log[__j].predicted_future_gc_time = pfgt;                              \\\n-    rejected_trigger_log[__j].future_planned_gc_time = fpgt;                                \\\n-    rejected_trigger_log[__j].avg_time_to_deplete_available = attda;                        \\\n-    rejected_trigger_log[__j].is_spiking = is;                                              \\\n-    rejected_trigger_log[__j].spike_rate = sr;                                              \\\n-    rejected_trigger_log[__j].spike_time_to_deplete_available = sttda;                      \\\n-  }\n-\n-#define DumpTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,        \\\n-                        irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda)           \\\n-  AppendTriggerInfo(ts, cap, avail, alloced, mt, ls,                                        \\\n-                    aar, aw, act, pfagt, absls, irwps, crba, ca, accel,                     \\\n-                    pfgt, fpgt, attda, is, sr, sttda);                                      \\\n-  dumpTriggerInfo(first_rejected_trigger, rejected_trigger_count, rejected_trigger_log);    \\\n-  rejected_trigger_count = 0;                                                               \\\n-  first_rejected_trigger = 0;\n-\n-#else\n-#define AppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,      \\\n-                          irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda) ;\n-\n-#define DumpTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,        \\\n-                        irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda) ;\n-#endif\n@@ -733,3 +476,0 @@\n-#ifdef KELVIN_START_GC\n-  size_t learned_steps = _gc_times_learned;\n-#endif\n@@ -753,6 +493,0 @@\n-    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                    acceleration, predicted_future_gc_time,\n-                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                    spike_time_to_deplete_available);\n@@ -772,6 +506,0 @@\n-    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                    acceleration, predicted_future_gc_time,\n-                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                    spike_time_to_deplete_available);\n@@ -781,14 +509,0 @@\n-#ifdef KELVIN_DEBUG\n-  _global_available_bytes = available;\n-  _global_min_threshold = min_threshold;\n-#endif\n-\n-#ifdef KELVIN_NEEDS_TO_SEE\n-  log_info(gc)(\"should_start_gc? did not trigger for minimum threshold\");\n-#endif\n-\n-#undef KELVIN_TRACE_START\n-#ifdef KELVIN_TRACE_START\n-  log_info(gc)(\"should_start?  learning steps: %zu, capacity: %zu\", _gc_times_learned, capacity);\n-#endif\n-\n@@ -805,6 +519,0 @@\n-      DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                      avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                      instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                      acceleration, predicted_future_gc_time,\n-                      future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                      spike_time_to_deplete_available);\n@@ -813,4 +521,0 @@\n-#ifdef KELVIN_NEEDS_TO_SEE\n-    log_info(gc)(\"should_start_gc? did not meet init threshold, available: %zu, init_threshold: %zu\",\n-                 available, init_threshold);\n-#endif\n@@ -819,5 +523,0 @@\n-#ifdef KELVIN_NEEDS_TO_SEE\n-  log_info(gc)(\"should_start_gc? did not trigger for learning, _gc_times_learned: %zu, max_learn: %zu\",\n-               _gc_times_learned, max_learn);\n-#endif\n-\n@@ -844,10 +543,0 @@\n-\n-#ifdef KELVIN_TRACE_START\n-    log_info(gc)(\"should_start_gc()?, predicted_future_accelerated_gc_time: %0.3f, avg_gc_cycle_time: %0.3f\"\n-                 \", allocated_bytes_since_last_sample: %zu, instantaneous_rate: %0.3f MB\/s\",\n-                 predicted_future_accelerated_gc_time, avg_cycle_time, allocated_bytes_since_last_sample,\n-                 (instantaneous_rate_words_per_second * HeapWordSize) \/ (1024 * 1024));\n-#endif\n-#ifdef KELVIN_DEBUG\n-    _global_allocatable_words = allocatable_words;\n-#endif\n@@ -860,8 +549,0 @@\n-#ifdef KELVIN_TRACE_START\n-    log_info(gc)(\"should_start_gc() checking instantaneous allocation, \"\n-                 \"instantaneous_rate: %0.3f MB\/s, acceleration: %0.3f MB\/s\/s\"\n-                 \", accelerated consumption:%zu\",\n-                 (current_rate_by_acceleration * HeapWordSize) \/ (1024 * 1024),\n-                 (acceleration * HeapWordSize) \/ (1024 * 1024), consumption_accelerated * HeapWordSize);\n-#endif\n-\n@@ -974,9 +655,0 @@\n-#ifdef KELVIN_SATB\n-      log_info(gc)(\" avg_alloc_rate is: %0.3f MB\/s\", avg_alloc_rate \/ (1024 * 1024));\n-      for (uint i = 0; i < _spike_acceleration_num_samples; i++) {\n-        uint index = (_spike_acceleration_first_sample_index + i) % ShenandoahRateAccelerationSampleSize;\n-        log_info(gc)(\" accel_consumption[%u] @%0.6f s: %0.6f MB\/s\", i, _spike_acceleration_rate_timestamps[index],\n-                     _spike_acceleration_rate_samples[index] * HeapWordSize \/ (1024 * 1024));\n-      }\n-#endif\n-\n@@ -989,6 +661,0 @@\n-      DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                      avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                      instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                      acceleration, predicted_future_gc_time,\n-                      future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                      spike_time_to_deplete_available);\n@@ -1009,5 +675,0 @@\n-#ifdef KELVIN_SATB\n-  log_info(gc)(\"should_start_gc? future: %0.3f, predicted_future_gc_time: %0.3f\",\n-               now + get_planned_sleep_interval(), predicted_future_gc_time);\n-#endif\n-\n@@ -1020,17 +681,0 @@\n-#ifdef KELVIN_TRACE_START\n-  {\n-    log_info(gc)\n-      (\"should_start(), rate: %.3f MB\/s, capacity: %zu, available: %zu, allocated: %zu, avg_cycle: %.3f s, avg_rate: %.3f MB\/s\",\n-       rate, capacity, available, allocated, avg_cycle_time, avg_alloc_rate \/ (1024 * 1024));\n-    size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n-    size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n-    size_t allocation_headroom = available;\n-    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n-    allocation_headroom -= MIN2(allocation_headroom, penalties);\n-    log_info(gc)(\"  allocation_headroom: %zu, spike_headroom: %zu, penalties: %zu\",\n-                 allocation_headroom, spike_headroom, penalties);\n-  }\n-#endif\n-\n-\n-\n@@ -1056,6 +700,0 @@\n-    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                      avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                      instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                      acceleration, predicted_future_gc_time,\n-                      future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                      spike_time_to_deplete_available);\n@@ -1075,6 +713,0 @@\n-    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                    acceleration, predicted_future_gc_time,\n-                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                    spike_time_to_deplete_available);\n@@ -1086,6 +718,0 @@\n-    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                    acceleration, predicted_future_gc_time,\n-                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                    spike_time_to_deplete_available);\n@@ -1094,6 +720,0 @@\n-    AppendTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n-                      avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n-                      instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n-                      acceleration, predicted_future_gc_time,\n-                      future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n-                      spike_time_to_deplete_available);\n@@ -1155,5 +775,0 @@\n-#undef KELVIN_NEEDS_TO_SEE\n-#ifdef KELVIN_NEEDS_TO_SEE\n-      log_info(gc)(\" accel_consumption[%u, index: %u] @%0.6f s: %0.6f MB\/s\", i, index, _spike_acceleration_rate_timestamps[index],\n-                   _spike_acceleration_rate_samples[index] * HeapWordSize \/ (1024 * 1024));\n-#endif\n@@ -1188,5 +803,0 @@\n-#ifdef KELVIN_NEEDS_TO_SEE\n-      log_info(gc)(\" momentary_rate computed from sample[%u] @ index %u, preceding %u with weight %.3f and rate %.3f MB\/s\",\n-                   i, sample_index, preceding_index, sample_weight,\n-                   _spike_acceleration_rate_samples[sample_index] * HeapWordSize \/ (1024 * 1024));\n-#endif\n@@ -1197,3 +807,0 @@\n-#ifdef KELVIN_NEEDS_TO_SEE\n-    log_info(gc)(\" momentary_rate final answer: %.3f MB\/s\", (momentary_rate * HeapWordSize) \/ (1024 * 1024));\n-#endif\n@@ -1201,7 +808,0 @@\n-#ifdef KELVIN_NEEDS_TO_SEE\n-    log_info(gc)(\" is_spiking? %s, momentary_rate: %.3f, average: %.3f, is zscore: %.3f > threshold: %.3f?\",\n-                 is_spiking? \"yes\": \"no\", (momentary_rate * HeapWordSize) \/ (1024 * 1024),\n-                 (_allocation_rate._rate.avg() * HeapWordSize) \/ (1024 * 1024),\n-                 (momentary_rate - _allocation_rate._rate.avg()) \/ _allocation_rate._rate.sd(),\n-                 _spike_threshold_sd);\n-#endif\n@@ -1229,4 +829,0 @@\n-#ifdef KELVIN_NEEDS_TO_SEE\n-      log_info(gc)(\"Calculating best-fit acceleration from x_array[%u]: %.3f and y_array[%u]: %.3f MB\/s\",\n-                   i, x_array[i], i, (y_array[i] * HeapWordSize) \/ (1024 * 1024));\n-#endif\n@@ -1246,6 +842,0 @@\n-#ifdef KELVIN_NEEDS_TO_SEE\n-    log_info(gc)(\"Calculated acceleration: %.3f MB\/s\/s, intercept: %.3f MB\/s\",\n-                 (m * HeapWordSize) \/ (1024 * 1024), (b * HeapWordSize) \/ (1024 * 1024));\n-#endif\n-\n-\n@@ -1254,5 +844,0 @@\n-\n-#ifdef KELVIN_NEEDS_TO_SEE\n-      log_info(gc)(\"Calculating acceleration to be %.3f MB\/s\/s, with current rate: %.3f MB\/s\",\n-                   (m * HeapWordSize) \/ (1024 * 1024), (proposed_current_rate * HeapWordSize) \/ (1024 * 1024));\n-#endif\n@@ -1268,13 +853,0 @@\n-#ifdef KELVIN_VERBOSE\n-  size_t bytes_to_be_consumed = words_to_be_consumed * HeapWordSize;\n-  log_info(gc)(\"Consuming %zu%s @ rate: %0.3f MB\/s, accel: %0.3f MB\/s\/s @ %0.3f s\",\n-               byte_size_in_proper_unit(bytes_to_be_consumed), proper_unit_for_byte_size(bytes_to_be_consumed),\n-               (current_rate * HeapWordSize) \/ (1024 * 1024),\n-               (acceleration * HeapWordSize) \/ (1024 * 1024), time_delta);\n-  log_info(gc)(\"Allocatable bytes: %zu, available: %zu, min_threshold: %zu\",\n-               _global_allocatable_words * HeapWordSize, _global_available_bytes, _global_min_threshold);\n-#endif\n-#ifdef KELVIN_NEEDS_TO_SEE\n-  log_info(gc)(\"For time %0.6f = %0.6f + %0.6f, bytes to be consumed is: %zu\",\n-               time_delta, get_planned_sleep_interval(), predicted_cycle_time, words_to_be_consumed * HeapWordSize);\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":1,"deletions":429,"binary":false,"changes":430,"status":"modified"},{"patch":"@@ -95,5 +95,0 @@\n-#undef KELVIN_VERBOSE\n-#ifdef KELVIN_VERBOSE\n-public:\n-#endif\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -163,4 +163,0 @@\n-#undef KELVIN_VERBOSE\n-#ifdef KELVIN_VERBOSE\n-  log_info(gc)(\"Made it to do-nothing implementation of start_idle_span()\");\n-#endif\n@@ -180,5 +176,0 @@\n-#undef KELVIN_VERBOSITY\n-#ifdef KELVIN_VERBOSITY\n-    log_info(gc)(\"record_degen_cycle_start(true), _precursor_cycle_start (aka cycle_start): %0.3f\",\n-                 _precursor_cycle_start);\n-#endif\n@@ -188,4 +179,0 @@\n-#ifdef KELVIN_VERBOSITY\n-    log_info(gc)(\"record_degen_cycle_start(false), _precursor_cycle_start: %0.3f, cycle_start: %0.3f\",\n-                 _precursor_cycle_start, _cycle_start);\n-#endif\n@@ -236,6 +223,0 @@\n-\n-#ifdef KELVIN_DEGEN_TRACE\n-  log_info(gc)(\"adjust_penalty(), _most_recent_declined_trigger_count %zu, Penalty_Free_Declinations: %zu, step: %zd\",\n-               _most_recent_declined_trigger_count, Penalty_Free_Declinations, step);\n-#endif\n-\n@@ -288,5 +269,0 @@\n-#undef KELVIN_DEGEN_TRACE\n-#ifdef KELVIN_DEGEN_TRACE\n-  log_info(gc)(\"record_success_degenerated(), adjusts penalty by %zd, new penalty: %zd\",\n-               Degenerated_Penalty, _gc_time_penalties);\n-#endif\n@@ -335,3 +311,0 @@\n-#ifdef KELVIN_VERBOSITY\n-  log_info(gc)(\"degen elapsed cycle time: %0.3f\", now - _precursor_cycle_start);\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":0,"deletions":27,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -1214,5 +1214,0 @@\n-#undef KELVIN_IDLE_SPAN\n-#ifdef KELVIN_IDLE_SPAN\n-  log_info(gc)(\"start_idle_span() at end of concurrent gc\");\n-#endif\n-#undef KELVIN_IDLE_SPAN\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -318,5 +318,0 @@\n-#undef KELVIN_IDLE_SPAN\n-#ifdef KELVIN_IDLE_SPAN\n-    log_info(gc)(\"start_idle_span() at end of degen gc\");\n-#endif\n-#undef KELVIN_IDLE_SPAN\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -255,5 +255,0 @@\n-#undef KELVIN_IDLE_SPAN\n-#ifdef KELVIN_IDLE_SPAN\n-  log_info(gc)(\"start_idle_span() at end of full gc\");\n-#endif\n-#undef KELVIN_IDLE_SPAN\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -173,4 +173,0 @@\n-#undef KELVIN_IDLE\n-#ifdef KELVIN_IDLE\n-  log_info(gc)(\"Doing ShenandoahGenerationalHeap::start_idle_span()\");\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahGenerationalHeap.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -509,4 +509,0 @@\n-#undef KELVIN_DEBUG\n-#ifdef KELVIN_DEBUG\n-  log_info(gc)(\"initialize_controller set _control_thread: \" PTR_FORMAT, p2i(_control_thread));\n-#endif\n@@ -847,4 +843,0 @@\n-#undef KELVIN_IDLE\n-#ifdef KELVIN_IDLE\n-  log_info(gc)(\"Doing ShenandoahHeap::start_idle_span()\");\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -429,4 +429,0 @@\n-#undef KELVIN_VISIBLE\n-#ifdef KELVIN_VISIBLE\n-    log_info(gc)(\"resuming idle span with mutator_free: \" SIZE_FORMAT, mutator_free);\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -138,6 +138,0 @@\n-#undef KELVIN_VERBOSE\n-#ifdef KELVIN_VERBOSE\n-  ShenandoahFreeSet* freeset = ShenandoahHeap::heap()->free_set();\n-  log_info(gc)(\"Young available is MIN(\" SIZE_FORMAT \", \" SIZE_FORMAT \") with capacity: \" SIZE_FORMAT \" and reserve: \" SIZE_FORMAT,\n-               available, freeset->available(), max_capacity(), freeset->reserved());\n-#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahYoungGeneration.cpp","additions":0,"deletions":6,"binary":false,"changes":6,"status":"modified"}]}