{"files":[{"patch":"@@ -139,8 +139,0 @@\n-double ShenandoahAdaptiveHeuristics::get_most_recent_wake_time() const {\n-  return (_is_generational)? _regulator_thread->get_most_recent_wake_time(): _control_thread->get_most_recent_wake_time();\n-}\n-\n-double ShenandoahAdaptiveHeuristics::get_planned_sleep_interval() const {\n-  return (_is_generational)? _regulator_thread->get_planned_sleep_interval(): _control_thread->get_planned_sleep_interval();\n-}\n-\n@@ -186,1 +178,1 @@\n-  size_t mutator_available = _free_set->capacity() - _free_set->used();\n+  size_t mutator_available = _free_set->available_holding_lock();\n@@ -707,7 +699,1 @@\n-\n-  if (ShenandoahHeuristics::should_start_gc()) {\n-    \/\/ ShenandoahHeuristics::should_start_gc() has accepted trigger, or declined it.\n-    return true;\n-  } else {\n-    return false;\n-  }\n+  return ShenandoahHeuristics::should_start_gc();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":2,"deletions":16,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -200,3 +200,0 @@\n-  double get_most_recent_wake_time() const;\n-  double get_planned_sleep_interval() const;\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -49,0 +49,2 @@\n+  _most_recent_trigger_evaluation_time(os::elapsedTime()),\n+  _most_recent_planned_sleep_interval(0.0),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -81,0 +81,4 @@\n+private:\n+  double _most_recent_trigger_evaluation_time;\n+  double _most_recent_planned_sleep_interval;\n+\n@@ -105,0 +109,1 @@\n+\n@@ -195,0 +200,8 @@\n+  inline double get_most_recent_wake_time() const {\n+    return _most_recent_trigger_evaluation_time;\n+  }\n+\n+  inline double get_planned_sleep_interval() const {\n+    return _most_recent_planned_sleep_interval;\n+  }\n+\n@@ -217,0 +230,5 @@\n+  void update_should_start_query_times(double now, double planned_sleep_interval) {\n+    _most_recent_trigger_evaluation_time = now;\n+    _most_recent_planned_sleep_interval = planned_sleep_interval;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahHeuristics.hpp","additions":18,"deletions":0,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -48,1 +48,0 @@\n-  _planned_sleep_interval = ShenandoahControlIntervalMin \/ 1000.0;\n@@ -63,0 +62,1 @@\n+  double most_recent_wake_time = os::elapsedTime();\n@@ -226,1 +226,1 @@\n-    const double before_sleep = _most_recent_wake_time;\n+    const double before_sleep = most_recent_wake_time;\n@@ -236,2 +236,3 @@\n-    _planned_sleep_interval = MIN2<int>(ShenandoahControlIntervalMax, MAX2(1, sleep * 2)) \/ 1000.0;\n-    _most_recent_wake_time = os::elapsedTime();\n+    double planned_sleep_interval = MIN2<int>(ShenandoahControlIntervalMax, MAX2(1, sleep * 2)) \/ 1000.0;\n+    most_recent_wake_time = os::elapsedTime();\n+    heuristics->update_should_start_query_times(most_recent_wake_time, planned_sleep_interval);\n@@ -239,1 +240,1 @@\n-      double elapsed = _most_recent_wake_time - before_sleep;\n+      double elapsed = most_recent_wake_time - before_sleep;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,6 +51,0 @@\n-  \/\/ Remember when Controller most recently woke from its periodic sleep\n-  double _most_recent_wake_time;\n-\n-  \/\/ How long do we plan to sleep before we again sample control status, in seconds.\n-  double _planned_sleep_interval;\n-\n@@ -64,3 +58,1 @@\n-    _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true),\n-    _most_recent_wake_time(os::elapsedTime()),\n-    _planned_sleep_interval(0)\n+    _gc_waiters_lock(Mutex::safepoint-2, \"ShenandoahRequestedGC_lock\", true)\n@@ -86,8 +78,0 @@\n-\n-  double get_most_recent_wake_time() const {\n-    return _most_recent_wake_time;\n-  }\n-\n-  double get_planned_sleep_interval() const {\n-    return _planned_sleep_interval;\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.hpp","additions":1,"deletions":17,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -829,0 +829,2 @@\n+  inline size_t available_holding_lock() const\n+                                  { return _partitions.available_in(ShenandoahFreeSetPartitionId::Mutator); }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,0 +132,1 @@\n+  _young_heuristics->update_should_start_query_times(_most_recent_wake_time, double(_sleep) \/ 1000.0);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -87,15 +87,0 @@\n-\n-public:\n-  inline double get_most_recent_wake_time() const {\n-    return _most_recent_wake_time;\n-  }\n-\n-  \/\/ Return actual duration of last regulator period, which is supposed to equal _sleep, but may be higher in case of scheduling jitter.\n-  inline double get_most_recent_period() const {\n-    return _most_recent_period;\n-  }\n-\n-  \/\/ return planned sleep duration, in s\n-  inline double get_planned_sleep_interval() const {\n-    return ((double) _sleep) \/ 1000.0;\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahRegulatorThread.hpp","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"}]}