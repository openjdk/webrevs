{"files":[{"patch":"@@ -152,3 +152,4 @@\n-  size_t headroom_adjustments = spike_headroom + penalties;\n-  if (mutator_available >= headroom_adjustments) {\n-    mutator_available -= headroom_adjustments;;\n+  _headroom_adjustment = spike_headroom + penalties;\n+  size_t adjusted_mutator_available;\n+  if (mutator_available >= _headroom_adjustment) {\n+    adjusted_mutator_available = mutator_available - _headroom_adjustment;\n@@ -156,1 +157,1 @@\n-    mutator_available = 0;\n+    adjusted_mutator_available = 0;\n@@ -162,1 +163,1 @@\n-  log_info(gc)(\"At start or resumption of idle gc span for %s, mutator available set to: \" PROPERFMT\n+  log_info(gc)(\"At start or resumption of idle gc span for %s, mutator available adjusted to: \" PROPERFMT\n@@ -165,1 +166,1 @@\n-               PROPERFMTARGS(mutator_available), PROPERFMTARGS(spike_headroom), PROPERFMTARGS(penalties));\n+               PROPERFMTARGS(adjusted_mutator_available), PROPERFMTARGS(spike_headroom), PROPERFMTARGS(penalties));\n@@ -167,1 +168,1 @@\n-  _most_recent_headroom_at_start_of_idle = mutator_available;\n+  _most_recent_headroom_at_start_of_idle = adjusted_mutator_available;\n@@ -169,1 +170,14 @@\n-  _trigger_threshold = (bytes_allocated_at_start_of_idle_span + mutator_available) \/ HeapWordSize;\n+  _trigger_threshold = (bytes_allocated_at_start_of_idle_span + adjusted_mutator_available) \/ HeapWordSize;\n+\n+#define KELVIN_DEBUG\n+#ifdef KELVIN_DEBUG\n+  \/\/ _free_set->available() should match mutator_available\n+  log_info(gc)(\"mutator_available: %zu, adjusted_mutator_available: %zu, _free_set->available(): %zu, \"\n+               \"bytes_allocated_at_start: %zu, threshold: %zu\",\n+               mutator_available, adjusted_mutator_available, _free_set->available(), bytes_allocated_at_start_of_idle_span,\n+               _trigger_threshold);\n+  \/\/ Throughout idle span, available() should equal (allocatable() + spike_headroom + penalties)\n+  size_t available = _free_set->available();\n+  log_info(gc)(\" available: %zu should equal allocatable: %zu + spike_headroom: %zu + penalties: %zu\",\n+               available, this->allocatable(available) * HeapWordSize, spike_headroom, penalties);\n+#endif\n@@ -548,3 +562,1 @@\n-\n-\n-#define AppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,      \\\n+#define ForceAppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,      \\\n@@ -587,0 +599,8 @@\n+  \/\/ We do not append trigger info for non-consequential sample periods\n+#define AppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,      \\\n+                          irwps, crba, ca, accel, pfgt, fpgt, attda, is, r, sr, sttda)      \\\n+  if (((absls) > 0) || ((sr) > 0)) {                                                        \\\n+    ForceAppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,     \\\n+                          irwps, crba, ca, accel, pfgt, fpgt, attda, is, r, sr, sttda)      \\\n+  }\n+\n@@ -589,1 +609,1 @@\n-  AppendTriggerInfo(ts, cap, avail, alloced, mt, ls,                                        \\\n+  ForceAppendTriggerInfo(ts, cap, avail, alloced, mt, ls,                                   \\\n@@ -611,1 +631,1 @@\n-  size_t allocatable_words = this->allocatable();\n+  size_t allocatable_words = this->allocatable(available);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":33,"deletions":13,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -186,0 +186,1 @@\n+#ifdef KELVIN_DEPRECATE\n@@ -192,0 +193,6 @@\n+#endif\n+\n+  \/\/ Returns number of words that can be allocated before we need to trigger next GC, given available in bytes.\n+  inline size_t allocatable(size_t available) const {\n+    return (available > _headroom_adjustment)? (available - _headroom_adjustment) \/ HeapWordSize: 0;\n+  }\n@@ -235,0 +242,2 @@\n+  \/\/ bytes of headroom at which we should trigger GC\n+  size_t _headroom_adjustment;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"}]}