{"files":[{"patch":"@@ -416,0 +416,92 @@\n+#define KELVIN_START_GC\n+#ifdef KELVIN_START_GC\n+const size_t MaxRejectedTriggers = 256;\n+typedef struct gc_start_info {\n+  double time_stamp;\n+  size_t capacity;\n+  size_t available;\n+  size_t allocated;\n+  size_t min_threshold;\n+  size_t learned_steps;\n+  double avg_alloc_rate;\n+  size_t allocatable_words;\n+  double avg_cycle_time;\n+  double predicted_future_accelerated_gc_time;\n+  size_t allocated_bytes_since_last_sample;\n+  double instantaneous_rate_words_per_second;\n+  double current_rate_by_acceleration;;\n+  size_t consumption_accelerated;\n+  double acceleration;\n+  double predicted_future_gc_time;\n+  double future_planned_gc_time;\n+  double avg_time_to_deplete_available;\n+  bool is_spiking;\n+  double spike_rate;\n+  double spike_time_to_deplete_available;\n+} TriggerInfo;\n+\n+\/\/ Most recently logged data represents the accepted trigger\n+static void dumpTriggerInfo(size_t first_trigger, size_t rejected_triggers, TriggerInfo* trigger_log) {\n+  static const char* const header[] = {\n+    \"\\n\",\n+    \"TimeStamp, Capacity (Bytes), Available (Bytes), Allocated (Bytes), \"\n+    \"Min Threshold (Bytes), Learned Steps, Average Allocation Rate (MB\/s), \"\n+    \"Allocatable (Words), Average Cycle Time (seconds), \"\n+    \"Predicted Accelerated GC Time (seconds), \"\n+    \"Allocated Since Last Sample (bytes), \"\n+    \"Instantaneous Allocation Rate (MB\/s), \"\n+    \"Current Allocation Rate by Acceleration (MB\/s), \"\n+    \"Accelerated Consumption (bytes), \"\n+    \"Acceleration (MB\/s\/s), Predicted Future GC Time (seconds), \"\n+    \"Future Planned GC Time (seconds), \"\n+    \"Average Time to Deplete Available (seconds), \"\n+    \"Is Spiking, Spike Rate (MB\/s), \"\n+    \"Spike Time to Deplete Available (s)\",\n+    \"                                                Min         Learned      Allocatable        Predicted                     Current                              Planned                   Spike\",\n+    \"TimeStamp Capacity     Available    Allocated   Threshold   Steps        (bytes)            Accelerated                   Rate by                              GC     Avg                Time\",\n+    \"|         (Bytes)      (Bytes)      (Bytes)     (Bytes)     |  Avg       |           Avg    GC     Allocated              Accel      Accelerated               Time   Time               to\",\n+    \"|         |            |            |           |           |  Alloc     |           Cycle  Time   Since                  (MB\/s)     Consumption               (s)    to                 Deplete\",\n+    \"|         |            |            |           |           |  Rate      |           Time   (s)    Last                   |          (bytes)                   |      Deplete            Available\",\n+    \"|         |            |            |           |           |  (MB\/s)    |           (s)    |      Sample                 |          |           Accel         |      Avail   Is         (s)\",\n+    \"|         |            |            |           |           |  |         |           |      |      (bytes)                |          |           MB\/s^2)       |      (s)     Spiking    |\",\n+    \"|         |            |            |           |           |  |         |           |      |      |           Spike      |          |           |      Future |      |       |   Spike  |\",\n+    \"|         |            |            |           |           |  |         |           |      |      |           Alloc      |          |           |      GC     |      |       |   Rate   |\",\n+    \"|         |            |            |           |           |  |         |           |      |      |           Rate       |          |           |      Time   |      |       |   (MB\/s) |\",\n+    \"|         |            |            |           |           |  |         |           |      |      |           (MB\/s)     |          |           |      (s)    |      |       |   |      |\",\n+    \"|         |            |            |           |           |  |         |           |      |      |           |          |          |           |      |      |      |       |   |      |\",\n+    \"v         v            v            v           v           v  v         v           v      v      v           v          v          v           v      v      v      v       v   v      v\"\n+  };\n+  for (unsigned int i = 0; i < sizeof(header) \/ sizeof(void*); i++) {\n+    log_info(gc)(\"%s\", header[i]);\n+  }\n+  for (unsigned int i = 0; i < rejected_triggers; i++) {\n+    size_t __index = (first_trigger + i) % MaxRejectedTriggers;\n+    log_info(gc)(\"%.6f, %zu, %zu, %zu, %zu, %zu, \"\n+                 \"%.3f, %zu, %.3f, %.3f, %zu, %.3f, %.3f, %zu, %.3f, %.3f, %.3f, %.3f, \"\n+                 \"%s, %.3f, %.3f\",\n+                 trigger_log[__index].time_stamp,\n+                 trigger_log[__index].capacity,\n+                 trigger_log[__index].available,\n+                 trigger_log[__index].allocated,\n+                 trigger_log[__index].min_threshold,\n+                 trigger_log[__index].learned_steps,\n+                 trigger_log[__index].avg_alloc_rate \/ (1024*1024),\n+                 trigger_log[__index].allocatable_words * HeapWordSize,\n+                 trigger_log[__index].avg_cycle_time,\n+                 trigger_log[__index].predicted_future_accelerated_gc_time,\n+                 trigger_log[__index].allocated_bytes_since_last_sample,\n+                 (trigger_log[__index].instantaneous_rate_words_per_second * HeapWordSize) \/ (1024*1024),\n+                 (trigger_log[__index].current_rate_by_acceleration * HeapWordSize) \/ (1024*1024),\n+                 trigger_log[__index].consumption_accelerated * HeapWordSize,\n+                 (trigger_log[__index].acceleration * HeapWordSize) \/ (1024*1024),\n+                 trigger_log[__index].predicted_future_gc_time,\n+                 trigger_log[__index].future_planned_gc_time,\n+                 trigger_log[__index].avg_time_to_deplete_available,\n+                 trigger_log[__index].is_spiking? \"yes\": \"no\",\n+                 trigger_log[__index].spike_rate \/ (1024*1024),\n+                 trigger_log[__index].spike_time_to_deplete_available);\n+  }\n+}\n+#endif\n+\n+\n@@ -445,0 +537,61 @@\n+\n+#ifdef KELVIN_START_GC\n+  static TriggerInfo rejected_trigger_log[MaxRejectedTriggers];\n+  static size_t rejected_trigger_count = 0;\n+  static size_t first_rejected_trigger = 0;\n+\n+#define AppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,      \\\n+                          irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda)         \\\n+  if (rejected_trigger_count >= MaxRejectedTriggers) {                                      \\\n+    first_rejected_trigger++;                                                               \\\n+    if (first_rejected_trigger >= MaxRejectedTriggers)  {                                   \\\n+      first_rejected_trigger = 0;                                                           \\\n+    }                                                                                       \\\n+  } else {                                                                                  \\\n+    rejected_trigger_count++;                                                               \\\n+  }                                                                                         \\\n+  log_info(gc)(\"AppendTrigger(first_rejected: %zu, rejected_count: %zu) @%.6f\",             \\\n+               first_rejected_trigger, rejected_trigger_count, ts);                         \\\n+  {                                                                                         \\\n+    size_t __j;                                                                             \\\n+    __j = (first_rejected_trigger + rejected_trigger_count - 1) % MaxRejectedTriggers;      \\\n+    rejected_trigger_log[__j].time_stamp = ts;                                              \\\n+    rejected_trigger_log[__j].capacity = cap;                                               \\\n+    rejected_trigger_log[__j].available = avail;                                            \\\n+    rejected_trigger_log[__j].allocated = alloced;                                          \\\n+    rejected_trigger_log[__j].min_threshold = mt;                                           \\\n+    rejected_trigger_log[__j].learned_steps = ls;                                           \\\n+    rejected_trigger_log[__j].avg_alloc_rate = aar;                                         \\\n+    rejected_trigger_log[__j].allocatable_words = aw;                                       \\\n+    rejected_trigger_log[__j].avg_cycle_time = act;                                         \\\n+    rejected_trigger_log[__j].predicted_future_accelerated_gc_time = pfagt;                 \\\n+    rejected_trigger_log[__j].allocated_bytes_since_last_sample = absls;                    \\\n+    rejected_trigger_log[__j].instantaneous_rate_words_per_second = irwps;                  \\\n+    rejected_trigger_log[__j].current_rate_by_acceleration = crba;                          \\\n+    rejected_trigger_log[__j].consumption_accelerated = ca;                                 \\\n+    rejected_trigger_log[__j].acceleration = accel;                                         \\\n+    rejected_trigger_log[__j].predicted_future_gc_time = pfgt;                              \\\n+    rejected_trigger_log[__j].future_planned_gc_time = fpgt;                                \\\n+    rejected_trigger_log[__j].avg_time_to_deplete_available = attda;                        \\\n+    rejected_trigger_log[__j].is_spiking = is;                                              \\\n+    rejected_trigger_log[__j].spike_rate = sr;                                              \\\n+    rejected_trigger_log[__j].spike_time_to_deplete_available = sttda;                      \\\n+  }\n+\n+#define DumpTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,        \\\n+                        irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda)           \\\n+  AppendTriggerInfo(ts, cap, avail, alloced, mt, ls,                                        \\\n+                    aar, aw, act, pfagt, absls, irwps, crba, ca, accel,                     \\\n+                    pfgt, fpgt, attda, is, sr, sttda);                                      \\\n+  dumpTriggerInfo(first_rejected_trigger, rejected_trigger_count, rejected_trigger_log);    \\\n+  rejected_trigger_count = 0;                                                               \\\n+  first_rejected_trigger = 0;\n+\n+#else\n+#define AppendTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,      \\\n+                          irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda) ;\n+\n+#define DumpTriggerInfo(ts, cap, avail, alloced, mt, ls, aar, aw, act, pfagt, absls,        \\\n+                        irwps, crba, ca, accel, pfgt, fpgt, attda, is, sr, sttda) ;\n+#endif\n+\n@@ -460,0 +613,5 @@\n+\n+#ifdef KELVIN_START_GC\n+  size_t learned_steps = _gc_times_learned;\n+#endif\n+\n@@ -477,0 +635,6 @@\n+    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                    acceleration, predicted_future_gc_time,\n+                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                    spike_time_to_deplete_available);\n@@ -490,0 +654,6 @@\n+    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                    acceleration, predicted_future_gc_time,\n+                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                    spike_time_to_deplete_available);\n@@ -503,0 +673,6 @@\n+      DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                      avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                      instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                      acceleration, predicted_future_gc_time,\n+                      future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                      spike_time_to_deplete_available);\n@@ -510,52 +686,0 @@\n-  \/\/ Suppose we don't trigger now, but decide to trigger in the next regulator cycle.  What will be the GC time then?\n-  predicted_future_gc_time = predict_gc_time(now + get_planned_sleep_interval());\n-  if (predicted_future_gc_time > avg_cycle_time) {\n-    future_planned_gc_time = predicted_future_gc_time;\n-    future_planned_gc_time_is_average = false;\n-  } else {\n-    future_planned_gc_time = avg_cycle_time;\n-    future_planned_gc_time_is_average = true;\n-  }\n-\n-  log_debug(gc)(\"%s: average GC time: %.2f ms, predicted GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n-                _space_info->name(), avg_cycle_time * 1000, predicted_future_gc_time * 1000,\n-                byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n-  size_t allocatable_bytes = allocatable_words * HeapWordSize;\n-  avg_time_to_deplete_available = allocatable_bytes \/ avg_alloc_rate;\n-\n-  \/\/ First check for traditional triggers.  If these fail, check for accelerated triggers.\n-  if (future_planned_gc_time > avg_time_to_deplete_available) {\n-    log_trigger(\"%s GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n-                \" to deplete free headroom (%zu%s) (margin of error = %.2f)\",\n-                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n-                byte_size_in_proper_unit(avg_alloc_rate),    proper_unit_for_byte_size(avg_alloc_rate),\n-                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n-                _margin_of_error_sd);\n-\n-    size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n-    size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n-    size_t allocation_headroom = available;\n-    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n-    allocation_headroom -= MIN2(allocation_headroom, penalties);\n-    log_info(gc, ergo)(\"Free headroom: %zu%s (free) - %zu%s (spike) - %zu%s (penalties) = %zu%s\",\n-                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n-                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n-                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n-                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n-    accept_trigger_with_type(RATE);\n-    return true;\n-  }\n-\n-  is_spiking = _allocation_rate.is_spiking(spike_rate, _spike_threshold_sd);\n-  spike_time_to_deplete_available = (spike_rate == 0)? future_planned_gc_time: allocatable_bytes \/ spike_rate;\n-  if (is_spiking && future_planned_gc_time > spike_time_to_deplete_available) {\n-    log_trigger(\"%s GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s)\"\n-                \" to deplete free headroom (%zu%s) (spike threshold = %.2f)\",\n-                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n-                byte_size_in_proper_unit(spike_rate),        proper_unit_for_byte_size(spike_rate),\n-                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n-                _spike_threshold_sd);\n-    accept_trigger_with_type(SPIKE);\n-    return true;\n-  }\n-\n@@ -697,0 +821,6 @@\n+      DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                      avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                      instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                      acceleration, predicted_future_gc_time,\n+                      future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                      spike_time_to_deplete_available);\n@@ -701,0 +831,83 @@\n+  \/\/ Suppose we don't trigger now, but decide to trigger in the next regulator cycle.  What will be the GC time then?\n+  predicted_future_gc_time = predict_gc_time(now + get_planned_sleep_interval());\n+  if (predicted_future_gc_time > avg_cycle_time) {\n+    future_planned_gc_time = predicted_future_gc_time;\n+    future_planned_gc_time_is_average = false;\n+  } else {\n+    future_planned_gc_time = avg_cycle_time;\n+    future_planned_gc_time_is_average = true;\n+  }\n+\n+  log_debug(gc)(\"%s: average GC time: %.2f ms, predicted GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n+                _space_info->name(), avg_cycle_time * 1000, predicted_future_gc_time * 1000,\n+                byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n+  size_t allocatable_bytes = allocatable_words * HeapWordSize;\n+  avg_time_to_deplete_available = allocatable_bytes \/ avg_alloc_rate;\n+\n+  if (future_planned_gc_time > avg_time_to_deplete_available) {\n+    log_trigger(\"%s GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n+                \" to deplete free headroom (%zu%s) (margin of error = %.2f)\",\n+                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n+                byte_size_in_proper_unit(avg_alloc_rate),    proper_unit_for_byte_size(avg_alloc_rate),\n+                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n+                _margin_of_error_sd);\n+\n+    size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n+    size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+    size_t allocation_headroom = available;\n+    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n+    allocation_headroom -= MIN2(allocation_headroom, penalties);\n+    log_info(gc, ergo)(\"Free headroom: %zu%s (free) - %zu%s (spike) - %zu%s (penalties) = %zu%s\",\n+                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n+                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n+                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n+                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n+    accept_trigger_with_type(RATE);\n+    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                    acceleration, predicted_future_gc_time,\n+                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                    spike_time_to_deplete_available);\n+    return true;\n+  }\n+\n+  is_spiking = _allocation_rate.is_spiking(spike_rate, _spike_threshold_sd);\n+  spike_time_to_deplete_available = (spike_rate == 0)? future_planned_gc_time: allocatable_bytes \/ spike_rate;\n+  if (is_spiking && future_planned_gc_time > spike_time_to_deplete_available) {\n+    log_trigger(\"%s GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s)\"\n+                \" to deplete free headroom (%zu%s) (spike threshold = %.2f)\",\n+                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n+                byte_size_in_proper_unit(spike_rate),        proper_unit_for_byte_size(spike_rate),\n+                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n+                _spike_threshold_sd);\n+    accept_trigger_with_type(SPIKE);\n+    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                    acceleration, predicted_future_gc_time,\n+                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                    spike_time_to_deplete_available);\n+    return true;\n+  }\n+\n+#ifdef KELVIN_START_GC\n+  if (ShenandoahHeuristics::should_start_gc()) {\n+    \/\/ ShenandoahHeuristics::should_start_gc() has accepted trigger, or declined it.\n+    DumpTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                    avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                    instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                    acceleration, predicted_future_gc_time,\n+                    future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                    spike_time_to_deplete_available);\n+    return true;\n+  } else {\n+    AppendTriggerInfo(now, capacity, available, allocated, min_threshold, learned_steps, avg_alloc_rate, allocatable_words,\n+                      avg_cycle_time, predicted_future_accelerated_gc_time, allocated_bytes_since_last_sample,\n+                      instantaneous_rate_words_per_second, current_rate_by_acceleration, consumption_accelerated,\n+                      acceleration, predicted_future_gc_time,\n+                      future_planned_gc_time, avg_time_to_deplete_available, is_spiking, spike_rate,\n+                      spike_time_to_deplete_available);\n+    return false;\n+  }\n+#else\n@@ -702,0 +915,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":266,"deletions":52,"binary":false,"changes":318,"status":"modified"},{"patch":"@@ -196,2 +196,2 @@\n-  \/\/ Invocations of should_start_gc() happen approximately once per ms.  Approximately every third invocation  of should_start_gc()\n-  \/\/ queries the allocation rate.\n+  \/\/ Invocations of should_start_gc() happen approximately once per ms.  Queries of allocation rate only happen if a\n+  \/\/ a certain amount of time has passed since the previous query.\n@@ -199,1 +199,0 @@\n-\n@@ -202,1 +201,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"}]}