{"files":[{"patch":"@@ -510,0 +510,52 @@\n+  \/\/ Suppose we don't trigger now, but decide to trigger in the next regulator cycle.  What will be the GC time then?\n+  predicted_future_gc_time = predict_gc_time(now + get_planned_sleep_interval());\n+  if (predicted_future_gc_time > avg_cycle_time) {\n+    future_planned_gc_time = predicted_future_gc_time;\n+    future_planned_gc_time_is_average = false;\n+  } else {\n+    future_planned_gc_time = avg_cycle_time;\n+    future_planned_gc_time_is_average = true;\n+  }\n+\n+  log_debug(gc)(\"%s: average GC time: %.2f ms, predicted GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n+                _space_info->name(), avg_cycle_time * 1000, predicted_future_gc_time * 1000,\n+                byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n+  size_t allocatable_bytes = allocatable_words * HeapWordSize;\n+  avg_time_to_deplete_available = allocatable_bytes \/ avg_alloc_rate;\n+\n+  \/\/ First check for traditional triggers.  If these fail, check for accelerated triggers.\n+  if (future_planned_gc_time > avg_time_to_deplete_available) {\n+    log_trigger(\"%s GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n+                \" to deplete free headroom (%zu%s) (margin of error = %.2f)\",\n+                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n+                byte_size_in_proper_unit(avg_alloc_rate),    proper_unit_for_byte_size(avg_alloc_rate),\n+                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n+                _margin_of_error_sd);\n+\n+    size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n+    size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n+    size_t allocation_headroom = available;\n+    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n+    allocation_headroom -= MIN2(allocation_headroom, penalties);\n+    log_info(gc, ergo)(\"Free headroom: %zu%s (free) - %zu%s (spike) - %zu%s (penalties) = %zu%s\",\n+                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n+                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n+                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n+                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n+    accept_trigger_with_type(RATE);\n+    return true;\n+  }\n+\n+  is_spiking = _allocation_rate.is_spiking(spike_rate, _spike_threshold_sd);\n+  spike_time_to_deplete_available = (spike_rate == 0)? future_planned_gc_time: allocatable_bytes \/ spike_rate;\n+  if (is_spiking && future_planned_gc_time > spike_time_to_deplete_available) {\n+    log_trigger(\"%s GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s)\"\n+                \" to deplete free headroom (%zu%s) (spike threshold = %.2f)\",\n+                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n+                byte_size_in_proper_unit(spike_rate),        proper_unit_for_byte_size(spike_rate),\n+                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n+                _spike_threshold_sd);\n+    accept_trigger_with_type(SPIKE);\n+    return true;\n+  }\n+\n@@ -649,50 +701,0 @@\n-  \/\/ Suppose we don't trigger now, but decide to trigger in the next regulator cycle.  What will be the GC time then?\n-  predicted_future_gc_time = predict_gc_time(now + get_planned_sleep_interval());\n-  if (predicted_future_gc_time > avg_cycle_time) {\n-    future_planned_gc_time = predicted_future_gc_time;\n-    future_planned_gc_time_is_average = false;\n-  } else {\n-    future_planned_gc_time = avg_cycle_time;\n-    future_planned_gc_time_is_average = true;\n-  }\n-\n-  log_debug(gc)(\"%s: average GC time: %.2f ms, predicted GC time: %.2f ms, allocation rate: %.0f %s\/s\",\n-                _space_info->name(), avg_cycle_time * 1000, predicted_future_gc_time * 1000,\n-                byte_size_in_proper_unit(avg_alloc_rate), proper_unit_for_byte_size(avg_alloc_rate));\n-  size_t allocatable_bytes = allocatable_words * HeapWordSize;\n-  avg_time_to_deplete_available = allocatable_bytes \/ avg_alloc_rate;\n-\n-  if (future_planned_gc_time > avg_time_to_deplete_available) {\n-    log_trigger(\"%s GC time (%.2f ms) is above the time for average allocation rate (%.0f %sB\/s)\"\n-                \" to deplete free headroom (%zu%s) (margin of error = %.2f)\",\n-                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n-                byte_size_in_proper_unit(avg_alloc_rate),    proper_unit_for_byte_size(avg_alloc_rate),\n-                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n-                _margin_of_error_sd);\n-\n-    size_t spike_headroom = capacity \/ 100 * ShenandoahAllocSpikeFactor;\n-    size_t penalties      = capacity \/ 100 * _gc_time_penalties;\n-    size_t allocation_headroom = available;\n-    allocation_headroom -= MIN2(allocation_headroom, spike_headroom);\n-    allocation_headroom -= MIN2(allocation_headroom, penalties);\n-    log_info(gc, ergo)(\"Free headroom: %zu%s (free) - %zu%s (spike) - %zu%s (penalties) = %zu%s\",\n-                       byte_size_in_proper_unit(available),           proper_unit_for_byte_size(available),\n-                       byte_size_in_proper_unit(spike_headroom),      proper_unit_for_byte_size(spike_headroom),\n-                       byte_size_in_proper_unit(penalties),           proper_unit_for_byte_size(penalties),\n-                       byte_size_in_proper_unit(allocation_headroom), proper_unit_for_byte_size(allocation_headroom));\n-    accept_trigger_with_type(RATE);\n-    return true;\n-  }\n-\n-  is_spiking = _allocation_rate.is_spiking(spike_rate, _spike_threshold_sd);\n-  spike_time_to_deplete_available = (spike_rate == 0)? future_planned_gc_time: allocatable_bytes \/ spike_rate;\n-  if (is_spiking && future_planned_gc_time > spike_time_to_deplete_available) {\n-    log_trigger(\"%s GC time (%.2f ms) is above the time for instantaneous allocation rate (%.0f %sB\/s)\"\n-                \" to deplete free headroom (%zu%s) (spike threshold = %.2f)\",\n-                future_planned_gc_time_is_average? \"Average\": \"Linear prediction of\", future_planned_gc_time * 1000,\n-                byte_size_in_proper_unit(spike_rate),        proper_unit_for_byte_size(spike_rate),\n-                byte_size_in_proper_unit(allocatable_bytes), proper_unit_for_byte_size(allocatable_bytes),\n-                _spike_threshold_sd);\n-    accept_trigger_with_type(SPIKE);\n-    return true;\n-  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/heuristics\/shenandoahAdaptiveHeuristics.cpp","additions":52,"deletions":50,"binary":false,"changes":102,"status":"modified"}]}