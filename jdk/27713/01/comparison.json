{"files":[{"patch":"@@ -28,1 +28,0 @@\n-#include \"runtime\/javaThread.hpp\"\n@@ -30,1 +29,0 @@\n-#include \"runtime\/orderAccess.hpp\"\n@@ -44,43 +42,0 @@\n-\/\/ Base loop to estimate ticks frequency for tsc counter from user mode.\n-\/\/ Volatiles and sleep() are used to prevent compiler from applying optimizations.\n-void Rdtsc::do_time_measurements(volatile jlong& time_base,\n-                                 volatile jlong& time_fast,\n-                                 volatile jlong& time_base_elapsed,\n-                                 volatile jlong& time_fast_elapsed) {\n-  static const unsigned int FT_SLEEP_MILLISECS = 1;\n-  const unsigned int loopcount = 3;\n-\n-  volatile jlong start = 0;\n-  volatile jlong fstart = 0;\n-  volatile jlong end = 0;\n-  volatile jlong fend = 0;\n-\n-  \/\/ Figure out the difference between rdtsc and os provided timer.\n-  \/\/ base algorithm adopted from JRockit.\n-  for (unsigned int times = 0; times < loopcount; times++) {\n-    start = os::elapsed_counter();\n-    OrderAccess::fence();\n-    fstart = os::rdtsc();\n-\n-    \/\/ use sleep to prevent compiler from optimizing\n-    JavaThread::current()->sleep(FT_SLEEP_MILLISECS);\n-\n-    end = os::elapsed_counter();\n-    OrderAccess::fence();\n-    fend = os::rdtsc();\n-\n-    time_base += end - start;\n-    time_fast += fend - fstart;\n-\n-    \/\/ basis for calculating the os tick start\n-    \/\/ to fast time tick start offset\n-    time_base_elapsed += end;\n-    time_fast_elapsed += (fend - _epoch);\n-  }\n-\n-  time_base \/= loopcount;\n-  time_fast \/= loopcount;\n-  time_base_elapsed \/= loopcount;\n-  time_fast_elapsed \/= loopcount;\n-}\n-\n@@ -107,23 +62,0 @@\n-  } else {\n-    \/\/ use measurements to estimate\n-    \/\/ a conversion factor and the tsc frequency\n-\n-    volatile jlong time_base = 0;\n-    volatile jlong time_fast = 0;\n-    volatile jlong time_base_elapsed = 0;\n-    volatile jlong time_fast_elapsed = 0;\n-\n-    \/\/ do measurements to get base data\n-    \/\/ on os timer and fast ticks tsc time relation.\n-    do_time_measurements(time_base, time_fast, time_base_elapsed, time_fast_elapsed);\n-\n-    \/\/ if invalid measurements, cannot proceed\n-    if (time_fast == 0 || time_base == 0) {\n-      return 0;\n-    }\n-\n-    os_to_tsc_conv_factor = (double)time_fast \/ (double)time_base;\n-    if (os_to_tsc_conv_factor > 1) {\n-      \/\/ estimate on tsc counter frequency\n-      tsc_freq = os_to_tsc_conv_factor * os_freq;\n-    }\n@@ -147,18 +79,10 @@\n-  const bool invtsc_support = Rdtsc::is_supported();\n-  if (FLAG_IS_DEFAULT(UseFastUnorderedTimeStamps) && invtsc_support) {\n-    FLAG_SET_ERGO(UseFastUnorderedTimeStamps, true);\n-  }\n-\n-  bool ft_enabled = UseFastUnorderedTimeStamps && invtsc_support;\n-\n-  if (!ft_enabled) {\n-    if (UseFastUnorderedTimeStamps && VM_Version::supports_tsc()) {\n-      warning(\"\\nThe hardware does not support invariant tsc (INVTSC) register and\/or cannot guarantee tsc synchronization between sockets at startup.\\n\"\\\n-        \"Values returned via rdtsc() are not guaranteed to be accurate, esp. when comparing values from cross sockets reads. Enabling UseFastUnorderedTimeStamps on non-invariant tsc hardware should be considered experimental.\\n\");\n-      ft_enabled = true;\n-    }\n-  }\n-\n-  if (!ft_enabled) {\n-    \/\/ Warn if unable to support command-line flag\n-    if (UseFastUnorderedTimeStamps && !VM_Version::supports_tsc()) {\n+  if (Rdtsc::is_supported()) {\n+    \/\/ Use rdtsc when it is supported by default\n+    FLAG_SET_ERGO_IF_DEFAULT(UseFastUnorderedTimeStamps, true);\n+  } else if (UseFastUnorderedTimeStamps) {\n+    assert(!FLAG_IS_DEFAULT(UseFastUnorderedTimeStamps), \"Unexpected default value\");\n+\n+    if (VM_Version::supports_tsc()) {\n+      warning(\"Ignoring UseFastUnorderedTimeStamps, the hardware does not support invariant tsc (INVTSC) register and\/or cannot guarantee tsc synchronization between sockets at startup.\\n\"\n+              \"Values returned via rdtsc() are not guaranteed to be accurate, esp. when comparing values from cross sockets reads.\");\n+    } else {\n@@ -167,0 +91,3 @@\n+\n+    \/\/ We do not support non invariant rdtsc\n+    FLAG_SET_ERGO(UseFastUnorderedTimeStamps, false);\n@@ -169,1 +96,1 @@\n-  return ft_enabled;\n+  return UseFastUnorderedTimeStamps;\n@@ -176,3 +103,4 @@\n-  bool result = initialize_elapsed_counter(); \/\/ init hw\n-  if (result) {\n-    result = ergonomics(); \/\/ check logical state\n+\n+  if (!ergonomics()) {\n+    \/\/ We decided to ergonomically not support rdtsc.\n+    return false;\n@@ -180,1 +108,3 @@\n-  return result;\n+\n+  \/\/ Try to initialize the elapsed counter\n+  return initialize_elapsed_counter();\n","filename":"src\/hotspot\/cpu\/x86\/rdtsc_x86.cpp","additions":21,"deletions":91,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -48,5 +48,0 @@\n-  static void do_time_measurements(volatile jlong& time_base,\n-                                   volatile jlong& time_fast,\n-                                   volatile jlong& time_base_elapsed,\n-                                   volatile jlong& time_fast_elapsed);\n-\n","filename":"src\/hotspot\/cpu\/x86\/rdtsc_x86.hpp","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"}]}