{"files":[{"patch":"@@ -405,1 +405,2 @@\n-  E at_grow(int i, const E& fill = E()) {\n+  template<typename Constructor>\n+  E& at_grow_with(int i, Constructor ctr) {\n@@ -409,3 +410,5 @@\n-      for (int j = this->_len; j <= i; j++)\n-        this->_data[j] = fill;\n-      this->_len = i+1;\n+      for (int j = this->_len; j <= i; j++) {\n+        this->_data[j].~E();\n+        ctr(&this->_data[j]);\n+      }\n+      this->_len = i + 1;\n@@ -416,1 +419,9 @@\n-  void at_put_grow(int i, const E& elem, const E& fill = E()) {\n+  template<typename... Args >\n+  E& at_grow(int i, const Args&... args) {\n+    return at_grow_with(i, [&](E* ptr) {\n+      ::new (ptr) E(args...);\n+    });\n+  }\n+\n+  template<typename Constructor>\n+  void at_put_grow_with(int i, Constructor ctr, const E& elem) {\n@@ -420,2 +431,4 @@\n-      for (int j = this->_len; j < i; j++)\n-        this->_data[j] = fill;\n+      for (int j = this->_len; j < i; j++) {\n+        this->_data[j].~E();\n+        ctr(&this->_data[j]);\n+      }\n@@ -424,1 +437,8 @@\n-    this->_data[i] = elem;\n+    ::new (&this->_data[i]) E(elem);\n+  }\n+\n+  template<typename... Args>\n+  void at_put_grow(int i, const E& elem, const Args&... args) {\n+    at_put_grow_with(i, [&](E* ptr) {\n+        ::new (ptr) E(args...);\n+    }, elem);\n","filename":"src\/hotspot\/share\/utilities\/growableArray.hpp","additions":28,"deletions":8,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -562,0 +562,64 @@\n+struct Elt {\n+  static int copy_calls;\n+  const char* str; int x;\n+\n+  Elt(const Elt& e)\n+    : str(e.str), x(e.x) {\n+    copy_calls++;\n+  }\n+  Elt(Elt&&) = default;\n+  Elt& operator=(const Elt&) = default;\n+  Elt& operator=(Elt&&) = default;\n+  Elt() {\n+  }\n+  Elt(const char* str, int x)\n+    : str(str),\n+      x(x) {\n+  }\n+};\n+int Elt::copy_calls = 0;\n+\n+TEST_VM_F(GrowableArrayTest, AtPutGrowOnlyCopiesLastElement) {\n+  ResourceMark rm;\n+  Elt::copy_calls = 0;\n+  GrowableArray<Elt> arr;\n+  arr.at_put_grow(16, Elt{\"final_elt\", 16}, \"earlier_elt\", 1);\n+  for (int i = 0; i < 16; i++) {\n+    ASSERT_STREQ(arr.at(i).str, \"earlier_elt\");\n+    ASSERT_EQ(arr.at(i).x, 1);\n+  }\n+  ASSERT_STREQ(arr.at(16).str, \"final_elt\");\n+  ASSERT_EQ(arr.at(16).x, 16);\n+  \/\/ Last element is copied\n+  ASSERT_EQ(Elt::copy_calls, 1);\n+}\n+\n+TEST_VM_F(GrowableArrayTest, ShouldBeAbleToGrowByCopying) {\n+  ResourceMark rm;\n+  Elt::copy_calls = 0;\n+  GrowableArray<Elt> arr{0};\n+  arr.at_put_grow(16, Elt{\"final_elt\", 16}, Elt{\"\",0});\n+  ASSERT_GE(Elt::copy_calls, 16);\n+}\n+\n+TEST_VM_F(GrowableArrayTest, CanGrowWithoutCopying) {\n+  ResourceMark rm;\n+  Elt::copy_calls = 0;\n+  GrowableArray<Elt> arr{0};\n+  arr.at_grow(15, \"hello\", 5);\n+  ASSERT_EQ(Elt::copy_calls, 0);\n+}\n+\n+TEST_VM_F(GrowableArrayTest, CanGrowUsingACapturingLambda) {\n+  ResourceMark rm;\n+  GrowableArray<int> arr{0};\n+  int i = 0;\n+  arr.at_grow_with(15, [&](int* ptr) {\n+    ::new (ptr) int(i);\n+    i++;\n+  });\n+  for (int j = 0; j < i; j++) {\n+    ASSERT_EQ(j, arr.at(j));\n+  }\n+}\n+\n","filename":"test\/hotspot\/gtest\/utilities\/test_growableArray.cpp","additions":64,"deletions":0,"binary":false,"changes":64,"status":"modified"}]}