{"files":[{"patch":"@@ -33,1 +33,0 @@\n-import jdk.internal.foreign.HeapMemorySegmentImpl;\n@@ -41,1 +40,0 @@\n-import java.io.FileDescriptor;\n@@ -45,1 +43,0 @@\n-import java.util.Objects;\n@@ -853,0 +850,1 @@\n+                @ForceInline\n@@ -928,0 +926,1 @@\n+                @ForceInline\n@@ -933,0 +932,1 @@\n+                @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -545,1 +545,2 @@\n-        return SegmentFactories.arrayOf$Type$Segment(base, offset, length, readOnly, bufferScope);\n+        \/\/ Direct buffers are not backed by an array.\n+        throw new UnsupportedOperationException();\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2329,21 +2329,1 @@\n-#if[byte]\n-        return 0;\n-#end[byte]\n-#if[short]\n-        return 1;\n-#end[short]\n-#if[char]\n-        return 1;\n-#end[char]\n-#if[int]\n-        return 2;\n-#end[int]\n-#if[float]\n-        return 2;\n-#end[float]\n-#if[long]\n-        return 3;\n-#end[long]\n-#if[double]\n-        return 3;\n-#end[double]\n+        return $Fulltype$.BYTES;\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -517,0 +517,1 @@\n+        \/\/ Implicit null check via NIO_ACCESS.scaleFactor(b)\n@@ -525,1 +526,1 @@\n-                ? arrayFreeSegment(b, offset, length)\n+                ? arrayLessSegment(b, offset, length)\n@@ -541,1 +542,1 @@\n-    private static AbstractMemorySegmentImpl arrayFreeSegment(Buffer b, long offset, long length) {\n+    private static AbstractMemorySegmentImpl arrayLessSegment(Buffer b, long offset, long length) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n-public abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n+abstract sealed class HeapMemorySegmentImpl extends AbstractMemorySegmentImpl {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/HeapMemorySegmentImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class SegmentOfBuffer {\n+\n+    private final ByteBuffer buffer = ByteBuffer\n+            .allocateDirect(0x1000)\n+            .order(ByteOrder.nativeOrder());\n+\n+    @Benchmark\n+    @Fork(value = 3)\n+    public long ofBuffer() {\n+        return MemorySegment.ofBuffer(buffer).address();\n+    }\n+\n+    @Benchmark\n+    @Fork(value = 3, jvmArgsAppend = \"-XX:CompileCommand=inline,jdk.internal.foreign.AbstractMemorySegmentImpl::ofBuffer,false\")\n+    public long ofBufferInlineFalse() {\n+        return MemorySegment.ofBuffer(buffer).address();\n+    }\n+\n+    @Benchmark\n+    @Fork(value = 3, jvmArgsAppend = \"-XX:CompileCommand=inline,jdk.internal.foreign.AbstractMemorySegmentImpl::ofBuffer,true\")\n+    public long ofBufferInlineTrue() {\n+        return MemorySegment.ofBuffer(buffer).address();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentOfBuffer.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}