{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,0 @@\n-import java.io.FileDescriptor;\n@@ -44,1 +43,0 @@\n-import java.util.Objects;\n@@ -783,0 +781,17 @@\n+    \/**\n+     * {@return the scale shifts for this Buffer}\n+     * <p>\n+     * The scale shifts are:\n+     *   ByteBuffer:               0\n+     *   ShortBuffer, CharBuffer:  1\n+     *   IntBuffer, FloatBuffer:   2\n+     *   LongBuffer, DoubleBuffer: 3\n+     *\/\n+    abstract int scaleShifts();\n+\n+    abstract AbstractMemorySegmentImpl heapSegment(Object base,\n+                                                   long offset,\n+                                                   long length,\n+                                                   boolean readOnly,\n+                                                   MemorySessionImpl bufferScope);\n+\n@@ -835,0 +850,1 @@\n+                @ForceInline\n@@ -909,0 +925,17 @@\n+\n+                @ForceInline\n+                @Override\n+                public int scaleShifts(Buffer buffer) {\n+                    return buffer.scaleShifts();\n+                }\n+\n+                @ForceInline\n+                @Override\n+                public AbstractMemorySegmentImpl heapSegment(Buffer buffer,\n+                                                             Object base,\n+                                                             long offset,\n+                                                             long length,\n+                                                             boolean readOnly,\n+                                                             MemorySessionImpl bufferScope) {\n+                    return buffer.heapSegment(base, offset, length, readOnly, bufferScope);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Buffer.java","additions":36,"deletions":3,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,4 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.SegmentFactories;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -249,0 +253,15 @@\n+    @ForceInline\n+    @Override\n+    int scaleShifts() {\n+        return Integer.numberOfTrailingZeros($Fulltype$.BYTES);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    AbstractMemorySegmentImpl heapSegment(Object base,\n+                                          long offset,\n+                                          long length,\n+                                          boolean readOnly,\n+                                          MemorySessionImpl bufferScope) {\n+        return SegmentFactories.arrayOfByteSegment(base, offset, length, readOnly, bufferScope);\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/nio\/ByteBufferAs-X-Buffer.java.template","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n@@ -35,0 +36,2 @@\n+import jdk.internal.foreign.SegmentFactories;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -531,0 +534,18 @@\n+#if[byte]\n+    @ForceInline\n+    @Override\n+    int scaleShifts() {\n+        return 0;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    AbstractMemorySegmentImpl heapSegment(Object base,\n+                                          long offset,\n+                                          long length,\n+                                          boolean readOnly,\n+                                          MemorySessionImpl bufferScope) {\n+        \/\/ Direct buffers are not backed by an array.\n+        throw new UnsupportedOperationException();\n+    }\n+#end[byte]\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Direct-X-Buffer.java.template","additions":22,"deletions":1,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.SegmentFactories;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -738,0 +742,17 @@\n+#if[byte]\n+    @ForceInline\n+    @Override\n+    int scaleShifts() {\n+        return 0;\n+    }\n+\n+    @ForceInline\n+    @Override\n+    AbstractMemorySegmentImpl heapSegment(Object base,\n+                                          long offset,\n+                                          long length,\n+                                          boolean readOnly,\n+                                          MemorySessionImpl bufferScope) {\n+        return SegmentFactories.arrayOf$Type$Segment(base, offset, length, readOnly, bufferScope);\n+    }\n+#end[byte]\n","filename":"src\/java.base\/share\/classes\/java\/nio\/Heap-X-Buffer.java.template","additions":21,"deletions":0,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,4 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n+import jdk.internal.foreign.SegmentFactories;\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -2324,0 +2328,16 @@\n+    @ForceInline\n+    @Override\n+    int scaleShifts() {\n+        return Integer.numberOfTrailingZeros($Fulltype$.BYTES);\n+    }\n+\n+    @ForceInline\n+    @Override\n+    AbstractMemorySegmentImpl heapSegment(Object base,\n+                                          long offset,\n+                                          long length,\n+                                          boolean readOnly,\n+                                          MemorySessionImpl bufferScope) {\n+        return SegmentFactories.arrayOf$Type$Segment(base, offset, length, readOnly, bufferScope);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/nio\/X-Buffer.java.template","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+import jdk.internal.foreign.AbstractMemorySegmentImpl;\n+import jdk.internal.foreign.MemorySessionImpl;\n@@ -33,1 +35,0 @@\n-import java.io.FileDescriptor;\n@@ -130,0 +131,10 @@\n+\n+    int scaleShifts(Buffer buffer);\n+\n+    AbstractMemorySegmentImpl heapSegment(Buffer buffer,\n+                                          Object base,\n+                                          long offset,\n+                                          long length,\n+                                          boolean readOnly,\n+                                          MemorySessionImpl bufferScope);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaNioAccess.java","additions":13,"deletions":2,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -33,6 +33,0 @@\n-import java.nio.CharBuffer;\n-import java.nio.DoubleBuffer;\n-import java.nio.FloatBuffer;\n-import java.nio.IntBuffer;\n-import java.nio.LongBuffer;\n-import java.nio.ShortBuffer;\n@@ -54,1 +48,0 @@\n-import jdk.internal.util.Architecture;\n@@ -60,2 +53,0 @@\n-import static java.lang.foreign.ValueLayout.JAVA_BYTE;\n-\n@@ -524,4 +515,29 @@\n-    public static AbstractMemorySegmentImpl ofBuffer(Buffer bb) {\n-        Objects.requireNonNull(bb);\n-        Object base = NIO_ACCESS.getBufferBase(bb);\n-        if (!bb.isDirect() && base == null) {\n+    @ForceInline\n+    public static AbstractMemorySegmentImpl ofBuffer(Buffer b) {\n+        \/\/ Implicit null check via NIO_ACCESS.scaleShifts(b)\n+        final int scaleShifts = NIO_ACCESS.scaleShifts(b);\n+        return ofBuffer(b, offset(b, scaleShifts), length(b, scaleShifts));\n+    }\n+\n+    @ForceInline\n+    private static AbstractMemorySegmentImpl ofBuffer(Buffer b, long offset, long length) {\n+        final Object base = NIO_ACCESS.getBufferBase(b);\n+        return (base == null)\n+                ? nativeSegment(b, offset, length)\n+                : NIO_ACCESS.heapSegment(b, base, offset, length, b.isReadOnly(), bufferScope(b));\n+    }\n+\n+    @ForceInline\n+    private static long offset(Buffer b, int scaleShifts) {\n+        final long bbAddress = NIO_ACCESS.getBufferAddress(b);\n+        return bbAddress + (((long) b.position()) << scaleShifts);\n+    }\n+\n+    @ForceInline\n+    private static long length(Buffer b, int scaleShifts) {\n+        return ((long) b.limit() - b.position()) << scaleShifts;\n+    }\n+\n+    @ForceInline\n+    private static AbstractMemorySegmentImpl nativeSegment(Buffer b, long offset, long length) {\n+        if (!b.isDirect()) {\n@@ -530,34 +546,4 @@\n-        long bbAddress = NIO_ACCESS.getBufferAddress(bb);\n-        UnmapperProxy unmapper = NIO_ACCESS.unmapper(bb);\n-\n-        int pos = bb.position();\n-        int limit = bb.limit();\n-        int size = limit - pos;\n-\n-        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl) NIO_ACCESS.bufferSegment(bb);\n-        boolean readOnly = bb.isReadOnly();\n-        int scaleFactor = getScaleFactor(bb);\n-        final MemorySessionImpl bufferScope;\n-        if (bufferSegment != null) {\n-            bufferScope = bufferSegment.scope;\n-        } else {\n-            bufferScope = MemorySessionImpl.createHeap(bufferRef(bb));\n-        }\n-        long off = bbAddress + ((long)pos << scaleFactor);\n-        long len = (long)size << scaleFactor;\n-        if (base != null) {\n-            return switch (base) {\n-                case byte[]   _ -> new HeapMemorySegmentImpl.OfByte(off, base, len, readOnly, bufferScope);\n-                case short[]  _ -> new HeapMemorySegmentImpl.OfShort(off, base, len, readOnly, bufferScope);\n-                case char[]   _ -> new HeapMemorySegmentImpl.OfChar(off, base, len, readOnly, bufferScope);\n-                case int[]    _ -> new HeapMemorySegmentImpl.OfInt(off, base, len, readOnly, bufferScope);\n-                case float[]  _ -> new HeapMemorySegmentImpl.OfFloat(off, base, len, readOnly, bufferScope);\n-                case long[]   _ -> new HeapMemorySegmentImpl.OfLong(off, base, len, readOnly, bufferScope);\n-                case double[] _ -> new HeapMemorySegmentImpl.OfDouble(off, base, len, readOnly, bufferScope);\n-                default         -> throw new AssertionError(\"Cannot get here\");\n-            };\n-        } else if (unmapper == null) {\n-            return new NativeMemorySegmentImpl(off, len, readOnly, bufferScope);\n-        } else {\n-            return new MappedMemorySegmentImpl(off, unmapper, len, readOnly, bufferScope);\n-        }\n+        final UnmapperProxy unmapper = NIO_ACCESS.unmapper(b);\n+        return unmapper == null\n+                ? new NativeMemorySegmentImpl(offset, length, b.isReadOnly(), bufferScope(b))\n+                : new MappedMemorySegmentImpl(offset, unmapper, length, b.isReadOnly(), bufferScope(b));\n@@ -566,0 +552,10 @@\n+    @ForceInline\n+    private static MemorySessionImpl bufferScope(Buffer b) {\n+        final AbstractMemorySegmentImpl bufferSegment =\n+                (AbstractMemorySegmentImpl) NIO_ACCESS.bufferSegment(b);\n+        return bufferSegment == null\n+                ? MemorySessionImpl.createHeap(bufferRef(b))\n+                : bufferSegment.scope;\n+    }\n+\n+    @ForceInline\n@@ -663,9 +659,0 @@\n-    private static int getScaleFactor(Buffer buffer) {\n-        return switch (buffer) {\n-            case ByteBuffer   _                 -> 0;\n-            case CharBuffer   _, ShortBuffer  _ -> 1;\n-            case IntBuffer    _, FloatBuffer  _ -> 2;\n-            case LongBuffer   _, DoubleBuffer _ -> 3;\n-        };\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":43,"deletions":56,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -143,0 +143,58 @@\n+    \/\/ Buffer conversion factories\n+\n+    public static AbstractMemorySegmentImpl arrayOfByteSegment(Object base,\n+                                                               long offset,\n+                                                               long length,\n+                                                               boolean readOnly,\n+                                                               MemorySessionImpl bufferScope) {\n+        return new HeapMemorySegmentImpl.OfByte(offset, base, length, readOnly, bufferScope);\n+    }\n+\n+    public static AbstractMemorySegmentImpl arrayOfShortSegment(Object base,\n+                                                                long offset,\n+                                                                long length,\n+                                                                boolean readOnly,\n+                                                                MemorySessionImpl bufferScope) {\n+        return new HeapMemorySegmentImpl.OfShort(offset, base, length, readOnly, bufferScope);\n+    }\n+\n+    public static AbstractMemorySegmentImpl arrayOfCharSegment(Object base,\n+                                                               long offset,\n+                                                               long length,\n+                                                               boolean readOnly,\n+                                                               MemorySessionImpl bufferScope) {\n+        return new HeapMemorySegmentImpl.OfChar(offset, base, length, readOnly, bufferScope);\n+    }\n+\n+    public static AbstractMemorySegmentImpl arrayOfIntSegment(Object base,\n+                                                              long offset,\n+                                                              long length,\n+                                                              boolean readOnly,\n+                                                              MemorySessionImpl bufferScope) {\n+        return new HeapMemorySegmentImpl.OfInt(offset, base, length, readOnly, bufferScope);\n+    }\n+\n+    public static AbstractMemorySegmentImpl arrayOfFloatSegment(Object base,\n+                                                                long offset,\n+                                                                long length,\n+                                                                boolean readOnly,\n+                                                                MemorySessionImpl bufferScope) {\n+        return new HeapMemorySegmentImpl.OfFloat(offset, base, length, readOnly, bufferScope);\n+    }\n+\n+    public static AbstractMemorySegmentImpl arrayOfLongSegment(Object base,\n+                                                               long offset,\n+                                                               long length,\n+                                                               boolean readOnly,\n+                                                               MemorySessionImpl bufferScope) {\n+        return new HeapMemorySegmentImpl.OfLong(offset, base, length, readOnly, bufferScope);\n+    }\n+\n+    public static AbstractMemorySegmentImpl arrayOfDoubleSegment(Object base,\n+                                                                 long offset,\n+                                                                 long length,\n+                                                                 boolean readOnly,\n+                                                                 MemorySessionImpl bufferScope) {\n+        return new HeapMemorySegmentImpl.OfDouble(offset, base, length, readOnly, bufferScope);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SegmentFactories.java","additions":58,"deletions":0,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@State(Scope.Benchmark)\n+public class SegmentOfBuffer {\n+\n+    private final ByteBuffer buffer = ByteBuffer\n+            .allocateDirect(0x1000)\n+            .order(ByteOrder.nativeOrder());\n+\n+    @Benchmark\n+    @Fork(value = 3)\n+    public long ofBuffer() {\n+        return MemorySegment.ofBuffer(buffer).address();\n+    }\n+\n+    @Benchmark\n+    @Fork(value = 3, jvmArgsAppend = \"-XX:CompileCommand=inline,jdk.internal.foreign.AbstractMemorySegmentImpl::ofBuffer,false\")\n+    public long ofBufferInlineFalse() {\n+        return MemorySegment.ofBuffer(buffer).address();\n+    }\n+\n+    @Benchmark\n+    @Fork(value = 3, jvmArgsAppend = \"-XX:CompileCommand=inline,jdk.internal.foreign.AbstractMemorySegmentImpl::ofBuffer,true\")\n+    public long ofBufferInlineTrue() {\n+        return MemorySegment.ofBuffer(buffer).address();\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/SegmentOfBuffer.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}