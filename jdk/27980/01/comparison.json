{"files":[{"patch":"@@ -2771,1 +2771,1 @@\n-     * @apiNote Note that calling {@code nthRoot(2)} is equivalent to calling {@code sqrt()}.\n+     * @apiNote Note that calling {@code rootn(2)} is equivalent to calling {@code sqrt()}.\n@@ -2773,1 +2773,1 @@\n-    public BigInteger nthRoot(int n) {\n+    public BigInteger rootn(int n) {\n@@ -2781,1 +2781,1 @@\n-        return new MutableBigInteger(this.mag).nthRootRem(n)[0].toBigInteger(signum);\n+        return new MutableBigInteger(this.mag).rootnRem(n)[0].toBigInteger(signum);\n@@ -2796,1 +2796,1 @@\n-     * @see #nthRoot(int)\n+     * @see #rootn(int)\n@@ -2798,1 +2798,1 @@\n-     * @apiNote Note that calling {@code nthRootAndRemainder(2)} is equivalent to calling\n+     * @apiNote Note that calling {@code rootnAndRemainder(2)} is equivalent to calling\n@@ -2801,1 +2801,1 @@\n-    public BigInteger[] nthRootAndRemainder(int n) {\n+    public BigInteger[] rootnAndRemainder(int n) {\n@@ -2809,1 +2809,1 @@\n-        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).nthRootRem(n);\n+        MutableBigInteger[] rootRem = new MutableBigInteger(this.mag).rootnRem(n);\n","filename":"src\/java.base\/share\/classes\/java\/math\/BigInteger.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1909,1 +1909,1 @@\n-    MutableBigInteger[] nthRootRem(int n) {\n+    MutableBigInteger[] rootnRem(int n) {\n@@ -1926,1 +1926,1 @@\n-            long sLong = (long) nthRootApprox(Math.nextUp(x >= 0 ? x : x + 0x1p64), n) + 1L;\n+            long sLong = (long) rootnApprox(Math.nextUp(x >= 0 ? x : x + 0x1p64), n) + 1L;\n@@ -1999,1 +1999,1 @@\n-                approx = nthRootApprox(rad, n);\n+                approx = rootnApprox(rad, n);\n@@ -2053,1 +2053,1 @@\n-                    newtonRecurrenceNthRoot(x, s, n, s.toBigInteger().pow(n - 1));\n+                    newtonRecurrenceRootn(x, s, n, s.toBigInteger().pow(n - 1));\n@@ -2063,1 +2063,1 @@\n-        newtonRecurrenceNthRoot(this, s, n, s.toBigInteger().pow(n - 1));\n+        newtonRecurrenceRootn(this, s, n, s.toBigInteger().pow(n - 1));\n@@ -2072,1 +2072,1 @@\n-            newtonRecurrenceNthRoot(this, s, n, sToN1);\n+            newtonRecurrenceRootn(this, s, n, sToN1);\n@@ -2076,1 +2076,1 @@\n-    private static double nthRootApprox(double x, int n) {\n+    private static double rootnApprox(double x, int n) {\n@@ -2083,1 +2083,1 @@\n-    private static void newtonRecurrenceNthRoot(\n+    private static void newtonRecurrenceRootn(\n","filename":"src\/java.base\/share\/classes\/java\/math\/MutableBigInteger.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *      8074460 8078672 8032027 8229845 8077587 8367365\n+ *      8074460 8078672 8032027 8229845 8077587 8367365 8370628\n@@ -235,1 +235,1 @@\n-                    y.nthRoot(power), \"BigInteger.pow() inconsistent with BigInteger.nthRoot()\");\n+                    y.rootn(power), \"BigInteger.pow() inconsistent with BigInteger.rootn()\");\n@@ -417,1 +417,1 @@\n-    private static void nthRootSmall() {\n+    private static void rootnSmall() {\n@@ -425,2 +425,2 @@\n-            s = x.nthRoot(n);\n-            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            s = x.rootn(n);\n+            \/\/ If rootn() does not throw an exception that is a failure.\n@@ -428,1 +428,1 @@\n-            printErr(\"nthRoot() of non-positive degree did not throw an exception\");\n+            printErr(\"rootn() of non-positive degree did not throw an exception\");\n@@ -437,2 +437,2 @@\n-            s = x.nthRoot(n);\n-            \/\/ If nthRoot() does not throw an exception that is a failure.\n+            s = x.rootn(n);\n+            \/\/ If rootn() does not throw an exception that is a failure.\n@@ -440,1 +440,1 @@\n-            printErr(\"nthRoot() of negative number and even degree did not throw an exception\");\n+            printErr(\"rootn() of negative number and even degree did not throw an exception\");\n@@ -445,1 +445,1 @@\n-        \/\/ A negative value with odd degree should return -nthRoot(-x, n)\n+        \/\/ A negative value with odd degree should return -rootn(-x, n)\n@@ -448,2 +448,2 @@\n-        failCount += checkResult(x.negate().nthRoot(n).negate(), x.nthRoot(n),\n-                \"nthRoot(\" + x + \", \" + n + \") != -nthRoot(\" + x.negate() + \", \" + n + \")\");\n+        failCount += checkResult(x.negate().rootn(n).negate(), x.rootn(n),\n+                \"rootn(\" + x + \", \" + n + \") != -rootn(\" + x.negate() + \", \" + n + \")\");\n@@ -452,2 +452,2 @@\n-        failCount += checkResult(BigInteger.ZERO, BigInteger.ZERO.nthRoot(n),\n-                \"nthRoot(0, \" + n + \") != 0\");\n+        failCount += checkResult(BigInteger.ZERO, BigInteger.ZERO.rootn(n),\n+                \"rootn(0, \" + n + \") != 0\");\n@@ -457,1 +457,1 @@\n-        failCount += checkResult(x, x.nthRoot(1), \"nthRoot(\" + x + \", 1) != \" + x);\n+        failCount += checkResult(x, x.rootn(1), \"rootn(\" + x + \", 1) != \" + x);\n@@ -464,1 +464,1 @@\n-                    BigInteger.valueOf(i).nthRoot(n), \"nthRoot(\" + i + \", \" + n + \") != 1\");\n+                    BigInteger.valueOf(i).rootn(n), \"rootn(\" + i + \", \" + n + \") != 1\");\n@@ -467,1 +467,1 @@\n-        report(\"nthRootSmall\", failCount);\n+        report(\"rootnSmall\", failCount);\n@@ -470,2 +470,2 @@\n-    public static void nthRoot() {\n-        nthRootSmall();\n+    public static void rootn() {\n+        rootnSmall();\n@@ -479,1 +479,1 @@\n-            failCount += checkResult(x, xN.nthRoot(n), \"nthRoot() x^n -> x\");\n+            failCount += checkResult(x, xN.rootn(n), \"rootn() x^n -> x\");\n@@ -483,1 +483,1 @@\n-            failCount += checkResult(x, xNup.nthRoot(n), \"nthRoot() x^n + 1 -> x\");\n+            failCount += checkResult(x, xNup.rootn(n), \"rootn() x^n + 1 -> x\");\n@@ -488,1 +488,1 @@\n-            failCount += checkResult(x, up.nthRoot(n), \"nthRoot() (x + 1)^n - 1 -> x\");\n+            failCount += checkResult(x, up.rootn(n), \"rootn() (x + 1)^n - 1 -> x\");\n@@ -490,2 +490,2 @@\n-            \/\/ nthRoot(x, n)^n <= x\n-            BigInteger r = x.nthRoot(n);\n+            \/\/ rootn(x, n)^n <= x\n+            BigInteger r = x.rootn(n);\n@@ -494,1 +494,1 @@\n-                printErr(\"nthRoot(x, n)^n > x for x = \" + x + \", n = \" + n);\n+                printErr(\"rootn(x, n)^n > x for x = \" + x + \", n = \" + n);\n@@ -497,1 +497,1 @@\n-            \/\/ (nthRoot(x, n) + 1)^n > x\n+            \/\/ (rootn(x, n) + 1)^n > x\n@@ -500,1 +500,1 @@\n-                printErr(\"(nthRoot(x, n) + 1)^n <= x for x = \" + x + \", n = \" + n);\n+                printErr(\"(rootn(x, n) + 1)^n <= x for x = \" + x + \", n = \" + n);\n@@ -516,1 +516,1 @@\n-        report(\"nthRoot for 2^N, 2^N - 1 and 2^N + 1, 1 <= N <= \" + maxExponent,\n+        report(\"rootn for 2^N, 2^N - 1 and 2^N + 1, 1 <= N <= \" + maxExponent,\n@@ -520,1 +520,1 @@\n-        report(\"nthRoot for int\", ints.mapToObj(x ->\n+        report(\"rootn for int\", ints.mapToObj(x ->\n@@ -524,1 +524,1 @@\n-        report(\"nthRoot for long\", longs.mapToObj(x ->\n+        report(\"rootn for long\", longs.mapToObj(x ->\n@@ -528,1 +528,1 @@\n-        report(\"nthRoot for double\", doubles.mapToObj(x ->\n+        report(\"rootn for double\", doubles.mapToObj(x ->\n@@ -532,1 +532,1 @@\n-    public static void nthRootAndRemainder() {\n+    public static void rootnAndRemainder() {\n@@ -539,3 +539,3 @@\n-            BigInteger[] actual = xN.nthRootAndRemainder(n);\n-            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n-            failCount += checkResult(BigInteger.ZERO, actual[1], \"nthRootAndRemainder()[1]\");\n+            BigInteger[] actual = xN.rootnAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"rootnAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ZERO, actual[1], \"rootnAndRemainder()[1]\");\n@@ -545,3 +545,3 @@\n-            actual = xNup.nthRootAndRemainder(n);\n-            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n-            failCount += checkResult(BigInteger.ONE, actual[1], \"nthRootAndRemainder()[1]\");\n+            actual = xNup.rootnAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"rootnAndRemainder()[0]\");\n+            failCount += checkResult(BigInteger.ONE, actual[1], \"rootnAndRemainder()[1]\");\n@@ -552,2 +552,2 @@\n-            actual = up.nthRootAndRemainder(n);\n-            failCount += checkResult(x, actual[0], \"nthRootAndRemainder()[0]\");\n+            actual = up.rootnAndRemainder(n);\n+            failCount += checkResult(x, actual[0], \"rootnAndRemainder()[0]\");\n@@ -555,1 +555,1 @@\n-            failCount += checkResult(r, actual[1], \"nthRootAndRemainder()[1]\");\n+            failCount += checkResult(r, actual[1], \"rootnAndRemainder()[1]\");\n@@ -561,1 +561,1 @@\n-        report(\"nthRootAndRemainder\", bits.mapToObj(x ->\n+        report(\"rootnAndRemainder\", bits.mapToObj(x ->\n@@ -1475,2 +1475,2 @@\n-            nthRoot();\n-            nthRootAndRemainder();\n+            rootn();\n+            rootnAndRemainder();\n","filename":"test\/jdk\/java\/math\/BigInteger\/BigIntegerTest.java","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"}]}