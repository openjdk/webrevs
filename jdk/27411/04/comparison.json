{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n@@ -29,1 +31,0 @@\n-import java.util.concurrent.RecursiveTask;\n@@ -31,1 +32,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -39,1 +40,1 @@\n- * faster than traditional (one-pivot) Quicksort implementations.\n+ * faster than traditional (one-pivot) Quicksort implementations.<p>\n@@ -42,2 +43,3 @@\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, counting sort and parallel merge sort.\n+ * Quicksort such as merging sort, sorting network, heap sort, mixed\n+ * insertion sort, counting sort and parallel merge sort. The actual\n+ * sorting algorithm depends on the data type and array size.\n@@ -50,1 +52,1 @@\n- * @version 2018.08.18\n+ * @version 2024.06.14\n@@ -52,1 +54,1 @@\n- * @since 1.7 * 14\n+ * @since 1.7 * 14 ^ 26\n@@ -57,1 +59,43 @@\n-     * Prevents instantiation.\n+     * <b>High-level description of sorting logic.<\/b><p>\n+     *\n+     * <b>Type: int\/long\/float\/double<\/b><p>\n+     *\n+     * If the array size is small, invoke mixed insertion sort on\n+     * non-leftmost parts or insertion sort on leftmost part.<p>\n+     *\n+     * Then try merging sort which is the best on almost\n+     * sorted arrays.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with heap sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Type: float\/double<\/b><p>\n+     *\n+     * Floating-point values require additional steps to process\n+     * negative zeros -0.0 and NaNs (Not-a-Number) and re-arrange\n+     * negative zeros at the end.<p>\n+     *\n+     * <b>Type: byte<\/b><p>\n+     *\n+     * Invoke insertion sort, if the array size is small,\n+     * otherwise switch to counting sort.<p>\n+     *\n+     * <b>Type: char\/short<\/b><p>\n+     *\n+     * Invoke counting sort on large array, otherwise run\n+     * insertion sort on small array.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with counting sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+     *\n+     * If the array size is small, sequential sort is run.\n+     * Otherwise invoke parallel merge sort (the recursion depth\n+     * depends on parallelism level), then run parallel Quicksort.\n@@ -61,4 +105,1 @@\n-    \/**\n-     * Max array size to use mixed insertion sort.\n-     *\/\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+    \/* ----------------------- Insertion sort ----------------------- *\/\n@@ -67,1 +108,1 @@\n-     * Max array size to use insertion sort.\n+     * Max size of array to use insertion sort (the best on shuffle data).\n@@ -69,1 +110,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 44;\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n@@ -71,4 +112,1 @@\n-    \/**\n-     * Min array size to perform sorting in parallel.\n-     *\/\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n+    \/* ------------------------ Merging sort ------------------------ *\/\n@@ -77,1 +115,1 @@\n-     * Min array size to try merging of runs.\n+     * Min size of array to use merging sort (the best on stagger data).\n@@ -79,1 +117,1 @@\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n@@ -82,1 +120,1 @@\n-     * Min size of the first run to continue with scanning.\n+     * Min size of run to continue scanning (the best on stagger data).\n@@ -84,1 +122,1 @@\n-    private static final int MIN_FIRST_RUN_SIZE = 16;\n+    private static final int MIN_RUN_SIZE = 64;\n@@ -87,1 +125,1 @@\n-     * Min factor for the first runs to continue scanning.\n+     * Max capacity of the index array to track the runs.\n@@ -89,1 +127,1 @@\n-    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+    private static final int MAX_RUN_CAPACITY = 10 << 10;\n@@ -91,4 +129,1 @@\n-    \/**\n-     * Max capacity of the index array for tracking runs.\n-     *\/\n-    private static final int MAX_RUN_CAPACITY = 5 << 10;\n+    \/* ------------------------ Digital sort ------------------------ *\/\n@@ -97,1 +132,1 @@\n-     * Min number of runs, required by parallel merging.\n+     * Min size of array to use counting sort (the best on random data).\n@@ -99,1 +134,1 @@\n-    private static final int MIN_RUN_COUNT = 4;\n+    private static final int MIN_COUNTING_SORT_SIZE = 640;\n@@ -102,1 +137,1 @@\n-     * Min array size to use parallel merging of parts.\n+     * Min size of array to use numerical sort (the best on repeated data).\n@@ -104,1 +139,1 @@\n-    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;\n+    private static final int MIN_NUMERICAL_SORT_SIZE = 9 << 10;\n@@ -106,4 +141,1 @@\n-    \/**\n-     * Min size of a byte array to use counting sort.\n-     *\/\n-    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;\n+    \/* ----------------------- Parallel sort ------------------------ *\/\n@@ -112,1 +144,1 @@\n-     * Min size of a short or char array to use counting sort.\n+     * Min size of array to perform sorting in parallel (the best on stagger data).\n@@ -114,1 +146,3 @@\n-    private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;\n+    private static final int MIN_PARALLEL_SORT_SIZE = 3 << 10;\n+\n+    \/* ----------------------- Infrastructure ----------------------- *\/\n@@ -117,1 +151,1 @@\n-     * Threshold of mixed insertion sort is incremented by this value.\n+     * Max recursive depth before switching to heap sort.\n@@ -119,1 +153,1 @@\n-    private static final int DELTA = 3 << 1;\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n@@ -122,1 +156,2 @@\n-     * Max recursive partitioning depth before using heap sort.\n+     * Max size of additional buffer in bytes,\n+     *      limited by max_heap \/ 16 or 2 GB max.\n@@ -124,1 +159,2 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+    private static final int MAX_BUFFER_SIZE =\n+        Math.clamp(Runtime.getRuntime().maxMemory() >>> 4, 0, Integer.MAX_VALUE);\n@@ -127,2 +163,4 @@\n-     * Represents a function that accepts the array and sorts the specified range\n-     * of the array into ascending order.\n+     * Represents a function that accepts the array and sorts\n+     * the specified range of the array into ascending order.\n+     *\n+     * @param <T> the class of array\n@@ -131,1 +169,1 @@\n-    private static interface SortOperation<A> {\n+    private interface SortOperation<T> {\n@@ -139,1 +177,1 @@\n-        void sort(A a, int low, int high);\n+        void sort(T a, int low, int high);\n@@ -144,0 +182,3 @@\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n@@ -145,0 +186,1 @@\n+     * @param <T> the class of array\n@@ -146,4 +188,5 @@\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to sort, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to sort from.\n+     * @param a the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n@@ -154,1 +197,0 @@\n-    @IntrinsicCandidate\n@@ -156,2 +198,4 @@\n-    private static <A> void sort(Class<?> elemType, A array, long offset, int low, int high, SortOperation<A> so) {\n-        so.sort(array, low, high);\n+    @IntrinsicCandidate\n+    private static <T> void sort(Class<?> elemType, T a, long offset,\n+            int low, int high, SortOperation<T> so) {\n+        so.sort(a, low, high);\n@@ -161,2 +205,4 @@\n-     * Represents a function that accepts the array and partitions the specified range\n-     * of the array using the pivots provided.\n+     * Represents a function that accepts the array and partitions\n+     * the specified range of the array using the given pivots.\n+     *\n+     * @param <T> the class of array\n@@ -165,1 +211,1 @@\n-    interface PartitionOperation<A> {\n+    private interface PartitionOperation<T> {\n@@ -169,3 +215,3 @@\n-         * @param a the array to be partitioned\n-         * @param low the index of the first element, inclusive, to be partitioned\n-         * @param high the index of the last element, exclusive, to be partitioned\n+         * @param a the array for partitioning\n+         * @param low the index of the first element, inclusive, for partitioning\n+         * @param high the index of the last element, exclusive, for partitioning\n@@ -174,0 +220,1 @@\n+         * @return indices of parts after partitioning\n@@ -175,1 +222,1 @@\n-        int[] partition(A a, int low, int high, int pivotIndex1, int pivotIndex2);\n+        int[] partition(T a, int low, int high, int pivotIndex1, int pivotIndex2);\n@@ -179,1 +226,4 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using the given pivots.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n@@ -181,7 +231,9 @@\n-     * @param elemType the class of the array to be partitioned\n-     * @param array the array to be partitioned\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to partition, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to partition from.\n-     * @param low the index of the first element, inclusive, to be partitioned\n-     * @param high the index of the last element, exclusive, to be partitioned\n+     * @param <T> the class of array\n+     * @param elemType the class of the array for partitioning\n+     * @param a the array for partitioning\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n@@ -191,0 +243,1 @@\n+     * @return indices of parts after partitioning\n@@ -192,1 +245,0 @@\n-    @IntrinsicCandidate\n@@ -194,2 +246,4 @@\n-    private static <A> int[] partition(Class<?> elemType, A array, long offset, int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<A> po) {\n-        return po.partition(array, low, high, pivotIndex1, pivotIndex2);\n+    @IntrinsicCandidate\n+    private static <T> int[] partition(Class<?> elemType, T a, long offset,\n+            int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<T> po) {\n+        return po.partition(a, low, high, pivotIndex1, pivotIndex2);\n@@ -198,16 +252,1 @@\n-    \/**\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n-     *\/\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n-\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n-    }\n+\/\/ #[int]\n@@ -217,1 +256,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -231,6 +270,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            int[] b = depth == 0 ? null : new int[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -243,2 +278,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -246,1 +280,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -249,1 +283,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -253,1 +287,1 @@\n-    static void sort(Sorter sorter, int[] a, int bits, int low, int high) {\n+    static void sort(Sorter<int[]> sorter, int[] a, int bits, int low, int high) {\n@@ -255,8 +289,1 @@\n-            int end = high - 1, size = high - low;\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -265,1 +292,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -267,2 +294,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -273,2 +301,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -276,2 +303,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -282,2 +310,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -285,2 +312,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -291,2 +318,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -294,1 +322,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -303,1 +331,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -307,1 +335,0 @@\n-            int a3 = a[e3];\n@@ -310,1 +337,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -313,7 +340,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -321,9 +359,3 @@\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    int t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -331,1 +363,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    int t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -333,3 +365,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    int t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -337,1 +369,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    int t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -341,3 +373,7 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n@@ -346,1 +382,2 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n@@ -348,9 +385,1 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+            int[] indices;\n@@ -358,0 +387,4 @@\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -359,0 +392,2 @@\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n@@ -364,3 +399,3 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -368,2 +403,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -372,1 +407,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -374,7 +412,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -386,2 +417,2 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -389,1 +420,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -392,1 +423,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -397,1 +428,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -399,1 +430,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -404,1 +435,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -406,3 +437,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -410,1 +444,0 @@\n-        int upper = end;\n@@ -412,4 +445,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        int pivot1 = a[e1];\n-        int pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        int pivot1 = a[pivotIndex1];\n+        int pivot2 = a[pivotIndex2];\n@@ -424,2 +460,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -436,13 +472,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -451,0 +481,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -455,12 +487,6 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n@@ -468,1 +494,8 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -477,2 +510,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -480,1 +513,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -484,1 +517,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -486,1 +519,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -489,3 +522,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -493,4 +526,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -498,3 +533,6 @@\n-        int upper = end;\n-        int e3 = pivotIndex1;\n-        int pivot = a[e3];\n+\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        int pivot = a[pivotIndex1];\n@@ -509,1 +547,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -512,1 +550,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n+         * Dutch National Flag partitioning\n@@ -514,13 +552,7 @@\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -529,0 +561,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -530,1 +564,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -533,2 +567,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -536,2 +572,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -539,6 +575,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -546,0 +578,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -553,1 +588,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -557,1 +593,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -559,2 +595,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -572,4 +608,11 @@\n-    private static void mixedInsertionSort(int[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(int[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            int ai = a[i = low], pin = a[--p];\n@@ -578,1 +621,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Swap larger element with pin.\n@@ -580,7 +623,3 @@\n-            for (int i; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -588,1 +627,0 @@\n-        } else {\n@@ -591,7 +629,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -599,40 +631,2 @@\n-            int pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n@@ -640,0 +634,8 @@\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            int a1 = a[i = low], a2 = a[++low];\n@@ -642,1 +644,3 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n@@ -644,9 +648,1 @@\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+            if (a1 > a2) {\n@@ -654,4 +650,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -659,4 +655,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -664,1 +660,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -666,4 +662,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -671,4 +667,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -676,0 +670,1 @@\n+                a[i + 1] = a1;\n@@ -687,1 +682,1 @@\n-    private static void insertionSort(int[] a, int low, int high) {\n+    static void insertionSort(int[] a, int low, int high) {\n@@ -692,4 +687,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -701,1 +697,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -703,0 +699,1 @@\n+     * @param sorter the parallel context\n@@ -706,0 +703,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -707,48 +705,1 @@\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<int[]> sorter, int[] a, int low, int high) {\n@@ -756,3 +707,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -760,0 +710,1 @@\n+        int count = 1;\n@@ -761,2 +712,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -767,2 +716,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -770,1 +718,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -786,0 +734,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -789,0 +743,1 @@\n+                \/\/ Check the next sequence\n@@ -795,1 +750,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -798,1 +753,0 @@\n-                if (k == high) {\n@@ -800,0 +754,1 @@\n+                if (k == high) {\n@@ -801,1 +756,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -806,11 +761,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -819,3 +764,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -823,0 +766,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -824,2 +768,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -830,2 +774,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -837,0 +780,1 @@\n+            }\n@@ -838,1 +782,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -840,5 +787,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -846,1 +793,0 @@\n-            run[count] = (last = k);\n@@ -850,1 +796,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -855,3 +801,1 @@\n-            if (sorter == null || (b = (int[]) sorter.b) == null) {\n-                b = new int[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -859,0 +803,2 @@\n+            } else if ((b = tryAllocate(int[].class, high - low)) == null) {\n+                return false;\n@@ -860,1 +806,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -868,0 +814,1 @@\n+     * @param sorter the parallel context\n@@ -869,1 +816,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -871,2 +818,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -876,1 +822,0 @@\n-     * @return the destination where runs are merged\n@@ -878,2 +823,2 @@\n-    private static int[] mergeRuns(int[] a, int[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<int[]> sorter, int[] a, int[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -882,2 +827,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -885,4 +830,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -892,1 +834,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -894,2 +836,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -898,1 +840,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -900,10 +842,2 @@\n-        int[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (int[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -911,1 +845,2 @@\n-        int[] dst = a1 == a ? b : a;\n+        int[] dst = aim ? a : b;\n+        int[] src = aim ? b : a;\n@@ -913,5 +848,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -919,2 +854,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -922,1 +860,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -924,1 +862,0 @@\n-        return dst;\n@@ -928,1 +865,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -930,1 +867,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -933,1 +870,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -936,1 +873,0 @@\n-     * @param a2 the second part\n@@ -940,2 +876,2 @@\n-    private static void mergeParts(Merger merger, int[] dst, int k,\n-            int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<int[]> merger, int[] dst, int k,\n+            int[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -943,1 +879,2 @@\n-        if (merger != null && a1 == a2) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n@@ -945,1 +882,4 @@\n-            while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n@@ -948,1 +888,1 @@\n-                 * The first part must be larger.\n+                 * Find the median of the larger part.\n@@ -950,4 +890,3 @@\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                int key = src[mi2];\n@@ -956,1 +895,1 @@\n-                 * Small parts will be merged sequentially.\n+                 * Split the smaller part.\n@@ -958,2 +897,8 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n@@ -961,0 +906,1 @@\n+            } else {\n@@ -965,3 +911,3 @@\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                int key = a1[mi1];\n-                int mi2 = hi2;\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                int key = src[mi1];\n@@ -970,1 +916,1 @@\n-                 * Partition the smaller part.\n+                 * Split the smaller part.\n@@ -972,2 +918,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n@@ -975,2 +921,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n@@ -978,1 +924,1 @@\n-                        mi2 = t;\n+                        mi2 = mid;\n@@ -981,0 +927,1 @@\n+            }\n@@ -982,1 +929,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -984,4 +934,4 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+            \/*\n+             * Skip the first parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -989,6 +939,5 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n-            }\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n@@ -998,1 +947,1 @@\n-         * Merge small parts sequentially.\n+         * Merge the small parts sequentially.\n@@ -1000,13 +949,1 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n-        }\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n-        }\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n-            }\n-        }\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -1015,2 +952,0 @@\n-\/\/ [long]\n-\n@@ -1018,2 +953,106 @@\n-     * Sorts the specified range of the array using parallel merge\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(int[] dst, int k,\n+            int[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    int next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    int next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    int next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(int[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            int max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+\n+\/\/ #[long]\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -1033,6 +1072,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            long[] b = depth == 0 ? null : new long[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -1045,2 +1080,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1048,1 +1082,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -1051,1 +1085,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1055,1 +1089,1 @@\n-    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {\n+    static void sort(Sorter<long[]> sorter, long[] a, int bits, int low, int high) {\n@@ -1057,9 +1091,1 @@\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -1068,1 +1094,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -1070,2 +1096,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -1076,2 +1103,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -1079,2 +1105,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -1085,2 +1112,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -1088,2 +1114,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -1094,2 +1120,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1097,1 +1124,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1106,1 +1133,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -1110,1 +1137,0 @@\n-            long a3 = a[e3];\n@@ -1113,1 +1139,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -1116,7 +1142,9 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -1124,9 +1152,12 @@\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    long t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -1134,1 +1165,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    long t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -1136,3 +1167,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    long t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -1140,1 +1171,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    long t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -1144,3 +1175,13 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -1149,1 +1190,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -1153,8 +1194,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -1165,3 +1201,3 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -1169,2 +1205,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -1173,1 +1209,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -1175,7 +1214,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -1187,2 +1219,2 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -1190,1 +1222,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -1193,1 +1225,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -1198,1 +1230,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -1200,1 +1232,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1205,1 +1237,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -1207,3 +1239,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -1211,1 +1246,0 @@\n-        int upper = end;\n@@ -1213,4 +1247,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        long pivot1 = a[e1];\n-        long pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        long pivot1 = a[pivotIndex1];\n+        long pivot2 = a[pivotIndex2];\n@@ -1225,2 +1262,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -1237,13 +1274,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -1252,0 +1283,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1256,12 +1289,12 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n@@ -1269,1 +1302,2 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -1278,2 +1312,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -1281,1 +1315,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -1285,1 +1319,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -1287,1 +1321,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1290,3 +1324,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -1294,4 +1328,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -1299,1 +1335,0 @@\n-        int upper = end;\n@@ -1301,2 +1336,5 @@\n-        int e3 = pivotIndex1;\n-        long pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        long pivot = a[pivotIndex1];\n@@ -1311,1 +1349,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -1314,1 +1352,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n+         * Dutch National Flag partitioning\n@@ -1316,13 +1354,7 @@\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -1331,0 +1363,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1332,1 +1366,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -1335,2 +1369,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -1338,2 +1374,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -1341,6 +1377,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -1348,0 +1380,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -1355,1 +1390,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -1359,1 +1395,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -1361,2 +1397,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -1374,4 +1410,11 @@\n-    private static void mixedInsertionSort(long[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(long[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            long ai = a[i = low], pin = a[--p];\n@@ -1380,1 +1423,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Swap larger element with pin.\n@@ -1382,7 +1425,3 @@\n-            for (int i; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -1390,1 +1429,0 @@\n-        } else {\n@@ -1393,7 +1431,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -1401,40 +1433,2 @@\n-            long pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n@@ -1442,0 +1436,8 @@\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            long a1 = a[i = low], a2 = a[++low];\n@@ -1444,1 +1446,3 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n@@ -1446,9 +1450,1 @@\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+            if (a1 > a2) {\n@@ -1456,4 +1452,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -1461,4 +1457,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -1466,1 +1462,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -1468,4 +1464,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -1473,4 +1469,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1478,0 +1472,1 @@\n+                a[i + 1] = a1;\n@@ -1489,1 +1484,1 @@\n-    private static void insertionSort(long[] a, int low, int high) {\n+    static void insertionSort(long[] a, int low, int high) {\n@@ -1494,4 +1489,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -1503,1 +1499,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1505,0 +1501,1 @@\n+     * @param sorter the parallel context\n@@ -1508,0 +1505,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1509,48 +1507,1 @@\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<long[]> sorter, long[] a, int low, int high) {\n@@ -1558,3 +1509,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -1562,0 +1512,1 @@\n+        int count = 1;\n@@ -1563,2 +1514,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -1569,2 +1518,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -1572,1 +1520,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -1588,0 +1536,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -1591,0 +1545,1 @@\n+                \/\/ Check the next sequence\n@@ -1597,1 +1552,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -1600,1 +1555,0 @@\n-                if (k == high) {\n@@ -1602,0 +1556,1 @@\n+                if (k == high) {\n@@ -1603,1 +1558,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -1608,11 +1563,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -1621,3 +1566,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -1625,0 +1568,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -1626,2 +1570,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -1632,2 +1576,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -1639,0 +1582,1 @@\n+            }\n@@ -1640,1 +1584,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -1642,5 +1589,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -1648,1 +1595,0 @@\n-            run[count] = (last = k);\n@@ -1652,1 +1598,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -1657,3 +1603,1 @@\n-            if (sorter == null || (b = (long[]) sorter.b) == null) {\n-                b = new long[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -1661,0 +1605,2 @@\n+            } else if ((b = tryAllocate(long[].class, high - low)) == null) {\n+                return false;\n@@ -1662,1 +1608,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -1670,0 +1616,1 @@\n+     * @param sorter the parallel context\n@@ -1671,1 +1618,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -1673,2 +1620,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -1678,1 +1624,0 @@\n-     * @return the destination where runs are merged\n@@ -1680,2 +1625,2 @@\n-    private static long[] mergeRuns(long[] a, long[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<long[]> sorter, long[] a, long[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -1684,2 +1629,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1687,4 +1632,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -1694,1 +1636,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -1696,2 +1638,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -1700,1 +1642,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -1702,1 +1644,2 @@\n-        long[] a1, a2;\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -1704,8 +1647,2 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (long[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        long[] dst = aim ? a : b;\n+        long[] src = aim ? b : a;\n@@ -1713,1 +1650,5 @@\n-        long[] dst = a1 == a ? b : a;\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -1715,8 +1656,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n-\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -1724,1 +1662,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -1726,1 +1664,0 @@\n-        return dst;\n@@ -1730,1 +1667,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -1732,1 +1669,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -1735,1 +1672,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -1738,1 +1675,0 @@\n-     * @param a2 the second part\n@@ -1742,2 +1678,2 @@\n-    private static void mergeParts(Merger merger, long[] dst, int k,\n-            long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<long[]> merger, long[] dst, int k,\n+            long[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -1745,1 +1681,2 @@\n-        if (merger != null && a1 == a2) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n@@ -1747,1 +1684,4 @@\n-            while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n@@ -1750,1 +1690,1 @@\n-                 * The first part must be larger.\n+                 * Find the median of the larger part.\n@@ -1752,4 +1692,3 @@\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                long key = src[mi2];\n@@ -1758,1 +1697,1 @@\n-                 * Small parts will be merged sequentially.\n+                 * Split the smaller part.\n@@ -1760,2 +1699,8 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n@@ -1763,0 +1708,1 @@\n+            } else {\n@@ -1767,3 +1713,3 @@\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                long key = a1[mi1];\n-                int mi2 = hi2;\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                long key = src[mi1];\n@@ -1772,1 +1718,1 @@\n-                 * Partition the smaller part.\n+                 * Split the smaller part.\n@@ -1774,2 +1720,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n@@ -1777,2 +1723,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n@@ -1780,1 +1726,1 @@\n-                        mi2 = t;\n+                        mi2 = mid;\n@@ -1783,0 +1729,1 @@\n+            }\n@@ -1784,1 +1731,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -1786,4 +1736,4 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+            \/*\n+             * Skip the first parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -1791,5 +1741,61 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n+\n+        \/*\n+         * Merge the small parts sequentially.\n+         *\/\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(long[] dst, int k,\n+            long[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    long next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    long next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    long next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n@@ -1800,1 +1806,1 @@\n-         * Merge small parts sequentially.\n+         * Copy the tail of the left and right parts.\n@@ -1802,2 +1808,14 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(long[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n@@ -1805,4 +1823,4 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n+        while (--high > low) {\n+            long max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n@@ -1810,3 +1828,23 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -1815,0 +1853,1 @@\n+        a[p] = value;\n@@ -1817,1 +1856,1 @@\n-\/\/ [byte]\n+\/\/ #[byte]\n@@ -1820,2 +1859,1 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or insertion sort.\n+     * Sorts the specified range of the array using insertion sort or counting sort.\n@@ -1828,3 +1866,1 @@\n-        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n+        if (high - low < MAX_INSERTION_SORT_SIZE) {\n@@ -1832,0 +1868,2 @@\n+        } else {\n+            countingSort(a, low, high);\n@@ -1842,1 +1880,1 @@\n-    private static void insertionSort(byte[] a, int low, int high) {\n+    static void insertionSort(byte[] a, int low, int high) {\n@@ -1847,4 +1885,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -1855,10 +1894,0 @@\n-    \/**\n-     * The number of distinct byte values.\n-     *\/\n-    private static final int NUM_BYTE_VALUES = 1 << 8;\n-\n-    \/**\n-     * Max index of byte counter.\n-     *\/\n-    private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;\n-\n@@ -1872,2 +1901,5 @@\n-    private static void countingSort(byte[] a, int low, int high) {\n-        int[] count = new int[NUM_BYTE_VALUES];\n+    static void countingSort(byte[] a, int low, int high) {\n+        \/*\n+         * Count the number of all values.\n+         *\/\n+        int[] count = new int[1 << 8];\n@@ -1876,1 +1908,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram.\n@@ -1883,11 +1915,3 @@\n-        if (high - low > NUM_BYTE_VALUES) {\n-            for (int i = MAX_BYTE_INDEX; --i > Byte.MAX_VALUE; ) {\n-                int value = i & 0xFF;\n-\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (byte) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_BYTE_INDEX; high > low; ) {\n-                while (count[--i & 0xFF] == 0);\n+        for (int value = Byte.MIN_VALUE; high > low; ) {\n+            while (count[--value & 0xFF] == 0);\n+            int num = count[value & 0xFF];\n@@ -1895,7 +1919,3 @@\n-                int value = i & 0xFF;\n-                int c = count[value];\n-\n-                do {\n-                    a[--high] = (byte) value;\n-                } while (--c > 0);\n-            }\n+            do {\n+                a[--high] = (byte) value;\n+            } while (--num > 0);\n@@ -1905,1 +1925,1 @@\n-\/\/ [char]\n+\/\/ #[char]\n@@ -1908,2 +1928,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n@@ -1916,1 +1936,1 @@\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n@@ -1924,2 +1944,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1929,1 +1948,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1935,1 +1954,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1938,1 +1957,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -1946,2 +1965,3 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1949,10 +1969,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1967,1 +1978,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -1971,1 +1982,0 @@\n-            char a3 = a[e3];\n@@ -1974,1 +1984,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -1977,7 +1987,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -1985,9 +2006,3 @@\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    char t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -1995,1 +2010,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    char t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -1997,3 +2012,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    char t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2001,1 +2016,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    char t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2005,3 +2020,7 @@\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to counting sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                countingSort(a, low, high);\n+                return;\n+            }\n@@ -2010,1 +2029,7 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2014,7 +2039,1 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                char pivot1 = a[e1];\n-                char pivot2 = a[e5];\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n@@ -2023,5 +2042,2 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n@@ -2029,2 +2045,6 @@\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n@@ -2033,1 +2053,3 @@\n-                 * Skip elements, which are less or greater than the pivots.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2035,0 +2057,67 @@\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            char[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        char pivot1 = a[pivotIndex1];\n+        char pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            char ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2036,1 +2125,0 @@\n-                while (a[--upper] > pivot2);\n@@ -2038,39 +2126,3 @@\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n@@ -2078,0 +2130,12 @@\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -2079,5 +2143,5 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2085,6 +2149,2 @@\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n+        return new int[] { lower, upper };\n+    }\n@@ -2092,1 +2152,17 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            char[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n@@ -2094,5 +2170,5 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                char pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        char pivot = a[pivotIndex1];\n@@ -2100,8 +2176,8 @@\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -2109,37 +2185,17 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            char ak = a[k];\n@@ -2147,4 +2203,4 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2152,6 +2208,9 @@\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n+\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2159,1 +2218,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2161,0 +2219,7 @@\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n@@ -2170,1 +2235,1 @@\n-    private static void insertionSort(char[] a, int low, int high) {\n+    static void insertionSort(char[] a, int low, int high) {\n@@ -2175,4 +2240,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -2183,5 +2249,0 @@\n-    \/**\n-     * The number of distinct char values.\n-     *\/\n-    private static final int NUM_CHAR_VALUES = 1 << 16;\n-\n@@ -2195,2 +2256,2 @@\n-    private static void countingSort(char[] a, int low, int high) {\n-        int[] count = new int[NUM_CHAR_VALUES];\n+    static void countingSort(char[] a, int low, int high) {\n+        int size = high - low;\n@@ -2198,4 +2259,5 @@\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i]]);\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n@@ -2203,8 +2265,15 @@\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_CHAR_VALUES) {\n-            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n-                for (low = high - count[--i]; high > low;\n-                    a[--high] = (char) i\n-                );\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i]]);\n+\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = count.length; high > low; ) {\n+                while (count[--value] == 0);\n+                int num = count[value];\n+\n+                do {\n+                    a[--high] = (char) value;\n+                } while (--num > 0);\n@@ -2212,0 +2281,1 @@\n+\n@@ -2213,3 +2283,0 @@\n-            for (int i = NUM_CHAR_VALUES; high > low; ) {\n-                while (count[--i] == 0);\n-                int c = count[i];\n@@ -2217,3 +2284,51 @@\n-                do {\n-                    a[--high] = (char) i;\n-                } while (--c > 0);\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            char[] b = new char[size];\n+\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n+\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF)];\n+            }\n+\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF)]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF)] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n@@ -2224,1 +2339,1 @@\n-\/\/ [short]\n+\/\/ #[short]\n@@ -2227,2 +2342,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n@@ -2235,1 +2350,1 @@\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n@@ -2243,2 +2358,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2248,1 +2362,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2254,1 +2368,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2257,1 +2371,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -2265,2 +2379,3 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2268,10 +2383,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2286,1 +2392,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -2290,1 +2396,0 @@\n-            short a3 = a[e3];\n@@ -2293,1 +2398,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2296,7 +2401,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -2304,9 +2420,3 @@\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    short t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -2314,1 +2424,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    short t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -2316,3 +2426,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    short t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2320,1 +2430,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    short t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2324,3 +2434,7 @@\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to counting sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                countingSort(a, low, high);\n+                return;\n+            }\n@@ -2329,1 +2443,7 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2333,0 +2453,2 @@\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n+\n@@ -2334,3 +2456,2 @@\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n@@ -2338,2 +2459,6 @@\n-                short pivot1 = a[e1];\n-                short pivot2 = a[e5];\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n@@ -2342,5 +2467,3 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2348,2 +2471,65 @@\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            short[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        short pivot1 = a[pivotIndex1];\n+        short pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            short ak = a[k];\n@@ -2351,3 +2537,1 @@\n-                \/*\n-                 * Skip elements, which are less or greater than the pivots.\n-                 *\/\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2355,1 +2539,0 @@\n-                while (a[--upper] > pivot2);\n@@ -2357,39 +2540,9 @@\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n@@ -2397,0 +2550,6 @@\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -2398,5 +2557,5 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2404,6 +2563,2 @@\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n+        return new int[] { lower, upper };\n+    }\n@@ -2411,1 +2566,17 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            short[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n@@ -2413,5 +2584,5 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                short pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        short pivot = a[pivotIndex1];\n@@ -2419,8 +2590,8 @@\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -2428,37 +2599,17 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            short ak = a[k];\n@@ -2466,4 +2617,4 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2471,6 +2622,9 @@\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n+\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2478,1 +2632,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2480,0 +2633,7 @@\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n@@ -2489,1 +2649,1 @@\n-    private static void insertionSort(short[] a, int low, int high) {\n+    static void insertionSort(short[] a, int low, int high) {\n@@ -2494,4 +2654,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -2502,10 +2663,0 @@\n-    \/**\n-     * The number of distinct short values.\n-     *\/\n-    private static final int NUM_SHORT_VALUES = 1 << 16;\n-\n-    \/**\n-     * Max index of short counter.\n-     *\/\n-    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n-\n@@ -2519,2 +2670,2 @@\n-    private static void countingSort(short[] a, int low, int high) {\n-        int[] count = new int[NUM_SHORT_VALUES];\n+    static void countingSort(short[] a, int low, int high) {\n+        int size = high - low;\n@@ -2522,4 +2673,5 @@\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n@@ -2527,6 +2679,11 @@\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_SHORT_VALUES) {\n-            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n-                int value = i & 0xFFFF;\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n+\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = Short.MIN_VALUE; high > low; ) {\n+                while (count[--value & 0xFFFF] == 0);\n+                int num = count[value & 0xFFFF];\n@@ -2534,3 +2691,3 @@\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (short) value\n-                );\n+                do {\n+                    a[--high] = (short) value;\n+                } while (--num > 0);\n@@ -2538,0 +2695,1 @@\n+\n@@ -2539,2 +2697,0 @@\n-            for (int i = MAX_SHORT_INDEX; high > low; ) {\n-                while (count[--i & 0xFFFF] == 0);\n@@ -2542,2 +2698,4 @@\n-                int value = i & 0xFFFF;\n-                int c = count[value];\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            short[] b = new short[size];\n@@ -2545,3 +2703,46 @@\n-                do {\n-                    a[--high] = (short) value;\n-                } while (--c > 0);\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n+\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF) ^ 0x80]; \/\/ Flip the sign bit\n+            }\n+\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF) ^ 0x80]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF) ^ 0x80] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n@@ -2552,1 +2753,6 @@\n-\/\/ [float]\n+\/\/ #[float]\n+\n+    \/**\n+     * The binary representation of float negative zero.\n+     *\/\n+    private static final int FLOAT_NEGATIVE_ZERO = Float.floatToRawIntBits(-0.0f);\n@@ -2556,1 +2762,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -2571,1 +2777,1 @@\n-         * Phase 1. Count the number of negative zero -0.0f,\n+         * Phase 1. Count the number of negative zero -0.0,\n@@ -2575,1 +2781,1 @@\n-        int numNegativeZero = 0;\n+        int negativeZeroCount = 0;\n@@ -2580,2 +2786,2 @@\n-            if (ak == 0.0f && Float.floatToRawIntBits(ak) < 0) { \/\/ ak is -0.0f\n-                numNegativeZero += 1;\n+            if (Float.floatToRawIntBits(ak) == FLOAT_NEGATIVE_ZERO) { \/\/ ak is -0.0\n+                negativeZeroCount++;\n@@ -2583,1 +2789,1 @@\n-            } else if (ak != ak) { \/\/ ak is NaN\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n@@ -2593,6 +2799,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            float[] b = depth == 0 ? null : new float[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -2604,2 +2806,2 @@\n-         * Phase 3. Turn positive zero 0.0f\n-         * back into negative zero -0.0f.\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0 back into negative zeros -0.0.\n@@ -2607,1 +2809,1 @@\n-        if (++numNegativeZero == 1) {\n+        if (++negativeZeroCount == 1) {\n@@ -2616,1 +2818,1 @@\n-            int middle = (low + high) >>> 1;\n+            int mid = (low + high) >>> 1;\n@@ -2618,2 +2820,2 @@\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n+            if (a[mid] < 0.0f) {\n+                low = mid + 1;\n@@ -2621,1 +2823,1 @@\n-                high = middle - 1;\n+                high = mid - 1;\n@@ -2626,1 +2828,1 @@\n-         * Replace the required number of 0.0f by -0.0f.\n+         * Replace 0.0 by negative zeros -0.0.\n@@ -2628,1 +2830,1 @@\n-        while (--numNegativeZero > 0) {\n+        while (--negativeZeroCount > 0) {\n@@ -2634,2 +2836,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2637,1 +2838,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -2640,1 +2841,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2644,1 +2845,1 @@\n-    static void sort(Sorter sorter, float[] a, int bits, int low, int high) {\n+    static void sort(Sorter<float[]> sorter, float[] a, int bits, int low, int high) {\n@@ -2646,9 +2847,1 @@\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -2657,1 +2850,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -2659,2 +2852,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -2665,2 +2859,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -2668,2 +2861,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -2674,2 +2868,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -2677,2 +2870,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -2683,2 +2876,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2686,1 +2880,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2695,1 +2889,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -2699,1 +2893,0 @@\n-            float a3 = a[e3];\n@@ -2702,1 +2895,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2705,7 +2898,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -2713,9 +2917,3 @@\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    float t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -2723,1 +2921,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    float t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -2725,3 +2923,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    float t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2729,1 +2927,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    float t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2733,3 +2931,13 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -2738,1 +2946,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2742,8 +2950,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -2754,3 +2957,3 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -2758,2 +2961,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -2762,1 +2965,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -2764,7 +2970,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -2776,2 +2975,2 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -2779,1 +2978,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -2782,1 +2981,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -2787,1 +2986,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -2789,1 +2988,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2794,1 +2993,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -2796,3 +2995,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -2800,1 +3002,0 @@\n-        int upper = end;\n@@ -2802,4 +3003,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        float pivot1 = a[e1];\n-        float pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        float pivot1 = a[pivotIndex1];\n+        float pivot2 = a[pivotIndex2];\n@@ -2814,2 +3018,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -2826,13 +3030,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -2841,0 +3039,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2845,12 +3045,6 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n@@ -2858,1 +3052,8 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2867,2 +3068,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2870,1 +3071,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -2874,1 +3075,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -2876,1 +3077,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2879,3 +3080,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -2883,3 +3084,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -2887,1 +3091,0 @@\n-        int upper = end;\n@@ -2889,2 +3092,5 @@\n-        int e3 = pivotIndex1;\n-        float pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        float pivot = a[pivotIndex1];\n@@ -2899,1 +3105,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -2902,11 +3108,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n+         * Dutch National Flag partitioning\n@@ -2914,3 +3110,7 @@\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -2919,0 +3119,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2920,1 +3122,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -2923,2 +3125,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2926,2 +3130,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -2929,6 +3133,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -2936,0 +3136,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2943,1 +3146,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -2947,1 +3151,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -2949,2 +3153,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -2962,10 +3166,5 @@\n-    private static void mixedInsertionSort(float[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n-\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n-                float ai = a[i = low];\n+    static void mixedInsertionSort(float[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n@@ -2973,6 +3172,5 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            float ai = a[i = low], pin = a[--p];\n@@ -2981,7 +3179,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -2989,40 +3181,3 @@\n-            float pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -3032,1 +3187,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -3034,32 +3189,2 @@\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n-\n-                } else if (a1 < a[i - 1]) {\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n-                }\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n@@ -3067,0 +3192,1 @@\n+            a[i] = ai;\n@@ -3068,1 +3194,0 @@\n-    }\n@@ -3070,10 +3195,5 @@\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(float[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            float ai = a[i = k];\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            float a1 = a[i = low], a2 = a[++low];\n@@ -3081,3 +3201,9 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -3085,4 +3211,1 @@\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n+                a[++i + 1] = a1;\n@@ -3090,15 +3213,17 @@\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n+\n+            } else if (a1 < a[i - 1]) {\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n@@ -3109,1 +3234,1 @@\n-     * Pushes specified element down during heap sort.\n+     * Sorts the specified range of the array using insertion sort.\n@@ -3111,3 +3236,1 @@\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n+     * @param a the array to be sorted\n@@ -3117,3 +3240,3 @@\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+    static void insertionSort(float[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            float ai = a[i = k];\n@@ -3121,8 +3244,6 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+            if (ai < a[i - 1]) {\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -3131,1 +3252,0 @@\n-        a[p] = value;\n@@ -3135,1 +3255,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3137,1 +3257,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -3139,3 +3259,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3143,2 +3263,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<float[]> sorter, float[] a, int low, int high) {\n@@ -3146,3 +3265,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -3150,0 +3268,1 @@\n+        int count = 1;\n@@ -3151,2 +3270,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -3157,2 +3274,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -3160,1 +3276,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -3176,0 +3292,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -3179,0 +3301,1 @@\n+                \/\/ Check the next sequence\n@@ -3185,1 +3308,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -3188,1 +3311,0 @@\n-                if (k == high) {\n@@ -3190,0 +3312,1 @@\n+                if (k == high) {\n@@ -3191,1 +3314,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -3196,11 +3319,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -3209,3 +3322,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -3213,0 +3324,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -3214,2 +3326,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -3220,2 +3332,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -3227,0 +3338,1 @@\n+            }\n@@ -3228,1 +3340,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -3230,5 +3345,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -3236,1 +3351,0 @@\n-            run[count] = (last = k);\n@@ -3240,1 +3354,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -3245,3 +3359,1 @@\n-            if (sorter == null || (b = (float[]) sorter.b) == null) {\n-                b = new float[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -3249,0 +3361,2 @@\n+            } else if ((b = tryAllocate(float[].class, high - low)) == null) {\n+                return false;\n@@ -3250,1 +3364,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -3258,0 +3372,1 @@\n+     * @param sorter the parallel context\n@@ -3259,1 +3374,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -3261,2 +3376,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -3266,1 +3380,0 @@\n-     * @return the destination where runs are merged\n@@ -3268,2 +3381,2 @@\n-    private static float[] mergeRuns(float[] a, float[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<float[]> sorter, float[] a, float[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -3272,2 +3385,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3275,4 +3388,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -3282,1 +3392,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -3284,2 +3394,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -3288,1 +3398,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -3290,10 +3400,2 @@\n-        float[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (float[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -3301,1 +3403,2 @@\n-        float[] dst = a1 == a ? b : a;\n+        float[] dst = aim ? a : b;\n+        float[] src = aim ? b : a;\n@@ -3303,5 +3406,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -3309,2 +3412,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -3312,1 +3418,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -3314,1 +3420,0 @@\n-        return dst;\n@@ -3318,1 +3423,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -3320,1 +3425,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -3323,1 +3428,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -3326,1 +3431,0 @@\n-     * @param a2 the second part\n@@ -3330,2 +3434,2 @@\n-    private static void mergeParts(Merger merger, float[] dst, int k,\n-            float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<float[]> merger, float[] dst, int k,\n+            float[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -3333,1 +3437,2 @@\n-        if (merger != null && a1 == a2) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n@@ -3335,1 +3440,4 @@\n-            while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n@@ -3338,1 +3446,1 @@\n-                 * The first part must be larger.\n+                 * Find the median of the larger part.\n@@ -3340,4 +3448,3 @@\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                float key = src[mi2];\n@@ -3346,1 +3453,1 @@\n-                 * Small parts will be merged sequentially.\n+                 * Split the smaller part.\n@@ -3348,2 +3455,8 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n@@ -3351,0 +3464,1 @@\n+            } else {\n@@ -3355,3 +3469,3 @@\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                float key = a1[mi1];\n-                int mi2 = hi2;\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                float key = src[mi1];\n@@ -3360,1 +3474,1 @@\n-                 * Partition the smaller part.\n+                 * Split the smaller part.\n@@ -3362,2 +3476,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n@@ -3365,2 +3479,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n@@ -3368,1 +3482,1 @@\n-                        mi2 = t;\n+                        mi2 = mid;\n@@ -3371,0 +3485,1 @@\n+            }\n@@ -3372,1 +3487,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -3374,4 +3492,4 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+            \/*\n+             * Skip the first parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -3379,5 +3497,61 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n+\n+        \/*\n+         * Merge the small parts sequentially.\n+         *\/\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(float[] dst, int k,\n+            float[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    float next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    float next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    float next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n@@ -3388,1 +3562,1 @@\n-         * Merge small parts sequentially.\n+         * Copy the tail of the left and right parts.\n@@ -3390,2 +3564,14 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(float[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n@@ -3393,4 +3579,4 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n+        while (--high > low) {\n+            float max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n@@ -3398,3 +3584,23 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -3403,0 +3609,1 @@\n+        a[p] = value;\n@@ -3405,1 +3612,6 @@\n-\/\/ [double]\n+\/\/ #[double]\n+\n+    \/**\n+     * The binary representation of double negative zero.\n+     *\/\n+    private static final long DOUBLE_NEGATIVE_ZERO = Double.doubleToRawLongBits(-0.0d);\n@@ -3409,1 +3621,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -3424,1 +3636,1 @@\n-         * Phase 1. Count the number of negative zero -0.0d,\n+         * Phase 1. Count the number of negative zero -0.0,\n@@ -3428,1 +3640,1 @@\n-        int numNegativeZero = 0;\n+        int negativeZeroCount = 0;\n@@ -3433,2 +3645,2 @@\n-            if (ak == 0.0d && Double.doubleToRawLongBits(ak) < 0) { \/\/ ak is -0.0d\n-                numNegativeZero += 1;\n+            if (Double.doubleToRawLongBits(ak) == DOUBLE_NEGATIVE_ZERO) { \/\/ ak is -0.0\n+                negativeZeroCount++;\n@@ -3436,1 +3648,1 @@\n-            } else if (ak != ak) { \/\/ ak is NaN\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n@@ -3446,6 +3658,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            double[] b = depth == 0 ? null : new double[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -3457,2 +3665,2 @@\n-         * Phase 3. Turn positive zero 0.0d\n-         * back into negative zero -0.0d.\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0 back into negative zeros -0.0.\n@@ -3460,1 +3668,1 @@\n-        if (++numNegativeZero == 1) {\n+        if (++negativeZeroCount == 1) {\n@@ -3469,1 +3677,1 @@\n-            int middle = (low + high) >>> 1;\n+            int mid = (low + high) >>> 1;\n@@ -3471,2 +3679,2 @@\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n+            if (a[mid] < 0.0d) {\n+                low = mid + 1;\n@@ -3474,1 +3682,1 @@\n-                high = middle - 1;\n+                high = mid - 1;\n@@ -3479,1 +3687,1 @@\n-         * Replace the required number of 0.0d by -0.0d.\n+         * Replace 0.0 by negative zeros -0.0.\n@@ -3481,1 +3689,1 @@\n-        while (--numNegativeZero > 0) {\n+        while (--negativeZeroCount > 0) {\n@@ -3487,2 +3695,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -3490,1 +3697,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -3493,1 +3700,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -3497,1 +3704,1 @@\n-    static void sort(Sorter sorter, double[] a, int bits, int low, int high) {\n+    static void sort(Sorter<double[]> sorter, double[] a, int bits, int low, int high) {\n@@ -3499,8 +3706,1 @@\n-            int end = high - 1, size = high - low;\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -3509,1 +3709,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -3511,2 +3711,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -3517,2 +3718,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -3520,2 +3720,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -3526,2 +3727,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -3529,2 +3729,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -3535,2 +3735,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -3538,1 +3739,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -3547,1 +3748,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -3551,1 +3752,0 @@\n-            double a3 = a[e3];\n@@ -3554,1 +3754,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -3557,7 +3757,9 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -3565,9 +3767,12 @@\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    double t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -3575,1 +3780,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    double t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -3577,3 +3782,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    double t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -3581,1 +3786,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    double t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -3585,3 +3790,13 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -3590,1 +3805,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -3594,8 +3809,3 @@\n-                \/*\n-                * Use the first and fifth of the five sorted elements as\n-                * the pivots. These values are inexpensive approximation\n-                * of tertiles. Note, that pivot1 < pivot2.\n-                *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -3606,3 +3816,3 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -3610,2 +3820,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -3614,1 +3824,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -3616,7 +3826,2 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -3629,2 +3834,2 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -3632,1 +3837,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -3635,1 +3840,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -3640,1 +3845,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -3642,1 +3847,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3647,1 +3852,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -3649,3 +3854,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -3653,1 +3861,0 @@\n-        int upper = end;\n@@ -3655,4 +3862,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        double pivot1 = a[e1];\n-        double pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        double pivot1 = a[pivotIndex1];\n+        double pivot2 = a[pivotIndex2];\n@@ -3661,8 +3871,8 @@\n-        * The first and the last elements to be sorted are moved\n-        * to the locations formerly occupied by the pivots. When\n-        * partitioning is completed, the pivots are swapped back\n-        * into their final positions, and excluded from the next\n-        * subsequent sorting.\n-        *\/\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -3671,2 +3881,2 @@\n-        * Skip elements, which are less or greater than the pivots.\n-        *\/\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n@@ -3679,13 +3889,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -3694,0 +3898,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3698,12 +3904,12 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n@@ -3711,1 +3917,2 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -3720,2 +3927,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -3723,1 +3930,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -3727,1 +3934,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -3729,1 +3936,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3732,2 +3939,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -3735,4 +3943,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -3740,1 +3950,0 @@\n-        int upper = end;\n@@ -3742,2 +3951,5 @@\n-        int e3 = pivotIndex1;\n-        double pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        double pivot = a[pivotIndex1];\n@@ -3746,7 +3958,7 @@\n-        * The first element to be sorted is moved to the\n-        * location formerly occupied by the pivot. After\n-        * completion of partitioning the pivot is swapped\n-        * back into its final position, and excluded from\n-        * the next subsequent sorting.\n-        *\/\n-        a[e3] = a[lower];\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -3755,9 +3967,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n+         * Dutch National Flag partitioning\n@@ -3765,5 +3969,7 @@\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -3772,0 +3978,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3773,1 +3981,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -3776,2 +3984,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -3779,2 +3989,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -3782,6 +3992,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -3789,0 +3995,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -3796,1 +4005,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -3800,1 +4010,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -3802,2 +4012,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -3812,53 +4022,8 @@\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void mixedInsertionSort(double[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n-\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n-\n-            \/*\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n-             *\/\n-            double pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void mixedInsertionSort(double[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n@@ -3866,7 +4031,5 @@\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            double ai = a[i = low], pin = a[--p];\n@@ -3874,8 +4037,6 @@\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -3885,1 +4046,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -3887,2 +4048,5 @@\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -3890,6 +4054,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            double a1 = a[i = low], a2 = a[++low];\n@@ -3897,4 +4060,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -3902,4 +4067,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3907,1 +4072,4 @@\n-                } else if (a1 < a[i - 1]) {\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3909,4 +4077,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -3914,4 +4079,7 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3919,0 +4087,1 @@\n+                a[i + 1] = a1;\n@@ -3930,1 +4099,1 @@\n-    private static void insertionSort(double[] a, int low, int high) {\n+    static void insertionSort(double[] a, int low, int high) {\n@@ -3935,4 +4104,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -3944,1 +4114,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3946,0 +4116,1 @@\n+     * @param sorter the parallel context\n@@ -3949,0 +4120,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3950,48 +4122,1 @@\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<double[]> sorter, double[] a, int low, int high) {\n@@ -3999,3 +4124,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -4003,0 +4127,1 @@\n+        int count = 1;\n@@ -4004,2 +4129,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -4010,2 +4133,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -4013,1 +4135,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -4029,0 +4151,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -4032,0 +4160,1 @@\n+                \/\/ Check the next sequence\n@@ -4038,1 +4167,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -4041,1 +4170,0 @@\n-                if (k == high) {\n@@ -4043,0 +4171,1 @@\n+                if (k == high) {\n@@ -4044,1 +4173,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -4049,11 +4178,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -4062,3 +4181,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -4066,0 +4183,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -4067,2 +4185,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -4073,2 +4191,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -4080,0 +4197,1 @@\n+            }\n@@ -4081,1 +4199,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -4083,5 +4204,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -4089,1 +4210,0 @@\n-            run[count] = (last = k);\n@@ -4093,1 +4213,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -4098,3 +4218,1 @@\n-            if (sorter == null || (b = (double[]) sorter.b) == null) {\n-                b = new double[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -4102,0 +4220,2 @@\n+            } else if ((b = tryAllocate(double[].class, high - low)) == null) {\n+                return false;\n@@ -4103,1 +4223,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -4111,0 +4231,1 @@\n+     * @param sorter the parallel context\n@@ -4112,1 +4233,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -4114,2 +4235,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -4119,1 +4239,0 @@\n-     * @return the destination where runs are merged\n@@ -4121,2 +4240,2 @@\n-    private static double[] mergeRuns(double[] a, double[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<double[]> sorter, double[] a, double[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -4125,2 +4244,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -4128,4 +4247,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -4135,1 +4251,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -4137,2 +4253,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -4141,1 +4257,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -4143,10 +4259,2 @@\n-        double[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (double[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -4154,1 +4262,2 @@\n-        double[] dst = a1 == a ? b : a;\n+        double[] dst = aim ? a : b;\n+        double[] src = aim ? b : a;\n@@ -4156,5 +4265,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -4162,2 +4271,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -4165,1 +4277,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -4167,1 +4279,0 @@\n-        return dst;\n@@ -4171,1 +4282,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -4173,1 +4284,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -4176,1 +4287,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -4179,1 +4290,0 @@\n-     * @param a2 the second part\n@@ -4183,2 +4293,2 @@\n-    private static void mergeParts(Merger merger, double[] dst, int k,\n-            double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<double[]> merger, double[] dst, int k,\n+            double[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -4186,1 +4296,2 @@\n-        if (merger != null && a1 == a2) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n@@ -4188,1 +4299,4 @@\n-            while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n@@ -4191,1 +4305,1 @@\n-                 * The first part must be larger.\n+                 * Find the median of the larger part.\n@@ -4193,4 +4307,3 @@\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                double key = src[mi2];\n@@ -4199,1 +4312,1 @@\n-                 * Small parts will be merged sequentially.\n+                 * Split the smaller part.\n@@ -4201,2 +4314,8 @@\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n@@ -4204,0 +4323,1 @@\n+            } else {\n@@ -4208,3 +4328,3 @@\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                double key = a1[mi1];\n-                int mi2 = hi2;\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                double key = src[mi1];\n@@ -4213,1 +4333,1 @@\n-                 * Partition the smaller part.\n+                 * Split the smaller part.\n@@ -4215,2 +4335,2 @@\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n@@ -4218,2 +4338,2 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n@@ -4221,1 +4341,1 @@\n-                        mi2 = t;\n+                        mi2 = mid;\n@@ -4224,0 +4344,6 @@\n+            }\n+\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -4225,1 +4351,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+            \/*\n+             * Skip the first parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -4227,4 +4356,6 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n@@ -4232,5 +4363,54 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+        \/*\n+         * Merge the small parts sequentially.\n+         *\/\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(double[] dst, int k,\n+            double[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    double next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    double next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    double next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n@@ -4241,1 +4421,1 @@\n-         * Merge small parts sequentially.\n+         * Copy the tail of the left and right parts.\n@@ -4243,2 +4423,19 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(double[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            double max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n@@ -4246,3 +4443,23 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -4251,3 +4468,21 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == 0) {\n+                continue;\n+            }\n+            if (c == total) {\n+                return false;\n@@ -4255,0 +4490,10 @@\n+            break;\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n@@ -4256,0 +4501,1 @@\n+        return true;\n@@ -4258,1 +4504,1 @@\n-\/\/ [class]\n+\/\/ #[class]\n@@ -4261,1 +4507,3 @@\n-     * This class implements parallel sorting.\n+     * Implementation of parallel sorting.\n+     *\n+     * @param <T> the class of array\n@@ -4263,2 +4511,5 @@\n-    private static final class Sorter extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4266,1 +4517,1 @@\n-        private final Object a, b;\n+        private final T a, b;\n@@ -4269,0 +4520,10 @@\n+        @SuppressWarnings(\"unchecked\")\n+        private Sorter(T a, int parallelism, int low, int size) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+            this.b = (T) tryAllocate(a.getClass(), size);\n+            this.depth = b == null ? 0 : ((parallelism >> 7) + 2) * (-2);\n+        }\n+\n@@ -4270,1 +4531,1 @@\n-                Object a, Object b, int low, int size, int offset, int depth) {\n+                T a, T b, int low, int size, int offset, int depth) {\n@@ -4281,1 +4542,2 @@\n-        public final void compute() {\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n@@ -4285,2 +4547,2 @@\n-                new Sorter(this, b, a, low, half, offset, depth + 1).fork();\n-                new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\n@@ -4288,11 +4550,6 @@\n-                if (a instanceof int[]) {\n-                    sort(this, (int[]) a, depth, low, low + size);\n-                } else if (a instanceof long[]) {\n-                    sort(this, (long[]) a, depth, low, low + size);\n-                } else if (a instanceof float[]) {\n-                    sort(this, (float[]) a, depth, low, low + size);\n-                } else if (a instanceof double[]) {\n-                    sort(this, (double[]) a, depth, low, low + size);\n-                } else {\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n+                switch(a) {\n+                    case int[] ai -> sort((Sorter<int[]>) this, ai, depth, low, low + size);\n+                    case long[] al -> sort((Sorter<long[]>) this, al, depth, low, low + size);\n+                    case float[] af -> sort((Sorter<float[]>) this, af, depth, low, low + size);\n+                    case double[] ad -> sort((Sorter<double[]>) this, ad, depth, low, low + size);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4305,1 +4562,1 @@\n-        public final void onCompletion(CountedCompleter<?> caller) {\n+        public void onCompletion(CountedCompleter<?> caller) {\n@@ -4310,1 +4567,1 @@\n-                new Merger(null,\n+                new Merger<>(null,\n@@ -4316,1 +4573,0 @@\n-                    b,\n@@ -4323,4 +4579,13 @@\n-        private void forkSorter(int depth, int low, int high) {\n-            addToPendingCount(1);\n-            Object a = this.a; \/\/ Use local variable for performance\n-            new Sorter(this, a, b, low, high - low, offset, depth).fork();\n+        private void fork(int depth, int low, int high) {\n+            if (high - low < MIN_PARALLEL_SORT_SIZE) {\n+                switch(a) {\n+                    case int[] ai -> sort(null, ai, depth, low, high);\n+                    case long[] al -> sort(null, al, depth, low, high);\n+                    case float[] af -> sort(null, af, depth, low, high);\n+                    case double[] ad -> sort(null, ad, depth, low, high);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+                }\n+            } else {\n+                addToPendingCount(1);\n+                new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+            }\n@@ -4331,1 +4596,3 @@\n-     * This class implements parallel merging.\n+     * Implementation of parallel merging.\n+     *\n+     * @param <T> the class of array\n@@ -4333,2 +4600,5 @@\n-    private static final class Merger extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n+    private static final class Merger<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4336,1 +4606,1 @@\n-        private final Object dst, a1, a2;\n+        private final T dst, src;\n@@ -4339,2 +4609,2 @@\n-        private Merger(CountedCompleter<?> parent, Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\n+                T src, int lo1, int hi1, int lo2, int hi2) {\n@@ -4344,1 +4614,1 @@\n-            this.a1 = a1;\n+            this.src = src;\n@@ -4347,1 +4617,0 @@\n-            this.a2 = a2;\n@@ -4353,16 +4622,8 @@\n-        public final void compute() {\n-            if (dst instanceof int[]) {\n-                mergeParts(this, (int[]) dst, k,\n-                    (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);\n-            } else if (dst instanceof long[]) {\n-                mergeParts(this, (long[]) dst, k,\n-                    (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);\n-            } else if (dst instanceof float[]) {\n-                mergeParts(this, (float[]) dst, k,\n-                    (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);\n-            } else if (dst instanceof double[]) {\n-                mergeParts(this, (double[]) dst, k,\n-                    (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);\n-            } else {\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            switch(dst) {\n+                case int[] di -> mergeParts((Merger<int[]>) this, di, k, (int[]) src, lo1, hi1, lo2, hi2);\n+                case long[] dl -> mergeParts((Merger<long[]>) this, dl, k, (long[]) src, lo1, hi1, lo2, hi2);\n+                case float[] df -> mergeParts((Merger<float[]>) this, df, k, (float[]) src, lo1, hi1, lo2, hi2);\n+                case double[] dd -> mergeParts((Merger<double[]>) this, dd, k, (double[]) src, lo1, hi1, lo2, hi2);\n+                default -> throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n@@ -4373,2 +4634,1 @@\n-        private void forkMerger(Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\n@@ -4376,1 +4636,1 @@\n-            new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();\n+            new Merger<>(this, dst, k, src, lo1, hi1, lo2, hi2).fork();\n@@ -4381,1 +4641,7 @@\n-     * This class implements parallel merging of runs.\n+     * Tries to allocate additional buffer.\n+     *\n+     * @param <T> the class of array\n+     * @param clazz the given array class\n+     * @param length the length of additional buffer\n+     * @return {@code null} if requested buffer is too big or there is no enough memory,\n+     *         otherwise created buffer\n@@ -4383,44 +4649,9 @@\n-    private static final class RunMerger extends RecursiveTask<Object> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int[] run;\n-        private final int offset, aim, lo, hi;\n-\n-        private RunMerger(Object a, Object b, int offset,\n-                int aim, int[] run, int lo, int hi) {\n-            this.a = a;\n-            this.b = b;\n-            this.offset = offset;\n-            this.aim = aim;\n-            this.run = run;\n-            this.lo = lo;\n-            this.hi = hi;\n-        }\n-\n-        @Override\n-        protected final Object compute() {\n-            if (a instanceof int[]) {\n-                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof long[]) {\n-                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof float[]) {\n-                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof double[]) {\n-                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n-        }\n-\n-        private RunMerger forkMe() {\n-            fork();\n-            return this;\n-        }\n-\n-        private Object getDestination() {\n-            join();\n-            return getRawResult();\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T tryAllocate(Class<T> clazz, int length) {\n+        try {\n+            int maxLength = MAX_BUFFER_SIZE >>\n+                (clazz == int[].class || clazz == float[].class ? 2 : 3);\n+            return length > maxLength ? null :\n+                (T) U.allocateUninitializedArray(clazz.componentType(), length);\n+        } catch (OutOfMemoryError e) {\n+            return null;\n@@ -4429,0 +4660,2 @@\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":2689,"deletions":2456,"binary":false,"changes":5145,"status":"modified"},{"patch":"@@ -0,0 +1,1627 @@\n+#if[Common1]\n+\/*\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+package java.util;\n+\n+import java.util.concurrent.CountedCompleter;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/**\n+ * This class implements powerful and fully optimized versions, both\n+ * sequential and parallel, of the Dual-Pivot Quicksort algorithm by\n+ * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n+ * offers O(n log(n)) performance on all data sets, and is typically\n+ * faster than traditional (one-pivot) Quicksort implementations.<p>\n+ *\n+ * There are also additional algorithms, invoked from the Dual-Pivot\n+ * Quicksort such as merging sort, sorting network, heap sort, mixed\n+ * insertion sort, counting sort and parallel merge sort. The actual\n+ * sorting algorithm depends on the data type and array size.\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ * @author Jon Bentley\n+ * @author Josh Bloch\n+ * @author Doug Lea\n+ *\n+ * @version 2024.06.14\n+ *\n+ * @since 1.7 * 14 ^ 26\n+ *\/\n+final class DualPivotQuicksort {\n+\n+    \/**\n+     * <b>High-level description of sorting logic.<\/b><p>\n+     *\n+     * <b>Type: int\/long\/float\/double<\/b><p>\n+     *\n+     * If the array size is small, invoke mixed insertion sort on\n+     * non-leftmost parts or insertion sort on leftmost part.<p>\n+     *\n+     * Then try merging sort which is the best on almost\n+     * sorted arrays.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with heap sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Type: float\/double<\/b><p>\n+     *\n+     * Floating-point values require additional steps to process\n+     * negative zeros -0.0 and NaNs (Not-a-Number) and re-arrange\n+     * negative zeros at the end.<p>\n+     *\n+     * <b>Type: byte<\/b><p>\n+     *\n+     * Invoke insertion sort, if the array size is small,\n+     * otherwise switch to counting sort.<p>\n+     *\n+     * <b>Type: char\/short<\/b><p>\n+     *\n+     * Invoke counting sort on large array, otherwise run\n+     * insertion sort on small array.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with counting sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+     *\n+     * If the array size is small, sequential sort is run.\n+     * Otherwise invoke parallel merge sort (the recursion depth\n+     * depends on parallelism level), then run parallel Quicksort.\n+     *\/\n+    private DualPivotQuicksort() {}\n+\n+    \/* ----------------------- Insertion sort ----------------------- *\/\n+\n+    \/**\n+     * Max size of array to use insertion sort (the best on shuffle data).\n+     *\/\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n+\n+    \/* ------------------------ Merging sort ------------------------ *\/\n+\n+    \/**\n+     * Min size of array to use merging sort (the best on stagger data).\n+     *\/\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n+\n+    \/**\n+     * Min size of run to continue scanning (the best on stagger data).\n+     *\/\n+    private static final int MIN_RUN_SIZE = 64;\n+\n+    \/**\n+     * Max capacity of the index array to track the runs.\n+     *\/\n+    private static final int MAX_RUN_CAPACITY = 10 << 10;\n+\n+    \/* ------------------------ Digital sort ------------------------ *\/\n+\n+    \/**\n+     * Min size of array to use counting sort (the best on random data).\n+     *\/\n+    private static final int MIN_COUNTING_SORT_SIZE = 640;\n+\n+    \/**\n+     * Min size of array to use numerical sort (the best on repeated data).\n+     *\/\n+    private static final int MIN_NUMERICAL_SORT_SIZE = 9 << 10;\n+\n+    \/* ----------------------- Parallel sort ------------------------ *\/\n+\n+    \/**\n+     * Min size of array to perform sorting in parallel (the best on stagger data).\n+     *\/\n+    private static final int MIN_PARALLEL_SORT_SIZE = 3 << 10;\n+\n+    \/* ----------------------- Infrastructure ----------------------- *\/\n+\n+    \/**\n+     * Max recursive depth before switching to heap sort.\n+     *\/\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n+\n+    \/**\n+     * Max size of additional buffer in bytes,\n+     *      limited by max_heap \/ 16 or 2 GB max.\n+     *\/\n+    private static final int MAX_BUFFER_SIZE =\n+        Math.clamp(Runtime.getRuntime().maxMemory() >>> 4, 0, Integer.MAX_VALUE);\n+\n+    \/**\n+     * Represents a function that accepts the array and sorts\n+     * the specified range of the array into ascending order.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    @FunctionalInterface\n+    private interface SortOperation<T> {\n+        \/**\n+         * Sorts the specified range of the array.\n+         *\n+         * @param a the array to be sorted\n+         * @param low the index of the first element, inclusive, to be sorted\n+         * @param high the index of the last element, exclusive, to be sorted\n+         *\/\n+        void sort(T a, int low, int high);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array into ascending numerical order.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n+     *\n+     * @param <T> the class of array\n+     * @param elemType the class of the elements of the array to be sorted\n+     * @param a the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param so the method reference for the fallback implementation\n+     *\/\n+    @ForceInline\n+    @IntrinsicCandidate\n+    private static <T> void sort(Class<?> elemType, T a, long offset,\n+            int low, int high, SortOperation<T> so) {\n+        so.sort(a, low, high);\n+    }\n+\n+    \/**\n+     * Represents a function that accepts the array and partitions\n+     * the specified range of the array using the given pivots.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    @FunctionalInterface\n+    private interface PartitionOperation<T> {\n+        \/**\n+         * Partitions the specified range of the array using the given pivots.\n+         *\n+         * @param a the array for partitioning\n+         * @param low the index of the first element, inclusive, for partitioning\n+         * @param high the index of the last element, exclusive, for partitioning\n+         * @param pivotIndex1 the index of pivot1, the first pivot\n+         * @param pivotIndex2 the index of pivot2, the second pivot\n+         * @return indices of parts after partitioning\n+         *\/\n+        int[] partition(T a, int low, int high, int pivotIndex1, int pivotIndex2);\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using the given pivots.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n+     *\n+     * @param <T> the class of array\n+     * @param elemType the class of the array for partitioning\n+     * @param a the array for partitioning\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @param po the method reference for the fallback implementation\n+     * @return indices of parts after partitioning\n+     *\/\n+    @ForceInline\n+    @IntrinsicCandidate\n+    private static <T> int[] partition(Class<?> elemType, T a, long offset,\n+            int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<T> po) {\n+        return po.partition(a, low, high, pivotIndex1, pivotIndex2);\n+    }\n+#end[Common1]\n+#if[AllTypes]\n+\n+\/\/ #[$type$]\n+#end[AllTypes]\n+#if[IntLong]\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int parallelism, int low, int high) {\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n+        } else {\n+            sort(null, a, 0, low, high);\n+        }\n+    }\n+#end[IntLong]\n+#if[FloatDouble]\n+\n+    \/**\n+     * The binary representation of $type$ negative zero.\n+     *\/\n+    private static final {#if[Float]?int}{#if[Double]?long} $TYPE$_NEGATIVE_ZERO = {#if[Float]?Float.floatToRawIntBits(-0.0f)}{#if[Double]?Double.doubleToRawLongBits(-0.0d)};\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int parallelism, int low, int high) {\n+        \/*\n+         * Phase 1. Count the number of negative zero -0.0,\n+         * turn them into positive zero, and move all NaNs\n+         * to the end of the array.\n+         *\/\n+        int negativeZeroCount = 0;\n+\n+        for (int k = high; k > low; ) {\n+            $type$ ak = a[--k];\n+\n+            if ({#if[Float]?Float.floatToRawIntBits}{#if[Double]?Double.doubleToRawLongBits}(ak) == $TYPE$_NEGATIVE_ZERO) { \/\/ ak is -0.0\n+                negativeZeroCount++;\n+                a[k] = 0.0{#if[Float]?f}{#if[Double]?d};\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n+                a[k] = a[--high];\n+                a[high] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Phase 2. Sort everything except NaNs,\n+         * which are already in place.\n+         *\/\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n+        } else {\n+            sort(null, a, 0, low, high);\n+        }\n+\n+        \/*\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0 back into negative zeros -0.0.\n+         *\/\n+        if (++negativeZeroCount == 1) {\n+            return;\n+        }\n+\n+        \/*\n+         * Find the position one less than\n+         * the index of the first zero.\n+         *\/\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+\n+            if (a[mid] < 0.0{#if[Float]?f}{#if[Double]?d}) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        \/*\n+         * Replace 0.0 by negative zeros -0.0.\n+         *\/\n+        while (--negativeZeroCount > 0) {\n+            a[++high] = -0.0{#if[Float]?f}{#if[Double]?d};\n+        }\n+    }\n+#end[FloatDouble]\n+#if[Byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort or counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(byte[] a, int low, int high) {\n+        if (high - low < MAX_INSERTION_SORT_SIZE) {\n+            insertionSort(a, low, high);\n+        } else {\n+            countingSort(a, low, high);\n+        }\n+    }\n+#end[Byte]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int low, int high) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            sort(a, 0, low, high);\n+        }\n+    }\n+#end[CharShort]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that range is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(Sorter<$type$[]> sorter, $type$[] a, int bits, int low, int high) {\n+        while (true) {\n+            int size = high - low;\n+\n+            \/*\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n+                return;\n+            }\n+\n+            \/*\n+             * Invoke adaptive insertion sort on small leftmost part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n+                sort($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n+                return;\n+            }\n+\n+            \/*\n+             * Try merging sort on large part.\n+             *\/\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n+             *\/\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = high - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { $type$ t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { $type$ t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { $type$ t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { $type$ t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { $type$ t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n+                }\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n+                }\n+            }\n+\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                indices = partition($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n+                } else {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n+                }\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                if (sorter == null) {\n+                    sort(sorter, a, bits | 1, indices[1], high);\n+                } else {\n+                    sorter.fork(bits | 1, indices[1], high);\n+                }\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+#end[IntLongFloatDouble]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that range is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int bits, int low, int high) {\n+        while (true) {\n+            int size = high - low;\n+\n+            \/*\n+             * Invoke insertion sort on small part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE) {\n+                insertionSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n+             *\/\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = high - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { $type$ t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { $type$ t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { $type$ t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { $type$ t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { $type$ t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n+                }\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n+                }\n+            }\n+\n+            \/*\n+             * Switch to counting sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                countingSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+#end[CharShort]\n+#if[AllExceptByte]\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            $type$[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        $type$ pivot1 = a[pivotIndex1];\n+        $type$ pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            $type$ ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n+\n+        return new int[] { lower, upper };\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            $type$[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        $type$ pivot = a[pivotIndex1];\n+\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            $type$ ak = a[k];\n+\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n+\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n+\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n+    }\n+#end[AllExceptByte]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n+     *\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n+     *\n+     * In the context of Dual-Pivot Quicksort, the pivot element\n+     * from the left part plays the role of sentinel, because it\n+     * is less than any elements from the given part. Therefore,\n+     * expensive check of the left range can be skipped on each\n+     * iteration unless it is the leftmost call.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void mixedInsertionSort($type$[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            $type$ ai = a[i = low], pin = a[--p];\n+\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            $type$ a1 = a[i = low], a2 = a[++low];\n+\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n+\n+            } else if (a1 < a[i - 1]) {\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n+        }\n+    }\n+#end[IntLongFloatDouble]\n+#if[AllTypes]\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort($type$[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            $type$ ai = a[i = k];\n+\n+            if (ai < a[i - 1]) {\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n+            }\n+        }\n+    }\n+#end[AllTypes]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Tries to sort the specified range of the array using merging sort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryMergingSort(Sorter<$type$[]> sorter, $type$[] a, int low, int high) {\n+        \/*\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n+         *\/\n+        int count = 1;\n+        int[] run = null;\n+\n+        \/*\n+         * Identify all possible runs.\n+         *\/\n+        for (int k = low + 1, last = low; k < high; ) {\n+            \/*\n+             * Find the next run.\n+             *\/\n+            if (a[k - 1] < a[k]) {\n+\n+                \/\/ Identify ascending sequence\n+                while (++k < high && a[k - 1] <= a[k]);\n+\n+            } else if (a[k - 1] > a[k]) {\n+\n+                \/\/ Identify descending sequence\n+                while (++k < high && a[k - 1] >= a[k]);\n+\n+                \/\/ Reverse into ascending order\n+                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\n+                    $type$ ai = a[i]; a[i] = a[j]; a[j] = ai;\n+                }\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n+            } else { \/\/ Identify constant sequence\n+                for ($type$ ak = a[k]; ++k < high && ak == a[k]; );\n+\n+                \/\/ Check the next sequence\n+                if (k < high) {\n+                    continue;\n+                }\n+            }\n+\n+            \/*\n+             * Process the current run.\n+             *\/\n+            if (run == null) {\n+\n+                if (k == high) {\n+                    \/*\n+                     * Array is monotonous sequence\n+                     * and therefore already sorted.\n+                     *\/\n+                    return true;\n+                }\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n+                run[0] = low;\n+\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n+\n+                if (k - low < count * MIN_RUN_SIZE) {\n+                    \/*\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n+                     *\/\n+                    return false;\n+                }\n+\n+                if (++count == run.length) {\n+                    \/*\n+                     * Array is not highly structured.\n+                     *\/\n+                    return false;\n+                }\n+            }\n+\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n+\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n+            }\n+        }\n+\n+        \/*\n+         * Merge all runs.\n+         *\/\n+        if (count > 1) {\n+            $type$[] b; int offset = low;\n+\n+            if (sorter != null && (b = sorter.b) != null) {\n+                offset = sorter.offset;\n+            } else if ((b = tryAllocate($type$[].class, high - low)) == null) {\n+                return false;\n+            }\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Merges the specified runs.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the source array\n+     * @param b the buffer for merging\n+     * @param offset the start index in the source, inclusive\n+     * @param aim whether the original array is used for merging\n+     * @param run the start indexes of the runs, inclusive\n+     * @param lo the start index of the first run, inclusive\n+     * @param hi the start index of the last run, inclusive\n+     *\/\n+    private static void mergeRuns(Sorter<$type$[]> sorter, $type$[] a, $type$[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n+\n+        if (hi - lo == 1) {\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n+            }\n+            return;\n+        }\n+\n+        \/*\n+         * Split the array into two approximately equal parts.\n+         *\/\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n+\n+        \/*\n+         * Merge the runs of all parts.\n+         *\/\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n+\n+        $type$[] dst = aim ? a : b;\n+        $type$[] src = aim ? b : a;\n+\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n+        } else {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts in parallel.\n+     *\n+     * @param merger the parallel context\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(Merger<$type$[]> merger, $type$[] dst, int k,\n+            $type$[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n+\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                $type$ key = src[mi2];\n+\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n+                }\n+            } else {\n+\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                $type$ key = src[mi1];\n+\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi2 = mid;\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n+\n+            \/*\n+             * Skip the first parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n+\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n+\n+        \/*\n+         * Merge the small parts sequentially.\n+         *\/\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts($type$[] dst, int k,\n+            $type$[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    $type$ next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    $type$ next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    $type$ next = src[lo1];\n+\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort($type$[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            $type$ max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown($type$[] a, int p, $type$ value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+#end[IntLongFloatDouble]\n+#if[Byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void countingSort(byte[] a, int low, int high) {\n+        \/*\n+         * Count the number of all values.\n+         *\/\n+        int[] count = new int[1 << 8];\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        for (int i = high; i > low; ++count[a[--i] & 0xFF]);\n+\n+        \/*\n+         * Place values on their final positions.\n+         *\/\n+        for (int value = Byte.MIN_VALUE; high > low; ) {\n+            while (count[--value & 0xFF] == 0);\n+            int num = count[value & 0xFF];\n+\n+            do {\n+                a[--high] = (byte) value;\n+            } while (--num > 0);\n+        }\n+    }\n+#end[Byte]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void countingSort($type$[] a, int low, int high) {\n+        int size = high - low;\n+\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n+\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i]{#if[Short]? & 0xFFFF}]);\n+\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = {#if[Char]?count.length}{#if[Short]?Short.MIN_VALUE}; high > low; ) {\n+                while (count[--value{#if[Short]? & 0xFFFF}] == 0);\n+                int num = count[value{#if[Short]? & 0xFFFF}];\n+\n+                do {\n+                    a[--high] = ($type$) value;\n+                } while (--num > 0);\n+            }\n+\n+        } else {\n+\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            $type$[] b = new $type$[size];\n+\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n+\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}];{#if[Short]? \/\/ Flip the sign bit}\n+            }\n+\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n+            }\n+        }\n+    }\n+#end[CharShort]\n+#if[Common2]\n+\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == 0) {\n+                continue;\n+            }\n+            if (c == total) {\n+                return false;\n+            }\n+            break;\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n+        }\n+        return true;\n+    }\n+\n+\/\/ #[class]\n+\n+    \/**\n+     * Implementation of parallel sorting.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n+        @SuppressWarnings(\"serial\")\n+        private final T a, b;\n+        private final int low, size, offset, depth;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private Sorter(T a, int parallelism, int low, int size) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+            this.b = (T) tryAllocate(a.getClass(), size);\n+            this.depth = b == null ? 0 : ((parallelism >> 7) + 2) * (-2);\n+        }\n+\n+        private Sorter(CountedCompleter<?> parent,\n+                T a, T b, int low, int size, int offset, int depth) {\n+            super(parent);\n+            this.a = a;\n+            this.b = b;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = offset;\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            if (depth < 0) {\n+                setPendingCount(2);\n+                int half = size >> 1;\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\n+            } else {\n+                switch(a) {\n+                    case int[] ai -> sort((Sorter<int[]>) this, ai, depth, low, low + size);\n+                    case long[] al -> sort((Sorter<long[]>) this, al, depth, low, low + size);\n+                    case float[] af -> sort((Sorter<float[]>) this, af, depth, low, low + size);\n+                    case double[] ad -> sort((Sorter<double[]>) this, ad, depth, low, low + size);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+                }\n+            }\n+            tryComplete();\n+        }\n+\n+        @Override\n+        public void onCompletion(CountedCompleter<?> caller) {\n+            if (depth < 0) {\n+                int mi = low + (size >> 1);\n+                boolean src = (depth & 1) == 0;\n+\n+                new Merger<>(null,\n+                    a,\n+                    src ? low : low - offset,\n+                    b,\n+                    src ? low - offset : low,\n+                    src ? mi - offset : mi,\n+                    src ? mi - offset : mi,\n+                    src ? low + size - offset : low + size\n+                ).invoke();\n+            }\n+        }\n+\n+        private void fork(int depth, int low, int high) {\n+            if (high - low < MIN_PARALLEL_SORT_SIZE) {\n+                switch(a) {\n+                    case int[] ai -> sort(null, ai, depth, low, high);\n+                    case long[] al -> sort(null, al, depth, low, high);\n+                    case float[] af -> sort(null, af, depth, low, high);\n+                    case double[] ad -> sort(null, ad, depth, low, high);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+                }\n+            } else {\n+                addToPendingCount(1);\n+                new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Implementation of parallel merging.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    private static final class Merger<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n+        @SuppressWarnings(\"serial\")\n+        private final T dst, src;\n+        private final int k, lo1, hi1, lo2, hi2;\n+\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\n+                T src, int lo1, int hi1, int lo2, int hi2) {\n+            super(parent);\n+            this.dst = dst;\n+            this.k = k;\n+            this.src = src;\n+            this.lo1 = lo1;\n+            this.hi1 = hi1;\n+            this.lo2 = lo2;\n+            this.hi2 = hi2;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            switch(dst) {\n+                case int[] di -> mergeParts((Merger<int[]>) this, di, k, (int[]) src, lo1, hi1, lo2, hi2);\n+                case long[] dl -> mergeParts((Merger<long[]>) this, dl, k, (long[]) src, lo1, hi1, lo2, hi2);\n+                case float[] df -> mergeParts((Merger<float[]>) this, df, k, (float[]) src, lo1, hi1, lo2, hi2);\n+                case double[] dd -> mergeParts((Merger<double[]>) this, dd, k, (double[]) src, lo1, hi1, lo2, hi2);\n+                default -> throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n+            }\n+            propagateCompletion();\n+        }\n+\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\n+            addToPendingCount(1);\n+            new Merger<>(this, dst, k, src, lo1, hi1, lo2, hi2).fork();\n+        }\n+    }\n+\n+    \/**\n+     * Tries to allocate additional buffer.\n+     *\n+     * @param <T> the class of array\n+     * @param clazz the given array class\n+     * @param length the length of additional buffer\n+     * @return {@code null} if requested buffer is too big or there is no enough memory,\n+     *         otherwise created buffer\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T tryAllocate(Class<T> clazz, int length) {\n+        try {\n+            int maxLength = MAX_BUFFER_SIZE >>\n+                (clazz == int[].class || clazz == float[].class ? 2 : 3);\n+            return length > maxLength ? null :\n+                (T) U.allocateUninitializedArray(clazz.componentType(), length);\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+}\n+#end[Common2]\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java.template","additions":1627,"deletions":0,"binary":false,"changes":1627,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+#!\/bin\/bash\n+\n+javac -d . ..\/..\/..\/..\/..\/..\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\n+\n+in=DualPivotQuicksort.java.template\n+out=DualPivotQuicksort.java\n+\n+rm -rf $out\n+\n+gen() {\n+    java build.tools.spp.Spp -nel -Dtype=$1 -DTYPE=$2 -K$3 -K$4 -K$5 -K$6 -K$7 -i$in -o$out\n+}\n+\n+gen \"\"     \"\"     Common1  \"\"            \"\"                 \"\"          \"\"\n+gen int    INT    AllTypes AllExceptByte IntLongFloatDouble IntLong     \"\"\n+gen long   LONG   AllTypes AllExceptByte IntLongFloatDouble IntLong     \"\"\n+gen byte   \"\"     AllTypes \"\"            \"\"                 \"\"          Byte\n+gen char   \"\"     AllTypes AllExceptByte \"\"                 CharShort   Char\n+gen short  \"\"     AllTypes AllExceptByte \"\"                 CharShort   Short\n+gen float  FLOAT  AllTypes AllExceptByte IntLongFloatDouble FloatDouble Float\n+gen double DOUBLE AllTypes AllExceptByte IntLongFloatDouble FloatDouble Double\n+gen \"\"     \"\"     Common2  \"\"            \"\"                 \"\"          \"\"\n+\n+rm -rf build\n","filename":"src\/java.base\/share\/classes\/java\/util\/gen-DualPivotQuicksort.sh","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,2 @@\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n@@ -27,1 +29,1 @@\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n@@ -39,1 +41,1 @@\n-import java.util.Comparator;\n+import java.util.Arrays;\n@@ -48,15 +50,3 @@\n-    \/\/ Array lengths used in a long run (default)\n-    private static final int[] LONG_RUN_LENGTHS = {\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n-\n-    \/\/ Array lengths used in a short run\n-    private static final int[] SHORT_RUN_LENGTHS = {\n-        1, 8, 55, 100, 10_000 };\n-\n-    \/\/ Random initial values used in a long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS = {\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n-\n-    \/\/ Random initial values used in a short run\n-    private static final TestRandom[] SHORT_RUN_RANDOMS = {\n-        TestRandom.C0FFEE };\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_LENGTHS =\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000 };\n@@ -64,3 +54,3 @@\n-    \/\/ Constants used in subarray sorting\n-    private static final int A380 = 0xA380;\n-    private static final int B747 = 0xB747;\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_LENGTHS =\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000, 64_000};\n@@ -68,5 +58,1 @@\n-    private final SortingHelper sortingHelper;\n-    private final TestRandom[] randoms;\n-    private final int[] lengths;\n-    private Object[] gold;\n-    private Object[] test;\n+    private static final Random random = new Random(0xC0FFEE);\n@@ -75,1 +61,0 @@\n-        long start = System.currentTimeMillis();\n@@ -77,0 +62,2 @@\n+        int[] lengths = shortRun ? SHORT_LENGTHS : LONG_LENGTHS;\n+        long start = System.currentTimeMillis();\n@@ -78,9 +65,9 @@\n-        int[] lengths = shortRun ? SHORT_RUN_LENGTHS : LONG_RUN_LENGTHS;\n-        TestRandom[] randoms = shortRun ? SHORT_RUN_RANDOMS : LONG_RUN_RANDOMS;\n-\n-        new Sorting(SortingHelper.DUAL_PIVOT_QUICKSORT, randoms, lengths).testCore();\n-        new Sorting(SortingHelper.PARALLEL_SORT, randoms, lengths).testCore();\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBasic();\n-        new Sorting(SortingHelper.ARRAYS_SORT, randoms, lengths).testAll();\n-        new Sorting(SortingHelper.ARRAYS_PARALLEL_SORT, randoms, lengths).testAll();\n-\n+        for (int length : lengths) {\n+            new IntegerHolder().test(length);\n+            new LongHolder().test(length);\n+            new ByteHolder().test(length);\n+            new CharacterHolder().test(length);\n+            new ShortHolder().test(length);\n+            new FloatHolder().test(length);\n+            new DoubleHolder().test(length);\n+        }\n@@ -88,1 +75,1 @@\n-        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1000);\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n@@ -91,5 +78,3 @@\n-    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths) {\n-        this.sortingHelper = sortingHelper;\n-        this.randoms = randoms;\n-        this.lengths = lengths;\n-    }\n+    private static class IntegerHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final int A380 = (int) 0xA380;\n@@ -97,2 +82,2 @@\n-    private void testBasic() {\n-        testEmptyArray();\n+        \/\/ Constant to fill the right part of array\n+        private static final int B747 = (int) 0xB747;\n@@ -100,5 +85,4 @@\n-        for (int length : lengths) {\n-            createData(length);\n-            testBasic(length);\n-        }\n-    }\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private int[] gold;\n+        private int[] test;\n@@ -106,5 +90,2 @@\n-    private void testBasic(int length) {\n-        for (TestRandom random : randoms) {\n-            testWithInsertionSort(length, random);\n-            testWithCheckSum(length, random);\n-            testWithScrambling(length, random);\n+        private IntegerHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n@@ -112,1 +93,0 @@\n-    }\n@@ -114,4 +94,4 @@\n-    private void testCore() {\n-        for (int length : lengths) {\n-            createData(length);\n-            testCore(length);\n+        private IntegerHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n@@ -119,1 +99,0 @@\n-    }\n@@ -121,2 +100,3 @@\n-    private void testCore(int length) {\n-        testBasic(length);\n+        private void test(int length) {\n+            gold = new int[length];\n+            test = new int[length];\n@@ -124,7 +104,8 @@\n-        for (TestRandom random : randoms) {\n-            testMergingSort(length, random);\n-            testSubArray(length, random);\n-            testNegativeZero(length, random);\n-            testFloatingPointSorting(length, random);\n-        }\n-    }\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n@@ -132,4 +113,1 @@\n-    private void testAll() {\n-        for (int length : lengths) {\n-            createData(length);\n-            testAll(length);\n+            out.println();\n@@ -137,4 +115,0 @@\n-    }\n-\n-    private void testAll(int length) {\n-        testCore(length);\n@@ -142,3 +116,2 @@\n-        for (TestRandom random : randoms) {\n-            testRange(length, random);\n-            testStability(length, random);\n+        private void testEmpty() {\n+            sortingHelper.sort(new int[test.length], 0, 0);\n@@ -146,24 +119,0 @@\n-    }\n-\n-    private void testEmptyArray() {\n-        testEmptyAndNullIntArray();\n-        testEmptyAndNullLongArray();\n-        testEmptyAndNullByteArray();\n-        testEmptyAndNullCharArray();\n-        testEmptyAndNullShortArray();\n-        testEmptyAndNullFloatArray();\n-        testEmptyAndNullDoubleArray();\n-    }\n-\n-    private void testStability(int length, TestRandom random) {\n-        printTestName(\"Test stability\", random, length);\n-\n-        Pair[] a = build(length, random);\n-        sortingHelper.sort(a);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        a = build(length, random);\n-        sortingHelper.sort(a, pairComparator);\n-        checkSorted(a);\n-        checkStable(a);\n@@ -171,6 +120,2 @@\n-        out.println();\n-    }\n-\n-    private void testEmptyAndNullIntArray() {\n-        sortingHelper.sort(new int[] {});\n-        sortingHelper.sort(new int[] {}, 0, 0);\n+        private void testStructured() {\n+            testEmpty();\n@@ -178,6 +123,1 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n+            if (test.length < 512) {\n@@ -186,2 +126,9 @@\n-            fail(sortingHelper + \"(int[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n@@ -189,2 +136,0 @@\n-        fail(sortingHelper + \"(int[]) shouldn't catch null array\");\n-    }\n@@ -192,10 +137,2 @@\n-    private void testEmptyAndNullLongArray() {\n-        sortingHelper.sort(new long[] {});\n-        sortingHelper.sort(new long[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n+        private void testBase() {\n+            if (test.length > 1_000) {\n@@ -204,2 +141,4 @@\n-            fail(sortingHelper + \"(long[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -207,6 +146,0 @@\n-        fail(sortingHelper + \"(long[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullByteArray() {\n-        sortingHelper.sort(new byte[] {});\n-        sortingHelper.sort(new byte[] {}, 0, 0);\n@@ -214,10 +147,5 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(byte[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -225,2 +153,0 @@\n-        fail(sortingHelper + \"(byte[]) shouldn't catch null array\");\n-    }\n@@ -228,3 +154,4 @@\n-    private void testEmptyAndNullCharArray() {\n-        sortingHelper.sort(new char[] {});\n-        sortingHelper.sort(new char[] {}, 0, 0);\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n@@ -232,7 +159,8 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n@@ -240,2 +168,0 @@\n-            fail(sortingHelper + \"(char[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n@@ -243,6 +169,0 @@\n-        fail(sortingHelper + \"(char[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullShortArray() {\n-        sortingHelper.sort(new short[] {});\n-        sortingHelper.sort(new short[] {}, 0, 0);\n@@ -250,3 +170,1 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n+        private void testRange(int m) {\n@@ -254,3 +172,15 @@\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n@@ -258,2 +188,0 @@\n-            fail(sortingHelper + \"(short[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n@@ -261,2 +189,0 @@\n-        fail(sortingHelper + \"(short[]) shouldn't catch null array\");\n-    }\n@@ -264,10 +190,2 @@\n-    private void testEmptyAndNullFloatArray() {\n-        sortingHelper.sort(new float[] {});\n-        sortingHelper.sort(new float[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n@@ -276,2 +194,12 @@\n-            fail(sortingHelper + \"(float[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n@@ -279,2 +207,0 @@\n-        fail(sortingHelper + \"(float[]) shouldn't catch null array\");\n-    }\n@@ -282,3 +208,3 @@\n-    private void testEmptyAndNullDoubleArray() {\n-        sortingHelper.sort(new double[] {});\n-        sortingHelper.sort(new double[] {}, 0, 0);\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -286,7 +212,7 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n@@ -294,2 +220,0 @@\n-            fail(sortingHelper + \"(double[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n@@ -297,2 +221,0 @@\n-        fail(sortingHelper + \"(double[]) shouldn't catch null array\");\n-    }\n@@ -300,3 +222,11 @@\n-    private void testSubArray(int length, TestRandom random) {\n-        if (length < 4) {\n-            return;\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n@@ -304,3 +234,0 @@\n-        for (int m = 1; m < length \/ 2; m <<= 1) {\n-            int fromIndex = m;\n-            int toIndex = length - m;\n@@ -308,8 +235,9 @@\n-            prepareSubArray((int[]) gold[0], fromIndex, toIndex);\n-            convertData(length);\n-\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test subarray\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                sortingHelper.sort(test[i], fromIndex, toIndex);\n-                checkSubArray(test[i], fromIndex, toIndex);\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n@@ -318,2 +246,0 @@\n-        out.println();\n-    }\n@@ -321,3 +247,3 @@\n-    private void testRange(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -325,5 +251,0 @@\n-        for (int m = 1; m < length; m <<= 1) {\n-            for (int i = 1; i <= length; i++) {\n-                ((int[]) gold[0]) [i - 1] = i % m + m % i;\n-            }\n-            convertData(length);\n@@ -331,4 +252,15 @@\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test range check\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                checkRange(test[i], m);\n+        private void checkSorted(int[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n@@ -337,2 +269,0 @@\n-        out.println();\n-    }\n@@ -340,5 +270,6 @@\n-    private void checkSorted(Pair[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i].getKey() > a[i + 1].getKey()) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" +\n-                    a[i].getKey() + \" and \" + a[i + 1].getKey());\n+        private void checkCheckSum(int[] a, int[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n@@ -347,1 +278,0 @@\n-    }\n@@ -349,10 +279,2 @@\n-    private void checkStable(Pair[] a) {\n-        for (int i = 0; i < a.length \/ 4; ) {\n-            int key1 = a[i].getKey();\n-            int value1 = a[i++].getValue();\n-            int key2 = a[i].getKey();\n-            int value2 = a[i++].getValue();\n-            int key3 = a[i].getKey();\n-            int value3 = a[i++].getValue();\n-            int key4 = a[i].getKey();\n-            int value4 = a[i++].getValue();\n+        private int checkSumXor(int[] a) {\n+            int checkSum = 0;\n@@ -360,8 +282,2 @@\n-            if (!(key1 == key2 && key2 == key3 && key3 == key4)) {\n-                fail(\"Keys are different \" + key1 + \", \" + key2 + \", \" +\n-                    key3 + \", \" + key4 + \" at position \" + i);\n-            }\n-            if (!(value1 < value2 && value2 < value3 && value3 < value4)) {\n-                fail(\"Sorting is not stable at position \" + i +\n-                    \". Second values have been changed: \" + value1 + \", \" +\n-                    value2 + \", \" + value3 + \", \" + value4);\n+            for (int e : a) {\n+                checkSum ^= (int) e;\n@@ -369,0 +285,1 @@\n+            return checkSum;\n@@ -370,1 +287,0 @@\n-    }\n@@ -372,2 +288,8 @@\n-    private Pair[] build(int length, Random random) {\n-        Pair[] a = new Pair[length * 4];\n+        private int checkSumPlus(int[] a) {\n+            int checkSum = 0;\n+\n+            for (int e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n@@ -375,6 +297,6 @@\n-        for (int i = 0; i < a.length; ) {\n-            int key = random.nextInt();\n-            a[i++] = new Pair(key, 1);\n-            a[i++] = new Pair(key, 2);\n-            a[i++] = new Pair(key, 3);\n-            a[i++] = new Pair(key, 4);\n+        private void compare(int[] a, int[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n@@ -382,2 +304,0 @@\n-        return a;\n-    }\n@@ -385,3 +305,2 @@\n-    private void testWithInsertionSort(int length, TestRandom random) {\n-        if (length > 1000) {\n-            return;\n+        private void sortByInsertionSort(int[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -389,4 +308,0 @@\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n@@ -394,7 +309,9 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test with insertion sort\", random, length,\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    sortByInsertionSort(gold[i]);\n-                    compare(test[i], gold[i]);\n-                }\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Integer.MIN_VALUE;\n@@ -402,0 +319,1 @@\n+            test = gold.clone();\n@@ -403,2 +321,0 @@\n-        out.println();\n-    }\n@@ -406,3 +322,2 @@\n-    private void testMergingSort(int length, TestRandom random) {\n-        if (length < (4 << 10)) { \/\/ DualPivotQuicksort.MIN_TRY_MERGE_SIZE\n-            return;\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Integer\", test.length, sortingHelper, m, builder);\n@@ -410,1 +325,0 @@\n-        final int PERIOD = 50;\n@@ -412,4 +326,3 @@\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; m++) {\n-            for (MergingBuilder builder : MergingBuilder.values()) {\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n+        private static void swap(int[] a, int i, int j) {\n+            int t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n@@ -417,7 +330,6 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test merging sort\", random, length,\n-                        \", m = \" + m + \", \" +  getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkSorted(test[i]);\n-                }\n-            }\n+        private static void reverse(int[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private interface Builder {\n+            void build(int[] a, int m);\n@@ -425,2 +337,0 @@\n-        out.println();\n-    }\n@@ -428,5 +338,9 @@\n-    private void testWithCheckSum(int length, TestRandom random) {\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n@@ -434,5 +348,9 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test with check sum\", random, length,\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkWithCheckSum(test[i], gold[i]);\n+            STEPS {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n@@ -442,2 +360,0 @@\n-        out.println();\n-    }\n@@ -445,5 +361,9 @@\n-    private void testWithScrambling(int length, TestRandom random) {\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (SortedBuilder builder : SortedBuilder.values()) {\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) random.nextInt();\n+                    }\n+                }\n+            },\n@@ -451,6 +371,9 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test with scrambling\", random, length,\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    scramble(test[i], random);\n-                    sortingHelper.sort(test[i]);\n-                    compare(test[i], gold[i]);\n+            PERMUTATION {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n@@ -458,4 +381,1 @@\n-            }\n-        }\n-        out.println();\n-    }\n+            },\n@@ -463,3 +383,4 @@\n-    private void testNegativeZero(int length, TestRandom random) {\n-        for (int i = 5; i < test.length; i++) {\n-            printTestName(\"Test negative zero -0.0\", random, length, \" \" + getType(i));\n+            UNIFORM {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    int mask = (m << 15) - 1;\n@@ -467,2 +388,5 @@\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values() [i - 5];\n-            builder.build(test[i], random);\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n@@ -470,5 +394,8 @@\n-            sortingHelper.sort(test[i]);\n-            checkNegativeZero(test[i]);\n-        }\n-        out.println();\n-    }\n+            REPEATED {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (i % m);\n+                    }\n+                }\n+            },\n@@ -476,25 +403,18 @@\n-    private void testFloatingPointSorting(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n-        final int MAX = 13;\n-\n-        for (int a = 0; a < MAX; a++) {\n-            for (int g = 0; g < MAX; g++) {\n-                for (int z = 0; z < MAX; z++) {\n-                    for (int n = 0; n < MAX; n++) {\n-                        for (int p = 0; p < MAX; p++) {\n-                            if (a + g + z + n + p != length) {\n-                                continue;\n-                            }\n-                            for (int i = 5; i < test.length; i++) {\n-                                printTestName(\"Test float-pointing sorting\", random, length,\n-                                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n-                                builder.build(gold[i], a, g, z, n, p, random);\n-                                copy(test[i], gold[i]);\n-                                scramble(test[i], random);\n-                                sortingHelper.sort(test[i]);\n-                                compare(test[i], gold[i], a, n, g);\n-                            }\n+            DUPLICATED {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (int) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (int) (--minus);\n@@ -504,7 +424,1 @@\n-            }\n-        }\n-\n-        for (int m = 13; m > 4; m--) {\n-            int t = length \/ m;\n-            int g = t, z = t, n = t, p = t;\n-            int a = length - g - z - n - p;\n+            },\n@@ -512,10 +426,7 @@\n-            for (int i = 5; i < test.length; i++) {\n-                printTestName(\"Test float-pointing sorting\", random, length,\n-                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                FloatingPointBuilder builder = FloatingPointBuilder.values() [i - 5];\n-                builder.build(gold[i], a, g, z, n, p, random);\n-                copy(test[i], gold[i]);\n-                scramble(test[i], random);\n-                sortingHelper.sort(test[i]);\n-                compare(test[i], gold[i], a, n, g);\n+            SHUFFLE {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (int) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n@@ -524,2 +435,0 @@\n-        out.println();\n-    }\n@@ -527,6 +436,9 @@\n-    private void prepareSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            a[i] = A380;\n-        }\n-        int middle = (fromIndex + toIndex) >>> 1;\n-        int k = 0;\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (m + i);\n+                    }\n+                }\n+            },\n@@ -534,3 +446,8 @@\n-        for (int i = fromIndex; i < middle; i++) {\n-            a[i] = k++;\n-        }\n+            DESCENDING {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (a.length - m - i);\n+                    }\n+                }\n+            },\n@@ -538,3 +455,6 @@\n-        for (int i = middle; i < toIndex; i++) {\n-            a[i] = k--;\n-        }\n+            EQUAL {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    Arrays.fill(a, (int) m);\n+                }\n+            },\n@@ -542,4 +462,8 @@\n-        for (int i = toIndex; i < a.length; i++) {\n-            a[i] = B747;\n-        }\n-    }\n+            SHIFTED {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (i << 10);\n+                    }\n+                }\n+            },\n@@ -547,19 +471,4 @@\n-    private void scramble(Object a, Random random) {\n-        if (a instanceof int[]) {\n-            scramble((int[]) a, random);\n-        } else if (a instanceof long[]) {\n-            scramble((long[]) a, random);\n-        } else if (a instanceof byte[]) {\n-            scramble((byte[]) a, random);\n-        } else if (a instanceof char[]) {\n-            scramble((char[]) a, random);\n-        } else if (a instanceof short[]) {\n-            scramble((short[]) a, random);\n-        } else if (a instanceof float[]) {\n-            scramble((float[]) a, random);\n-        } else if (a instanceof double[]) {\n-            scramble((double[]) a, random);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n@@ -567,5 +476,8 @@\n-    private void scramble(int[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (int) (a.length - i - 1);\n+                    }\n+                }\n+            },\n@@ -573,5 +485,8 @@\n-    private void scramble(long[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n+            PLATEAU {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) Math.min(i, m);\n+                    }\n+                }\n+            },\n@@ -579,5 +494,4 @@\n-    private void scramble(byte[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n+            LATCH {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n@@ -585,5 +499,5 @@\n-    private void scramble(char[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (i % max);\n+                    }\n+                }\n+            },\n@@ -591,5 +505,7 @@\n-    private void scramble(short[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n+            POINT {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    Arrays.fill(a, (int) 0);\n+                    a[a.length \/ 2] = (int) m;\n+                }\n+            },\n@@ -597,5 +513,9 @@\n-    private void scramble(float[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n+            LINE {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n@@ -603,5 +523,9 @@\n-    private void scramble(double[] a, Random random) {\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-        }\n-    }\n+            PEARL {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n@@ -609,3 +533,9 @@\n-    private void swap(int[] a, int i, int j) {\n-        int t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n+            TRAPEZIUM {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n@@ -613,2 +543,9 @@\n-    private void swap(long[] a, int i, int j) {\n-        long t = a[i]; a[i] = a[j]; a[j] = t;\n+            STAGGER {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n+        }\n@@ -617,3 +554,3 @@\n-    private void swap(byte[] a, int i, int j) {\n-        byte t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n+    private static class LongHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final long A380 = (long) 0xA380;\n@@ -621,3 +558,2 @@\n-    private void swap(char[] a, int i, int j) {\n-        char t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n+        \/\/ Constant to fill the right part of array\n+        private static final long B747 = (long) 0xB747;\n@@ -625,3 +561,4 @@\n-    private void swap(short[] a, int i, int j) {\n-        short t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private long[] gold;\n+        private long[] test;\n@@ -629,3 +566,3 @@\n-    private void swap(float[] a, int i, int j) {\n-        float t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n+        private LongHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n@@ -633,3 +570,5 @@\n-    private void swap(double[] a, int i, int j) {\n-        double t = a[i]; a[i] = a[j]; a[j] = t;\n-    }\n+        private LongHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n@@ -637,4 +576,3 @@\n-    private void checkWithCheckSum(Object test, Object gold) {\n-        checkSorted(test);\n-        checkCheckSum(test, gold);\n-    }\n+        private void test(int length) {\n+            gold = new long[length];\n+            test = new long[length];\n@@ -642,4 +580,8 @@\n-    private void fail(String message) {\n-        err.format(\"\\n*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n-        throw new RuntimeException(\"Test failed\");\n-    }\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n@@ -647,7 +589,1 @@\n-    private void checkNegativeZero(Object a) {\n-        if (a instanceof float[]) {\n-            checkNegativeZero((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkNegativeZero((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+            out.println();\n@@ -655,1 +591,0 @@\n-    }\n@@ -657,5 +592,2 @@\n-    private void checkNegativeZero(float[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (Float.floatToRawIntBits(a[i]) == 0 && Float.floatToRawIntBits(a[i + 1]) < 0) {\n-                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\n-            }\n+        private void testEmpty() {\n+            sortingHelper.sort(new long[test.length], 0, 0);\n@@ -663,1 +595,0 @@\n-    }\n@@ -665,4 +596,14 @@\n-    private void checkNegativeZero(double[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (Double.doubleToRawLongBits(a[i]) == 0 && Double.doubleToRawLongBits(a[i + 1]) < 0) {\n-                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n@@ -671,1 +612,0 @@\n-    }\n@@ -673,7 +613,8 @@\n-    private void compare(Object a, Object b, int numNaN, int numNeg, int numNegZero) {\n-        if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b, numNaN, numNeg, numNegZero);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b, numNaN, numNeg, numNegZero);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -681,1 +622,0 @@\n-    }\n@@ -683,5 +623,5 @@\n-    private void compare(float[] a, float[] b, int numNaN, int numNeg, int numNegZero) {\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n-                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n-            }\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -689,1 +629,0 @@\n-        final int NEGATIVE_ZERO = Float.floatToIntBits(-0.0f);\n@@ -691,4 +630,3 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Float.floatToIntBits(a[i])) {\n-                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n-            }\n+        private void testAll() {\n+            testCore();\n+            testRange();\n@@ -697,3 +635,8 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n@@ -702,1 +645,0 @@\n-    }\n@@ -704,4 +646,17 @@\n-    private void compare(double[] a, double[] b, int numNaN, int numNeg, int numNegZero) {\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n-                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n@@ -710,1 +665,0 @@\n-        final long NEGATIVE_ZERO = Double.doubleToLongBits(-0.0d);\n@@ -712,3 +666,3 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Double.doubleToLongBits(a[i])) {\n-                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n@@ -716,1 +670,2 @@\n-        }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -718,3 +673,8 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n@@ -723,1 +683,0 @@\n-    }\n@@ -725,19 +684,3 @@\n-    private void compare(Object a, Object b) {\n-        if (a instanceof int[]) {\n-            compare((int[]) a, (int[]) b);\n-        } else if (a instanceof long[]) {\n-            compare((long[]) a, (long[]) b);\n-        } else if (a instanceof byte[]) {\n-            compare((byte[]) a, (byte[]) b);\n-        } else if (a instanceof char[]) {\n-            compare((char[]) a, (char[]) b);\n-        } else if (a instanceof short[]) {\n-            compare((short[]) a, (short[]) b);\n-        } else if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -745,4 +688,7 @@\n-    private void compare(int[] a, int[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n@@ -751,1 +697,0 @@\n-    }\n@@ -753,4 +698,10 @@\n-    private void compare(long[] a, long[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n@@ -759,1 +710,0 @@\n-    }\n@@ -761,4 +711,9 @@\n-    private void compare(byte[] a, byte[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n@@ -767,1 +722,0 @@\n-    }\n@@ -769,5 +723,3 @@\n-    private void compare(char[] a, char[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -775,1 +727,0 @@\n-    }\n@@ -777,4 +728,5 @@\n-    private void compare(short[] a, short[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+        private void checkSorted(long[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n@@ -782,7 +734,9 @@\n-        }\n-    }\n-\n-    private void compare(float[] a, float[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n@@ -791,1 +745,0 @@\n-    }\n@@ -793,4 +746,6 @@\n-    private void compare(double[] a, double[] b) {\n-        for (int i = 0; i < a.length; i++) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+        private void checkCheckSum(long[] a, long[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n@@ -799,1 +754,0 @@\n-    }\n@@ -801,2 +755,2 @@\n-    private String getType(int i) {\n-        Object a = test[i];\n+        private int checkSumXor(long[] a) {\n+            int checkSum = 0;\n@@ -804,20 +758,4 @@\n-        if (a instanceof int[]) {\n-            return \"INT   \";\n-        }\n-        if (a instanceof long[]) {\n-            return \"LONG  \";\n-        }\n-        if (a instanceof byte[]) {\n-            return \"BYTE  \";\n-        }\n-        if (a instanceof char[]) {\n-            return \"CHAR  \";\n-        }\n-        if (a instanceof short[]) {\n-            return \"SHORT \";\n-        }\n-        if (a instanceof float[]) {\n-            return \"FLOAT \";\n-        }\n-        if (a instanceof double[]) {\n-            return \"DOUBLE\";\n+            for (long e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n@@ -825,3 +763,0 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return null;\n-    }\n@@ -829,19 +764,2 @@\n-    private void checkSorted(Object a) {\n-        if (a instanceof int[]) {\n-            checkSorted((int[]) a);\n-        } else if (a instanceof long[]) {\n-            checkSorted((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            checkSorted((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            checkSorted((char[]) a);\n-        } else if (a instanceof short[]) {\n-            checkSorted((short[]) a);\n-        } else if (a instanceof float[]) {\n-            checkSorted((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkSorted((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n+        private int checkSumPlus(long[] a) {\n+            int checkSum = 0;\n@@ -849,4 +767,2 @@\n-    private void checkSorted(int[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            for (long e : a) {\n+                checkSum += (int) e;\n@@ -854,0 +770,1 @@\n+            return checkSum;\n@@ -855,1 +772,0 @@\n-    }\n@@ -857,4 +773,5 @@\n-    private void checkSorted(long[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+        private void compare(long[] a, long[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n@@ -863,1 +780,0 @@\n-    }\n@@ -865,5 +781,2 @@\n-    private void checkSorted(byte[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n+        private void sortByInsertionSort(long[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -871,1 +784,0 @@\n-    }\n@@ -873,4 +785,3 @@\n-    private void checkSorted(char[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n@@ -878,7 +789,2 @@\n-        }\n-    }\n-\n-    private void checkSorted(short[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n@@ -886,7 +792,2 @@\n-        }\n-    }\n-\n-    private void checkSorted(float[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            if (withMin) {\n+                gold[m] = Long.MIN_VALUE;\n@@ -894,0 +795,1 @@\n+            test = gold.clone();\n@@ -895,1 +797,0 @@\n-    }\n@@ -897,5 +798,2 @@\n-    private void checkSorted(double[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Long\", test.length, sortingHelper, m, builder);\n@@ -903,1 +801,0 @@\n-    }\n@@ -905,6 +802,2 @@\n-    private void checkCheckSum(Object test, Object gold) {\n-        if (checkSumXor(test) != checkSumXor(gold)) {\n-            fail(\"Original and sorted arrays are not identical [^]\");\n-        }\n-        if (checkSumPlus(test) != checkSumPlus(gold)) {\n-            fail(\"Original and sorted arrays are not identical [+]\");\n+        private static void swap(long[] a, int i, int j) {\n+            long t = a[i]; a[i] = a[j]; a[j] = t;\n@@ -912,1 +805,0 @@\n-    }\n@@ -914,12 +806,2 @@\n-    private int checkSumXor(Object a) {\n-        if (a instanceof int[]) {\n-            return checkSumXor((int[]) a);\n-        }\n-        if (a instanceof long[]) {\n-            return checkSumXor((long[]) a);\n-        }\n-        if (a instanceof byte[]) {\n-            return checkSumXor((byte[]) a);\n-        }\n-        if (a instanceof char[]) {\n-            return checkSumXor((char[]) a);\n+        private static void reverse(long[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n@@ -927,8 +809,3 @@\n-        if (a instanceof short[]) {\n-            return checkSumXor((short[]) a);\n-        }\n-        if (a instanceof float[]) {\n-            return checkSumXor((float[]) a);\n-        }\n-        if (a instanceof double[]) {\n-            return checkSumXor((double[]) a);\n+\n+        private interface Builder {\n+            void build(long[] a, int m);\n@@ -936,3 +813,0 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n-    }\n@@ -940,2 +814,9 @@\n-    private int checkSumXor(int[] a) {\n-        int checkSum = 0;\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n@@ -943,2 +824,11 @@\n-        for (int e : a) {\n-            checkSum ^= e;\n+            STEPS {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n@@ -946,2 +836,0 @@\n-        return checkSum;\n-    }\n@@ -949,2 +837,64 @@\n-    private int checkSumXor(long[] a) {\n-        long checkSum = 0;\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (long) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (long) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n@@ -952,2 +902,8 @@\n-        for (long e : a) {\n-            checkSum ^= e;\n+            SHUFFLE {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (long) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n@@ -955,2 +911,0 @@\n-        return (int) checkSum;\n-    }\n@@ -958,2 +912,106 @@\n-    private int checkSumXor(byte[] a) {\n-        byte checkSum = 0;\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    Arrays.fill(a, (long) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (long) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    Arrays.fill(a, (long) 0);\n+                    a[a.length \/ 2] = (long) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n@@ -961,2 +1019,8 @@\n-        for (byte e : a) {\n-            checkSum ^= e;\n+            STAGGER {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n@@ -964,1 +1028,0 @@\n-        return (int) checkSum;\n@@ -967,2 +1030,6 @@\n-    private int checkSumXor(char[] a) {\n-        char checkSum = 0;\n+    private static class ByteHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final byte A380 = (byte) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final byte B747 = (byte) 0xB747;\n@@ -970,2 +1037,13 @@\n-        for (char e : a) {\n-            checkSum ^= e;\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private byte[] gold;\n+        private byte[] test;\n+\n+        private ByteHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private ByteHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n@@ -973,2 +1051,0 @@\n-        return (int) checkSum;\n-    }\n@@ -976,2 +1052,3 @@\n-    private int checkSumXor(short[] a) {\n-        short checkSum = 0;\n+        private void test(int length) {\n+            gold = new byte[length];\n+            test = new byte[length];\n@@ -979,2 +1056,11 @@\n-        for (short e : a) {\n-            checkSum ^= e;\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new byte[test.length], 0, 0);\n@@ -982,2 +1068,0 @@\n-        return (int) checkSum;\n-    }\n@@ -985,2 +1069,16 @@\n-    private int checkSumXor(float[] a) {\n-        int checkSum = 0;\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n@@ -988,2 +1086,8 @@\n-        for (float e : a) {\n-            checkSum ^= (int) e;\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -991,2 +1095,0 @@\n-        return checkSum;\n-    }\n@@ -994,2 +1096,6 @@\n-    private int checkSumXor(double[] a) {\n-        int checkSum = 0;\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n@@ -997,2 +1103,3 @@\n-        for (double e : a) {\n-            checkSum ^= (int) e;\n+        private void testAll() {\n+            testCore();\n+            testRange();\n@@ -1000,2 +1107,0 @@\n-        return checkSum;\n-    }\n@@ -1003,3 +1108,9 @@\n-    private int checkSumPlus(Object a) {\n-        if (a instanceof int[]) {\n-            return checkSumPlus((int[]) a);\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n@@ -1007,2 +1118,19 @@\n-        if (a instanceof long[]) {\n-            return checkSumPlus((long[]) a);\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n@@ -1010,2 +1138,17 @@\n-        if (a instanceof byte[]) {\n-            return checkSumPlus((byte[]) a);\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n@@ -1013,2 +1156,13 @@\n-        if (a instanceof char[]) {\n-            return checkSumPlus((char[]) a);\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n@@ -1016,2 +1170,12 @@\n-        if (a instanceof short[]) {\n-            return checkSumPlus((short[]) a);\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n@@ -1019,2 +1183,11 @@\n-        if (a instanceof float[]) {\n-            return checkSumPlus((float[]) a);\n+\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n@@ -1022,2 +1195,4 @@\n-        if (a instanceof double[]) {\n-            return checkSumPlus((double[]) a);\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -1025,3 +1200,0 @@\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n-    }\n@@ -1029,2 +1201,17 @@\n-    private int checkSumPlus(int[] a) {\n-        int checkSum = 0;\n+        private void checkSorted(byte[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n@@ -1032,2 +1219,7 @@\n-        for (int e : a) {\n-            checkSum += e;\n+        private void checkCheckSum(byte[] a, byte[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n@@ -1035,2 +1227,0 @@\n-        return checkSum;\n-    }\n@@ -1038,2 +1228,2 @@\n-    private int checkSumPlus(long[] a) {\n-        long checkSum = 0;\n+        private int checkSumXor(byte[] a) {\n+            int checkSum = 0;\n@@ -1041,2 +1231,4 @@\n-        for (long e : a) {\n-            checkSum += e;\n+            for (byte e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n@@ -1044,2 +1236,0 @@\n-        return (int) checkSum;\n-    }\n@@ -1047,2 +1237,2 @@\n-    private int checkSumPlus(byte[] a) {\n-        byte checkSum = 0;\n+        private int checkSumPlus(byte[] a) {\n+            int checkSum = 0;\n@@ -1050,2 +1240,12 @@\n-        for (byte e : a) {\n-            checkSum += e;\n+            for (byte e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(byte[] a, byte[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n@@ -1053,2 +1253,0 @@\n-        return (int) checkSum;\n-    }\n@@ -1056,2 +1254,3 @@\n-    private int checkSumPlus(char[] a) {\n-        char checkSum = 0;\n+        private void sortByInsertionSort(byte[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n@@ -1059,2 +1258,11 @@\n-        for (char e : a) {\n-            checkSum += e;\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Byte.MIN_VALUE;\n+            }\n+            test = gold.clone();\n@@ -1062,2 +1270,0 @@\n-        return (int) checkSum;\n-    }\n@@ -1065,2 +1271,220 @@\n-    private int checkSumPlus(short[] a) {\n-        short checkSum = 0;\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Byte\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(byte[] a, int i, int j) {\n+            byte t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(byte[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private interface Builder {\n+            void build(byte[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (byte) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (byte) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (byte) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    Arrays.fill(a, (byte) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (byte) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    Arrays.fill(a, (byte) 0);\n+                    a[a.length \/ 2] = (byte) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n@@ -1068,2 +1492,8 @@\n-        for (short e : a) {\n-            checkSum += e;\n+            STAGGER {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n@@ -1071,1 +1501,0 @@\n-        return (int) checkSum;\n@@ -1074,2 +1503,1419 @@\n-    private int checkSumPlus(float[] a) {\n-        int checkSum = 0;\n+    private static class CharacterHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final char A380 = (char) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final char B747 = (char) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private char[] gold;\n+        private char[] test;\n+\n+        private CharacterHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private CharacterHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new char[length];\n+            test = new char[length];\n+\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new char[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n+\n+        private void checkSorted(char[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum(char[] a, char[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n+\n+        private int checkSumXor(char[] a) {\n+            int checkSum = 0;\n+\n+            for (char e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus(char[] a) {\n+            int checkSum = 0;\n+\n+            for (char e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(char[] a, char[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private void sortByInsertionSort(char[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Character.MIN_VALUE;\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Character\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(char[] a, int i, int j) {\n+            char t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(char[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private interface Builder {\n+            void build(char[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (char) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (char) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (char) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    Arrays.fill(a, (char) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (char) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    Arrays.fill(a, (char) 0);\n+                    a[a.length \/ 2] = (char) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class ShortHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final short A380 = (short) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final short B747 = (short) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private short[] gold;\n+        private short[] test;\n+\n+        private ShortHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private ShortHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new short[length];\n+            test = new short[length];\n+\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new short[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n+\n+        private void checkSorted(short[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum(short[] a, short[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n+\n+        private int checkSumXor(short[] a) {\n+            int checkSum = 0;\n+\n+            for (short e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus(short[] a) {\n+            int checkSum = 0;\n+\n+            for (short e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(short[] a, short[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private void sortByInsertionSort(short[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Short.MIN_VALUE;\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Short\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(short[] a, int i, int j) {\n+            short t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(short[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private interface Builder {\n+            void build(short[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (short) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (short) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (short) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    Arrays.fill(a, (short) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (short) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    Arrays.fill(a, (short) 0);\n+                    a[a.length \/ 2] = (short) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class FloatHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final float A380 = (float) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final float B747 = (float) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private float[] gold;\n+        private float[] test;\n+\n+        private FloatHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private FloatHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new float[length];\n+            test = new float[length];\n+\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new float[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+            testNegativeZeroAndNaN();\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testNegativeZeroAndNaN() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : FloatingPointBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    scramble();\n+                    print(\"negative zero and NaN\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    check(test, m);\n+                }\n+            }\n+        }\n+\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n+\n+        private void checkSorted(float[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum(float[] a, float[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n+\n+        private int checkSumXor(float[] a) {\n+            int checkSum = 0;\n+\n+            for (float e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus(float[] a) {\n+            int checkSum = 0;\n+\n+            for (float e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(float[] a, float[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private void sortByInsertionSort(float[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Float.NEGATIVE_INFINITY;\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Float\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(float[] a, int i, int j) {\n+            float t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(float[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private void check(float[] a, int m) {\n+            final int NEGATIVE_ZERO = Float.floatToIntBits(-0.0f);\n+\n+            int k1 = a.length \/ (m + 1) * m     \/ 5;\n+            int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+            int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+            int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n+\n+            for (int i = 0; i < k1; ++i) {\n+                float v = (float) (-(a.length + m) + i);\n+\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k1; i < k2; ++i) {\n+                if (Float.floatToIntBits(a[i]) != NEGATIVE_ZERO) {\n+                    fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k2; i < k3; ++i) {\n+                if (a[i] != 0.0f || Float.floatToIntBits(a[i]) == NEGATIVE_ZERO) {\n+                    fail(\"There must be 0.0 instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k3; i < k4; ++i) {\n+                float v = (float) (m + i);\n+\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k4; i < a.length; ++i) {\n+                if (!Float.isNaN(a[i])) {\n+                    fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private interface Builder {\n+            void build(float[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (float) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (float) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (float) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    Arrays.fill(a, (float) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (float) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (float) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n@@ -1077,5 +2923,5 @@\n-        for (float e : a) {\n-            checkSum += (int) e;\n-        }\n-        return checkSum;\n-    }\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (i % max);\n+                    }\n+                }\n+            },\n@@ -1083,2 +2929,7 @@\n-    private int checkSumPlus(double[] a) {\n-        int checkSum = 0;\n+            POINT {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    Arrays.fill(a, (float) 0);\n+                    a[a.length \/ 2] = (float) m;\n+                }\n+            },\n@@ -1086,5 +2937,9 @@\n-        for (double e : a) {\n-            checkSum += (int) e;\n-        }\n-        return checkSum;\n-    }\n+            LINE {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n@@ -1092,19 +2947,9 @@\n-    private void sortByInsertionSort(Object a) {\n-        if (a instanceof int[]) {\n-            sortByInsertionSort((int[]) a);\n-        } else if (a instanceof long[]) {\n-            sortByInsertionSort((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            sortByInsertionSort((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            sortByInsertionSort((char[]) a);\n-        } else if (a instanceof short[]) {\n-            sortByInsertionSort((short[]) a);\n-        } else if (a instanceof float[]) {\n-            sortByInsertionSort((float[]) a);\n-        } else if (a instanceof double[]) {\n-            sortByInsertionSort((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n+            PEARL {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n@@ -1112,3 +2957,9 @@\n-    private void sortByInsertionSort(int[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            int ai = a[i];\n+            TRAPEZIUM {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n@@ -1116,2 +2967,7 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+            STAGGER {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) ((i * m + i) % a.length);\n+                    }\n+                }\n@@ -1119,1 +2975,0 @@\n-            a[j + 1] = ai;\n@@ -1121,1 +2976,0 @@\n-    }\n@@ -1123,3 +2977,8 @@\n-    private void sortByInsertionSort(long[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            long ai = a[i];\n+        private enum FloatingPointBuilder implements Builder {\n+            NEGATIVE_ZERO_AND_NAN {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int k1 = a.length \/ (m + 1) * m     \/ 5;\n+                    int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+                    int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+                    int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n@@ -1127,2 +2986,16 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+                    for (int i = 0; i < k1; ++i) {\n+                        a[i] = (float) (-(a.length + m) + i);\n+                    }\n+                    for (int i = k1; i < k2; ++i) {\n+                        a[i] = -0.0f;\n+                    }\n+                    for (int i = k2; i < k3; ++i) {\n+                        a[i] = 0.0f;\n+                    }\n+                    for (int i = k3; i < k4; ++i) {\n+                        a[i] = (float) (m + i);\n+                    }\n+                    for (int i = k4; i < a.length; ++i) {\n+                        a[i] = Float.NaN;\n+                    }\n+                }\n@@ -1130,1 +3003,0 @@\n-            a[j + 1] = ai;\n@@ -1134,3 +3006,3 @@\n-    private void sortByInsertionSort(byte[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            byte ai = a[i];\n+    private static class DoubleHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final double A380 = (double) 0xA380;\n@@ -1138,6 +3010,2 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n+        \/\/ Constant to fill the right part of array\n+        private static final double B747 = (double) 0xB747;\n@@ -1145,3 +3013,4 @@\n-    private void sortByInsertionSort(char[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            char ai = a[i];\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private double[] gold;\n+        private double[] test;\n@@ -1149,4 +3018,2 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n+        private DoubleHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n@@ -1154,5 +3021,0 @@\n-    }\n-\n-    private void sortByInsertionSort(short[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            short ai = a[i];\n@@ -1160,4 +3022,4 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n+        private DoubleHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n@@ -1165,1 +3027,0 @@\n-    }\n@@ -1167,3 +3028,3 @@\n-    private void sortByInsertionSort(float[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            float ai = a[i];\n+        private void test(int length) {\n+            gold = new double[length];\n+            test = new double[length];\n@@ -1171,10 +3032,8 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(double[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            double ai = a[i];\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n@@ -1182,4 +3041,1 @@\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n+            out.println();\n@@ -1187,1 +3043,0 @@\n-    }\n@@ -1189,17 +3044,2 @@\n-    private void checkSubArray(Object a, int fromIndex, int toIndex) {\n-        if (a instanceof int[]) {\n-            checkSubArray((int[]) a, fromIndex, toIndex);\n-        } else if (a instanceof long[]) {\n-            checkSubArray((long[]) a, fromIndex, toIndex);\n-        } else if (a instanceof byte[]) {\n-            checkSubArray((byte[]) a, fromIndex, toIndex);\n-        } else if (a instanceof char[]) {\n-            checkSubArray((char[]) a, fromIndex, toIndex);\n-        } else if (a instanceof short[]) {\n-            checkSubArray((short[]) a, fromIndex, toIndex);\n-        } else if (a instanceof float[]) {\n-            checkSubArray((float[]) a, fromIndex, toIndex);\n-        } else if (a instanceof double[]) {\n-            checkSubArray((double[]) a, fromIndex, toIndex);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        private void testEmpty() {\n+            sortingHelper.sort(new double[test.length], 0, 0);\n@@ -1207,1 +3047,0 @@\n-    }\n@@ -1209,6 +3048,2 @@\n-    private void checkSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n+        private void testStructured() {\n+            testEmpty();\n@@ -1216,3 +3051,2 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            if (test.length < 512) {\n+                return;\n@@ -1220,5 +3054,8 @@\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n@@ -1227,1 +3064,0 @@\n-    }\n@@ -1229,4 +3065,3 @@\n-    private void checkSubArray(long[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (long) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n@@ -1234,0 +3069,4 @@\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -1236,4 +3075,6 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+            testNegativeZeroAndNaN();\n@@ -1242,4 +3083,3 @@\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (long) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n+        private void testAll() {\n+            testCore();\n+            testRange();\n@@ -1247,1 +3087,0 @@\n-    }\n@@ -1249,4 +3088,8 @@\n-    private void checkSubArray(byte[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (byte) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n@@ -1256,3 +3099,17 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n@@ -1262,3 +3119,3 @@\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (byte) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n@@ -1266,2 +3123,2 @@\n-        }\n-    }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -1269,4 +3126,8 @@\n-    private void checkSubArray(char[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (char) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n@@ -1276,5 +3137,3 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -1282,3 +3141,7 @@\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (char) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n@@ -1287,1 +3150,0 @@\n-    }\n@@ -1289,4 +3151,10 @@\n-    private void checkSubArray(short[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (short) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n@@ -1296,3 +3164,10 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+        private void testNegativeZeroAndNaN() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : FloatingPointBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    scramble();\n+                    print(\"negative zero and NaN\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    check(test, m);\n+                }\n@@ -1302,3 +3177,9 @@\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (short) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n@@ -1307,1 +3188,0 @@\n-    }\n@@ -1309,5 +3189,3 @@\n-    private void checkSubArray(float[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (float) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n-            }\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -1316,3 +3194,5 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+        private void checkSorted(double[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n@@ -1320,5 +3200,4 @@\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (float) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n@@ -1326,7 +3205,4 @@\n-        }\n-    }\n-\n-    private void checkSubArray(double[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (double) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n@@ -1336,3 +3212,3 @@\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+        private void checkCheckSum(double[] a, double[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n@@ -1340,5 +3216,2 @@\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (double) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n@@ -1347,1 +3220,0 @@\n-    }\n@@ -1349,19 +3221,2 @@\n-    private void checkRange(Object a, int m) {\n-        if (a instanceof int[]) {\n-            checkRange((int[]) a, m);\n-        } else if (a instanceof long[]) {\n-            checkRange((long[]) a, m);\n-        } else if (a instanceof byte[]) {\n-            checkRange((byte[]) a, m);\n-        } else if (a instanceof char[]) {\n-            checkRange((char[]) a, m);\n-        } else if (a instanceof short[]) {\n-            checkRange((short[]) a, m);\n-        } else if (a instanceof float[]) {\n-            checkRange((float[]) a, m);\n-        } else if (a instanceof double[]) {\n-            checkRange((double[]) a, m);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n+        private int checkSumXor(double[] a) {\n+            int checkSum = 0;\n@@ -1369,16 +3224,2 @@\n-    private void checkRange(int[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+            for (double e : a) {\n+                checkSum ^= (int) e;\n@@ -1386,0 +3227,1 @@\n+            return checkSum;\n@@ -1387,1 +3229,0 @@\n-    }\n@@ -1389,19 +3230,2 @@\n-    private void checkRange(long[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n+        private int checkSumPlus(double[] a) {\n+            int checkSum = 0;\n@@ -1409,16 +3233,2 @@\n-    private void checkRange(byte[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+            for (double e : a) {\n+                checkSum += (int) e;\n@@ -1426,0 +3236,1 @@\n+            return checkSum;\n@@ -1427,1 +3238,0 @@\n-    }\n@@ -1429,16 +3239,5 @@\n-    private void checkRange(char[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+        private void compare(double[] a, double[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n@@ -1447,1 +3246,0 @@\n-    }\n@@ -1449,17 +3247,2 @@\n-    private void checkRange(short[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n+        private void sortByInsertionSort(double[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -1467,1 +3250,0 @@\n-    }\n@@ -1469,16 +3251,3 @@\n-    private void checkRange(float[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n@@ -1486,19 +3255,5 @@\n-        }\n-    }\n-\n-    private void checkRange(double[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Double.NEGATIVE_INFINITY;\n@@ -1506,0 +3261,1 @@\n+            test = gold.clone();\n@@ -1507,1 +3263,0 @@\n-    }\n@@ -1509,7 +3264,2 @@\n-    private void copy(Object dst, Object src) {\n-        if (src instanceof float[]) {\n-            copy((float[]) dst, (float[]) src);\n-        } else if (src instanceof double[]) {\n-            copy((double[]) dst, (double[]) src);\n-        } else {\n-            fail(\"Unknown type of array: \" + src.getClass().getName());\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Double\", test.length, sortingHelper, m, builder);\n@@ -1517,5 +3267,0 @@\n-    }\n-\n-    private void copy(float[] dst, float[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n@@ -1523,26 +3268,2 @@\n-    private void copy(double[] dst, double[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n-    }\n-\n-    private void printTestName(String test, TestRandom random, int length) {\n-        printTestName(test, random, length, \"\");\n-    }\n-\n-    private void createData(int length) {\n-        gold = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n-\n-        test = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n-    }\n-\n-    private void convertData(int length) {\n-        for (int i = 1; i < gold.length; i++) {\n-            TypeConverter converter = TypeConverter.values()[i - 1];\n-            converter.convert((int[])gold[0], gold[i]);\n+        private static void swap(double[] a, int i, int j) {\n+            double t = a[i]; a[i] = a[j]; a[j] = t;\n@@ -1551,2 +3272,2 @@\n-        for (int i = 0; i < gold.length; i++) {\n-            System.arraycopy(gold[i], 0, test[i], 0, length);\n+        private static void reverse(double[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n@@ -1554,25 +3275,0 @@\n-    }\n-\n-    private String hex(long a, int b) {\n-        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\n-    }\n-\n-    private void printTestName(String test, TestRandom random, int length, String message) {\n-        out.println( \"[\" + sortingHelper + \"] '\" + test +\n-            \"' length = \" + length + \", random = \" + random + message);\n-    }\n-\n-    private static enum TypeConverter {\n-        LONG {\n-            void convert(int[] src, Object dst) {\n-                long[] b = (long[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (long) src[i];\n-                }\n-            }\n-        },\n-\n-        BYTE {\n-            void convert(int[] src, Object dst) {\n-                byte[] b = (byte[]) dst;\n@@ -1580,15 +3276,2 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (byte) src[i];\n-                }\n-            }\n-        },\n-\n-        CHAR {\n-            void convert(int[] src, Object dst) {\n-                char[] b = (char[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (char) src[i];\n-                }\n-            }\n-        },\n+        private void check(double[] a, int m) {\n+            final long NEGATIVE_ZERO = Double.doubleToLongBits(-0.0d);\n@@ -1596,9 +3279,4 @@\n-        SHORT {\n-            void convert(int[] src, Object dst) {\n-                short[] b = (short[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (short) src[i];\n-                }\n-            }\n-        },\n+            int k1 = a.length \/ (m + 1) * m     \/ 5;\n+            int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+            int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+            int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n@@ -1606,3 +3284,2 @@\n-        FLOAT {\n-            void convert(int[] src, Object dst) {\n-                float[] b = (float[]) dst;\n+            for (int i = 0; i < k1; ++i) {\n+                double v = (double) (-(a.length + m) + i);\n@@ -1610,2 +3287,2 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (float) src[i];\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n@@ -1614,8 +3291,3 @@\n-        },\n-\n-        DOUBLE {\n-            void convert(int[] src, Object dst) {\n-                double[] b = (double[]) dst;\n-\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (double) src[i];\n+            for (int i = k1; i < k2; ++i) {\n+                if (Double.doubleToLongBits(a[i]) != NEGATIVE_ZERO) {\n+                    fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n@@ -1624,14 +3296,3 @@\n-        };\n-\n-        abstract void convert(int[] src, Object dst);\n-    }\n-\n-    private static enum SortedBuilder {\n-        STEPS {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < m; i++) {\n-                    a[i] = 0;\n-                }\n-\n-                for (int i = m; i < a.length; i++) {\n-                    a[i] = 1;\n+            for (int i = k2; i < k3; ++i) {\n+                if (a[i] != 0.0d || Double.doubleToLongBits(a[i]) == NEGATIVE_ZERO) {\n+                    fail(\"There must be 0.0 instead of \" + a[i] + \" at position \" + i);\n@@ -1640,1 +3301,2 @@\n-        };\n+            for (int i = k3; i < k4; ++i) {\n+                double v = (double) (m + i);\n@@ -1642,8 +3304,2 @@\n-        abstract void build(int[] a, int m);\n-    }\n-\n-    private static enum UnsortedBuilder {\n-        RANDOM {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt();\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n@@ -1652,6 +3308,3 @@\n-        },\n-\n-        ASCENDING {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m + i;\n+            for (int i = k4; i < a.length; ++i) {\n+                if (!Double.isNaN(a[i])) {\n+                    fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n@@ -1660,1 +3313,1 @@\n-        },\n+        }\n@@ -1662,7 +3315,3 @@\n-        DESCENDING {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = a.length - m - i;\n-                }\n-            }\n-        },\n+        private interface Builder {\n+            void build(double[] a, int m);\n+        }\n@@ -1670,4 +3319,7 @@\n-        EQUAL {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m;\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (Math.min(i + m, 127));\n+                    }\n@@ -1675,9 +3327,1 @@\n-            }\n-        },\n-\n-        SAW {\n-            void build(int[] a, int m, Random random) {\n-                int incCount = 1;\n-                int decCount = a.length;\n-                int i = 0;\n-                int period = m--;\n+            },\n@@ -1685,6 +3329,5 @@\n-                while (true) {\n-                    for (int k = 1; k <= period; k++) {\n-                        if (i >= a.length) {\n-                            return;\n-                        }\n-                        a[i++] = incCount++;\n+            STEPS {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n@@ -1692,7 +3335,2 @@\n-                    period += m;\n-\n-                    for (int k = 1; k <= period; k++) {\n-                        if (i >= a.length) {\n-                            return;\n-                        }\n-                        a[i++] = decCount--;\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n@@ -1700,1 +3338,0 @@\n-                    period += m;\n@@ -1703,1 +3340,1 @@\n-        },\n+        }\n@@ -1705,4 +3342,7 @@\n-        REPEATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % m;\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) random.nextInt();\n+                    }\n@@ -1710,2 +3350,1 @@\n-            }\n-        },\n+            },\n@@ -1713,4 +3352,9 @@\n-        DUPLICATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt(m);\n+            PERMUTATION {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n@@ -1718,2 +3362,1 @@\n-            }\n-        },\n+            },\n@@ -1721,3 +3364,4 @@\n-        ORGAN_PIPES {\n-            void build(int[] a, int m, Random random) {\n-                int middle = a.length \/ (m + 1);\n+            UNIFORM {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int mask = (m << 15) - 1;\n@@ -1725,2 +3369,3 @@\n-                for (int i = 0; i < middle; i++) {\n-                    a[i] = i;\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (random.nextInt() & mask);\n+                    }\n@@ -1728,0 +3373,1 @@\n+            },\n@@ -1729,2 +3375,6 @@\n-                for (int i = middle; i < a.length; i++) {\n-                    a[i] = a.length - i - 1;\n+            REPEATED {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (i % m);\n+                    }\n@@ -1732,2 +3382,1 @@\n-            }\n-        },\n+            },\n@@ -1735,4 +3384,6 @@\n-        STAGGER {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = (i * m + i) % a.length;\n+            DUPLICATED {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) random.nextInt(m);\n+                    }\n@@ -1740,7 +3391,13 @@\n-            }\n-        },\n-\n-        PLATEAU {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = Math.min(i, m);\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (double) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (double) (--minus);\n+                        }\n+                    }\n@@ -1748,6 +3405,1 @@\n-            }\n-        },\n-\n-        SHUFFLE {\n-            void build(int[] a, int m, Random random) {\n-                int x = 0, y = 0;\n+            },\n@@ -1755,2 +3407,6 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n+            SHUFFLE {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (double) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n@@ -1759,6 +3415,1 @@\n-        },\n-\n-        LATCH {\n-            void build(int[] a, int m, Random random) {\n-                int max = a.length \/ m;\n-                max = max < 2 ? 2 : max;\n+        }\n@@ -1766,2 +3417,7 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % max;\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (m + i);\n+                    }\n@@ -1769,11 +3425,1 @@\n-            }\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n-    }\n-\n-    private static enum MergingBuilder {\n-        ASCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = 1, i = 0;\n+            },\n@@ -1781,5 +3427,5 @@\n-                for (int k = 0; k < m; k++) {\n-                    v = 1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v++;\n+            DESCENDING {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (a.length - m - i);\n@@ -1788,0 +3434,1 @@\n+            },\n@@ -1789,2 +3436,4 @@\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v++;\n+            EQUAL {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    Arrays.fill(a, (double) m);\n@@ -1792,0 +3441,1 @@\n+            },\n@@ -1793,8 +3443,8 @@\n-                a[a.length - 1] = 0;\n-            }\n-        },\n-\n-        DESCENDING {\n-            void build(int[] a, int m) {\n-                int period = a.length \/ m;\n-                int v = -1, i = 0;\n+            SHIFTED {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (i << 10);\n+                    }\n+                }\n+            },\n@@ -1802,2 +3452,4 @@\n-                for (int k = 0; k < m; k++) {\n-                    v = -1;\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n@@ -1805,2 +3457,5 @@\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v--;\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (double) (a.length - i - 1);\n@@ -1809,0 +3464,1 @@\n+            },\n@@ -1810,2 +3466,6 @@\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v--;\n+            PLATEAU {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) Math.min(i, m);\n+                    }\n@@ -1813,0 +3473,1 @@\n+            },\n@@ -1814,3 +3475,4 @@\n-                a[a.length - 1] = 0;\n-            }\n-        },\n+            LATCH {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n@@ -1818,4 +3480,3 @@\n-        POINT {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = 0;\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (i % max);\n+                    }\n@@ -1823,3 +3484,1 @@\n-                a[a.length \/ 2] = m;\n-            }\n-        },\n+            },\n@@ -1827,4 +3486,5 @@\n-        LINE {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i;\n+            POINT {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    Arrays.fill(a, (double) 0);\n+                    a[a.length \/ 2] = (double) m;\n@@ -1832,3 +3492,1 @@\n-                reverse(a, 0, a.length - 1);\n-            }\n-        },\n+            },\n@@ -1836,4 +3494,7 @@\n-        PEARL {\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i;\n+            LINE {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n@@ -1841,9 +3502,1 @@\n-                reverse(a, 0, 2);\n-            }\n-        },\n-\n-        RING {\n-            void build(int[] a, int m) {\n-                int k1 = a.length \/ 3;\n-                int k2 = a.length \/ 3 * 2;\n-                int level = a.length \/ 3;\n+            },\n@@ -1851,2 +3504,7 @@\n-                for (int i = 0, k = level; i < k1; i++) {\n-                    a[i] = k--;\n+            PEARL {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n@@ -1854,0 +3512,1 @@\n+            },\n@@ -1855,2 +3514,7 @@\n-                for (int i = k1; i < k2; i++) {\n-                    a[i] = 0;\n+            TRAPEZIUM {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n@@ -1858,0 +3522,1 @@\n+            },\n@@ -1859,2 +3524,6 @@\n-                for (int i = k2, k = level; i < a.length; i++) {\n-                    a[i] = k--;\n+            STAGGER {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) ((i * m + i) % a.length);\n+                    }\n@@ -1863,10 +3532,0 @@\n-        };\n-\n-        abstract void build(int[] a, int m);\n-\n-        private static void reverse(int[] a, int lo, int hi) {\n-            for (--hi; lo < hi; ) {\n-                int tmp = a[lo];\n-                a[lo++] = a[hi];\n-                a[hi--] = tmp;\n-            }\n@@ -1874,12 +3533,0 @@\n-    }\n-\n-    private static enum NegativeZeroBuilder {\n-        FLOAT {\n-            void build(Object o, Random random) {\n-                float[] a = (float[]) o;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? -0.0f : 0.0f;\n-                }\n-            }\n-        },\n@@ -1887,3 +3534,8 @@\n-        DOUBLE {\n-            void build(Object o, Random random) {\n-                double[] a = (double[]) o;\n+        private enum FloatingPointBuilder implements Builder {\n+            NEGATIVE_ZERO_AND_NAN {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int k1 = a.length \/ (m + 1) * m     \/ 5;\n+                    int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+                    int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+                    int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n@@ -1891,2 +3543,15 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? -0.0d : 0.0d;\n+                    for (int i = 0; i < k1; ++i) {\n+                        a[i] = (double) (-(a.length + m) + i);\n+                    }\n+                    for (int i = k1; i < k2; ++i) {\n+                        a[i] = -0.0d;\n+                    }\n+                    for (int i = k2; i < k3; ++i) {\n+                        a[i] = 0.0d;\n+                    }\n+                    for (int i = k3; i < k4; ++i) {\n+                        a[i] = (double) (m + i);\n+                    }\n+                    for (int i = k4; i < a.length; ++i) {\n+                        a[i] = Double.NaN;\n+                    }\n@@ -1895,64 +3560,0 @@\n-        };\n-\n-        abstract void build(Object o, Random random);\n-    }\n-\n-    private static enum FloatingPointBuilder {\n-        FLOAT {\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n-                float negativeValue = -random.nextFloat();\n-                float positiveValue =  random.nextFloat();\n-                float[] x = (float[]) o;\n-                int fromIndex = 0;\n-\n-                writeValue(x, negativeValue, fromIndex, n);\n-                fromIndex += n;\n-\n-                writeValue(x, -0.0f, fromIndex, g);\n-                fromIndex += g;\n-\n-                writeValue(x, 0.0f, fromIndex, z);\n-                fromIndex += z;\n-\n-                writeValue(x, positiveValue, fromIndex, p);\n-                fromIndex += p;\n-\n-                writeValue(x, Float.NaN, fromIndex, a);\n-            }\n-        },\n-\n-        DOUBLE {\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n-                double negativeValue = -random.nextFloat();\n-                double positiveValue =  random.nextFloat();\n-                double[] x = (double[]) o;\n-                int fromIndex = 0;\n-\n-                writeValue(x, negativeValue, fromIndex, n);\n-                fromIndex += n;\n-\n-                writeValue(x, -0.0d, fromIndex, g);\n-                fromIndex += g;\n-\n-                writeValue(x, 0.0d, fromIndex, z);\n-                fromIndex += z;\n-\n-                writeValue(x, positiveValue, fromIndex, p);\n-                fromIndex += p;\n-\n-                writeValue(x, Double.NaN, fromIndex, a);\n-            }\n-        };\n-\n-        abstract void build(Object o, int a, int g, int z, int n, int p, Random random);\n-\n-        private static void writeValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n-                a[i] = value;\n-            }\n-        }\n-\n-        private static void writeValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n-                a[i] = value;\n-            }\n@@ -1962,35 +3563,2 @@\n-    private static Comparator<Pair> pairComparator = new Comparator<Pair>() {\n-\n-        @Override\n-        public int compare(Pair p1, Pair p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n-    private static class Pair implements Comparable<Pair> {\n-\n-        private Pair(int key, int value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        int getKey() {\n-            return key;\n-        }\n-\n-        int getValue() {\n-            return value;\n-        }\n-\n-        @Override\n-        public int compareTo(Pair pair) {\n-            return Integer.compare(key, pair.key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"(\" + key + \", \" + value + \")\";\n-        }\n-\n-        private int key;\n-        private int value;\n+    private static void out(String name, String type, int length, SortingHelper sortingHelper, int m, Object builder) {\n+        out.println(\"[ \" + type + \" | Length = \" + length + \" | \" + sortingHelper + \" ] 'Test \" + name + \"', m = \" + m + \", \" + builder);\n@@ -1999,17 +3567,3 @@\n-    private static class TestRandom extends Random {\n-\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n-        private static final TestRandom DEDA = new TestRandom(0xDEDA);\n-        private static final TestRandom C0FFEE = new TestRandom(0xC0FFEE);\n-\n-        private TestRandom(long seed) {\n-            super(seed);\n-            this.seed = Long.toHexString(seed).toUpperCase();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return seed;\n-        }\n-\n-        private String seed;\n+    private static void fail(String message) {\n+        err.format(\"*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":3121,"deletions":1567,"binary":false,"changes":4688,"status":"modified"},{"patch":"@@ -0,0 +1,672 @@\n+#if[Common1]\n+\/*\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+\/*\n+ * @test\n+ * @compile\/module=java.base java\/util\/SortingHelper.java\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n+ * @build Sorting\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraySort,_arrayPartition Sorting -shortrun\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileCommand=CompileThresholdScaling,java.util.DualPivotQuicksort::sort,0.0001 Sorting -shortrun\n+ * @summary Exercise Arrays.sort, Arrays.parallelSort\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ * @author Jon Bentley\n+ * @author Josh Bloch\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.SortingHelper;\n+\n+public class Sorting {\n+\n+    private static final PrintStream out = System.out;\n+    private static final PrintStream err = System.err;\n+\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_LENGTHS =\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000 };\n+\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_LENGTHS =\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000, 64_000};\n+\n+    private static final Random random = new Random(0xC0FFEE);\n+\n+    public static void main(String[] args) {\n+        boolean shortRun = args.length > 0 && args[0].equals(\"-shortrun\");\n+        int[] lengths = shortRun ? SHORT_LENGTHS : LONG_LENGTHS;\n+        long start = System.currentTimeMillis();\n+\n+        for (int length : lengths) {\n+            new IntegerHolder().test(length);\n+            new LongHolder().test(length);\n+            new ByteHolder().test(length);\n+            new CharacterHolder().test(length);\n+            new ShortHolder().test(length);\n+            new FloatHolder().test(length);\n+            new DoubleHolder().test(length);\n+        }\n+        long end = System.currentTimeMillis();\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n+    }\n+#end[Common1]\n+#if[AllTypes]\n+\n+    private static class $Type$Holder {\n+        \/\/ Constant to fill the left part of array\n+        private static final $type$ A380 = ($type$) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final $type$ B747 = ($type$) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private $type$[] gold;\n+        private $type$[] test;\n+\n+        private $Type$Holder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private $Type$Holder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new $type$[length];\n+            test = new $type$[length];\n+\n+#if[IntLongFloatDouble]\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+#end[IntLongFloatDouble]\n+#if[AllTypes]\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+#end[AllTypes]\n+#if[IntLongFloatDouble]\n+            set(SortingHelper.HEAP_SORT).testBase();\n+#end[IntLongFloatDouble]\n+#if[ByteCharShort]\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+#end[ByteCharShort]\n+#if[AllTypes]\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+#end[AllTypes]\n+#if[IntLongFloatDouble]\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+#end[IntLongFloatDouble]\n+#if[AllTypes]\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+#end[AllTypes]\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new $type$[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+#if[FloatDouble]\n+            testNegativeZeroAndNaN();\n+#end[FloatDouble]\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+#if[FloatDouble]\n+        private void testNegativeZeroAndNaN() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : FloatingPointBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    scramble();\n+                    print(\"negative zero and NaN\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    check(test, m);\n+                }\n+            }\n+        }\n+\n+#end[FloatDouble]\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n+\n+        private void checkSorted($type$[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum($type$[] a, $type$[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n+\n+        private int checkSumXor($type$[] a) {\n+            int checkSum = 0;\n+\n+            for ($type$ e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus($type$[] a) {\n+            int checkSum = 0;\n+\n+            for ($type$ e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare($type$[] a, $type$[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private void sortByInsertionSort($type$[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = $Type$.{#if[!FloatDouble]?MIN_VALUE}{#if[FloatDouble]?NEGATIVE_INFINITY};\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"$Type$\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap($type$[] a, int i, int j) {\n+            $type$ t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse($type$[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+#if[FloatDouble]\n+        private void check($type$[] a, int m) {\n+            final {#if[Float]?int}{#if[Double]?long} NEGATIVE_ZERO = $Type$.{#if[Float]?floatToIntBits(-0.0f)}{#if[Double]?doubleToLongBits(-0.0d)};\n+\n+            int k1 = a.length \/ (m + 1) * m     \/ 5;\n+            int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+            int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+            int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n+\n+            for (int i = 0; i < k1; ++i) {\n+                $type$ v = ($type$) (-(a.length + m) + i);\n+\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k1; i < k2; ++i) {\n+                if ($Type$.{#if[Float]?floatToIntBits(a[i])}{#if[Double]?doubleToLongBits(a[i])} != NEGATIVE_ZERO) {\n+                    fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k2; i < k3; ++i) {\n+                if (a[i] != 0.0{#if[Float]?f}{#if[Double]?d} || $Type$.{#if[Float]?floatToIntBits(a[i])}{#if[Double]?doubleToLongBits(a[i])} == NEGATIVE_ZERO) {\n+                    fail(\"There must be 0.0 instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k3; i < k4; ++i) {\n+                $type$ v = ($type$) (m + i);\n+\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k4; i < a.length; ++i) {\n+                if (!$Type$.isNaN(a[i])) {\n+                    fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+#end[FloatDouble]\n+        private interface Builder {\n+            void build($type$[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = ($type$) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = ($type$) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = ($type$) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    Arrays.fill(a, ($type$) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = ($type$) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    Arrays.fill(a, ($type$) 0);\n+                    a[a.length \/ 2] = ($type$) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n+        }\n+#if[FloatDouble]\n+\n+        private enum FloatingPointBuilder implements Builder {\n+            NEGATIVE_ZERO_AND_NAN {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int k1 = a.length \/ (m + 1) * m     \/ 5;\n+                    int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+                    int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+                    int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n+\n+                    for (int i = 0; i < k1; ++i) {\n+                        a[i] = ($type$) (-(a.length + m) + i);\n+                    }\n+                    for (int i = k1; i < k2; ++i) {\n+                        a[i] = -0.0{#if[Float]?f}{#if[Double]?d};\n+                    }\n+                    for (int i = k2; i < k3; ++i) {\n+                        a[i] = 0.0{#if[Float]?f}{#if[Double]?d};\n+                    }\n+                    for (int i = k3; i < k4; ++i) {\n+                        a[i] = ($type$) (m + i);\n+                    }\n+                    for (int i = k4; i < a.length; ++i) {\n+                        a[i] = $Type$.NaN;\n+                    }\n+                }\n+            }\n+        }\n+#end[FloatDouble]\n+    }\n+#end[AllTypes]\n+#if[Common2]\n+\n+    private static void out(String name, String type, int length, SortingHelper sortingHelper, int m, Object builder) {\n+        out.println(\"[ \" + type + \" | Length = \" + length + \" | \" + sortingHelper + \" ] 'Test \" + name + \"', m = \" + m + \", \" + builder);\n+    }\n+\n+    private static void fail(String message) {\n+        err.format(\"*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n+    }\n+}\n+#end[Common2]\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java.template","additions":672,"deletions":0,"binary":false,"changes":672,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+#!\/bin\/bash\n+\n+javac -d . ..\/..\/..\/..\/..\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\n+\n+in=Sorting.java.template\n+out=Sorting.java\n+\n+rm -rf $out\n+\n+gen() {\n+    java build.tools.spp.Spp -nel -Dtype=$1 -DType=$2 -K$3 -K$4 -K$5 -K$6 -i$in -o$out\n+}\n+\n+gen \"\"     \"\"        Common1  \"\"                 \"\"                 \"\"\n+gen int    Integer   AllTypes IntLongFloatDouble IntLongFloatDouble \"\"\n+gen long   Long      AllTypes IntLongFloatDouble IntLongFloatDouble \"\"\n+gen byte   Byte      AllTypes ByteCharShort      \"\"                 \"\"\n+gen char   Character AllTypes ByteCharShort      \"\"                 \"\"\n+gen short  Short     AllTypes ByteCharShort      \"\"                 \"\"\n+gen float  Float     AllTypes IntLongFloatDouble FloatDouble        Float\n+gen double Double    AllTypes IntLongFloatDouble FloatDouble        Double\n+gen \"\"     \"\"        Common2  \"\"                 \"\"                 \"\"\n+\n+rm -rf build\n","filename":"test\/jdk\/java\/util\/Arrays\/gen-Sorting.sh","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * This class provides access to package-private\n- * methods of DualPivotQuicksort class.\n+ * This class provides access to package-private methods of DualPivotQuicksort class.\n@@ -32,1 +31,1 @@\n- * @version 2019.09.19\n+ * @version 2024.06.14\n@@ -34,1 +33,1 @@\n- * @since 14\n+ * @since 14 * 20 ^ 26\n@@ -38,2 +37,1 @@\n-    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\n-\n+    INSERTION_SORT(\"Insertion sort\") {\n@@ -41,17 +39,10 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.insertionSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.insertionSort(al, low, high);\n+                case byte[] ab -> DualPivotQuicksort.insertionSort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.insertionSort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.insertionSort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.insertionSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.insertionSort(ad, low, high);\n+                default -> fail(a);\n@@ -60,0 +51,1 @@\n+    },\n@@ -61,0 +53,1 @@\n+    MIXED_INSERTION_SORT(\"Mixed insertion sort\") {\n@@ -63,16 +56,6 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.mixedInsertionSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.mixedInsertionSort(al, low, high);\n+                case float[] af -> DualPivotQuicksort.mixedInsertionSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.mixedInsertionSort(ad, low, high);\n+                default -> fail(a);\n@@ -81,10 +64,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -93,2 +66,1 @@\n-    PARALLEL_SORT(\"Parallel sort\") {\n-\n+    MERGING_SORT(\"Merging sort\") {\n@@ -96,17 +68,7 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> checkMerging(DualPivotQuicksort.tryMergingSort(null, ai, low, high - low));\n+                case long[] al -> checkMerging(DualPivotQuicksort.tryMergingSort(null, al, low, high - low));\n+                case float[] af -> checkMerging(DualPivotQuicksort.tryMergingSort(null, af, low, high - low));\n+                case double[] ad -> checkMerging(DualPivotQuicksort.tryMergingSort(null, ad, low, high - low));\n+                default -> fail(a);\n@@ -115,0 +77,1 @@\n+    },\n@@ -116,0 +79,1 @@\n+    COUNTING_SORT(\"Counting sort\") {\n@@ -118,16 +82,5 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case byte[] ab -> DualPivotQuicksort.countingSort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.countingSort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.countingSort(as, low, high);\n+                default -> fail(a);\n@@ -136,10 +89,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -149,1 +92,0 @@\n-\n@@ -151,17 +93,7 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.heapSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.heapSort(al, low, high);\n+                case float[] af -> DualPivotQuicksort.heapSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.heapSort(ad, low, high);\n+                default -> fail(a);\n@@ -170,0 +102,1 @@\n+    },\n@@ -171,0 +104,1 @@\n+    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\n@@ -173,16 +107,9 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, 0, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, 0, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, 0, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, 0, low, high);\n+                default -> fail(a);\n@@ -191,10 +118,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -203,2 +120,1 @@\n-    ARRAYS_SORT(\"Arrays.sort\") {\n-\n+    PARALLEL_QUICKSORT(\"Parallel Quicksort\") {\n@@ -206,17 +122,7 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, 4, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, 4, low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, 4, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, 4, low, high);\n+                default -> fail(a);\n@@ -225,0 +131,1 @@\n+    },\n@@ -226,0 +133,1 @@\n+    ARRAYS_SORT(\"Arrays.sort\") {\n@@ -228,16 +136,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.sort(ai, low, high);\n+                case long[] al -> Arrays.sort(al, low, high);\n+                case byte[] ab -> Arrays.sort(ab, low, high);\n+                case char[] ac -> Arrays.sort(ac, low, high);\n+                case short[] as -> Arrays.sort(as, low, high);\n+                case float[] af -> Arrays.sort(af, low, high);\n+                case double[] ad -> Arrays.sort(ad, low, high);\n+                default -> fail(a);\n@@ -246,11 +147,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            Arrays.sort(a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.sort(a, comparator);\n-        }\n@@ -260,22 +150,0 @@\n-\n-        @Override\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a);\n-            } else {\n-                fail(a);\n-            }\n-        }\n-\n@@ -284,16 +152,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.parallelSort(ai, low, high);\n+                case long[] al -> Arrays.parallelSort(al, low, high);\n+                case byte[] ab -> Arrays.parallelSort(ab, low, high);\n+                case char[] ac -> Arrays.parallelSort(ac, low, high);\n+                case short[] as -> Arrays.parallelSort(as, low, high);\n+                case float[] af -> Arrays.parallelSort(af, low, high);\n+                case double[] ad -> Arrays.parallelSort(ad, low, high);\n+                default -> fail(a);\n@@ -302,12 +163,0 @@\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a) {\n-            Arrays.parallelSort((Comparable[]) a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.parallelSort(a, comparator);\n-        }\n@@ -316,9 +165,1 @@\n-    abstract public void sort(Object a);\n-\n-    abstract public void sort(Object a, int low, int high);\n-\n-    abstract public void sort(Object[] a);\n-\n-    abstract public void sort(Object[] a, Comparator comparator);\n-\n-    private SortingHelper(String name) {\n+    SortingHelper(String name) {\n@@ -328,0 +169,2 @@\n+    public abstract void sort(Object a, int low, int high);\n+\n@@ -333,2 +176,4 @@\n-    private static void fail(Object a) {\n-        throw new RuntimeException(\"Unexpected type of array: \" + a.getClass().getName());\n+    private static void checkMerging(boolean result) {\n+        if (!result) {\n+            fail(\"Merging sort must return true\");\n+        }\n@@ -337,1 +182,3 @@\n-    private String name;\n+    private static void fail(Object a) {\n+        fail(\"Unknown array: \" + a.getClass().getName());\n+    }\n@@ -339,5 +186,3 @@\n-    \/**\n-     * Parallelism level for sequential and parallel sorting.\n-     *\/\n-    private static final int SEQUENTIAL = 0;\n-    private static final int PARALLEL = 87;\n+    private static void fail(String message) {\n+        throw new RuntimeException(message);\n+    }\n@@ -345,5 +190,1 @@\n-    \/**\n-     * Heap sort will be invoked, if recursion depth is too big.\n-     * Value is taken from DualPivotQuicksort.MAX_RECURSION_DEPTH.\n-     *\/\n-    private static final int BIG_DEPTH = 64 * (3 << 1);\n+    private final String name;\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":98,"deletions":257,"binary":false,"changes":355,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,6 @@\n-package org.openjdk.bench.java.lang;\n+\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n@@ -28,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -30,1 +36,0 @@\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n@@ -36,1 +41,0 @@\n-import org.openjdk.jmh.annotations.Level;\n@@ -38,8 +42,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n-import java.util.Arrays;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-import java.io.UnsupportedEncodingException;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n@@ -48,1 +44,7 @@\n- * Performance test of Arrays.sort() methods\n+ * Microbenchmarking of Arrays.sort() and Arrays.parallelSort().\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ *\n+ * @version 2024.06.14\n+ *\n+ * @since 26\n@@ -50,1 +52,1 @@\n-@Fork(value=1, jvmArgs={\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n+@State(Scope.Benchmark)\n@@ -53,3 +55,3 @@\n-@State(Scope.Thread)\n-@Warmup(iterations = 3, time=5)\n-@Measurement(iterations = 3, time=3)\n+@Warmup(iterations = 2, time = 4, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n@@ -58,43 +60,9 @@\n-    @Param({\"10\",\"25\",\"50\",\"75\",\"100\", \"1000\", \"10000\", \"100000\", \"1000000\"})\n-    private int size;\n-\n-    private int[] ints_unsorted;\n-    private long[] longs_unsorted;\n-    private float[] floats_unsorted;\n-    private double[] doubles_unsorted;\n-\n-    private int[] ints_sorted;\n-    private long[] longs_sorted;\n-    private float[] floats_sorted;\n-    private double[] doubles_sorted;\n-\n-\n-    public void initialize() {\n-        Random rnd = new Random(42);\n-\n-        ints_unsorted = new int[size];\n-        longs_unsorted = new long[size];\n-        floats_unsorted = new float[size];\n-        doubles_unsorted = new double[size];\n-\n-        int[] intSpecialCases = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n-        long[] longSpecialCases = {Long.MIN_VALUE, Long.MAX_VALUE};\n-        float[] floatSpecialCases = {+0.0f, -0.0f, Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NaN};\n-        double[] doubleSpecialCases = {+0.0, -0.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN};\n-\n-        for (int i = 0; i < size; i++) {\n-            ints_unsorted[i] = rnd.nextInt();\n-            longs_unsorted[i] = rnd.nextLong();\n-            if (i % 10 != 0) {\n-                ints_unsorted[i] = rnd.nextInt();\n-                longs_unsorted[i] = rnd.nextLong();\n-                floats_unsorted[i] = rnd.nextFloat();\n-                doubles_unsorted[i] = rnd.nextDouble();\n-            } else {\n-                ints_unsorted[i] = intSpecialCases[rnd.nextInt(intSpecialCases.length)];\n-                longs_unsorted[i] = longSpecialCases[rnd.nextInt(longSpecialCases.length)];\n-                floats_unsorted[i] = floatSpecialCases[rnd.nextInt(floatSpecialCases.length)];\n-                doubles_unsorted[i] = doubleSpecialCases[rnd.nextInt(doubleSpecialCases.length)];\n-            }\n-        }\n-    }\n+    private static final int PARALLELISM = java.util.concurrent.ForkJoinPool.getCommonPoolParallelism();\n+\n+    @Param({ \"600\", \"3000\", \"40000\", \"800000\", \"5000000\" })\n+    int size;\n+\n+    @Param\n+    Builder builder;\n+\n+    int[] b;\n@@ -103,2 +71,2 @@\n-    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-        initialize();\n+    public void init() {\n+        b = new int[size];\n@@ -107,7 +75,1 @@\n-    @Setup(Level.Invocation)\n-    public void clear() {\n-        ints_sorted = ints_unsorted.clone();\n-        longs_sorted = longs_unsorted.clone();\n-        floats_sorted = floats_unsorted.clone();\n-        doubles_sorted = doubles_unsorted.clone();\n-    }\n+    public enum Builder {\n@@ -115,5 +77,10 @@\n-    @Benchmark\n-    public int[] intSort() throws Throwable {\n-        Arrays.sort(ints_sorted);\n-        return ints_sorted;\n-    }\n+        REPEATED {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x111);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt(5);\n+                }\n+            }\n+        },\n@@ -121,4 +88,32 @@\n-    @Benchmark\n-    public int[] intParallelSort() throws Throwable {\n-        Arrays.parallelSort(ints_sorted);\n-        return ints_sorted;\n+        STAGGER {\n+            @Override\n+            void build(int[] b) {\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = (i * 8) % b.length;\n+                }\n+            }\n+        },\n+\n+        SHUFFLE {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x999);\n+\n+                for (int i = 0, j = 0, k = 1; i < b.length; ++i) {\n+                    b[i] = random.nextInt(11) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        },\n+\n+        RANDOM {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x777);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt();\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] b);\n@@ -127,4 +122,16 @@\n-    @Benchmark\n-    public long[] longSort() throws Throwable {\n-        Arrays.sort(longs_sorted);\n-        return longs_sorted;\n+    public static class Int extends ArraysSort {\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(b);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(b);\n+        }\n@@ -133,4 +140,26 @@\n-    @Benchmark\n-    public long[] longParallelSort() throws Throwable {\n-        Arrays.parallelSort(longs_sorted);\n-        return longs_sorted;\n+    public static class Long extends ArraysSort {\n+        long[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new long[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -139,4 +168,21 @@\n-    @Benchmark\n-    public float[] floatSort() throws Throwable {\n-        Arrays.sort(floats_sorted);\n-        return floats_sorted;\n+    public static class Short extends ArraysSort {\n+        short[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new short[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (short) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -145,4 +191,21 @@\n-    @Benchmark\n-    public float[] floatParallelSort() throws Throwable {\n-        Arrays.parallelSort(floats_sorted);\n-        return floats_sorted;\n+    public static class Byte extends ArraysSort {\n+        byte[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new byte[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (byte) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -151,4 +214,21 @@\n-    @Benchmark\n-    public double[] doubleSort() throws Throwable {\n-        Arrays.sort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Char extends ArraysSort {\n+        char[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new char[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (char) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -157,4 +237,26 @@\n-    @Benchmark\n-    public double[] doubleParallelSort() throws Throwable {\n-        Arrays.parallelSort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Float extends ArraysSort {\n+        float[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new float[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -163,0 +265,27 @@\n+    public static class Double extends ArraysSort {\n+        double[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new double[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":231,"deletions":102,"binary":false,"changes":333,"status":"modified"}]}