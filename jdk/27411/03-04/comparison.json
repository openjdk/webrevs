{"files":[{"patch":"@@ -45,42 +45,1 @@\n- * sorting algorithm depends on the data type and array size.<p>\n- *\n- * <b>Type: int\/long\/float\/double<\/b><p>\n- *\n- * If the array size is small, invoke mixed insertion sort on non-leftmost\n- * parts or insertion sort on leftmost part.<p>\n- *\n- * Then try merging sort which is the best on almost sorted arrays.<p>\n- *\n- * On the next step check the recursion depth to avoid quadratic time\n- * with heap sort.<p>\n- *\n- * Then apply Quicksort with two pivots on random data, otherwise\n- * run one-pivot Quicksort.<p>\n- *\n- * <b>Type: float\/double<\/b><p>\n- *\n- * Floating-point values require additional steps to process\n- * negative zeros -0.0 and NaNs (Not-a-Number) before sorting and\n- * re-arrange negative zeros at the end.<p>\n- *\n- * <b>Type: byte<\/b><p>\n- *\n- * Invoke insertion sort, if the array size is small, otherwise switch\n- * to counting sort.<p>\n- *\n- * <b>Type: char\/short<\/b><p>\n- *\n- * Invoke counting sort on large array, otherwise run insertion sort\n- * on small array.<p>\n- *\n- * On the next step check the recursion depth to avoid quadratic time\n- * with counting sort.<p>\n- *\n- * Then apply Quicksort with two pivots on random data, otherwise\n- * run one-pivot Quicksort.<p>\n- *\n- * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n- *\n- * If the array size is small, sequential sort is run. Otherwise\n- * invoke parallel merge sort (the recursion depth depends on\n- * parallelism level), then run parallel Quicksort.\n+ * sorting algorithm depends on the data type and array size.\n@@ -100,1 +59,43 @@\n-     * Prevents instantiation.\n+     * <b>High-level description of sorting logic.<\/b><p>\n+     *\n+     * <b>Type: int\/long\/float\/double<\/b><p>\n+     *\n+     * If the array size is small, invoke mixed insertion sort on\n+     * non-leftmost parts or insertion sort on leftmost part.<p>\n+     *\n+     * Then try merging sort which is the best on almost\n+     * sorted arrays.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with heap sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Type: float\/double<\/b><p>\n+     *\n+     * Floating-point values require additional steps to process\n+     * negative zeros -0.0 and NaNs (Not-a-Number) and re-arrange\n+     * negative zeros at the end.<p>\n+     *\n+     * <b>Type: byte<\/b><p>\n+     *\n+     * Invoke insertion sort, if the array size is small,\n+     * otherwise switch to counting sort.<p>\n+     *\n+     * <b>Type: char\/short<\/b><p>\n+     *\n+     * Invoke counting sort on large array, otherwise run\n+     * insertion sort on small array.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with counting sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+     *\n+     * If the array size is small, sequential sort is run.\n+     * Otherwise invoke parallel merge sort (the recursion depth\n+     * depends on parallelism level), then run parallel Quicksort.\n@@ -104,1 +105,1 @@\n-    \/* --------------------- Insertion sort --------------------- *\/\n+    \/* ----------------------- Insertion sort ----------------------- *\/\n@@ -111,1 +112,1 @@\n-    \/* ---------------------- Merging sort ---------------------- *\/\n+    \/* ------------------------ Merging sort ------------------------ *\/\n@@ -128,1 +129,1 @@\n-    \/* ---------------------- Digital sort ---------------------- *\/\n+    \/* ------------------------ Digital sort ------------------------ *\/\n@@ -140,1 +141,1 @@\n-    \/* --------------------- Parallel sort ---------------------- *\/\n+    \/* ----------------------- Parallel sort ------------------------ *\/\n@@ -147,1 +148,1 @@\n-    \/* --------------------- Infrastructure --------------------- *\/\n+    \/* ----------------------- Infrastructure ----------------------- *\/\n@@ -302,1 +303,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n@@ -398,4 +399,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n-                    sorter.fork(bits | 1, indices[1] + 1, high);\n-                } else {\n+                if (sorter == null) {\n@@ -404,0 +402,3 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -416,3 +417,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[1], high);\n-                } else {\n+                if (sorter == null) {\n@@ -420,0 +419,2 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -856,1 +857,1 @@\n-        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n@@ -878,1 +879,3 @@\n-        while (true) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n+\n@@ -883,3 +886,0 @@\n-                int lo = lo1; lo1 = lo2; lo2 = lo;\n-                int hi = hi1; hi1 = hi2; hi2 = hi;\n-            }\n@@ -887,6 +887,6 @@\n-            \/*\n-             * Merge the small parts sequentially.\n-             *\/\n-            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n-                break;\n-            }\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                int key = src[mi2];\n@@ -894,6 +894,5 @@\n-            \/*\n-             * Find the median of the larger part.\n-             *\/\n-            int mi1 = (lo1 + hi1) >>> 1;\n-            int mi2 = hi2;\n-            int key = src[mi1];\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n@@ -901,5 +900,7 @@\n-            \/*\n-             * Split the smaller part.\n-             *\/\n-            for (int mi0 = lo2; mi0 < mi2; ) {\n-                int mid = (mi0 + mi2) >>> 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n+                }\n+            } else {\n@@ -907,4 +908,18 @@\n-                if (key > src[mid]) {\n-                    mi0 = mid + 1;\n-                } else {\n-                    mi2 = mid;\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                int key = src[mi1];\n+\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi2 = mid;\n+                    }\n@@ -920,1 +935,1 @@\n-             * Reserve space for the second parts.\n+             * Skip the first parts.\n@@ -932,1 +947,1 @@\n-         * Check if the array is already ordered and then merge the parts.\n+         * Merge the small parts sequentially.\n@@ -934,6 +949,1 @@\n-        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n-            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n-        } else {\n-            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n-            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n-        }\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -956,3 +966,4 @@\n-        if (src[hi1 - 1] < src[hi2 - 1]) {\n-            while (lo1 < hi1) {\n-                int next = src[lo1];\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    int next = src[lo1];\n@@ -960,5 +971,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -966,4 +978,3 @@\n-            }\n-        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n-            while (lo2 < hi2) {\n-                int next = src[lo1];\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    int next = src[lo1];\n@@ -971,5 +982,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -977,4 +989,3 @@\n-            }\n-        } else {\n-            while (lo1 < hi1 && lo2 < hi2) {\n-                int next = src[lo1];\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    int next = src[lo1];\n@@ -982,5 +993,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -995,1 +1007,1 @@\n-        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -1093,1 +1105,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n@@ -1189,4 +1201,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n-                    sorter.fork(bits | 1, indices[1] + 1, high);\n-                } else {\n+                if (sorter == null) {\n@@ -1195,0 +1204,3 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -1207,3 +1219,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[1], high);\n-                } else {\n+                if (sorter == null) {\n@@ -1211,0 +1221,2 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -1647,1 +1659,1 @@\n-        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n@@ -1669,1 +1681,3 @@\n-        while (true) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n+\n@@ -1674,3 +1688,0 @@\n-                int lo = lo1; lo1 = lo2; lo2 = lo;\n-                int hi = hi1; hi1 = hi2; hi2 = hi;\n-            }\n@@ -1678,6 +1689,6 @@\n-            \/*\n-             * Merge the small parts sequentially.\n-             *\/\n-            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n-                break;\n-            }\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                long key = src[mi2];\n@@ -1685,6 +1696,5 @@\n-            \/*\n-             * Find the median of the larger part.\n-             *\/\n-            int mi1 = (lo1 + hi1) >>> 1;\n-            int mi2 = hi2;\n-            long key = src[mi1];\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n@@ -1692,5 +1702,7 @@\n-            \/*\n-             * Split the smaller part.\n-             *\/\n-            for (int mi0 = lo2; mi0 < mi2; ) {\n-                int mid = (mi0 + mi2) >>> 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n+                }\n+            } else {\n@@ -1698,4 +1710,18 @@\n-                if (key > src[mid]) {\n-                    mi0 = mid + 1;\n-                } else {\n-                    mi2 = mid;\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                long key = src[mi1];\n+\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi2 = mid;\n+                    }\n@@ -1711,1 +1737,1 @@\n-             * Reserve space for the second parts.\n+             * Skip the first parts.\n@@ -1723,1 +1749,1 @@\n-         * Check if the array is already ordered and then merge the parts.\n+         * Merge the small parts sequentially.\n@@ -1725,6 +1751,1 @@\n-        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n-            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n-        } else {\n-            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n-            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n-        }\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -1747,3 +1768,4 @@\n-        if (src[hi1 - 1] < src[hi2 - 1]) {\n-            while (lo1 < hi1) {\n-                long next = src[lo1];\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    long next = src[lo1];\n@@ -1751,5 +1773,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -1757,4 +1780,3 @@\n-            }\n-        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n-            while (lo2 < hi2) {\n-                long next = src[lo1];\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    long next = src[lo1];\n@@ -1762,5 +1784,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -1768,4 +1791,3 @@\n-            }\n-        } else {\n-            while (lo1 < hi1 && lo2 < hi2) {\n-                long next = src[lo1];\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    long next = src[lo1];\n@@ -1773,5 +1795,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -1786,1 +1809,1 @@\n-        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -1929,1 +1952,1 @@\n-    private static void sort(char[] a, int bits, int low, int high) {\n+    static void sort(char[] a, int bits, int low, int high) {\n@@ -2343,1 +2366,1 @@\n-    private static void sort(short[] a, int bits, int low, int high) {\n+    static void sort(short[] a, int bits, int low, int high) {\n@@ -2838,1 +2861,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n@@ -2934,4 +2957,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n-                    sorter.fork(bits | 1, indices[1] + 1, high);\n-                } else {\n+                if (sorter == null) {\n@@ -2940,0 +2960,3 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -2952,3 +2975,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[1], high);\n-                } else {\n+                if (sorter == null) {\n@@ -2956,0 +2977,2 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -3392,1 +3415,1 @@\n-        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n@@ -3414,1 +3437,3 @@\n-        while (true) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n+\n@@ -3419,3 +3444,0 @@\n-                int lo = lo1; lo1 = lo2; lo2 = lo;\n-                int hi = hi1; hi1 = hi2; hi2 = hi;\n-            }\n@@ -3423,6 +3445,6 @@\n-            \/*\n-             * Merge the small parts sequentially.\n-             *\/\n-            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n-                break;\n-            }\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                float key = src[mi2];\n@@ -3430,6 +3452,5 @@\n-            \/*\n-             * Find the median of the larger part.\n-             *\/\n-            int mi1 = (lo1 + hi1) >>> 1;\n-            int mi2 = hi2;\n-            float key = src[mi1];\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n@@ -3437,5 +3458,7 @@\n-            \/*\n-             * Split the smaller part.\n-             *\/\n-            for (int mi0 = lo2; mi0 < mi2; ) {\n-                int mid = (mi0 + mi2) >>> 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n+                }\n+            } else {\n@@ -3443,4 +3466,18 @@\n-                if (key > src[mid]) {\n-                    mi0 = mid + 1;\n-                } else {\n-                    mi2 = mid;\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                float key = src[mi1];\n+\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi2 = mid;\n+                    }\n@@ -3456,1 +3493,1 @@\n-             * Reserve space for the second parts.\n+             * Skip the first parts.\n@@ -3468,1 +3505,1 @@\n-         * Check if the array is already ordered and then merge the parts.\n+         * Merge the small parts sequentially.\n@@ -3470,6 +3507,1 @@\n-        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n-            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n-        } else {\n-            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n-            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n-        }\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -3492,3 +3524,4 @@\n-        if (src[hi1 - 1] < src[hi2 - 1]) {\n-            while (lo1 < hi1) {\n-                float next = src[lo1];\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    float next = src[lo1];\n@@ -3496,5 +3529,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -3502,4 +3536,3 @@\n-            }\n-        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n-            while (lo2 < hi2) {\n-                float next = src[lo1];\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    float next = src[lo1];\n@@ -3507,5 +3540,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -3513,4 +3547,3 @@\n-            }\n-        } else {\n-            while (lo1 < hi1 && lo2 < hi2) {\n-                float next = src[lo1];\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    float next = src[lo1];\n@@ -3518,5 +3551,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -3531,1 +3565,1 @@\n-        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -3686,1 +3720,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n@@ -3782,4 +3816,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n-                    sorter.fork(bits | 1, indices[1] + 1, high);\n-                } else {\n+                if (sorter == null) {\n@@ -3788,0 +3819,3 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -3800,3 +3834,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[1], high);\n-                } else {\n+                if (sorter == null) {\n@@ -3804,0 +3836,2 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -4240,1 +4274,1 @@\n-        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n@@ -4262,1 +4296,3 @@\n-        while (true) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n+\n@@ -4267,3 +4303,0 @@\n-                int lo = lo1; lo1 = lo2; lo2 = lo;\n-                int hi = hi1; hi1 = hi2; hi2 = hi;\n-            }\n@@ -4271,6 +4304,6 @@\n-            \/*\n-             * Merge the small parts sequentially.\n-             *\/\n-            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n-                break;\n-            }\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                double key = src[mi2];\n@@ -4278,6 +4311,5 @@\n-            \/*\n-             * Find the median of the larger part.\n-             *\/\n-            int mi1 = (lo1 + hi1) >>> 1;\n-            int mi2 = hi2;\n-            double key = src[mi1];\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n@@ -4285,5 +4317,7 @@\n-            \/*\n-             * Split the smaller part.\n-             *\/\n-            for (int mi0 = lo2; mi0 < mi2; ) {\n-                int mid = (mi0 + mi2) >>> 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n+                }\n+            } else {\n@@ -4291,4 +4325,18 @@\n-                if (key > src[mid]) {\n-                    mi0 = mid + 1;\n-                } else {\n-                    mi2 = mid;\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                double key = src[mi1];\n+\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi2 = mid;\n+                    }\n@@ -4304,1 +4352,1 @@\n-             * Reserve space for the second parts.\n+             * Skip the first parts.\n@@ -4316,1 +4364,1 @@\n-         * Check if the array is already ordered and then merge the parts.\n+         * Merge the small parts sequentially.\n@@ -4318,6 +4366,1 @@\n-        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n-            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n-        } else {\n-            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n-            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n-        }\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -4340,3 +4383,4 @@\n-        if (src[hi1 - 1] < src[hi2 - 1]) {\n-            while (lo1 < hi1) {\n-                double next = src[lo1];\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    double next = src[lo1];\n@@ -4344,5 +4388,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -4350,4 +4395,3 @@\n-            }\n-        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n-            while (lo2 < hi2) {\n-                double next = src[lo1];\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    double next = src[lo1];\n@@ -4355,5 +4399,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -4361,4 +4406,3 @@\n-            }\n-        } else {\n-            while (lo1 < hi1 && lo2 < hi2) {\n-                double next = src[lo1];\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    double next = src[lo1];\n@@ -4366,5 +4410,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -4379,1 +4424,1 @@\n-        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -4439,0 +4484,3 @@\n+            if (c == 0) {\n+                continue;\n+            }\n@@ -4442,3 +4490,1 @@\n-            if (c > 0) {\n-                break;\n-            }\n+            break;\n@@ -4534,2 +4580,12 @@\n-            addToPendingCount(1);\n-            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+            if (high - low < MIN_PARALLEL_SORT_SIZE) {\n+                switch(a) {\n+                    case int[] ai -> sort(null, ai, depth, low, high);\n+                    case long[] al -> sort(null, al, depth, low, high);\n+                    case float[] af -> sort(null, af, depth, low, high);\n+                    case double[] ad -> sort(null, ad, depth, low, high);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+                }\n+            } else {\n+                addToPendingCount(1);\n+                new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":387,"deletions":331,"binary":false,"changes":718,"status":"modified"},{"patch":"@@ -46,42 +46,1 @@\n- * sorting algorithm depends on the data type and array size.<p>\n- *\n- * <b>Type: int\/long\/float\/double<\/b><p>\n- *\n- * If the array size is small, invoke mixed insertion sort on non-leftmost\n- * parts or insertion sort on leftmost part.<p>\n- *\n- * Then try merging sort which is the best on almost sorted arrays.<p>\n- *\n- * On the next step check the recursion depth to avoid quadratic time\n- * with heap sort.<p>\n- *\n- * Then apply Quicksort with two pivots on random data, otherwise\n- * run one-pivot Quicksort.<p>\n- *\n- * <b>Type: float\/double<\/b><p>\n- *\n- * Floating-point values require additional steps to process\n- * negative zeros -0.0 and NaNs (Not-a-Number) before sorting and\n- * re-arrange negative zeros at the end.<p>\n- *\n- * <b>Type: byte<\/b><p>\n- *\n- * Invoke insertion sort, if the array size is small, otherwise switch\n- * to counting sort.<p>\n- *\n- * <b>Type: char\/short<\/b><p>\n- *\n- * Invoke counting sort on large array, otherwise run insertion sort\n- * on small array.<p>\n- *\n- * On the next step check the recursion depth to avoid quadratic time\n- * with counting sort.<p>\n- *\n- * Then apply Quicksort with two pivots on random data, otherwise\n- * run one-pivot Quicksort.<p>\n- *\n- * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n- *\n- * If the array size is small, sequential sort is run. Otherwise\n- * invoke parallel merge sort (the recursion depth depends on\n- * parallelism level), then run parallel Quicksort.\n+ * sorting algorithm depends on the data type and array size.\n@@ -101,1 +60,43 @@\n-     * Prevents instantiation.\n+     * <b>High-level description of sorting logic.<\/b><p>\n+     *\n+     * <b>Type: int\/long\/float\/double<\/b><p>\n+     *\n+     * If the array size is small, invoke mixed insertion sort on\n+     * non-leftmost parts or insertion sort on leftmost part.<p>\n+     *\n+     * Then try merging sort which is the best on almost\n+     * sorted arrays.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with heap sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Type: float\/double<\/b><p>\n+     *\n+     * Floating-point values require additional steps to process\n+     * negative zeros -0.0 and NaNs (Not-a-Number) and re-arrange\n+     * negative zeros at the end.<p>\n+     *\n+     * <b>Type: byte<\/b><p>\n+     *\n+     * Invoke insertion sort, if the array size is small,\n+     * otherwise switch to counting sort.<p>\n+     *\n+     * <b>Type: char\/short<\/b><p>\n+     *\n+     * Invoke counting sort on large array, otherwise run\n+     * insertion sort on small array.<p>\n+     *\n+     * Then check the recursion depth to avoid quadratic time\n+     * with counting sort.<p>\n+     *\n+     * Then apply Quicksort with two pivots on random data,\n+     * otherwise run one-pivot Quicksort.<p>\n+     *\n+     * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+     *\n+     * If the array size is small, sequential sort is run.\n+     * Otherwise invoke parallel merge sort (the recursion depth\n+     * depends on parallelism level), then run parallel Quicksort.\n@@ -105,1 +106,1 @@\n-    \/* --------------------- Insertion sort --------------------- *\/\n+    \/* ----------------------- Insertion sort ----------------------- *\/\n@@ -112,1 +113,1 @@\n-    \/* ---------------------- Merging sort ---------------------- *\/\n+    \/* ------------------------ Merging sort ------------------------ *\/\n@@ -129,1 +130,1 @@\n-    \/* ---------------------- Digital sort ---------------------- *\/\n+    \/* ------------------------ Digital sort ------------------------ *\/\n@@ -141,1 +142,1 @@\n-    \/* --------------------- Parallel sort ---------------------- *\/\n+    \/* ----------------------- Parallel sort ------------------------ *\/\n@@ -148,1 +149,1 @@\n-    \/* --------------------- Infrastructure --------------------- *\/\n+    \/* ----------------------- Infrastructure ----------------------- *\/\n@@ -252,2 +253,1 @@\n-#if[!Common1]\n-#if[!Common2]\n+#if[AllTypes]\n@@ -256,2 +256,1 @@\n-#end[Common2]\n-#end[Common1]\n+#end[AllTypes]\n@@ -428,1 +427,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 3) {\n@@ -524,4 +523,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n-                    sorter.fork(bits | 1, indices[1] + 1, high);\n-                } else {\n+                if (sorter == null) {\n@@ -530,0 +526,3 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -542,3 +541,1 @@\n-                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n-                    sorter.fork(bits | 1, indices[1], high);\n-                } else {\n+                if (sorter == null) {\n@@ -546,0 +543,2 @@\n+                } else {\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -563,1 +562,1 @@\n-    private static void sort($type$[] a, int bits, int low, int high) {\n+    static void sort($type$[] a, int bits, int low, int high) {\n@@ -1112,1 +1111,1 @@\n-        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+        if (hi2 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n@@ -1134,1 +1133,3 @@\n-        while (true) {\n+        while (hi2 - lo2 + hi1 - lo1 > MIN_PARALLEL_SORT_SIZE) {\n+            int mi1, mi2;\n+\n@@ -1139,3 +1140,0 @@\n-                int lo = lo1; lo1 = lo2; lo2 = lo;\n-                int hi = hi1; hi1 = hi2; hi2 = hi;\n-            }\n@@ -1143,6 +1141,6 @@\n-            \/*\n-             * Merge the small parts sequentially.\n-             *\/\n-            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n-                break;\n-            }\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi2 = (lo2 + hi2) >>> 1;\n+                mi1 = hi1;\n+                $type$ key = src[mi2];\n@@ -1150,6 +1148,5 @@\n-            \/*\n-             * Find the median of the larger part.\n-             *\/\n-            int mi1 = (lo1 + hi1) >>> 1;\n-            int mi2 = hi2;\n-            $type$ key = src[mi1];\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo1; mi0 < mi1; ) {\n+                    int mid = (mi0 + mi1) >>> 1;\n@@ -1157,5 +1154,7 @@\n-            \/*\n-             * Split the smaller part.\n-             *\/\n-            for (int mi0 = lo2; mi0 < mi2; ) {\n-                int mid = (mi0 + mi2) >>> 1;\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi1 = mid;\n+                    }\n+                }\n+            } else {\n@@ -1163,4 +1162,18 @@\n-                if (key > src[mid]) {\n-                    mi0 = mid + 1;\n-                } else {\n-                    mi2 = mid;\n+                \/*\n+                 * Find the median of the larger part.\n+                 *\/\n+                mi1 = (lo1 + hi1) >>> 1;\n+                mi2 = hi2;\n+                $type$ key = src[mi1];\n+\n+                \/*\n+                 * Split the smaller part.\n+                 *\/\n+                for (int mi0 = lo2; mi0 < mi2; ) {\n+                    int mid = (mi0 + mi2) >>> 1;\n+\n+                    if (key > src[mid]) {\n+                        mi0 = mid + 1;\n+                    } else {\n+                        mi2 = mid;\n+                    }\n@@ -1176,1 +1189,1 @@\n-             * Reserve space for the second parts.\n+             * Skip the first parts.\n@@ -1188,1 +1201,1 @@\n-         * Check if the array is already ordered and then merge the parts.\n+         * Merge the small parts sequentially.\n@@ -1190,6 +1203,1 @@\n-        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n-            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n-        } else {\n-            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n-            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n-        }\n+        mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -1212,3 +1220,4 @@\n-        if (src[hi1 - 1] < src[hi2 - 1]) {\n-            while (lo1 < hi1) {\n-                $type$ next = src[lo1];\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            if (src[hi1 - 1] < src[hi2 - 1]) {\n+                while (lo1 < hi1) {\n+                    $type$ next = src[lo1];\n@@ -1216,5 +1225,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -1222,4 +1232,3 @@\n-            }\n-        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n-            while (lo2 < hi2) {\n-                $type$ next = src[lo1];\n+            } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+                while (lo2 < hi2) {\n+                    $type$ next = src[lo1];\n@@ -1227,5 +1236,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -1233,4 +1243,3 @@\n-            }\n-        } else {\n-            while (lo1 < hi1 && lo2 < hi2) {\n-                $type$ next = src[lo1];\n+            } else {\n+                while (lo1 < hi1 && lo2 < hi2) {\n+                    $type$ next = src[lo1];\n@@ -1238,5 +1247,6 @@\n-                if (next <= src[lo2]) {\n-                    dst[k++] = src[lo1++];\n-                }\n-                if (next >= src[lo2]) {\n-                    dst[k++] = src[lo2++];\n+                    if (next <= src[lo2]) {\n+                        dst[k++] = src[lo1++];\n+                    }\n+                    if (next >= src[lo2]) {\n+                        dst[k++] = src[lo2++];\n+                    }\n@@ -1251,1 +1261,1 @@\n-        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+        System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -1438,0 +1448,3 @@\n+            if (c == 0) {\n+                continue;\n+            }\n@@ -1441,3 +1454,1 @@\n-            if (c > 0) {\n-                break;\n-            }\n+            break;\n@@ -1533,2 +1544,12 @@\n-            addToPendingCount(1);\n-            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+            if (high - low < MIN_PARALLEL_SORT_SIZE) {\n+                switch(a) {\n+                    case int[] ai -> sort(null, ai, depth, low, high);\n+                    case long[] al -> sort(null, al, depth, low, high);\n+                    case float[] af -> sort(null, af, depth, low, high);\n+                    case double[] ad -> sort(null, ad, depth, low, high);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+                }\n+            } else {\n+                addToPendingCount(1);\n+                new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java.template","additions":148,"deletions":127,"binary":false,"changes":275,"status":"modified"},{"patch":"@@ -24,0 +24,2 @@\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n@@ -48,4 +50,0 @@\n-    \/\/ Lengths of arrays for [mixed] insertion sort\n-    private static final int[] RUN_LENGTHS =\n-        { 1, 2, 14, 100, 500, 1_000 };\n-\n@@ -54,1 +52,1 @@\n-        { 1, 2, 14, 100, 500, 1_000, 11_000 };\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000 };\n@@ -58,9 +56,1 @@\n-        { 1, 2, 14, 100, 500, 1_000, 11_000, 50_000};\n-\n-    \/\/ Initial random values for short run\n-    private static final TestRandom[] SHORT_RANDOMS =\n-        {TestRandom.C0FFEE};\n-\n-    \/\/ Initial random values for long run (default)\n-    private static final TestRandom[] LONG_RANDOMS =\n-        {TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE};\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000, 64_000};\n@@ -68,12 +58,1 @@\n-    \/\/ Constant to fill the left part of array\n-    private static final int A380 = 0xA380;\n-\n-    \/\/ Constant to fill the right part of array\n-    private static final int B747 = 0xB747;\n-\n-    private final SortingHelper sortingHelper;\n-    private final TestRandom[] randoms;\n-    private final int[] lengths;\n-    private final boolean withMin;\n-    private Object[] gold;\n-    private Object[] test;\n+    private static final Random random = new Random(0xC0FFEE);\n@@ -82,1 +61,0 @@\n-        long start = System.currentTimeMillis();\n@@ -84,1 +62,0 @@\n-\n@@ -86,14 +63,1 @@\n-        TestRandom[] randoms = shortRun ? SHORT_RANDOMS : LONG_RANDOMS;\n-\n-        new Sorting(SortingHelper.INSERTION_SORT, randoms, false).testBase();\n-        new Sorting(SortingHelper.MIXED_INSERTION_SORT, randoms, true).testBase();\n-        new Sorting(SortingHelper.MERGING_SORT, randoms, lengths).testStructured();\n-\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBase();\n-        new Sorting(SortingHelper.COUNTING_SORT, randoms, lengths).testBase();\n-\n-        new Sorting(SortingHelper.DUAL_PIVOT_QUICKSORT, randoms, lengths).testCore();\n-        new Sorting(SortingHelper.PARALLEL_QUICKSORT, randoms, lengths).testCore();\n-\n-        new Sorting(SortingHelper.ARRAYS_SORT, randoms, lengths).testAll();\n-        new Sorting(SortingHelper.ARRAYS_PARALLEL_SORT, randoms, lengths).testAll();\n+        long start = System.currentTimeMillis();\n@@ -101,0 +65,9 @@\n+        for (int length : lengths) {\n+            new IntegerHolder().test(length);\n+            new LongHolder().test(length);\n+            new ByteHolder().test(length);\n+            new CharacterHolder().test(length);\n+            new ShortHolder().test(length);\n+            new FloatHolder().test(length);\n+            new DoubleHolder().test(length);\n+        }\n@@ -105,7 +78,3 @@\n-    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, boolean withMin) {\n-        this(sortingHelper, randoms, RUN_LENGTHS, withMin);\n-    }\n-\n-    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths) {\n-        this(sortingHelper, randoms, lengths, false);\n-    }\n+    private static class IntegerHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final int A380 = (int) 0xA380;\n@@ -113,6 +82,2 @@\n-    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths, boolean withMin) {\n-        this.sortingHelper = sortingHelper;\n-        this.randoms = randoms;\n-        this.lengths = lengths;\n-        this.withMin = withMin;\n-    }\n+        \/\/ Constant to fill the right part of array\n+        private static final int B747 = (int) 0xB747;\n@@ -120,2 +85,4 @@\n-    private void testBase() {\n-        testEmptyArray();\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private int[] gold;\n+        private int[] test;\n@@ -123,3 +90,3 @@\n-        for (int length : lengths) {\n-            createArray(length);\n-            testStructured(length);\n+        private IntegerHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n@@ -127,5 +94,4 @@\n-            for (TestRandom random : randoms) {\n-                testWithCheckSum(length, random);\n-                testWithInsertionSort(length, random);\n-                testWithScrambling(length, random);\n-            }\n+        private IntegerHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n@@ -133,1 +99,0 @@\n-    }\n@@ -135,2 +100,3 @@\n-    private void testCore() {\n-        testBase();\n+        private void test(int length) {\n+            gold = new int[length];\n+            test = new int[length];\n@@ -138,2 +104,8 @@\n-        for (int length : lengths) {\n-            createArray(length);\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n@@ -141,4 +113,1 @@\n-            for (TestRandom random : randoms) {\n-                testNegativeZero(length, random);\n-                testFloatingPointSorting(length, random);\n-            }\n+            out.println();\n@@ -146,1 +115,0 @@\n-    }\n@@ -148,6 +116,2 @@\n-    private void testAll() {\n-        testCore();\n-\n-        for (int length : lengths) {\n-            createArray(length);\n-            sortRange(length);\n+        private void testEmpty() {\n+            sortingHelper.sort(new int[test.length], 0, 0);\n@@ -155,11 +119,0 @@\n-    }\n-\n-    private void testEmptyArray() {\n-        sortingHelper.sort(new int[]{});\n-        sortingHelper.sort(new int[]{}, 0, 0);\n-\n-        sortingHelper.sort(new long[]{});\n-        sortingHelper.sort(new long[]{}, 0, 0);\n-\n-        sortingHelper.sort(new byte[]{});\n-        sortingHelper.sort(new byte[]{}, 0, 0);\n@@ -167,2 +120,2 @@\n-        sortingHelper.sort(new char[]{});\n-        sortingHelper.sort(new char[]{}, 0, 0);\n+        private void testStructured() {\n+            testEmpty();\n@@ -170,16 +123,2 @@\n-        sortingHelper.sort(new short[]{});\n-        sortingHelper.sort(new short[]{}, 0, 0);\n-\n-        sortingHelper.sort(new float[]{});\n-        sortingHelper.sort(new float[]{}, 0, 0);\n-\n-        sortingHelper.sort(new double[]{});\n-        sortingHelper.sort(new double[]{}, 0, 0);\n-    }\n-\n-    private void sortRange(int length) {\n-        int[] a = (int[]) gold[0];\n-\n-        for (int m = 1; m < length; m <<= 1) {\n-            for (int i = 1; i <= length; ++i) {\n-                a[i - 1] = i % m + m % i;\n+            if (test.length < 512) {\n+                return;\n@@ -187,6 +126,8 @@\n-            convertArray(m \/ 4);\n-\n-            for (int i = 0; i < test.length; ++i) {\n-                printTestName(\"Test range check\", length,\n-                        \", m = \" + m + \", \" + getType(i));\n-                sortRange(test[i], m);\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n@@ -195,8 +136,0 @@\n-        out.println();\n-    }\n-\n-    private void testWithInsertionSort(int length, TestRandom random) {\n-        if (length > 1_000) {\n-            return;\n-        }\n-        int[] a = (int[]) gold[0];\n@@ -204,14 +137,3 @@\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\n-                builder.build(a, m, random);\n-                int shift = m \/ 4;\n-                convertArray(shift);\n-\n-                for (int i = 0; i < test.length; ++i) {\n-                    printTestName(\"Test with insertion sort\", random, length,\n-                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i], shift, length - shift);\n-                    sortByInsertionSort(gold[i], shift, length - shift);\n-                    checkSorted(gold[i], shift);\n-                    compare(test[i], gold[i]);\n-                }\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n@@ -219,0 +141,4 @@\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -220,2 +146,0 @@\n-        out.println();\n-    }\n@@ -223,4 +147,5 @@\n-    private void testStructured() {\n-        for (int length : lengths) {\n-            createArray(length);\n-            testStructured(length);\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -228,1 +153,0 @@\n-    }\n@@ -230,3 +154,3 @@\n-    private void testStructured(int length) {\n-        if (length < 512) {\n-            return;\n+        private void testAll() {\n+            testCore();\n+            testRange();\n@@ -234,6 +158,0 @@\n-        int[] a = (int[]) gold[0];\n-\n-        for (int m = 1; m < 8; ++m) {\n-            for (StructuredBuilder builder : StructuredBuilder.values()) {\n-                builder.build(a, m);\n-                convertArray(0);\n@@ -241,5 +159,7 @@\n-                for (int i = 0; i < test.length; ++i) {\n-                    printTestName(\"Test structured\", length,\n-                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]\/*, shift, length - shift*\/);\n-                    checkSorted(test[i], 0);\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n@@ -249,5 +169,0 @@\n-        out.println();\n-    }\n-\n-    private void testWithCheckSum(int length, TestRandom random) {\n-        int[] a = (int[]) gold[0];\n@@ -255,11 +170,16 @@\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (UnsortedBuilder builder : UnsortedBuilder.values()) {\n-                builder.build(a, m, random);\n-                int shift = m \/ 4;\n-                convertArray(shift);\n-\n-                for (int i = 0; i < test.length; ++i) {\n-                    printTestName(\"Test with check sum\", random, length,\n-                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i], shift, length - shift);\n-                    checkWithCheckSum(test[i], gold[i], shift);\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n@@ -269,5 +189,0 @@\n-        out.println();\n-    }\n-\n-    private void testWithScrambling(int length, TestRandom random) {\n-        int[] a = (int[]) gold[0];\n@@ -275,4 +190,6 @@\n-        for (int m = 1; m <= length; m <<= 1) {\n-            for (SortedBuilder builder : SortedBuilder.values()) {\n-                builder.build(a, m);\n-                convertArray(0);\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -280,6 +197,7 @@\n-                for (int i = 0; i < test.length; ++i) {\n-                    printTestName(\"Test with scrambling\", random, length,\n-                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    scramble(test[i], random);\n-                    sortingHelper.sort(test[i]);\n-                    compare(test[i], gold[i]);\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n@@ -289,2 +207,0 @@\n-        out.println();\n-    }\n@@ -292,3 +208,3 @@\n-    private void testNegativeZero(int length, TestRandom random) {\n-        for (int i = 5; i < test.length; ++i) {\n-            printTestName(\"Test negative zero -0.0\", random, length, \" \" + getType(i));\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -296,5 +212,8 @@\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values()[i - 5];\n-            builder.build(test[i], random);\n-\n-            sortingHelper.sort(test[i]);\n-            checkNegativeZero(test[i]);\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n@@ -302,2 +221,0 @@\n-        out.println();\n-    }\n@@ -305,28 +222,9 @@\n-    private void testFloatingPointSorting(int length, TestRandom random) {\n-        if (length < 6) {\n-            return;\n-        }\n-        final int MAX = 14;\n-        int s = 4;\n-\n-        for (int k = 0; k < MAX; ++k) {\n-            for (int g = 0; g < MAX; ++g) {\n-                for (int z = 0; z < MAX; ++z) {\n-                    for (int n = 0; n < MAX; ++n) {\n-                        for (int p = 0; p < MAX; ++p) {\n-                            if (k + g + z + n + p + s != length) {\n-                                continue;\n-                            }\n-                            for (int i = 5; i < test.length; ++i) {\n-                                printTestName(\"Test float-pointing sorting\", random, length,\n-                                        \", k = \" + k + \", g = \" + g + \", z = \" + z +\n-                                                \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n-                                builder.build(gold[i], k, g, z, n, p, random);\n-                                copy(test[i], gold[i]);\n-                                scramble(test[i], random);\n-                                sortingHelper.sort(test[i]);\n-                                compare(test[i], gold[i], k, n + 2, g);\n-                            }\n-                        }\n-                    }\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n@@ -337,14 +235,9 @@\n-        for (int m = MAX; m > 4; --m) {\n-            int g = length \/ m;\n-            int k = length - g - g - g - g - s;\n-\n-            for (int i = 5; i < test.length; ++i) {\n-                printTestName(\"Test float-pointing sorting\", random, length,\n-                        \", k = \" + k + \", g = \" + g + \", z = \" + g +\n-                                \", n = \" + g + \", p = \" + g + \", \" + getType(i));\n-                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n-                builder.build(gold[i], k, g, g, g, g, random);\n-                copy(test[i], gold[i]);\n-                scramble(test[i], random);\n-                sortingHelper.sort(test[i]);\n-                compare(test[i], gold[i], k, g + 2, g);\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n@@ -353,2 +246,0 @@\n-        out.println();\n-    }\n@@ -356,10 +247,3 @@\n-    private void scramble(Object a, Random random) {\n-        switch (a) {\n-            case int[] ai -> scramble(ai, random);\n-            case long[] al -> scramble(al, random);\n-            case byte[] ab -> scramble(ab, random);\n-            case char[] ac -> scramble(ac, random);\n-            case short[] as -> scramble(as, random);\n-            case float[] af -> scramble(af, random);\n-            case double[] ad -> scramble(ad, random);\n-            default -> fail(a);\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -367,1 +251,0 @@\n-    }\n@@ -369,4 +252,10 @@\n-    private void scramble(int[] a, Random random) {\n-        if (withMin) {\n-            for (int i = 7; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+        private void checkSorted(int[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n@@ -374,3 +263,4 @@\n-        } else {\n-            for (int i = 0; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n@@ -379,1 +269,0 @@\n-    }\n@@ -381,4 +270,3 @@\n-    private void scramble(long[] a, Random random) {\n-        if (withMin) {\n-            for (int i = 7; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+        private void checkCheckSum(int[] a, int[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n@@ -386,3 +274,2 @@\n-        } else {\n-            for (int i = 1; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n@@ -391,1 +278,0 @@\n-    }\n@@ -393,8 +279,5 @@\n-    private void scramble(byte[] a, Random random) {\n-        if (withMin) {\n-            for (int i = 7; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n-            }\n-        } else {\n-            for (int i = 1; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        private int checkSumXor(int[] a) {\n+            int checkSum = 0;\n+\n+            for (int e : a) {\n+                checkSum ^= (int) e;\n@@ -402,0 +285,1 @@\n+            return checkSum;\n@@ -403,1 +287,0 @@\n-    }\n@@ -405,8 +288,5 @@\n-    private void scramble(char[] a, Random random) {\n-        if (withMin) {\n-            for (int i = 7; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n-            }\n-        } else {\n-            for (int i = 1; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        private int checkSumPlus(int[] a) {\n+            int checkSum = 0;\n+\n+            for (int e : a) {\n+                checkSum += (int) e;\n@@ -414,0 +294,1 @@\n+            return checkSum;\n@@ -415,1 +296,0 @@\n-    }\n@@ -417,8 +297,5 @@\n-    private void scramble(short[] a, Random random) {\n-        if (withMin) {\n-            for (int i = 7; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n-            }\n-        } else {\n-            for (int i = 1; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        private void compare(int[] a, int[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n@@ -427,1 +304,0 @@\n-    }\n@@ -429,9 +305,2 @@\n-    private void scramble(float[] a, Random random) {\n-        if (withMin) {\n-            for (int i = 7; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n-            }\n-        } else {\n-            for (int i = 1; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n-            }\n+        private void sortByInsertionSort(int[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -439,1 +308,0 @@\n-    }\n@@ -441,4 +309,6 @@\n-    private void scramble(double[] a, Random random) {\n-        if (withMin) {\n-            for (int i = 7; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n@@ -446,3 +316,2 @@\n-        } else {\n-            for (int i = 1; i < a.length * 7; ++i) {\n-                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            if (withMin) {\n+                gold[m] = Integer.MIN_VALUE;\n@@ -450,0 +319,1 @@\n+            test = gold.clone();\n@@ -451,1 +321,0 @@\n-    }\n@@ -453,5 +322,3 @@\n-    private void swap(int[] a, int i, int j) {\n-        int t = a[i];\n-        a[i] = a[j];\n-        a[j] = t;\n-    }\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Integer\", test.length, sortingHelper, m, builder);\n+        }\n@@ -459,5 +326,3 @@\n-    private void swap(long[] a, int i, int j) {\n-        long t = a[i];\n-        a[i] = a[j];\n-        a[j] = t;\n-    }\n+        private static void swap(int[] a, int i, int j) {\n+            int t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n@@ -465,5 +330,3 @@\n-    private void swap(byte[] a, int i, int j) {\n-        byte t = a[i];\n-        a[i] = a[j];\n-        a[j] = t;\n-    }\n+        private static void reverse(int[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n@@ -471,5 +334,3 @@\n-    private void swap(char[] a, int i, int j) {\n-        char t = a[i];\n-        a[i] = a[j];\n-        a[j] = t;\n-    }\n+        private interface Builder {\n+            void build(int[] a, int m);\n+        }\n@@ -477,5 +338,9 @@\n-    private void swap(short[] a, int i, int j) {\n-        short t = a[i];\n-        a[i] = a[j];\n-        a[j] = t;\n-    }\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n@@ -483,5 +348,12 @@\n-    private void swap(float[] a, int i, int j) {\n-        float t = a[i];\n-        a[i] = a[j];\n-        a[j] = t;\n-    }\n+            STEPS {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n@@ -489,5 +361,9 @@\n-    private void swap(double[] a, int i, int j) {\n-        double t = a[i];\n-        a[i] = a[j];\n-        a[j] = t;\n-    }\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) random.nextInt();\n+                    }\n+                }\n+            },\n@@ -495,4 +371,11 @@\n-    private void checkWithCheckSum(Object test, Object gold, int m) {\n-        checkSorted(test, m);\n-        checkCheckSum(test, gold);\n-    }\n+            PERMUTATION {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n@@ -500,7 +383,4 @@\n-    private void checkNegativeZero(Object a) {\n-        switch (a) {\n-            case float[] af -> checkNegativeZero(af);\n-            case double[] ad -> checkNegativeZero(ad);\n-            default -> fail(a);\n-        }\n-    }\n+            UNIFORM {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    int mask = (m << 15) - 1;\n@@ -508,7 +388,5 @@\n-    private void checkNegativeZero(float[] a) {\n-        for (int i = 0; i < a.length - 1; ++i) {\n-            if (Float.floatToRawIntBits(a[i]) == 0 && Float.floatToRawIntBits(a[i + 1]) < 0) {\n-                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\n-            }\n-        }\n-    }\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n@@ -516,7 +394,8 @@\n-    private void checkNegativeZero(double[] a) {\n-        for (int i = 0; i < a.length - 1; ++i) {\n-            if (Double.doubleToRawLongBits(a[i]) == 0 && Double.doubleToRawLongBits(a[i + 1]) < 0) {\n-                fail(a[i] + \" before \" + a[i + 1] + \" at position \" + i);\n-            }\n-        }\n-    }\n+            REPEATED {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (i % m);\n+                    }\n+                }\n+            },\n@@ -524,7 +403,22 @@\n-    private void compare(Object a, Object b, int numNaN, int numNeg, int numNegZero) {\n-        switch (a) {\n-            case float[] af -> compare(af, (float[]) b, numNaN, numNeg, numNegZero);\n-            case double[] ad -> compare(ad, (double[]) b, numNaN, numNeg, numNegZero);\n-            default -> fail(a);\n-        }\n-    }\n+            DUPLICATED {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (int) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (int) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n@@ -532,4 +426,7 @@\n-    private void compare(float[] a, float[] b, int numNaN, int numNeg, int numNegZero) {\n-        for (int i = a.length - numNaN; i < a.length; ++i) {\n-            if (!Float.isNaN(a[i])) {\n-                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n+            SHUFFLE {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (int) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n@@ -538,1 +435,0 @@\n-        final int NEGATIVE_ZERO = Float.floatToIntBits(-0.0f);\n@@ -540,5 +436,9 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n-            if (Float.floatToIntBits(a[i]) != NEGATIVE_ZERO) {\n-                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (m + i);\n+                    }\n+                }\n+            },\n@@ -546,6 +446,8 @@\n-        for (int i = 0; i < a.length - numNaN; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n+            DESCENDING {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (a.length - m - i);\n+                    }\n+                }\n+            },\n@@ -553,7 +455,6 @@\n-    private void compare(double[] a, double[] b, int numNaN, int numNeg, int numNegZero) {\n-        for (int i = a.length - numNaN; i < a.length; ++i) {\n-            if (!Double.isNaN(a[i])) {\n-                fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-        final long NEGATIVE_ZERO = Double.doubleToLongBits(-0.0d);\n+            EQUAL {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    Arrays.fill(a, (int) m);\n+                }\n+            },\n@@ -561,5 +462,8 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n-            if (Double.doubleToLongBits(a[i]) != NEGATIVE_ZERO) {\n-                fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n+            SHIFTED {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (i << 10);\n+                    }\n+                }\n+            },\n@@ -567,6 +471,4 @@\n-        for (int i = 0; i < a.length - numNaN; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n-        }\n-    }\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n@@ -574,12 +476,8 @@\n-    private void compare(Object a, Object b) {\n-        switch (a) {\n-            case int[] ai -> compare(ai, (int[]) b);\n-            case long[] al -> compare(al, (long[]) b);\n-            case byte[] ab -> compare(ab, (byte[]) b);\n-            case char[] ac -> compare(ac, (char[]) b);\n-            case short[] as -> compare(as, (short[]) b);\n-            case float[] af -> compare(af, (float[]) b);\n-            case double[] ad -> compare(ad, (double[]) b);\n-            default -> fail(a);\n-        }\n-    }\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (int) (a.length - i - 1);\n+                    }\n+                }\n+            },\n@@ -587,4 +485,65 @@\n-    private void compare(int[] a, int[] b) {\n-        for (int i = 0; i < a.length; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+            PLATEAU {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    Arrays.fill(a, (int) 0);\n+                    a[a.length \/ 2] = (int) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build(int[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (int) ((i * m + i) % a.length);\n+                    }\n+                }\n@@ -595,5 +554,14 @@\n-    private void compare(long[] a, long[] b) {\n-        for (int i = 0; i < a.length; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n+    private static class LongHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final long A380 = (long) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final long B747 = (long) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private long[] gold;\n+        private long[] test;\n+\n+        private LongHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n@@ -601,1 +569,0 @@\n-    }\n@@ -603,5 +570,4 @@\n-    private void compare(byte[] a, byte[] b) {\n-        for (int i = 0; i < a.length; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n+        private LongHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n@@ -609,1 +575,0 @@\n-    }\n@@ -611,5 +576,14 @@\n-    private void compare(char[] a, char[] b) {\n-        for (int i = 0; i < a.length; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n+        private void test(int length) {\n+            gold = new long[length];\n+            test = new long[length];\n+\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n@@ -617,1 +591,0 @@\n-    }\n@@ -619,5 +592,2 @@\n-    private void compare(short[] a, short[] b) {\n-        for (int i = 0; i < a.length; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n-            }\n+        private void testEmpty() {\n+            sortingHelper.sort(new long[test.length], 0, 0);\n@@ -625,1 +595,0 @@\n-    }\n@@ -627,4 +596,14 @@\n-    private void compare(float[] a, float[] b) {\n-        for (int i = 0; i < a.length; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n@@ -633,1 +612,0 @@\n-    }\n@@ -635,4 +613,3 @@\n-    private void compare(double[] a, double[] b) {\n-        for (int i = 0; i < a.length; ++i) {\n-            if (a[i] != b[i]) {\n-                fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n@@ -640,0 +617,4 @@\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -641,16 +622,0 @@\n-    }\n-\n-    private String getType(int i) {\n-        Object a = test[i];\n-\n-        return switch (a) {\n-            case int[] _ -> \"INT   \";\n-            case long[] _ -> \"LONG  \";\n-            case byte[] _ -> \"BYTE  \";\n-            case char[] _ -> \"CHAR  \";\n-            case short[] _ -> \"SHORT \";\n-            case float[] _ -> \"FLOAT \";\n-            case double[] _ -> \"DOUBLE\";\n-            default -> null;\n-        };\n-    }\n@@ -658,10 +623,5 @@\n-    private void checkSorted(Object a, int m) {\n-        switch (a) {\n-            case int[] ai -> checkSorted(ai, m);\n-            case long[] al -> checkSorted(al, m);\n-            case byte[] ab -> checkSorted(ab, m);\n-            case char[] ac -> checkSorted(ac, m);\n-            case short[] as -> checkSorted(as, m);\n-            case float[] af -> checkSorted(af, m);\n-            case double[] ad -> checkSorted(ad, m);\n-            default -> fail(a);\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -669,1 +629,0 @@\n-    }\n@@ -671,5 +630,3 @@\n-    private void checkSorted(int[] a, int m) {\n-        for (int i = 0; i < m; ++i) {\n-            if (a[i] != A380) {\n-                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n+        private void testAll() {\n+            testCore();\n+            testRange();\n@@ -677,3 +634,9 @@\n-        for (int i = m; i < a.length - m - 1; ++i) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n@@ -682,3 +645,18 @@\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            if (a[i] != B747) {\n-                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n@@ -687,1 +665,0 @@\n-    }\n@@ -689,4 +666,3 @@\n-    private void checkSorted(long[] a, int m) {\n-        for (int i = 0; i < m; ++i) {\n-            if (a[i] != toLong(A380)) {\n-                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n@@ -694,4 +670,11 @@\n-        }\n-        for (int i = m; i < a.length - m - 1; ++i) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n@@ -700,3 +683,12 @@\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            if (a[i] != toLong(B747)) {\n-                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n@@ -705,1 +697,0 @@\n-    }\n@@ -707,4 +698,10 @@\n-    private void checkSorted(byte[] a, int m) {\n-        for (int i = 0; i < m; ++i) {\n-            if (a[i] != (byte) A380) {\n-                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n@@ -713,3 +710,10 @@\n-        for (int i = m; i < a.length - m - 1; ++i) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n@@ -718,4 +722,4 @@\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            if (a[i] != (byte) B747) {\n-                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -723,1 +727,0 @@\n-    }\n@@ -725,4 +728,5 @@\n-    private void checkSorted(char[] a, int m) {\n-        for (int i = 0; i < m; ++i) {\n-            if (a[i] != (char) A380) {\n-                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+        private void checkSorted(long[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n@@ -730,4 +734,4 @@\n-        }\n-        for (int i = m; i < a.length - m - 1; ++i) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n@@ -735,4 +739,4 @@\n-        }\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            if (a[i] != (char) B747) {\n-                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n@@ -741,1 +745,0 @@\n-    }\n@@ -743,4 +746,3 @@\n-    private void checkSorted(short[] a, int m) {\n-        for (int i = 0; i < m; ++i) {\n-            if (a[i] != (short) A380) {\n-                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+        private void checkCheckSum(long[] a, long[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n@@ -748,4 +750,2 @@\n-        }\n-        for (int i = m; i < a.length - m - 1; ++i) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n@@ -754,3 +754,6 @@\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            if (a[i] != (short) B747) {\n-                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+\n+        private int checkSumXor(long[] a) {\n+            int checkSum = 0;\n+\n+            for (long e : a) {\n+                checkSum ^= (int) e;\n@@ -758,0 +761,1 @@\n+            return checkSum;\n@@ -759,1 +763,0 @@\n-    }\n@@ -761,4 +764,5 @@\n-    private void checkSorted(float[] a, int m) {\n-        for (int i = 0; i < m; ++i) {\n-            if (a[i] != (float) A380) {\n-                fail(\"Sort changes left element at position \" + i + hex((long) a[i], A380));\n+        private int checkSumPlus(long[] a) {\n+            int checkSum = 0;\n+\n+            for (long e : a) {\n+                checkSum += (int) e;\n@@ -766,0 +770,1 @@\n+            return checkSum;\n@@ -767,3 +772,6 @@\n-        for (int i = m; i < a.length - m - 1; ++i) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+\n+        private void compare(long[] a, long[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n@@ -772,4 +780,3 @@\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            if (a[i] != (float) B747) {\n-                fail(\"Sort changes right element at position \" + i + hex((long) a[i], B747));\n-            }\n+\n+        private void sortByInsertionSort(long[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -777,1 +784,0 @@\n-    }\n@@ -779,4 +785,3 @@\n-    private void checkSorted(double[] a, int m) {\n-        for (int i = 0; i < m; ++i) {\n-            if (a[i] != toDouble(A380)) {\n-                fail(\"Sort changes left element at position \" + i + hex((long) a[i], A380));\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n@@ -784,4 +789,2 @@\n-        }\n-        for (int i = m; i < a.length - m - 1; ++i) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n@@ -789,4 +792,2 @@\n-        }\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            if (a[i] != B747) {\n-                fail(\"Sort changes right element at position \" + i + hex((long) a[i], B747));\n+            if (withMin) {\n+                gold[m] = Long.MIN_VALUE;\n@@ -794,0 +795,1 @@\n+            test = gold.clone();\n@@ -795,1 +797,0 @@\n-    }\n@@ -797,6 +798,2 @@\n-    private void checkCheckSum(Object test, Object gold) {\n-        if (checkSumXor(test) != checkSumXor(gold)) {\n-            fail(\"Original and sorted arrays are not identical [^]\");\n-        }\n-        if (checkSumPlus(test) != checkSumPlus(gold)) {\n-            fail(\"Original and sorted arrays are not identical [+]\");\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Long\", test.length, sortingHelper, m, builder);\n@@ -804,17 +801,0 @@\n-    }\n-\n-    private int checkSumXor(Object a) {\n-        return switch (a) {\n-            case int[] ai -> checkSumXor(ai);\n-            case long[] al -> checkSumXor(al);\n-            case byte[] ab -> checkSumXor(ab);\n-            case char[] ac -> checkSumXor(ac);\n-            case short[] as -> checkSumXor(as);\n-            case float[] af -> checkSumXor(af);\n-            case double[] ad -> checkSumXor(ad);\n-            default -> -1;\n-        };\n-    }\n-\n-    private int checkSumXor(int[] a) {\n-        int checkSum = 0;\n@@ -822,2 +802,2 @@\n-        for (int e : a) {\n-            checkSum ^= e;\n+        private static void swap(long[] a, int i, int j) {\n+            long t = a[i]; a[i] = a[j]; a[j] = t;\n@@ -825,5 +805,0 @@\n-        return checkSum;\n-    }\n-\n-    private int checkSumXor(long[] a) {\n-        long checkSum = 0;\n@@ -831,2 +806,2 @@\n-        for (long e : a) {\n-            checkSum ^= e;\n+        private static void reverse(long[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n@@ -834,5 +809,0 @@\n-        return (int) checkSum;\n-    }\n-\n-    private int checkSumXor(byte[] a) {\n-        byte checkSum = 0;\n@@ -840,2 +810,2 @@\n-        for (byte e : a) {\n-            checkSum ^= e;\n+        private interface Builder {\n+            void build(long[] a, int m);\n@@ -843,2 +813,0 @@\n-        return checkSum;\n-    }\n@@ -846,2 +814,9 @@\n-    private int checkSumXor(char[] a) {\n-        char checkSum = 0;\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n@@ -849,4 +824,677 @@\n-        for (char e : a) {\n-            checkSum ^= e;\n-        }\n-        return checkSum;\n+            STEPS {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (long) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (long) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (long) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    Arrays.fill(a, (long) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (long) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    Arrays.fill(a, (long) 0);\n+                    a[a.length \/ 2] = (long) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build(long[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (long) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static class ByteHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final byte A380 = (byte) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final byte B747 = (byte) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private byte[] gold;\n+        private byte[] test;\n+\n+        private ByteHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private ByteHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new byte[length];\n+            test = new byte[length];\n+\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new byte[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n+\n+        private void checkSorted(byte[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum(byte[] a, byte[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n+\n+        private int checkSumXor(byte[] a) {\n+            int checkSum = 0;\n+\n+            for (byte e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus(byte[] a) {\n+            int checkSum = 0;\n+\n+            for (byte e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(byte[] a, byte[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private void sortByInsertionSort(byte[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Byte.MIN_VALUE;\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Byte\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(byte[] a, int i, int j) {\n+            byte t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(byte[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private interface Builder {\n+            void build(byte[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (byte) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (byte) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (byte) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    Arrays.fill(a, (byte) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (byte) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    Arrays.fill(a, (byte) 0);\n+                    a[a.length \/ 2] = (byte) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build(byte[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (byte) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n+        }\n@@ -855,2 +1503,344 @@\n-    private int checkSumXor(short[] a) {\n-        short checkSum = 0;\n+    private static class CharacterHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final char A380 = (char) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final char B747 = (char) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private char[] gold;\n+        private char[] test;\n+\n+        private CharacterHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private CharacterHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new char[length];\n+            test = new char[length];\n+\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new char[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n+\n+        private void checkSorted(char[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum(char[] a, char[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n+\n+        private int checkSumXor(char[] a) {\n+            int checkSum = 0;\n+\n+            for (char e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus(char[] a) {\n+            int checkSum = 0;\n+\n+            for (char e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(char[] a, char[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private void sortByInsertionSort(char[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Character.MIN_VALUE;\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Character\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(char[] a, int i, int j) {\n+            char t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(char[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private interface Builder {\n+            void build(char[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (char) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (char) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n@@ -858,2 +1848,8 @@\n-        for (short e : a) {\n-            checkSum ^= e;\n+            SHUFFLE {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (char) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n@@ -861,2 +1857,0 @@\n-        return checkSum;\n-    }\n@@ -864,2 +1858,106 @@\n-    private int checkSumXor(float[] a) {\n-        int checkSum = 0;\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    Arrays.fill(a, (char) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (char) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    Arrays.fill(a, (char) 0);\n+                    a[a.length \/ 2] = (char) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n@@ -867,2 +1965,8 @@\n-        for (float e : a) {\n-            checkSum ^= (int) e;\n+            STAGGER {\n+                @Override\n+                public void build(char[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (char) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n@@ -870,1 +1974,0 @@\n-        return checkSum;\n@@ -873,2 +1976,11 @@\n-    private int checkSumXor(double[] a) {\n-        int checkSum = 0;\n+    private static class ShortHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final short A380 = (short) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final short B747 = (short) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private short[] gold;\n+        private short[] test;\n@@ -876,2 +1988,2 @@\n-        for (double e : a) {\n-            checkSum ^= (int) e;\n+        private ShortHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n@@ -879,2 +1991,0 @@\n-        return checkSum;\n-    }\n@@ -882,12 +1992,9 @@\n-    private int checkSumPlus(Object a) {\n-        return switch (a) {\n-            case int[] ai -> checkSumPlus(ai);\n-            case long[] al -> checkSumPlus(al);\n-            case byte[] ab -> checkSumPlus(ab);\n-            case char[] ac -> checkSumPlus(ac);\n-            case short[] as -> checkSumPlus(as);\n-            case float[] af -> checkSumPlus(af);\n-            case double[] ad -> checkSumPlus(ad);\n-            default -> -1;\n-        };\n-    }\n+        private ShortHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new short[length];\n+            test = new short[length];\n@@ -895,2 +2002,5 @@\n-    private int checkSumPlus(int[] a) {\n-        int checkSum = 0;\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n@@ -898,2 +2008,5 @@\n-        for (int e : a) {\n-            checkSum += e;\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new short[test.length], 0, 0);\n@@ -901,2 +2014,0 @@\n-        return checkSum;\n-    }\n@@ -904,2 +2015,2 @@\n-    private int checkSumPlus(long[] a) {\n-        long checkSum = 0;\n+        private void testStructured() {\n+            testEmpty();\n@@ -907,2 +2018,12 @@\n-        for (long e : a) {\n-            checkSum += e;\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n@@ -910,2 +2031,0 @@\n-        return (int) checkSum;\n-    }\n@@ -913,2 +2032,9 @@\n-    private int checkSumPlus(byte[] a) {\n-        byte checkSum = 0;\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n@@ -916,2 +2042,5 @@\n-        for (byte e : a) {\n-            checkSum += e;\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n@@ -919,2 +2048,0 @@\n-        return checkSum;\n-    }\n@@ -922,2 +2049,4 @@\n-    private int checkSumPlus(char[] a) {\n-        char checkSum = 0;\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n@@ -925,2 +2054,29 @@\n-        for (char e : a) {\n-            checkSum += e;\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n@@ -928,2 +2084,0 @@\n-        return checkSum;\n-    }\n@@ -931,2 +2085,6 @@\n-    private int checkSumPlus(short[] a) {\n-        short checkSum = 0;\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -934,2 +2092,9 @@\n-        for (short e : a) {\n-            checkSum += e;\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n@@ -937,2 +2102,0 @@\n-        return checkSum;\n-    }\n@@ -940,2 +2103,3 @@\n-    private int checkSumPlus(float[] a) {\n-        int checkSum = 0;\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -943,2 +2107,21 @@\n-        for (float e : a) {\n-            checkSum += (int) e;\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n@@ -946,2 +2129,0 @@\n-        return checkSum;\n-    }\n@@ -949,2 +2130,11 @@\n-    private int checkSumPlus(double[] a) {\n-        int checkSum = 0;\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n@@ -952,2 +2142,3 @@\n-        for (double e : a) {\n-            checkSum += (int) e;\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -955,2 +2146,0 @@\n-        return checkSum;\n-    }\n@@ -958,3 +2147,17 @@\n-    private void sortByInsertionSort(Object a, int low, int high) {\n-        SortingHelper.INSERTION_SORT.sort(a, low, high);\n-    }\n+        private void checkSorted(short[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n@@ -962,10 +2165,7 @@\n-    private void sortRange(Object a, int m) {\n-        switch (a) {\n-            case int[] ai -> sortRange(ai, m);\n-            case long[] al -> sortRange(al, m);\n-            case byte[] ab -> sortRange(ab, m);\n-            case char[] ac -> sortRange(ac, m);\n-            case short[] as -> sortRange(as, m);\n-            case float[] af -> sortRange(af, m);\n-            case double[] ad -> sortRange(ad, m);\n-            default -> fail(a);\n+        private void checkCheckSum(short[] a, short[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n@@ -973,1 +2173,0 @@\n-    }\n@@ -975,16 +2174,22 @@\n-    private void sortRange(int[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n-                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                        \"fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                            \"toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {\n+        private int checkSumXor(short[] a) {\n+            int checkSum = 0;\n+\n+            for (short e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus(short[] a) {\n+            int checkSum = 0;\n+\n+            for (short e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(short[] a, short[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n@@ -994,1 +2199,0 @@\n-    }\n@@ -996,16 +2200,52 @@\n-    private void sortRange(long[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n-                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                        \"fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                            \"toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {\n+        private void sortByInsertionSort(short[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Short.MIN_VALUE;\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Short\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(short[] a, int i, int j) {\n+            short t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(short[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private interface Builder {\n+            void build(short[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n@@ -1015,1 +2255,0 @@\n-    }\n@@ -1017,16 +2256,71 @@\n-    private void sortRange(byte[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n-                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                        \"fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                            \"toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (short) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (short) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (short) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n@@ -1036,1 +2330,0 @@\n-    }\n@@ -1038,16 +2331,113 @@\n-    private void sortRange(char[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n-                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                        \"fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                            \"toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    Arrays.fill(a, (short) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (short) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    Arrays.fill(a, (short) 0);\n+                    a[a.length \/ 2] = (short) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build(short[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (short) ((i * m + i) % a.length);\n+                    }\n@@ -1059,6 +2449,94 @@\n-    private void sortRange(short[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n-                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n+    private static class FloatHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final float A380 = (float) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final float B747 = (float) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private float[] gold;\n+        private float[] test;\n+\n+        private FloatHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private FloatHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new float[length];\n+            test = new float[length];\n+\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new float[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+            testNegativeZeroAndNaN();\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n@@ -1066,4 +2544,4 @@\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                        \"fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n@@ -1071,1 +2549,1 @@\n-                    sortingHelper.sort(a, 0, a.length + m);\n+                    sortingHelper.sort(test, -m, test.length);\n@@ -1073,2 +2551,52 @@\n-                            \"toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n@@ -1078,1 +2606,0 @@\n-    }\n@@ -1080,16 +2607,9 @@\n-    private void sortRange(float[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n-                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                        \"fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                            \"toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {\n+        private void testNegativeZeroAndNaN() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : FloatingPointBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    scramble();\n+                    print(\"negative zero and NaN\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    check(test, m);\n@@ -1099,1 +2619,0 @@\n-    }\n@@ -1101,16 +2620,8 @@\n-    private void sortRange(double[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n-                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                        \"fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n-                            \"toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n@@ -1120,1 +2631,0 @@\n-    }\n@@ -1122,5 +2632,3 @@\n-    private void copy(Object dst, Object src) {\n-        switch (src) {\n-            case float[] sf -> System.arraycopy(sf, 0, dst, 0, sf.length);\n-            case double[] sd -> System.arraycopy(sd, 0, dst, 0, sd.length);\n-            default -> fail(src);\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n@@ -1128,1 +2636,0 @@\n-    }\n@@ -1130,13 +2637,26 @@\n-    private void createArray(int length) {\n-        gold = new Object[]{\n-                new int[length], new long[length],\n-                new byte[length], new char[length], new short[length],\n-                new float[length], new double[length]\n-        };\n-\n-        test = new Object[]{\n-                new int[length], new long[length],\n-                new byte[length], new char[length], new short[length],\n-                new float[length], new double[length]\n-        };\n-    }\n+        private void checkSorted(float[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum(float[] a, float[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n@@ -1144,2 +2664,2 @@\n-    private void convertArray(int m) {\n-        int[] a = (int[]) gold[0];\n+        private int checkSumXor(float[] a) {\n+            int checkSum = 0;\n@@ -1147,2 +2667,4 @@\n-        for (int i = 0; i < m; ++i) {\n-            a[i] = A380;\n+            for (float e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n@@ -1150,2 +2672,8 @@\n-        for (int i = a.length - m; i < a.length; ++i) {\n-            a[i] = B747;\n+\n+        private int checkSumPlus(float[] a) {\n+            int checkSum = 0;\n+\n+            for (float e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n@@ -1153,3 +2681,7 @@\n-        for (int i = 0; i < gold.length; ++i) {\n-            TypeConverter converter = TypeConverter.values()[i];\n-            converter.convert(a, gold[i], withMin, m);\n+\n+        private void compare(float[] a, float[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n@@ -1157,2 +2689,3 @@\n-        for (int i = 0; i < gold.length; ++i) {\n-            System.arraycopy(gold[i], 0, test[i], 0, a.length);\n+\n+        private void sortByInsertionSort(float[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -1160,1 +2693,0 @@\n-    }\n@@ -1162,3 +2694,12 @@\n-    private String hex(long a, int b) {\n-        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\n-    }\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Float.NEGATIVE_INFINITY;\n+            }\n+            test = gold.clone();\n+        }\n@@ -1166,3 +2707,3 @@\n-    private void printTestName(String test, int length, String message) {\n-        out.println(\"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n-    }\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Float\", test.length, sortingHelper, m, builder);\n+        }\n@@ -1170,4 +2711,3 @@\n-    private void printTestName(String test, TestRandom random, int length, String message) {\n-        out.println(\"[\" + sortingHelper + \"] '\" + test +\n-                \"' length = \" + length + \", random = \" + random + message);\n-    }\n+        private static void swap(float[] a, int i, int j) {\n+            float t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n@@ -1175,3 +2715,3 @@\n-    private void fail(Object a) {\n-        fail(\"Unknown type: \" + a.getClass().getName());\n-    }\n+        private static void reverse(float[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n@@ -1179,4 +2719,2 @@\n-    private void fail(String message) {\n-        err.format(\"*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n-        throw new RuntimeException(\"Test failed\");\n-    }\n+        private void check(float[] a, int m) {\n+            final int NEGATIVE_ZERO = Float.floatToIntBits(-0.0f);\n@@ -1184,3 +2722,4 @@\n-    private static long toLong(int i) {\n-        return (((long) i) << 32) | i;\n-    }\n+            int k1 = a.length \/ (m + 1) * m     \/ 5;\n+            int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+            int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+            int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n@@ -1188,6 +2727,2 @@\n-    private static double toDouble(int i) {\n-        long v = toLong(i);\n-        v = (v > 0) ? ~v : v & ~(1L << 63);\n-        double d = Double.longBitsToDouble(v);\n-        return Double.isNaN(d) ? 0.0d : d;\n-    }\n+            for (int i = 0; i < k1; ++i) {\n+                float v = (float) (-(a.length + m) + i);\n@@ -1195,6 +2730,2 @@\n-    private enum TypeConverter {\n-        INT {\n-            @Override\n-            void convert(int[] src, Object dst, boolean withMin, int m) {\n-                if (withMin) {\n-                    src[m] = Integer.MIN_VALUE;\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n@@ -1203,9 +2734,3 @@\n-        },\n-\n-        LONG {\n-            @Override\n-            void convert(int[] src, Object dst, boolean withMin, int m) {\n-                long[] b = (long[]) dst;\n-\n-                for (int i = 0; i < src.length; ++i) {\n-                    b[i] = toLong(src[i]);\n+            for (int i = k1; i < k2; ++i) {\n+                if (Float.floatToIntBits(a[i]) != NEGATIVE_ZERO) {\n+                    fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n@@ -1213,2 +2738,4 @@\n-                if (withMin) {\n-                    b[m] = Long.MIN_VALUE;\n+            }\n+            for (int i = k2; i < k3; ++i) {\n+                if (a[i] != 0.0f || Float.floatToIntBits(a[i]) == NEGATIVE_ZERO) {\n+                    fail(\"There must be 0.0 instead of \" + a[i] + \" at position \" + i);\n@@ -1217,1 +2744,2 @@\n-        },\n+            for (int i = k3; i < k4; ++i) {\n+                float v = (float) (m + i);\n@@ -1219,7 +2747,2 @@\n-        BYTE {\n-            @Override\n-            void convert(int[] src, Object dst, boolean withMin, int m) {\n-                byte[] b = (byte[]) dst;\n-\n-                for (int i = 0; i < src.length; ++i) {\n-                    b[i] = (byte) src[i];\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n@@ -1227,2 +2750,4 @@\n-                if (withMin) {\n-                    b[m] = Byte.MIN_VALUE;\n+            }\n+            for (int i = k4; i < a.length; ++i) {\n+                if (!Float.isNaN(a[i])) {\n+                    fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n@@ -1231,1 +2756,1 @@\n-        },\n+        }\n@@ -1233,4 +2758,3 @@\n-        CHAR {\n-            @Override\n-            void convert(int[] src, Object dst, boolean withMin, int m) {\n-                char[] b = (char[]) dst;\n+        private interface Builder {\n+            void build(float[] a, int m);\n+        }\n@@ -1238,2 +2762,7 @@\n-                for (int i = 0; i < src.length; ++i) {\n-                    b[i] = (char) src[i];\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (Math.min(i + m, 127));\n+                    }\n@@ -1241,2 +2770,11 @@\n-                if (withMin) {\n-                    b[m] = Character.MIN_VALUE;\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n@@ -1245,6 +2783,1 @@\n-        },\n-\n-        SHORT {\n-            @Override\n-            void convert(int[] src, Object dst, boolean withMin, int m) {\n-                short[] b = (short[]) dst;\n+        }\n@@ -1252,2 +2785,7 @@\n-                for (int i = 0; i < src.length; ++i) {\n-                    b[i] = (short) src[i];\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) random.nextInt();\n+                    }\n@@ -1255,2 +2793,11 @@\n-                if (withMin) {\n-                    b[m] = Short.MIN_VALUE;\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n@@ -1258,2 +2805,1 @@\n-            }\n-        },\n+            },\n@@ -1261,4 +2807,4 @@\n-        FLOAT {\n-            @Override\n-            void convert(int[] src, Object dst, boolean withMin, int m) {\n-                float[] b = (float[]) dst;\n+            UNIFORM {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int mask = (m << 15) - 1;\n@@ -1266,5 +2812,3 @@\n-                for (int i = 0; i < src.length; ++i) {\n-                    b[i] = src[i];\n-                }\n-                if (withMin) {\n-                    b[m] = Float.NEGATIVE_INFINITY;\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (random.nextInt() & mask);\n+                    }\n@@ -1272,2 +2816,1 @@\n-            }\n-        },\n+            },\n@@ -1275,4 +2818,8 @@\n-        DOUBLE {\n-            @Override\n-            void convert(int[] src, Object dst, boolean withMin, int m) {\n-                double[] b = (double[]) dst;\n+            REPEATED {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (i % m);\n+                    }\n+                }\n+            },\n@@ -1280,2 +2827,6 @@\n-                for (int i = 0; i < src.length \/ 2; ++i) {\n-                    b[i] = toDouble(src[i]);\n+            DUPLICATED {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) random.nextInt(m);\n+                    }\n@@ -1283,2 +2834,13 @@\n-                for (int i = src.length \/ 2; i < src.length; ++i) {\n-                    b[i] = src[i];\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (float) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (float) (--minus);\n+                        }\n+                    }\n@@ -1286,2 +2848,8 @@\n-                if (withMin) {\n-                    b[m] = Double.NEGATIVE_INFINITY;\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (float) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n@@ -1290,4 +2858,1 @@\n-        };\n-\n-        abstract void convert(int[] src, Object dst, boolean withMin, int m);\n-    }\n+        }\n@@ -1295,6 +2860,7 @@\n-    private enum SortedBuilder {\n-        STEPS {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < m; ++i) {\n-                    a[i] = 0;\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (m + i);\n+                    }\n@@ -1302,0 +2868,1 @@\n+            },\n@@ -1303,2 +2870,6 @@\n-                for (int i = m; i < a.length; ++i) {\n-                    a[i] = 1;\n+            DESCENDING {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (a.length - m - i);\n+                    }\n@@ -1306,2 +2877,1 @@\n-            }\n-        };\n+            },\n@@ -1309,2 +2879,6 @@\n-        abstract void build(int[] a, int m);\n-    }\n+            EQUAL {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    Arrays.fill(a, (float) m);\n+                }\n+            },\n@@ -1312,6 +2886,6 @@\n-    private enum UnsortedBuilder {\n-        RANDOM {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = random.nextInt();\n+            SHIFTED {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (i << 10);\n+                    }\n@@ -1319,2 +2893,1 @@\n-            }\n-        },\n+            },\n@@ -1322,4 +2895,4 @@\n-        PERMUTATION {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n@@ -1327,2 +2900,6 @@\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = i & mask;\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (float) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (float) (a.length - i - 1);\n+                    }\n@@ -1330,5 +2907,8 @@\n-                for (int i = a.length; i > 1; --i) {\n-                    int k = random.nextInt(i);\n-                    int t = a[i - 1];\n-                    a[i - 1] = a[k];\n-                    a[k] = t;\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) Math.min(i, m);\n+                    }\n@@ -1336,2 +2916,1 @@\n-            }\n-        },\n+            },\n@@ -1339,4 +2918,4 @@\n-        UNIFORM {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                int mask = (m << 15) - 1;\n+            LATCH {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n@@ -1344,2 +2923,3 @@\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = random.nextInt() & mask;\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) (i % max);\n+                    }\n@@ -1347,2 +2927,1 @@\n-            }\n-        },\n+            },\n@@ -1350,5 +2929,5 @@\n-        STAGGER {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = (i * m + i) % a.length;\n+            POINT {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    Arrays.fill(a, (float) 0);\n+                    a[a.length \/ 2] = (float) m;\n@@ -1356,2 +2935,1 @@\n-            }\n-        },\n+            },\n@@ -1359,5 +2937,7 @@\n-        REPEATED {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = i % m;\n+            LINE {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n@@ -1365,2 +2945,1 @@\n-            }\n-        },\n+            },\n@@ -1368,5 +2947,7 @@\n-        DUPLICATED {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = random.nextInt(m);\n+            PEARL {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n@@ -1374,2 +2955,1 @@\n-            }\n-        },\n+            },\n@@ -1377,14 +2957,5 @@\n-        SAWTOOTH {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                int incCount = 1;\n-                int decCount = a.length;\n-                int i = 0;\n-                int period = m--;\n-\n-                while (true) {\n-                    for (int k = 1; k <= period; ++k) {\n-                        if (i >= a.length) {\n-                            return;\n-                        }\n-                        a[i++] = incCount++;\n+            TRAPEZIUM {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) i;\n@@ -1392,1 +2963,3 @@\n-                    period += m;\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n@@ -1394,5 +2967,5 @@\n-                    for (int k = 1; k <= period; ++k) {\n-                        if (i >= a.length) {\n-                            return;\n-                        }\n-                        a[i++] = decCount--;\n+            STAGGER {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (float) ((i * m + i) % a.length);\n@@ -1400,1 +2973,0 @@\n-                    period += m;\n@@ -1403,1 +2975,10 @@\n-        },\n+        }\n+\n+        private enum FloatingPointBuilder implements Builder {\n+            NEGATIVE_ZERO_AND_NAN {\n+                @Override\n+                public void build(float[] a, int m) {\n+                    int k1 = a.length \/ (m + 1) * m     \/ 5;\n+                    int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+                    int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+                    int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n@@ -1405,5 +2986,15 @@\n-        SHUFFLE {\n-            @Override\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n-                    a[i] = random.nextInt(m) > 0 ? (j += 2) : (k += 2);\n+                    for (int i = 0; i < k1; ++i) {\n+                        a[i] = (float) (-(a.length + m) + i);\n+                    }\n+                    for (int i = k1; i < k2; ++i) {\n+                        a[i] = -0.0f;\n+                    }\n+                    for (int i = k2; i < k3; ++i) {\n+                        a[i] = 0.0f;\n+                    }\n+                    for (int i = k3; i < k4; ++i) {\n+                        a[i] = (float) (m + i);\n+                    }\n+                    for (int i = k4; i < a.length; ++i) {\n+                        a[i] = Float.NaN;\n+                    }\n@@ -1412,3 +3003,1 @@\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n+        }\n@@ -1417,9 +3006,44 @@\n-    private enum StructuredBuilder {\n-        ASCENDING {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = m + i;\n-                }\n-            }\n-        },\n+    private static class DoubleHolder {\n+        \/\/ Constant to fill the left part of array\n+        private static final double A380 = (double) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final double B747 = (double) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private double[] gold;\n+        private double[] test;\n+\n+        private DoubleHolder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private DoubleHolder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new double[length];\n+            test = new double[length];\n+\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+            set(SortingHelper.HEAP_SORT).testBase();\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new double[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n@@ -1427,5 +3051,10 @@\n-        DESCENDING {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = a.length - m - i;\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n@@ -1434,1 +3063,1 @@\n-        },\n+        }\n@@ -1436,4 +3065,3 @@\n-        EQUAL {\n-            @Override\n-            void build(int[] a, int m) {\n-                Arrays.fill(a, m);\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n@@ -1441,1 +3069,5 @@\n-        },\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n@@ -1443,8 +3075,7 @@\n-        SHIFTED {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = i << 10;\n-                }\n-            }\n-        },\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+            testNegativeZeroAndNaN();\n+        }\n@@ -1452,4 +3083,4 @@\n-        ORGAN_PIPES {\n-            @Override\n-            void build(int[] a, int m) {\n-                int middle = a.length \/ (m + 1);\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n@@ -1457,5 +3088,7 @@\n-                for (int i = 0; i < middle; ++i) {\n-                    a[i] = i;\n-                }\n-                for (int i = middle; i < a.length; ++i) {\n-                    a[i] = a.length - i - 1;\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n@@ -1464,1 +3097,1 @@\n-        },\n+        }\n@@ -1466,5 +3099,16 @@\n-        PLATEAU {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = Math.min(i, m);\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n@@ -1473,1 +3117,1 @@\n-        },\n+        }\n@@ -1475,4 +3119,6 @@\n-        LATCH {\n-            @Override\n-            void build(int[] a, int m) {\n-                int max = Math.max(a.length \/ m, 2);\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -1480,2 +3126,7 @@\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = i % max;\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n@@ -1484,1 +3135,5 @@\n-        },\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n@@ -1486,5 +3141,7 @@\n-        POINT {\n-            @Override\n-            void build(int[] a, int m) {\n-                Arrays.fill(a, 0);\n-                a[a.length \/ 2] = m;\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n@@ -1492,1 +3149,1 @@\n-        },\n+        }\n@@ -1494,5 +3151,9 @@\n-        LINE {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = i;\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n@@ -1500,1 +3161,0 @@\n-                reverse(a, Math.max(0, a.length - m), a.length);\n@@ -1502,1 +3162,1 @@\n-        },\n+        }\n@@ -1504,5 +3164,9 @@\n-        PEARL {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = i;\n+        private void testNegativeZeroAndNaN() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : FloatingPointBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    scramble();\n+                    print(\"negative zero and NaN\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    check(test, m);\n@@ -1510,1 +3174,0 @@\n-                reverse(a, 0, Math.min(m, a.length));\n@@ -1512,1 +3175,1 @@\n-        },\n+        }\n@@ -1514,5 +3177,8 @@\n-        TRAPEZIUM {\n-            @Override\n-            void build(int[] a, int m) {\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = i;\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n@@ -1520,1 +3186,0 @@\n-                reverse(a, m, a.length - m);\n@@ -1522,1 +3187,1 @@\n-        },\n+        }\n@@ -1524,6 +3189,4 @@\n-        RING {\n-            @Override\n-            void build(int[] a, int m) {\n-                int k1 = a.length \/ 3;\n-                int k2 = a.length \/ 3 * 2;\n-                int level = a.length \/ 3;\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n@@ -1531,2 +3194,4 @@\n-                for (int i = 0, k = level; i < k1; ++i) {\n-                    a[i] = k--;\n+        private void checkSorted(double[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n@@ -1534,2 +3199,4 @@\n-                for (int i = k1; i < k2; ++i) {\n-                    a[i] = 0;\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n@@ -1537,2 +3204,4 @@\n-                for (int i = k2, k = level; i < a.length; ++i) {\n-                    a[i] = k--;\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n@@ -1541,1 +3210,10 @@\n-        };\n+        }\n+\n+        private void checkCheckSum(double[] a, double[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n@@ -1543,1 +3221,2 @@\n-        abstract void build(int[] a, int m);\n+        private int checkSumXor(double[] a) {\n+            int checkSum = 0;\n@@ -1545,5 +3224,2 @@\n-        private static void reverse(int[] a, int lo, int hi) {\n-            for (--hi; lo < hi; ) {\n-                int tmp = a[lo];\n-                a[lo++] = a[hi];\n-                a[hi--] = tmp;\n+            for (double e : a) {\n+                checkSum ^= (int) e;\n@@ -1551,0 +3227,1 @@\n+            return checkSum;\n@@ -1552,1 +3229,0 @@\n-    }\n@@ -1554,5 +3230,2 @@\n-    private enum NegativeZeroBuilder {\n-        FLOAT {\n-            @Override\n-            void build(Object o, Random random) {\n-                float[] a = (float[]) o;\n+        private int checkSumPlus(double[] a) {\n+            int checkSum = 0;\n@@ -1560,2 +3233,10 @@\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = random.nextBoolean() ? -0.0f : 0.0f;\n+            for (double e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare(double[] a, double[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n@@ -1564,1 +3245,33 @@\n-        },\n+        }\n+\n+        private void sortByInsertionSort(double[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = Double.NEGATIVE_INFINITY;\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"Double\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap(double[] a, int i, int j) {\n+            double t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse(double[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+        private void check(double[] a, int m) {\n+            final long NEGATIVE_ZERO = Double.doubleToLongBits(-0.0d);\n@@ -1566,4 +3279,4 @@\n-        DOUBLE {\n-            @Override\n-            void build(Object o, Random random) {\n-                double[] a = (double[]) o;\n+            int k1 = a.length \/ (m + 1) * m     \/ 5;\n+            int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+            int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+            int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n@@ -1571,2 +3284,15 @@\n-                for (int i = 0; i < a.length; ++i) {\n-                    a[i] = random.nextBoolean() ? -0.0d : 0.0d;\n+            for (int i = 0; i < k1; ++i) {\n+                double v = (double) (-(a.length + m) + i);\n+\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k1; i < k2; ++i) {\n+                if (Double.doubleToLongBits(a[i]) != NEGATIVE_ZERO) {\n+                    fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k2; i < k3; ++i) {\n+                if (a[i] != 0.0d || Double.doubleToLongBits(a[i]) == NEGATIVE_ZERO) {\n+                    fail(\"There must be 0.0 instead of \" + a[i] + \" at position \" + i);\n@@ -1575,1 +3301,2 @@\n-        };\n+            for (int i = k3; i < k4; ++i) {\n+                double v = (double) (m + i);\n@@ -1577,2 +3304,10 @@\n-        abstract void build(Object o, Random random);\n-    }\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k4; i < a.length; ++i) {\n+                if (!Double.isNaN(a[i])) {\n+                    fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n@@ -1580,8 +3315,3 @@\n-    private enum FloatingPointBuilder {\n-        FLOAT {\n-            @Override\n-            void build(Object o, int k, int g, int z, int n, int p, Random random) {\n-                float negativeValue = -random.nextFloat();\n-                float positiveValue = random.nextFloat();\n-                float[] a = (float[]) o;\n-                int fromIndex = 0;\n+        private interface Builder {\n+            void build(double[] a, int m);\n+        }\n@@ -1589,2 +3319,9 @@\n-                fillWithValue(a, Float.NEGATIVE_INFINITY, fromIndex, 1);\n-                fromIndex += 1;\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n@@ -1592,2 +3329,12 @@\n-                fillWithValue(a, -Float.MAX_VALUE, fromIndex, 1);\n-                fromIndex += 1;\n+            STEPS {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n@@ -1595,2 +3342,9 @@\n-                fillWithValue(a, negativeValue, fromIndex, n);\n-                fromIndex += n;\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) random.nextInt();\n+                    }\n+                }\n+            },\n@@ -1598,2 +3352,11 @@\n-                fillWithValue(a, -0.0f, fromIndex, g);\n-                fromIndex += g;\n+            PERMUTATION {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n@@ -1601,2 +3364,4 @@\n-                fillWithValue(a, 0.0f, fromIndex, z);\n-                fromIndex += z;\n+            UNIFORM {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int mask = (m << 15) - 1;\n@@ -1604,2 +3369,5 @@\n-                fillWithValue(a, positiveValue, fromIndex, p);\n-                fromIndex += p;\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n@@ -1607,2 +3375,8 @@\n-                fillWithValue(a, Float.MAX_VALUE, fromIndex, 1);\n-                fromIndex += 1;\n+            REPEATED {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (i % m);\n+                    }\n+                }\n+            },\n@@ -1610,2 +3384,22 @@\n-                fillWithValue(a, Float.POSITIVE_INFINITY, fromIndex, 1);\n-                fromIndex += 1;\n+            DUPLICATED {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (double) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = (double) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n@@ -1613,1 +3407,7 @@\n-                fillWithValue(a, Float.NaN, fromIndex, k);\n+            SHUFFLE {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = (double) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n@@ -1615,1 +3415,20 @@\n-        },\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (a.length - m - i);\n+                    }\n+                }\n+            },\n@@ -1617,7 +3436,6 @@\n-        DOUBLE {\n-            @Override\n-            void build(Object o, int k, int g, int z, int n, int p, Random random) {\n-                double negativeValue = -random.nextFloat();\n-                double positiveValue = random.nextFloat();\n-                double[] a = (double[]) o;\n-                int fromIndex = 0;\n+            EQUAL {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    Arrays.fill(a, (double) m);\n+                }\n+            },\n@@ -1625,2 +3443,8 @@\n-                fillWithValue(a, Double.NEGATIVE_INFINITY, fromIndex, 1);\n-                fromIndex++;\n+            SHIFTED {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (i << 10);\n+                    }\n+                }\n+            },\n@@ -1628,2 +3452,4 @@\n-                fillWithValue(a, -Double.MAX_VALUE, fromIndex, 1);\n-                fromIndex++;\n+            ORGAN_PIPES {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n@@ -1631,2 +3457,8 @@\n-                fillWithValue(a, negativeValue, fromIndex, n);\n-                fromIndex += n;\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = (double) (a.length - i - 1);\n+                    }\n+                }\n+            },\n@@ -1634,2 +3466,8 @@\n-                fillWithValue(a, -0.0d, fromIndex, g);\n-                fromIndex += g;\n+            PLATEAU {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) Math.min(i, m);\n+                    }\n+                }\n+            },\n@@ -1637,2 +3475,4 @@\n-                fillWithValue(a, 0.0d, fromIndex, z);\n-                fromIndex += z;\n+            LATCH {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n@@ -1640,2 +3480,5 @@\n-                fillWithValue(a, positiveValue, fromIndex, p);\n-                fromIndex += p;\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) (i % max);\n+                    }\n+                }\n+            },\n@@ -1643,2 +3486,7 @@\n-                fillWithValue(a, Double.MAX_VALUE, fromIndex, 1);\n-                fromIndex += 1;\n+            POINT {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    Arrays.fill(a, (double) 0);\n+                    a[a.length \/ 2] = (double) m;\n+                }\n+            },\n@@ -1646,2 +3494,9 @@\n-                fillWithValue(a, Double.POSITIVE_INFINITY, fromIndex, 1);\n-                fromIndex += 1;\n+            LINE {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n@@ -1649,3 +3504,9 @@\n-                fillWithValue(a, Double.NaN, fromIndex, k);\n-            }\n-        };\n+            PEARL {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n@@ -1653,1 +3514,9 @@\n-        abstract void build(Object o, int k, int g, int z, int n, int p, Random random);\n+            TRAPEZIUM {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n@@ -1655,3 +3524,7 @@\n-        private static void fillWithValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; ++i) {\n-                a[i] = value;\n+            STAGGER {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = (double) ((i * m + i) % a.length);\n+                    }\n+                }\n@@ -1661,3 +3534,25 @@\n-        private static void fillWithValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; ++i) {\n-                a[i] = value;\n+        private enum FloatingPointBuilder implements Builder {\n+            NEGATIVE_ZERO_AND_NAN {\n+                @Override\n+                public void build(double[] a, int m) {\n+                    int k1 = a.length \/ (m + 1) * m     \/ 5;\n+                    int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+                    int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+                    int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n+\n+                    for (int i = 0; i < k1; ++i) {\n+                        a[i] = (double) (-(a.length + m) + i);\n+                    }\n+                    for (int i = k1; i < k2; ++i) {\n+                        a[i] = -0.0d;\n+                    }\n+                    for (int i = k2; i < k3; ++i) {\n+                        a[i] = 0.0d;\n+                    }\n+                    for (int i = k3; i < k4; ++i) {\n+                        a[i] = (double) (m + i);\n+                    }\n+                    for (int i = k4; i < a.length; ++i) {\n+                        a[i] = Double.NaN;\n+                    }\n+                }\n@@ -1668,15 +3563,3 @@\n-    private static class TestRandom extends Random {\n-\n-        private static final TestRandom DEDA = new TestRandom(0xDEDA);\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n-        private static final TestRandom C0FFEE = new TestRandom(0xC0FFEE);\n-\n-        private TestRandom(long seed) {\n-            super(seed);\n-            this.seed = Long.toHexString(seed).toUpperCase();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return seed;\n-        }\n+    private static void out(String name, String type, int length, SortingHelper sortingHelper, int m, Object builder) {\n+        out.println(\"[ \" + type + \" | Length = \" + length + \" | \" + sortingHelper + \" ] 'Test \" + name + \"', m = \" + m + \", \" + builder);\n+    }\n@@ -1684,1 +3567,3 @@\n-        private final String seed;\n+    private static void fail(String message) {\n+        err.format(\"*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":3125,"deletions":1240,"binary":false,"changes":4365,"status":"modified"},{"patch":"@@ -0,0 +1,672 @@\n+#if[Common1]\n+\/*\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+\/*\n+ * @test\n+ * @compile\/module=java.base java\/util\/SortingHelper.java\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n+ * @build Sorting\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:DisableIntrinsic=_arraySort,_arrayPartition Sorting -shortrun\n+ * @run main\/othervm -XX:-TieredCompilation -XX:CompileCommand=CompileThresholdScaling,java.util.DualPivotQuicksort::sort,0.0001 Sorting -shortrun\n+ * @summary Exercise Arrays.sort, Arrays.parallelSort\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ * @author Jon Bentley\n+ * @author Josh Bloch\n+ *\/\n+\n+import java.io.PrintStream;\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.SortingHelper;\n+\n+public class Sorting {\n+\n+    private static final PrintStream out = System.out;\n+    private static final PrintStream err = System.err;\n+\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_LENGTHS =\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000 };\n+\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_LENGTHS =\n+        { 1, 2, 3, 14, 55, 100, 500, 1_000, 14_000, 64_000};\n+\n+    private static final Random random = new Random(0xC0FFEE);\n+\n+    public static void main(String[] args) {\n+        boolean shortRun = args.length > 0 && args[0].equals(\"-shortrun\");\n+        int[] lengths = shortRun ? SHORT_LENGTHS : LONG_LENGTHS;\n+        long start = System.currentTimeMillis();\n+\n+        for (int length : lengths) {\n+            new IntegerHolder().test(length);\n+            new LongHolder().test(length);\n+            new ByteHolder().test(length);\n+            new CharacterHolder().test(length);\n+            new ShortHolder().test(length);\n+            new FloatHolder().test(length);\n+            new DoubleHolder().test(length);\n+        }\n+        long end = System.currentTimeMillis();\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n+    }\n+#end[Common1]\n+#if[AllTypes]\n+\n+    private static class $Type$Holder {\n+        \/\/ Constant to fill the left part of array\n+        private static final $type$ A380 = ($type$) 0xA380;\n+\n+        \/\/ Constant to fill the right part of array\n+        private static final $type$ B747 = ($type$) 0xB747;\n+\n+        private SortingHelper sortingHelper;\n+        private boolean withMin;\n+        private $type$[] gold;\n+        private $type$[] test;\n+\n+        private $Type$Holder set(SortingHelper sortingHelper) {\n+            return set(sortingHelper, false);\n+        }\n+\n+        private $Type$Holder set(SortingHelper sortingHelper, boolean withMin) {\n+            this.sortingHelper = sortingHelper;\n+            this.withMin = withMin;\n+            return this;\n+        }\n+\n+        private void test(int length) {\n+            gold = new $type$[length];\n+            test = new $type$[length];\n+\n+#if[IntLongFloatDouble]\n+            set(SortingHelper.MERGING_SORT).testStructured();\n+            set(SortingHelper.MIXED_INSERTION_SORT, true).testBase();\n+#end[IntLongFloatDouble]\n+#if[AllTypes]\n+            set(SortingHelper.INSERTION_SORT).testBase();\n+#end[AllTypes]\n+#if[IntLongFloatDouble]\n+            set(SortingHelper.HEAP_SORT).testBase();\n+#end[IntLongFloatDouble]\n+#if[ByteCharShort]\n+            set(SortingHelper.COUNTING_SORT).testCore();\n+#end[ByteCharShort]\n+#if[AllTypes]\n+            set(SortingHelper.DUAL_PIVOT_QUICKSORT).testCore();\n+#end[AllTypes]\n+#if[IntLongFloatDouble]\n+            set(SortingHelper.PARALLEL_QUICKSORT).testCore();\n+#end[IntLongFloatDouble]\n+#if[AllTypes]\n+            set(SortingHelper.ARRAYS_SORT).testAll();\n+            set(SortingHelper.ARRAYS_PARALLEL_SORT).testAll();\n+#end[AllTypes]\n+\n+            out.println();\n+        }\n+\n+        private void testEmpty() {\n+            sortingHelper.sort(new $type$[test.length], 0, 0);\n+        }\n+\n+        private void testStructured() {\n+            testEmpty();\n+\n+            if (test.length < 512) {\n+                return;\n+            }\n+            for (int m = 1; m < 9; ++m) {\n+                for (Builder builder : StructuredBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"structured\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    checkWithCheckSum(0);\n+                }\n+            }\n+        }\n+\n+        private void testBase() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+        }\n+\n+        private void testCore() {\n+            testStructured();\n+            testWithCheckSum();\n+            testWithInsertionSort();\n+            testWithScrambling();\n+#if[FloatDouble]\n+            testNegativeZeroAndNaN();\n+#end[FloatDouble]\n+        }\n+\n+        private void testAll() {\n+            testCore();\n+            testRange();\n+        }\n+\n+        private void testRange() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"range\", m, builder);\n+                    testRange(m);\n+                }\n+            }\n+        }\n+\n+        private void testRange(int m) {\n+            try {\n+                sortingHelper.sort(test, m + 1, m);\n+                fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                        \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+            } catch (IllegalArgumentException iae) {\n+                try {\n+                    sortingHelper.sort(test, -m, test.length);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"fromIndex = \" + (-m));\n+                } catch (ArrayIndexOutOfBoundsException aoe) {\n+                    try {\n+                        sortingHelper.sort(test, 0, test.length + m);\n+                        fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                                \"toIndex = \" + (test.length + m));\n+                    } catch (ArrayIndexOutOfBoundsException expected) {}\n+                }\n+            }\n+        }\n+\n+        private void testWithInsertionSort() {\n+            if (test.length > 1_000) {\n+                return;\n+            }\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with insertion sort\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    sortByInsertionSort(gold, offset, test.length - offset);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+        private void testWithCheckSum() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                int offset = m \/ 4;\n+\n+                for (Builder builder : UnsortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(offset);\n+                    print(\"with check sum\", m, builder);\n+                    sortingHelper.sort(test, offset, test.length - offset);\n+                    checkWithCheckSum(offset);\n+                }\n+            }\n+        }\n+\n+        private void testWithScrambling() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : SortedBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    print(\"with scrambling\", m, builder);\n+                    scramble();\n+                    sortingHelper.sort(test, 0, test.length);\n+                    compare(test, gold);\n+                }\n+            }\n+        }\n+\n+#if[FloatDouble]\n+        private void testNegativeZeroAndNaN() {\n+            for (int m = 1; m <= test.length; m <<= 1) {\n+                for (Builder builder : FloatingPointBuilder.values()) {\n+                    builder.build(gold, m);\n+                    setup(0);\n+                    scramble();\n+                    print(\"negative zero and NaN\", m, builder);\n+                    sortingHelper.sort(test, 0, test.length);\n+                    check(test, m);\n+                }\n+            }\n+        }\n+\n+#end[FloatDouble]\n+        private void scramble() {\n+            if (withMin) {\n+                for (int i = 7; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length - 1) + 1, random.nextInt(test.length - 1) + 1);\n+                }\n+            } else {\n+                for (int i = 0; i < test.length * 7; ++i) {\n+                    swap(test, random.nextInt(test.length), random.nextInt(test.length));\n+                }\n+            }\n+        }\n+\n+        private void checkWithCheckSum(int m) {\n+            checkSorted(test, m);\n+            checkCheckSum(test, gold);\n+        }\n+\n+        private void checkSorted($type$[] a, int m) {\n+            for (int i = 0; i < m; ++i) {\n+                if (a[i] != A380) {\n+                    fail(\"Sort changes left element at position \" + i + \": \" + a[i] + \", must be A380\");\n+                }\n+            }\n+            for (int i = m; i < a.length - m - 1; ++i) {\n+                if (a[i] > a[i + 1]) {\n+                    fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n+                }\n+            }\n+            for (int i = a.length - m; i < a.length; ++i) {\n+                if (a[i] != B747) {\n+                    fail(\"Sort changes right element at position \" + i + \": \" + a[i] + \", must be B747\");\n+                }\n+            }\n+        }\n+\n+        private void checkCheckSum($type$[] a, $type$[] b) {\n+            if (checkSumXor(a) != checkSumXor(b)) {\n+                fail(\"Original and sorted arrays are not identical [^]\");\n+            }\n+            if (checkSumPlus(a) != checkSumPlus(b)) {\n+                fail(\"Original and sorted arrays are not identical [+]\");\n+            }\n+        }\n+\n+        private int checkSumXor($type$[] a) {\n+            int checkSum = 0;\n+\n+            for ($type$ e : a) {\n+                checkSum ^= (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private int checkSumPlus($type$[] a) {\n+            int checkSum = 0;\n+\n+            for ($type$ e : a) {\n+                checkSum += (int) e;\n+            }\n+            return checkSum;\n+        }\n+\n+        private void compare($type$[] a, $type$[] b) {\n+            for (int i = 0; i < a.length; ++i) {\n+                if (a[i] != b[i]) {\n+                    fail(\"There must be \" + b[i] + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+        private void sortByInsertionSort($type$[] a, int low, int high) {\n+            SortingHelper.INSERTION_SORT.sort(a, low, high);\n+        }\n+\n+        private void setup(int m) {\n+            for (int i = 0; i < m; ++i) {\n+                gold[i] = A380;\n+            }\n+            for (int i = gold.length - m; i < gold.length; ++i) {\n+                gold[i] = B747;\n+            }\n+            if (withMin) {\n+                gold[m] = $Type$.{#if[!FloatDouble]?MIN_VALUE}{#if[FloatDouble]?NEGATIVE_INFINITY};\n+            }\n+            test = gold.clone();\n+        }\n+\n+        private void print(String name, int m, Builder builder) {\n+            out(name, \"$Type$\", test.length, sortingHelper, m, builder);\n+        }\n+\n+        private static void swap($type$[] a, int i, int j) {\n+            $type$ t = a[i]; a[i] = a[j]; a[j] = t;\n+        }\n+\n+        private static void reverse($type$[] a, int lo, int hi) {\n+            for (--hi; lo < hi; swap(a, lo++, hi--));\n+        }\n+\n+#if[FloatDouble]\n+        private void check($type$[] a, int m) {\n+            final {#if[Float]?int}{#if[Double]?long} NEGATIVE_ZERO = $Type$.{#if[Float]?floatToIntBits(-0.0f)}{#if[Double]?doubleToLongBits(-0.0d)};\n+\n+            int k1 = a.length \/ (m + 1) * m     \/ 5;\n+            int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+            int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+            int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n+\n+            for (int i = 0; i < k1; ++i) {\n+                $type$ v = ($type$) (-(a.length + m) + i);\n+\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k1; i < k2; ++i) {\n+                if ($Type$.{#if[Float]?floatToIntBits(a[i])}{#if[Double]?doubleToLongBits(a[i])} != NEGATIVE_ZERO) {\n+                    fail(\"There must be -0.0 instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k2; i < k3; ++i) {\n+                if (a[i] != 0.0{#if[Float]?f}{#if[Double]?d} || $Type$.{#if[Float]?floatToIntBits(a[i])}{#if[Double]?doubleToLongBits(a[i])} == NEGATIVE_ZERO) {\n+                    fail(\"There must be 0.0 instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k3; i < k4; ++i) {\n+                $type$ v = ($type$) (m + i);\n+\n+                if (a[i] != v) {\n+                    fail(\"There must be \" + v + \" instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+            for (int i = k4; i < a.length; ++i) {\n+                if (!$Type$.isNaN(a[i])) {\n+                    fail(\"There must be NaN instead of \" + a[i] + \" at position \" + i);\n+                }\n+            }\n+        }\n+\n+#end[FloatDouble]\n+        private interface Builder {\n+            void build($type$[] a, int m);\n+        }\n+\n+        private enum SortedBuilder implements Builder {\n+            ANGLE {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (Math.min(i + m, 127));\n+                    }\n+                }\n+            },\n+\n+            STEPS {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < m; ++i) {\n+                        a[i] = 0;\n+                    }\n+                    for (int i = m; i < a.length; ++i) {\n+                        a[i] = 1;\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum UnsortedBuilder implements Builder {\n+            RANDOM {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) random.nextInt();\n+                    }\n+                }\n+            },\n+\n+            PERMUTATION {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (m + i);\n+                    }\n+                    for (int i = a.length; i > 1; --i) {\n+                        swap(a, i - 1, random.nextInt(i));\n+                    }\n+                }\n+            },\n+\n+            UNIFORM {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int mask = (m << 15) - 1;\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (random.nextInt() & mask);\n+                    }\n+                }\n+            },\n+\n+            REPEATED {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (i % m);\n+                    }\n+                }\n+            },\n+\n+            DUPLICATED {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) random.nextInt(m);\n+                    }\n+                }\n+            },\n+\n+            SAWTOOTH {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0, minus = a.length, plus = 0; i < a.length; ) {\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = ($type$) (++plus);\n+                        }\n+                        for (int k = 0; ++k <= m && i < a.length; ++i) {\n+                            a[i] = ($type$) (--minus);\n+                        }\n+                    }\n+                }\n+            },\n+\n+            SHUFFLE {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                        a[i] = ($type$) (random.nextInt(m) > 0 ? (j += 2) : (k += 2));\n+                    }\n+                }\n+            }\n+        }\n+\n+        private enum StructuredBuilder implements Builder {\n+            ASCENDING {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (m + i);\n+                    }\n+                }\n+            },\n+\n+            DESCENDING {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (a.length - m - i);\n+                    }\n+                }\n+            },\n+\n+            EQUAL {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    Arrays.fill(a, ($type$) m);\n+                }\n+            },\n+\n+            SHIFTED {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (i << 10);\n+                    }\n+                }\n+            },\n+\n+            ORGAN_PIPES {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int middle = a.length \/ (m + 1);\n+\n+                    for (int i = 0; i < middle; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    for (int i = middle; i < a.length; ++i) {\n+                        a[i] = ($type$) (a.length - i - 1);\n+                    }\n+                }\n+            },\n+\n+            PLATEAU {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) Math.min(i, m);\n+                    }\n+                }\n+            },\n+\n+            LATCH {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int max = Math.max(a.length \/ m, 2);\n+\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) (i % max);\n+                    }\n+                }\n+            },\n+\n+            POINT {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    Arrays.fill(a, ($type$) 0);\n+                    a[a.length \/ 2] = ($type$) m;\n+                }\n+            },\n+\n+            LINE {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    reverse(a, Math.max(0, a.length - m), a.length);\n+                }\n+            },\n+\n+            PEARL {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    reverse(a, 0, Math.min(m, a.length));\n+                }\n+            },\n+\n+            TRAPEZIUM {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) i;\n+                    }\n+                    reverse(a, m, a.length - m);\n+                }\n+            },\n+\n+            STAGGER {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    for (int i = 0; i < a.length; ++i) {\n+                        a[i] = ($type$) ((i * m + i) % a.length);\n+                    }\n+                }\n+            }\n+        }\n+#if[FloatDouble]\n+\n+        private enum FloatingPointBuilder implements Builder {\n+            NEGATIVE_ZERO_AND_NAN {\n+                @Override\n+                public void build($type$[] a, int m) {\n+                    int k1 = a.length \/ (m + 1) * m     \/ 5;\n+                    int k2 = a.length \/ (m + 1) * m * 2 \/ 5;\n+                    int k3 = a.length \/ (m + 1) * m * 3 \/ 5;\n+                    int k4 = a.length \/ (m + 1) * m * 4 \/ 5;\n+\n+                    for (int i = 0; i < k1; ++i) {\n+                        a[i] = ($type$) (-(a.length + m) + i);\n+                    }\n+                    for (int i = k1; i < k2; ++i) {\n+                        a[i] = -0.0{#if[Float]?f}{#if[Double]?d};\n+                    }\n+                    for (int i = k2; i < k3; ++i) {\n+                        a[i] = 0.0{#if[Float]?f}{#if[Double]?d};\n+                    }\n+                    for (int i = k3; i < k4; ++i) {\n+                        a[i] = ($type$) (m + i);\n+                    }\n+                    for (int i = k4; i < a.length; ++i) {\n+                        a[i] = $Type$.NaN;\n+                    }\n+                }\n+            }\n+        }\n+#end[FloatDouble]\n+    }\n+#end[AllTypes]\n+#if[Common2]\n+\n+    private static void out(String name, String type, int length, SortingHelper sortingHelper, int m, Object builder) {\n+        out.println(\"[ \" + type + \" | Length = \" + length + \" | \" + sortingHelper + \" ] 'Test \" + name + \"', m = \" + m + \", \" + builder);\n+    }\n+\n+    private static void fail(String message) {\n+        err.format(\"*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n+    }\n+}\n+#end[Common2]\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java.template","additions":672,"deletions":0,"binary":false,"changes":672,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+#!\/bin\/bash\n+\n+javac -d . ..\/..\/..\/..\/..\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\n+\n+in=Sorting.java.template\n+out=Sorting.java\n+\n+rm -rf $out\n+\n+gen() {\n+    java build.tools.spp.Spp -nel -Dtype=$1 -DType=$2 -K$3 -K$4 -K$5 -K$6 -i$in -o$out\n+}\n+\n+gen \"\"     \"\"        Common1  \"\"                 \"\"                 \"\"\n+gen int    Integer   AllTypes IntLongFloatDouble IntLongFloatDouble \"\"\n+gen long   Long      AllTypes IntLongFloatDouble IntLongFloatDouble \"\"\n+gen byte   Byte      AllTypes ByteCharShort      \"\"                 \"\"\n+gen char   Character AllTypes ByteCharShort      \"\"                 \"\"\n+gen short  Short     AllTypes ByteCharShort      \"\"                 \"\"\n+gen float  Float     AllTypes IntLongFloatDouble FloatDouble        Float\n+gen double Double    AllTypes IntLongFloatDouble FloatDouble        Double\n+gen \"\"     \"\"        Common2  \"\"                 \"\"                 \"\"\n+\n+rm -rf build\n","filename":"test\/jdk\/java\/util\/Arrays\/gen-Sorting.sh","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -59,3 +59,0 @@\n-                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n-                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n-                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n@@ -73,7 +70,4 @@\n-                case int[] ai -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, ai, low, high - low));\n-                case long[] al -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, al, low, high - low));\n-                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n-                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n-                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n-                case float[] af -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, af, low, high - low));\n-                case double[] ad -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, ad, low, high - low));\n+                case int[] ai -> checkMerging(DualPivotQuicksort.tryMergingSort(null, ai, low, high - low));\n+                case long[] al -> checkMerging(DualPivotQuicksort.tryMergingSort(null, al, low, high - low));\n+                case float[] af -> checkMerging(DualPivotQuicksort.tryMergingSort(null, af, low, high - low));\n+                case double[] ad -> checkMerging(DualPivotQuicksort.tryMergingSort(null, ad, low, high - low));\n@@ -89,2 +83,0 @@\n-                case int[] ai -> DualPivotQuicksort.sort(ai, 0, low, high);\n-                case long[] al -> DualPivotQuicksort.sort(al, 0, low, high);\n@@ -94,2 +86,0 @@\n-                case float[] af -> DualPivotQuicksort.sort(af, 0, low, high);\n-                case double[] ad -> DualPivotQuicksort.sort(ad, 0, low, high);\n@@ -107,3 +97,0 @@\n-                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n-                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n-                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n@@ -134,2 +121,0 @@\n-        final int parallel = 4;\n-\n@@ -139,7 +124,4 @@\n-                case int[] ai -> DualPivotQuicksort.sort(ai, parallel, low, high);\n-                case long[] al -> DualPivotQuicksort.sort(al, parallel, low, high);\n-                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n-                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n-                case short[] as -> DualPivotQuicksort.sort(as,low, high);\n-                case float[] af -> DualPivotQuicksort.sort(af, parallel, low, high);\n-                case double[] ad -> DualPivotQuicksort.sort(ad, parallel, low, high);\n+                case int[] ai -> DualPivotQuicksort.sort(ai, 4, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, 4, low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, 4, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, 4, low, high);\n@@ -152,14 +134,0 @@\n-        @Override\n-        public void sort(Object a) {\n-            switch(a) {\n-                case int[] ai -> Arrays.sort(ai);\n-                case long[] al -> Arrays.sort(al);\n-                case byte[] ab -> Arrays.sort(ab);\n-                case char[] ac -> Arrays.sort(ac);\n-                case short[] as -> Arrays.sort(as);\n-                case float[] af -> Arrays.sort(af);\n-                case double[] ad -> Arrays.sort(ad);\n-                default -> fail(a);\n-            }\n-        }\n-\n@@ -182,14 +150,0 @@\n-        @Override\n-        public void sort(Object a) {\n-            switch(a) {\n-                case int[] ai -> Arrays.parallelSort(ai);\n-                case long[] al -> Arrays.parallelSort(al);\n-                case byte[] ab -> Arrays.parallelSort(ab);\n-                case char[] ac -> Arrays.parallelSort(ac);\n-                case short[] as -> Arrays.parallelSort(as);\n-                case float[] af -> Arrays.parallelSort(af);\n-                case double[] ad -> Arrays.parallelSort(ad);\n-                default -> fail(a);\n-            }\n-        }\n-\n@@ -217,13 +171,0 @@\n-    public void sort(Object a) {\n-        switch(a) {\n-            case int[] ai -> sort(ai, 0, ai.length);\n-            case long[] al -> sort(al, 0, al.length);\n-            case byte[] ab -> sort(ab, 0, ab.length);\n-            case char[] ac -> sort(ac, 0, ac.length);\n-            case short[] as -> sort(as, 0, as.length);\n-            case float[] af -> sort(af, 0, af.length);\n-            case double[] ad -> sort(ad, 0, ad.length);\n-            default -> fail(a);\n-        }\n-    }\n-\n@@ -235,1 +176,1 @@\n-    private static void check(String name, boolean result) {\n+    private static void checkMerging(boolean result) {\n@@ -237,1 +178,1 @@\n-            fail(name + \" sort must return true\");\n+            fail(\"Merging sort must return true\");\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":10,"deletions":69,"binary":false,"changes":79,"status":"modified"}]}