{"files":[{"patch":"@@ -26,0 +26,2 @@\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n@@ -42,2 +44,43 @@\n- * (pin, simple and pair) insertion sort, counting sort and parallel\n- * merge sort.\n+ * insertion sort, counting sort and parallel merge sort. The actual\n+ * sorting algorithm depends on the data type and array size.<p>\n+ *\n+ * <b>Type: int\/long\/float\/double<\/b><p>\n+ *\n+ * If the array size is small, invoke mixed insertion sort on non-leftmost\n+ * parts or insertion sort on leftmost part.<p>\n+ *\n+ * Then try merging sort which is the best on almost sorted arrays.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with heap sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Type: float\/double<\/b><p>\n+ *\n+ * Floating-point values require additional steps to process\n+ * negative zeros -0.0 and NaNs (Not-a-Number) before sorting and\n+ * re-arrange negative zeros at the end.<p>\n+ *\n+ * <b>Type: byte<\/b><p>\n+ *\n+ * Invoke insertion sort, if the array size is small, otherwise switch\n+ * to counting sort.<p>\n+ *\n+ * <b>Type: char\/short<\/b><p>\n+ *\n+ * Invoke counting sort on large array, otherwise run insertion sort\n+ * on small array.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with counting sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+ *\n+ * If the array size is small, sequential sort is run. Otherwise\n+ * invoke parallel merge sort (the recursion depth depends on\n+ * parallelism level), then run parallel Quicksort.\n@@ -64,1 +107,1 @@\n-     * Max size of array to use insertion sort (the best for shuffle data).\n+     * Max size of array to use insertion sort (the best on shuffle data).\n@@ -66,1 +109,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 51;\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n@@ -71,1 +114,1 @@\n-     * Min size of array to use merging sort (the best for stagger data).\n+     * Min size of array to use merging sort (the best on stagger data).\n@@ -76,1 +119,1 @@\n-     * Min size of run to continue scanning (the best for stagger data).\n+     * Min size of run to continue scanning (the best on stagger data).\n@@ -88,1 +131,1 @@\n-     * Min size of array to use counting sort (the best for random data).\n+     * Min size of array to use counting sort (the best on random data).\n@@ -93,1 +136,1 @@\n-     * Min size of array to use numerical sort (the best for repeated data).\n+     * Min size of array to use numerical sort (the best on repeated data).\n@@ -100,1 +143,1 @@\n-     * Min size of array to perform sorting in parallel (the best for stagger data).\n+     * Min size of array to perform sorting in parallel (the best on stagger data).\n@@ -208,0 +251,2 @@\n+\/\/ #[int]\n+\n@@ -255,1 +300,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -257,1 +302,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n@@ -549,2 +594,2 @@\n-     * Mixed insertion sort is combination of pin insertion sort,\n-     * simple insertion sort and pair insertion sort.<p>\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -564,1 +609,1 @@\n-         * Split part for pin and pair insertion sorts.\n+         * Split the array for pin and pair insertion sorts.\n@@ -566,16 +611,1 @@\n-        int end = high - 3 * ((high - low) >> 3 << 1);\n-\n-        \/*\n-         * Invoke simple insertion sort on small part.\n-         *\/\n-        if (end == high) {\n-            for (int i; ++low < high; ) {\n-                int ai = a[i = low];\n-\n-                while (ai < a[i - 1]) {\n-                    a[i] = a[--i];\n-                }\n-                a[i] = ai;\n-            }\n-            return;\n-        }\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n@@ -1061,1 +1091,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -1063,1 +1093,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n@@ -1355,2 +1385,2 @@\n-     * Mixed insertion sort is combination of pin insertion sort,\n-     * simple insertion sort and pair insertion sort.<p>\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -1370,1 +1400,1 @@\n-         * Split part for pin and pair insertion sorts.\n+         * Split the array for pin and pair insertion sorts.\n@@ -1372,16 +1402,1 @@\n-        int end = high - 3 * ((high - low) >> 3 << 1);\n-\n-        \/*\n-         * Invoke simple insertion sort on small part.\n-         *\/\n-        if (end == high) {\n-            for (int i; ++low < high; ) {\n-                long ai = a[i = low];\n-\n-                while (ai < a[i - 1]) {\n-                    a[i] = a[--i];\n-                }\n-                a[i] = ai;\n-            }\n-            return;\n-        }\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n@@ -2012,1 +2027,1 @@\n-                indices = partitionWithOnePivot(a, low, high, e3);\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n@@ -2120,1 +2135,2 @@\n-     * @param pivotIndex the index of single pivot\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n@@ -2124,1 +2140,1 @@\n-            char[] a, int low, int high, int pivotIndex) {\n+            char[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n@@ -2135,1 +2151,1 @@\n-        char pivot = a[pivotIndex];\n+        char pivot = a[pivotIndex1];\n@@ -2144,1 +2160,1 @@\n-        a[pivotIndex] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -2257,2 +2273,2 @@\n-                ++count1[ a[i]        & 0xFF];\n-                ++count2[(a[i] >>> 8) & 0xFF];\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF)];\n@@ -2282,1 +2298,1 @@\n-                        a[--count2[(b[--i] >>> 8) & 0xFF]] = b[i];\n+                        a[--count2[((b[--i] >>> 8) & 0xFF)]] = b[i];\n@@ -2286,1 +2302,1 @@\n-                        b[--count2[(a[--i] >>> 8) & 0xFF] - low] = a[i];\n+                        b[--count2[((a[--i] >>> 8) & 0xFF)] - low] = a[i];\n@@ -2300,32 +2316,0 @@\n-    \/**\n-     * Checks the count array and then computes the histogram.\n-     *\n-     * @param count the count array\n-     * @param total the total number of elements\n-     * @param low the index of the first element, inclusive\n-     * @return {@code true} if the digit must be processed, otherwise {@code false}\n-     *\/\n-    private static boolean processDigit(int[] count, int total, int low) {\n-        \/*\n-         * Check if we can skip the given digit.\n-         *\/\n-        for (int c : count) {\n-            if (c == total) {\n-                return false;\n-            }\n-            if (c > 0) {\n-                break;\n-            }\n-        }\n-\n-        \/*\n-         * Compute the histogram.\n-         *\/\n-        count[0] += low;\n-\n-        for (int i = 0; ++i < count.length; ) {\n-            count[i] += count[i - 1];\n-        }\n-        return true;\n-    }\n-\n@@ -2457,1 +2441,1 @@\n-                indices = partitionWithOnePivot(a, low, high, e3);\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n@@ -2565,1 +2549,2 @@\n-     * @param pivotIndex the index of single pivot\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n@@ -2569,1 +2554,1 @@\n-            short[] a, int low, int high, int pivotIndex) {\n+            short[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n@@ -2580,1 +2565,1 @@\n-        short pivot = a[pivotIndex];\n+        short pivot = a[pivotIndex1];\n@@ -2589,1 +2574,1 @@\n-        a[pivotIndex] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -2769,1 +2754,1 @@\n-         * Phase 1. Count the number of negative zero -0.0f,\n+         * Phase 1. Count the number of negative zero -0.0,\n@@ -2778,1 +2763,1 @@\n-            if (Float.floatToRawIntBits(ak) == FLOAT_NEGATIVE_ZERO) { \/\/ ak is -0.0f\n+            if (Float.floatToRawIntBits(ak) == FLOAT_NEGATIVE_ZERO) { \/\/ ak is -0.0\n@@ -2799,1 +2784,1 @@\n-         * zeros 0.0f back into negative zeros -0.0f.\n+         * zeros 0.0 back into negative zeros -0.0.\n@@ -2820,1 +2805,1 @@\n-         * Replace 0.0f by negative zeros -0.0f.\n+         * Replace 0.0 by negative zeros -0.0.\n@@ -2851,1 +2836,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -2853,1 +2838,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n@@ -3145,2 +3130,2 @@\n-     * Mixed insertion sort is combination of pin insertion sort,\n-     * simple insertion sort and pair insertion sort.<p>\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -3160,1 +3145,1 @@\n-         * Split part for pin and pair insertion sorts.\n+         * Split the array for pin and pair insertion sorts.\n@@ -3162,16 +3147,1 @@\n-        int end = high - 3 * ((high - low) >> 3 << 1);\n-\n-        \/*\n-         * Invoke simple insertion sort on small part.\n-         *\/\n-        if (end == high) {\n-            for (int i; ++low < high; ) {\n-                float ai = a[i = low];\n-\n-                while (ai < a[i - 1]) {\n-                    a[i] = a[--i];\n-                }\n-                a[i] = ai;\n-            }\n-            return;\n-        }\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n@@ -3632,1 +3602,1 @@\n-         * Phase 1. Count the number of negative zero -0.0d,\n+         * Phase 1. Count the number of negative zero -0.0,\n@@ -3641,1 +3611,1 @@\n-            if (Double.doubleToRawLongBits(ak) == DOUBLE_NEGATIVE_ZERO) { \/\/ ak is -0.0d\n+            if (Double.doubleToRawLongBits(ak) == DOUBLE_NEGATIVE_ZERO) { \/\/ ak is -0.0\n@@ -3662,1 +3632,1 @@\n-         * zeros 0.0d back into negative zeros -0.0d.\n+         * zeros 0.0 back into negative zeros -0.0.\n@@ -3683,1 +3653,1 @@\n-         * Replace 0.0d by negative zeros -0.0d.\n+         * Replace 0.0 by negative zeros -0.0.\n@@ -3714,1 +3684,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -3716,1 +3686,1 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n@@ -4008,2 +3978,2 @@\n-     * Mixed insertion sort is combination of pin insertion sort,\n-     * simple insertion sort and pair insertion sort.<p>\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -4023,1 +3993,1 @@\n-         * Split part for pin and pair insertion sorts.\n+         * Split the array for pin and pair insertion sorts.\n@@ -4025,16 +3995,1 @@\n-        int end = high - 3 * ((high - low) >> 3 << 1);\n-\n-        \/*\n-         * Invoke simple insertion sort on small part.\n-         *\/\n-        if (end == high) {\n-            for (int i; ++low < high; ) {\n-                double ai = a[i = low];\n-\n-                while (ai < a[i - 1]) {\n-                    a[i] = a[--i];\n-                }\n-                a[i] = ai;\n-            }\n-            return;\n-        }\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n@@ -4471,0 +4426,32 @@\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c > 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n+        }\n+        return true;\n+    }\n+\n@@ -4475,0 +4462,2 @@\n+     *\n+     * @param <T> the class of array\n@@ -4552,0 +4541,2 @@\n+     *\n+     * @param <T> the class of array\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":138,"deletions":147,"binary":false,"changes":285,"status":"modified"},{"patch":"@@ -0,0 +1,1606 @@\n+#if[Common1]\n+\/*\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+package java.util;\n+\n+import java.util.concurrent.CountedCompleter;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/**\n+ * This class implements powerful and fully optimized versions, both\n+ * sequential and parallel, of the Dual-Pivot Quicksort algorithm by\n+ * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n+ * offers O(n log(n)) performance on all data sets, and is typically\n+ * faster than traditional (one-pivot) Quicksort implementations.<p>\n+ *\n+ * There are also additional algorithms, invoked from the Dual-Pivot\n+ * Quicksort such as merging sort, sorting network, heap sort, mixed\n+ * insertion sort, counting sort and parallel merge sort. The actual\n+ * sorting algorithm depends on the data type and array size.<p>\n+ *\n+ * <b>Type: int\/long\/float\/double<\/b><p>\n+ *\n+ * If the array size is small, invoke mixed insertion sort on non-leftmost\n+ * parts or insertion sort on leftmost part.<p>\n+ *\n+ * Then try merging sort which is the best on almost sorted arrays.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with heap sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Type: float\/double<\/b><p>\n+ *\n+ * Floating-point values require additional steps to process\n+ * negative zeros -0.0 and NaNs (Not-a-Number) before sorting and\n+ * re-arrange negative zeros at the end.<p>\n+ *\n+ * <b>Type: byte<\/b><p>\n+ *\n+ * Invoke insertion sort, if the array size is small, otherwise switch\n+ * to counting sort.<p>\n+ *\n+ * <b>Type: char\/short<\/b><p>\n+ *\n+ * Invoke counting sort on large array, otherwise run insertion sort\n+ * on small array.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with counting sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+ *\n+ * If the array size is small, sequential sort is run. Otherwise\n+ * invoke parallel merge sort (the recursion depth depends on\n+ * parallelism level), then run parallel Quicksort.\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ * @author Jon Bentley\n+ * @author Josh Bloch\n+ * @author Doug Lea\n+ *\n+ * @version 2024.06.14\n+ *\n+ * @since 1.7 * 14 ^ 26\n+ *\/\n+final class DualPivotQuicksort {\n+\n+    \/**\n+     * Prevents instantiation.\n+     *\/\n+    private DualPivotQuicksort() {}\n+\n+    \/* --------------------- Insertion sort --------------------- *\/\n+\n+    \/**\n+     * Max size of array to use insertion sort (the best on shuffle data).\n+     *\/\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n+\n+    \/* ---------------------- Merging sort ---------------------- *\/\n+\n+    \/**\n+     * Min size of array to use merging sort (the best on stagger data).\n+     *\/\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n+\n+    \/**\n+     * Min size of run to continue scanning (the best on stagger data).\n+     *\/\n+    private static final int MIN_RUN_SIZE = 64;\n+\n+    \/**\n+     * Max capacity of the index array to track the runs.\n+     *\/\n+    private static final int MAX_RUN_CAPACITY = 10 << 10;\n+\n+    \/* ---------------------- Digital sort ---------------------- *\/\n+\n+    \/**\n+     * Min size of array to use counting sort (the best on random data).\n+     *\/\n+    private static final int MIN_COUNTING_SORT_SIZE = 640;\n+\n+    \/**\n+     * Min size of array to use numerical sort (the best on repeated data).\n+     *\/\n+    private static final int MIN_NUMERICAL_SORT_SIZE = 9 << 10;\n+\n+    \/* --------------------- Parallel sort ---------------------- *\/\n+\n+    \/**\n+     * Min size of array to perform sorting in parallel (the best on stagger data).\n+     *\/\n+    private static final int MIN_PARALLEL_SORT_SIZE = 3 << 10;\n+\n+    \/* --------------------- Infrastructure --------------------- *\/\n+\n+    \/**\n+     * Max recursive depth before switching to heap sort.\n+     *\/\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n+\n+    \/**\n+     * Max size of additional buffer in bytes,\n+     *      limited by max_heap \/ 16 or 2 GB max.\n+     *\/\n+    private static final int MAX_BUFFER_SIZE =\n+        Math.clamp(Runtime.getRuntime().maxMemory() >>> 4, 0, Integer.MAX_VALUE);\n+\n+    \/**\n+     * Represents a function that accepts the array and sorts\n+     * the specified range of the array into ascending order.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    @FunctionalInterface\n+    private interface SortOperation<T> {\n+        \/**\n+         * Sorts the specified range of the array.\n+         *\n+         * @param a the array to be sorted\n+         * @param low the index of the first element, inclusive, to be sorted\n+         * @param high the index of the last element, exclusive, to be sorted\n+         *\/\n+        void sort(T a, int low, int high);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array into ascending numerical order.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n+     *\n+     * @param <T> the class of array\n+     * @param elemType the class of the elements of the array to be sorted\n+     * @param a the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param so the method reference for the fallback implementation\n+     *\/\n+    @ForceInline\n+    @IntrinsicCandidate\n+    private static <T> void sort(Class<?> elemType, T a, long offset,\n+            int low, int high, SortOperation<T> so) {\n+        so.sort(a, low, high);\n+    }\n+\n+    \/**\n+     * Represents a function that accepts the array and partitions\n+     * the specified range of the array using the given pivots.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    @FunctionalInterface\n+    private interface PartitionOperation<T> {\n+        \/**\n+         * Partitions the specified range of the array using the given pivots.\n+         *\n+         * @param a the array for partitioning\n+         * @param low the index of the first element, inclusive, for partitioning\n+         * @param high the index of the last element, exclusive, for partitioning\n+         * @param pivotIndex1 the index of pivot1, the first pivot\n+         * @param pivotIndex2 the index of pivot2, the second pivot\n+         * @return indices of parts after partitioning\n+         *\/\n+        int[] partition(T a, int low, int high, int pivotIndex1, int pivotIndex2);\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using the given pivots.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n+     *\n+     * @param <T> the class of array\n+     * @param elemType the class of the array for partitioning\n+     * @param a the array for partitioning\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @param po the method reference for the fallback implementation\n+     * @return indices of parts after partitioning\n+     *\/\n+    @ForceInline\n+    @IntrinsicCandidate\n+    private static <T> int[] partition(Class<?> elemType, T a, long offset,\n+            int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<T> po) {\n+        return po.partition(a, low, high, pivotIndex1, pivotIndex2);\n+    }\n+#end[Common1]\n+#if[!Common1]\n+#if[!Common2]\n+\n+\/\/ #[$type$]\n+#end[Common2]\n+#end[Common1]\n+#if[IntLong]\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int parallelism, int low, int high) {\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n+        } else {\n+            sort(null, a, 0, low, high);\n+        }\n+    }\n+#end[IntLong]\n+#if[FloatDouble]\n+\n+    \/**\n+     * The binary representation of $type$ negative zero.\n+     *\/\n+    private static final {#if[Float]?int}{#if[Double]?long} $TYPE$_NEGATIVE_ZERO = {#if[Float]?Float.floatToRawIntBits(-0.0f)}{#if[Double]?Double.doubleToRawLongBits(-0.0d)};\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int parallelism, int low, int high) {\n+        \/*\n+         * Phase 1. Count the number of negative zero -0.0,\n+         * turn them into positive zero, and move all NaNs\n+         * to the end of the array.\n+         *\/\n+        int negativeZeroCount = 0;\n+\n+        for (int k = high; k > low; ) {\n+            $type$ ak = a[--k];\n+\n+            if ({#if[Float]?Float.floatToRawIntBits}{#if[Double]?Double.doubleToRawLongBits}(ak) == $TYPE$_NEGATIVE_ZERO) { \/\/ ak is -0.0\n+                negativeZeroCount++;\n+                a[k] = 0.0{#if[Float]?f}{#if[Double]?d};\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n+                a[k] = a[--high];\n+                a[high] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Phase 2. Sort everything except NaNs,\n+         * which are already in place.\n+         *\/\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n+        } else {\n+            sort(null, a, 0, low, high);\n+        }\n+\n+        \/*\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0 back into negative zeros -0.0.\n+         *\/\n+        if (++negativeZeroCount == 1) {\n+            return;\n+        }\n+\n+        \/*\n+         * Find the position one less than\n+         * the index of the first zero.\n+         *\/\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+\n+            if (a[mid] < 0.0{#if[Float]?f}{#if[Double]?d}) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        \/*\n+         * Replace 0.0 by negative zeros -0.0.\n+         *\/\n+        while (--negativeZeroCount > 0) {\n+            a[++high] = -0.0{#if[Float]?f}{#if[Double]?d};\n+        }\n+    }\n+#end[FloatDouble]\n+#if[Byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort or counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(byte[] a, int low, int high) {\n+        if (high - low < MAX_INSERTION_SORT_SIZE) {\n+            insertionSort(a, low, high);\n+        } else {\n+            countingSort(a, low, high);\n+        }\n+    }\n+#end[Byte]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int low, int high) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            sort(a, 0, low, high);\n+        }\n+    }\n+#end[CharShort]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that range is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(Sorter<$type$[]> sorter, $type$[] a, int bits, int low, int high) {\n+        while (true) {\n+            int size = high - low;\n+\n+            \/*\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n+                return;\n+            }\n+\n+            \/*\n+             * Invoke adaptive insertion sort on small leftmost part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+                sort($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n+                return;\n+            }\n+\n+            \/*\n+             * Try merging sort on large part.\n+             *\/\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n+             *\/\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = high - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { $type$ t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { $type$ t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { $type$ t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { $type$ t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { $type$ t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n+                }\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n+                }\n+            }\n+\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                indices = partition($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n+                }\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.fork(bits | 1, indices[1], high);\n+                } else {\n+                    sort(sorter, a, bits | 1, indices[1], high);\n+                }\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+#end[IntLongFloatDouble]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that range is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void sort($type$[] a, int bits, int low, int high) {\n+        while (true) {\n+            int size = high - low;\n+\n+            \/*\n+             * Invoke insertion sort on small part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE) {\n+                insertionSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n+             *\/\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = high - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { $type$ t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { $type$ t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { $type$ t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { $type$ t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { $type$ t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n+                }\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n+                }\n+            }\n+\n+            \/*\n+             * Switch to counting sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                countingSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+#end[CharShort]\n+#if[AllExceptByte]\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            $type$[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        $type$ pivot1 = a[pivotIndex1];\n+        $type$ pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            $type$ ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n+\n+        return new int[] { lower, upper };\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            $type$[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        $type$ pivot = a[pivotIndex1];\n+\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            $type$ ak = a[k];\n+\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n+\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n+\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n+    }\n+#end[AllExceptByte]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n+     *\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n+     *\n+     * In the context of Dual-Pivot Quicksort, the pivot element\n+     * from the left part plays the role of sentinel, because it\n+     * is less than any elements from the given part. Therefore,\n+     * expensive check of the left range can be skipped on each\n+     * iteration unless it is the leftmost call.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void mixedInsertionSort($type$[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            $type$ ai = a[i = low], pin = a[--p];\n+\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            $type$ a1 = a[i = low], a2 = a[++low];\n+\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n+\n+            } else if (a1 < a[i - 1]) {\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n+        }\n+    }\n+#end[IntLongFloatDouble]\n+#if[AllTypes]\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort($type$[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            $type$ ai = a[i = k];\n+\n+            if (ai < a[i - 1]) {\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n+            }\n+        }\n+    }\n+#end[AllTypes]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Tries to sort the specified range of the array using merging sort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryMergingSort(Sorter<$type$[]> sorter, $type$[] a, int low, int high) {\n+        \/*\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n+         *\/\n+        int count = 1;\n+        int[] run = null;\n+\n+        \/*\n+         * Identify all possible runs.\n+         *\/\n+        for (int k = low + 1, last = low; k < high; ) {\n+            \/*\n+             * Find the next run.\n+             *\/\n+            if (a[k - 1] < a[k]) {\n+\n+                \/\/ Identify ascending sequence\n+                while (++k < high && a[k - 1] <= a[k]);\n+\n+            } else if (a[k - 1] > a[k]) {\n+\n+                \/\/ Identify descending sequence\n+                while (++k < high && a[k - 1] >= a[k]);\n+\n+                \/\/ Reverse into ascending order\n+                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\n+                    $type$ ai = a[i]; a[i] = a[j]; a[j] = ai;\n+                }\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n+            } else { \/\/ Identify constant sequence\n+                for ($type$ ak = a[k]; ++k < high && ak == a[k]; );\n+\n+                \/\/ Check the next sequence\n+                if (k < high) {\n+                    continue;\n+                }\n+            }\n+\n+            \/*\n+             * Process the current run.\n+             *\/\n+            if (run == null) {\n+\n+                if (k == high) {\n+                    \/*\n+                     * Array is monotonous sequence\n+                     * and therefore already sorted.\n+                     *\/\n+                    return true;\n+                }\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n+                run[0] = low;\n+\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n+\n+                if (k - low < count * MIN_RUN_SIZE) {\n+                    \/*\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n+                     *\/\n+                    return false;\n+                }\n+\n+                if (++count == run.length) {\n+                    \/*\n+                     * Array is not highly structured.\n+                     *\/\n+                    return false;\n+                }\n+            }\n+\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n+\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n+            }\n+        }\n+\n+        \/*\n+         * Merge all runs.\n+         *\/\n+        if (count > 1) {\n+            $type$[] b; int offset = low;\n+\n+            if (sorter != null && (b = sorter.b) != null) {\n+                offset = sorter.offset;\n+            } else if ((b = tryAllocate($type$[].class, high - low)) == null) {\n+                return false;\n+            }\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Merges the specified runs.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the source array\n+     * @param b the buffer for merging\n+     * @param offset the start index in the source, inclusive\n+     * @param aim whether the original array is used for merging\n+     * @param run the start indexes of the runs, inclusive\n+     * @param lo the start index of the first run, inclusive\n+     * @param hi the start index of the last run, inclusive\n+     *\/\n+    private static void mergeRuns(Sorter<$type$[]> sorter, $type$[] a, $type$[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n+\n+        if (hi - lo == 1) {\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n+            }\n+            return;\n+        }\n+\n+        \/*\n+         * Split the array into two approximately equal parts.\n+         *\/\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n+\n+        \/*\n+         * Merge the runs of all parts.\n+         *\/\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n+\n+        $type$[] dst = aim ? a : b;\n+        $type$[] src = aim ? b : a;\n+\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n+        } else {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts in parallel.\n+     *\n+     * @param merger the parallel context\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(Merger<$type$[]> merger, $type$[] dst, int k,\n+            $type$[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n+\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n+\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            $type$ key = src[mi1];\n+\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n+                }\n+            }\n+\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n+\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n+\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n+\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts($type$[] dst, int k,\n+            $type$[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                $type$ next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                $type$ next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                $type$ next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort($type$[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            $type$ max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown($type$[] a, int p, $type$ value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+#end[IntLongFloatDouble]\n+#if[Byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void countingSort(byte[] a, int low, int high) {\n+        \/*\n+         * Count the number of all values.\n+         *\/\n+        int[] count = new int[1 << 8];\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        for (int i = high; i > low; ++count[a[--i] & 0xFF]);\n+\n+        \/*\n+         * Place values on their final positions.\n+         *\/\n+        for (int value = Byte.MIN_VALUE; high > low; ) {\n+            while (count[--value & 0xFF] == 0);\n+            int num = count[value & 0xFF];\n+\n+            do {\n+                a[--high] = (byte) value;\n+            } while (--num > 0);\n+        }\n+    }\n+#end[Byte]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void countingSort($type$[] a, int low, int high) {\n+        int size = high - low;\n+\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n+\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i]{#if[Short]? & 0xFFFF}]);\n+\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = {#if[Char]?count.length}{#if[Short]?Short.MIN_VALUE}; high > low; ) {\n+                while (count[--value{#if[Short]? & 0xFFFF}] == 0);\n+                int num = count[value{#if[Short]? & 0xFFFF}];\n+\n+                do {\n+                    a[--high] = ($type$) value;\n+                } while (--num > 0);\n+            }\n+\n+        } else {\n+\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            $type$[] b = new $type$[size];\n+\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n+\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}];{#if[Short]? \/\/ Flip the sign bit}\n+            }\n+\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n+            }\n+        }\n+    }\n+#end[CharShort]\n+#if[Common2]\n+\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c > 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n+        }\n+        return true;\n+    }\n+\n+\/\/ #[class]\n+\n+    \/**\n+     * Implementation of parallel sorting.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n+        @SuppressWarnings(\"serial\")\n+        private final T a, b;\n+        private final int low, size, offset, depth;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private Sorter(T a, int parallelism, int low, int size) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+            this.b = (T) tryAllocate(a.getClass(), size);\n+            this.depth = b == null ? 0 : ((parallelism >> 7) + 2) * (-2);\n+        }\n+\n+        private Sorter(CountedCompleter<?> parent,\n+                T a, T b, int low, int size, int offset, int depth) {\n+            super(parent);\n+            this.a = a;\n+            this.b = b;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = offset;\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            if (depth < 0) {\n+                setPendingCount(2);\n+                int half = size >> 1;\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\n+            } else {\n+                switch(a) {\n+                    case int[] ai -> sort((Sorter<int[]>) this, ai, depth, low, low + size);\n+                    case long[] al -> sort((Sorter<long[]>) this, al, depth, low, low + size);\n+                    case float[] af -> sort((Sorter<float[]>) this, af, depth, low, low + size);\n+                    case double[] ad -> sort((Sorter<double[]>) this, ad, depth, low, low + size);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+                }\n+            }\n+            tryComplete();\n+        }\n+\n+        @Override\n+        public void onCompletion(CountedCompleter<?> caller) {\n+            if (depth < 0) {\n+                int mi = low + (size >> 1);\n+                boolean src = (depth & 1) == 0;\n+\n+                new Merger<>(null,\n+                    a,\n+                    src ? low : low - offset,\n+                    b,\n+                    src ? low - offset : low,\n+                    src ? mi - offset : mi,\n+                    src ? mi - offset : mi,\n+                    src ? low + size - offset : low + size\n+                ).invoke();\n+            }\n+        }\n+\n+        private void fork(int depth, int low, int high) {\n+            addToPendingCount(1);\n+            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+        }\n+    }\n+\n+    \/**\n+     * Implementation of parallel merging.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    private static final class Merger<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n+        @SuppressWarnings(\"serial\")\n+        private final T dst, src;\n+        private final int k, lo1, hi1, lo2, hi2;\n+\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\n+                T src, int lo1, int hi1, int lo2, int hi2) {\n+            super(parent);\n+            this.dst = dst;\n+            this.k = k;\n+            this.src = src;\n+            this.lo1 = lo1;\n+            this.hi1 = hi1;\n+            this.lo2 = lo2;\n+            this.hi2 = hi2;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            switch(dst) {\n+                case int[] di -> mergeParts((Merger<int[]>) this, di, k, (int[]) src, lo1, hi1, lo2, hi2);\n+                case long[] dl -> mergeParts((Merger<long[]>) this, dl, k, (long[]) src, lo1, hi1, lo2, hi2);\n+                case float[] df -> mergeParts((Merger<float[]>) this, df, k, (float[]) src, lo1, hi1, lo2, hi2);\n+                case double[] dd -> mergeParts((Merger<double[]>) this, dd, k, (double[]) src, lo1, hi1, lo2, hi2);\n+                default -> throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n+            }\n+            propagateCompletion();\n+        }\n+\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\n+            addToPendingCount(1);\n+            new Merger<>(this, dst, k, src, lo1, hi1, lo2, hi2).fork();\n+        }\n+    }\n+\n+    \/**\n+     * Tries to allocate additional buffer.\n+     *\n+     * @param <T> the class of array\n+     * @param clazz the given array class\n+     * @param length the length of additional buffer\n+     * @return {@code null} if requested buffer is too big or there is no enough memory,\n+     *         otherwise created buffer\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T tryAllocate(Class<T> clazz, int length) {\n+        try {\n+            int maxLength = MAX_BUFFER_SIZE >>\n+                (clazz == int[].class || clazz == float[].class ? 2 : 3);\n+            return length > maxLength ? null :\n+                (T) U.allocateUninitializedArray(clazz.componentType(), length);\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+}\n+#end[Common2]\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java.template","additions":1606,"deletions":0,"binary":false,"changes":1606,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+#!\/bin\/bash\n+\n+javac -d . ..\/..\/..\/..\/..\/..\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\n+\n+in=DualPivotQuicksort.java.template\n+out=DualPivotQuicksort.java\n+\n+rm -rf $out\n+\n+gen() {\n+    java build.tools.spp.Spp -nel -Dtype=$1 -DTYPE=$2 -K$3 -K$4 -K$5 -K$6 -K$7 -i$in -o$out\n+}\n+\n+gen \"\"     \"\"     Common1  \"\"            \"\"                 \"\"          \"\"\n+gen int    INT    AllTypes AllExceptByte IntLongFloatDouble IntLong     \"\"\n+gen long   LONG   AllTypes AllExceptByte IntLongFloatDouble IntLong     \"\"\n+gen byte   \"\"     AllTypes \"\"            \"\"                 \"\"          Byte\n+gen char   \"\"     AllTypes AllExceptByte \"\"                 CharShort   Char\n+gen short  \"\"     AllTypes AllExceptByte \"\"                 CharShort   Short\n+gen float  FLOAT  AllTypes AllExceptByte IntLongFloatDouble FloatDouble Float\n+gen double DOUBLE AllTypes AllExceptByte IntLongFloatDouble FloatDouble Double\n+gen \"\"     \"\"     Common2  \"\"            \"\"                 \"\"          \"\"\n+\n+rm -rf build\n","filename":"src\/java.base\/share\/classes\/java\/util\/gen-DualPivotQuicksort.sh","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"}]}