{"files":[{"patch":"@@ -41,3 +41,3 @@\n- * Quicksort such as merging sort, sorting network, Radix sort, heap\n- * sort, mixed (simple, pin, pair) insertion sort, counting sort and\n- * parallel merge sort.\n+ * Quicksort such as merging sort, sorting network, heap sort, mixed\n+ * (pin, simple and pair) insertion sort, counting sort and parallel\n+ * merge sort.\n@@ -85,1 +85,1 @@\n-    \/* --------------------- Numerical sort --------------------- *\/\n+    \/* ---------------------- Digital sort ---------------------- *\/\n@@ -88,1 +88,1 @@\n-     * Min size of array to use Radix sort.\n+     * Min size of array to use counting sort.\n@@ -90,1 +90,1 @@\n-    private static final int MIN_RADIX_SORT_SIZE = 640;\n+    private static final int MIN_COUNTING_SORT_SIZE = 640;\n@@ -93,1 +93,1 @@\n-     * Min size of array to use counting sort.\n+     * Min size of array to use numerical sort.\n@@ -95,1 +95,1 @@\n-    private static final int MIN_COUNTING_SORT_SIZE = 9 << 10;\n+    private static final int MIN_NUMERICAL_SORT_SIZE = 9 << 10;\n@@ -116,1 +116,1 @@\n-        (int) Math.min(Runtime.getRuntime().maxMemory() >>> 4, Integer.MAX_VALUE);\n+        Math.clamp(Runtime.getRuntime().maxMemory() >>> 4, 0, Integer.MAX_VALUE);\n@@ -284,9 +284,0 @@\n-            \/*\n-             * Check if part is large and contains random\n-             * data, taking into account parallel context.\n-             *\/\n-            boolean isLargeRandom =\n-\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n-                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n-                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n-\n@@ -330,9 +321,0 @@\n-            \/*\n-             * Try Radix sort on large fully random data.\n-             *\/\n-            if (isLargeRandom\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n-                    && tryRadixSort(sorter, a, low, high)) {\n-                return;\n-            }\n-\n@@ -980,125 +962,0 @@\n-    \/**\n-     * Tries to sort the specified range of the array\n-     * using LSD (The Least Significant Digit) Radix sort.\n-     *\n-     * @param sorter the parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    static boolean tryRadixSort(Sorter<int[]> sorter, int[] a, int low, int high) {\n-        int[] b; int offset = low, size = high - low;\n-\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        if (sorter != null && (b = sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else if ((b = tryAllocate(int[].class, size)) == null) {\n-            return false;\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n-\n-        \/*\n-         * Count the number of all digits.\n-         *\/\n-        int[] count1 = new int[1 << 10];\n-        int[] count2 = new int[1 << 11];\n-        int[] count3 = new int[1 << 11];\n-\n-        for (int i = low; i < high; ++i) {\n-            ++count1[ a[i]         & 0x3FF];\n-            ++count2[(a[i] >>> 10) & 0x7FF];\n-            ++count3[(a[i] >>> 21) ^ 0x400]; \/\/ Flip the sign bit\n-        }\n-\n-        \/*\n-         * Check digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, size, low);\n-        boolean processDigit2 = processDigit(count2, size, low);\n-        boolean processDigit3 = processDigit(count3, size, low);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = high; i > low; ) {\n-                b[--count1[a[--i] & 0x3FF] - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = last; i > start; ) {\n-                    a[--count2[(b[--i] >>> 10) & 0x7FF]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count2[(a[--i] >>> 10) & 0x7FF] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = last; i > start; ) {\n-                    a[--count3[(b[--i] >>> 21) ^ 0x400]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count3[(a[--i] >>> 21) ^ 0x400] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n-    }\n-\n-    \/**\n-     * Checks the count array and then computes the histogram.\n-     *\n-     * @param count the count array\n-     * @param total the total number of elements\n-     * @param low the index of the first element, inclusive\n-     * @return {@code true} if the digit must be processed, otherwise {@code false}\n-     *\/\n-    private static boolean processDigit(int[] count, int total, int low) {\n-        \/*\n-         * Check if we can skip the given digit.\n-         *\/\n-        for (int c : count) {\n-            if (c == total) {\n-                return false;\n-            }\n-            if (c > 0) {\n-                break;\n-            }\n-        }\n-\n-        \/*\n-         * Compute the histogram.\n-         *\/\n-        count[0] += low;\n-\n-        for (int i = 0; ++i < count.length; ) {\n-            count[i] += count[i - 1];\n-        }\n-        return true;\n-    }\n-\n@@ -1233,9 +1090,0 @@\n-            \/*\n-             * Check if part is large and contains random\n-             * data, taking into account parallel context.\n-             *\/\n-            boolean isLargeRandom =\n-\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n-                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n-                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n-\n@@ -1279,9 +1127,0 @@\n-            \/*\n-             * Try Radix sort on large fully random data.\n-             *\/\n-            if (isLargeRandom\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n-                    && tryRadixSort(sorter, a, low, high)) {\n-                return;\n-            }\n-\n@@ -1929,147 +1768,0 @@\n-    \/**\n-     * Tries to sort the specified range of the array\n-     * using LSD (The Least Significant Digit) Radix sort.\n-     *\n-     * @param sorter the parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    static boolean tryRadixSort(Sorter<long[]> sorter, long[] a, int low, int high) {\n-        long[] b; int offset = low, size = high - low;\n-\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        if (sorter != null && (b = sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else if ((b = tryAllocate(long[].class, size)) == null) {\n-            return false;\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n-\n-        \/*\n-         * Count the number of all digits.\n-         *\/\n-        int[] count1 = new int[1 << 10];\n-        int[] count2 = new int[1 << 11];\n-        int[] count3 = new int[1 << 11];\n-        int[] count4 = new int[1 << 11];\n-        int[] count5 = new int[1 << 11];\n-        int[] count6 = new int[1 << 10];\n-\n-        for (int i = low; i < high; ++i) {\n-            ++count1[(int)  (a[i]         & 0x3FF)];\n-            ++count2[(int) ((a[i] >>> 10) & 0x7FF)];\n-            ++count3[(int) ((a[i] >>> 21) & 0x7FF)];\n-            ++count4[(int) ((a[i] >>> 32) & 0x7FF)];\n-            ++count5[(int) ((a[i] >>> 43) & 0x7FF)];\n-            ++count6[(int) ((a[i] >>> 54) ^ 0x200)]; \/\/ Flip the sign bit\n-        }\n-\n-        \/*\n-         * Check digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, size, low);\n-        boolean processDigit2 = processDigit(count2, size, low);\n-        boolean processDigit3 = processDigit(count3, size, low);\n-        boolean processDigit4 = processDigit(count4, size, low);\n-        boolean processDigit5 = processDigit(count5, size, low);\n-        boolean processDigit6 = processDigit(count6, size, low);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = high; i > low; ) {\n-                b[--count1[(int) (a[--i] & 0x3FF)] - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = last; i > start; ) {\n-                    a[--count2[(int) ((b[--i] >>> 10) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count2[(int) ((a[--i] >>> 10) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = last; i > start; ) {\n-                    a[--count3[(int) ((b[--i] >>> 21) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count3[(int) ((a[--i] >>> 21) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 4-th digit.\n-         *\/\n-        if (processDigit4) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-                for (int i = last; i > start; ) {\n-                    a[--count4[(int) ((b[--i] >>> 32) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count4[(int) ((a[--i] >>> 32) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 5-th digit.\n-         *\/\n-        if (processDigit5) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n-                for (int i = last; i > start; ) {\n-                    a[--count5[(int) ((b[--i] >>> 43) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count5[(int) ((a[--i] >>> 43) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 6-th digit.\n-         *\/\n-        if (processDigit6) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n-                for (int i = last; i > start; ) {\n-                    a[--count6[(int) ((b[--i] >>> 54) ^ 0x200)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count6[(int) ((a[--i] >>> 54) ^ 0x200)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n-    }\n-\n@@ -2166,0 +1858,3 @@\n+        \/*\n+         * Count the number of all values.\n+         *\/\n@@ -2189,2 +1884,2 @@\n-     * Sorts the specified range of the array using counting sort,\n-     * Radix sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n@@ -2199,2 +1894,0 @@\n-        } else if (high - low > MIN_RADIX_SORT_SIZE) {\n-            radixSort(a, low, high);\n@@ -2284,1 +1977,1 @@\n-             * Switch to Radix sort to avoid quadratic time.\n+             * Switch to counting sort to avoid quadratic time.\n@@ -2287,1 +1980,1 @@\n-                radixSort(a, low, high);\n+                countingSort(a, low, high);\n@@ -2519,1 +2212,1 @@\n-        int[] count = new int[1 << 16];\n+        int size = high - low;\n@@ -2521,4 +2214,5 @@\n-        \/*\n-         * Compute the histogram.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i]]);\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n@@ -2526,6 +2220,4 @@\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        for (int value = count.length; high > low; ) {\n-            while (count[--value] == 0);\n-            int num = count[value];\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i]]);\n@@ -2533,5 +2225,6 @@\n-            do {\n-                a[--high] = (char) value;\n-            } while (--num > 0);\n-        }\n-    }\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = count.length; high > low; ) {\n+                while (count[--value] == 0);\n+                int num = count[value];\n@@ -2539,13 +2232,4 @@\n-    \/**\n-     * Sorts the specified range of the array using Radix sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void radixSort(char[] a, int low, int high) {\n-        \/*\n-         * Count the number of all bytes.\n-         *\/\n-        int[] count1 = new int[1 << 8];\n-        int[] count2 = new int[1 << 8];\n+                do {\n+                    a[--high] = (char) value;\n+                } while (--num > 0);\n+            }\n@@ -2553,4 +2237,1 @@\n-        for (int i = low; i < high; ++i) {\n-            ++count1[ a[i]        & 0xFF];\n-            ++count2[(a[i] >>> 8) & 0xFF];\n-        }\n+        } else {\n@@ -2558,5 +2239,4 @@\n-        \/*\n-         * Check bytes to be processed.\n-         *\/\n-        count1[0] += low;\n-        count2[0] += low;\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            char[] b = new char[size];\n@@ -2564,4 +2244,5 @@\n-        for (int i = 0; ++i < 256; ) {\n-            count1[i] += count1[i - 1];\n-            count2[i] += count2[i - 1];\n-        }\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n@@ -2569,1 +2250,4 @@\n-        int size = high - low;\n+            for (int i = low; i < high; ++i) {\n+                ++count1[ a[i]        & 0xFF];\n+                ++count2[(a[i] >>> 8) & 0xFF];\n+            }\n@@ -2571,4 +2255,38 @@\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        char[] b = new char[size];\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[(b[--i] >>> 8) & 0xFF]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[(a[--i] >>> 8) & 0xFF] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n+            }\n+        }\n+    }\n@@ -2576,0 +2294,9 @@\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n@@ -2577,1 +2304,1 @@\n-         * Process the 1-st byte.\n+         * Check if we can skip the given digit.\n@@ -2579,2 +2306,7 @@\n-        for (int i = high; i > low; ) {\n-            b[--count1[a[--i] & 0xFF] - low] = a[i];\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c > 0) {\n+                break;\n+            }\n@@ -2584,1 +2316,1 @@\n-         * Process the 2-nd byte.\n+         * Compute the histogram.\n@@ -2586,2 +2318,4 @@\n-        for (int i = size; i > 0; ) {\n-            a[--count2[(b[--i] >>> 8) & 0xFF]] = b[i];\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n@@ -2589,0 +2323,1 @@\n+        return true;\n@@ -2594,2 +2329,2 @@\n-     * Sorts the specified range of the array using counting sort,\n-     * Radix sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n@@ -2604,2 +2339,0 @@\n-        } else if (high - low > MIN_RADIX_SORT_SIZE) {\n-            radixSort(a, low, high);\n@@ -2689,1 +2422,1 @@\n-             * Switch to Radix sort to avoid quadratic time.\n+             * Switch to counting sort to avoid quadratic time.\n@@ -2692,1 +2425,1 @@\n-                radixSort(a, low, high);\n+                countingSort(a, low, high);\n@@ -2924,1 +2657,1 @@\n-        int[] count = new int[1 << 16];\n+        int size = high - low;\n@@ -2926,4 +2659,5 @@\n-        \/*\n-         * Compute the histogram.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n@@ -2931,6 +2665,4 @@\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        for (int value = Short.MIN_VALUE; high > low; ) {\n-            while (count[--value & 0xFFFF] == 0);\n-            int num = count[value & 0xFFFF];\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n@@ -2938,5 +2670,6 @@\n-            do {\n-                a[--high] = (short) value;\n-            } while (--num > 0);\n-        }\n-    }\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = Short.MIN_VALUE; high > low; ) {\n+                while (count[--value & 0xFFFF] == 0);\n+                int num = count[value & 0xFFFF];\n@@ -2944,13 +2677,4 @@\n-    \/**\n-     * Sorts the specified range of the array using Radix sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    static void radixSort(short[] a, int low, int high) {\n-        \/*\n-         * Count the number of all bytes.\n-         *\/\n-        int[] count1 = new int[1 << 8];\n-        int[] count2 = new int[1 << 8];\n+                do {\n+                    a[--high] = (short) value;\n+                } while (--num > 0);\n+            }\n@@ -2958,4 +2682,1 @@\n-        for (int i = low; i < high; ++i) {\n-            ++count1[  a[i]        & 0xFF];\n-            ++count2[((a[i] >>> 8) & 0xFF) ^ 0x80]; \/\/ Flip the sign bit\n-        }\n+        } else {\n@@ -2963,5 +2684,4 @@\n-        \/*\n-         * Check bytes to be processed.\n-         *\/\n-        count1[0] += low;\n-        count2[0] += low;\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            short[] b = new short[size];\n@@ -2969,4 +2689,5 @@\n-        for (int i = 0; ++i < 256; ) {\n-            count1[i] += count1[i - 1];\n-            count2[i] += count2[i - 1];\n-        }\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n@@ -2974,1 +2695,4 @@\n-        int size = high - low;\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF) ^ 0x80]; \/\/ Flip the sign bit\n+            }\n@@ -2976,4 +2700,5 @@\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        short[] b = new short[size];\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n@@ -2981,6 +2706,8 @@\n-        \/*\n-         * Process the 1-st byte.\n-         *\/\n-        for (int i = high; i > low; ) {\n-            b[--count1[a[--i] & 0xFF] - low] = a[i];\n-        }\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n@@ -2988,5 +2715,21 @@\n-        \/*\n-         * Process the 2-nd byte.\n-         *\/\n-        for (int i = size; i > 0; ) {\n-            a[--count2[((b[--i] >>> 8) & 0xFF) ^ 0x80]] = b[i];\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF) ^ 0x80]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF) ^ 0x80] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n+            }\n@@ -3137,9 +2880,0 @@\n-            \/*\n-             * Check if part is large and contains random\n-             * data, taking into account parallel context.\n-             *\/\n-            boolean isLargeRandom =\n-\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n-                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n-                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n-\n@@ -3183,9 +2917,0 @@\n-            \/*\n-             * Try Radix sort on large fully random data.\n-             *\/\n-            if (isLargeRandom\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n-                    && tryRadixSort(sorter, a, low, high)) {\n-                return;\n-            }\n-\n@@ -3833,106 +3558,0 @@\n-    \/**\n-     * Tries to sort the specified range of the array\n-     * using LSD (The Least Significant Digit) Radix sort.\n-     *\n-     * @param sorter the parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    static boolean tryRadixSort(Sorter<float[]> sorter, float[] a, int low, int high) {\n-        float[] b; int offset = low, size = high - low;\n-\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        if (sorter != null && (b = sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else if ((b = tryAllocate(float[].class, size)) == null) {\n-            return false;\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n-\n-        \/*\n-         * Count the number of all digits.\n-         *\/\n-        int[] count1 = new int[1 << 10];\n-        int[] count2 = new int[1 << 11];\n-        int[] count3 = new int[1 << 11];\n-\n-        for (int i = low; i < high; ++i) {\n-            ++count1[ f2i(a[i])         & 0x3FF];\n-            ++count2[(f2i(a[i]) >>> 10) & 0x7FF];\n-            ++count3[(f2i(a[i]) >>> 21) & 0x7FF];\n-        }\n-\n-        \/*\n-         * Check digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, size, low);\n-        boolean processDigit2 = processDigit(count2, size, low);\n-        boolean processDigit3 = processDigit(count3, size, low);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = high; i > low; ) {\n-                b[--count1[f2i(a[--i]) & 0x3FF] - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = last; i > start; ) {\n-                    a[--count2[(f2i(b[--i]) >>> 10) & 0x7FF]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count2[(f2i(a[--i]) >>> 10) & 0x7FF] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = last; i > start; ) {\n-                    a[--count3[(f2i(b[--i]) >>> 21) & 0x7FF]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count3[(f2i(a[--i]) >>> 21) & 0x7FF] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n-    }\n-\n-    private static final int SIGN_32_BIT = 1 << 31;\n-\n-    \/**\n-     * Returns the masked bits of float value.\n-     *\n-     * @param f the given float value\n-     * @return masked bits\n-     *\/\n-    private static int f2i(float f) {\n-        int x = Float.floatToRawIntBits(f);\n-        return x < 0 ? ~x : x | SIGN_32_BIT;\n-    }\n-\n@@ -4124,9 +3743,0 @@\n-            \/*\n-             * Check if part is large and contains random\n-             * data, taking into account parallel context.\n-             *\/\n-            boolean isLargeRandom =\n-\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n-                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n-                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n-\n@@ -4170,9 +3780,0 @@\n-            \/*\n-             * Try Radix sort on large fully random data.\n-             *\/\n-            if (isLargeRandom\n-                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n-                    && tryRadixSort(sorter, a, low, high)) {\n-                return;\n-            }\n-\n@@ -4820,160 +4421,0 @@\n-    \/**\n-     * Tries to sort the specified range of the array\n-     * using LSD (The Least Significant Digit) Radix sort.\n-     *\n-     * @param sorter the parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n-     *\/\n-    static boolean tryRadixSort(Sorter<double[]> sorter, double[] a, int low, int high) {\n-        double[] b; int offset = low, size = high - low;\n-\n-        \/*\n-         * Allocate additional buffer.\n-         *\/\n-        if (sorter != null && (b = sorter.b) != null) {\n-            offset = sorter.offset;\n-        } else if ((b = tryAllocate(double[].class, size)) == null) {\n-            return false;\n-        }\n-\n-        int start = low - offset;\n-        int last = high - offset;\n-\n-        \/*\n-         * Count the number of all digits.\n-         *\/\n-        int[] count1 = new int[1 << 10];\n-        int[] count2 = new int[1 << 11];\n-        int[] count3 = new int[1 << 11];\n-        int[] count4 = new int[1 << 11];\n-        int[] count5 = new int[1 << 11];\n-        int[] count6 = new int[1 << 10];\n-\n-        for (int i = low; i < high; ++i) {\n-            ++count1[(int)  (d2l(a[i])         & 0x3FF)];\n-            ++count2[(int) ((d2l(a[i]) >>> 10) & 0x7FF)];\n-            ++count3[(int) ((d2l(a[i]) >>> 21) & 0x7FF)];\n-            ++count4[(int) ((d2l(a[i]) >>> 32) & 0x7FF)];\n-            ++count5[(int) ((d2l(a[i]) >>> 43) & 0x7FF)];\n-            ++count6[(int) ((d2l(a[i]) >>> 54) & 0x3FF)];\n-        }\n-\n-        \/*\n-         * Check digits to be processed.\n-         *\/\n-        boolean processDigit1 = processDigit(count1, size, low);\n-        boolean processDigit2 = processDigit(count2, size, low);\n-        boolean processDigit3 = processDigit(count3, size, low);\n-        boolean processDigit4 = processDigit(count4, size, low);\n-        boolean processDigit5 = processDigit(count5, size, low);\n-        boolean processDigit6 = processDigit(count6, size, low);\n-\n-        \/*\n-         * Process the 1-st digit.\n-         *\/\n-        if (processDigit1) {\n-            for (int i = high; i > low; ) {\n-                b[--count1[(int) (d2l(a[--i]) & 0x3FF)] - offset] = a[i];\n-            }\n-        }\n-\n-        \/*\n-         * Process the 2-nd digit.\n-         *\/\n-        if (processDigit2) {\n-            if (processDigit1) {\n-                for (int i = last; i > start; ) {\n-                    a[--count2[(int) ((d2l(b[--i]) >>> 10) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count2[(int) ((d2l(a[--i]) >>> 10) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 3-rd digit.\n-         *\/\n-        if (processDigit3) {\n-            if (processDigit1 ^ processDigit2) {\n-                for (int i = last; i > start; ) {\n-                    a[--count3[(int) ((d2l(b[--i]) >>> 21) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count3[(int) ((d2l(a[--i]) >>> 21) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 4-th digit.\n-         *\/\n-        if (processDigit4) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n-                for (int i = last; i > start; ) {\n-                    a[--count4[(int) ((d2l(b[--i]) >>> 32) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count4[(int) ((d2l(a[--i]) >>> 32) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 5-th digit.\n-         *\/\n-        if (processDigit5) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n-                for (int i = last; i > start; ) {\n-                    a[--count5[(int) ((d2l(b[--i]) >>> 43) & 0x7FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count5[(int) ((d2l(a[--i]) >>> 43) & 0x7FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Process the 6-th digit.\n-         *\/\n-        if (processDigit6) {\n-            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n-                for (int i = last; i > start; ) {\n-                    a[--count6[(int) ((d2l(b[--i]) >>> 54) & 0x3FF)]] = b[i];\n-                }\n-            } else {\n-                for (int i = high; i > low; ) {\n-                    b[--count6[(int) ((d2l(a[--i]) >>> 54) & 0x3FF)] - offset] = a[i];\n-                }\n-            }\n-        }\n-\n-        \/*\n-         * Copy the buffer to original array, if we process ood number of digits.\n-         *\/\n-        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n-            System.arraycopy(b, low - offset, a, low, size);\n-        }\n-        return true;\n-    }\n-\n-    private static final long SIGN_64_BIT = 1L << 63;\n-\n-    \/**\n-     * Returns the masked bits of double value.\n-     *\n-     * @param d the given double value\n-     * @return masked bits\n-     *\/\n-    private static long d2l(double d) {\n-        long x = Double.doubleToRawLongBits(d);\n-        return x < 0 ? ~x : x | SIGN_64_BIT;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":183,"deletions":742,"binary":false,"changes":925,"status":"modified"},{"patch":"@@ -92,1 +92,0 @@\n-        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testBase();\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -85,16 +85,0 @@\n-    RADIX_SORT(\"Radix sort\") {\n-        @Override\n-        public void sort(Object a, int low, int high) {\n-            switch(a) {\n-                case int[] ai -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, ai, low, high));\n-                case long[] al -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, al, low, high));\n-                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n-                case char[] ac -> DualPivotQuicksort.radixSort(ac, low, high);\n-                case short[] as -> DualPivotQuicksort.radixSort(as, low, high);\n-                case float[] af -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, af, low, high));\n-                case double[] ad -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, ad, low, high));\n-                default -> fail(a);\n-            }\n-        }\n-    },\n-\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}