{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,0 @@\n-import java.util.concurrent.RecursiveTask;\n@@ -31,1 +30,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -33,0 +31,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -39,1 +38,1 @@\n- * faster than traditional (one-pivot) Quicksort implementations.\n+ * faster than traditional (one-pivot) Quicksort implementations.<p>\n@@ -42,2 +41,3 @@\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, counting sort and parallel merge sort.\n+ * Quicksort such as merging sort, sorting network, Radix sort, heap\n+ * sort, mixed (simple, pin, pair) insertion sort, counting sort and\n+ * parallel merge sort.\n@@ -50,1 +50,1 @@\n- * @version 2018.08.18\n+ * @version 2024.06.14\n@@ -52,1 +52,1 @@\n- * @since 1.7 * 14\n+ * @since 1.7 * 14 ^ 26\n@@ -61,4 +61,1 @@\n-    \/**\n-     * Max array size to use mixed insertion sort.\n-     *\/\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+    \/* --------------------- Insertion sort --------------------- *\/\n@@ -67,1 +64,1 @@\n-     * Max array size to use insertion sort.\n+     * Max size of array to use insertion sort.\n@@ -69,1 +66,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 44;\n+    private static final int MAX_INSERTION_SORT_SIZE = 51;\n@@ -71,4 +68,1 @@\n-    \/**\n-     * Min array size to perform sorting in parallel.\n-     *\/\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n+    \/* ---------------------- Merging sort ---------------------- *\/\n@@ -77,1 +71,1 @@\n-     * Min array size to try merging of runs.\n+     * Min size of array to use merging sort.\n@@ -79,1 +73,1 @@\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n@@ -82,1 +76,1 @@\n-     * Min size of the first run to continue with scanning.\n+     * Min size of run to continue scanning.\n@@ -84,1 +78,1 @@\n-    private static final int MIN_FIRST_RUN_SIZE = 16;\n+    private static final int MIN_RUN_SIZE = 64;\n@@ -87,1 +81,1 @@\n-     * Min factor for the first runs to continue scanning.\n+     * Max capacity of the index array to track the runs.\n@@ -89,1 +83,1 @@\n-    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+    private static final int MAX_RUN_CAPACITY = 10 << 10;\n@@ -91,4 +85,1 @@\n-    \/**\n-     * Max capacity of the index array for tracking runs.\n-     *\/\n-    private static final int MAX_RUN_CAPACITY = 5 << 10;\n+    \/* --------------------- Numerical sort --------------------- *\/\n@@ -97,1 +88,1 @@\n-     * Min number of runs, required by parallel merging.\n+     * Min size of array to use Radix sort.\n@@ -99,1 +90,1 @@\n-    private static final int MIN_RUN_COUNT = 4;\n+    private static final int MIN_RADIX_SORT_SIZE = 640;\n@@ -102,1 +93,1 @@\n-     * Min array size to use parallel merging of parts.\n+     * Min size of array to use counting sort.\n@@ -104,1 +95,1 @@\n-    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;\n+    private static final int MIN_COUNTING_SORT_SIZE = 9 << 10;\n@@ -106,4 +97,1 @@\n-    \/**\n-     * Min size of a byte array to use counting sort.\n-     *\/\n-    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;\n+    \/* --------------------- Parallel sort ---------------------- *\/\n@@ -112,1 +100,1 @@\n-     * Min size of a short or char array to use counting sort.\n+     * Min size of array to perform sorting in parallel.\n@@ -114,1 +102,3 @@\n-    private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;\n+    private static final int MIN_PARALLEL_SORT_SIZE = 3 << 10;\n+\n+    \/* --------------------- Infrastructure --------------------- *\/\n@@ -117,1 +107,1 @@\n-     * Threshold of mixed insertion sort is incremented by this value.\n+     * Max recursive depth before switching to heap sort.\n@@ -119,1 +109,1 @@\n-    private static final int DELTA = 3 << 1;\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n@@ -122,1 +112,2 @@\n-     * Max recursive partitioning depth before using heap sort.\n+     * Max size of additional buffer in bytes,\n+     *      limited by max_heap \/ 16 or 2 GB max.\n@@ -124,1 +115,2 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+    private static final int MAX_BUFFER_SIZE =\n+        (int) Math.min(Runtime.getRuntime().maxMemory() >>> 4, Integer.MAX_VALUE);\n@@ -127,2 +119,4 @@\n-     * Represents a function that accepts the array and sorts the specified range\n-     * of the array into ascending order.\n+     * Represents a function that accepts the array and sorts\n+     * the specified range of the array into ascending order.\n+     *\n+     * @param <T> the class of array\n@@ -131,1 +125,1 @@\n-    private static interface SortOperation<A> {\n+    private interface SortOperation<T> {\n@@ -139,1 +133,1 @@\n-        void sort(A a, int low, int high);\n+        void sort(T a, int low, int high);\n@@ -145,0 +139,1 @@\n+     * @param <T> the class of array\n@@ -146,4 +141,5 @@\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to sort, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to sort from.\n+     * @param a the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n@@ -154,1 +150,0 @@\n-    @IntrinsicCandidate\n@@ -156,2 +151,4 @@\n-    private static <A> void sort(Class<?> elemType, A array, long offset, int low, int high, SortOperation<A> so) {\n-        so.sort(array, low, high);\n+    @IntrinsicCandidate\n+    private static <T> void sort(Class<?> elemType, T a, long offset,\n+            int low, int high, SortOperation<T> so) {\n+        so.sort(a, low, high);\n@@ -161,2 +158,4 @@\n-     * Represents a function that accepts the array and partitions the specified range\n-     * of the array using the pivots provided.\n+     * Represents a function that accepts the array and partitions\n+     * the specified range of the array using the given pivots.\n+     *\n+     * @param <T> the class of array\n@@ -165,1 +164,1 @@\n-    interface PartitionOperation<A> {\n+    private interface PartitionOperation<T> {\n@@ -169,3 +168,3 @@\n-         * @param a the array to be partitioned\n-         * @param low the index of the first element, inclusive, to be partitioned\n-         * @param high the index of the last element, exclusive, to be partitioned\n+         * @param a the array for partitioning\n+         * @param low the index of the first element, inclusive, for partitioning\n+         * @param high the index of the last element, exclusive, for partitioning\n@@ -174,0 +173,1 @@\n+         * @return indices of parts after partitioning\n@@ -175,1 +175,1 @@\n-        int[] partition(A a, int low, int high, int pivotIndex1, int pivotIndex2);\n+        int[] partition(T a, int low, int high, int pivotIndex1, int pivotIndex2);\n@@ -179,1 +179,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using the given pivots.\n@@ -181,7 +181,9 @@\n-     * @param elemType the class of the array to be partitioned\n-     * @param array the array to be partitioned\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to partition, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to partition from.\n-     * @param low the index of the first element, inclusive, to be partitioned\n-     * @param high the index of the last element, exclusive, to be partitioned\n+     * @param <T> the class of array\n+     * @param elemType the class of the array for partitioning\n+     * @param a the array for partitioning\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n@@ -191,0 +193,1 @@\n+     * @return indices of parts after partitioning\n@@ -192,1 +195,0 @@\n-    @IntrinsicCandidate\n@@ -194,19 +196,4 @@\n-    private static <A> int[] partition(Class<?> elemType, A array, long offset, int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<A> po) {\n-        return po.partition(array, low, high, pivotIndex1, pivotIndex2);\n-    }\n-\n-    \/**\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n-     *\/\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n-\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n+    @IntrinsicCandidate\n+    private static <T> int[] partition(Class<?> elemType, T a, long offset,\n+            int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<T> po) {\n+        return po.partition(a, low, high, pivotIndex1, pivotIndex2);\n@@ -217,1 +204,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -231,6 +218,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            int[] b = depth == 0 ? null : new int[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -243,2 +226,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -246,1 +228,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -249,1 +231,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -253,1 +235,1 @@\n-    static void sort(Sorter sorter, int[] a, int bits, int low, int high) {\n+    static void sort(Sorter<int[]> sorter, int[] a, int bits, int low, int high) {\n@@ -255,1 +237,2 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n+\n@@ -257,1 +240,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -259,2 +242,3 @@\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -268,10 +252,2 @@\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -282,2 +258,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -285,2 +260,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -291,2 +266,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -294,1 +270,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -303,1 +279,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -307,1 +283,0 @@\n-            int a3 = a[e3];\n@@ -310,1 +285,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n+                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -313,7 +297,9 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n@@ -321,9 +307,12 @@\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    int t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -331,1 +320,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    int t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -333,3 +322,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    int t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -337,1 +326,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    int t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -341,3 +330,8 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n@@ -346,1 +340,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Switch to heap sort to avoid quadratic time.\n@@ -348,9 +342,10 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -358,0 +353,4 @@\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -359,0 +358,2 @@\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n@@ -365,2 +366,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -368,2 +369,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -372,1 +373,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -374,7 +378,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -387,1 +384,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -389,1 +386,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -392,1 +389,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -397,1 +394,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -399,1 +396,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -404,1 +401,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -406,3 +403,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -410,1 +410,0 @@\n-        int upper = end;\n@@ -412,4 +411,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        int pivot1 = a[e1];\n-        int pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        int pivot1 = a[pivotIndex1];\n+        int pivot2 = a[pivotIndex2];\n@@ -424,2 +426,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -436,13 +438,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -451,0 +447,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -455,14 +453,15 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n-                }\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -477,2 +476,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -480,1 +479,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -484,1 +483,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -486,1 +485,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -489,3 +488,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -493,4 +492,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -498,3 +499,6 @@\n-        int upper = end;\n-        int e3 = pivotIndex1;\n-        int pivot = a[e3];\n+\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        int pivot = a[pivotIndex1];\n@@ -509,1 +513,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -512,11 +516,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n+         * Dutch National Flag partitioning\n@@ -524,3 +518,7 @@\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -529,0 +527,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -530,1 +530,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -533,2 +533,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -536,2 +538,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -539,6 +541,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -546,0 +544,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -553,1 +554,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -557,1 +559,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -559,2 +561,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.<p>\n@@ -572,4 +574,5 @@\n-    private static void mixedInsertionSort(int[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(int[] a, int low, int high) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n@@ -577,4 +580,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -583,2 +587,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -586,1 +590,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -588,1 +592,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            int ai = a[i = low], pin = a[--p];\n@@ -591,7 +602,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -599,40 +604,3 @@\n-            int pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -642,1 +610,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -644,2 +612,5 @@\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -647,6 +618,12 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            int a1 = a[i = low], a2 = a[++low];\n+\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -654,4 +631,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -659,4 +636,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -664,1 +641,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -666,4 +643,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -671,4 +648,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -676,0 +651,1 @@\n+                a[i + 1] = a1;\n@@ -687,1 +663,1 @@\n-    private static void insertionSort(int[] a, int low, int high) {\n+    static void insertionSort(int[] a, int low, int high) {\n@@ -692,4 +668,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -701,1 +678,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -703,0 +680,1 @@\n+     * @param sorter the parallel context\n@@ -706,0 +684,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -707,48 +686,1 @@\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<int[]> sorter, int[] a, int low, int high) {\n@@ -756,3 +688,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -760,0 +691,1 @@\n+        int count = 1;\n@@ -761,2 +693,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -767,2 +697,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -770,1 +699,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -786,0 +715,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -789,0 +724,1 @@\n+                \/\/ Check the next sequence\n@@ -795,1 +731,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -798,1 +734,0 @@\n-                if (k == high) {\n@@ -800,0 +735,1 @@\n+                if (k == high) {\n@@ -801,1 +737,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -806,11 +742,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -819,3 +745,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -823,0 +747,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -824,2 +749,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -830,2 +755,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -837,0 +761,1 @@\n+            }\n@@ -838,1 +763,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -840,5 +768,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -846,1 +774,0 @@\n-            run[count] = (last = k);\n@@ -850,1 +777,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -855,3 +782,1 @@\n-            if (sorter == null || (b = (int[]) sorter.b) == null) {\n-                b = new int[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -859,0 +784,2 @@\n+            } else if ((b = tryAllocate(int[].class, high - low)) == null) {\n+                return false;\n@@ -860,1 +787,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -868,0 +795,1 @@\n+     * @param sorter the parallel context\n@@ -869,1 +797,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -871,2 +799,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -876,1 +803,0 @@\n-     * @return the destination where runs are merged\n@@ -878,2 +804,2 @@\n-    private static int[] mergeRuns(int[] a, int[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<int[]> sorter, int[] a, int[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -882,2 +808,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -885,4 +811,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -892,1 +815,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -894,2 +817,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -898,1 +821,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -900,10 +823,2 @@\n-        int[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (int[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -911,1 +826,2 @@\n-        int[] dst = a1 == a ? b : a;\n+        int[] dst = aim ? a : b;\n+        int[] src = aim ? b : a;\n@@ -913,5 +829,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -919,2 +835,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -922,1 +841,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -924,1 +843,0 @@\n-        return dst;\n@@ -928,1 +846,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -930,1 +848,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -933,1 +851,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -936,1 +854,0 @@\n-     * @param a2 the second part\n@@ -940,2 +857,2 @@\n-    private static void mergeParts(Merger merger, int[] dst, int k,\n-            int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<int[]> merger, int[] dst, int k,\n+            int[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -943,11 +860,8 @@\n-        if (merger != null && a1 == a2) {\n-\n-            while (true) {\n-\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n@@ -955,6 +869,6 @@\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n-                }\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n@@ -962,6 +876,6 @@\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                int key = a1[mi1];\n-                int mi2 = hi2;\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            int key = src[mi1];\n@@ -969,5 +883,5 @@\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n@@ -975,5 +889,4 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n@@ -981,0 +894,1 @@\n+            }\n@@ -982,6 +896,4 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n-\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -989,6 +901,10 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n-            }\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n+\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n@@ -998,1 +914,1 @@\n-         * Merge small parts sequentially.\n+         * Check if the array is already ordered and then merge the parts.\n@@ -1000,2 +916,5 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -1003,1 +922,17 @@\n-        if (dst != a1 || k < lo1) {\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(int[] dst, int k,\n+            int[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n@@ -1005,1 +940,8 @@\n-                dst[k++] = a1[lo1++];\n+                int next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n@@ -1007,2 +949,1 @@\n-        }\n-        if (dst != a2 || k < lo2) {\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n@@ -1010,1 +951,193 @@\n-                dst[k++] = a2[lo2++];\n+                int next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                int next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter<int[]> sorter, int[] a, int low, int high) {\n+        int[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(int[].class, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1 << 10];\n+        int[] count2 = new int[1 << 11];\n+        int[] count3 = new int[1 << 11];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[ a[i]         & 0x3FF];\n+            ++count2[(a[i] >>> 10) & 0x7FF];\n+            ++count3[(a[i] >>> 21) ^ 0x400]; \/\/ Flip the sign bit\n+        }\n+\n+        \/*\n+         * Check digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[a[--i] & 0x3FF] - offset] = a[i];\n+            }\n+        }\n+\n+        \/*\n+         * Process the 2-nd digit.\n+         *\/\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(b[--i] >>> 10) & 0x7FF]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(a[--i] >>> 10) & 0x7FF] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(b[--i] >>> 21) ^ 0x400]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(a[--i] >>> 21) ^ 0x400] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c > 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(int[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            int max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -1013,0 +1146,1 @@\n+        a[p] = value;\n@@ -1015,1 +1149,1 @@\n-\/\/ [long]\n+\/\/ #[long]\n@@ -1019,1 +1153,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -1033,6 +1167,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            long[] b = depth == 0 ? null : new long[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -1045,2 +1175,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1048,1 +1177,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -1051,1 +1180,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1055,1 +1184,1 @@\n-    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {\n+    static void sort(Sorter<long[]> sorter, long[] a, int bits, int low, int high) {\n@@ -1057,1 +1186,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1060,1 +1189,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -1062,2 +1191,3 @@\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -1071,1 +1201,2 @@\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -1076,2 +1207,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Try merging sort on large part.\n@@ -1079,2 +1209,2 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -1085,2 +1215,3 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1088,10 +1219,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1106,1 +1228,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -1110,1 +1232,0 @@\n-            long a3 = a[e3];\n@@ -1113,1 +1234,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n+                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -1116,7 +1246,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -1124,9 +1265,3 @@\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    long t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -1134,1 +1269,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    long t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -1136,3 +1271,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    long t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -1140,1 +1275,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    long t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -1144,3 +1279,22 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -1149,1 +1303,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -1153,8 +1307,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -1166,2 +1315,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -1169,2 +1318,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -1173,1 +1322,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -1175,7 +1327,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -1188,1 +1333,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -1190,1 +1335,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -1193,1 +1338,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -1198,1 +1343,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -1200,1 +1345,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1205,1 +1350,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -1207,3 +1352,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -1211,1 +1359,0 @@\n-        int upper = end;\n@@ -1213,4 +1360,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        long pivot1 = a[e1];\n-        long pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        long pivot1 = a[pivotIndex1];\n+        long pivot2 = a[pivotIndex2];\n@@ -1225,2 +1375,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -1237,13 +1387,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -1252,0 +1396,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1256,14 +1402,15 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n-                }\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -1278,2 +1425,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -1281,1 +1428,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -1285,1 +1432,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -1287,1 +1434,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1290,3 +1437,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -1294,4 +1441,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -1299,1 +1448,0 @@\n-        int upper = end;\n@@ -1301,2 +1449,5 @@\n-        int e3 = pivotIndex1;\n-        long pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        long pivot = a[pivotIndex1];\n@@ -1311,1 +1462,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -1314,11 +1465,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n+         * Dutch National Flag partitioning\n@@ -1326,3 +1467,7 @@\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -1331,0 +1476,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1332,1 +1479,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -1335,2 +1482,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -1338,2 +1487,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -1341,6 +1490,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -1348,0 +1493,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -1355,1 +1503,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -1359,1 +1508,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -1361,2 +1510,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.<p>\n@@ -1374,4 +1523,5 @@\n-    private static void mixedInsertionSort(long[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(long[] a, int low, int high) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n@@ -1379,4 +1529,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -1385,2 +1536,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -1388,1 +1539,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -1390,1 +1541,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            long ai = a[i = low], pin = a[--p];\n@@ -1393,7 +1551,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -1401,40 +1553,3 @@\n-            long pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -1444,1 +1559,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -1446,2 +1561,5 @@\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -1449,6 +1567,12 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            long a1 = a[i = low], a2 = a[++low];\n+\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -1456,4 +1580,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -1461,4 +1585,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -1466,1 +1590,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -1468,4 +1592,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -1473,4 +1597,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1478,0 +1600,1 @@\n+                a[i + 1] = a1;\n@@ -1489,1 +1612,1 @@\n-    private static void insertionSort(long[] a, int low, int high) {\n+    static void insertionSort(long[] a, int low, int high) {\n@@ -1494,38 +1617,3 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using heap sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n@@ -1533,8 +1621,1 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+                a[i] = ai;\n@@ -1543,1 +1624,0 @@\n-        a[p] = value;\n@@ -1547,1 +1627,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1549,1 +1629,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -1551,3 +1631,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1555,2 +1635,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<long[]> sorter, long[] a, int low, int high) {\n@@ -1558,3 +1637,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -1562,0 +1640,1 @@\n+        int count = 1;\n@@ -1563,2 +1642,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -1569,2 +1646,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -1572,1 +1648,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -1588,0 +1664,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -1591,0 +1673,1 @@\n+                \/\/ Check the next sequence\n@@ -1597,1 +1680,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -1600,1 +1683,0 @@\n-                if (k == high) {\n@@ -1602,0 +1684,1 @@\n+                if (k == high) {\n@@ -1603,1 +1686,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -1608,11 +1691,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -1621,3 +1694,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -1625,0 +1696,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -1626,2 +1698,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -1632,2 +1704,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -1639,0 +1710,1 @@\n+            }\n@@ -1640,1 +1712,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -1642,5 +1717,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -1648,1 +1723,0 @@\n-            run[count] = (last = k);\n@@ -1652,1 +1726,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -1657,3 +1731,1 @@\n-            if (sorter == null || (b = (long[]) sorter.b) == null) {\n-                b = new long[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -1661,0 +1733,2 @@\n+            } else if ((b = tryAllocate(long[].class, high - low)) == null) {\n+                return false;\n@@ -1662,1 +1736,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -1670,0 +1744,1 @@\n+     * @param sorter the parallel context\n@@ -1671,1 +1746,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -1673,2 +1748,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -1678,1 +1752,0 @@\n-     * @return the destination where runs are merged\n@@ -1680,2 +1753,2 @@\n-    private static long[] mergeRuns(long[] a, long[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<long[]> sorter, long[] a, long[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -1684,2 +1757,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1687,4 +1760,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -1694,1 +1764,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -1696,2 +1766,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -1700,1 +1770,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -1702,1 +1772,5 @@\n-        long[] a1, a2;\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n+\n+        long[] dst = aim ? a : b;\n+        long[] src = aim ? b : a;\n@@ -1704,4 +1778,11 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (long[]) merger.getDestination();\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -1709,2 +1790,1 @@\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -1712,0 +1792,32 @@\n+    }\n+\n+    \/**\n+     * Merges the sorted parts in parallel.\n+     *\n+     * @param merger the parallel context\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(Merger<long[]> merger, long[] dst, int k,\n+            long[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n+\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n@@ -1713,1 +1825,29 @@\n-        long[] dst = a1 == a ? b : a;\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            long key = src[mi1];\n+\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n+                }\n+            }\n+\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n+\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -1715,5 +1855,6 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n@@ -1721,2 +1862,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -1724,1 +1868,2 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -1726,1 +1871,0 @@\n-        return dst;\n@@ -1730,1 +1874,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts sequentially.\n@@ -1732,1 +1876,0 @@\n-     * @param merger parallel context\n@@ -1735,1 +1878,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -1738,1 +1881,0 @@\n-     * @param a2 the second part\n@@ -1742,2 +1884,2 @@\n-    private static void mergeParts(Merger merger, long[] dst, int k,\n-            long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {\n+    private static void mergeParts(long[] dst, int k,\n+            long[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -1745,1 +1887,3 @@\n-        if (merger != null && a1 == a2) {\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                long next = src[lo1];\n@@ -1747,1 +1891,10 @@\n-            while (true) {\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                long next = src[lo1];\n@@ -1749,6 +1902,5 @@\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n@@ -1756,0 +1908,4 @@\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                long next = src[lo1];\n@@ -1757,5 +1913,2 @@\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n@@ -1763,0 +1916,5 @@\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        }\n@@ -1764,6 +1922,6 @@\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                long key = a1[mi1];\n-                int mi2 = hi2;\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n@@ -1771,5 +1929,12 @@\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter<long[]> sorter, long[] a, int low, int high) {\n+        long[] b; int offset = low, size = high - low;\n@@ -1777,6 +1942,8 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(long[].class, size)) == null) {\n+            return false;\n+        }\n@@ -1784,1 +1951,2 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+        int start = low - offset;\n+        int last = high - offset;\n@@ -1786,4 +1954,18 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1 << 10];\n+        int[] count2 = new int[1 << 11];\n+        int[] count3 = new int[1 << 11];\n+        int[] count4 = new int[1 << 11];\n+        int[] count5 = new int[1 << 11];\n+        int[] count6 = new int[1 << 10];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[(int)  (a[i]         & 0x3FF)];\n+            ++count2[(int) ((a[i] >>> 10) & 0x7FF)];\n+            ++count3[(int) ((a[i] >>> 21) & 0x7FF)];\n+            ++count4[(int) ((a[i] >>> 32) & 0x7FF)];\n+            ++count5[(int) ((a[i] >>> 43) & 0x7FF)];\n+            ++count6[(int) ((a[i] >>> 54) ^ 0x200)]; \/\/ Flip the sign bit\n+        }\n@@ -1791,5 +1973,16 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+        \/*\n+         * Check digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n+        boolean processDigit4 = processDigit(count4, size, low);\n+        boolean processDigit5 = processDigit(count5, size, low);\n+        boolean processDigit6 = processDigit(count6, size, low);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[(int) (a[--i] & 0x3FF)] - offset] = a[i];\n@@ -1800,1 +1993,1 @@\n-         * Merge small parts sequentially.\n+         * Process the 2-nd digit.\n@@ -1802,2 +1995,10 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(int) ((b[--i] >>> 10) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(int) ((a[--i] >>> 10) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n@@ -1805,3 +2006,13 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(int) ((b[--i] >>> 21) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(int) ((a[--i] >>> 21) & 0x7FF)] - offset] = a[i];\n+                }\n@@ -1810,3 +2021,94 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = last; i > start; ) {\n+                    a[--count4[(int) ((b[--i] >>> 32) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count4[(int) ((a[--i] >>> 32) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = last; i > start; ) {\n+                    a[--count5[(int) ((b[--i] >>> 43) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count5[(int) ((a[--i] >>> 43) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = last; i > start; ) {\n+                    a[--count6[(int) ((b[--i] >>> 54) ^ 0x200)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count6[(int) ((a[--i] >>> 54) ^ 0x200)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(long[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            long max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -1815,0 +2117,1 @@\n+        a[p] = value;\n@@ -1817,1 +2120,1 @@\n-\/\/ [byte]\n+\/\/ #[byte]\n@@ -1820,2 +2123,1 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or insertion sort.\n+     * Sorts the specified range of the array using insertion sort or counting sort.\n@@ -1828,3 +2130,1 @@\n-        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n+        if (high - low < MAX_INSERTION_SORT_SIZE) {\n@@ -1832,0 +2132,2 @@\n+        } else {\n+            countingSort(a, low, high);\n@@ -1842,1 +2144,1 @@\n-    private static void insertionSort(byte[] a, int low, int high) {\n+    static void insertionSort(byte[] a, int low, int high) {\n@@ -1847,4 +2149,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -1855,10 +2158,0 @@\n-    \/**\n-     * The number of distinct byte values.\n-     *\/\n-    private static final int NUM_BYTE_VALUES = 1 << 8;\n-\n-    \/**\n-     * Max index of byte counter.\n-     *\/\n-    private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;\n-\n@@ -1872,2 +2165,2 @@\n-    private static void countingSort(byte[] a, int low, int high) {\n-        int[] count = new int[NUM_BYTE_VALUES];\n+    static void countingSort(byte[] a, int low, int high) {\n+        int[] count = new int[1 << 8];\n@@ -1876,1 +2169,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram.\n@@ -1883,14 +2176,3 @@\n-        if (high - low > NUM_BYTE_VALUES) {\n-            for (int i = MAX_BYTE_INDEX; --i > Byte.MAX_VALUE; ) {\n-                int value = i & 0xFF;\n-\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (byte) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_BYTE_INDEX; high > low; ) {\n-                while (count[--i & 0xFF] == 0);\n-\n-                int value = i & 0xFF;\n-                int c = count[value];\n+        for (int value = Byte.MIN_VALUE; high > low; ) {\n+            while (count[--value & 0xFF] == 0);\n+            int num = count[value & 0xFF];\n@@ -1898,4 +2180,3 @@\n-                do {\n-                    a[--high] = (byte) value;\n-                } while (--c > 0);\n-            }\n+            do {\n+                a[--high] = (byte) value;\n+            } while (--num > 0);\n@@ -1905,1 +2186,1 @@\n-\/\/ [char]\n+\/\/ #[char]\n@@ -1908,2 +2189,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort,\n+     * Radix sort or Dual-Pivot Quicksort.\n@@ -1916,1 +2197,1 @@\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n@@ -1918,0 +2199,2 @@\n+        } else if (high - low > MIN_RADIX_SORT_SIZE) {\n+            radixSort(a, low, high);\n@@ -1924,2 +2207,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1929,1 +2211,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1933,1 +2215,1 @@\n-    static void sort(char[] a, int bits, int low, int high) {\n+    private static void sort(char[] a, int bits, int low, int high) {\n@@ -1935,1 +2217,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1938,1 +2220,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -1946,2 +2228,3 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1949,10 +2232,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1967,1 +2241,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -1971,1 +2245,0 @@\n-            char a3 = a[e3];\n@@ -1974,1 +2247,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -1977,7 +2250,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -1985,9 +2269,3 @@\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    char t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -1995,1 +2273,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    char t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -1997,3 +2275,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    char t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2001,1 +2279,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    char t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2005,3 +2283,7 @@\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to Radix sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                radixSort(a, low, high);\n+                return;\n+            }\n@@ -2010,1 +2292,7 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2014,7 +2302,1 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                char pivot1 = a[e1];\n-                char pivot2 = a[e5];\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n@@ -2023,5 +2305,2 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n@@ -2029,2 +2308,6 @@\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3);\n@@ -2033,1 +2316,3 @@\n-                 * Skip elements, which are less or greater than the pivots.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2035,0 +2320,67 @@\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            char[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        char pivot1 = a[pivotIndex1];\n+        char pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            char ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2036,1 +2388,0 @@\n-                while (a[--upper] > pivot2);\n@@ -2038,39 +2389,3 @@\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n@@ -2078,0 +2393,12 @@\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -2079,5 +2406,5 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2085,6 +2412,2 @@\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n+        return new int[] { lower, upper };\n+    }\n@@ -2092,1 +2415,16 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            char[] a, int low, int high, int pivotIndex) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n@@ -2094,5 +2432,5 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                char pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        char pivot = a[pivotIndex];\n@@ -2100,8 +2438,8 @@\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex] = a[lower];\n@@ -2109,21 +2447,17 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            char ak = a[k];\n@@ -2131,2 +2465,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2134,2 +2470,2 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -2137,8 +2473,2 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -2146,0 +2476,5 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n+            }\n+        }\n@@ -2147,4 +2482,4 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n@@ -2152,6 +2487,20 @@\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n+        return new int[] { lower, upper };\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort(char[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            char ai = a[i = k];\n+\n+            if (ai < a[i - 1]) {\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -2159,1 +2508,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2164,1 +2512,1 @@\n-     * Sorts the specified range of the array using insertion sort.\n+     * Sorts the specified range of the array using counting sort.\n@@ -2170,3 +2518,2 @@\n-    private static void insertionSort(char[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            char ai = a[i = k];\n+    static void countingSort(char[] a, int low, int high) {\n+        int[] count = new int[1 << 16];\n@@ -2174,6 +2521,15 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        for (int i = high; i > low; ++count[a[--i]]);\n+\n+        \/*\n+         * Place values on their final positions.\n+         *\/\n+        for (int value = count.length; high > low; ) {\n+            while (count[--value] == 0);\n+            int num = count[value];\n+\n+            do {\n+                a[--high] = (char) value;\n+            } while (--num > 0);\n@@ -2184,6 +2540,1 @@\n-     * The number of distinct char values.\n-     *\/\n-    private static final int NUM_CHAR_VALUES = 1 << 16;\n-\n-    \/**\n-     * Sorts the specified range of the array using counting sort.\n+     * Sorts the specified range of the array using Radix sort.\n@@ -2195,2 +2546,11 @@\n-    private static void countingSort(char[] a, int low, int high) {\n-        int[] count = new int[NUM_CHAR_VALUES];\n+    static void radixSort(char[] a, int low, int high) {\n+        \/*\n+         * Count the number of all bytes.\n+         *\/\n+        int[] count1 = new int[1 << 8];\n+        int[] count2 = new int[1 << 8];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[ a[i]        & 0xFF];\n+            ++count2[(a[i] >>> 8) & 0xFF];\n+        }\n@@ -2199,1 +2559,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Check bytes to be processed.\n@@ -2201,1 +2561,9 @@\n-        for (int i = high; i > low; ++count[a[--i]]);\n+        count1[0] += low;\n+        count2[0] += low;\n+\n+        for (int i = 0; ++i < 256; ) {\n+            count1[i] += count1[i - 1];\n+            count2[i] += count2[i - 1];\n+        }\n+\n+        int size = high - low;\n@@ -2204,1 +2572,1 @@\n-         * Place values on their final positions.\n+         * Allocate additional buffer.\n@@ -2206,10 +2574,1 @@\n-        if (high - low > NUM_CHAR_VALUES) {\n-            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n-                for (low = high - count[--i]; high > low;\n-                    a[--high] = (char) i\n-                );\n-            }\n-        } else {\n-            for (int i = NUM_CHAR_VALUES; high > low; ) {\n-                while (count[--i] == 0);\n-                int c = count[i];\n+        char[] b = new char[size];\n@@ -2217,4 +2576,12 @@\n-                do {\n-                    a[--high] = (char) i;\n-                } while (--c > 0);\n-            }\n+        \/*\n+         * Process the 1-st byte.\n+         *\/\n+        for (int i = high; i > low; ) {\n+            b[--count1[a[--i] & 0xFF] - low] = a[i];\n+        }\n+\n+        \/*\n+         * Process the 2-nd byte.\n+         *\/\n+        for (int i = size; i > 0; ) {\n+            a[--count2[(b[--i] >>> 8) & 0xFF]] = b[i];\n@@ -2224,1 +2591,1 @@\n-\/\/ [short]\n+\/\/ #[short]\n@@ -2227,2 +2594,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort,\n+     * Radix sort or Dual-Pivot Quicksort.\n@@ -2235,1 +2602,1 @@\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n@@ -2237,0 +2604,2 @@\n+        } else if (high - low > MIN_RADIX_SORT_SIZE) {\n+            radixSort(a, low, high);\n@@ -2243,2 +2612,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2248,1 +2616,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2252,1 +2620,1 @@\n-    static void sort(short[] a, int bits, int low, int high) {\n+    private static void sort(short[] a, int bits, int low, int high) {\n@@ -2254,1 +2622,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2257,1 +2625,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -2265,11 +2633,3 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2277,1 +2637,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2286,1 +2646,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -2290,1 +2650,0 @@\n-            short a3 = a[e3];\n@@ -2293,1 +2652,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2296,7 +2655,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -2304,9 +2674,3 @@\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    short t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -2314,1 +2678,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    short t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -2316,3 +2680,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    short t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2320,1 +2684,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    short t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2324,3 +2688,13 @@\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to Radix sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                radixSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -2329,1 +2703,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2333,7 +2707,1 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                short pivot1 = a[e1];\n-                short pivot2 = a[e5];\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n@@ -2342,5 +2710,2 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n@@ -2348,2 +2713,6 @@\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3);\n@@ -2352,1 +2721,3 @@\n-                 * Skip elements, which are less or greater than the pivots.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2354,0 +2725,67 @@\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            short[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        short pivot1 = a[pivotIndex1];\n+        short pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            short ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2355,1 +2793,0 @@\n-                while (a[--upper] > pivot2);\n@@ -2357,39 +2794,9 @@\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n@@ -2397,0 +2804,6 @@\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -2398,5 +2811,5 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2404,6 +2817,2 @@\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n+        return new int[] { lower, upper };\n+    }\n@@ -2411,1 +2820,16 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            short[] a, int low, int high, int pivotIndex) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n@@ -2413,5 +2837,5 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                short pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        short pivot = a[pivotIndex];\n@@ -2419,8 +2843,8 @@\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex] = a[lower];\n@@ -2428,21 +2852,17 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            short ak = a[k];\n@@ -2450,2 +2870,4 @@\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2453,2 +2875,2 @@\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -2456,8 +2878,2 @@\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -2465,12 +2881,3 @@\n-\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n-\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2478,1 +2885,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2480,0 +2886,7 @@\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n@@ -2489,1 +2902,1 @@\n-    private static void insertionSort(short[] a, int low, int high) {\n+    static void insertionSort(short[] a, int low, int high) {\n@@ -2494,4 +2907,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -2502,10 +2916,0 @@\n-    \/**\n-     * The number of distinct short values.\n-     *\/\n-    private static final int NUM_SHORT_VALUES = 1 << 16;\n-\n-    \/**\n-     * Max index of short counter.\n-     *\/\n-    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n-\n@@ -2519,2 +2923,2 @@\n-    private static void countingSort(short[] a, int low, int high) {\n-        int[] count = new int[NUM_SHORT_VALUES];\n+    static void countingSort(short[] a, int low, int high) {\n+        int[] count = new int[1 << 16];\n@@ -2523,1 +2927,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram.\n@@ -2530,3 +2934,3 @@\n-        if (high - low > NUM_SHORT_VALUES) {\n-            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n-                int value = i & 0xFFFF;\n+        for (int value = Short.MIN_VALUE; high > low; ) {\n+            while (count[--value & 0xFFFF] == 0);\n+            int num = count[value & 0xFFFF];\n@@ -2534,7 +2938,5 @@\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (short) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_SHORT_INDEX; high > low; ) {\n-                while (count[--i & 0xFFFF] == 0);\n+            do {\n+                a[--high] = (short) value;\n+            } while (--num > 0);\n+        }\n+    }\n@@ -2542,2 +2944,13 @@\n-                int value = i & 0xFFFF;\n-                int c = count[value];\n+    \/**\n+     * Sorts the specified range of the array using Radix sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void radixSort(short[] a, int low, int high) {\n+        \/*\n+         * Count the number of all bytes.\n+         *\/\n+        int[] count1 = new int[1 << 8];\n+        int[] count2 = new int[1 << 8];\n@@ -2545,4 +2958,35 @@\n-                do {\n-                    a[--high] = (short) value;\n-                } while (--c > 0);\n-            }\n+        for (int i = low; i < high; ++i) {\n+            ++count1[  a[i]        & 0xFF];\n+            ++count2[((a[i] >>> 8) & 0xFF) ^ 0x80]; \/\/ Flip the sign bit\n+        }\n+\n+        \/*\n+         * Check bytes to be processed.\n+         *\/\n+        count1[0] += low;\n+        count2[0] += low;\n+\n+        for (int i = 0; ++i < 256; ) {\n+            count1[i] += count1[i - 1];\n+            count2[i] += count2[i - 1];\n+        }\n+\n+        int size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        short[] b = new short[size];\n+\n+        \/*\n+         * Process the 1-st byte.\n+         *\/\n+        for (int i = high; i > low; ) {\n+            b[--count1[a[--i] & 0xFF] - low] = a[i];\n+        }\n+\n+        \/*\n+         * Process the 2-nd byte.\n+         *\/\n+        for (int i = size; i > 0; ) {\n+            a[--count2[((b[--i] >>> 8) & 0xFF) ^ 0x80]] = b[i];\n@@ -2552,1 +2996,6 @@\n-\/\/ [float]\n+\/\/ #[float]\n+\n+    \/**\n+     * The binary representation of float negative zero.\n+     *\/\n+    private static final int FLOAT_NEGATIVE_ZERO = Float.floatToRawIntBits(-0.0f);\n@@ -2556,1 +3005,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -2575,1 +3024,1 @@\n-        int numNegativeZero = 0;\n+        int negativeZeroCount = 0;\n@@ -2580,2 +3029,2 @@\n-            if (ak == 0.0f && Float.floatToRawIntBits(ak) < 0) { \/\/ ak is -0.0f\n-                numNegativeZero += 1;\n+            if (Float.floatToRawIntBits(ak) == FLOAT_NEGATIVE_ZERO) { \/\/ ak is -0.0f\n+                negativeZeroCount++;\n@@ -2583,1 +3032,1 @@\n-            } else if (ak != ak) { \/\/ ak is NaN\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n@@ -2593,6 +3042,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            float[] b = depth == 0 ? null : new float[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -2604,2 +3049,2 @@\n-         * Phase 3. Turn positive zero 0.0f\n-         * back into negative zero -0.0f.\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0f back into negative zeros -0.0f.\n@@ -2607,1 +3052,1 @@\n-        if (++numNegativeZero == 1) {\n+        if (++negativeZeroCount == 1) {\n@@ -2616,1 +3061,1 @@\n-            int middle = (low + high) >>> 1;\n+            int mid = (low + high) >>> 1;\n@@ -2618,2 +3063,2 @@\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n+            if (a[mid] < 0.0f) {\n+                low = mid + 1;\n@@ -2621,1 +3066,1 @@\n-                high = middle - 1;\n+                high = mid - 1;\n@@ -2626,1 +3071,1 @@\n-         * Replace the required number of 0.0f by -0.0f.\n+         * Replace 0.0f by negative zeros -0.0f.\n@@ -2628,1 +3073,1 @@\n-        while (--numNegativeZero > 0) {\n+        while (--negativeZeroCount > 0) {\n@@ -2634,2 +3079,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2637,1 +3081,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -2640,1 +3084,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2644,1 +3088,1 @@\n-    static void sort(Sorter sorter, float[] a, int bits, int low, int high) {\n+    static void sort(Sorter<float[]> sorter, float[] a, int bits, int low, int high) {\n@@ -2646,1 +3090,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2649,1 +3093,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -2651,2 +3095,3 @@\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -2660,10 +3105,2 @@\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -2674,2 +3111,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -2677,2 +3113,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -2683,2 +3119,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2686,1 +3123,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2695,1 +3132,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -2699,1 +3136,0 @@\n-            float a3 = a[e3];\n@@ -2702,1 +3138,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n+                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -2705,7 +3150,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -2713,9 +3169,3 @@\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    float t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -2723,1 +3173,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    float t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -2725,3 +3175,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    float t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2729,1 +3179,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    float t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2733,3 +3183,22 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -2738,1 +3207,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2742,8 +3211,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -2755,2 +3219,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -2758,2 +3222,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -2762,1 +3226,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -2764,7 +3231,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -2777,1 +3237,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -2779,1 +3239,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -2782,1 +3242,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -2787,1 +3247,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -2789,1 +3249,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2794,1 +3254,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -2796,3 +3256,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -2800,1 +3263,0 @@\n-        int upper = end;\n@@ -2802,4 +3264,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        float pivot1 = a[e1];\n-        float pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        float pivot1 = a[pivotIndex1];\n+        float pivot2 = a[pivotIndex2];\n@@ -2814,2 +3279,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -2826,13 +3291,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -2841,0 +3300,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2845,14 +3306,15 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n-                }\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2867,2 +3329,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2870,1 +3332,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -2874,1 +3336,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -2876,1 +3338,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2879,3 +3341,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -2883,3 +3345,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -2887,1 +3352,0 @@\n-        int upper = end;\n@@ -2889,2 +3353,5 @@\n-        int e3 = pivotIndex1;\n-        float pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        float pivot = a[pivotIndex1];\n@@ -2899,1 +3366,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -2902,9 +3369,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n+         * Dutch National Flag partitioning\n@@ -2912,5 +3371,7 @@\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -2919,0 +3380,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2920,1 +3383,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -2923,2 +3386,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2926,2 +3391,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -2929,6 +3394,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -2936,0 +3397,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2943,1 +3407,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -2947,1 +3412,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -2949,2 +3414,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.<p>\n@@ -2962,4 +3427,5 @@\n-    private static void mixedInsertionSort(float[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(float[] a, int low, int high) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n@@ -2967,4 +3433,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -2973,2 +3440,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -2976,1 +3443,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -2978,1 +3445,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            float ai = a[i = low], pin = a[--p];\n@@ -2981,7 +3455,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -2989,40 +3457,3 @@\n-            float pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -3032,1 +3463,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -3034,2 +3465,5 @@\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -3037,6 +3471,12 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            float a1 = a[i = low], a2 = a[++low];\n+\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -3044,4 +3484,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3049,4 +3489,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3054,1 +3494,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -3056,4 +3496,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -3061,4 +3501,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3066,0 +3504,1 @@\n+                a[i + 1] = a1;\n@@ -3077,1 +3516,1 @@\n-    private static void insertionSort(float[] a, int low, int high) {\n+    static void insertionSort(float[] a, int low, int high) {\n@@ -3082,4 +3521,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -3091,1 +3531,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3093,0 +3533,1 @@\n+     * @param sorter the parallel context\n@@ -3096,0 +3537,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3097,48 +3539,1 @@\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<float[]> sorter, float[] a, int low, int high) {\n@@ -3146,3 +3541,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -3150,0 +3544,1 @@\n+        int count = 1;\n@@ -3151,2 +3546,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -3157,2 +3550,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -3160,1 +3552,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -3176,0 +3568,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -3179,0 +3577,1 @@\n+                \/\/ Check the next sequence\n@@ -3185,1 +3584,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -3188,1 +3587,0 @@\n-                if (k == high) {\n@@ -3190,0 +3588,1 @@\n+                if (k == high) {\n@@ -3191,1 +3590,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -3196,11 +3595,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -3209,3 +3598,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -3213,0 +3600,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -3214,2 +3602,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -3220,2 +3608,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -3227,0 +3614,1 @@\n+            }\n@@ -3228,1 +3616,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -3230,5 +3621,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -3236,1 +3627,0 @@\n-            run[count] = (last = k);\n@@ -3240,1 +3630,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -3245,3 +3635,1 @@\n-            if (sorter == null || (b = (float[]) sorter.b) == null) {\n-                b = new float[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -3249,0 +3637,2 @@\n+            } else if ((b = tryAllocate(float[].class, high - low)) == null) {\n+                return false;\n@@ -3250,1 +3640,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -3258,0 +3648,1 @@\n+     * @param sorter the parallel context\n@@ -3259,1 +3650,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -3261,2 +3652,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -3266,1 +3656,0 @@\n-     * @return the destination where runs are merged\n@@ -3268,2 +3657,220 @@\n-    private static float[] mergeRuns(float[] a, float[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<float[]> sorter, float[] a, float[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n+\n+        if (hi - lo == 1) {\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n+            }\n+            return;\n+        }\n+\n+        \/*\n+         * Split the array into two approximately equal parts.\n+         *\/\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n+\n+        \/*\n+         * Merge the runs of all parts.\n+         *\/\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n+\n+        float[] dst = aim ? a : b;\n+        float[] src = aim ? b : a;\n+\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n+        } else {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts in parallel.\n+     *\n+     * @param merger the parallel context\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(Merger<float[]> merger, float[] dst, int k,\n+            float[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n+\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n+\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            float key = src[mi1];\n+\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n+                }\n+            }\n+\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n+\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n+\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n+\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(float[] dst, int k,\n+            float[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                float next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                float next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                float next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter<float[]> sorter, float[] a, int low, int high) {\n+        float[] b; int offset = low, size = high - low;\n+\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(float[].class, size)) == null) {\n+            return false;\n+        }\n+\n+        int start = low - offset;\n+        int last = high - offset;\n+\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1 << 10];\n+        int[] count2 = new int[1 << 11];\n+        int[] count3 = new int[1 << 11];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[ f2i(a[i])         & 0x3FF];\n+            ++count2[(f2i(a[i]) >>> 10) & 0x7FF];\n+            ++count3[(f2i(a[i]) >>> 21) & 0x7FF];\n+        }\n+\n+        \/*\n+         * Check digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n@@ -3271,3 +3878,6 @@\n-        if (hi - lo == 1) {\n-            if (aim >= 0) {\n-                return a;\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[f2i(a[--i]) & 0x3FF] - offset] = a[i];\n@@ -3275,4 +3885,0 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n@@ -3282,1 +3888,1 @@\n-         * Split into approximately equal parts.\n+         * Process the 2-nd digit.\n@@ -3284,2 +3890,11 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(f2i(b[--i]) >>> 10) & 0x7FF]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(f2i(a[--i]) >>> 10) & 0x7FF] - offset] = a[i];\n+                }\n+            }\n+        }\n@@ -3288,1 +3903,1 @@\n-         * Merge the left and right parts.\n+         * Process the 3-rd digit.\n@@ -3290,1 +3905,11 @@\n-        float[] a1, a2;\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(f2i(b[--i]) >>> 21) & 0x7FF]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(f2i(a[--i]) >>> 21) & 0x7FF] - offset] = a[i];\n+                }\n+            }\n+        }\n@@ -3292,7 +3917,5 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (float[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+            System.arraycopy(b, low - offset, a, low, size);\n@@ -3300,0 +3923,2 @@\n+        return true;\n+    }\n@@ -3301,1 +3926,1 @@\n-        float[] dst = a1 == a ? b : a;\n+    private static final int SIGN_32_BIT = 1 << 31;\n@@ -3303,5 +3928,10 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+    \/**\n+     * Returns the masked bits of float value.\n+     *\n+     * @param f the given float value\n+     * @return masked bits\n+     *\/\n+    private static int f2i(float f) {\n+        int x = Float.floatToRawIntBits(f);\n+        return x < 0 ? ~x : x | SIGN_32_BIT;\n+    }\n@@ -3309,4 +3939,15 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n-        } else {\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(float[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            float max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n@@ -3314,1 +3955,0 @@\n-        return dst;\n@@ -3318,1 +3958,1 @@\n-     * Merges the sorted parts.\n+     * Pushes specified element down during heap sort.\n@@ -3320,9 +3960,5 @@\n-     * @param merger parallel context\n-     * @param dst the destination where parts are merged\n-     * @param k the start index of the destination, inclusive\n-     * @param a1 the first part\n-     * @param lo1 the start index of the first part, inclusive\n-     * @param hi1 the end index of the first part, exclusive\n-     * @param a2 the second part\n-     * @param lo2 the start index of the second part, inclusive\n-     * @param hi2 the end index of the second part, exclusive\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n@@ -3330,48 +3966,3 @@\n-    private static void mergeParts(Merger merger, float[] dst, int k,\n-            float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {\n-\n-        if (merger != null && a1 == a2) {\n-\n-            while (true) {\n-\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n-\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n-                }\n-\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                float key = a1[mi1];\n-                int mi2 = hi2;\n-\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n-\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n-\n-                int d = mi2 - lo2 + mi1 - lo1;\n-\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n@@ -3379,5 +3970,2 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+            if (k > high) {\n+                break;\n@@ -3385,11 +3973,2 @@\n-        }\n-\n-        \/*\n-         * Merge small parts sequentially.\n-         *\/\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n-        }\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n@@ -3397,4 +3976,2 @@\n-        }\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+            if (a[k] <= value) {\n+                break;\n@@ -3403,0 +3980,1 @@\n+        a[p] = value;\n@@ -3405,1 +3983,6 @@\n-\/\/ [double]\n+\/\/ #[double]\n+\n+    \/**\n+     * The binary representation of double negative zero.\n+     *\/\n+    private static final long DOUBLE_NEGATIVE_ZERO = Double.doubleToRawLongBits(-0.0d);\n@@ -3409,1 +3992,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -3428,1 +4011,1 @@\n-        int numNegativeZero = 0;\n+        int negativeZeroCount = 0;\n@@ -3433,2 +4016,2 @@\n-            if (ak == 0.0d && Double.doubleToRawLongBits(ak) < 0) { \/\/ ak is -0.0d\n-                numNegativeZero += 1;\n+            if (Double.doubleToRawLongBits(ak) == DOUBLE_NEGATIVE_ZERO) { \/\/ ak is -0.0d\n+                negativeZeroCount++;\n@@ -3436,1 +4019,1 @@\n-            } else if (ak != ak) { \/\/ ak is NaN\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n@@ -3446,6 +4029,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            double[] b = depth == 0 ? null : new double[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -3457,2 +4036,2 @@\n-         * Phase 3. Turn positive zero 0.0d\n-         * back into negative zero -0.0d.\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0d back into negative zeros -0.0d.\n@@ -3460,1 +4039,1 @@\n-        if (++numNegativeZero == 1) {\n+        if (++negativeZeroCount == 1) {\n@@ -3469,1 +4048,1 @@\n-            int middle = (low + high) >>> 1;\n+            int mid = (low + high) >>> 1;\n@@ -3471,2 +4050,2 @@\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n+            if (a[mid] < 0.0d) {\n+                low = mid + 1;\n@@ -3474,1 +4053,1 @@\n-                high = middle - 1;\n+                high = mid - 1;\n@@ -3479,1 +4058,1 @@\n-         * Replace the required number of 0.0d by -0.0d.\n+         * Replace 0.0d by negative zeros -0.0d.\n@@ -3481,1 +4060,1 @@\n-        while (--numNegativeZero > 0) {\n+        while (--negativeZeroCount > 0) {\n@@ -3487,2 +4066,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -3490,1 +4068,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -3493,1 +4071,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -3497,1 +4075,1 @@\n-    static void sort(Sorter sorter, double[] a, int bits, int low, int high) {\n+    static void sort(Sorter<double[]> sorter, double[] a, int bits, int low, int high) {\n@@ -3499,1 +4077,2 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n+\n@@ -3501,1 +4080,1 @@\n-             * Run mixed insertion sort on small non-leftmost parts.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -3503,2 +4082,3 @@\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -3512,10 +4092,2 @@\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n-                return;\n-            }\n-\n-            \/*\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n-             *\/\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -3526,2 +4098,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -3529,2 +4100,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -3535,2 +4106,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -3538,1 +4110,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -3547,1 +4119,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -3551,1 +4123,0 @@\n-            double a3 = a[e3];\n@@ -3554,1 +4125,10 @@\n-             * Sort these elements in place by the combination\n+             * Check if part is large and contains random\n+             * data, taking into account parallel context.\n+             *\/\n+            boolean isLargeRandom =\n+\/\/              size > MIN_RADIX_SORT_SIZE && (sorter == null || bits > 0) &&\n+                size > MIN_RADIX_SORT_SIZE && (sorter != null && bits > 0) &&\n+                (a[e1] > a[e2] || a[e2] > a[e3] || a[e3] > a[e4] || a[e4] > a[e5]);\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n@@ -3557,7 +4137,18 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n@@ -3565,9 +4156,3 @@\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    double t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -3575,1 +4160,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    double t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -3577,3 +4162,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    double t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -3581,1 +4166,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    double t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -3585,3 +4170,22 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Try Radix sort on large fully random data.\n+             *\/\n+            if (isLargeRandom\n+                    && a[e1] < a[e2] && a[e2] < a[e4] && a[e4] < a[e5]\n+                    && tryRadixSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -3590,1 +4194,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -3594,8 +4198,3 @@\n-                \/*\n-                * Use the first and fifth of the five sorted elements as\n-                * the pivots. These values are inexpensive approximation\n-                * of tertiles. Note, that pivot1 < pivot2.\n-                *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -3607,2 +4206,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -3610,2 +4209,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -3614,1 +4213,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -3616,7 +4215,2 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -3630,1 +4224,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -3632,1 +4226,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -3635,1 +4229,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -3640,1 +4234,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -3642,1 +4236,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3647,1 +4241,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -3649,3 +4243,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -3653,1 +4250,0 @@\n-        int upper = end;\n@@ -3655,4 +4251,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        double pivot1 = a[e1];\n-        double pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        double pivot1 = a[pivotIndex1];\n+        double pivot2 = a[pivotIndex2];\n@@ -3661,8 +4260,8 @@\n-        * The first and the last elements to be sorted are moved\n-        * to the locations formerly occupied by the pivots. When\n-        * partitioning is completed, the pivots are swapped back\n-        * into their final positions, and excluded from the next\n-        * subsequent sorting.\n-        *\/\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -3671,2 +4270,2 @@\n-        * Skip elements, which are less or greater than the pivots.\n-        *\/\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n@@ -3679,13 +4278,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -3694,0 +4287,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3698,14 +4293,15 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n-                }\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -3720,2 +4316,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -3723,1 +4319,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -3727,1 +4323,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -3729,1 +4325,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3732,2 +4328,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -3735,4 +4332,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -3740,1 +4339,0 @@\n-        int upper = end;\n@@ -3742,2 +4340,5 @@\n-        int e3 = pivotIndex1;\n-        double pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        double pivot = a[pivotIndex1];\n@@ -3746,7 +4347,7 @@\n-        * The first element to be sorted is moved to the\n-        * location formerly occupied by the pivot. After\n-        * completion of partitioning the pivot is swapped\n-        * back into its final position, and excluded from\n-        * the next subsequent sorting.\n-        *\/\n-        a[e3] = a[lower];\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -3755,9 +4356,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n+         * Dutch National Flag partitioning\n@@ -3765,5 +4358,7 @@\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -3772,0 +4367,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3773,1 +4370,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -3776,2 +4373,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -3779,2 +4378,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -3782,6 +4381,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -3789,0 +4384,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -3796,1 +4394,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -3800,1 +4399,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -3802,2 +4401,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort,\n+     * simple insertion sort and pair insertion sort.<p>\n@@ -3815,4 +4414,5 @@\n-    private static void mixedInsertionSort(double[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(double[] a, int low, int high) {\n+        \/*\n+         * Split part for pin and pair insertion sorts.\n+         *\/\n+        int end = high - 3 * ((high - low) >> 3 << 1);\n@@ -3820,4 +4420,5 @@\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n+        \/*\n+         * Invoke simple insertion sort on small part.\n+         *\/\n+        if (end == high) {\n+            for (int i; ++low < high; ) {\n@@ -3826,2 +4427,2 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n+                while (ai < a[i - 1]) {\n+                    a[i] = a[--i];\n@@ -3829,1 +4430,1 @@\n-                a[i + 1] = ai;\n+                a[i] = ai;\n@@ -3831,1 +4432,8 @@\n-        } else {\n+            return;\n+        }\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            double ai = a[i = low], pin = a[--p];\n@@ -3834,7 +4442,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -3842,40 +4444,3 @@\n-            double pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -3885,1 +4450,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -3887,2 +4452,5 @@\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -3890,6 +4458,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            double a1 = a[i = low], a2 = a[++low];\n@@ -3897,4 +4464,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -3902,4 +4471,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3907,1 +4476,4 @@\n-                } else if (a1 < a[i - 1]) {\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3909,4 +4481,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -3914,4 +4483,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -3919,14 +4486,1 @@\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(double[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            double ai = a[i = k];\n+                a[++i + 1] = a2;\n@@ -3934,2 +4488,1 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n+                while (a1 < a[--i]) {\n@@ -3938,1 +4491,1 @@\n-                a[i + 1] = ai;\n+                a[i + 1] = a1;\n@@ -3944,1 +4497,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Sorts the specified range of the array using insertion sort.\n@@ -3950,23 +4503,3 @@\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n+    static void insertionSort(double[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            double ai = a[i = k];\n@@ -3974,8 +4507,6 @@\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+            if (ai < a[i - 1]) {\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -3984,1 +4515,0 @@\n-        a[p] = value;\n@@ -3988,1 +4518,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3990,1 +4520,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -3992,3 +4522,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3996,2 +4526,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<double[]> sorter, double[] a, int low, int high) {\n@@ -3999,3 +4528,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -4003,0 +4531,1 @@\n+        int count = 1;\n@@ -4004,2 +4533,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -4010,2 +4537,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -4013,1 +4539,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -4029,0 +4555,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -4032,0 +4564,1 @@\n+                \/\/ Check the next sequence\n@@ -4038,1 +4571,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -4041,1 +4574,0 @@\n-                if (k == high) {\n@@ -4043,0 +4575,1 @@\n+                if (k == high) {\n@@ -4044,1 +4577,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -4049,11 +4582,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -4062,3 +4585,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -4066,0 +4587,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -4067,2 +4589,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -4073,2 +4595,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -4080,0 +4601,1 @@\n+            }\n@@ -4081,1 +4603,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -4083,5 +4608,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -4089,1 +4614,0 @@\n-            run[count] = (last = k);\n@@ -4093,1 +4617,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -4098,3 +4622,1 @@\n-            if (sorter == null || (b = (double[]) sorter.b) == null) {\n-                b = new double[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -4102,0 +4624,2 @@\n+            } else if ((b = tryAllocate(double[].class, high - low)) == null) {\n+                return false;\n@@ -4103,1 +4627,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -4111,0 +4635,1 @@\n+     * @param sorter the parallel context\n@@ -4112,1 +4637,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -4114,2 +4639,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -4119,1 +4643,0 @@\n-     * @return the destination where runs are merged\n@@ -4121,2 +4644,2 @@\n-    private static double[] mergeRuns(double[] a, double[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<double[]> sorter, double[] a, double[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -4125,2 +4648,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -4128,4 +4651,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -4135,1 +4655,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -4137,2 +4657,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -4141,1 +4661,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -4143,1 +4663,5 @@\n-        double[] a1, a2;\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n+\n+        double[] dst = aim ? a : b;\n+        double[] src = aim ? b : a;\n@@ -4145,4 +4669,11 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (double[]) merger.getDestination();\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -4150,2 +4681,1 @@\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -4153,0 +4683,57 @@\n+    }\n+\n+    \/**\n+     * Merges the sorted parts in parallel.\n+     *\n+     * @param merger the parallel context\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(Merger<double[]> merger, double[] dst, int k,\n+            double[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n+\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n+\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            double key = src[mi1];\n+\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n+                }\n+            }\n+\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -4154,1 +4741,4 @@\n-        double[] dst = a1 == a ? b : a;\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -4156,5 +4746,6 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n@@ -4162,2 +4753,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -4165,1 +4759,2 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n@@ -4167,1 +4762,0 @@\n-        return dst;\n@@ -4171,1 +4765,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts sequentially.\n@@ -4173,1 +4767,0 @@\n-     * @param merger parallel context\n@@ -4176,1 +4769,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -4179,1 +4772,0 @@\n-     * @param a2 the second part\n@@ -4183,2 +4775,2 @@\n-    private static void mergeParts(Merger merger, double[] dst, int k,\n-            double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {\n+    private static void mergeParts(double[] dst, int k,\n+            double[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -4186,1 +4778,3 @@\n-        if (merger != null && a1 == a2) {\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                double next = src[lo1];\n@@ -4188,1 +4782,10 @@\n-            while (true) {\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                double next = src[lo1];\n@@ -4190,6 +4793,2 @@\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n@@ -4197,0 +4796,7 @@\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                double next = src[lo1];\n@@ -4198,5 +4804,2 @@\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n@@ -4204,0 +4807,5 @@\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        }\n@@ -4205,6 +4813,6 @@\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                double key = a1[mi1];\n-                int mi2 = hi2;\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n@@ -4212,5 +4820,12 @@\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+    \/**\n+     * Tries to sort the specified range of the array\n+     * using LSD (The Least Significant Digit) Radix sort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryRadixSort(Sorter<double[]> sorter, double[] a, int low, int high) {\n+        double[] b; int offset = low, size = high - low;\n@@ -4218,6 +4833,8 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n+        \/*\n+         * Allocate additional buffer.\n+         *\/\n+        if (sorter != null && (b = sorter.b) != null) {\n+            offset = sorter.offset;\n+        } else if ((b = tryAllocate(double[].class, size)) == null) {\n+            return false;\n+        }\n@@ -4225,1 +4842,2 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+        int start = low - offset;\n+        int last = high - offset;\n@@ -4227,4 +4845,18 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+        \/*\n+         * Count the number of all digits.\n+         *\/\n+        int[] count1 = new int[1 << 10];\n+        int[] count2 = new int[1 << 11];\n+        int[] count3 = new int[1 << 11];\n+        int[] count4 = new int[1 << 11];\n+        int[] count5 = new int[1 << 11];\n+        int[] count6 = new int[1 << 10];\n+\n+        for (int i = low; i < high; ++i) {\n+            ++count1[(int)  (d2l(a[i])         & 0x3FF)];\n+            ++count2[(int) ((d2l(a[i]) >>> 10) & 0x7FF)];\n+            ++count3[(int) ((d2l(a[i]) >>> 21) & 0x7FF)];\n+            ++count4[(int) ((d2l(a[i]) >>> 32) & 0x7FF)];\n+            ++count5[(int) ((d2l(a[i]) >>> 43) & 0x7FF)];\n+            ++count6[(int) ((d2l(a[i]) >>> 54) & 0x3FF)];\n+        }\n@@ -4232,5 +4864,16 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+        \/*\n+         * Check digits to be processed.\n+         *\/\n+        boolean processDigit1 = processDigit(count1, size, low);\n+        boolean processDigit2 = processDigit(count2, size, low);\n+        boolean processDigit3 = processDigit(count3, size, low);\n+        boolean processDigit4 = processDigit(count4, size, low);\n+        boolean processDigit5 = processDigit(count5, size, low);\n+        boolean processDigit6 = processDigit(count6, size, low);\n+\n+        \/*\n+         * Process the 1-st digit.\n+         *\/\n+        if (processDigit1) {\n+            for (int i = high; i > low; ) {\n+                b[--count1[(int) (d2l(a[--i]) & 0x3FF)] - offset] = a[i];\n@@ -4241,1 +4884,1 @@\n-         * Merge small parts sequentially.\n+         * Process the 2-nd digit.\n@@ -4243,2 +4886,10 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        if (processDigit2) {\n+            if (processDigit1) {\n+                for (int i = last; i > start; ) {\n+                    a[--count2[(int) ((d2l(b[--i]) >>> 10) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count2[(int) ((d2l(a[--i]) >>> 10) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n@@ -4246,3 +4897,13 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n+\n+        \/*\n+         * Process the 3-rd digit.\n+         *\/\n+        if (processDigit3) {\n+            if (processDigit1 ^ processDigit2) {\n+                for (int i = last; i > start; ) {\n+                    a[--count3[(int) ((d2l(b[--i]) >>> 21) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count3[(int) ((d2l(a[--i]) >>> 21) & 0x7FF)] - offset] = a[i];\n+                }\n@@ -4251,3 +4912,107 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+\n+        \/*\n+         * Process the 4-th digit.\n+         *\/\n+        if (processDigit4) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3) {\n+                for (int i = last; i > start; ) {\n+                    a[--count4[(int) ((d2l(b[--i]) >>> 32) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count4[(int) ((d2l(a[--i]) >>> 32) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 5-th digit.\n+         *\/\n+        if (processDigit5) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4) {\n+                for (int i = last; i > start; ) {\n+                    a[--count5[(int) ((d2l(b[--i]) >>> 43) & 0x7FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count5[(int) ((d2l(a[--i]) >>> 43) & 0x7FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Process the 6-th digit.\n+         *\/\n+        if (processDigit6) {\n+            if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5) {\n+                for (int i = last; i > start; ) {\n+                    a[--count6[(int) ((d2l(b[--i]) >>> 54) & 0x3FF)]] = b[i];\n+                }\n+            } else {\n+                for (int i = high; i > low; ) {\n+                    b[--count6[(int) ((d2l(a[--i]) >>> 54) & 0x3FF)] - offset] = a[i];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the buffer to original array, if we process ood number of digits.\n+         *\/\n+        if (processDigit1 ^ processDigit2 ^ processDigit3 ^ processDigit4 ^ processDigit5 ^ processDigit6) {\n+            System.arraycopy(b, low - offset, a, low, size);\n+        }\n+        return true;\n+    }\n+\n+    private static final long SIGN_64_BIT = 1L << 63;\n+\n+    \/**\n+     * Returns the masked bits of double value.\n+     *\n+     * @param d the given double value\n+     * @return masked bits\n+     *\/\n+    private static long d2l(double d) {\n+        long x = Double.doubleToRawLongBits(d);\n+        return x < 0 ? ~x : x | SIGN_64_BIT;\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(double[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            double max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -4256,0 +5021,1 @@\n+        a[p] = value;\n@@ -4258,1 +5024,1 @@\n-\/\/ [class]\n+\/\/ #[class]\n@@ -4261,1 +5027,1 @@\n-     * This class implements parallel sorting.\n+     * Implementation of parallel sorting.\n@@ -4263,2 +5029,4 @@\n-    private static final class Sorter extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\n+\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4266,1 +5034,1 @@\n-        private final Object a, b;\n+        private final T a, b;\n@@ -4269,0 +5037,10 @@\n+        @SuppressWarnings(\"unchecked\")\n+        private Sorter(T a, int parallelism, int low, int size) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+            this.b = (T) tryAllocate(a.getClass(), size);\n+            this.depth = b == null ? 0 : ((parallelism >> 7) + 2) * (-2);\n+        }\n+\n@@ -4270,1 +5048,1 @@\n-                Object a, Object b, int low, int size, int offset, int depth) {\n+                T a, T b, int low, int size, int offset, int depth) {\n@@ -4281,1 +5059,2 @@\n-        public final void compute() {\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n@@ -4285,2 +5064,2 @@\n-                new Sorter(this, b, a, low, half, offset, depth + 1).fork();\n-                new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\n@@ -4288,11 +5067,6 @@\n-                if (a instanceof int[]) {\n-                    sort(this, (int[]) a, depth, low, low + size);\n-                } else if (a instanceof long[]) {\n-                    sort(this, (long[]) a, depth, low, low + size);\n-                } else if (a instanceof float[]) {\n-                    sort(this, (float[]) a, depth, low, low + size);\n-                } else if (a instanceof double[]) {\n-                    sort(this, (double[]) a, depth, low, low + size);\n-                } else {\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n+                switch(a) {\n+                    case int[] ai -> sort((Sorter<int[]>) this, ai, depth, low, low + size);\n+                    case long[] al -> sort((Sorter<long[]>) this, al, depth, low, low + size);\n+                    case float[] af -> sort((Sorter<float[]>) this, af, depth, low, low + size);\n+                    case double[] ad -> sort((Sorter<double[]>) this, ad, depth, low, low + size);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4305,1 +5079,1 @@\n-        public final void onCompletion(CountedCompleter<?> caller) {\n+        public void onCompletion(CountedCompleter<?> caller) {\n@@ -4310,1 +5084,1 @@\n-                new Merger(null,\n+                new Merger<>(null,\n@@ -4316,1 +5090,0 @@\n-                    b,\n@@ -4323,1 +5096,1 @@\n-        private void forkSorter(int depth, int low, int high) {\n+        private void fork(int depth, int low, int high) {\n@@ -4325,2 +5098,1 @@\n-            Object a = this.a; \/\/ Use local variable for performance\n-            new Sorter(this, a, b, low, high - low, offset, depth).fork();\n+            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n@@ -4331,1 +5103,1 @@\n-     * This class implements parallel merging.\n+     * Implementation of parallel merging.\n@@ -4333,2 +5105,4 @@\n-    private static final class Merger extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n+    private static final class Merger<T> extends CountedCompleter<Void> {\n+\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4336,1 +5110,1 @@\n-        private final Object dst, a1, a2;\n+        private final T dst, src;\n@@ -4339,2 +5113,2 @@\n-        private Merger(CountedCompleter<?> parent, Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\n+                T src, int lo1, int hi1, int lo2, int hi2) {\n@@ -4344,1 +5118,1 @@\n-            this.a1 = a1;\n+            this.src = src;\n@@ -4347,1 +5121,0 @@\n-            this.a2 = a2;\n@@ -4353,16 +5126,8 @@\n-        public final void compute() {\n-            if (dst instanceof int[]) {\n-                mergeParts(this, (int[]) dst, k,\n-                    (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);\n-            } else if (dst instanceof long[]) {\n-                mergeParts(this, (long[]) dst, k,\n-                    (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);\n-            } else if (dst instanceof float[]) {\n-                mergeParts(this, (float[]) dst, k,\n-                    (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);\n-            } else if (dst instanceof double[]) {\n-                mergeParts(this, (double[]) dst, k,\n-                    (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);\n-            } else {\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            switch(dst) {\n+                case int[] di -> mergeParts((Merger<int[]>) this, di, k, (int[]) src, lo1, hi1, lo2, hi2);\n+                case long[] dl -> mergeParts((Merger<long[]>) this, dl, k, (long[]) src, lo1, hi1, lo2, hi2);\n+                case float[] df -> mergeParts((Merger<float[]>) this, df, k, (float[]) src, lo1, hi1, lo2, hi2);\n+                case double[] dd -> mergeParts((Merger<double[]>) this, dd, k, (double[]) src, lo1, hi1, lo2, hi2);\n+                default -> throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n@@ -4373,2 +5138,1 @@\n-        private void forkMerger(Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\n@@ -4376,1 +5140,1 @@\n-            new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();\n+            new Merger<>(this, dst, k, src, lo1, hi1, lo2, hi2).fork();\n@@ -4381,1 +5145,7 @@\n-     * This class implements parallel merging of runs.\n+     * Tries to allocate additional buffer.\n+     *\n+     * @param <T> the class of array\n+     * @param clazz the given array class\n+     * @param length the length of additional buffer\n+     * @return {@code null} if requested buffer is too big or there is no enough memory,\n+     *         otherwise created buffer\n@@ -4383,44 +5153,9 @@\n-    private static final class RunMerger extends RecursiveTask<Object> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int[] run;\n-        private final int offset, aim, lo, hi;\n-\n-        private RunMerger(Object a, Object b, int offset,\n-                int aim, int[] run, int lo, int hi) {\n-            this.a = a;\n-            this.b = b;\n-            this.offset = offset;\n-            this.aim = aim;\n-            this.run = run;\n-            this.lo = lo;\n-            this.hi = hi;\n-        }\n-\n-        @Override\n-        protected final Object compute() {\n-            if (a instanceof int[]) {\n-                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof long[]) {\n-                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof float[]) {\n-                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof double[]) {\n-                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n-        }\n-\n-        private RunMerger forkMe() {\n-            fork();\n-            return this;\n-        }\n-\n-        private Object getDestination() {\n-            join();\n-            return getRawResult();\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T tryAllocate(Class<T> clazz, int length) {\n+        try {\n+            int maxLength = MAX_BUFFER_SIZE >>\n+                (clazz == int[].class || clazz == float[].class ? 2 : 3);\n+            return length > maxLength ? null :\n+                (T) U.allocateUninitializedArray(clazz.componentType(), length);\n+        } catch (OutOfMemoryError e) {\n+            return null;\n@@ -4429,0 +5164,2 @@\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":3211,"deletions":2474,"binary":false,"changes":5685,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n@@ -39,1 +39,1 @@\n-import java.util.Comparator;\n+import java.util.Arrays;\n@@ -48,3 +48,3 @@\n-    \/\/ Array lengths used in a long run (default)\n-    private static final int[] LONG_RUN_LENGTHS = {\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n+    \/\/ Lengths of arrays for [mixed] insertion sort\n+    private static final int[] RUN_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000 };\n@@ -52,3 +52,3 @@\n-    \/\/ Array lengths used in a short run\n-    private static final int[] SHORT_RUN_LENGTHS = {\n-        1, 8, 55, 100, 10_000 };\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000, 11_000 };\n@@ -56,3 +56,3 @@\n-    \/\/ Random initial values used in a long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS = {\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000, 11_000, 50_000};\n@@ -60,3 +60,3 @@\n-    \/\/ Random initial values used in a short run\n-    private static final TestRandom[] SHORT_RUN_RANDOMS = {\n-        TestRandom.C0FFEE };\n+    \/\/ Initial random values for short run\n+    private static final TestRandom[] SHORT_RANDOMS =\n+        {TestRandom.C0FFEE};\n@@ -64,1 +64,5 @@\n-    \/\/ Constants used in subarray sorting\n+    \/\/ Initial random values for long run (default)\n+    private static final TestRandom[] LONG_RANDOMS =\n+        {TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE};\n+\n+    \/\/ Constant to fill the left part of array\n@@ -66,0 +70,2 @@\n+\n+    \/\/ Constant to fill the right part of array\n@@ -71,0 +77,1 @@\n+    private final boolean withMin;\n@@ -78,2 +85,10 @@\n-        int[] lengths = shortRun ? SHORT_RUN_LENGTHS : LONG_RUN_LENGTHS;\n-        TestRandom[] randoms = shortRun ? SHORT_RUN_RANDOMS : LONG_RUN_RANDOMS;\n+        int[] lengths = shortRun ? SHORT_LENGTHS : LONG_LENGTHS;\n+        TestRandom[] randoms = shortRun ? SHORT_RANDOMS : LONG_RANDOMS;\n+\n+        new Sorting(SortingHelper.INSERTION_SORT, randoms, false).testBase();\n+        new Sorting(SortingHelper.MIXED_INSERTION_SORT, randoms, true).testBase();\n+        new Sorting(SortingHelper.MERGING_SORT, randoms, lengths).testStructured();\n+\n+        new Sorting(SortingHelper.RADIX_SORT, randoms, lengths).testBase();\n+        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBase();\n+        new Sorting(SortingHelper.COUNTING_SORT, randoms, lengths).testBase();\n@@ -82,2 +97,2 @@\n-        new Sorting(SortingHelper.PARALLEL_SORT, randoms, lengths).testCore();\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBasic();\n+        new Sorting(SortingHelper.PARALLEL_QUICKSORT, randoms, lengths).testCore();\n+\n@@ -88,1 +103,5 @@\n-        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1000);\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, boolean withMin) {\n+        this(sortingHelper, randoms, RUN_LENGTHS, withMin);\n@@ -92,0 +111,4 @@\n+        this(sortingHelper, randoms, lengths, false);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths, boolean withMin) {\n@@ -95,0 +118,1 @@\n+        this.withMin = withMin;\n@@ -97,1 +121,1 @@\n-    private void testBasic() {\n+    private void testBase() {\n@@ -101,4 +125,2 @@\n-            createData(length);\n-            testBasic(length);\n-        }\n-    }\n+            createArray(length);\n+            testStructured(length);\n@@ -106,5 +128,5 @@\n-    private void testBasic(int length) {\n-        for (TestRandom random : randoms) {\n-            testWithInsertionSort(length, random);\n-            testWithCheckSum(length, random);\n-            testWithScrambling(length, random);\n+            for (TestRandom random : randoms) {\n+                testWithCheckSum(length, random);\n+                testWithInsertionSort(length, random);\n+                testWithScrambling(length, random);\n+            }\n@@ -115,8 +137,1 @@\n-        for (int length : lengths) {\n-            createData(length);\n-            testCore(length);\n-        }\n-    }\n-\n-    private void testCore(int length) {\n-        testBasic(length);\n+        testBase();\n@@ -124,9 +139,0 @@\n-        for (TestRandom random : randoms) {\n-            testMergingSort(length, random);\n-            testSubArray(length, random);\n-            testNegativeZero(length, random);\n-            testFloatingPointSorting(length, random);\n-        }\n-    }\n-\n-    private void testAll() {\n@@ -134,36 +140,1 @@\n-            createData(length);\n-            testAll(length);\n-        }\n-    }\n-\n-    private void testAll(int length) {\n-        testCore(length);\n-\n-        for (TestRandom random : randoms) {\n-            testRange(length, random);\n-            testStability(length, random);\n-        }\n-    }\n-\n-    private void testEmptyArray() {\n-        testEmptyAndNullIntArray();\n-        testEmptyAndNullLongArray();\n-        testEmptyAndNullByteArray();\n-        testEmptyAndNullCharArray();\n-        testEmptyAndNullShortArray();\n-        testEmptyAndNullFloatArray();\n-        testEmptyAndNullDoubleArray();\n-    }\n-\n-    private void testStability(int length, TestRandom random) {\n-        printTestName(\"Test stability\", random, length);\n-\n-        Pair[] a = build(length, random);\n-        sortingHelper.sort(a);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        a = build(length, random);\n-        sortingHelper.sort(a, pairComparator);\n-        checkSorted(a);\n-        checkStable(a);\n+            createArray(length);\n@@ -171,32 +142,3 @@\n-        out.println();\n-    }\n-\n-    private void testEmptyAndNullIntArray() {\n-        sortingHelper.sort(new int[] {});\n-        sortingHelper.sort(new int[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(int[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(int[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullLongArray() {\n-        sortingHelper.sort(new long[] {});\n-        sortingHelper.sort(new long[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n+            for (TestRandom random : randoms) {\n+                testNegativeZero(length, random);\n+                testFloatingPointSorting(length, random);\n@@ -204,2 +146,0 @@\n-            fail(sortingHelper + \"(long[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n@@ -207,1 +147,0 @@\n-        fail(sortingHelper + \"(long[]) shouldn't catch null array\");\n@@ -210,3 +149,2 @@\n-    private void testEmptyAndNullByteArray() {\n-        sortingHelper.sort(new byte[] {});\n-        sortingHelper.sort(new byte[] {}, 0, 0);\n+    private void testAll() {\n+        testCore();\n@@ -214,10 +152,3 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(byte[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n+        for (int length : lengths) {\n+            createArray(length);\n+            sortRange(length);\n@@ -225,1 +156,0 @@\n-        fail(sortingHelper + \"(byte[]) shouldn't catch null array\");\n@@ -228,17 +158,3 @@\n-    private void testEmptyAndNullCharArray() {\n-        sortingHelper.sort(new char[] {});\n-        sortingHelper.sort(new char[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(char[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(char[]) shouldn't catch null array\");\n-    }\n+    private void testEmptyArray() {\n+        sortingHelper.sort(new int[]{});\n+        sortingHelper.sort(new int[]{}, 0, 0);\n@@ -246,3 +162,2 @@\n-    private void testEmptyAndNullShortArray() {\n-        sortingHelper.sort(new short[] {});\n-        sortingHelper.sort(new short[] {}, 0, 0);\n+        sortingHelper.sort(new long[]{});\n+        sortingHelper.sort(new long[]{}, 0, 0);\n@@ -250,13 +165,2 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(short[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(short[]) shouldn't catch null array\");\n-    }\n+        sortingHelper.sort(new byte[]{});\n+        sortingHelper.sort(new byte[]{}, 0, 0);\n@@ -264,3 +168,2 @@\n-    private void testEmptyAndNullFloatArray() {\n-        sortingHelper.sort(new float[] {});\n-        sortingHelper.sort(new float[] {}, 0, 0);\n+        sortingHelper.sort(new char[]{});\n+        sortingHelper.sort(new char[]{}, 0, 0);\n@@ -268,13 +171,2 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(float[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(float[]) shouldn't catch null array\");\n-    }\n+        sortingHelper.sort(new short[]{});\n+        sortingHelper.sort(new short[]{}, 0, 0);\n@@ -282,3 +174,2 @@\n-    private void testEmptyAndNullDoubleArray() {\n-        sortingHelper.sort(new double[] {});\n-        sortingHelper.sort(new double[] {}, 0, 0);\n+        sortingHelper.sort(new float[]{});\n+        sortingHelper.sort(new float[]{}, 0, 0);\n@@ -286,12 +177,2 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(double[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(double[]) shouldn't catch null array\");\n+        sortingHelper.sort(new double[]{});\n+        sortingHelper.sort(new double[]{}, 0, 0);\n@@ -300,20 +181,2 @@\n-    private void testSubArray(int length, TestRandom random) {\n-        if (length < 4) {\n-            return;\n-        }\n-        for (int m = 1; m < length \/ 2; m <<= 1) {\n-            int fromIndex = m;\n-            int toIndex = length - m;\n-\n-            prepareSubArray((int[]) gold[0], fromIndex, toIndex);\n-            convertData(length);\n-\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test subarray\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                sortingHelper.sort(test[i], fromIndex, toIndex);\n-                checkSubArray(test[i], fromIndex, toIndex);\n-            }\n-        }\n-        out.println();\n-    }\n+    private void sortRange(int length) {\n+        int[] a = (int[]) gold[0];\n@@ -321,4 +184,0 @@\n-    private void testRange(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n@@ -326,2 +185,2 @@\n-            for (int i = 1; i <= length; i++) {\n-                ((int[]) gold[0]) [i - 1] = i % m + m % i;\n+            for (int i = 1; i <= length; ++i) {\n+                a[i - 1] = i % m + m % i;\n@@ -329,1 +188,1 @@\n-            convertData(length);\n+            convertArray(m \/ 4);\n@@ -331,4 +190,4 @@\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test range check\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                checkRange(test[i], m);\n+            for (int i = 0; i < test.length; ++i) {\n+                printTestName(\"Test range check\", length,\n+                        \", m = \" + m + \", \" + getType(i));\n+                sortRange(test[i], m);\n@@ -340,45 +199,0 @@\n-    private void checkSorted(Pair[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i].getKey() > a[i + 1].getKey()) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" +\n-                    a[i].getKey() + \" and \" + a[i + 1].getKey());\n-            }\n-        }\n-    }\n-\n-    private void checkStable(Pair[] a) {\n-        for (int i = 0; i < a.length \/ 4; ) {\n-            int key1 = a[i].getKey();\n-            int value1 = a[i++].getValue();\n-            int key2 = a[i].getKey();\n-            int value2 = a[i++].getValue();\n-            int key3 = a[i].getKey();\n-            int value3 = a[i++].getValue();\n-            int key4 = a[i].getKey();\n-            int value4 = a[i++].getValue();\n-\n-            if (!(key1 == key2 && key2 == key3 && key3 == key4)) {\n-                fail(\"Keys are different \" + key1 + \", \" + key2 + \", \" +\n-                    key3 + \", \" + key4 + \" at position \" + i);\n-            }\n-            if (!(value1 < value2 && value2 < value3 && value3 < value4)) {\n-                fail(\"Sorting is not stable at position \" + i +\n-                    \". Second values have been changed: \" + value1 + \", \" +\n-                    value2 + \", \" + value3 + \", \" + value4);\n-            }\n-        }\n-    }\n-\n-    private Pair[] build(int length, Random random) {\n-        Pair[] a = new Pair[length * 4];\n-\n-        for (int i = 0; i < a.length; ) {\n-            int key = random.nextInt();\n-            a[i++] = new Pair(key, 1);\n-            a[i++] = new Pair(key, 2);\n-            a[i++] = new Pair(key, 3);\n-            a[i++] = new Pair(key, 4);\n-        }\n-        return a;\n-    }\n-\n@@ -386,1 +200,1 @@\n-        if (length > 1000) {\n+        if (length > 1_000) {\n@@ -389,0 +203,2 @@\n+        int[] a = (int[]) gold[0];\n+\n@@ -391,2 +207,3 @@\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n+                builder.build(a, m, random);\n+                int shift = m \/ 4;\n+                convertArray(shift);\n@@ -394,1 +211,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -396,3 +213,4 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    sortByInsertionSort(gold[i]);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                    sortingHelper.sort(test[i], shift, length - shift);\n+                    sortByInsertionSort(gold[i], shift, length - shift);\n+                    checkSorted(gold[i], shift);\n@@ -406,2 +224,9 @@\n-    private void testMergingSort(int length, TestRandom random) {\n-        if (length < (4 << 10)) { \/\/ DualPivotQuicksort.MIN_TRY_MERGE_SIZE\n+    private void testStructured() {\n+        for (int length : lengths) {\n+            createArray(length);\n+            testStructured(length);\n+        }\n+    }\n+\n+    private void testStructured(int length) {\n+        if (length < 512) {\n@@ -410,1 +235,1 @@\n-        final int PERIOD = 50;\n+        int[] a = (int[]) gold[0];\n@@ -412,4 +237,4 @@\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; m++) {\n-            for (MergingBuilder builder : MergingBuilder.values()) {\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n+        for (int m = 1; m < 8; ++m) {\n+            for (StructuredBuilder builder : StructuredBuilder.values()) {\n+                builder.build(a, m);\n+                convertArray(0);\n@@ -417,5 +242,5 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test merging sort\", random, length,\n-                        \", m = \" + m + \", \" +  getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkSorted(test[i]);\n+                for (int i = 0; i < test.length; ++i) {\n+                    printTestName(\"Test structured\", length,\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                    sortingHelper.sort(test[i]\/*, shift, length - shift*\/);\n+                    checkSorted(test[i], 0);\n@@ -429,0 +254,2 @@\n+        int[] a = (int[]) gold[0];\n+\n@@ -431,2 +258,3 @@\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n+                builder.build(a, m, random);\n+                int shift = m \/ 4;\n+                convertArray(shift);\n@@ -434,1 +262,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -436,3 +264,3 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkWithCheckSum(test[i], gold[i]);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                    sortingHelper.sort(test[i], shift, length - shift);\n+                    checkWithCheckSum(test[i], gold[i], shift);\n@@ -446,0 +274,2 @@\n+        int[] a = (int[]) gold[0];\n+\n@@ -448,2 +278,2 @@\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n+                builder.build(a, m);\n+                convertArray(0);\n@@ -451,1 +281,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -453,1 +283,1 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n@@ -464,1 +294,1 @@\n-        for (int i = 5; i < test.length; i++) {\n+        for (int i = 5; i < test.length; ++i) {\n@@ -467,1 +297,1 @@\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values() [i - 5];\n+            NegativeZeroBuilder builder = NegativeZeroBuilder.values()[i - 5];\n@@ -477,1 +307,1 @@\n-        if (length < 2) {\n+        if (length < 6) {\n@@ -480,1 +310,2 @@\n-        final int MAX = 13;\n+        final int MAX = 14;\n+        int s = 4;\n@@ -482,6 +313,6 @@\n-        for (int a = 0; a < MAX; a++) {\n-            for (int g = 0; g < MAX; g++) {\n-                for (int z = 0; z < MAX; z++) {\n-                    for (int n = 0; n < MAX; n++) {\n-                        for (int p = 0; p < MAX; p++) {\n-                            if (a + g + z + n + p != length) {\n+        for (int k = 0; k < MAX; ++k) {\n+            for (int g = 0; g < MAX; ++g) {\n+                for (int z = 0; z < MAX; ++z) {\n+                    for (int n = 0; n < MAX; ++n) {\n+                        for (int p = 0; p < MAX; ++p) {\n+                            if (k + g + z + n + p + s != length) {\n@@ -490,1 +321,1 @@\n-                            for (int i = 5; i < test.length; i++) {\n+                            for (int i = 5; i < test.length; ++i) {\n@@ -492,2 +323,2 @@\n-                                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n+                                        \", k = \" + k + \", g = \" + g + \", z = \" + z +\n+                                                \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n@@ -495,1 +326,1 @@\n-                                builder.build(gold[i], a, g, z, n, p, random);\n+                                builder.build(gold[i], k, g, z, n, p, random);\n@@ -499,1 +330,1 @@\n-                                compare(test[i], gold[i], a, n, g);\n+                                compare(test[i], gold[i], k, n + 2, g);\n@@ -507,4 +338,3 @@\n-        for (int m = 13; m > 4; m--) {\n-            int t = length \/ m;\n-            int g = t, z = t, n = t, p = t;\n-            int a = length - g - z - n - p;\n+        for (int m = MAX; m > 4; --m) {\n+            int g = length \/ m;\n+            int k = length - g - g - g - g - s;\n@@ -512,1 +342,1 @@\n-            for (int i = 5; i < test.length; i++) {\n+            for (int i = 5; i < test.length; ++i) {\n@@ -514,4 +344,4 @@\n-                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                FloatingPointBuilder builder = FloatingPointBuilder.values() [i - 5];\n-                builder.build(gold[i], a, g, z, n, p, random);\n+                        \", k = \" + k + \", g = \" + g + \", z = \" + g +\n+                                \", n = \" + g + \", p = \" + g + \", \" + getType(i));\n+                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n+                builder.build(gold[i], k, g, g, g, g, random);\n@@ -521,1 +351,1 @@\n-                compare(test[i], gold[i], a, n, g);\n+                compare(test[i], gold[i], k, g + 2, g);\n@@ -527,20 +357,0 @@\n-    private void prepareSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            a[i] = A380;\n-        }\n-        int middle = (fromIndex + toIndex) >>> 1;\n-        int k = 0;\n-\n-        for (int i = fromIndex; i < middle; i++) {\n-            a[i] = k++;\n-        }\n-\n-        for (int i = middle; i < toIndex; i++) {\n-            a[i] = k--;\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            a[i] = B747;\n-        }\n-    }\n-\n@@ -548,16 +358,9 @@\n-        if (a instanceof int[]) {\n-            scramble((int[]) a, random);\n-        } else if (a instanceof long[]) {\n-            scramble((long[]) a, random);\n-        } else if (a instanceof byte[]) {\n-            scramble((byte[]) a, random);\n-        } else if (a instanceof char[]) {\n-            scramble((char[]) a, random);\n-        } else if (a instanceof short[]) {\n-            scramble((short[]) a, random);\n-        } else if (a instanceof float[]) {\n-            scramble((float[]) a, random);\n-        } else if (a instanceof double[]) {\n-            scramble((double[]) a, random);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case int[] ai -> scramble(ai, random);\n+            case long[] al -> scramble(al, random);\n+            case byte[] ab -> scramble(ab, random);\n+            case char[] ac -> scramble(ac, random);\n+            case short[] as -> scramble(as, random);\n+            case float[] af -> scramble(af, random);\n+            case double[] ad -> scramble(ad, random);\n+            default -> fail(a);\n@@ -568,2 +371,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 0; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -574,2 +383,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -580,2 +395,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -586,2 +407,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -592,2 +419,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -598,2 +431,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -604,2 +443,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -610,1 +455,3 @@\n-        int t = a[i]; a[i] = a[j]; a[j] = t;\n+        int t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -614,1 +461,3 @@\n-        long t = a[i]; a[i] = a[j]; a[j] = t;\n+        long t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -618,1 +467,3 @@\n-        byte t = a[i]; a[i] = a[j]; a[j] = t;\n+        byte t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -622,1 +473,3 @@\n-        char t = a[i]; a[i] = a[j]; a[j] = t;\n+        char t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -626,1 +479,3 @@\n-        short t = a[i]; a[i] = a[j]; a[j] = t;\n+        short t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -630,1 +485,3 @@\n-        float t = a[i]; a[i] = a[j]; a[j] = t;\n+        float t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -634,1 +491,3 @@\n-        double t = a[i]; a[i] = a[j]; a[j] = t;\n+        double t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -637,2 +496,2 @@\n-    private void checkWithCheckSum(Object test, Object gold) {\n-        checkSorted(test);\n+    private void checkWithCheckSum(Object test, Object gold, int m) {\n+        checkSorted(test, m);\n@@ -642,5 +501,0 @@\n-    private void fail(String message) {\n-        err.format(\"\\n*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n-        throw new RuntimeException(\"Test failed\");\n-    }\n-\n@@ -648,6 +502,4 @@\n-        if (a instanceof float[]) {\n-            checkNegativeZero((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkNegativeZero((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case float[] af -> checkNegativeZero(af);\n+            case double[] ad -> checkNegativeZero(ad);\n+            default -> fail(a);\n@@ -658,1 +510,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -666,1 +518,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -674,6 +526,4 @@\n-        if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b, numNaN, numNeg, numNegZero);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b, numNaN, numNeg, numNegZero);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case float[] af -> compare(af, (float[]) b, numNaN, numNeg, numNegZero);\n+            case double[] ad -> compare(ad, (double[]) b, numNaN, numNeg, numNegZero);\n+            default -> fail(a);\n@@ -684,2 +534,2 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n+            if (!Float.isNaN(a[i])) {\n@@ -691,2 +541,2 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Float.floatToIntBits(a[i])) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n+            if (Float.floatToIntBits(a[i]) != NEGATIVE_ZERO) {\n@@ -697,1 +547,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -705,2 +555,2 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n+            if (!Double.isNaN(a[i])) {\n@@ -712,2 +562,2 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Double.doubleToLongBits(a[i])) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n+            if (Double.doubleToLongBits(a[i]) != NEGATIVE_ZERO) {\n@@ -718,1 +568,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -726,16 +576,9 @@\n-        if (a instanceof int[]) {\n-            compare((int[]) a, (int[]) b);\n-        } else if (a instanceof long[]) {\n-            compare((long[]) a, (long[]) b);\n-        } else if (a instanceof byte[]) {\n-            compare((byte[]) a, (byte[]) b);\n-        } else if (a instanceof char[]) {\n-            compare((char[]) a, (char[]) b);\n-        } else if (a instanceof short[]) {\n-            compare((short[]) a, (short[]) b);\n-        } else if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case int[] ai -> compare(ai, (int[]) b);\n+            case long[] al -> compare(al, (long[]) b);\n+            case byte[] ab -> compare(ab, (byte[]) b);\n+            case char[] ac -> compare(ac, (char[]) b);\n+            case short[] as -> compare(as, (short[]) b);\n+            case float[] af -> compare(af, (float[]) b);\n+            case double[] ad -> compare(ad, (double[]) b);\n+            default -> fail(a);\n@@ -746,1 +589,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -754,1 +597,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -762,1 +605,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -770,1 +613,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -778,1 +621,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -786,1 +629,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -794,1 +637,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -804,23 +647,10 @@\n-        if (a instanceof int[]) {\n-            return \"INT   \";\n-        }\n-        if (a instanceof long[]) {\n-            return \"LONG  \";\n-        }\n-        if (a instanceof byte[]) {\n-            return \"BYTE  \";\n-        }\n-        if (a instanceof char[]) {\n-            return \"CHAR  \";\n-        }\n-        if (a instanceof short[]) {\n-            return \"SHORT \";\n-        }\n-        if (a instanceof float[]) {\n-            return \"FLOAT \";\n-        }\n-        if (a instanceof double[]) {\n-            return \"DOUBLE\";\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return null;\n+        return switch (a) {\n+            case int[] _ -> \"INT   \";\n+            case long[] _ -> \"LONG  \";\n+            case byte[] _ -> \"BYTE  \";\n+            case char[] _ -> \"CHAR  \";\n+            case short[] _ -> \"SHORT \";\n+            case float[] _ -> \"FLOAT \";\n+            case double[] _ -> \"DOUBLE\";\n+            default -> null;\n+        };\n@@ -829,17 +659,10 @@\n-    private void checkSorted(Object a) {\n-        if (a instanceof int[]) {\n-            checkSorted((int[]) a);\n-        } else if (a instanceof long[]) {\n-            checkSorted((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            checkSorted((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            checkSorted((char[]) a);\n-        } else if (a instanceof short[]) {\n-            checkSorted((short[]) a);\n-        } else if (a instanceof float[]) {\n-            checkSorted((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkSorted((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+    private void checkSorted(Object a, int m) {\n+        switch (a) {\n+            case int[] ai -> checkSorted(ai, m);\n+            case long[] al -> checkSorted(al, m);\n+            case byte[] ab -> checkSorted(ab, m);\n+            case char[] ac -> checkSorted(ac, m);\n+            case short[] as -> checkSorted(as, m);\n+            case float[] af -> checkSorted(af, m);\n+            case double[] ad -> checkSorted(ad, m);\n+            default -> fail(a);\n@@ -849,2 +672,7 @@\n-    private void checkSorted(int[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(int[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -855,0 +683,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -857,2 +690,7 @@\n-    private void checkSorted(long[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(long[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != toLong(A380)) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -863,0 +701,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != toLong(B747)) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -865,2 +708,7 @@\n-    private void checkSorted(byte[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(byte[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (byte) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -871,0 +719,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (byte) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -873,2 +726,7 @@\n-    private void checkSorted(char[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(char[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (char) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -879,0 +737,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (char) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -881,2 +744,7 @@\n-    private void checkSorted(short[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(short[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (short) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -887,0 +755,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (short) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -889,2 +762,7 @@\n-    private void checkSorted(float[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(float[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (float) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex((long) a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -895,0 +773,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (float) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex((long) a[i], B747));\n+            }\n+        }\n@@ -897,2 +780,7 @@\n-    private void checkSorted(double[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(double[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != toDouble(A380)) {\n+                fail(\"Sort changes left element at position \" + i + hex((long) a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -903,0 +791,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != B747) {\n+                fail(\"Sort changes right element at position \" + i + hex((long) a[i], B747));\n+            }\n+        }\n@@ -915,23 +808,10 @@\n-        if (a instanceof int[]) {\n-            return checkSumXor((int[]) a);\n-        }\n-        if (a instanceof long[]) {\n-            return checkSumXor((long[]) a);\n-        }\n-        if (a instanceof byte[]) {\n-            return checkSumXor((byte[]) a);\n-        }\n-        if (a instanceof char[]) {\n-            return checkSumXor((char[]) a);\n-        }\n-        if (a instanceof short[]) {\n-            return checkSumXor((short[]) a);\n-        }\n-        if (a instanceof float[]) {\n-            return checkSumXor((float[]) a);\n-        }\n-        if (a instanceof double[]) {\n-            return checkSumXor((double[]) a);\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n+        return switch (a) {\n+            case int[] ai -> checkSumXor(ai);\n+            case long[] al -> checkSumXor(al);\n+            case byte[] ab -> checkSumXor(ab);\n+            case char[] ac -> checkSumXor(ac);\n+            case short[] as -> checkSumXor(as);\n+            case float[] af -> checkSumXor(af);\n+            case double[] ad -> checkSumXor(ad);\n+            default -> -1;\n+        };\n@@ -964,1 +844,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -973,1 +853,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -982,1 +862,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1004,23 +884,10 @@\n-        if (a instanceof int[]) {\n-            return checkSumPlus((int[]) a);\n-        }\n-        if (a instanceof long[]) {\n-            return checkSumPlus((long[]) a);\n-        }\n-        if (a instanceof byte[]) {\n-            return checkSumPlus((byte[]) a);\n-        }\n-        if (a instanceof char[]) {\n-            return checkSumPlus((char[]) a);\n-        }\n-        if (a instanceof short[]) {\n-            return checkSumPlus((short[]) a);\n-        }\n-        if (a instanceof float[]) {\n-            return checkSumPlus((float[]) a);\n-        }\n-        if (a instanceof double[]) {\n-            return checkSumPlus((double[]) a);\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n+        return switch (a) {\n+            case int[] ai -> checkSumPlus(ai);\n+            case long[] al -> checkSumPlus(al);\n+            case byte[] ab -> checkSumPlus(ab);\n+            case char[] ac -> checkSumPlus(ac);\n+            case short[] as -> checkSumPlus(as);\n+            case float[] af -> checkSumPlus(af);\n+            case double[] ad -> checkSumPlus(ad);\n+            default -> -1;\n+        };\n@@ -1053,1 +920,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1062,1 +929,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1071,1 +938,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1092,18 +959,2 @@\n-    private void sortByInsertionSort(Object a) {\n-        if (a instanceof int[]) {\n-            sortByInsertionSort((int[]) a);\n-        } else if (a instanceof long[]) {\n-            sortByInsertionSort((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            sortByInsertionSort((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            sortByInsertionSort((char[]) a);\n-        } else if (a instanceof short[]) {\n-            sortByInsertionSort((short[]) a);\n-        } else if (a instanceof float[]) {\n-            sortByInsertionSort((float[]) a);\n-        } else if (a instanceof double[]) {\n-            sortByInsertionSort((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n+    private void sortByInsertionSort(Object a, int low, int high) {\n+        SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -1112,8 +963,10 @@\n-    private void sortByInsertionSort(int[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            int ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n+    private void sortRange(Object a, int m) {\n+        switch (a) {\n+            case int[] ai -> sortRange(ai, m);\n+            case long[] al -> sortRange(al, m);\n+            case byte[] ab -> sortRange(ab, m);\n+            case char[] ac -> sortRange(ac, m);\n+            case short[] as -> sortRange(as, m);\n+            case float[] af -> sortRange(af, m);\n+            case double[] ad -> sortRange(ad, m);\n+            default -> fail(a);\n@@ -1123,6 +976,17 @@\n-    private void sortByInsertionSort(long[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            long ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+    private void sortRange(int[] a, int m) {\n+        try {\n+            sortingHelper.sort(a, m + 1, m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+        } catch (IllegalArgumentException iae) {\n+            try {\n+                sortingHelper.sort(a, -m, a.length);\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\n+                try {\n+                    sortingHelper.sort(a, 0, a.length + m);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1130,1 +994,0 @@\n-            a[j + 1] = ai;\n@@ -1134,6 +997,17 @@\n-    private void sortByInsertionSort(byte[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            byte ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+    private void sortRange(long[] a, int m) {\n+        try {\n+            sortingHelper.sort(a, m + 1, m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+        } catch (IllegalArgumentException iae) {\n+            try {\n+                sortingHelper.sort(a, -m, a.length);\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\n+                try {\n+                    sortingHelper.sort(a, 0, a.length + m);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1141,1 +1015,0 @@\n-            a[j + 1] = ai;\n@@ -1145,6 +1018,17 @@\n-    private void sortByInsertionSort(char[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            char ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+    private void sortRange(byte[] a, int m) {\n+        try {\n+            sortingHelper.sort(a, m + 1, m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+        } catch (IllegalArgumentException iae) {\n+            try {\n+                sortingHelper.sort(a, -m, a.length);\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\n+                try {\n+                    sortingHelper.sort(a, 0, a.length + m);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1152,1 +1036,0 @@\n-            a[j + 1] = ai;\n@@ -1156,214 +1039,1 @@\n-    private void sortByInsertionSort(short[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            short ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(float[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            float ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(double[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            double ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void checkSubArray(Object a, int fromIndex, int toIndex) {\n-        if (a instanceof int[]) {\n-            checkSubArray((int[]) a, fromIndex, toIndex);\n-        } else if (a instanceof long[]) {\n-            checkSubArray((long[]) a, fromIndex, toIndex);\n-        } else if (a instanceof byte[]) {\n-            checkSubArray((byte[]) a, fromIndex, toIndex);\n-        } else if (a instanceof char[]) {\n-            checkSubArray((char[]) a, fromIndex, toIndex);\n-        } else if (a instanceof short[]) {\n-            checkSubArray((short[]) a, fromIndex, toIndex);\n-        } else if (a instanceof float[]) {\n-            checkSubArray((float[]) a, fromIndex, toIndex);\n-        } else if (a instanceof double[]) {\n-            checkSubArray((double[]) a, fromIndex, toIndex);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(long[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (long) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (long) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(byte[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (byte) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (byte) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(char[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (char) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (char) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(short[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (short) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (short) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(float[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (float) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (float) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(double[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (double) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (double) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkRange(Object a, int m) {\n-        if (a instanceof int[]) {\n-            checkRange((int[]) a, m);\n-        } else if (a instanceof long[]) {\n-            checkRange((long[]) a, m);\n-        } else if (a instanceof byte[]) {\n-            checkRange((byte[]) a, m);\n-        } else if (a instanceof char[]) {\n-            checkRange((char[]) a, m);\n-        } else if (a instanceof short[]) {\n-            checkRange((short[]) a, m);\n-        } else if (a instanceof float[]) {\n-            checkRange((float[]) a, m);\n-        } else if (a instanceof double[]) {\n-            checkRange((double[]) a, m);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkRange(int[] a, int m) {\n+    private void sortRange(char[] a, int m) {\n@@ -1372,2 +1042,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1377,2 +1047,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1382,3 +1052,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1389,1 +1060,1 @@\n-    private void checkRange(long[] a, int m) {\n+    private void sortRange(short[] a, int m) {\n@@ -1392,2 +1063,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1397,2 +1068,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1402,3 +1073,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1409,1 +1081,1 @@\n-    private void checkRange(byte[] a, int m) {\n+    private void sortRange(float[] a, int m) {\n@@ -1412,2 +1084,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1417,2 +1089,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1422,3 +1094,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1429,1 +1102,1 @@\n-    private void checkRange(char[] a, int m) {\n+    private void sortRange(double[] a, int m) {\n@@ -1432,2 +1105,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1437,2 +1110,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1442,3 +1115,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1449,17 +1123,5 @@\n-    private void checkRange(short[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n+    private void copy(Object dst, Object src) {\n+        switch (src) {\n+            case float[] sf -> System.arraycopy(sf, 0, dst, 0, sf.length);\n+            case double[] sd -> System.arraycopy(sd, 0, dst, 0, sd.length);\n+            default -> fail(src);\n@@ -1469,19 +1131,6 @@\n-    private void checkRange(float[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n+    private void createArray(int length) {\n+        gold = new Object[]{\n+                new int[length], new long[length],\n+                new byte[length], new char[length], new short[length],\n+                new float[length], new double[length]\n+        };\n@@ -1489,18 +1138,5 @@\n-    private void checkRange(double[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n+        test = new Object[]{\n+                new int[length], new long[length],\n+                new byte[length], new char[length], new short[length],\n+                new float[length], new double[length]\n+        };\n@@ -1509,7 +1145,15 @@\n-    private void copy(Object dst, Object src) {\n-        if (src instanceof float[]) {\n-            copy((float[]) dst, (float[]) src);\n-        } else if (src instanceof double[]) {\n-            copy((double[]) dst, (double[]) src);\n-        } else {\n-            fail(\"Unknown type of array: \" + src.getClass().getName());\n+    private void convertArray(int m) {\n+        int[] a = (int[]) gold[0];\n+\n+        for (int i = 0; i < m; ++i) {\n+            a[i] = A380;\n+        }\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            a[i] = B747;\n+        }\n+        for (int i = 0; i < gold.length; ++i) {\n+            TypeConverter converter = TypeConverter.values()[i];\n+            converter.convert(a, gold[i], withMin, m);\n+        }\n+        for (int i = 0; i < gold.length; ++i) {\n+            System.arraycopy(gold[i], 0, test[i], 0, a.length);\n@@ -1519,2 +1163,2 @@\n-    private void copy(float[] dst, float[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n+    private String hex(long a, int b) {\n+        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\n@@ -1523,2 +1167,2 @@\n-    private void copy(double[] dst, double[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n+    private void printTestName(String test, int length, String message) {\n+        out.println(\"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n@@ -1527,2 +1171,3 @@\n-    private void printTestName(String test, TestRandom random, int length) {\n-        printTestName(test, random, length, \"\");\n+    private void printTestName(String test, TestRandom random, int length, String message) {\n+        out.println(\"[\" + sortingHelper + \"] '\" + test +\n+                \"' length = \" + length + \", random = \" + random + message);\n@@ -1531,12 +1176,2 @@\n-    private void createData(int length) {\n-        gold = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n-\n-        test = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n+    private void fail(Object a) {\n+        fail(\"Unknown type: \" + a.getClass().getName());\n@@ -1545,9 +1180,3 @@\n-    private void convertData(int length) {\n-        for (int i = 1; i < gold.length; i++) {\n-            TypeConverter converter = TypeConverter.values()[i - 1];\n-            converter.convert((int[])gold[0], gold[i]);\n-        }\n-\n-        for (int i = 0; i < gold.length; i++) {\n-            System.arraycopy(gold[i], 0, test[i], 0, length);\n-        }\n+    private void fail(String message) {\n+        err.format(\"*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n@@ -1556,2 +1185,2 @@\n-    private String hex(long a, int b) {\n-        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\n+    private static long toLong(int i) {\n+        return (((long) i) << 32) | i;\n@@ -1560,3 +1189,5 @@\n-    private void printTestName(String test, TestRandom random, int length, String message) {\n-        out.println( \"[\" + sortingHelper + \"] '\" + test +\n-            \"' length = \" + length + \", random = \" + random + message);\n+    private static double toDouble(int i) {\n+        long v = toLong(i);\n+        v = (v > 0) ? ~v : v & ~(1L << 63);\n+        double d = Double.longBitsToDouble(v);\n+        return Double.isNaN(d) ? 0.0d : d;\n@@ -1565,1 +1196,10 @@\n-    private static enum TypeConverter {\n+    private enum TypeConverter {\n+        INT {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n+                if (withMin) {\n+                    src[m] = Integer.MIN_VALUE;\n+                }\n+            }\n+        },\n+\n@@ -1567,1 +1207,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1570,2 +1211,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (long) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = toLong(src[i]);\n+                }\n+                if (withMin) {\n+                    b[m] = Long.MIN_VALUE;\n@@ -1577,1 +1221,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1580,1 +1225,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1583,0 +1228,3 @@\n+                if (withMin) {\n+                    b[m] = Byte.MIN_VALUE;\n+                }\n@@ -1587,1 +1235,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1590,1 +1239,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1593,0 +1242,3 @@\n+                if (withMin) {\n+                    b[m] = Character.MIN_VALUE;\n+                }\n@@ -1597,1 +1249,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1600,1 +1253,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1603,0 +1256,3 @@\n+                if (withMin) {\n+                    b[m] = Short.MIN_VALUE;\n+                }\n@@ -1607,1 +1263,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1610,2 +1267,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (float) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (withMin) {\n+                    b[m] = Float.NEGATIVE_INFINITY;\n@@ -1617,1 +1277,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1620,2 +1281,8 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (double) src[i];\n+                for (int i = 0; i < src.length \/ 2; ++i) {\n+                    b[i] = toDouble(src[i]);\n+                }\n+                for (int i = src.length \/ 2; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (withMin) {\n+                    b[m] = Double.NEGATIVE_INFINITY;\n@@ -1626,1 +1293,1 @@\n-        abstract void convert(int[] src, Object dst);\n+        abstract void convert(int[] src, Object dst, boolean withMin, int m);\n@@ -1629,1 +1296,1 @@\n-    private static enum SortedBuilder {\n+    private enum SortedBuilder {\n@@ -1631,0 +1298,1 @@\n+            @Override\n@@ -1632,1 +1300,1 @@\n-                for (int i = 0; i < m; i++) {\n+                for (int i = 0; i < m; ++i) {\n@@ -1636,1 +1304,1 @@\n-                for (int i = m; i < a.length; i++) {\n+                for (int i = m; i < a.length; ++i) {\n@@ -1645,1 +1313,1 @@\n-    private static enum UnsortedBuilder {\n+    private enum UnsortedBuilder {\n@@ -1647,0 +1315,1 @@\n+            @Override\n@@ -1648,1 +1317,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1654,1 +1323,2 @@\n-        ASCENDING {\n+        PERMUTATION {\n+            @Override\n@@ -1656,2 +1326,10 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m + i;\n+                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i & mask;\n+                }\n+                for (int i = a.length; i > 1; --i) {\n+                    int k = random.nextInt(i);\n+                    int t = a[i - 1];\n+                    a[i - 1] = a[k];\n+                    a[k] = t;\n@@ -1662,1 +1340,2 @@\n-        DESCENDING {\n+        UNIFORM {\n+            @Override\n@@ -1664,2 +1343,4 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = a.length - m - i;\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt() & mask;\n@@ -1670,1 +1351,2 @@\n-        EQUAL {\n+        STAGGER {\n+            @Override\n@@ -1672,2 +1354,2 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = (i * m + i) % a.length;\n@@ -1678,1 +1360,20 @@\n-        SAW {\n+        REPEATED {\n+            @Override\n+            void build(int[] a, int m, Random random) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i % m;\n+                }\n+            }\n+        },\n+\n+        DUPLICATED {\n+            @Override\n+            void build(int[] a, int m, Random random) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m);\n+                }\n+            }\n+        },\n+\n+        SAWTOOTH {\n+            @Override\n@@ -1686,1 +1387,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1694,1 +1395,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1705,9 +1406,2 @@\n-        REPEATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % m;\n-                }\n-            }\n-        },\n-\n-        DUPLICATED {\n+        SHUFFLE {\n+            @Override\n@@ -1715,2 +1409,2 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt(m);\n+                for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m) > 0 ? (j += 2) : (k += 2);\n@@ -1719,5 +1413,1 @@\n-        },\n-\n-        ORGAN_PIPES {\n-            void build(int[] a, int m, Random random) {\n-                int middle = a.length \/ (m + 1);\n+        };\n@@ -1725,3 +1415,2 @@\n-                for (int i = 0; i < middle; i++) {\n-                    a[i] = i;\n-                }\n+        abstract void build(int[] a, int m, Random random);\n+    }\n@@ -1729,2 +1418,6 @@\n-                for (int i = middle; i < a.length; i++) {\n-                    a[i] = a.length - i - 1;\n+    private enum StructuredBuilder {\n+        ASCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = m + i;\n@@ -1735,4 +1428,5 @@\n-        STAGGER {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = (i * m + i) % a.length;\n+        DESCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = a.length - m - i;\n@@ -1743,5 +1437,4 @@\n-        PLATEAU {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = Math.min(i, m);\n-                }\n+        EQUAL {\n+            @Override\n+            void build(int[] a, int m) {\n+                Arrays.fill(a, m);\n@@ -1751,6 +1444,5 @@\n-        SHUFFLE {\n-            void build(int[] a, int m, Random random) {\n-                int x = 0, y = 0;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n+        SHIFTED {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i << 10;\n@@ -1761,4 +1453,4 @@\n-        LATCH {\n-            void build(int[] a, int m, Random random) {\n-                int max = a.length \/ m;\n-                max = max < 2 ? 2 : max;\n+        ORGAN_PIPES {\n+            @Override\n+            void build(int[] a, int m) {\n+                int middle = a.length \/ (m + 1);\n@@ -1766,2 +1458,5 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % max;\n+                for (int i = 0; i < middle; ++i) {\n+                    a[i] = i;\n+                }\n+                for (int i = middle; i < a.length; ++i) {\n+                    a[i] = a.length - i - 1;\n@@ -1770,4 +1465,1 @@\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n-    }\n+        },\n@@ -1775,2 +1467,2 @@\n-    private static enum MergingBuilder {\n-        ASCENDING {\n+        PLATEAU {\n+            @Override\n@@ -1778,13 +1470,2 @@\n-                int period = a.length \/ m;\n-                int v = 1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = 1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v++;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v++;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = Math.min(i, m);\n@@ -1792,2 +1473,0 @@\n-\n-                a[a.length - 1] = 0;\n@@ -1797,1 +1476,2 @@\n-        DESCENDING {\n+        LATCH {\n+            @Override\n@@ -1799,10 +1479,1 @@\n-                int period = a.length \/ m;\n-                int v = -1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = -1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v--;\n-                    }\n-                }\n+                int max = Math.max(a.length \/ m, 2);\n@@ -1810,2 +1481,2 @@\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v--;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i % max;\n@@ -1813,2 +1484,0 @@\n-\n-                a[a.length - 1] = 0;\n@@ -1819,0 +1488,1 @@\n+            @Override\n@@ -1820,3 +1490,1 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = 0;\n-                }\n+                Arrays.fill(a, 0);\n@@ -1828,0 +1496,1 @@\n+            @Override\n@@ -1829,1 +1498,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1832,1 +1501,1 @@\n-                reverse(a, 0, a.length - 1);\n+                reverse(a, Math.max(0, a.length - m), a.length);\n@@ -1837,0 +1506,1 @@\n+            @Override\n@@ -1838,1 +1508,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1841,1 +1511,11 @@\n-                reverse(a, 0, 2);\n+                reverse(a, 0, Math.min(m, a.length));\n+            }\n+        },\n+\n+        TRAPEZIUM {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i;\n+                }\n+                reverse(a, m, a.length - m);\n@@ -1846,0 +1526,1 @@\n+            @Override\n@@ -1851,1 +1532,1 @@\n-                for (int i = 0, k = level; i < k1; i++) {\n+                for (int i = 0, k = level; i < k1; ++i) {\n@@ -1854,2 +1535,1 @@\n-\n-                for (int i = k1; i < k2; i++) {\n+                for (int i = k1; i < k2; ++i) {\n@@ -1858,2 +1538,1 @@\n-\n-                for (int i = k2, k = level; i < a.length; i++) {\n+                for (int i = k2, k = level; i < a.length; ++i) {\n@@ -1876,1 +1555,1 @@\n-    private static enum NegativeZeroBuilder {\n+    private enum NegativeZeroBuilder {\n@@ -1878,0 +1557,1 @@\n+            @Override\n@@ -1881,1 +1561,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1888,0 +1568,1 @@\n+            @Override\n@@ -1891,1 +1572,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1900,1 +1581,1 @@\n-    private static enum FloatingPointBuilder {\n+    private enum FloatingPointBuilder {\n@@ -1902,1 +1583,2 @@\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n+            @Override\n+            void build(Object o, int k, int g, int z, int n, int p, Random random) {\n@@ -1904,2 +1586,2 @@\n-                float positiveValue =  random.nextFloat();\n-                float[] x = (float[]) o;\n+                float positiveValue = random.nextFloat();\n+                float[] a = (float[]) o;\n@@ -1908,1 +1590,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(a, Float.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, -Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, negativeValue, fromIndex, n);\n@@ -1911,1 +1599,1 @@\n-                writeValue(x, -0.0f, fromIndex, g);\n+                fillWithValue(a, -0.0f, fromIndex, g);\n@@ -1914,1 +1602,1 @@\n-                writeValue(x, 0.0f, fromIndex, z);\n+                fillWithValue(a, 0.0f, fromIndex, z);\n@@ -1917,1 +1605,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(a, positiveValue, fromIndex, p);\n@@ -1920,1 +1608,7 @@\n-                writeValue(x, Float.NaN, fromIndex, a);\n+                fillWithValue(a, Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Float.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Float.NaN, fromIndex, k);\n@@ -1925,1 +1619,2 @@\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n+            @Override\n+            void build(Object o, int k, int g, int z, int n, int p, Random random) {\n@@ -1927,2 +1622,2 @@\n-                double positiveValue =  random.nextFloat();\n-                double[] x = (double[]) o;\n+                double positiveValue = random.nextFloat();\n+                double[] a = (double[]) o;\n@@ -1931,1 +1626,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(a, Double.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(a, -Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(a, negativeValue, fromIndex, n);\n@@ -1934,1 +1635,1 @@\n-                writeValue(x, -0.0d, fromIndex, g);\n+                fillWithValue(a, -0.0d, fromIndex, g);\n@@ -1937,1 +1638,1 @@\n-                writeValue(x, 0.0d, fromIndex, z);\n+                fillWithValue(a, 0.0d, fromIndex, z);\n@@ -1940,1 +1641,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(a, positiveValue, fromIndex, p);\n@@ -1943,1 +1644,7 @@\n-                writeValue(x, Double.NaN, fromIndex, a);\n+                fillWithValue(a, Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Double.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Double.NaN, fromIndex, k);\n@@ -1947,1 +1654,1 @@\n-        abstract void build(Object o, int a, int g, int z, int n, int p, Random random);\n+        abstract void build(Object o, int k, int g, int z, int n, int p, Random random);\n@@ -1949,2 +1656,2 @@\n-        private static void writeValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(float[] a, float value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1955,2 +1662,2 @@\n-        private static void writeValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(double[] a, double value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1962,37 +1669,0 @@\n-    private static Comparator<Pair> pairComparator = new Comparator<Pair>() {\n-\n-        @Override\n-        public int compare(Pair p1, Pair p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n-    private static class Pair implements Comparable<Pair> {\n-\n-        private Pair(int key, int value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        int getKey() {\n-            return key;\n-        }\n-\n-        int getValue() {\n-            return value;\n-        }\n-\n-        @Override\n-        public int compareTo(Pair pair) {\n-            return Integer.compare(key, pair.key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"(\" + key + \", \" + value + \")\";\n-        }\n-\n-        private int key;\n-        private int value;\n-    }\n-\n@@ -2001,1 +1671,0 @@\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2003,0 +1672,1 @@\n+        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2015,1 +1685,1 @@\n-        private String seed;\n+        private final String seed;\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":787,"deletions":1117,"binary":false,"changes":1904,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * This class provides access to package-private\n- * methods of DualPivotQuicksort class.\n+ * This class provides access to package-private methods of DualPivotQuicksort class.\n@@ -32,1 +31,1 @@\n- * @version 2019.09.19\n+ * @version 2024.06.14\n@@ -34,1 +33,1 @@\n- * @since 14\n+ * @since 14 * 20 ^ 26\n@@ -38,2 +37,1 @@\n-    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\n-\n+    INSERTION_SORT(\"Insertion sort\") {\n@@ -41,17 +39,10 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.insertionSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.insertionSort(al, low, high);\n+                case byte[] ab -> DualPivotQuicksort.insertionSort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.insertionSort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.insertionSort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.insertionSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.insertionSort(ad, low, high);\n+                default -> fail(a);\n@@ -60,0 +51,1 @@\n+    },\n@@ -61,0 +53,1 @@\n+    MIXED_INSERTION_SORT(\"Mixed insertion sort\") {\n@@ -63,16 +56,9 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.mixedInsertionSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.mixedInsertionSort(al, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.mixedInsertionSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.mixedInsertionSort(ad, low, high);\n+                default -> fail(a);\n@@ -81,10 +67,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -93,2 +69,1 @@\n-    PARALLEL_SORT(\"Parallel sort\") {\n-\n+    MERGING_SORT(\"Merging sort\") {\n@@ -96,17 +71,10 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, ai, low, high - low));\n+                case long[] al -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, al, low, high - low));\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, af, low, high - low));\n+                case double[] ad -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, ad, low, high - low));\n+                default -> fail(a);\n@@ -115,0 +83,1 @@\n+    },\n@@ -116,0 +85,1 @@\n+    RADIX_SORT(\"Radix sort\") {\n@@ -118,16 +88,9 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, ai, low, high));\n+                case long[] al -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, al, low, high));\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.radixSort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.radixSort(as, low, high);\n+                case float[] af -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, af, low, high));\n+                case double[] ad -> check(\"Radix\", DualPivotQuicksort.tryRadixSort(null, ad, low, high));\n+                default -> fail(a);\n@@ -136,0 +99,1 @@\n+    },\n@@ -137,0 +101,1 @@\n+    COUNTING_SORT(\"Counting sort\") {\n@@ -138,7 +103,11 @@\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, 0, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, 0, low, high);\n+                case byte[] ab -> DualPivotQuicksort.countingSort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.countingSort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.countingSort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, 0, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, 0, low, high);\n+                default -> fail(a);\n+            }\n@@ -149,1 +118,0 @@\n-\n@@ -151,17 +119,10 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.heapSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.heapSort(al, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.heapSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.heapSort(ad, low, high);\n+                default -> fail(a);\n@@ -170,0 +131,1 @@\n+    },\n@@ -171,0 +133,1 @@\n+    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\n@@ -173,16 +136,9 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, 0, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, 0, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, 0, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, 0, low, high);\n+                default -> fail(a);\n@@ -191,0 +147,1 @@\n+    },\n@@ -192,4 +149,2 @@\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n+    PARALLEL_QUICKSORT(\"Parallel Quicksort\") {\n+        final int parallel = 4;\n@@ -198,2 +153,11 @@\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, parallel, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, parallel, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as,low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, parallel, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, parallel, low, high);\n+                default -> fail(a);\n+            }\n@@ -204,1 +168,0 @@\n-\n@@ -207,16 +170,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.sort(ai);\n+                case long[] al -> Arrays.sort(al);\n+                case byte[] ab -> Arrays.sort(ab);\n+                case char[] ac -> Arrays.sort(ac);\n+                case short[] as -> Arrays.sort(as);\n+                case float[] af -> Arrays.sort(af);\n+                case double[] ad -> Arrays.sort(ad);\n+                default -> fail(a);\n@@ -228,16 +184,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.sort(ai, low, high);\n+                case long[] al -> Arrays.sort(al, low, high);\n+                case byte[] ab -> Arrays.sort(ab, low, high);\n+                case char[] ac -> Arrays.sort(ac, low, high);\n+                case short[] as -> Arrays.sort(as, low, high);\n+                case float[] af -> Arrays.sort(af, low, high);\n+                case double[] ad -> Arrays.sort(ad, low, high);\n+                default -> fail(a);\n@@ -246,11 +195,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            Arrays.sort(a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.sort(a, comparator);\n-        }\n@@ -260,1 +198,0 @@\n-\n@@ -263,16 +200,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.parallelSort(ai);\n+                case long[] al -> Arrays.parallelSort(al);\n+                case byte[] ab -> Arrays.parallelSort(ab);\n+                case char[] ac -> Arrays.parallelSort(ac);\n+                case short[] as -> Arrays.parallelSort(as);\n+                case float[] af -> Arrays.parallelSort(af);\n+                case double[] ad -> Arrays.parallelSort(ad);\n+                default -> fail(a);\n@@ -284,16 +214,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.parallelSort(ai, low, high);\n+                case long[] al -> Arrays.parallelSort(al, low, high);\n+                case byte[] ab -> Arrays.parallelSort(ab, low, high);\n+                case char[] ac -> Arrays.parallelSort(ac, low, high);\n+                case short[] as -> Arrays.parallelSort(as, low, high);\n+                case float[] af -> Arrays.parallelSort(af, low, high);\n+                case double[] ad -> Arrays.parallelSort(ad, low, high);\n+                default -> fail(a);\n@@ -302,12 +225,0 @@\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a) {\n-            Arrays.parallelSort((Comparable[]) a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.parallelSort(a, comparator);\n-        }\n@@ -316,9 +227,1 @@\n-    abstract public void sort(Object a);\n-\n-    abstract public void sort(Object a, int low, int high);\n-\n-    abstract public void sort(Object[] a);\n-\n-    abstract public void sort(Object[] a, Comparator comparator);\n-\n-    private SortingHelper(String name) {\n+    SortingHelper(String name) {\n@@ -328,0 +231,15 @@\n+    public abstract void sort(Object a, int low, int high);\n+\n+    public void sort(Object a) {\n+        switch(a) {\n+            case int[] ai -> sort(ai, 0, ai.length);\n+            case long[] al -> sort(al, 0, al.length);\n+            case byte[] ab -> sort(ab, 0, ab.length);\n+            case char[] ac -> sort(ac, 0, ac.length);\n+            case short[] as -> sort(as, 0, as.length);\n+            case float[] af -> sort(af, 0, af.length);\n+            case double[] ad -> sort(ad, 0, ad.length);\n+            default -> fail(a);\n+        }\n+    }\n+\n@@ -333,2 +251,4 @@\n-    private static void fail(Object a) {\n-        throw new RuntimeException(\"Unexpected type of array: \" + a.getClass().getName());\n+    private static void check(String name, boolean result) {\n+        if (!result) {\n+            fail(name + \" sort must return true\");\n+        }\n@@ -337,1 +257,3 @@\n-    private String name;\n+    private static void fail(Object a) {\n+        fail(\"Unknown array: \" + a.getClass().getName());\n+    }\n@@ -339,5 +261,3 @@\n-    \/**\n-     * Parallelism level for sequential and parallel sorting.\n-     *\/\n-    private static final int SEQUENTIAL = 0;\n-    private static final int PARALLEL = 87;\n+    private static void fail(String message) {\n+        throw new RuntimeException(message);\n+    }\n@@ -345,5 +265,1 @@\n-    \/**\n-     * Heap sort will be invoked, if recursion depth is too big.\n-     * Value is taken from DualPivotQuicksort.MAX_RECURSION_DEPTH.\n-     *\/\n-    private static final int BIG_DEPTH = 64 * (3 << 1);\n+    private final String name;\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":159,"deletions":243,"binary":false,"changes":402,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,6 @@\n-package org.openjdk.bench.java.lang;\n+\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n@@ -28,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -30,1 +36,0 @@\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n@@ -36,1 +41,0 @@\n-import org.openjdk.jmh.annotations.Level;\n@@ -38,8 +42,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n-import java.util.Arrays;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-import java.io.UnsupportedEncodingException;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n@@ -48,1 +44,7 @@\n- * Performance test of Arrays.sort() methods\n+ * Microbenchmarking of Arrays.sort() and Arrays.parallelSort().\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ *\n+ * @version 2024.06.14\n+ *\n+ * @since 26\n@@ -50,1 +52,1 @@\n-@Fork(value=1, jvmArgs={\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n+@State(Scope.Benchmark)\n@@ -53,3 +55,3 @@\n-@State(Scope.Thread)\n-@Warmup(iterations = 3, time=5)\n-@Measurement(iterations = 3, time=3)\n+@Warmup(iterations = 2, time = 4, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n@@ -58,43 +60,9 @@\n-    @Param({\"10\",\"25\",\"50\",\"75\",\"100\", \"1000\", \"10000\", \"100000\", \"1000000\"})\n-    private int size;\n-\n-    private int[] ints_unsorted;\n-    private long[] longs_unsorted;\n-    private float[] floats_unsorted;\n-    private double[] doubles_unsorted;\n-\n-    private int[] ints_sorted;\n-    private long[] longs_sorted;\n-    private float[] floats_sorted;\n-    private double[] doubles_sorted;\n-\n-\n-    public void initialize() {\n-        Random rnd = new Random(42);\n-\n-        ints_unsorted = new int[size];\n-        longs_unsorted = new long[size];\n-        floats_unsorted = new float[size];\n-        doubles_unsorted = new double[size];\n-\n-        int[] intSpecialCases = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n-        long[] longSpecialCases = {Long.MIN_VALUE, Long.MAX_VALUE};\n-        float[] floatSpecialCases = {+0.0f, -0.0f, Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NaN};\n-        double[] doubleSpecialCases = {+0.0, -0.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN};\n-\n-        for (int i = 0; i < size; i++) {\n-            ints_unsorted[i] = rnd.nextInt();\n-            longs_unsorted[i] = rnd.nextLong();\n-            if (i % 10 != 0) {\n-                ints_unsorted[i] = rnd.nextInt();\n-                longs_unsorted[i] = rnd.nextLong();\n-                floats_unsorted[i] = rnd.nextFloat();\n-                doubles_unsorted[i] = rnd.nextDouble();\n-            } else {\n-                ints_unsorted[i] = intSpecialCases[rnd.nextInt(intSpecialCases.length)];\n-                longs_unsorted[i] = longSpecialCases[rnd.nextInt(longSpecialCases.length)];\n-                floats_unsorted[i] = floatSpecialCases[rnd.nextInt(floatSpecialCases.length)];\n-                doubles_unsorted[i] = doubleSpecialCases[rnd.nextInt(doubleSpecialCases.length)];\n-            }\n-        }\n-    }\n+    private static final int PARALLELISM = java.util.concurrent.ForkJoinPool.getCommonPoolParallelism();\n+\n+    @Param({ \"600\", \"3000\", \"40000\", \"800000\", \"5000000\" })\n+    int size;\n+\n+    @Param\n+    Builder builder;\n+\n+    int[] b;\n@@ -103,2 +71,2 @@\n-    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-        initialize();\n+    public void init() {\n+        b = new int[size];\n@@ -107,7 +75,1 @@\n-    @Setup(Level.Invocation)\n-    public void clear() {\n-        ints_sorted = ints_unsorted.clone();\n-        longs_sorted = longs_unsorted.clone();\n-        floats_sorted = floats_unsorted.clone();\n-        doubles_sorted = doubles_unsorted.clone();\n-    }\n+    public enum Builder {\n@@ -115,5 +77,10 @@\n-    @Benchmark\n-    public int[] intSort() throws Throwable {\n-        Arrays.sort(ints_sorted);\n-        return ints_sorted;\n-    }\n+        REPEATED {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x111);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt(5);\n+                }\n+            }\n+        },\n@@ -121,4 +88,32 @@\n-    @Benchmark\n-    public int[] intParallelSort() throws Throwable {\n-        Arrays.parallelSort(ints_sorted);\n-        return ints_sorted;\n+        STAGGER {\n+            @Override\n+            void build(int[] b) {\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = (i * 8) % b.length;\n+                }\n+            }\n+        },\n+\n+        SHUFFLE {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x999);\n+\n+                for (int i = 0, j = 0, k = 1; i < b.length; ++i) {\n+                    b[i] = random.nextInt(11) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        },\n+\n+        RANDOM {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x777);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt();\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] b);\n@@ -127,4 +122,16 @@\n-    @Benchmark\n-    public long[] longSort() throws Throwable {\n-        Arrays.sort(longs_sorted);\n-        return longs_sorted;\n+    public static class Int extends ArraysSort {\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(b);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(b);\n+        }\n@@ -133,4 +140,26 @@\n-    @Benchmark\n-    public long[] longParallelSort() throws Throwable {\n-        Arrays.parallelSort(longs_sorted);\n-        return longs_sorted;\n+    public static class Long extends ArraysSort {\n+        long[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new long[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -139,4 +168,21 @@\n-    @Benchmark\n-    public float[] floatSort() throws Throwable {\n-        Arrays.sort(floats_sorted);\n-        return floats_sorted;\n+    public static class Short extends ArraysSort {\n+        short[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new short[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (short) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -145,4 +191,21 @@\n-    @Benchmark\n-    public float[] floatParallelSort() throws Throwable {\n-        Arrays.parallelSort(floats_sorted);\n-        return floats_sorted;\n+    public static class Byte extends ArraysSort {\n+        byte[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new byte[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (byte) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -151,4 +214,21 @@\n-    @Benchmark\n-    public double[] doubleSort() throws Throwable {\n-        Arrays.sort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Char extends ArraysSort {\n+        char[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new char[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (char) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -157,4 +237,26 @@\n-    @Benchmark\n-    public double[] doubleParallelSort() throws Throwable {\n-        Arrays.parallelSort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Float extends ArraysSort {\n+        float[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new float[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -163,0 +265,27 @@\n+    public static class Double extends ArraysSort {\n+        double[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new double[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":231,"deletions":102,"binary":false,"changes":333,"status":"modified"}]}