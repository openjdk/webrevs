{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+\/\/ -- This file was mechanically generated: Do not edit! -- \/\/\n+\n@@ -29,1 +31,0 @@\n-import java.util.concurrent.RecursiveTask;\n@@ -31,1 +32,0 @@\n-import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -33,0 +33,1 @@\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n@@ -39,1 +40,1 @@\n- * faster than traditional (one-pivot) Quicksort implementations.\n+ * faster than traditional (one-pivot) Quicksort implementations.<p>\n@@ -42,2 +43,44 @@\n- * Quicksort, such as mixed insertion sort, merging of runs and heap\n- * sort, counting sort and parallel merge sort.\n+ * Quicksort such as merging sort, sorting network, heap sort, mixed\n+ * insertion sort, counting sort and parallel merge sort. The actual\n+ * sorting algorithm depends on the data type and array size.<p>\n+ *\n+ * <b>Type: int\/long\/float\/double<\/b><p>\n+ *\n+ * If the array size is small, invoke mixed insertion sort on non-leftmost\n+ * parts or insertion sort on leftmost part.<p>\n+ *\n+ * Then try merging sort which is the best on almost sorted arrays.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with heap sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Type: float\/double<\/b><p>\n+ *\n+ * Floating-point values require additional steps to process\n+ * negative zeros -0.0 and NaNs (Not-a-Number) before sorting and\n+ * re-arrange negative zeros at the end.<p>\n+ *\n+ * <b>Type: byte<\/b><p>\n+ *\n+ * Invoke insertion sort, if the array size is small, otherwise switch\n+ * to counting sort.<p>\n+ *\n+ * <b>Type: char\/short<\/b><p>\n+ *\n+ * Invoke counting sort on large array, otherwise run insertion sort\n+ * on small array.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with counting sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+ *\n+ * If the array size is small, sequential sort is run. Otherwise\n+ * invoke parallel merge sort (the recursion depth depends on\n+ * parallelism level), then run parallel Quicksort.\n@@ -50,1 +93,1 @@\n- * @version 2018.08.18\n+ * @version 2024.06.14\n@@ -52,1 +95,1 @@\n- * @since 1.7 * 14\n+ * @since 1.7 * 14 ^ 26\n@@ -61,4 +104,1 @@\n-    \/**\n-     * Max array size to use mixed insertion sort.\n-     *\/\n-    private static final int MAX_MIXED_INSERTION_SORT_SIZE = 65;\n+    \/* --------------------- Insertion sort --------------------- *\/\n@@ -67,1 +107,1 @@\n-     * Max array size to use insertion sort.\n+     * Max size of array to use insertion sort (the best on shuffle data).\n@@ -69,1 +109,1 @@\n-    private static final int MAX_INSERTION_SORT_SIZE = 44;\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n@@ -71,4 +111,1 @@\n-    \/**\n-     * Min array size to perform sorting in parallel.\n-     *\/\n-    private static final int MIN_PARALLEL_SORT_SIZE = 4 << 10;\n+    \/* ---------------------- Merging sort ---------------------- *\/\n@@ -77,1 +114,1 @@\n-     * Min array size to try merging of runs.\n+     * Min size of array to use merging sort (the best on stagger data).\n@@ -79,1 +116,1 @@\n-    private static final int MIN_TRY_MERGE_SIZE = 4 << 10;\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n@@ -82,1 +119,1 @@\n-     * Min size of the first run to continue with scanning.\n+     * Min size of run to continue scanning (the best on stagger data).\n@@ -84,1 +121,1 @@\n-    private static final int MIN_FIRST_RUN_SIZE = 16;\n+    private static final int MIN_RUN_SIZE = 64;\n@@ -87,1 +124,1 @@\n-     * Min factor for the first runs to continue scanning.\n+     * Max capacity of the index array to track the runs.\n@@ -89,1 +126,1 @@\n-    private static final int MIN_FIRST_RUNS_FACTOR = 7;\n+    private static final int MAX_RUN_CAPACITY = 10 << 10;\n@@ -91,4 +128,1 @@\n-    \/**\n-     * Max capacity of the index array for tracking runs.\n-     *\/\n-    private static final int MAX_RUN_CAPACITY = 5 << 10;\n+    \/* ---------------------- Digital sort ---------------------- *\/\n@@ -97,1 +131,1 @@\n-     * Min number of runs, required by parallel merging.\n+     * Min size of array to use counting sort (the best on random data).\n@@ -99,1 +133,1 @@\n-    private static final int MIN_RUN_COUNT = 4;\n+    private static final int MIN_COUNTING_SORT_SIZE = 640;\n@@ -102,1 +136,1 @@\n-     * Min array size to use parallel merging of parts.\n+     * Min size of array to use numerical sort (the best on repeated data).\n@@ -104,1 +138,1 @@\n-    private static final int MIN_PARALLEL_MERGE_PARTS_SIZE = 4 << 10;\n+    private static final int MIN_NUMERICAL_SORT_SIZE = 9 << 10;\n@@ -106,4 +140,1 @@\n-    \/**\n-     * Min size of a byte array to use counting sort.\n-     *\/\n-    private static final int MIN_BYTE_COUNTING_SORT_SIZE = 64;\n+    \/* --------------------- Parallel sort ---------------------- *\/\n@@ -112,1 +143,1 @@\n-     * Min size of a short or char array to use counting sort.\n+     * Min size of array to perform sorting in parallel (the best on stagger data).\n@@ -114,1 +145,3 @@\n-    private static final int MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE = 1750;\n+    private static final int MIN_PARALLEL_SORT_SIZE = 3 << 10;\n+\n+    \/* --------------------- Infrastructure --------------------- *\/\n@@ -117,1 +150,1 @@\n-     * Threshold of mixed insertion sort is incremented by this value.\n+     * Max recursive depth before switching to heap sort.\n@@ -119,1 +152,1 @@\n-    private static final int DELTA = 3 << 1;\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n@@ -122,1 +155,2 @@\n-     * Max recursive partitioning depth before using heap sort.\n+     * Max size of additional buffer in bytes,\n+     *      limited by max_heap \/ 16 or 2 GB max.\n@@ -124,1 +158,2 @@\n-    private static final int MAX_RECURSION_DEPTH = 64 * DELTA;\n+    private static final int MAX_BUFFER_SIZE =\n+        Math.clamp(Runtime.getRuntime().maxMemory() >>> 4, 0, Integer.MAX_VALUE);\n@@ -127,2 +162,4 @@\n-     * Represents a function that accepts the array and sorts the specified range\n-     * of the array into ascending order.\n+     * Represents a function that accepts the array and sorts\n+     * the specified range of the array into ascending order.\n+     *\n+     * @param <T> the class of array\n@@ -131,1 +168,1 @@\n-    private static interface SortOperation<A> {\n+    private interface SortOperation<T> {\n@@ -139,1 +176,1 @@\n-        void sort(A a, int low, int high);\n+        void sort(T a, int low, int high);\n@@ -144,0 +181,3 @@\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n@@ -145,0 +185,1 @@\n+     * @param <T> the class of array\n@@ -146,4 +187,5 @@\n-     * @param array the array to be sorted\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to sort, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to sort from.\n+     * @param a the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n@@ -154,1 +196,0 @@\n-    @IntrinsicCandidate\n@@ -156,2 +197,4 @@\n-    private static <A> void sort(Class<?> elemType, A array, long offset, int low, int high, SortOperation<A> so) {\n-        so.sort(array, low, high);\n+    @IntrinsicCandidate\n+    private static <T> void sort(Class<?> elemType, T a, long offset,\n+            int low, int high, SortOperation<T> so) {\n+        so.sort(a, low, high);\n@@ -161,2 +204,4 @@\n-     * Represents a function that accepts the array and partitions the specified range\n-     * of the array using the pivots provided.\n+     * Represents a function that accepts the array and partitions\n+     * the specified range of the array using the given pivots.\n+     *\n+     * @param <T> the class of array\n@@ -165,1 +210,1 @@\n-    interface PartitionOperation<A> {\n+    private interface PartitionOperation<T> {\n@@ -169,3 +214,3 @@\n-         * @param a the array to be partitioned\n-         * @param low the index of the first element, inclusive, to be partitioned\n-         * @param high the index of the last element, exclusive, to be partitioned\n+         * @param a the array for partitioning\n+         * @param low the index of the first element, inclusive, for partitioning\n+         * @param high the index of the last element, exclusive, for partitioning\n@@ -174,0 +219,1 @@\n+         * @return indices of parts after partitioning\n@@ -175,1 +221,1 @@\n-        int[] partition(A a, int low, int high, int pivotIndex1, int pivotIndex2);\n+        int[] partition(T a, int low, int high, int pivotIndex1, int pivotIndex2);\n@@ -179,1 +225,4 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using the given pivots.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n@@ -181,7 +230,9 @@\n-     * @param elemType the class of the array to be partitioned\n-     * @param array the array to be partitioned\n-     * @param offset the relative offset, in bytes, from the base address of\n-     * the array to partition, otherwise if the array is {@code null},an absolute\n-     * address pointing to the first element to partition from.\n-     * @param low the index of the first element, inclusive, to be partitioned\n-     * @param high the index of the last element, exclusive, to be partitioned\n+     * @param <T> the class of array\n+     * @param elemType the class of the array for partitioning\n+     * @param a the array for partitioning\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n@@ -191,0 +242,1 @@\n+     * @return indices of parts after partitioning\n@@ -192,1 +244,0 @@\n-    @IntrinsicCandidate\n@@ -194,2 +245,4 @@\n-    private static <A> int[] partition(Class<?> elemType, A array, long offset, int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<A> po) {\n-        return po.partition(array, low, high, pivotIndex1, pivotIndex2);\n+    @IntrinsicCandidate\n+    private static <T> int[] partition(Class<?> elemType, T a, long offset,\n+            int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<T> po) {\n+        return po.partition(a, low, high, pivotIndex1, pivotIndex2);\n@@ -198,16 +251,1 @@\n-    \/**\n-     * Calculates the double depth of parallel merging.\n-     * Depth is negative, if tasks split before sorting.\n-     *\n-     * @param parallelism the parallelism level\n-     * @param size the target size\n-     * @return the depth of parallel merging\n-     *\/\n-    private static int getDepth(int parallelism, int size) {\n-        int depth = 0;\n-\n-        while ((parallelism >>= 3) > 0 && (size >>= 2) > 0) {\n-            depth -= 2;\n-        }\n-        return depth;\n-    }\n+\/\/ #[int]\n@@ -217,1 +255,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -231,6 +269,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            int[] b = depth == 0 ? null : new int[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -243,2 +277,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -246,1 +279,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -249,1 +282,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -253,1 +286,1 @@\n-    static void sort(Sorter sorter, int[] a, int bits, int low, int high) {\n+    static void sort(Sorter<int[]> sorter, int[] a, int bits, int low, int high) {\n@@ -255,8 +288,1 @@\n-            int end = high - 1, size = high - low;\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -265,1 +291,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -267,2 +293,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -273,2 +300,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -276,2 +302,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+                sort(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -282,2 +309,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -285,2 +311,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -291,2 +317,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -294,1 +321,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -303,1 +330,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -307,1 +334,0 @@\n-            int a3 = a[e3];\n@@ -310,1 +336,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -313,17 +339,22 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { int t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { int t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { int t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { int t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { int t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { int t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { int t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { int t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { int t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { int t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    int t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -331,1 +362,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    int t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -333,3 +364,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    int t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -337,1 +368,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    int t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -341,3 +372,7 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n@@ -346,1 +381,2 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n@@ -348,9 +384,1 @@\n-            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+            int[] indices;\n@@ -358,0 +386,4 @@\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n@@ -359,0 +391,2 @@\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n@@ -365,2 +399,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -368,2 +402,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -372,1 +406,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -374,7 +411,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(int.class, a, Unsafe.ARRAY_INT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -387,1 +417,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -389,1 +419,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -392,1 +422,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -397,1 +427,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -399,1 +429,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -404,1 +434,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -406,3 +436,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -410,1 +443,0 @@\n-        int upper = end;\n@@ -412,4 +444,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        int pivot1 = a[e1];\n-        int pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        int pivot1 = a[pivotIndex1];\n+        int pivot2 = a[pivotIndex2];\n@@ -424,2 +459,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -436,13 +471,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -451,0 +480,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -455,12 +486,12 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n@@ -468,1 +499,2 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -477,2 +509,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -480,1 +512,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -484,1 +516,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -486,1 +518,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -489,3 +521,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -493,4 +525,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            int[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -498,3 +532,6 @@\n-        int upper = end;\n-        int e3 = pivotIndex1;\n-        int pivot = a[e3];\n+\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        int pivot = a[pivotIndex1];\n@@ -509,1 +546,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -512,9 +549,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n+         * Dutch National Flag partitioning\n@@ -522,5 +551,7 @@\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -529,0 +560,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -530,1 +563,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -533,2 +566,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -536,2 +571,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -539,6 +574,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -546,0 +577,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -553,1 +587,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -557,1 +592,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -559,2 +594,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -572,4 +607,11 @@\n-    private static void mixedInsertionSort(int[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(int[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            int ai = a[i = low], pin = a[--p];\n@@ -578,1 +620,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Swap larger element with pin.\n@@ -580,7 +622,3 @@\n-            for (int i; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -588,1 +626,0 @@\n-        } else {\n@@ -591,7 +628,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -599,40 +630,2 @@\n-            int pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                int ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n@@ -640,0 +633,8 @@\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            int a1 = a[i = low], a2 = a[++low];\n@@ -642,1 +643,3 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n@@ -644,9 +647,1 @@\n-            for (int i; low < high; ++low) {\n-                int a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+            if (a1 > a2) {\n@@ -654,4 +649,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -659,4 +654,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -664,1 +659,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -666,4 +661,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -671,4 +666,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -676,0 +669,1 @@\n+                a[i + 1] = a1;\n@@ -687,1 +681,1 @@\n-    private static void insertionSort(int[] a, int low, int high) {\n+    static void insertionSort(int[] a, int low, int high) {\n@@ -692,4 +686,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -701,1 +696,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -703,0 +698,1 @@\n+     * @param sorter the parallel context\n@@ -706,0 +702,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -707,48 +704,1 @@\n-    private static void heapSort(int[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            int max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(int[] a, int p, int value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, int[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<int[]> sorter, int[] a, int low, int high) {\n@@ -756,3 +706,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -760,0 +709,1 @@\n+        int count = 1;\n@@ -761,2 +711,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -767,2 +715,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -770,1 +717,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -786,0 +733,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -789,0 +742,1 @@\n+                \/\/ Check the next sequence\n@@ -795,1 +749,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -798,1 +752,0 @@\n-                if (k == high) {\n@@ -800,0 +753,1 @@\n+                if (k == high) {\n@@ -801,1 +755,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -806,11 +760,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -819,3 +763,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -823,0 +765,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -824,2 +767,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -830,2 +773,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -837,0 +779,1 @@\n+            }\n@@ -838,1 +781,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -840,5 +786,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -846,1 +792,0 @@\n-            run[count] = (last = k);\n@@ -850,1 +795,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -855,3 +800,1 @@\n-            if (sorter == null || (b = (int[]) sorter.b) == null) {\n-                b = new int[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -859,0 +802,2 @@\n+            } else if ((b = tryAllocate(int[].class, high - low)) == null) {\n+                return false;\n@@ -860,1 +805,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -868,0 +813,1 @@\n+     * @param sorter the parallel context\n@@ -869,1 +815,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -871,2 +817,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -876,1 +821,0 @@\n-     * @return the destination where runs are merged\n@@ -878,2 +822,2 @@\n-    private static int[] mergeRuns(int[] a, int[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<int[]> sorter, int[] a, int[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -882,2 +826,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -885,4 +829,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -892,1 +833,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -894,2 +835,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -898,1 +839,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -900,10 +841,2 @@\n-        int[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (int[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -911,1 +844,2 @@\n-        int[] dst = a1 == a ? b : a;\n+        int[] dst = aim ? a : b;\n+        int[] src = aim ? b : a;\n@@ -913,5 +847,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -919,2 +853,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -922,1 +859,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -924,1 +861,0 @@\n-        return dst;\n@@ -928,1 +864,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -930,1 +866,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -933,1 +869,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -936,1 +872,0 @@\n-     * @param a2 the second part\n@@ -940,2 +875,2 @@\n-    private static void mergeParts(Merger merger, int[] dst, int k,\n-            int[] a1, int lo1, int hi1, int[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<int[]> merger, int[] dst, int k,\n+            int[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -943,1 +878,8 @@\n-        if (merger != null && a1 == a2) {\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n@@ -945,1 +887,6 @@\n-            while (true) {\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n@@ -947,7 +894,6 @@\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            int key = src[mi1];\n@@ -955,5 +901,10 @@\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n@@ -961,0 +912,1 @@\n+            }\n@@ -962,6 +914,4 @@\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                int key = a1[mi1];\n-                int mi2 = hi2;\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -969,5 +919,4 @@\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -975,6 +924,6 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n@@ -982,1 +931,10 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+        }\n+    }\n@@ -984,4 +942,13 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(int[] dst, int k,\n+            int[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -989,5 +956,32 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                int next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                int next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                int next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n@@ -998,1 +992,1 @@\n-         * Merge small parts sequentially.\n+         * Copy the tail of the left and right parts.\n@@ -1000,2 +994,14 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(int[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n@@ -1003,4 +1009,4 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n+        while (--high > low) {\n+            int max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n@@ -1008,3 +1014,23 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(int[] a, int p, int value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -1013,0 +1039,1 @@\n+        a[p] = value;\n@@ -1015,1 +1042,1 @@\n-\/\/ [long]\n+\/\/ #[long]\n@@ -1019,1 +1046,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -1033,6 +1060,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            long[] b = depth == 0 ? null : new long[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -1045,2 +1068,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1048,1 +1070,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -1051,1 +1073,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1055,1 +1077,1 @@\n-    static void sort(Sorter sorter, long[] a, int bits, int low, int high) {\n+    static void sort(Sorter<long[]> sorter, long[] a, int bits, int low, int high) {\n@@ -1057,9 +1079,1 @@\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -1068,1 +1082,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -1070,2 +1084,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -1076,2 +1091,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -1079,2 +1093,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+                sort(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -1085,2 +1100,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -1088,2 +1102,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -1094,2 +1108,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1097,1 +1112,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1106,1 +1121,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -1110,1 +1125,0 @@\n-            long a3 = a[e3];\n@@ -1113,1 +1127,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -1116,17 +1130,22 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { long t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { long t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { long t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { long t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { long t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { long t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { long t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { long t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { long t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { long t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    long t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -1134,1 +1153,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    long t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -1136,3 +1155,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    long t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -1140,1 +1159,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    long t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -1144,3 +1163,13 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -1149,1 +1178,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -1153,8 +1182,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -1166,2 +1190,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -1169,2 +1193,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -1173,1 +1197,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -1175,7 +1202,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(long.class, a, Unsafe.ARRAY_LONG_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -1188,1 +1208,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -1190,1 +1210,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -1193,1 +1213,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -1198,1 +1218,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -1200,1 +1220,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1205,1 +1225,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -1207,3 +1227,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -1211,1 +1234,0 @@\n-        int upper = end;\n@@ -1213,4 +1235,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        long pivot1 = a[e1];\n-        long pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        long pivot1 = a[pivotIndex1];\n+        long pivot2 = a[pivotIndex2];\n@@ -1225,2 +1250,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -1237,13 +1262,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -1252,0 +1271,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1256,12 +1277,6 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n@@ -1269,1 +1284,8 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -1278,2 +1300,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -1281,1 +1303,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -1285,1 +1307,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -1287,1 +1309,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -1290,3 +1312,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -1294,4 +1316,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            long[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -1299,1 +1323,0 @@\n-        int upper = end;\n@@ -1301,2 +1324,5 @@\n-        int e3 = pivotIndex1;\n-        long pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        long pivot = a[pivotIndex1];\n@@ -1311,1 +1337,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -1314,9 +1340,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n+         * Dutch National Flag partitioning\n@@ -1324,5 +1342,7 @@\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -1331,0 +1351,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -1332,1 +1354,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -1335,2 +1357,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -1338,2 +1362,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -1341,6 +1365,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -1348,0 +1368,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -1355,1 +1378,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -1359,1 +1383,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -1361,2 +1385,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -1374,4 +1398,11 @@\n-    private static void mixedInsertionSort(long[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(long[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            long ai = a[i = low], pin = a[--p];\n@@ -1380,1 +1411,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Swap larger element with pin.\n@@ -1382,7 +1413,3 @@\n-            for (int i; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -1390,1 +1417,0 @@\n-        } else {\n@@ -1393,7 +1419,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -1401,40 +1421,2 @@\n-            long pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                long ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n@@ -1442,0 +1424,8 @@\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            long a1 = a[i = low], a2 = a[++low];\n@@ -1444,1 +1434,3 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n@@ -1446,2 +1438,1 @@\n-            for (int i; low < high; ++low) {\n-                long a1 = a[i = low], a2 = a[++low];\n+            if (a1 > a2) {\n@@ -1449,11 +1440,4 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n-\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -1461,4 +1445,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -1466,1 +1450,1 @@\n-                } else if (a1 < a[i - 1]) {\n+            } else if (a1 < a[i - 1]) {\n@@ -1468,4 +1452,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n@@ -1473,4 +1457,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -1478,0 +1460,1 @@\n+                a[i + 1] = a1;\n@@ -1489,1 +1472,1 @@\n-    private static void insertionSort(long[] a, int low, int high) {\n+    static void insertionSort(long[] a, int low, int high) {\n@@ -1494,4 +1477,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -1503,1 +1487,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -1505,0 +1489,1 @@\n+     * @param sorter the parallel context\n@@ -1508,0 +1493,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -1509,48 +1495,1 @@\n-    private static void heapSort(long[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            long max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(long[] a, int p, long value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, long[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<long[]> sorter, long[] a, int low, int high) {\n@@ -1558,3 +1497,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -1562,0 +1500,1 @@\n+        int count = 1;\n@@ -1563,2 +1502,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -1569,2 +1506,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -1572,1 +1508,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -1588,0 +1524,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -1591,0 +1533,1 @@\n+                \/\/ Check the next sequence\n@@ -1597,1 +1540,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -1600,1 +1543,0 @@\n-                if (k == high) {\n@@ -1602,0 +1544,1 @@\n+                if (k == high) {\n@@ -1603,1 +1546,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -1608,11 +1551,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -1621,3 +1554,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -1625,0 +1556,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -1626,2 +1558,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -1632,2 +1564,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -1639,8 +1570,0 @@\n-\n-                if (count == run.length) {\n-\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n@@ -1648,0 +1571,4 @@\n+\n+            \/*\n+             * Save the current run.\n+             *\/\n@@ -1649,1 +1576,8 @@\n-        }\n+\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n+            }\n+        }\n@@ -1652,1 +1586,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -1657,3 +1591,1 @@\n-            if (sorter == null || (b = (long[]) sorter.b) == null) {\n-                b = new long[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -1661,0 +1593,2 @@\n+            } else if ((b = tryAllocate(long[].class, high - low)) == null) {\n+                return false;\n@@ -1662,1 +1596,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -1670,0 +1604,1 @@\n+     * @param sorter the parallel context\n@@ -1671,1 +1606,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -1673,2 +1608,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -1678,1 +1612,0 @@\n-     * @return the destination where runs are merged\n@@ -1680,2 +1613,2 @@\n-    private static long[] mergeRuns(long[] a, long[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<long[]> sorter, long[] a, long[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -1684,2 +1617,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -1687,4 +1620,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -1694,1 +1624,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -1696,2 +1626,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -1700,1 +1630,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -1702,10 +1632,2 @@\n-        long[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (long[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -1713,1 +1635,2 @@\n-        long[] dst = a1 == a ? b : a;\n+        long[] dst = aim ? a : b;\n+        long[] src = aim ? b : a;\n@@ -1715,5 +1638,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -1721,2 +1644,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -1724,1 +1650,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -1726,1 +1652,0 @@\n-        return dst;\n@@ -1730,1 +1655,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -1732,1 +1657,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -1735,1 +1660,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -1738,1 +1663,0 @@\n-     * @param a2 the second part\n@@ -1742,2 +1666,2 @@\n-    private static void mergeParts(Merger merger, long[] dst, int k,\n-            long[] a1, int lo1, int hi1, long[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<long[]> merger, long[] dst, int k,\n+            long[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -1745,1 +1669,8 @@\n-        if (merger != null && a1 == a2) {\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n@@ -1747,1 +1678,6 @@\n-            while (true) {\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n@@ -1749,7 +1685,6 @@\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            long key = src[mi1];\n@@ -1757,5 +1692,10 @@\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n@@ -1763,0 +1703,1 @@\n+            }\n@@ -1764,6 +1705,4 @@\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                long key = a1[mi1];\n-                int mi2 = hi2;\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -1771,5 +1710,4 @@\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -1777,6 +1715,31 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n+\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(long[] dst, int k,\n+            long[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -1784,1 +1747,3 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                long next = src[lo1];\n@@ -1786,4 +1751,10 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                long next = src[lo1];\n@@ -1791,5 +1762,17 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                long next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n@@ -1800,1 +1783,1 @@\n-         * Merge small parts sequentially.\n+         * Copy the tail of the left and right parts.\n@@ -1802,2 +1785,14 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(long[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n@@ -1805,4 +1800,4 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n+        while (--high > low) {\n+            long max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n@@ -1810,3 +1805,23 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(long[] a, int p, long value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -1815,0 +1830,1 @@\n+        a[p] = value;\n@@ -1817,1 +1833,1 @@\n-\/\/ [byte]\n+\/\/ #[byte]\n@@ -1820,2 +1836,1 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or insertion sort.\n+     * Sorts the specified range of the array using insertion sort or counting sort.\n@@ -1828,3 +1843,1 @@\n-        if (high - low > MIN_BYTE_COUNTING_SORT_SIZE) {\n-            countingSort(a, low, high);\n-        } else {\n+        if (high - low < MAX_INSERTION_SORT_SIZE) {\n@@ -1832,0 +1845,2 @@\n+        } else {\n+            countingSort(a, low, high);\n@@ -1842,1 +1857,1 @@\n-    private static void insertionSort(byte[] a, int low, int high) {\n+    static void insertionSort(byte[] a, int low, int high) {\n@@ -1847,4 +1862,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -1855,10 +1871,0 @@\n-    \/**\n-     * The number of distinct byte values.\n-     *\/\n-    private static final int NUM_BYTE_VALUES = 1 << 8;\n-\n-    \/**\n-     * Max index of byte counter.\n-     *\/\n-    private static final int MAX_BYTE_INDEX = Byte.MAX_VALUE + NUM_BYTE_VALUES + 1;\n-\n@@ -1872,2 +1878,5 @@\n-    private static void countingSort(byte[] a, int low, int high) {\n-        int[] count = new int[NUM_BYTE_VALUES];\n+    static void countingSort(byte[] a, int low, int high) {\n+        \/*\n+         * Count the number of all values.\n+         *\/\n+        int[] count = new int[1 << 8];\n@@ -1876,1 +1885,1 @@\n-         * Compute a histogram with the number of each values.\n+         * Compute the histogram.\n@@ -1883,3 +1892,3 @@\n-        if (high - low > NUM_BYTE_VALUES) {\n-            for (int i = MAX_BYTE_INDEX; --i > Byte.MAX_VALUE; ) {\n-                int value = i & 0xFF;\n+        for (int value = Byte.MIN_VALUE; high > low; ) {\n+            while (count[--value & 0xFF] == 0);\n+            int num = count[value & 0xFF];\n@@ -1887,15 +1896,3 @@\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (byte) value\n-                );\n-            }\n-        } else {\n-            for (int i = MAX_BYTE_INDEX; high > low; ) {\n-                while (count[--i & 0xFF] == 0);\n-\n-                int value = i & 0xFF;\n-                int c = count[value];\n-\n-                do {\n-                    a[--high] = (byte) value;\n-                } while (--c > 0);\n-            }\n+            do {\n+                a[--high] = (byte) value;\n+            } while (--num > 0);\n@@ -1905,1 +1902,1 @@\n-\/\/ [char]\n+\/\/ #[char]\n@@ -1908,2 +1905,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n@@ -1916,1 +1913,1 @@\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n@@ -1924,2 +1921,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -1929,1 +1925,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -1933,1 +1929,1 @@\n-    static void sort(char[] a, int bits, int low, int high) {\n+    private static void sort(char[] a, int bits, int low, int high) {\n@@ -1935,1 +1931,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -1938,1 +1934,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -1946,11 +1942,3 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n-             *\/\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -1958,1 +1946,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -1967,1 +1955,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -1971,1 +1959,0 @@\n-            char a3 = a[e3];\n@@ -1974,1 +1961,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -1977,17 +1964,22 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { char t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { char t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { char t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { char t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { char t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { char t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { char t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { char t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { char t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { char t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    char t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -1995,1 +1987,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    char t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -1997,3 +1989,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    char t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2001,1 +1993,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    char t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2005,3 +1997,13 @@\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to counting sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                countingSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -2010,1 +2012,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2014,7 +2016,1 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                char pivot1 = a[e1];\n-                char pivot2 = a[e5];\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n@@ -2023,5 +2019,2 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n@@ -2029,2 +2022,6 @@\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n@@ -2033,1 +2030,3 @@\n-                 * Skip elements, which are less or greater than the pivots.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2035,0 +2034,67 @@\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            char[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        char pivot1 = a[pivotIndex1];\n+        char pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            char ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2036,1 +2102,0 @@\n-                while (a[--upper] > pivot2);\n@@ -2038,39 +2103,3 @@\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n@@ -2078,0 +2107,12 @@\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n@@ -2079,5 +2120,5 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2085,6 +2126,2 @@\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n+        return new int[] { lower, upper };\n+    }\n@@ -2092,1 +2129,17 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            char[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n@@ -2094,5 +2147,5 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                char pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        char pivot = a[pivotIndex1];\n@@ -2100,8 +2153,8 @@\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -2109,37 +2162,17 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    char ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            char ak = a[k];\n@@ -2147,4 +2180,4 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2152,6 +2185,9 @@\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n+\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2159,1 +2195,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2161,0 +2196,7 @@\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n@@ -2170,1 +2212,1 @@\n-    private static void insertionSort(char[] a, int low, int high) {\n+    static void insertionSort(char[] a, int low, int high) {\n@@ -2175,4 +2217,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -2183,5 +2226,0 @@\n-    \/**\n-     * The number of distinct char values.\n-     *\/\n-    private static final int NUM_CHAR_VALUES = 1 << 16;\n-\n@@ -2195,2 +2233,2 @@\n-    private static void countingSort(char[] a, int low, int high) {\n-        int[] count = new int[NUM_CHAR_VALUES];\n+    static void countingSort(char[] a, int low, int high) {\n+        int size = high - low;\n@@ -2198,4 +2236,5 @@\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i]]);\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n@@ -2203,8 +2242,15 @@\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_CHAR_VALUES) {\n-            for (int i = NUM_CHAR_VALUES; i > 0; ) {\n-                for (low = high - count[--i]; high > low;\n-                    a[--high] = (char) i\n-                );\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i]]);\n+\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = count.length; high > low; ) {\n+                while (count[--value] == 0);\n+                int num = count[value];\n+\n+                do {\n+                    a[--high] = (char) value;\n+                } while (--num > 0);\n@@ -2212,0 +2258,1 @@\n+\n@@ -2213,3 +2260,0 @@\n-            for (int i = NUM_CHAR_VALUES; high > low; ) {\n-                while (count[--i] == 0);\n-                int c = count[i];\n@@ -2217,3 +2261,51 @@\n-                do {\n-                    a[--high] = (char) i;\n-                } while (--c > 0);\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            char[] b = new char[size];\n+\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n+\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF)];\n+            }\n+\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF)]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF)] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n@@ -2224,1 +2316,1 @@\n-\/\/ [short]\n+\/\/ #[short]\n@@ -2227,2 +2319,2 @@\n-     * Sorts the specified range of the array using\n-     * counting sort or Dual-Pivot Quicksort.\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n@@ -2235,1 +2327,1 @@\n-        if (high - low > MIN_SHORT_OR_CHAR_COUNTING_SORT_SIZE) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n@@ -2243,2 +2335,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2248,1 +2339,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2252,1 +2343,1 @@\n-    static void sort(short[] a, int bits, int low, int high) {\n+    private static void sort(short[] a, int bits, int low, int high) {\n@@ -2254,1 +2345,1 @@\n-            int end = high - 1, size = high - low;\n+            int size = high - low;\n@@ -2257,1 +2348,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Invoke insertion sort on small part.\n@@ -2265,2 +2356,3 @@\n-             * Switch to counting sort if execution\n-             * time is becoming quadratic.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2268,10 +2360,1 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                countingSort(a, low, high);\n-                return;\n-            }\n-\n-            \/*\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n-             *\/\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2286,1 +2369,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -2290,1 +2373,0 @@\n-            short a3 = a[e3];\n@@ -2293,1 +2375,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2296,17 +2378,22 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { short t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { short t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { short t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { short t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { short t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { short t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { short t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { short t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { short t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { short t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    short t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -2314,1 +2401,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    short t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -2316,3 +2403,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    short t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2320,1 +2407,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    short t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2324,3 +2411,13 @@\n-            \/\/ Pointers\n-            int lower = low; \/\/ The index of the last element of the left part\n-            int upper = end; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to counting sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                countingSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -2329,1 +2426,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2333,7 +2430,1 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                short pivot1 = a[e1];\n-                short pivot2 = a[e5];\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n@@ -2342,5 +2433,2 @@\n-                 * The first and the last elements to be sorted are moved\n-                 * to the locations formerly occupied by the pivots. When\n-                 * partitioning is completed, the pivots are swapped back\n-                 * into their final positions, and excluded from the next\n-                 * subsequent sorting.\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n@@ -2348,2 +2436,6 @@\n-                a[e1] = a[lower];\n-                a[e5] = a[upper];\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n@@ -2352,1 +2444,3 @@\n-                 * Skip elements, which are less or greater than the pivots.\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n@@ -2354,0 +2448,67 @@\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            short[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        short pivot1 = a[pivotIndex1];\n+        short pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            short ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n@@ -2355,1 +2516,0 @@\n-                while (a[--upper] > pivot2);\n@@ -2357,39 +2517,3 @@\n-                \/*\n-                 * Backward 3-interval partitioning\n-                 *\n-                 *   left part                 central part          right part\n-                 * +------------------------------------------------------------+\n-                 * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-                 * +------------------------------------------------------------+\n-                 *             ^       ^                            ^\n-                 *             |       |                            |\n-                 *           lower     k                          upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *              all in (low, lower] < pivot1\n-                 *    pivot1 <= all in (k, upper)  <= pivot2\n-                 *              all in [upper, end) > pivot2\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int unused = --lower, k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n-\n-                    if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                        while (lower < k) {\n-                            if (a[++lower] >= pivot1) {\n-                                if (a[lower] > pivot2) {\n-                                    a[k] = a[--upper];\n-                                    a[upper] = a[lower];\n-                                } else {\n-                                    a[k] = a[lower];\n-                                }\n-                                a[lower] = ak;\n-                                break;\n-                            }\n-                        }\n-                    } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n-                        a[k] = a[--upper];\n-                        a[upper] = ak;\n-                    }\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n@@ -2397,0 +2521,18 @@\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2398,5 +2540,2 @@\n-                \/*\n-                 * Swap the pivots into their final positions.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot1;\n-                a[end] = a[upper]; a[upper] = pivot2;\n+        return new int[] { lower, upper };\n+    }\n@@ -2404,6 +2543,17 @@\n-                \/*\n-                 * Sort non-left parts recursively,\n-                 * excluding known pivots.\n-                 *\/\n-                sort(a, bits | 1, lower + 1, upper);\n-                sort(a, bits | 1, upper + 1, high);\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            short[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n@@ -2411,1 +2561,5 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        short pivot = a[pivotIndex1];\n@@ -2413,5 +2567,8 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                short pivot = a[e3];\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -2419,8 +2576,17 @@\n-                \/*\n-                 * The first element to be sorted is moved to the\n-                 * location formerly occupied by the pivot. After\n-                 * completion of partitioning the pivot is swapped\n-                 * back into its final position, and excluded from\n-                 * the next subsequent sorting.\n-                 *\/\n-                a[e3] = a[lower];\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            short ak = a[k];\n@@ -2428,37 +2594,4 @@\n-                \/*\n-                 * Traditional 3-way (Dutch National Flag) partitioning\n-                 *\n-                 *   left part                 central part    right part\n-                 * +------------------------------------------------------+\n-                 * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-                 * +------------------------------------------------------+\n-                 *              ^           ^                ^\n-                 *              |           |                |\n-                 *            lower         k              upper\n-                 *\n-                 * Invariants:\n-                 *\n-                 *   all in (low, lower] < pivot\n-                 *   all in (k, upper)  == pivot\n-                 *   all in [upper, end] > pivot\n-                 *\n-                 * Pointer k is the last index of ?-part\n-                 *\/\n-                for (int k = ++upper; --k > lower; ) {\n-                    short ak = a[k];\n-\n-                    if (ak != pivot) {\n-                        a[k] = pivot;\n-\n-                        if (ak < pivot) { \/\/ Move a[k] to the left side\n-                            while (a[++lower] < pivot);\n-\n-                            if (a[lower] > pivot) {\n-                                a[--upper] = a[lower];\n-                            }\n-                            a[lower] = ak;\n-                        } else { \/\/ ak > pivot - Move a[k] to the right side\n-                            a[--upper] = ak;\n-                        }\n-                    }\n-                }\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2466,4 +2599,2 @@\n-                \/*\n-                 * Swap the pivot into its final position.\n-                 *\/\n-                a[low] = a[lower]; a[lower] = pivot;\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -2471,6 +2602,6 @@\n-                \/*\n-                 * Sort the right part, excluding known pivot.\n-                 * All elements from the central part are\n-                 * equal and therefore already sorted.\n-                 *\/\n-                sort(a, bits | 1, upper, high);\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2478,1 +2609,0 @@\n-            high = lower; \/\/ Iterate along the left part\n@@ -2480,0 +2610,7 @@\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n@@ -2489,1 +2626,1 @@\n-    private static void insertionSort(short[] a, int low, int high) {\n+    static void insertionSort(short[] a, int low, int high) {\n@@ -2494,4 +2631,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -2502,10 +2640,0 @@\n-    \/**\n-     * The number of distinct short values.\n-     *\/\n-    private static final int NUM_SHORT_VALUES = 1 << 16;\n-\n-    \/**\n-     * Max index of short counter.\n-     *\/\n-    private static final int MAX_SHORT_INDEX = Short.MAX_VALUE + NUM_SHORT_VALUES + 1;\n-\n@@ -2519,2 +2647,2 @@\n-    private static void countingSort(short[] a, int low, int high) {\n-        int[] count = new int[NUM_SHORT_VALUES];\n+    static void countingSort(short[] a, int low, int high) {\n+        int size = high - low;\n@@ -2522,4 +2650,5 @@\n-        \/*\n-         * Compute a histogram with the number of each values.\n-         *\/\n-        for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n@@ -2527,6 +2656,11 @@\n-        \/*\n-         * Place values on their final positions.\n-         *\/\n-        if (high - low > NUM_SHORT_VALUES) {\n-            for (int i = MAX_SHORT_INDEX; --i > Short.MAX_VALUE; ) {\n-                int value = i & 0xFFFF;\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i] & 0xFFFF]);\n+\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = Short.MIN_VALUE; high > low; ) {\n+                while (count[--value & 0xFFFF] == 0);\n+                int num = count[value & 0xFFFF];\n@@ -2534,3 +2668,3 @@\n-                for (low = high - count[value]; high > low;\n-                    a[--high] = (short) value\n-                );\n+                do {\n+                    a[--high] = (short) value;\n+                } while (--num > 0);\n@@ -2538,0 +2672,1 @@\n+\n@@ -2539,2 +2674,0 @@\n-            for (int i = MAX_SHORT_INDEX; high > low; ) {\n-                while (count[--i & 0xFFFF] == 0);\n@@ -2542,2 +2675,4 @@\n-                int value = i & 0xFFFF;\n-                int c = count[value];\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            short[] b = new short[size];\n@@ -2545,3 +2680,46 @@\n-                do {\n-                    a[--high] = (short) value;\n-                } while (--c > 0);\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n+\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF) ^ 0x80]; \/\/ Flip the sign bit\n+            }\n+\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF) ^ 0x80]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF) ^ 0x80] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n@@ -2552,1 +2730,6 @@\n-\/\/ [float]\n+\/\/ #[float]\n+\n+    \/**\n+     * The binary representation of float negative zero.\n+     *\/\n+    private static final int FLOAT_NEGATIVE_ZERO = Float.floatToRawIntBits(-0.0f);\n@@ -2556,1 +2739,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -2571,1 +2754,1 @@\n-         * Phase 1. Count the number of negative zero -0.0f,\n+         * Phase 1. Count the number of negative zero -0.0,\n@@ -2575,1 +2758,1 @@\n-        int numNegativeZero = 0;\n+        int negativeZeroCount = 0;\n@@ -2580,2 +2763,2 @@\n-            if (ak == 0.0f && Float.floatToRawIntBits(ak) < 0) { \/\/ ak is -0.0f\n-                numNegativeZero += 1;\n+            if (Float.floatToRawIntBits(ak) == FLOAT_NEGATIVE_ZERO) { \/\/ ak is -0.0\n+                negativeZeroCount++;\n@@ -2583,1 +2766,1 @@\n-            } else if (ak != ak) { \/\/ ak is NaN\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n@@ -2593,6 +2776,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            float[] b = depth == 0 ? null : new float[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -2604,2 +2783,2 @@\n-         * Phase 3. Turn positive zero 0.0f\n-         * back into negative zero -0.0f.\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0 back into negative zeros -0.0.\n@@ -2607,1 +2786,1 @@\n-        if (++numNegativeZero == 1) {\n+        if (++negativeZeroCount == 1) {\n@@ -2616,1 +2795,1 @@\n-            int middle = (low + high) >>> 1;\n+            int mid = (low + high) >>> 1;\n@@ -2618,2 +2797,2 @@\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n+            if (a[mid] < 0.0f) {\n+                low = mid + 1;\n@@ -2621,1 +2800,1 @@\n-                high = middle - 1;\n+                high = mid - 1;\n@@ -2626,1 +2805,1 @@\n-         * Replace the required number of 0.0f by -0.0f.\n+         * Replace 0.0 by negative zeros -0.0.\n@@ -2628,1 +2807,1 @@\n-        while (--numNegativeZero > 0) {\n+        while (--negativeZeroCount > 0) {\n@@ -2634,2 +2813,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -2637,1 +2815,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -2640,1 +2818,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -2644,1 +2822,1 @@\n-    static void sort(Sorter sorter, float[] a, int bits, int low, int high) {\n+    static void sort(Sorter<float[]> sorter, float[] a, int bits, int low, int high) {\n@@ -2646,9 +2824,1 @@\n-            int end = high - 1, size = high - low;\n-\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -2657,1 +2827,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -2659,2 +2829,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -2665,2 +2836,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -2668,2 +2838,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+                sort(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -2674,2 +2845,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -2677,2 +2847,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -2683,2 +2853,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -2686,1 +2857,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -2695,1 +2866,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -2699,1 +2870,0 @@\n-            float a3 = a[e3];\n@@ -2702,1 +2872,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -2705,17 +2875,22 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { float t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { float t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { float t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { float t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { float t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { float t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { float t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { float t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { float t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { float t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    float t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -2723,1 +2898,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    float t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -2725,3 +2900,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    float t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -2729,1 +2904,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    float t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -2733,3 +2908,13 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -2738,1 +2923,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -2742,8 +2927,3 @@\n-                \/*\n-                 * Use the first and fifth of the five sorted elements as\n-                 * the pivots. These values are inexpensive approximation\n-                 * of tertiles. Note, that pivot1 < pivot2.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -2755,2 +2935,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -2758,2 +2938,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -2762,1 +2942,4 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -2764,7 +2947,0 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(float.class, a, Unsafe.ARRAY_FLOAT_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n@@ -2777,1 +2953,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -2779,1 +2955,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -2782,1 +2958,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -2787,1 +2963,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -2789,1 +2965,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2794,1 +2970,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -2796,3 +2972,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -2800,1 +2979,0 @@\n-        int upper = end;\n@@ -2802,4 +2980,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        float pivot1 = a[e1];\n-        float pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        float pivot1 = a[pivotIndex1];\n+        float pivot2 = a[pivotIndex2];\n@@ -2814,2 +2995,2 @@\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -2826,13 +3007,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -2841,0 +3016,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2845,12 +3022,12 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n@@ -2858,1 +3035,2 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -2867,2 +3045,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -2870,1 +3048,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -2874,1 +3052,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -2876,1 +3054,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -2879,3 +3057,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n-     *\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -2883,3 +3061,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            float[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -2887,1 +3068,0 @@\n-        int upper = end;\n@@ -2889,2 +3069,5 @@\n-        int e3 = pivotIndex1;\n-        float pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        float pivot = a[pivotIndex1];\n@@ -2899,1 +3082,1 @@\n-        a[e3] = a[lower];\n+        a[pivotIndex1] = a[lower];\n@@ -2902,1 +3085,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n+         * Dutch National Flag partitioning\n@@ -2904,13 +3087,7 @@\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n-         *\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -2919,0 +3096,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -2920,1 +3099,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -2923,2 +3102,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -2926,2 +3107,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -2929,6 +3110,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -2936,0 +3113,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -2943,1 +3123,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -2947,1 +3128,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -2949,2 +3130,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -2962,4 +3143,11 @@\n-    private static void mixedInsertionSort(float[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n+    static void mixedInsertionSort(float[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            float ai = a[i = low], pin = a[--p];\n@@ -2968,1 +3156,1 @@\n-             * Invoke simple insertion sort on tiny array.\n+             * Swap larger element with pin.\n@@ -2970,7 +3158,3 @@\n-            for (int i; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -2978,1 +3162,0 @@\n-        } else {\n@@ -2981,7 +3164,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Insert element into sorted part.\n@@ -2989,40 +3166,2 @@\n-            float pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                float ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n@@ -3030,0 +3169,8 @@\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            float a1 = a[i = low], a2 = a[++low];\n@@ -3032,1 +3179,3 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n@@ -3034,9 +3183,1 @@\n-            for (int i; low < high; ++low) {\n-                float a1 = a[i = low], a2 = a[++low];\n-\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+            if (a1 > a2) {\n@@ -3044,9 +3185,4 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n-\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3054,1 +3190,4 @@\n-                } else if (a1 < a[i - 1]) {\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3056,4 +3195,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -3061,4 +3197,2 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n@@ -3066,14 +3200,1 @@\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Sorts the specified range of the array using insertion sort.\n-     *\n-     * @param a the array to be sorted\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void insertionSort(float[] a, int low, int high) {\n-        for (int i, k = low; ++k < high; ) {\n-            float ai = a[i = k];\n+                a[++i + 1] = a2;\n@@ -3081,2 +3202,1 @@\n-            if (ai < a[i - 1]) {\n-                while (--i >= low && ai < a[i]) {\n+                while (a1 < a[--i]) {\n@@ -3085,1 +3205,1 @@\n-                a[i + 1] = ai;\n+                a[i + 1] = a1;\n@@ -3091,1 +3211,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Sorts the specified range of the array using insertion sort.\n@@ -3097,32 +3217,10 @@\n-    private static void heapSort(float[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            float max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(float[] a, int p, float value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n+    static void insertionSort(float[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            float ai = a[i = k];\n+\n+            if (ai < a[i - 1]) {\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -3131,1 +3229,0 @@\n-        a[p] = value;\n@@ -3135,1 +3232,1 @@\n-     * Tries to sort the specified range of the array.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3137,1 +3234,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -3139,3 +3236,3 @@\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3143,2 +3240,1 @@\n-    private static boolean tryMergeRuns(Sorter sorter, float[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<float[]> sorter, float[] a, int low, int high) {\n@@ -3146,3 +3242,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -3150,0 +3245,1 @@\n+        int count = 1;\n@@ -3151,2 +3247,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -3157,2 +3251,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -3160,1 +3253,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -3176,0 +3269,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -3179,0 +3278,1 @@\n+                \/\/ Check the next sequence\n@@ -3185,1 +3285,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -3188,1 +3288,0 @@\n-                if (k == high) {\n@@ -3190,0 +3289,1 @@\n+                if (k == high) {\n@@ -3191,1 +3291,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -3196,11 +3296,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -3209,3 +3299,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -3213,0 +3301,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -3214,2 +3303,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -3220,2 +3309,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -3227,0 +3315,1 @@\n+            }\n@@ -3228,1 +3317,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -3230,5 +3322,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -3236,1 +3328,0 @@\n-            run[count] = (last = k);\n@@ -3240,1 +3331,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -3245,3 +3336,1 @@\n-            if (sorter == null || (b = (float[]) sorter.b) == null) {\n-                b = new float[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -3249,0 +3338,2 @@\n+            } else if ((b = tryAllocate(float[].class, high - low)) == null) {\n+                return false;\n@@ -3250,1 +3341,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -3258,0 +3349,1 @@\n+     * @param sorter the parallel context\n@@ -3259,1 +3351,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -3261,2 +3353,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -3266,1 +3357,0 @@\n-     * @return the destination where runs are merged\n@@ -3268,2 +3358,2 @@\n-    private static float[] mergeRuns(float[] a, float[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<float[]> sorter, float[] a, float[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -3272,2 +3362,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -3275,4 +3365,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -3282,1 +3369,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -3284,2 +3371,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -3288,1 +3375,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -3290,1 +3377,2 @@\n-        float[] a1, a2;\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -3292,8 +3380,2 @@\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (float[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        float[] dst = aim ? a : b;\n+        float[] src = aim ? b : a;\n@@ -3301,1 +3383,5 @@\n-        float[] dst = a1 == a ? b : a;\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -3303,8 +3389,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n-\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -3312,1 +3395,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -3314,1 +3397,0 @@\n-        return dst;\n@@ -3318,1 +3400,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -3320,1 +3402,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -3323,1 +3405,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -3326,1 +3408,0 @@\n-     * @param a2 the second part\n@@ -3330,2 +3411,2 @@\n-    private static void mergeParts(Merger merger, float[] dst, int k,\n-            float[] a1, int lo1, int hi1, float[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<float[]> merger, float[] dst, int k,\n+            float[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -3333,1 +3414,8 @@\n-        if (merger != null && a1 == a2) {\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n@@ -3335,1 +3423,6 @@\n-            while (true) {\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n@@ -3337,7 +3430,6 @@\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            float key = src[mi1];\n@@ -3345,5 +3437,10 @@\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n@@ -3351,0 +3448,1 @@\n+            }\n@@ -3352,6 +3450,4 @@\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                float key = a1[mi1];\n-                int mi2 = hi2;\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -3359,5 +3455,4 @@\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -3365,6 +3460,6 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n@@ -3372,1 +3467,10 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+        }\n+    }\n@@ -3374,4 +3478,13 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(float[] dst, int k,\n+            float[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -3379,5 +3492,32 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                float next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                float next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                float next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n@@ -3388,1 +3528,1 @@\n-         * Merge small parts sequentially.\n+         * Copy the tail of the left and right parts.\n@@ -3390,2 +3530,14 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(float[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n@@ -3393,4 +3545,4 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n-            }\n+        while (--high > low) {\n+            float max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n@@ -3398,3 +3550,23 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(float[] a, int p, float value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -3403,0 +3575,1 @@\n+        a[p] = value;\n@@ -3405,1 +3578,6 @@\n-\/\/ [double]\n+\/\/ #[double]\n+\n+    \/**\n+     * The binary representation of double negative zero.\n+     *\/\n+    private static final long DOUBLE_NEGATIVE_ZERO = Double.doubleToRawLongBits(-0.0d);\n@@ -3409,1 +3587,1 @@\n-     * sort and\/or Dual-Pivot Quicksort.\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n@@ -3424,1 +3602,1 @@\n-         * Phase 1. Count the number of negative zero -0.0d,\n+         * Phase 1. Count the number of negative zero -0.0,\n@@ -3428,1 +3606,1 @@\n-        int numNegativeZero = 0;\n+        int negativeZeroCount = 0;\n@@ -3433,2 +3611,2 @@\n-            if (ak == 0.0d && Double.doubleToRawLongBits(ak) < 0) { \/\/ ak is -0.0d\n-                numNegativeZero += 1;\n+            if (Double.doubleToRawLongBits(ak) == DOUBLE_NEGATIVE_ZERO) { \/\/ ak is -0.0\n+                negativeZeroCount++;\n@@ -3436,1 +3614,1 @@\n-            } else if (ak != ak) { \/\/ ak is NaN\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n@@ -3446,6 +3624,2 @@\n-        int size = high - low;\n-\n-        if (parallelism > 1 && size > MIN_PARALLEL_SORT_SIZE) {\n-            int depth = getDepth(parallelism, size >> 12);\n-            double[] b = depth == 0 ? null : new double[size];\n-            new Sorter(null, a, b, low, size, low, depth).invoke();\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n@@ -3457,2 +3631,2 @@\n-         * Phase 3. Turn positive zero 0.0d\n-         * back into negative zero -0.0d.\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0 back into negative zeros -0.0.\n@@ -3460,1 +3634,1 @@\n-        if (++numNegativeZero == 1) {\n+        if (++negativeZeroCount == 1) {\n@@ -3469,1 +3643,1 @@\n-            int middle = (low + high) >>> 1;\n+            int mid = (low + high) >>> 1;\n@@ -3471,2 +3645,2 @@\n-            if (a[middle] < 0) {\n-                low = middle + 1;\n+            if (a[mid] < 0.0d) {\n+                low = mid + 1;\n@@ -3474,1 +3648,1 @@\n-                high = middle - 1;\n+                high = mid - 1;\n@@ -3479,1 +3653,1 @@\n-         * Replace the required number of 0.0d by -0.0d.\n+         * Replace 0.0 by negative zeros -0.0.\n@@ -3481,1 +3655,1 @@\n-        while (--numNegativeZero > 0) {\n+        while (--negativeZeroCount > 0) {\n@@ -3487,2 +3661,1 @@\n-     * Sorts the specified array using the Dual-Pivot Quicksort and\/or\n-     * other sorts in special-cases, possibly with parallel partitions.\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n@@ -3490,1 +3663,1 @@\n-     * @param sorter parallel context\n+     * @param sorter the parallel context\n@@ -3493,1 +3666,1 @@\n-     *        the right bit \"0\" indicates that array is the leftmost part\n+     *        the right bit \"0\" indicates that range is the leftmost part\n@@ -3497,1 +3670,1 @@\n-    static void sort(Sorter sorter, double[] a, int bits, int low, int high) {\n+    static void sort(Sorter<double[]> sorter, double[] a, int bits, int low, int high) {\n@@ -3499,8 +3672,1 @@\n-            int end = high - 1, size = high - low;\n-            \/*\n-             * Run mixed insertion sort on small non-leftmost parts.\n-             *\/\n-            if (size < MAX_MIXED_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::mixedInsertionSort);\n-                return;\n-            }\n+            int size = high - low;\n@@ -3509,1 +3675,1 @@\n-             * Invoke insertion sort on small leftmost part.\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n@@ -3511,2 +3677,3 @@\n-            if (size < MAX_INSERTION_SORT_SIZE) {\n-                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, DualPivotQuicksort::insertionSort);\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n@@ -3517,2 +3684,1 @@\n-             * Check if the whole array or large non-leftmost\n-             * parts are nearly sorted and then merge runs.\n+             * Invoke adaptive insertion sort on small leftmost part.\n@@ -3520,2 +3686,3 @@\n-            if ((bits == 0 || size > MIN_TRY_MERGE_SIZE && (bits & 1) > 0)\n-                    && tryMergeRuns(sorter, a, low, size)) {\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+                sort(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n@@ -3526,2 +3693,1 @@\n-             * Switch to heap sort if execution\n-             * time is becoming quadratic.\n+             * Try merging sort on large part.\n@@ -3529,2 +3695,2 @@\n-            if ((bits += DELTA) > MAX_RECURSION_DEPTH) {\n-                heapSort(a, low, high);\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n@@ -3535,2 +3701,3 @@\n-             * Use an inexpensive approximation of the golden ratio\n-             * to select five sample elements and determine pivots.\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n@@ -3538,1 +3705,1 @@\n-            int step = (size >> 3) * 3 + 3;\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n@@ -3547,1 +3714,1 @@\n-            int e5 = end - step;\n+            int e5 = high - step;\n@@ -3551,1 +3718,0 @@\n-            double a3 = a[e3];\n@@ -3554,1 +3720,1 @@\n-             * Sort these elements in place by the combination\n+             * Sort these elements in-place by the combination\n@@ -3557,17 +3723,22 @@\n-             *    5 ------o-----------o------------\n-             *            |           |\n-             *    4 ------|-----o-----o-----o------\n-             *            |     |           |\n-             *    2 ------o-----|-----o-----o------\n-             *                  |     |\n-             *    1 ------------o-----o------------\n-             *\/\n-            if (a[e5] < a[e2]) { double t = a[e5]; a[e5] = a[e2]; a[e2] = t; }\n-            if (a[e4] < a[e1]) { double t = a[e4]; a[e4] = a[e1]; a[e1] = t; }\n-            if (a[e5] < a[e4]) { double t = a[e5]; a[e5] = a[e4]; a[e4] = t; }\n-            if (a[e2] < a[e1]) { double t = a[e2]; a[e2] = a[e1]; a[e1] = t; }\n-            if (a[e4] < a[e2]) { double t = a[e4]; a[e4] = a[e2]; a[e2] = t; }\n-\n-            if (a3 < a[e2]) {\n-                if (a3 < a[e1]) {\n-                    a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = a3;\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { double t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { double t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { double t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { double t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { double t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    double t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n@@ -3575,1 +3746,1 @@\n-                    a[e3] = a[e2]; a[e2] = a3;\n+                    double t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n@@ -3577,3 +3748,3 @@\n-            } else if (a3 > a[e4]) {\n-                if (a3 > a[e5]) {\n-                    a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = a3;\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    double t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n@@ -3581,1 +3752,1 @@\n-                    a[e3] = a[e4]; a[e4] = a3;\n+                    double t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n@@ -3585,3 +3756,13 @@\n-            \/\/ Pointers\n-            int lower; \/\/ The index of the last element of the left part\n-            int upper; \/\/ The index of the first element of the right part\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n@@ -3590,1 +3771,1 @@\n-             * Partitioning with 2 pivots in case of different elements.\n+             * Partitioning with two pivots on array of fully random elements.\n@@ -3594,8 +3775,3 @@\n-                \/*\n-                * Use the first and fifth of the five sorted elements as\n-                * the pivots. These values are inexpensive approximation\n-                * of tertiles. Note, that pivot1 < pivot2.\n-                *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e1, e5, DualPivotQuicksort::partitionDualPivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n@@ -3607,2 +3783,2 @@\n-                    sorter.forkSorter(bits | 1, lower + 1, upper);\n-                    sorter.forkSorter(bits | 1, upper + 1, high);\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n@@ -3610,2 +3786,2 @@\n-                    sort(sorter, a, bits | 1, lower + 1, upper);\n-                    sort(sorter, a, bits | 1, upper + 1, high);\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n@@ -3614,1 +3790,1 @@\n-            } else { \/\/ Use single pivot in case of many equal elements\n+            } else { \/\/ Partitioning with one pivot\n@@ -3616,7 +3792,2 @@\n-                \/*\n-                 * Use the third of the five sorted elements as the pivot.\n-                 * This value is inexpensive approximation of the median.\n-                 *\/\n-                int[] pivotIndices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET, low, high, e3, e3, DualPivotQuicksort::partitionSinglePivot);\n-                lower = pivotIndices[0];\n-                upper = pivotIndices[1];\n+                indices = partition(double.class, a, Unsafe.ARRAY_DOUBLE_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n@@ -3630,1 +3801,1 @@\n-                    sorter.forkSorter(bits | 1, upper, high);\n+                    sorter.fork(bits | 1, indices[1], high);\n@@ -3632,1 +3803,1 @@\n-                    sort(sorter, a, bits | 1, upper, high);\n+                    sort(sorter, a, bits | 1, indices[1], high);\n@@ -3635,1 +3806,1 @@\n-            high = lower; \/\/ Iterate along the left part\n+            high = indices[0]; \/\/ Iterate along the left part\n@@ -3640,1 +3811,1 @@\n-     * Partitions the specified range of the array using the two pivots provided.\n+     * Partitions the specified range of the array using two given pivots.\n@@ -3642,1 +3813,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3647,1 +3818,1 @@\n-     *\n+     * @return indices of parts after partitioning\n@@ -3649,3 +3820,6 @@\n-    @ForceInline\n-    private static int[] partitionDualPivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-        int end = high - 1;\n+    private static int[] partitionWithTwoPivots(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n@@ -3653,1 +3827,0 @@\n-        int upper = end;\n@@ -3655,4 +3828,7 @@\n-        int e1 = pivotIndex1;\n-        int e5 = pivotIndex2;\n-        double pivot1 = a[e1];\n-        double pivot2 = a[e5];\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        double pivot1 = a[pivotIndex1];\n+        double pivot2 = a[pivotIndex2];\n@@ -3661,8 +3837,8 @@\n-        * The first and the last elements to be sorted are moved\n-        * to the locations formerly occupied by the pivots. When\n-        * partitioning is completed, the pivots are swapped back\n-        * into their final positions, and excluded from the next\n-        * subsequent sorting.\n-        *\/\n-        a[e1] = a[lower];\n-        a[e5] = a[upper];\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n@@ -3671,2 +3847,2 @@\n-        * Skip elements, which are less or greater than the pivots.\n-        *\/\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n@@ -3679,13 +3855,7 @@\n-         *   left part                 central part          right part\n-         * +------------------------------------------------------------+\n-                  * |  < pivot1  |   ?   |  pivot1 <= && <= pivot2  |  > pivot2  |\n-         * +------------------------------------------------------------+\n-         *             ^       ^                            ^\n-         *             |       |                            |\n-         *           lower     k                          upper\n-         *\n-         * Invariants:\n-         *\n-         *              all in (low, lower] < pivot1\n-         *    pivot1 <= all in (k, upper)  <= pivot2\n-         *              all in [upper, end) > pivot2\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n@@ -3694,0 +3864,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3698,12 +3870,12 @@\n-            if (ak < pivot1) { \/\/ Move a[k] to the left side\n-                while (lower < k) {\n-                    if (a[++lower] >= pivot1) {\n-                        if (a[lower] > pivot2) {\n-                            a[k] = a[--upper];\n-                            a[upper] = a[lower];\n-                        } else {\n-                            a[k] = a[lower];\n-                        }\n-                        a[lower] = ak;\n-                        break;\n-                    }\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n@@ -3711,1 +3883,2 @@\n-            } else if (ak > pivot2) { \/\/ Move a[k] to the right side\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n@@ -3720,2 +3893,2 @@\n-        a[low] = a[lower]; a[lower] = pivot1;\n-        a[end] = a[upper]; a[upper] = pivot2;\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n@@ -3723,1 +3896,1 @@\n-        return new int[] {lower, upper};\n+        return new int[] { lower, upper };\n@@ -3727,1 +3900,1 @@\n-     * Partitions the specified range of the array using a single pivot provided.\n+     * Partitions the specified range of the array using one given pivot.\n@@ -3729,1 +3902,1 @@\n-     * @param array the array to be partitioned\n+     * @param a the array for partitioning\n@@ -3732,2 +3905,3 @@\n-     * @param pivotIndex1 the index of pivot1, the first pivot\n-     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n@@ -3735,4 +3909,6 @@\n-    @ForceInline\n-    private static int[] partitionSinglePivot(double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n-\n-        int end = high - 1;\n+    private static int[] partitionWithOnePivot(\n+            double[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n@@ -3740,1 +3916,0 @@\n-        int upper = end;\n@@ -3742,2 +3917,5 @@\n-        int e3 = pivotIndex1;\n-        double pivot = a[e3];\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        double pivot = a[pivotIndex1];\n@@ -3746,7 +3924,7 @@\n-        * The first element to be sorted is moved to the\n-        * location formerly occupied by the pivot. After\n-        * completion of partitioning the pivot is swapped\n-        * back into its final position, and excluded from\n-        * the next subsequent sorting.\n-        *\/\n-        a[e3] = a[lower];\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n@@ -3755,9 +3933,1 @@\n-         * Traditional 3-way (Dutch National Flag) partitioning\n-         *\n-         *   left part                 central part    right part\n-         * +------------------------------------------------------+\n-         * |   < pivot   |     ?     |   == pivot   |   > pivot   |\n-         * +------------------------------------------------------+\n-         *              ^           ^                ^\n-         *              |           |                |\n-         *            lower         k              upper\n+         * Dutch National Flag partitioning\n@@ -3765,5 +3935,7 @@\n-         * Invariants:\n-         *\n-         *   all in (low, lower] < pivot\n-         *   all in (k, upper)  == pivot\n-         *   all in [upper, end] > pivot\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n@@ -3772,0 +3944,2 @@\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n@@ -3773,1 +3947,1 @@\n-        for (int k = ++upper; --k > lower; ) {\n+        for (int k = upper; --k > lower; ) {\n@@ -3776,2 +3950,4 @@\n-            if (ak != pivot) {\n-                a[k] = pivot;\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n@@ -3779,2 +3955,2 @@\n-                if (ak < pivot) { \/\/ Move a[k] to the left side\n-                    while (a[++lower] < pivot);\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n@@ -3782,6 +3958,2 @@\n-                    if (a[lower] > pivot) {\n-                        a[--upper] = a[lower];\n-                    }\n-                    a[lower] = ak;\n-                } else { \/\/ ak > pivot - Move a[k] to the right side\n-                    a[--upper] = ak;\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n@@ -3789,0 +3961,3 @@\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n@@ -3796,1 +3971,2 @@\n-        return new int[] {lower, upper};\n+\n+        return new int[] { lower, upper };\n@@ -3800,1 +3976,1 @@\n-     * Sorts the specified range of the array using mixed insertion sort.\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n@@ -3802,2 +3978,2 @@\n-     * Mixed insertion sort is combination of simple insertion sort,\n-     * pin insertion sort and pair insertion sort.\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n@@ -3815,10 +3991,5 @@\n-    private static void mixedInsertionSort(double[] a, int low, int high) {\n-        int size = high - low;\n-        int end = high - 3 * ((size >> 5) << 3);\n-        if (end == high) {\n-\n-            \/*\n-             * Invoke simple insertion sort on tiny array.\n-             *\/\n-            for (int i; ++low < end; ) {\n-                double ai = a[i = low];\n+    static void mixedInsertionSort(double[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n@@ -3826,6 +3997,5 @@\n-                while (ai < a[--i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n-            }\n-        } else {\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            double ai = a[i = low], pin = a[--p];\n@@ -3834,7 +4004,1 @@\n-             * Start with pin insertion sort on small part.\n-             *\n-             * Pin insertion sort is extended simple insertion sort.\n-             * The main idea of this sort is to put elements larger\n-             * than an element called pin to the end of array (the\n-             * proper area for such elements). It avoids expensive\n-             * movements of these elements through the whole array.\n+             * Swap larger element with pin.\n@@ -3842,40 +4006,3 @@\n-            double pin = a[end];\n-\n-            for (int i, p = high; ++low < end; ) {\n-                double ai = a[i = low];\n-\n-                if (ai < a[i - 1]) { \/\/ Small element\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    a[i] = a[--i];\n-\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-\n-                } else if (p > i && ai > pin) { \/\/ Large element\n-\n-                    \/*\n-                     * Find element smaller than pin.\n-                     *\/\n-                    while (a[--p] > pin);\n-\n-                    \/*\n-                     * Swap it with large element.\n-                     *\/\n-                    if (p > i) {\n-                        ai = a[p];\n-                        a[p] = a[i];\n-                    }\n-\n-                    \/*\n-                     * Insert small element into sorted part.\n-                     *\/\n-                    while (ai < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = ai;\n-                }\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n@@ -3885,1 +4012,1 @@\n-             * Continue with pair insertion sort on remain part.\n+             * Insert element into sorted part.\n@@ -3887,2 +4014,5 @@\n-            for (int i; low < high; ++low) {\n-                double a1 = a[i = low], a2 = a[++low];\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n@@ -3890,6 +4020,5 @@\n-                \/*\n-                 * Insert two elements per iteration: at first, insert the\n-                 * larger element and then insert the smaller element, but\n-                 * from the position where the larger element was inserted.\n-                 *\/\n-                if (a1 > a2) {\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            double a1 = a[i = low], a2 = a[++low];\n@@ -3897,4 +4026,6 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a1;\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n@@ -3902,4 +4033,4 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a2;\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n@@ -3907,1 +4038,4 @@\n-                } else if (a1 < a[i - 1]) {\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n@@ -3909,4 +4043,1 @@\n-                    while (a2 < a[--i]) {\n-                        a[i + 2] = a[i];\n-                    }\n-                    a[++i + 1] = a2;\n+            } else if (a1 < a[i - 1]) {\n@@ -3914,4 +4045,7 @@\n-                    while (a1 < a[--i]) {\n-                        a[i + 1] = a[i];\n-                    }\n-                    a[i + 1] = a1;\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n@@ -3919,0 +4053,1 @@\n+                a[i + 1] = a1;\n@@ -3930,1 +4065,1 @@\n-    private static void insertionSort(double[] a, int low, int high) {\n+    static void insertionSort(double[] a, int low, int high) {\n@@ -3935,4 +4070,5 @@\n-                while (--i >= low && ai < a[i]) {\n-                    a[i + 1] = a[i];\n-                }\n-                a[i + 1] = ai;\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n@@ -3944,1 +4080,1 @@\n-     * Sorts the specified range of the array using heap sort.\n+     * Tries to sort the specified range of the array using merging sort.\n@@ -3946,0 +4082,1 @@\n+     * @param sorter the parallel context\n@@ -3949,0 +4086,1 @@\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n@@ -3950,48 +4088,1 @@\n-    private static void heapSort(double[] a, int low, int high) {\n-        for (int k = (low + high) >>> 1; k > low; ) {\n-            pushDown(a, --k, a[k], low, high);\n-        }\n-        while (--high > low) {\n-            double max = a[low];\n-            pushDown(a, low, a[high], low, high);\n-            a[high] = max;\n-        }\n-    }\n-\n-    \/**\n-     * Pushes specified element down during heap sort.\n-     *\n-     * @param a the given array\n-     * @param p the start index\n-     * @param value the given element\n-     * @param low the index of the first element, inclusive, to be sorted\n-     * @param high the index of the last element, exclusive, to be sorted\n-     *\/\n-    private static void pushDown(double[] a, int p, double value, int low, int high) {\n-        for (int k ;; a[p] = a[p = k]) {\n-            k = (p << 1) - low + 2; \/\/ Index of the right child\n-\n-            if (k > high) {\n-                break;\n-            }\n-            if (k == high || a[k] < a[k - 1]) {\n-                --k;\n-            }\n-            if (a[k] <= value) {\n-                break;\n-            }\n-        }\n-        a[p] = value;\n-    }\n-\n-    \/**\n-     * Tries to sort the specified range of the array.\n-     *\n-     * @param sorter parallel context\n-     * @param a the array to be sorted\n-     * @param low the index of the first element to be sorted\n-     * @param size the array size\n-     * @return true if finally sorted, false otherwise\n-     *\/\n-    private static boolean tryMergeRuns(Sorter sorter, double[] a, int low, int size) {\n-\n+    static boolean tryMergingSort(Sorter<double[]> sorter, double[] a, int low, int high) {\n@@ -3999,3 +4090,2 @@\n-         * The run array is constructed only if initial runs are\n-         * long enough to continue, run[i] then holds start index\n-         * of the i-th sequence of elements in non-descending order.\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n@@ -4003,0 +4093,1 @@\n+        int count = 1;\n@@ -4004,2 +4095,0 @@\n-        int high = low + size;\n-        int count = 1, last = low;\n@@ -4010,2 +4099,1 @@\n-        for (int k = low + 1; k < high; ) {\n-\n+        for (int k = low + 1, last = low; k < high; ) {\n@@ -4013,1 +4101,1 @@\n-             * Find the end index of the current run.\n+             * Find the next run.\n@@ -4029,0 +4117,6 @@\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n@@ -4032,0 +4126,1 @@\n+                \/\/ Check the next sequence\n@@ -4038,1 +4133,1 @@\n-             * Check special cases.\n+             * Process the current run.\n@@ -4041,1 +4136,0 @@\n-                if (k == high) {\n@@ -4043,0 +4137,1 @@\n+                if (k == high) {\n@@ -4044,1 +4139,1 @@\n-                     * The array is monotonous sequence,\n+                     * Array is monotonous sequence\n@@ -4049,11 +4144,1 @@\n-\n-                if (k - low < MIN_FIRST_RUN_SIZE) {\n-\n-                    \/*\n-                     * The first run is too small\n-                     * to proceed with scanning.\n-                     *\/\n-                    return false;\n-                }\n-\n-                run = new int[((size >> 10) | 0x7F) & 0x3FF];\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n@@ -4062,3 +4147,1 @@\n-            } else if (a[last - 1] > a[last]) {\n-\n-                if (count > (k - low) >> MIN_FIRST_RUNS_FACTOR) {\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n@@ -4066,0 +4149,1 @@\n+                if (k - low < count * MIN_RUN_SIZE) {\n@@ -4067,2 +4151,2 @@\n-                     * The first runs are not long\n-                     * enough to continue scanning.\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n@@ -4073,2 +4157,1 @@\n-                if (++count == MAX_RUN_CAPACITY) {\n-\n+                if (++count == run.length) {\n@@ -4080,0 +4163,1 @@\n+            }\n@@ -4081,1 +4165,4 @@\n-                if (count == run.length) {\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n@@ -4083,5 +4170,5 @@\n-                    \/*\n-                     * Increase capacity of index array.\n-                     *\/\n-                    run = Arrays.copyOf(run, count << 1);\n-                }\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n@@ -4089,1 +4176,0 @@\n-            run[count] = (last = k);\n@@ -4093,1 +4179,1 @@\n-         * Merge runs of highly structured array.\n+         * Merge all runs.\n@@ -4098,3 +4184,1 @@\n-            if (sorter == null || (b = (double[]) sorter.b) == null) {\n-                b = new double[size];\n-            } else {\n+            if (sorter != null && (b = sorter.b) != null) {\n@@ -4102,0 +4186,2 @@\n+            } else if ((b = tryAllocate(double[].class, high - low)) == null) {\n+                return false;\n@@ -4103,1 +4189,1 @@\n-            mergeRuns(a, b, offset, 1, sorter != null, run, 0, count);\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n@@ -4111,0 +4197,1 @@\n+     * @param sorter the parallel context\n@@ -4112,1 +4199,1 @@\n-     * @param b the temporary buffer used in merging\n+     * @param b the buffer for merging\n@@ -4114,2 +4201,1 @@\n-     * @param aim specifies merging: to source ( > 0), buffer ( < 0) or any ( == 0)\n-     * @param parallel indicates whether merging is performed in parallel\n+     * @param aim whether the original array is used for merging\n@@ -4119,1 +4205,0 @@\n-     * @return the destination where runs are merged\n@@ -4121,2 +4206,2 @@\n-    private static double[] mergeRuns(double[] a, double[] b, int offset,\n-            int aim, boolean parallel, int[] run, int lo, int hi) {\n+    private static void mergeRuns(Sorter<double[]> sorter, double[] a, double[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n@@ -4125,2 +4210,2 @@\n-            if (aim >= 0) {\n-                return a;\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n@@ -4128,4 +4213,1 @@\n-            for (int i = run[hi], j = i - offset, low = run[lo]; i > low;\n-                b[--j] = a[--i]\n-            );\n-            return b;\n+            return;\n@@ -4135,1 +4217,1 @@\n-         * Split into approximately equal parts.\n+         * Split the array into two approximately equal parts.\n@@ -4137,2 +4219,2 @@\n-        int mi = lo, rmi = (run[lo] + run[hi]) >>> 1;\n-        while (run[++mi + 1] <= rmi);\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n@@ -4141,1 +4223,1 @@\n-         * Merge the left and right parts.\n+         * Merge the runs of all parts.\n@@ -4143,10 +4225,2 @@\n-        double[] a1, a2;\n-\n-        if (parallel && hi - lo > MIN_RUN_COUNT) {\n-            RunMerger merger = new RunMerger(a, b, offset, 0, run, mi, hi).forkMe();\n-            a1 = mergeRuns(a, b, offset, -aim, true, run, lo, mi);\n-            a2 = (double[]) merger.getDestination();\n-        } else {\n-            a1 = mergeRuns(a, b, offset, -aim, false, run, lo, mi);\n-            a2 = mergeRuns(a, b, offset,    0, false, run, mi, hi);\n-        }\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n@@ -4154,1 +4228,2 @@\n-        double[] dst = a1 == a ? b : a;\n+        double[] dst = aim ? a : b;\n+        double[] src = aim ? b : a;\n@@ -4156,5 +4231,5 @@\n-        int k   = a1 == a ? run[lo] - offset : run[lo];\n-        int lo1 = a1 == b ? run[lo] - offset : run[lo];\n-        int hi1 = a1 == b ? run[mi] - offset : run[mi];\n-        int lo2 = a2 == b ? run[mi] - offset : run[mi];\n-        int hi2 = a2 == b ? run[hi] - offset : run[hi];\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n@@ -4162,2 +4237,5 @@\n-        if (parallel) {\n-            new Merger(null, dst, k, a1, lo1, hi1, a2, lo2, hi2).invoke();\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n@@ -4165,1 +4243,1 @@\n-            mergeParts(null, dst, k, a1, lo1, hi1, a2, lo2, hi2);\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n@@ -4167,1 +4245,0 @@\n-        return dst;\n@@ -4171,1 +4248,1 @@\n-     * Merges the sorted parts.\n+     * Merges the sorted parts in parallel.\n@@ -4173,1 +4250,1 @@\n-     * @param merger parallel context\n+     * @param merger the parallel context\n@@ -4176,1 +4253,1 @@\n-     * @param a1 the first part\n+     * @param src the source array\n@@ -4179,1 +4256,0 @@\n-     * @param a2 the second part\n@@ -4183,2 +4259,2 @@\n-    private static void mergeParts(Merger merger, double[] dst, int k,\n-            double[] a1, int lo1, int hi1, double[] a2, int lo2, int hi2) {\n+    private static void mergeParts(Merger<double[]> merger, double[] dst, int k,\n+            double[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -4186,1 +4262,8 @@\n-        if (merger != null && a1 == a2) {\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n@@ -4188,1 +4271,6 @@\n-            while (true) {\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n@@ -4190,7 +4278,6 @@\n-                \/*\n-                 * The first part must be larger.\n-                 *\/\n-                if (hi1 - lo1 < hi2 - lo2) {\n-                    int lo = lo1; lo1 = lo2; lo2 = lo;\n-                    int hi = hi1; hi1 = hi2; hi2 = hi;\n-                }\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            double key = src[mi1];\n@@ -4198,5 +4285,10 @@\n-                \/*\n-                 * Small parts will be merged sequentially.\n-                 *\/\n-                if (hi1 - lo1 < MIN_PARALLEL_MERGE_PARTS_SIZE) {\n-                    break;\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n@@ -4204,0 +4296,1 @@\n+            }\n@@ -4205,6 +4298,4 @@\n-                \/*\n-                 * Find the median of the larger part.\n-                 *\/\n-                int mi1 = (lo1 + hi1) >>> 1;\n-                double key = a1[mi1];\n-                int mi2 = hi2;\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n@@ -4212,5 +4303,4 @@\n-                \/*\n-                 * Partition the smaller part.\n-                 *\/\n-                for (int loo = lo2; loo < mi2; ) {\n-                    int t = (loo + mi2) >>> 1;\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n@@ -4218,6 +4308,6 @@\n-                    if (key > a2[t]) {\n-                        loo = t + 1;\n-                    } else {\n-                        mi2 = t;\n-                    }\n-                }\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n@@ -4225,1 +4315,10 @@\n-                int d = mi2 - lo2 + mi1 - lo1;\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+        }\n+    }\n@@ -4227,4 +4326,13 @@\n-                \/*\n-                 * Merge the right sub-parts in parallel.\n-                 *\/\n-                merger.forkMerger(dst, k + d, a1, mi1, hi1, a2, mi2, hi2);\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(double[] dst, int k,\n+            double[] src, int lo1, int hi1, int lo2, int hi2) {\n@@ -4232,5 +4340,32 @@\n-                \/*\n-                 * Process the sub-left parts.\n-                 *\/\n-                hi1 = mi1;\n-                hi2 = mi2;\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                double next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                double next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                double next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n@@ -4241,1 +4376,1 @@\n-         * Merge small parts sequentially.\n+         * Copy the tail of the left and right parts.\n@@ -4243,2 +4378,14 @@\n-        while (lo1 < hi1 && lo2 < hi2) {\n-            dst[k++] = a1[lo1] < a2[lo2] ? a1[lo1++] : a2[lo2++];\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort(double[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n@@ -4246,3 +4393,28 @@\n-        if (dst != a1 || k < lo1) {\n-            while (lo1 < hi1) {\n-                dst[k++] = a1[lo1++];\n+        while (--high > low) {\n+            double max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown(double[] a, int p, double value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n@@ -4251,3 +4423,18 @@\n-        if (dst != a2 || k < lo2) {\n-            while (lo2 < hi2) {\n-                dst[k++] = a2[lo2++];\n+        a[p] = value;\n+    }\n+\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n@@ -4255,0 +4442,12 @@\n+            if (c > 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n@@ -4256,0 +4455,1 @@\n+        return true;\n@@ -4258,1 +4458,1 @@\n-\/\/ [class]\n+\/\/ #[class]\n@@ -4261,1 +4461,3 @@\n-     * This class implements parallel sorting.\n+     * Implementation of parallel sorting.\n+     *\n+     * @param <T> the class of array\n@@ -4263,2 +4465,5 @@\n-    private static final class Sorter extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4266,1 +4471,1 @@\n-        private final Object a, b;\n+        private final T a, b;\n@@ -4269,0 +4474,10 @@\n+        @SuppressWarnings(\"unchecked\")\n+        private Sorter(T a, int parallelism, int low, int size) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+            this.b = (T) tryAllocate(a.getClass(), size);\n+            this.depth = b == null ? 0 : ((parallelism >> 7) + 2) * (-2);\n+        }\n+\n@@ -4270,1 +4485,1 @@\n-                Object a, Object b, int low, int size, int offset, int depth) {\n+                T a, T b, int low, int size, int offset, int depth) {\n@@ -4281,1 +4496,2 @@\n-        public final void compute() {\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n@@ -4285,2 +4501,2 @@\n-                new Sorter(this, b, a, low, half, offset, depth + 1).fork();\n-                new Sorter(this, b, a, low + half, size - half, offset, depth + 1).compute();\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\n@@ -4288,11 +4504,6 @@\n-                if (a instanceof int[]) {\n-                    sort(this, (int[]) a, depth, low, low + size);\n-                } else if (a instanceof long[]) {\n-                    sort(this, (long[]) a, depth, low, low + size);\n-                } else if (a instanceof float[]) {\n-                    sort(this, (float[]) a, depth, low, low + size);\n-                } else if (a instanceof double[]) {\n-                    sort(this, (double[]) a, depth, low, low + size);\n-                } else {\n-                    throw new IllegalArgumentException(\n-                        \"Unknown type of array: \" + a.getClass().getName());\n+                switch(a) {\n+                    case int[] ai -> sort((Sorter<int[]>) this, ai, depth, low, low + size);\n+                    case long[] al -> sort((Sorter<long[]>) this, al, depth, low, low + size);\n+                    case float[] af -> sort((Sorter<float[]>) this, af, depth, low, low + size);\n+                    case double[] ad -> sort((Sorter<double[]>) this, ad, depth, low, low + size);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n@@ -4305,1 +4516,1 @@\n-        public final void onCompletion(CountedCompleter<?> caller) {\n+        public void onCompletion(CountedCompleter<?> caller) {\n@@ -4310,1 +4521,1 @@\n-                new Merger(null,\n+                new Merger<>(null,\n@@ -4316,1 +4527,0 @@\n-                    b,\n@@ -4323,1 +4533,1 @@\n-        private void forkSorter(int depth, int low, int high) {\n+        private void fork(int depth, int low, int high) {\n@@ -4325,2 +4535,1 @@\n-            Object a = this.a; \/\/ Use local variable for performance\n-            new Sorter(this, a, b, low, high - low, offset, depth).fork();\n+            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n@@ -4331,1 +4540,3 @@\n-     * This class implements parallel merging.\n+     * Implementation of parallel merging.\n+     *\n+     * @param <T> the class of array\n@@ -4333,2 +4544,5 @@\n-    private static final class Merger extends CountedCompleter<Void> {\n-        private static final long serialVersionUID = 20180818L;\n+    private static final class Merger<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n@@ -4336,1 +4550,1 @@\n-        private final Object dst, a1, a2;\n+        private final T dst, src;\n@@ -4339,2 +4553,2 @@\n-        private Merger(CountedCompleter<?> parent, Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\n+                T src, int lo1, int hi1, int lo2, int hi2) {\n@@ -4344,1 +4558,1 @@\n-            this.a1 = a1;\n+            this.src = src;\n@@ -4347,1 +4561,0 @@\n-            this.a2 = a2;\n@@ -4353,16 +4566,8 @@\n-        public final void compute() {\n-            if (dst instanceof int[]) {\n-                mergeParts(this, (int[]) dst, k,\n-                    (int[]) a1, lo1, hi1, (int[]) a2, lo2, hi2);\n-            } else if (dst instanceof long[]) {\n-                mergeParts(this, (long[]) dst, k,\n-                    (long[]) a1, lo1, hi1, (long[]) a2, lo2, hi2);\n-            } else if (dst instanceof float[]) {\n-                mergeParts(this, (float[]) dst, k,\n-                    (float[]) a1, lo1, hi1, (float[]) a2, lo2, hi2);\n-            } else if (dst instanceof double[]) {\n-                mergeParts(this, (double[]) dst, k,\n-                    (double[]) a1, lo1, hi1, (double[]) a2, lo2, hi2);\n-            } else {\n-                throw new IllegalArgumentException(\n-                    \"Unknown type of array: \" + dst.getClass().getName());\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            switch(dst) {\n+                case int[] di -> mergeParts((Merger<int[]>) this, di, k, (int[]) src, lo1, hi1, lo2, hi2);\n+                case long[] dl -> mergeParts((Merger<long[]>) this, dl, k, (long[]) src, lo1, hi1, lo2, hi2);\n+                case float[] df -> mergeParts((Merger<float[]>) this, df, k, (float[]) src, lo1, hi1, lo2, hi2);\n+                case double[] dd -> mergeParts((Merger<double[]>) this, dd, k, (double[]) src, lo1, hi1, lo2, hi2);\n+                default -> throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n@@ -4373,2 +4578,1 @@\n-        private void forkMerger(Object dst, int k,\n-                Object a1, int lo1, int hi1, Object a2, int lo2, int hi2) {\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\n@@ -4376,1 +4580,1 @@\n-            new Merger(this, dst, k, a1, lo1, hi1, a2, lo2, hi2).fork();\n+            new Merger<>(this, dst, k, src, lo1, hi1, lo2, hi2).fork();\n@@ -4381,1 +4585,7 @@\n-     * This class implements parallel merging of runs.\n+     * Tries to allocate additional buffer.\n+     *\n+     * @param <T> the class of array\n+     * @param clazz the given array class\n+     * @param length the length of additional buffer\n+     * @return {@code null} if requested buffer is too big or there is no enough memory,\n+     *         otherwise created buffer\n@@ -4383,44 +4593,9 @@\n-    private static final class RunMerger extends RecursiveTask<Object> {\n-        private static final long serialVersionUID = 20180818L;\n-        @SuppressWarnings(\"serial\")\n-        private final Object a, b;\n-        private final int[] run;\n-        private final int offset, aim, lo, hi;\n-\n-        private RunMerger(Object a, Object b, int offset,\n-                int aim, int[] run, int lo, int hi) {\n-            this.a = a;\n-            this.b = b;\n-            this.offset = offset;\n-            this.aim = aim;\n-            this.run = run;\n-            this.lo = lo;\n-            this.hi = hi;\n-        }\n-\n-        @Override\n-        protected final Object compute() {\n-            if (a instanceof int[]) {\n-                return mergeRuns((int[]) a, (int[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof long[]) {\n-                return mergeRuns((long[]) a, (long[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof float[]) {\n-                return mergeRuns((float[]) a, (float[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            if (a instanceof double[]) {\n-                return mergeRuns((double[]) a, (double[]) b, offset, aim, true, run, lo, hi);\n-            }\n-            throw new IllegalArgumentException(\n-                \"Unknown type of array: \" + a.getClass().getName());\n-        }\n-\n-        private RunMerger forkMe() {\n-            fork();\n-            return this;\n-        }\n-\n-        private Object getDestination() {\n-            join();\n-            return getRawResult();\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T tryAllocate(Class<T> clazz, int length) {\n+        try {\n+            int maxLength = MAX_BUFFER_SIZE >>\n+                (clazz == int[].class || clazz == float[].class ? 2 : 3);\n+            return length > maxLength ? null :\n+                (T) U.allocateUninitializedArray(clazz.componentType(), length);\n+        } catch (OutOfMemoryError e) {\n+            return null;\n@@ -4429,0 +4604,2 @@\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java","additions":2663,"deletions":2486,"binary":false,"changes":5149,"status":"modified"},{"patch":"@@ -0,0 +1,1606 @@\n+#if[Common1]\n+\/*\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#warn This file is preprocessed before being compiled\n+\n+package java.util;\n+\n+import java.util.concurrent.CountedCompleter;\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.vm.annotation.ForceInline;\n+import jdk.internal.vm.annotation.IntrinsicCandidate;\n+\n+\/**\n+ * This class implements powerful and fully optimized versions, both\n+ * sequential and parallel, of the Dual-Pivot Quicksort algorithm by\n+ * Vladimir Yaroslavskiy, Jon Bentley and Josh Bloch. This algorithm\n+ * offers O(n log(n)) performance on all data sets, and is typically\n+ * faster than traditional (one-pivot) Quicksort implementations.<p>\n+ *\n+ * There are also additional algorithms, invoked from the Dual-Pivot\n+ * Quicksort such as merging sort, sorting network, heap sort, mixed\n+ * insertion sort, counting sort and parallel merge sort. The actual\n+ * sorting algorithm depends on the data type and array size.<p>\n+ *\n+ * <b>Type: int\/long\/float\/double<\/b><p>\n+ *\n+ * If the array size is small, invoke mixed insertion sort on non-leftmost\n+ * parts or insertion sort on leftmost part.<p>\n+ *\n+ * Then try merging sort which is the best on almost sorted arrays.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with heap sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Type: float\/double<\/b><p>\n+ *\n+ * Floating-point values require additional steps to process\n+ * negative zeros -0.0 and NaNs (Not-a-Number) before sorting and\n+ * re-arrange negative zeros at the end.<p>\n+ *\n+ * <b>Type: byte<\/b><p>\n+ *\n+ * Invoke insertion sort, if the array size is small, otherwise switch\n+ * to counting sort.<p>\n+ *\n+ * <b>Type: char\/short<\/b><p>\n+ *\n+ * Invoke counting sort on large array, otherwise run insertion sort\n+ * on small array.<p>\n+ *\n+ * On the next step check the recursion depth to avoid quadratic time\n+ * with counting sort.<p>\n+ *\n+ * Then apply Quicksort with two pivots on random data, otherwise\n+ * run one-pivot Quicksort.<p>\n+ *\n+ * <b>Parallel sorting (int\/long\/float\/double)<\/b><p>\n+ *\n+ * If the array size is small, sequential sort is run. Otherwise\n+ * invoke parallel merge sort (the recursion depth depends on\n+ * parallelism level), then run parallel Quicksort.\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ * @author Jon Bentley\n+ * @author Josh Bloch\n+ * @author Doug Lea\n+ *\n+ * @version 2024.06.14\n+ *\n+ * @since 1.7 * 14 ^ 26\n+ *\/\n+final class DualPivotQuicksort {\n+\n+    \/**\n+     * Prevents instantiation.\n+     *\/\n+    private DualPivotQuicksort() {}\n+\n+    \/* --------------------- Insertion sort --------------------- *\/\n+\n+    \/**\n+     * Max size of array to use insertion sort (the best on shuffle data).\n+     *\/\n+    private static final int MAX_INSERTION_SORT_SIZE = 37;\n+\n+    \/* ---------------------- Merging sort ---------------------- *\/\n+\n+    \/**\n+     * Min size of array to use merging sort (the best on stagger data).\n+     *\/\n+    private static final int MIN_MERGING_SORT_SIZE = 512;\n+\n+    \/**\n+     * Min size of run to continue scanning (the best on stagger data).\n+     *\/\n+    private static final int MIN_RUN_SIZE = 64;\n+\n+    \/**\n+     * Max capacity of the index array to track the runs.\n+     *\/\n+    private static final int MAX_RUN_CAPACITY = 10 << 10;\n+\n+    \/* ---------------------- Digital sort ---------------------- *\/\n+\n+    \/**\n+     * Min size of array to use counting sort (the best on random data).\n+     *\/\n+    private static final int MIN_COUNTING_SORT_SIZE = 640;\n+\n+    \/**\n+     * Min size of array to use numerical sort (the best on repeated data).\n+     *\/\n+    private static final int MIN_NUMERICAL_SORT_SIZE = 9 << 10;\n+\n+    \/* --------------------- Parallel sort ---------------------- *\/\n+\n+    \/**\n+     * Min size of array to perform sorting in parallel (the best on stagger data).\n+     *\/\n+    private static final int MIN_PARALLEL_SORT_SIZE = 3 << 10;\n+\n+    \/* --------------------- Infrastructure --------------------- *\/\n+\n+    \/**\n+     * Max recursive depth before switching to heap sort.\n+     *\/\n+    private static final int MAX_RECURSION_DEPTH = 64 << 1;\n+\n+    \/**\n+     * Max size of additional buffer in bytes,\n+     *      limited by max_heap \/ 16 or 2 GB max.\n+     *\/\n+    private static final int MAX_BUFFER_SIZE =\n+        Math.clamp(Runtime.getRuntime().maxMemory() >>> 4, 0, Integer.MAX_VALUE);\n+\n+    \/**\n+     * Represents a function that accepts the array and sorts\n+     * the specified range of the array into ascending order.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    @FunctionalInterface\n+    private interface SortOperation<T> {\n+        \/**\n+         * Sorts the specified range of the array.\n+         *\n+         * @param a the array to be sorted\n+         * @param low the index of the first element, inclusive, to be sorted\n+         * @param high the index of the last element, exclusive, to be sorted\n+         *\/\n+        void sort(T a, int low, int high);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array into ascending numerical order.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n+     *\n+     * @param <T> the class of array\n+     * @param elemType the class of the elements of the array to be sorted\n+     * @param a the array to be sorted\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @param so the method reference for the fallback implementation\n+     *\/\n+    @ForceInline\n+    @IntrinsicCandidate\n+    private static <T> void sort(Class<?> elemType, T a, long offset,\n+            int low, int high, SortOperation<T> so) {\n+        so.sort(a, low, high);\n+    }\n+\n+    \/**\n+     * Represents a function that accepts the array and partitions\n+     * the specified range of the array using the given pivots.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    @FunctionalInterface\n+    private interface PartitionOperation<T> {\n+        \/**\n+         * Partitions the specified range of the array using the given pivots.\n+         *\n+         * @param a the array for partitioning\n+         * @param low the index of the first element, inclusive, for partitioning\n+         * @param high the index of the last element, exclusive, for partitioning\n+         * @param pivotIndex1 the index of pivot1, the first pivot\n+         * @param pivotIndex2 the index of pivot2, the second pivot\n+         * @return indices of parts after partitioning\n+         *\/\n+        int[] partition(T a, int low, int high, int pivotIndex1, int pivotIndex2);\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using the given pivots.\n+     * The signature of this method is in sync with native implementation\n+     * based on AVX512 instructions from linux\/native\/libsimdsort package,\n+     * don't change the signature.\n+     *\n+     * @param <T> the class of array\n+     * @param elemType the class of the array for partitioning\n+     * @param a the array for partitioning\n+     * @param offset the relative offset, in bytes, from the base\n+     *        address of the array to partition, otherwise if the\n+     *        array is {@code null}, an absolute address pointing\n+     *        to the first element to partition from\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @param po the method reference for the fallback implementation\n+     * @return indices of parts after partitioning\n+     *\/\n+    @ForceInline\n+    @IntrinsicCandidate\n+    private static <T> int[] partition(Class<?> elemType, T a, long offset,\n+            int low, int high, int pivotIndex1, int pivotIndex2, PartitionOperation<T> po) {\n+        return po.partition(a, low, high, pivotIndex1, pivotIndex2);\n+    }\n+#end[Common1]\n+#if[!Common1]\n+#if[!Common2]\n+\n+\/\/ #[$type$]\n+#end[Common2]\n+#end[Common1]\n+#if[IntLong]\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int parallelism, int low, int high) {\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n+        } else {\n+            sort(null, a, 0, low, high);\n+        }\n+    }\n+#end[IntLong]\n+#if[FloatDouble]\n+\n+    \/**\n+     * The binary representation of $type$ negative zero.\n+     *\/\n+    private static final {#if[Float]?int}{#if[Double]?long} $TYPE$_NEGATIVE_ZERO = {#if[Float]?Float.floatToRawIntBits(-0.0f)}{#if[Double]?Double.doubleToRawLongBits(-0.0d)};\n+\n+    \/**\n+     * Sorts the specified range of the array using parallel merge\n+     * sort and\/or Dual-Pivot Quicksort.<p>\n+     *\n+     * To balance the faster splitting and parallelism of merge sort\n+     * with the faster element partitioning of Quicksort, ranges are\n+     * subdivided in tiers such that, if there is enough parallelism,\n+     * the four-way parallel merge is started, still ensuring enough\n+     * parallelism to process the partitions.\n+     *\n+     * @param a the array to be sorted\n+     * @param parallelism the parallelism level\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int parallelism, int low, int high) {\n+        \/*\n+         * Phase 1. Count the number of negative zero -0.0,\n+         * turn them into positive zero, and move all NaNs\n+         * to the end of the array.\n+         *\/\n+        int negativeZeroCount = 0;\n+\n+        for (int k = high; k > low; ) {\n+            $type$ ak = a[--k];\n+\n+            if ({#if[Float]?Float.floatToRawIntBits}{#if[Double]?Double.doubleToRawLongBits}(ak) == $TYPE$_NEGATIVE_ZERO) { \/\/ ak is -0.0\n+                negativeZeroCount++;\n+                a[k] = 0.0{#if[Float]?f}{#if[Double]?d};\n+            } else if (ak != ak) { \/\/ ak is Not-a-Number (NaN)\n+                a[k] = a[--high];\n+                a[high] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Phase 2. Sort everything except NaNs,\n+         * which are already in place.\n+         *\/\n+        if (parallelism > 1 && high - low > MIN_PARALLEL_SORT_SIZE) {\n+            new Sorter<>(a, parallelism, low, high - low).invoke();\n+        } else {\n+            sort(null, a, 0, low, high);\n+        }\n+\n+        \/*\n+         * Phase 3. Turn the required number of positive\n+         * zeros 0.0 back into negative zeros -0.0.\n+         *\/\n+        if (++negativeZeroCount == 1) {\n+            return;\n+        }\n+\n+        \/*\n+         * Find the position one less than\n+         * the index of the first zero.\n+         *\/\n+        while (low <= high) {\n+            int mid = (low + high) >>> 1;\n+\n+            if (a[mid] < 0.0{#if[Float]?f}{#if[Double]?d}) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        \/*\n+         * Replace 0.0 by negative zeros -0.0.\n+         *\/\n+        while (--negativeZeroCount > 0) {\n+            a[++high] = -0.0{#if[Float]?f}{#if[Double]?d};\n+        }\n+    }\n+#end[FloatDouble]\n+#if[Byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort or counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(byte[] a, int low, int high) {\n+        if (high - low < MAX_INSERTION_SORT_SIZE) {\n+            insertionSort(a, low, high);\n+        } else {\n+            countingSort(a, low, high);\n+        }\n+    }\n+#end[Byte]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort\n+     * Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort($type$[] a, int low, int high) {\n+        if (high - low > MIN_COUNTING_SORT_SIZE) {\n+            countingSort(a, low, high);\n+        } else {\n+            sort(a, 0, low, high);\n+        }\n+    }\n+#end[CharShort]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that range is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void sort(Sorter<$type$[]> sorter, $type$[] a, int bits, int low, int high) {\n+        while (true) {\n+            int size = high - low;\n+\n+            \/*\n+             * Run adaptive mixed insertion sort on small non-leftmost parts.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE + bits && (bits & 1) > 0) {\n+                sort($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::mixedInsertionSort);\n+                return;\n+            }\n+\n+            \/*\n+             * Invoke adaptive insertion sort on small leftmost part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE + bits * 5) {\n+                sort($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, DualPivotQuicksort::insertionSort);\n+                return;\n+            }\n+\n+            \/*\n+             * Try merging sort on large part.\n+             *\/\n+            if (size > MIN_MERGING_SORT_SIZE * bits\n+                    && tryMergingSort(sorter, a, low, high)) {\n+                return;\n+            }\n+\n+            \/*\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n+             *\/\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = high - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { $type$ t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { $type$ t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { $type$ t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { $type$ t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { $type$ t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n+                }\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n+                }\n+            }\n+\n+            \/*\n+             * Switch to heap sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                heapSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                indices = partition($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, e1, e5, DualPivotQuicksort::partitionWithTwoPivots);\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.fork(bits | 1, indices[0] + 1, indices[1]);\n+                    sorter.fork(bits | 1, indices[1] + 1, high);\n+                } else {\n+                    sort(sorter, a, bits | 1, indices[0] + 1, indices[1]);\n+                    sort(sorter, a, bits | 1, indices[1] + 1, high);\n+                }\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partition($type$.class, a, Unsafe.ARRAY_$TYPE$_BASE_OFFSET,\n+                    low, high, e3, e3, DualPivotQuicksort::partitionWithOnePivot);\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                if (size > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+                    sorter.fork(bits | 1, indices[1], high);\n+                } else {\n+                    sort(sorter, a, bits | 1, indices[1], high);\n+                }\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+#end[IntLongFloatDouble]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using Dual-Pivot Quicksort.\n+     *\n+     * @param a the array to be sorted\n+     * @param bits the combination of recursion depth and bit flag, where\n+     *        the right bit \"0\" indicates that range is the leftmost part\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void sort($type$[] a, int bits, int low, int high) {\n+        while (true) {\n+            int size = high - low;\n+\n+            \/*\n+             * Invoke insertion sort on small part.\n+             *\/\n+            if (size < MAX_INSERTION_SORT_SIZE) {\n+                insertionSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * Divide the given array into the golden ratio using\n+             * an inexpensive approximation to select five sample\n+             * elements and determine pivots.\n+             *\/\n+            int step = (size >> 2) + (size >> 3) + (size >> 7);\n+\n+            \/*\n+             * Five elements around (and including) the central element\n+             * will be used for pivot selection as described below. The\n+             * unequal choice of spacing these elements was empirically\n+             * determined to work well on a wide variety of inputs.\n+             *\/\n+            int e1 = low + step;\n+            int e5 = high - step;\n+            int e3 = (e1 + e5) >>> 1;\n+            int e2 = (e1 + e3) >>> 1;\n+            int e4 = (e3 + e5) >>> 1;\n+\n+            \/*\n+             * Sort these elements in-place by the combination\n+             * of 4-element sorting network and insertion sort.\n+             *\n+             *   1 ---------o---------------o-----------------\n+             *              |               |\n+             *   2 ---------|-------o-------o-------o---------\n+             *              |       |               |\n+             *   3 ---------|-------|---------------|---------\n+             *              |       |               |\n+             *   4 ---------o-------|-------o-------o---------\n+             *                      |       |\n+             *   5 -----------------o-------o-----------------\n+             *\/\n+            if (a[e1] > a[e4]) { $type$ t = a[e1]; a[e1] = a[e4]; a[e4] = t; }\n+            if (a[e2] > a[e5]) { $type$ t = a[e2]; a[e2] = a[e5]; a[e5] = t; }\n+            if (a[e4] > a[e5]) { $type$ t = a[e4]; a[e4] = a[e5]; a[e5] = t; }\n+            if (a[e1] > a[e2]) { $type$ t = a[e1]; a[e1] = a[e2]; a[e2] = t; }\n+            if (a[e2] > a[e4]) { $type$ t = a[e2]; a[e2] = a[e4]; a[e4] = t; }\n+\n+            \/*\n+             * Insert the third element.\n+             *\/\n+            if (a[e3] < a[e2]) {\n+                if (a[e3] < a[e1]) {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = a[e1]; a[e1] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e2]; a[e2] = t;\n+                }\n+            } else if (a[e3] > a[e4]) {\n+                if (a[e3] > a[e5]) {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = a[e5]; a[e5] = t;\n+                } else {\n+                    $type$ t = a[e3]; a[e3] = a[e4]; a[e4] = t;\n+                }\n+            }\n+\n+            \/*\n+             * Switch to counting sort to avoid quadratic time.\n+             *\/\n+            if ((bits += 2) > MAX_RECURSION_DEPTH) {\n+                countingSort(a, low, high);\n+                return;\n+            }\n+\n+            \/*\n+             * indices[0] - the index of the last element of the left part\n+             * indices[1] - the index of the first element of the right part\n+             *\/\n+            int[] indices;\n+\n+            \/*\n+             * Partitioning with two pivots on array of fully random elements.\n+             *\/\n+            if (a[e1] < a[e2] && a[e2] < a[e3] && a[e3] < a[e4] && a[e4] < a[e5]) {\n+\n+                indices = partitionWithTwoPivots(a, low, high, e1, e5);\n+\n+                \/*\n+                 * Sort non-left parts recursively (possibly in parallel),\n+                 * excluding known pivots.\n+                 *\/\n+                sort(a, bits | 1, indices[0] + 1, indices[1]);\n+                sort(a, bits | 1, indices[1] + 1, high);\n+\n+            } else { \/\/ Partitioning with one pivot\n+\n+                indices = partitionWithOnePivot(a, low, high, e3, e3);\n+\n+                \/*\n+                 * Sort the right part (possibly in parallel), excluding\n+                 * known pivot. All elements from the central part are\n+                 * equal and therefore already sorted.\n+                 *\/\n+                sort(a, bits | 1, indices[1], high);\n+            }\n+            high = indices[0]; \/\/ Iterate along the left part\n+        }\n+    }\n+#end[CharShort]\n+#if[AllExceptByte]\n+\n+    \/**\n+     * Partitions the specified range of the array using two given pivots.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of pivot1, the first pivot\n+     * @param pivotIndex2 the index of pivot2, the second pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithTwoPivots(\n+            $type$[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = --high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the first and fifth of the five sorted elements as\n+         * the pivots. These values are inexpensive approximation\n+         * of tertiles. Note, that pivot1 < pivot2.\n+         *\/\n+        $type$ pivot1 = a[pivotIndex1];\n+        $type$ pivot2 = a[pivotIndex2];\n+\n+        \/*\n+         * The first and the last elements to be sorted are moved\n+         * to the locations formerly occupied by the pivots. When\n+         * partitioning is completed, the pivots are swapped back\n+         * into their final positions, and excluded from the next\n+         * subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+        a[pivotIndex2] = a[upper];\n+\n+        \/*\n+         * Skip elements, which are less or greater than the pivots.\n+         *\/\n+        while (a[++lower] < pivot1);\n+        while (a[--upper] > pivot2);\n+\n+        \/*\n+         * Backward 3-interval partitioning\n+         *\n+         *     left part                     central part          right part\n+         * +--------------+----------+--------------------------+--------------+\n+         * |   < pivot1   |    ?     |  pivot1 <= .. <= pivot2  |   > pivot2   |\n+         * +--------------+----------+--------------------------+--------------+\n+         *               ^          ^                            ^\n+         *               |          |                            |\n+         *             lower        k                          upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int unused = --lower, k = ++upper; --k > lower; ) {\n+            $type$ ak = a[k];\n+\n+            if (ak < pivot1) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot1);\n+\n+                if (lower > k) {\n+                    lower = k;\n+                    break;\n+                }\n+                if (a[lower] > pivot2) {\n+                    a[k] = a[--upper];\n+                    a[upper] = a[lower];\n+                } else {\n+                    a[k] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else if (ak > pivot2) { \/\/ Move a[k] to the right part\n+                a[k] = a[--upper];\n+                a[upper] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Swap the pivots into their final positions.\n+         *\/\n+        a[low]  = a[lower]; a[lower] = pivot1;\n+        a[high] = a[upper]; a[upper] = pivot2;\n+\n+        return new int[] { lower, upper };\n+    }\n+\n+    \/**\n+     * Partitions the specified range of the array using one given pivot.\n+     *\n+     * @param a the array for partitioning\n+     * @param low the index of the first element, inclusive, for partitioning\n+     * @param high the index of the last element, exclusive, for partitioning\n+     * @param pivotIndex1 the index of single pivot\n+     * @param pivotIndex2 the index of single pivot\n+     * @return indices of parts after partitioning\n+     *\/\n+    private static int[] partitionWithOnePivot(\n+            $type$[] a, int low, int high, int pivotIndex1, int pivotIndex2) {\n+        \/*\n+         * Pointers to the right and left parts.\n+         *\/\n+        int upper = high;\n+        int lower = low;\n+\n+        \/*\n+         * Use the third of the five sorted elements as the pivot.\n+         * This value is inexpensive approximation of the median.\n+         *\/\n+        $type$ pivot = a[pivotIndex1];\n+\n+        \/*\n+         * The first element to be sorted is moved to the\n+         * location formerly occupied by the pivot. After\n+         * completion of partitioning the pivot is swapped\n+         * back into its final position, and excluded from\n+         * the next subsequent sorting.\n+         *\/\n+        a[pivotIndex1] = a[lower];\n+\n+        \/*\n+         * Dutch National Flag partitioning\n+         *\n+         *     left part               central part    right part\n+         * +--------------+----------+--------------+-------------+\n+         * |   < pivot    |    ?     |   == pivot   |   > pivot   |\n+         * +--------------+----------+--------------+-------------+\n+         *               ^          ^                ^\n+         *               |          |                |\n+         *             lower        k              upper\n+         *\n+         * Pointer k is the last index of ?-part\n+         * Pointer lower is the last index of left part\n+         * Pointer upper is the first index of right part\n+         *\/\n+        for (int k = upper; --k > lower; ) {\n+            $type$ ak = a[k];\n+\n+            if (ak == pivot) {\n+                continue;\n+            }\n+            a[k] = pivot;\n+\n+            if (ak < pivot) { \/\/ Move a[k] to the left part\n+                while (a[++lower] < pivot);\n+\n+                if (a[lower] > pivot) {\n+                    a[--upper] = a[lower];\n+                }\n+                a[lower] = ak;\n+            } else { \/\/ ak > pivot - Move a[k] to the right part\n+                a[--upper] = ak;\n+            }\n+        }\n+\n+        \/*\n+         * Swap the pivot into its final position.\n+         *\/\n+        a[low] = a[lower]; a[lower] = pivot;\n+\n+        return new int[] { lower, upper };\n+    }\n+#end[AllExceptByte]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Sorts the specified range of the array using mixed insertion sort.<p>\n+     *\n+     * Mixed insertion sort is combination of pin insertion sort\n+     * and pair insertion sort.<p>\n+     *\n+     * In the context of Dual-Pivot Quicksort, the pivot element\n+     * from the left part plays the role of sentinel, because it\n+     * is less than any elements from the given part. Therefore,\n+     * expensive check of the left range can be skipped on each\n+     * iteration unless it is the leftmost call.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void mixedInsertionSort($type$[] a, int low, int high) {\n+        \/*\n+         * Split the array for pin and pair insertion sorts.\n+         *\/\n+        int end = high - ((3 * ((high - low) >> 2)) & ~1);\n+\n+        \/*\n+         * Start with pin insertion sort.\n+         *\/\n+        for (int i, p = high; ++low < end; ) {\n+            $type$ ai = a[i = low], pin = a[--p];\n+\n+            \/*\n+             * Swap larger element with pin.\n+             *\/\n+            if (ai > pin) {\n+                ai = pin;\n+                a[p] = a[i];\n+            }\n+\n+            \/*\n+             * Insert element into sorted part.\n+             *\/\n+            while (ai < a[i - 1]) {\n+                a[i] = a[--i];\n+            }\n+            a[i] = ai;\n+        }\n+\n+        \/*\n+         * Finish with pair insertion sort.\n+         *\/\n+        for (int i; low < high; ++low) {\n+            $type$ a1 = a[i = low], a2 = a[++low];\n+\n+            \/*\n+             * Insert two elements per iteration: at first, insert the\n+             * larger element and then insert the smaller element, but\n+             * from the position where the larger element was inserted.\n+             *\/\n+            if (a1 > a2) {\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a1;\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a2;\n+\n+            } else if (a1 < a[i - 1]) {\n+\n+                while (a2 < a[--i]) {\n+                    a[i + 2] = a[i];\n+                }\n+                a[++i + 1] = a2;\n+\n+                while (a1 < a[--i]) {\n+                    a[i + 1] = a[i];\n+                }\n+                a[i + 1] = a1;\n+            }\n+        }\n+    }\n+#end[IntLongFloatDouble]\n+#if[AllTypes]\n+\n+    \/**\n+     * Sorts the specified range of the array using insertion sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void insertionSort($type$[] a, int low, int high) {\n+        for (int i, k = low; ++k < high; ) {\n+            $type$ ai = a[i = k];\n+\n+            if (ai < a[i - 1]) {\n+                do {\n+                    a[i] = a[--i];\n+                } while (i > low && ai < a[i - 1]);\n+\n+                a[i] = ai;\n+            }\n+        }\n+    }\n+#end[AllTypes]\n+#if[IntLongFloatDouble]\n+\n+    \/**\n+     * Tries to sort the specified range of the array using merging sort.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     * @return {@code true} if the array is finally sorted, otherwise {@code false}\n+     *\/\n+    static boolean tryMergingSort(Sorter<$type$[]> sorter, $type$[] a, int low, int high) {\n+        \/*\n+         * The element run[i] holds the start index\n+         * of i-th sequence in non-descending order.\n+         *\/\n+        int count = 1;\n+        int[] run = null;\n+\n+        \/*\n+         * Identify all possible runs.\n+         *\/\n+        for (int k = low + 1, last = low; k < high; ) {\n+            \/*\n+             * Find the next run.\n+             *\/\n+            if (a[k - 1] < a[k]) {\n+\n+                \/\/ Identify ascending sequence\n+                while (++k < high && a[k - 1] <= a[k]);\n+\n+            } else if (a[k - 1] > a[k]) {\n+\n+                \/\/ Identify descending sequence\n+                while (++k < high && a[k - 1] >= a[k]);\n+\n+                \/\/ Reverse into ascending order\n+                for (int i = last - 1, j = k; ++i < --j && a[i] > a[j]; ) {\n+                    $type$ ai = a[i]; a[i] = a[j]; a[j] = ai;\n+                }\n+\n+                \/\/ Check the next sequence\n+                if (k < high && a[k - 1] < a[k]) {\n+                    continue;\n+                }\n+\n+            } else { \/\/ Identify constant sequence\n+                for ($type$ ak = a[k]; ++k < high && ak == a[k]; );\n+\n+                \/\/ Check the next sequence\n+                if (k < high) {\n+                    continue;\n+                }\n+            }\n+\n+            \/*\n+             * Process the current run.\n+             *\/\n+            if (run == null) {\n+\n+                if (k == high) {\n+                    \/*\n+                     * Array is monotonous sequence\n+                     * and therefore already sorted.\n+                     *\/\n+                    return true;\n+                }\n+                run = new int[Math.min((high - low) >> 6, MAX_RUN_CAPACITY) | 8];\n+                run[0] = low;\n+\n+            } else if (a[last - 1] > a[last]) { \/\/ Start the new run\n+\n+                if (k - low < count * MIN_RUN_SIZE) {\n+                    \/*\n+                     * Terminate the scanning,\n+                     * if the runs are too small.\n+                     *\/\n+                    return false;\n+                }\n+\n+                if (++count == run.length) {\n+                    \/*\n+                     * Array is not highly structured.\n+                     *\/\n+                    return false;\n+                }\n+            }\n+\n+            \/*\n+             * Save the current run.\n+             *\/\n+            run[count] = (last = k);\n+\n+            \/*\n+             * Check single-element run at the end.\n+             *\/\n+            if (++k == high) {\n+                --k;\n+            }\n+        }\n+\n+        \/*\n+         * Merge all runs.\n+         *\/\n+        if (count > 1) {\n+            $type$[] b; int offset = low;\n+\n+            if (sorter != null && (b = sorter.b) != null) {\n+                offset = sorter.offset;\n+            } else if ((b = tryAllocate($type$[].class, high - low)) == null) {\n+                return false;\n+            }\n+            mergeRuns(sorter, a, b, offset, true, run, 0, count);\n+        }\n+        return true;\n+    }\n+\n+    \/**\n+     * Merges the specified runs.\n+     *\n+     * @param sorter the parallel context\n+     * @param a the source array\n+     * @param b the buffer for merging\n+     * @param offset the start index in the source, inclusive\n+     * @param aim whether the original array is used for merging\n+     * @param run the start indexes of the runs, inclusive\n+     * @param lo the start index of the first run, inclusive\n+     * @param hi the start index of the last run, inclusive\n+     *\/\n+    private static void mergeRuns(Sorter<$type$[]> sorter, $type$[] a, $type$[] b, int offset,\n+            boolean aim, int[] run, int lo, int hi) {\n+\n+        if (hi - lo == 1) {\n+            if (!aim) {\n+                System.arraycopy(a, run[lo], b, run[lo] - offset, run[hi] - run[lo]);\n+            }\n+            return;\n+        }\n+\n+        \/*\n+         * Split the array into two approximately equal parts.\n+         *\/\n+        int mi = lo, key = (run[lo] + run[hi]) >>> 1;\n+        while (run[++mi + 1] <= key);\n+\n+        \/*\n+         * Merge the runs of all parts.\n+         *\/\n+        mergeRuns(sorter, a, b, offset, !aim, run, lo, mi);\n+        mergeRuns(sorter, a, b, offset, !aim, run, mi, hi);\n+\n+        $type$[] dst = aim ? a : b;\n+        $type$[] src = aim ? b : a;\n+\n+        int k  = !aim ? run[lo] - offset : run[lo];\n+        int lo1 = aim ? run[lo] - offset : run[lo];\n+        int hi1 = aim ? run[mi] - offset : run[mi];\n+        int lo2 = aim ? run[mi] - offset : run[mi];\n+        int hi2 = aim ? run[hi] - offset : run[hi];\n+\n+        \/*\n+         * Merge the left and right parts.\n+         *\/\n+        if (hi1 - lo1 > MIN_PARALLEL_SORT_SIZE && sorter != null) {\n+            new Merger<>(null, dst, k, src, lo1, hi1, lo2, hi2).invoke();\n+        } else {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts in parallel.\n+     *\n+     * @param merger the parallel context\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts(Merger<$type$[]> merger, $type$[] dst, int k,\n+            $type$[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        while (true) {\n+            \/*\n+             * The first part must be larger.\n+             *\/\n+            if (hi1 - lo1 < hi2 - lo2) {\n+                int lo = lo1; lo1 = lo2; lo2 = lo;\n+                int hi = hi1; hi1 = hi2; hi2 = hi;\n+            }\n+\n+            \/*\n+             * Merge the small parts sequentially.\n+             *\/\n+            if (hi1 - lo1 < MIN_PARALLEL_SORT_SIZE) {\n+                break;\n+            }\n+\n+            \/*\n+             * Find the median of the larger part.\n+             *\/\n+            int mi1 = (lo1 + hi1) >>> 1;\n+            int mi2 = hi2;\n+            $type$ key = src[mi1];\n+\n+            \/*\n+             * Split the smaller part.\n+             *\/\n+            for (int mi0 = lo2; mi0 < mi2; ) {\n+                int mid = (mi0 + mi2) >>> 1;\n+\n+                if (key > src[mid]) {\n+                    mi0 = mid + 1;\n+                } else {\n+                    mi2 = mid;\n+                }\n+            }\n+\n+            \/*\n+             * Merge the first parts in parallel.\n+             *\/\n+            merger.fork(k, lo1, mi1, lo2, mi2);\n+\n+            \/*\n+             * Reserve space for the second parts.\n+             *\/\n+            k += mi2 - lo2 + mi1 - lo1;\n+\n+            \/*\n+             * Iterate along the second parts.\n+             *\/\n+            lo1 = mi1;\n+            lo2 = mi2;\n+        }\n+\n+        \/*\n+         * Check if the array is already ordered and then merge the parts.\n+         *\/\n+        if (lo1 < hi1 && lo2 < hi2 && src[hi1 - 1] > src[lo2]) {\n+            mergeParts(dst, k, src, lo1, hi1, lo2, hi2);\n+        } else {\n+            System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+            System.arraycopy(src, lo2, dst, k + hi1 - lo1, hi2 - lo2);\n+        }\n+    }\n+\n+    \/**\n+     * Merges the sorted parts sequentially.\n+     *\n+     * @param dst the destination where parts are merged\n+     * @param k the start index of the destination, inclusive\n+     * @param src the source array\n+     * @param lo1 the start index of the first part, inclusive\n+     * @param hi1 the end index of the first part, exclusive\n+     * @param lo2 the start index of the second part, inclusive\n+     * @param hi2 the end index of the second part, exclusive\n+     *\/\n+    private static void mergeParts($type$[] dst, int k,\n+            $type$[] src, int lo1, int hi1, int lo2, int hi2) {\n+\n+        if (src[hi1 - 1] < src[hi2 - 1]) {\n+            while (lo1 < hi1) {\n+                $type$ next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else if (src[hi1 - 1] > src[hi2 - 1]) {\n+            while (lo2 < hi2) {\n+                $type$ next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        } else {\n+            while (lo1 < hi1 && lo2 < hi2) {\n+                $type$ next = src[lo1];\n+\n+                if (next <= src[lo2]) {\n+                    dst[k++] = src[lo1++];\n+                }\n+                if (next >= src[lo2]) {\n+                    dst[k++] = src[lo2++];\n+                }\n+            }\n+        }\n+\n+        \/*\n+         * Copy the tail of the left and right parts.\n+         *\/\n+        System.arraycopy(src, lo1, dst, k, hi1 - lo1);\n+        System.arraycopy(src, lo2, dst, k, hi2 - lo2);\n+    }\n+\n+    \/**\n+     * Sorts the specified range of the array using heap sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void heapSort($type$[] a, int low, int high) {\n+        for (int k = (low + high) >>> 1; k > low; ) {\n+            pushDown(a, --k, a[k], low, high);\n+        }\n+        while (--high > low) {\n+            $type$ max = a[low];\n+            pushDown(a, low, a[high], low, high);\n+            a[high] = max;\n+        }\n+    }\n+\n+    \/**\n+     * Pushes specified element down during heap sort.\n+     *\n+     * @param a the given array\n+     * @param p the start index\n+     * @param value the given element\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    private static void pushDown($type$[] a, int p, $type$ value, int low, int high) {\n+        for (int k ;; a[p] = a[p = k]) {\n+            k = (p << 1) - low + 2; \/\/ Index of the right child\n+\n+            if (k > high) {\n+                break;\n+            }\n+            if (k == high || a[k] < a[k - 1]) {\n+                --k;\n+            }\n+            if (a[k] <= value) {\n+                break;\n+            }\n+        }\n+        a[p] = value;\n+    }\n+#end[IntLongFloatDouble]\n+#if[Byte]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void countingSort(byte[] a, int low, int high) {\n+        \/*\n+         * Count the number of all values.\n+         *\/\n+        int[] count = new int[1 << 8];\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        for (int i = high; i > low; ++count[a[--i] & 0xFF]);\n+\n+        \/*\n+         * Place values on their final positions.\n+         *\/\n+        for (int value = Byte.MIN_VALUE; high > low; ) {\n+            while (count[--value & 0xFF] == 0);\n+            int num = count[value & 0xFF];\n+\n+            do {\n+                a[--high] = (byte) value;\n+            } while (--num > 0);\n+        }\n+    }\n+#end[Byte]\n+#if[CharShort]\n+\n+    \/**\n+     * Sorts the specified range of the array using counting sort.\n+     *\n+     * @param a the array to be sorted\n+     * @param low the index of the first element, inclusive, to be sorted\n+     * @param high the index of the last element, exclusive, to be sorted\n+     *\/\n+    static void countingSort($type$[] a, int low, int high) {\n+        int size = high - low;\n+\n+        if (size > MIN_NUMERICAL_SORT_SIZE) {\n+            \/*\n+             * Count the number of all values.\n+             *\/\n+            int[] count = new int[1 << 16];\n+\n+            \/*\n+             * Compute the histogram.\n+             *\/\n+            for (int i = high; i > low; ++count[a[--i]{#if[Short]? & 0xFFFF}]);\n+\n+            \/*\n+             * Place values on their final positions.\n+             *\/\n+            for (int value = {#if[Char]?count.length}{#if[Short]?Short.MIN_VALUE}; high > low; ) {\n+                while (count[--value{#if[Short]? & 0xFFFF}] == 0);\n+                int num = count[value{#if[Short]? & 0xFFFF}];\n+\n+                do {\n+                    a[--high] = ($type$) value;\n+                } while (--num > 0);\n+            }\n+\n+        } else {\n+\n+            \/*\n+             * Allocate additional buffer.\n+             *\/\n+            $type$[] b = new $type$[size];\n+\n+            \/*\n+             * Count the number of all digits.\n+             *\/\n+            int[] count1 = new int[1 << 8];\n+            int[] count2 = new int[1 << 8];\n+\n+            for (int i = low; i < high; ++i) {\n+                ++count1[  a[i]        & 0xFF];\n+                ++count2[((a[i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}];{#if[Short]? \/\/ Flip the sign bit}\n+            }\n+\n+            \/*\n+             * Check digits to be processed.\n+             *\/\n+            boolean processDigit1 = processDigit(count1, size, low);\n+            boolean processDigit2 = processDigit(count2, size, low);\n+\n+            \/*\n+             * Process the 1-st digit.\n+             *\/\n+            if (processDigit1) {\n+                for (int i = high; i > low; ) {\n+                    b[--count1[a[--i] & 0xFF] - low] = a[i];\n+                }\n+            }\n+\n+            \/*\n+             * Process the 2-nd digit.\n+             *\/\n+            if (processDigit2) {\n+                if (processDigit1) {\n+                    for (int i = size; i > 0; ) {\n+                        a[--count2[((b[--i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}]] = b[i];\n+                    }\n+                } else {\n+                    for (int i = high; i > low; ) {\n+                        b[--count2[((a[--i] >>> 8) & 0xFF){#if[Short]? ^ 0x80}] - low] = a[i];\n+                    }\n+                }\n+            }\n+\n+            \/*\n+             * Copy the buffer to original array, if we process ood number of digits.\n+             *\/\n+            if (processDigit1 ^ processDigit2) {\n+                System.arraycopy(b, 0, a, low, size);\n+            }\n+        }\n+    }\n+#end[CharShort]\n+#if[Common2]\n+\n+    \/**\n+     * Checks the count array and then computes the histogram.\n+     *\n+     * @param count the count array\n+     * @param total the total number of elements\n+     * @param low the index of the first element, inclusive\n+     * @return {@code true} if the digit must be processed, otherwise {@code false}\n+     *\/\n+    private static boolean processDigit(int[] count, int total, int low) {\n+        \/*\n+         * Check if we can skip the given digit.\n+         *\/\n+        for (int c : count) {\n+            if (c == total) {\n+                return false;\n+            }\n+            if (c > 0) {\n+                break;\n+            }\n+        }\n+\n+        \/*\n+         * Compute the histogram.\n+         *\/\n+        count[0] += low;\n+\n+        for (int i = 0; ++i < count.length; ) {\n+            count[i] += count[i - 1];\n+        }\n+        return true;\n+    }\n+\n+\/\/ #[class]\n+\n+    \/**\n+     * Implementation of parallel sorting.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    private static final class Sorter<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n+        @SuppressWarnings(\"serial\")\n+        private final T a, b;\n+        private final int low, size, offset, depth;\n+\n+        @SuppressWarnings(\"unchecked\")\n+        private Sorter(T a, int parallelism, int low, int size) {\n+            this.a = a;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = low;\n+            this.b = (T) tryAllocate(a.getClass(), size);\n+            this.depth = b == null ? 0 : ((parallelism >> 7) + 2) * (-2);\n+        }\n+\n+        private Sorter(CountedCompleter<?> parent,\n+                T a, T b, int low, int size, int offset, int depth) {\n+            super(parent);\n+            this.a = a;\n+            this.b = b;\n+            this.low = low;\n+            this.size = size;\n+            this.offset = offset;\n+            this.depth = depth;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            if (depth < 0) {\n+                setPendingCount(2);\n+                int half = size >> 1;\n+                new Sorter<>(this, b, a, low, half, offset, depth + 1).fork();\n+                new Sorter<>(this, b, a, low + half, size - half, offset, depth + 1).compute();\n+            } else {\n+                switch(a) {\n+                    case int[] ai -> sort((Sorter<int[]>) this, ai, depth, low, low + size);\n+                    case long[] al -> sort((Sorter<long[]>) this, al, depth, low, low + size);\n+                    case float[] af -> sort((Sorter<float[]>) this, af, depth, low, low + size);\n+                    case double[] ad -> sort((Sorter<double[]>) this, ad, depth, low, low + size);\n+                    default -> throw new IllegalArgumentException(\"Unknown array: \" + a.getClass().getName());\n+                }\n+            }\n+            tryComplete();\n+        }\n+\n+        @Override\n+        public void onCompletion(CountedCompleter<?> caller) {\n+            if (depth < 0) {\n+                int mi = low + (size >> 1);\n+                boolean src = (depth & 1) == 0;\n+\n+                new Merger<>(null,\n+                    a,\n+                    src ? low : low - offset,\n+                    b,\n+                    src ? low - offset : low,\n+                    src ? mi - offset : mi,\n+                    src ? mi - offset : mi,\n+                    src ? low + size - offset : low + size\n+                ).invoke();\n+            }\n+        }\n+\n+        private void fork(int depth, int low, int high) {\n+            addToPendingCount(1);\n+            new Sorter<>(this, a, b, low, high - low, offset, depth).fork();\n+        }\n+    }\n+\n+    \/**\n+     * Implementation of parallel merging.\n+     *\n+     * @param <T> the class of array\n+     *\/\n+    private static final class Merger<T> extends CountedCompleter<Void> {\n+\n+        @java.io.Serial\n+        private static final long serialVersionUID = 123456789L;\n+\n+        @SuppressWarnings(\"serial\")\n+        private final T dst, src;\n+        private final int k, lo1, hi1, lo2, hi2;\n+\n+        private Merger(CountedCompleter<?> parent, T dst, int k,\n+                T src, int lo1, int hi1, int lo2, int hi2) {\n+            super(parent);\n+            this.dst = dst;\n+            this.k = k;\n+            this.src = src;\n+            this.lo1 = lo1;\n+            this.hi1 = hi1;\n+            this.lo2 = lo2;\n+            this.hi2 = hi2;\n+        }\n+\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        public void compute() {\n+            switch(dst) {\n+                case int[] di -> mergeParts((Merger<int[]>) this, di, k, (int[]) src, lo1, hi1, lo2, hi2);\n+                case long[] dl -> mergeParts((Merger<long[]>) this, dl, k, (long[]) src, lo1, hi1, lo2, hi2);\n+                case float[] df -> mergeParts((Merger<float[]>) this, df, k, (float[]) src, lo1, hi1, lo2, hi2);\n+                case double[] dd -> mergeParts((Merger<double[]>) this, dd, k, (double[]) src, lo1, hi1, lo2, hi2);\n+                default -> throw new IllegalArgumentException(\"Unknown array: \" + dst.getClass().getName());\n+            }\n+            propagateCompletion();\n+        }\n+\n+        private void fork(int k, int lo1, int hi1, int lo2, int hi2) {\n+            addToPendingCount(1);\n+            new Merger<>(this, dst, k, src, lo1, hi1, lo2, hi2).fork();\n+        }\n+    }\n+\n+    \/**\n+     * Tries to allocate additional buffer.\n+     *\n+     * @param <T> the class of array\n+     * @param clazz the given array class\n+     * @param length the length of additional buffer\n+     * @return {@code null} if requested buffer is too big or there is no enough memory,\n+     *         otherwise created buffer\n+     *\/\n+    @SuppressWarnings(\"unchecked\")\n+    private static <T> T tryAllocate(Class<T> clazz, int length) {\n+        try {\n+            int maxLength = MAX_BUFFER_SIZE >>\n+                (clazz == int[].class || clazz == float[].class ? 2 : 3);\n+            return length > maxLength ? null :\n+                (T) U.allocateUninitializedArray(clazz.componentType(), length);\n+        } catch (OutOfMemoryError e) {\n+            return null;\n+        }\n+    }\n+\n+    private static final Unsafe U = Unsafe.getUnsafe();\n+}\n+#end[Common2]\n","filename":"src\/java.base\/share\/classes\/java\/util\/DualPivotQuicksort.java.template","additions":1606,"deletions":0,"binary":false,"changes":1606,"status":"added"},{"patch":"@@ -0,0 +1,24 @@\n+#!\/bin\/bash\n+\n+javac -d . ..\/..\/..\/..\/..\/..\/make\/jdk\/src\/classes\/build\/tools\/spp\/Spp.java\n+\n+in=DualPivotQuicksort.java.template\n+out=DualPivotQuicksort.java\n+\n+rm -rf $out\n+\n+gen() {\n+    java build.tools.spp.Spp -nel -Dtype=$1 -DTYPE=$2 -K$3 -K$4 -K$5 -K$6 -K$7 -i$in -o$out\n+}\n+\n+gen \"\"     \"\"     Common1  \"\"            \"\"                 \"\"          \"\"\n+gen int    INT    AllTypes AllExceptByte IntLongFloatDouble IntLong     \"\"\n+gen long   LONG   AllTypes AllExceptByte IntLongFloatDouble IntLong     \"\"\n+gen byte   \"\"     AllTypes \"\"            \"\"                 \"\"          Byte\n+gen char   \"\"     AllTypes AllExceptByte \"\"                 CharShort   Char\n+gen short  \"\"     AllTypes AllExceptByte \"\"                 CharShort   Short\n+gen float  FLOAT  AllTypes AllExceptByte IntLongFloatDouble FloatDouble Float\n+gen double DOUBLE AllTypes AllExceptByte IntLongFloatDouble FloatDouble Double\n+gen \"\"     \"\"     Common2  \"\"            \"\"                 \"\"          \"\"\n+\n+rm -rf build\n","filename":"src\/java.base\/share\/classes\/java\/util\/gen-DualPivotQuicksort.sh","additions":24,"deletions":0,"binary":false,"changes":24,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297\n+ * @bug 6880672 6896573 6899694 6976036 7013585 7018258 8003981 8226297 8266431\n@@ -39,1 +39,1 @@\n-import java.util.Comparator;\n+import java.util.Arrays;\n@@ -48,3 +48,3 @@\n-    \/\/ Array lengths used in a long run (default)\n-    private static final int[] LONG_RUN_LENGTHS = {\n-        1, 3, 8, 21, 55, 100, 1_000, 10_000, 100_000 };\n+    \/\/ Lengths of arrays for [mixed] insertion sort\n+    private static final int[] RUN_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000 };\n@@ -52,3 +52,3 @@\n-    \/\/ Array lengths used in a short run\n-    private static final int[] SHORT_RUN_LENGTHS = {\n-        1, 8, 55, 100, 10_000 };\n+    \/\/ Lengths of arrays for short run\n+    private static final int[] SHORT_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000, 11_000 };\n@@ -56,3 +56,3 @@\n-    \/\/ Random initial values used in a long run (default)\n-    private static final TestRandom[] LONG_RUN_RANDOMS = {\n-        TestRandom.BABA, TestRandom.DEDA, TestRandom.C0FFEE };\n+    \/\/ Lengths of arrays for long run (default)\n+    private static final int[] LONG_LENGTHS =\n+        { 1, 2, 14, 100, 500, 1_000, 11_000, 50_000};\n@@ -60,3 +60,3 @@\n-    \/\/ Random initial values used in a short run\n-    private static final TestRandom[] SHORT_RUN_RANDOMS = {\n-        TestRandom.C0FFEE };\n+    \/\/ Initial random values for short run\n+    private static final TestRandom[] SHORT_RANDOMS =\n+        {TestRandom.C0FFEE};\n@@ -64,1 +64,5 @@\n-    \/\/ Constants used in subarray sorting\n+    \/\/ Initial random values for long run (default)\n+    private static final TestRandom[] LONG_RANDOMS =\n+        {TestRandom.DEDA, TestRandom.BABA, TestRandom.C0FFEE};\n+\n+    \/\/ Constant to fill the left part of array\n@@ -66,0 +70,2 @@\n+\n+    \/\/ Constant to fill the right part of array\n@@ -71,0 +77,1 @@\n+    private final boolean withMin;\n@@ -78,2 +85,9 @@\n-        int[] lengths = shortRun ? SHORT_RUN_LENGTHS : LONG_RUN_LENGTHS;\n-        TestRandom[] randoms = shortRun ? SHORT_RUN_RANDOMS : LONG_RUN_RANDOMS;\n+        int[] lengths = shortRun ? SHORT_LENGTHS : LONG_LENGTHS;\n+        TestRandom[] randoms = shortRun ? SHORT_RANDOMS : LONG_RANDOMS;\n+\n+        new Sorting(SortingHelper.INSERTION_SORT, randoms, false).testBase();\n+        new Sorting(SortingHelper.MIXED_INSERTION_SORT, randoms, true).testBase();\n+        new Sorting(SortingHelper.MERGING_SORT, randoms, lengths).testStructured();\n+\n+        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBase();\n+        new Sorting(SortingHelper.COUNTING_SORT, randoms, lengths).testBase();\n@@ -82,2 +96,2 @@\n-        new Sorting(SortingHelper.PARALLEL_SORT, randoms, lengths).testCore();\n-        new Sorting(SortingHelper.HEAP_SORT, randoms, lengths).testBasic();\n+        new Sorting(SortingHelper.PARALLEL_QUICKSORT, randoms, lengths).testCore();\n+\n@@ -88,1 +102,5 @@\n-        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1000);\n+        out.format(\"PASSED in %d sec.\\n\", (end - start) \/ 1_000);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, boolean withMin) {\n+        this(sortingHelper, randoms, RUN_LENGTHS, withMin);\n@@ -92,0 +110,4 @@\n+        this(sortingHelper, randoms, lengths, false);\n+    }\n+\n+    private Sorting(SortingHelper sortingHelper, TestRandom[] randoms, int[] lengths, boolean withMin) {\n@@ -95,0 +117,1 @@\n+        this.withMin = withMin;\n@@ -97,1 +120,1 @@\n-    private void testBasic() {\n+    private void testBase() {\n@@ -101,4 +124,2 @@\n-            createData(length);\n-            testBasic(length);\n-        }\n-    }\n+            createArray(length);\n+            testStructured(length);\n@@ -106,5 +127,5 @@\n-    private void testBasic(int length) {\n-        for (TestRandom random : randoms) {\n-            testWithInsertionSort(length, random);\n-            testWithCheckSum(length, random);\n-            testWithScrambling(length, random);\n+            for (TestRandom random : randoms) {\n+                testWithCheckSum(length, random);\n+                testWithInsertionSort(length, random);\n+                testWithScrambling(length, random);\n+            }\n@@ -115,8 +136,1 @@\n-        for (int length : lengths) {\n-            createData(length);\n-            testCore(length);\n-        }\n-    }\n-\n-    private void testCore(int length) {\n-        testBasic(length);\n+        testBase();\n@@ -124,9 +138,0 @@\n-        for (TestRandom random : randoms) {\n-            testMergingSort(length, random);\n-            testSubArray(length, random);\n-            testNegativeZero(length, random);\n-            testFloatingPointSorting(length, random);\n-        }\n-    }\n-\n-    private void testAll() {\n@@ -134,36 +139,1 @@\n-            createData(length);\n-            testAll(length);\n-        }\n-    }\n-\n-    private void testAll(int length) {\n-        testCore(length);\n-\n-        for (TestRandom random : randoms) {\n-            testRange(length, random);\n-            testStability(length, random);\n-        }\n-    }\n-\n-    private void testEmptyArray() {\n-        testEmptyAndNullIntArray();\n-        testEmptyAndNullLongArray();\n-        testEmptyAndNullByteArray();\n-        testEmptyAndNullCharArray();\n-        testEmptyAndNullShortArray();\n-        testEmptyAndNullFloatArray();\n-        testEmptyAndNullDoubleArray();\n-    }\n-\n-    private void testStability(int length, TestRandom random) {\n-        printTestName(\"Test stability\", random, length);\n-\n-        Pair[] a = build(length, random);\n-        sortingHelper.sort(a);\n-        checkSorted(a);\n-        checkStable(a);\n-\n-        a = build(length, random);\n-        sortingHelper.sort(a, pairComparator);\n-        checkSorted(a);\n-        checkStable(a);\n+            createArray(length);\n@@ -171,32 +141,3 @@\n-        out.println();\n-    }\n-\n-    private void testEmptyAndNullIntArray() {\n-        sortingHelper.sort(new int[] {});\n-        sortingHelper.sort(new int[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(int[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(int[]) shouldn't catch null array\");\n-    }\n-\n-    private void testEmptyAndNullLongArray() {\n-        sortingHelper.sort(new long[] {});\n-        sortingHelper.sort(new long[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n+            for (TestRandom random : randoms) {\n+                testNegativeZero(length, random);\n+                testFloatingPointSorting(length, random);\n@@ -204,2 +145,0 @@\n-            fail(sortingHelper + \"(long[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n@@ -207,1 +146,0 @@\n-        fail(sortingHelper + \"(long[]) shouldn't catch null array\");\n@@ -210,3 +148,2 @@\n-    private void testEmptyAndNullByteArray() {\n-        sortingHelper.sort(new byte[] {});\n-        sortingHelper.sort(new byte[] {}, 0, 0);\n+    private void testAll() {\n+        testCore();\n@@ -214,10 +151,3 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(byte[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n+        for (int length : lengths) {\n+            createArray(length);\n+            sortRange(length);\n@@ -225,1 +155,0 @@\n-        fail(sortingHelper + \"(byte[]) shouldn't catch null array\");\n@@ -228,17 +157,3 @@\n-    private void testEmptyAndNullCharArray() {\n-        sortingHelper.sort(new char[] {});\n-        sortingHelper.sort(new char[] {}, 0, 0);\n-\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(char[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(char[]) shouldn't catch null array\");\n-    }\n+    private void testEmptyArray() {\n+        sortingHelper.sort(new int[]{});\n+        sortingHelper.sort(new int[]{}, 0, 0);\n@@ -246,3 +161,2 @@\n-    private void testEmptyAndNullShortArray() {\n-        sortingHelper.sort(new short[] {});\n-        sortingHelper.sort(new short[] {}, 0, 0);\n+        sortingHelper.sort(new long[]{});\n+        sortingHelper.sort(new long[]{}, 0, 0);\n@@ -250,13 +164,2 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(short[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(short[]) shouldn't catch null array\");\n-    }\n+        sortingHelper.sort(new byte[]{});\n+        sortingHelper.sort(new byte[]{}, 0, 0);\n@@ -264,3 +167,2 @@\n-    private void testEmptyAndNullFloatArray() {\n-        sortingHelper.sort(new float[] {});\n-        sortingHelper.sort(new float[] {}, 0, 0);\n+        sortingHelper.sort(new char[]{});\n+        sortingHelper.sort(new char[]{}, 0, 0);\n@@ -268,13 +170,2 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(float[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(float[]) shouldn't catch null array\");\n-    }\n+        sortingHelper.sort(new short[]{});\n+        sortingHelper.sort(new short[]{}, 0, 0);\n@@ -282,3 +173,2 @@\n-    private void testEmptyAndNullDoubleArray() {\n-        sortingHelper.sort(new double[] {});\n-        sortingHelper.sort(new double[] {}, 0, 0);\n+        sortingHelper.sort(new float[]{});\n+        sortingHelper.sort(new float[]{}, 0, 0);\n@@ -286,12 +176,2 @@\n-        try {\n-            sortingHelper.sort(null);\n-        } catch (NullPointerException expected) {\n-            try {\n-                sortingHelper.sort(null, 0, 0);\n-            } catch (NullPointerException expected2) {\n-                return;\n-            }\n-            fail(sortingHelper + \"(double[],fromIndex,toIndex) shouldn't \" +\n-                \"catch null array\");\n-        }\n-        fail(sortingHelper + \"(double[]) shouldn't catch null array\");\n+        sortingHelper.sort(new double[]{});\n+        sortingHelper.sort(new double[]{}, 0, 0);\n@@ -300,20 +180,2 @@\n-    private void testSubArray(int length, TestRandom random) {\n-        if (length < 4) {\n-            return;\n-        }\n-        for (int m = 1; m < length \/ 2; m <<= 1) {\n-            int fromIndex = m;\n-            int toIndex = length - m;\n-\n-            prepareSubArray((int[]) gold[0], fromIndex, toIndex);\n-            convertData(length);\n-\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test subarray\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                sortingHelper.sort(test[i], fromIndex, toIndex);\n-                checkSubArray(test[i], fromIndex, toIndex);\n-            }\n-        }\n-        out.println();\n-    }\n+    private void sortRange(int length) {\n+        int[] a = (int[]) gold[0];\n@@ -321,4 +183,0 @@\n-    private void testRange(int length, TestRandom random) {\n-        if (length < 2) {\n-            return;\n-        }\n@@ -326,2 +184,2 @@\n-            for (int i = 1; i <= length; i++) {\n-                ((int[]) gold[0]) [i - 1] = i % m + m % i;\n+            for (int i = 1; i <= length; ++i) {\n+                a[i - 1] = i % m + m % i;\n@@ -329,1 +187,1 @@\n-            convertData(length);\n+            convertArray(m \/ 4);\n@@ -331,4 +189,4 @@\n-            for (int i = 0; i < test.length; i++) {\n-                printTestName(\"Test range check\", random, length,\n-                    \", m = \" + m + \", \" + getType(i));\n-                checkRange(test[i], m);\n+            for (int i = 0; i < test.length; ++i) {\n+                printTestName(\"Test range check\", length,\n+                        \", m = \" + m + \", \" + getType(i));\n+                sortRange(test[i], m);\n@@ -340,45 +198,0 @@\n-    private void checkSorted(Pair[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n-            if (a[i].getKey() > a[i + 1].getKey()) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" +\n-                    a[i].getKey() + \" and \" + a[i + 1].getKey());\n-            }\n-        }\n-    }\n-\n-    private void checkStable(Pair[] a) {\n-        for (int i = 0; i < a.length \/ 4; ) {\n-            int key1 = a[i].getKey();\n-            int value1 = a[i++].getValue();\n-            int key2 = a[i].getKey();\n-            int value2 = a[i++].getValue();\n-            int key3 = a[i].getKey();\n-            int value3 = a[i++].getValue();\n-            int key4 = a[i].getKey();\n-            int value4 = a[i++].getValue();\n-\n-            if (!(key1 == key2 && key2 == key3 && key3 == key4)) {\n-                fail(\"Keys are different \" + key1 + \", \" + key2 + \", \" +\n-                    key3 + \", \" + key4 + \" at position \" + i);\n-            }\n-            if (!(value1 < value2 && value2 < value3 && value3 < value4)) {\n-                fail(\"Sorting is not stable at position \" + i +\n-                    \". Second values have been changed: \" + value1 + \", \" +\n-                    value2 + \", \" + value3 + \", \" + value4);\n-            }\n-        }\n-    }\n-\n-    private Pair[] build(int length, Random random) {\n-        Pair[] a = new Pair[length * 4];\n-\n-        for (int i = 0; i < a.length; ) {\n-            int key = random.nextInt();\n-            a[i++] = new Pair(key, 1);\n-            a[i++] = new Pair(key, 2);\n-            a[i++] = new Pair(key, 3);\n-            a[i++] = new Pair(key, 4);\n-        }\n-        return a;\n-    }\n-\n@@ -386,1 +199,1 @@\n-        if (length > 1000) {\n+        if (length > 1_000) {\n@@ -389,0 +202,2 @@\n+        int[] a = (int[]) gold[0];\n+\n@@ -391,2 +206,3 @@\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n+                builder.build(a, m, random);\n+                int shift = m \/ 4;\n+                convertArray(shift);\n@@ -394,1 +210,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -396,3 +212,4 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    sortByInsertionSort(gold[i]);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                    sortingHelper.sort(test[i], shift, length - shift);\n+                    sortByInsertionSort(gold[i], shift, length - shift);\n+                    checkSorted(gold[i], shift);\n@@ -406,2 +223,9 @@\n-    private void testMergingSort(int length, TestRandom random) {\n-        if (length < (4 << 10)) { \/\/ DualPivotQuicksort.MIN_TRY_MERGE_SIZE\n+    private void testStructured() {\n+        for (int length : lengths) {\n+            createArray(length);\n+            testStructured(length);\n+        }\n+    }\n+\n+    private void testStructured(int length) {\n+        if (length < 512) {\n@@ -410,1 +234,1 @@\n-        final int PERIOD = 50;\n+        int[] a = (int[]) gold[0];\n@@ -412,4 +236,4 @@\n-        for (int m = PERIOD - 2; m <= PERIOD + 2; m++) {\n-            for (MergingBuilder builder : MergingBuilder.values()) {\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n+        for (int m = 1; m < 8; ++m) {\n+            for (StructuredBuilder builder : StructuredBuilder.values()) {\n+                builder.build(a, m);\n+                convertArray(0);\n@@ -417,5 +241,5 @@\n-                for (int i = 0; i < test.length; i++) {\n-                    printTestName(\"Test merging sort\", random, length,\n-                        \", m = \" + m + \", \" +  getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkSorted(test[i]);\n+                for (int i = 0; i < test.length; ++i) {\n+                    printTestName(\"Test structured\", length,\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                    sortingHelper.sort(test[i]\/*, shift, length - shift*\/);\n+                    checkSorted(test[i], 0);\n@@ -429,0 +253,2 @@\n+        int[] a = (int[]) gold[0];\n+\n@@ -431,2 +257,3 @@\n-                builder.build((int[]) gold[0], m, random);\n-                convertData(length);\n+                builder.build(a, m, random);\n+                int shift = m \/ 4;\n+                convertArray(shift);\n@@ -434,1 +261,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -436,3 +263,3 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n-                    sortingHelper.sort(test[i]);\n-                    checkWithCheckSum(test[i], gold[i]);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                    sortingHelper.sort(test[i], shift, length - shift);\n+                    checkWithCheckSum(test[i], gold[i], shift);\n@@ -446,0 +273,2 @@\n+        int[] a = (int[]) gold[0];\n+\n@@ -448,2 +277,2 @@\n-                builder.build((int[]) gold[0], m);\n-                convertData(length);\n+                builder.build(a, m);\n+                convertArray(0);\n@@ -451,1 +280,1 @@\n-                for (int i = 0; i < test.length; i++) {\n+                for (int i = 0; i < test.length; ++i) {\n@@ -453,1 +282,1 @@\n-                        \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n+                            \", m = \" + m + \", \" + getType(i) + \" \" + builder);\n@@ -464,1 +293,1 @@\n-        for (int i = 5; i < test.length; i++) {\n+        for (int i = 5; i < test.length; ++i) {\n@@ -467,1 +296,1 @@\n-            NegativeZeroBuilder builder = NegativeZeroBuilder.values() [i - 5];\n+            NegativeZeroBuilder builder = NegativeZeroBuilder.values()[i - 5];\n@@ -477,1 +306,1 @@\n-        if (length < 2) {\n+        if (length < 6) {\n@@ -480,1 +309,2 @@\n-        final int MAX = 13;\n+        final int MAX = 14;\n+        int s = 4;\n@@ -482,6 +312,6 @@\n-        for (int a = 0; a < MAX; a++) {\n-            for (int g = 0; g < MAX; g++) {\n-                for (int z = 0; z < MAX; z++) {\n-                    for (int n = 0; n < MAX; n++) {\n-                        for (int p = 0; p < MAX; p++) {\n-                            if (a + g + z + n + p != length) {\n+        for (int k = 0; k < MAX; ++k) {\n+            for (int g = 0; g < MAX; ++g) {\n+                for (int z = 0; z < MAX; ++z) {\n+                    for (int n = 0; n < MAX; ++n) {\n+                        for (int p = 0; p < MAX; ++p) {\n+                            if (k + g + z + n + p + s != length) {\n@@ -490,1 +320,1 @@\n-                            for (int i = 5; i < test.length; i++) {\n+                            for (int i = 5; i < test.length; ++i) {\n@@ -492,2 +322,2 @@\n-                                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n+                                        \", k = \" + k + \", g = \" + g + \", z = \" + z +\n+                                                \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n@@ -495,1 +325,1 @@\n-                                builder.build(gold[i], a, g, z, n, p, random);\n+                                builder.build(gold[i], k, g, z, n, p, random);\n@@ -499,1 +329,1 @@\n-                                compare(test[i], gold[i], a, n, g);\n+                                compare(test[i], gold[i], k, n + 2, g);\n@@ -507,4 +337,3 @@\n-        for (int m = 13; m > 4; m--) {\n-            int t = length \/ m;\n-            int g = t, z = t, n = t, p = t;\n-            int a = length - g - z - n - p;\n+        for (int m = MAX; m > 4; --m) {\n+            int g = length \/ m;\n+            int k = length - g - g - g - g - s;\n@@ -512,1 +341,1 @@\n-            for (int i = 5; i < test.length; i++) {\n+            for (int i = 5; i < test.length; ++i) {\n@@ -514,4 +343,4 @@\n-                    \", a = \" + a + \", g = \" + g + \", z = \" + z +\n-                    \", n = \" + n + \", p = \" + p + \", \" + getType(i));\n-                FloatingPointBuilder builder = FloatingPointBuilder.values() [i - 5];\n-                builder.build(gold[i], a, g, z, n, p, random);\n+                        \", k = \" + k + \", g = \" + g + \", z = \" + g +\n+                                \", n = \" + g + \", p = \" + g + \", \" + getType(i));\n+                FloatingPointBuilder builder = FloatingPointBuilder.values()[i - 5];\n+                builder.build(gold[i], k, g, g, g, g, random);\n@@ -521,1 +350,1 @@\n-                compare(test[i], gold[i], a, n, g);\n+                compare(test[i], gold[i], k, g + 2, g);\n@@ -527,20 +356,0 @@\n-    private void prepareSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            a[i] = A380;\n-        }\n-        int middle = (fromIndex + toIndex) >>> 1;\n-        int k = 0;\n-\n-        for (int i = fromIndex; i < middle; i++) {\n-            a[i] = k++;\n-        }\n-\n-        for (int i = middle; i < toIndex; i++) {\n-            a[i] = k--;\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            a[i] = B747;\n-        }\n-    }\n-\n@@ -548,16 +357,9 @@\n-        if (a instanceof int[]) {\n-            scramble((int[]) a, random);\n-        } else if (a instanceof long[]) {\n-            scramble((long[]) a, random);\n-        } else if (a instanceof byte[]) {\n-            scramble((byte[]) a, random);\n-        } else if (a instanceof char[]) {\n-            scramble((char[]) a, random);\n-        } else if (a instanceof short[]) {\n-            scramble((short[]) a, random);\n-        } else if (a instanceof float[]) {\n-            scramble((float[]) a, random);\n-        } else if (a instanceof double[]) {\n-            scramble((double[]) a, random);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case int[] ai -> scramble(ai, random);\n+            case long[] al -> scramble(al, random);\n+            case byte[] ab -> scramble(ab, random);\n+            case char[] ac -> scramble(ac, random);\n+            case short[] as -> scramble(as, random);\n+            case float[] af -> scramble(af, random);\n+            case double[] ad -> scramble(ad, random);\n+            default -> fail(a);\n@@ -568,2 +370,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 0; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -574,2 +382,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -580,2 +394,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -586,2 +406,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -592,2 +418,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -598,2 +430,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -604,2 +442,8 @@\n-        for (int i = 0; i < a.length * 7; i++) {\n-            swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+        if (withMin) {\n+            for (int i = 7; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length - 1) + 1, random.nextInt(a.length - 1) + 1);\n+            }\n+        } else {\n+            for (int i = 1; i < a.length * 7; ++i) {\n+                swap(a, random.nextInt(a.length), random.nextInt(a.length));\n+            }\n@@ -610,1 +454,3 @@\n-        int t = a[i]; a[i] = a[j]; a[j] = t;\n+        int t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -614,1 +460,3 @@\n-        long t = a[i]; a[i] = a[j]; a[j] = t;\n+        long t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -618,1 +466,3 @@\n-        byte t = a[i]; a[i] = a[j]; a[j] = t;\n+        byte t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -622,1 +472,3 @@\n-        char t = a[i]; a[i] = a[j]; a[j] = t;\n+        char t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -626,1 +478,3 @@\n-        short t = a[i]; a[i] = a[j]; a[j] = t;\n+        short t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -630,1 +484,3 @@\n-        float t = a[i]; a[i] = a[j]; a[j] = t;\n+        float t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -634,1 +490,3 @@\n-        double t = a[i]; a[i] = a[j]; a[j] = t;\n+        double t = a[i];\n+        a[i] = a[j];\n+        a[j] = t;\n@@ -637,2 +495,2 @@\n-    private void checkWithCheckSum(Object test, Object gold) {\n-        checkSorted(test);\n+    private void checkWithCheckSum(Object test, Object gold, int m) {\n+        checkSorted(test, m);\n@@ -642,5 +500,0 @@\n-    private void fail(String message) {\n-        err.format(\"\\n*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n-        throw new RuntimeException(\"Test failed\");\n-    }\n-\n@@ -648,6 +501,4 @@\n-        if (a instanceof float[]) {\n-            checkNegativeZero((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkNegativeZero((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case float[] af -> checkNegativeZero(af);\n+            case double[] ad -> checkNegativeZero(ad);\n+            default -> fail(a);\n@@ -658,1 +509,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -666,1 +517,1 @@\n-        for (int i = 0; i < a.length - 1; i++) {\n+        for (int i = 0; i < a.length - 1; ++i) {\n@@ -674,6 +525,4 @@\n-        if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b, numNaN, numNeg, numNegZero);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b, numNaN, numNeg, numNegZero);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case float[] af -> compare(af, (float[]) b, numNaN, numNeg, numNegZero);\n+            case double[] ad -> compare(ad, (double[]) b, numNaN, numNeg, numNegZero);\n+            default -> fail(a);\n@@ -684,2 +533,2 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n+            if (!Float.isNaN(a[i])) {\n@@ -691,2 +540,2 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Float.floatToIntBits(a[i])) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n+            if (Float.floatToIntBits(a[i]) != NEGATIVE_ZERO) {\n@@ -697,1 +546,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -705,2 +554,2 @@\n-        for (int i = a.length - numNaN; i < a.length; i++) {\n-            if (a[i] == a[i]) {\n+        for (int i = a.length - numNaN; i < a.length; ++i) {\n+            if (!Double.isNaN(a[i])) {\n@@ -712,2 +561,2 @@\n-        for (int i = numNeg; i < numNeg + numNegZero; i++) {\n-            if (NEGATIVE_ZERO != Double.doubleToLongBits(a[i])) {\n+        for (int i = numNeg; i < numNeg + numNegZero; ++i) {\n+            if (Double.doubleToLongBits(a[i]) != NEGATIVE_ZERO) {\n@@ -718,1 +567,1 @@\n-        for (int i = 0; i < a.length - numNaN; i++) {\n+        for (int i = 0; i < a.length - numNaN; ++i) {\n@@ -726,16 +575,9 @@\n-        if (a instanceof int[]) {\n-            compare((int[]) a, (int[]) b);\n-        } else if (a instanceof long[]) {\n-            compare((long[]) a, (long[]) b);\n-        } else if (a instanceof byte[]) {\n-            compare((byte[]) a, (byte[]) b);\n-        } else if (a instanceof char[]) {\n-            compare((char[]) a, (char[]) b);\n-        } else if (a instanceof short[]) {\n-            compare((short[]) a, (short[]) b);\n-        } else if (a instanceof float[]) {\n-            compare((float[]) a, (float[]) b);\n-        } else if (a instanceof double[]) {\n-            compare((double[]) a, (double[]) b);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+        switch (a) {\n+            case int[] ai -> compare(ai, (int[]) b);\n+            case long[] al -> compare(al, (long[]) b);\n+            case byte[] ab -> compare(ab, (byte[]) b);\n+            case char[] ac -> compare(ac, (char[]) b);\n+            case short[] as -> compare(as, (short[]) b);\n+            case float[] af -> compare(af, (float[]) b);\n+            case double[] ad -> compare(ad, (double[]) b);\n+            default -> fail(a);\n@@ -746,1 +588,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -754,1 +596,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -762,1 +604,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -770,1 +612,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -778,1 +620,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -786,1 +628,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -794,1 +636,1 @@\n-        for (int i = 0; i < a.length; i++) {\n+        for (int i = 0; i < a.length; ++i) {\n@@ -804,23 +646,10 @@\n-        if (a instanceof int[]) {\n-            return \"INT   \";\n-        }\n-        if (a instanceof long[]) {\n-            return \"LONG  \";\n-        }\n-        if (a instanceof byte[]) {\n-            return \"BYTE  \";\n-        }\n-        if (a instanceof char[]) {\n-            return \"CHAR  \";\n-        }\n-        if (a instanceof short[]) {\n-            return \"SHORT \";\n-        }\n-        if (a instanceof float[]) {\n-            return \"FLOAT \";\n-        }\n-        if (a instanceof double[]) {\n-            return \"DOUBLE\";\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return null;\n+        return switch (a) {\n+            case int[] _ -> \"INT   \";\n+            case long[] _ -> \"LONG  \";\n+            case byte[] _ -> \"BYTE  \";\n+            case char[] _ -> \"CHAR  \";\n+            case short[] _ -> \"SHORT \";\n+            case float[] _ -> \"FLOAT \";\n+            case double[] _ -> \"DOUBLE\";\n+            default -> null;\n+        };\n@@ -829,17 +658,10 @@\n-    private void checkSorted(Object a) {\n-        if (a instanceof int[]) {\n-            checkSorted((int[]) a);\n-        } else if (a instanceof long[]) {\n-            checkSorted((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            checkSorted((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            checkSorted((char[]) a);\n-        } else if (a instanceof short[]) {\n-            checkSorted((short[]) a);\n-        } else if (a instanceof float[]) {\n-            checkSorted((float[]) a);\n-        } else if (a instanceof double[]) {\n-            checkSorted((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n+    private void checkSorted(Object a, int m) {\n+        switch (a) {\n+            case int[] ai -> checkSorted(ai, m);\n+            case long[] al -> checkSorted(al, m);\n+            case byte[] ab -> checkSorted(ab, m);\n+            case char[] ac -> checkSorted(ac, m);\n+            case short[] as -> checkSorted(as, m);\n+            case float[] af -> checkSorted(af, m);\n+            case double[] ad -> checkSorted(ad, m);\n+            default -> fail(a);\n@@ -849,2 +671,7 @@\n-    private void checkSorted(int[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(int[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -855,0 +682,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -857,2 +689,7 @@\n-    private void checkSorted(long[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(long[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != toLong(A380)) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -863,0 +700,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != toLong(B747)) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -865,2 +707,7 @@\n-    private void checkSorted(byte[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(byte[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (byte) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -871,0 +718,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (byte) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -873,2 +725,7 @@\n-    private void checkSorted(char[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(char[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (char) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -879,0 +736,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (char) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -881,2 +743,7 @@\n-    private void checkSorted(short[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(short[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (short) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex(a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -887,0 +754,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (short) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex(a[i], B747));\n+            }\n+        }\n@@ -889,2 +761,7 @@\n-    private void checkSorted(float[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(float[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != (float) A380) {\n+                fail(\"Sort changes left element at position \" + i + hex((long) a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -895,0 +772,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != (float) B747) {\n+                fail(\"Sort changes right element at position \" + i + hex((long) a[i], B747));\n+            }\n+        }\n@@ -897,2 +779,7 @@\n-    private void checkSorted(double[] a) {\n-        for (int i = 0; i < a.length - 1; i++) {\n+    private void checkSorted(double[] a, int m) {\n+        for (int i = 0; i < m; ++i) {\n+            if (a[i] != toDouble(A380)) {\n+                fail(\"Sort changes left element at position \" + i + hex((long) a[i], A380));\n+            }\n+        }\n+        for (int i = m; i < a.length - m - 1; ++i) {\n@@ -903,0 +790,5 @@\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            if (a[i] != B747) {\n+                fail(\"Sort changes right element at position \" + i + hex((long) a[i], B747));\n+            }\n+        }\n@@ -915,23 +807,10 @@\n-        if (a instanceof int[]) {\n-            return checkSumXor((int[]) a);\n-        }\n-        if (a instanceof long[]) {\n-            return checkSumXor((long[]) a);\n-        }\n-        if (a instanceof byte[]) {\n-            return checkSumXor((byte[]) a);\n-        }\n-        if (a instanceof char[]) {\n-            return checkSumXor((char[]) a);\n-        }\n-        if (a instanceof short[]) {\n-            return checkSumXor((short[]) a);\n-        }\n-        if (a instanceof float[]) {\n-            return checkSumXor((float[]) a);\n-        }\n-        if (a instanceof double[]) {\n-            return checkSumXor((double[]) a);\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n+        return switch (a) {\n+            case int[] ai -> checkSumXor(ai);\n+            case long[] al -> checkSumXor(al);\n+            case byte[] ab -> checkSumXor(ab);\n+            case char[] ac -> checkSumXor(ac);\n+            case short[] as -> checkSumXor(as);\n+            case float[] af -> checkSumXor(af);\n+            case double[] ad -> checkSumXor(ad);\n+            default -> -1;\n+        };\n@@ -964,1 +843,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -973,1 +852,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -982,1 +861,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1004,23 +883,10 @@\n-        if (a instanceof int[]) {\n-            return checkSumPlus((int[]) a);\n-        }\n-        if (a instanceof long[]) {\n-            return checkSumPlus((long[]) a);\n-        }\n-        if (a instanceof byte[]) {\n-            return checkSumPlus((byte[]) a);\n-        }\n-        if (a instanceof char[]) {\n-            return checkSumPlus((char[]) a);\n-        }\n-        if (a instanceof short[]) {\n-            return checkSumPlus((short[]) a);\n-        }\n-        if (a instanceof float[]) {\n-            return checkSumPlus((float[]) a);\n-        }\n-        if (a instanceof double[]) {\n-            return checkSumPlus((double[]) a);\n-        }\n-        fail(\"Unknown type of array: \" + a.getClass().getName());\n-        return -1;\n+        return switch (a) {\n+            case int[] ai -> checkSumPlus(ai);\n+            case long[] al -> checkSumPlus(al);\n+            case byte[] ab -> checkSumPlus(ab);\n+            case char[] ac -> checkSumPlus(ac);\n+            case short[] as -> checkSumPlus(as);\n+            case float[] af -> checkSumPlus(af);\n+            case double[] ad -> checkSumPlus(ad);\n+            default -> -1;\n+        };\n@@ -1053,1 +919,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1062,1 +928,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1071,1 +937,1 @@\n-        return (int) checkSum;\n+        return checkSum;\n@@ -1092,18 +958,2 @@\n-    private void sortByInsertionSort(Object a) {\n-        if (a instanceof int[]) {\n-            sortByInsertionSort((int[]) a);\n-        } else if (a instanceof long[]) {\n-            sortByInsertionSort((long[]) a);\n-        } else if (a instanceof byte[]) {\n-            sortByInsertionSort((byte[]) a);\n-        } else if (a instanceof char[]) {\n-            sortByInsertionSort((char[]) a);\n-        } else if (a instanceof short[]) {\n-            sortByInsertionSort((short[]) a);\n-        } else if (a instanceof float[]) {\n-            sortByInsertionSort((float[]) a);\n-        } else if (a instanceof double[]) {\n-            sortByInsertionSort((double[]) a);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n+    private void sortByInsertionSort(Object a, int low, int high) {\n+        SortingHelper.INSERTION_SORT.sort(a, low, high);\n@@ -1112,8 +962,10 @@\n-    private void sortByInsertionSort(int[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            int ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n+    private void sortRange(Object a, int m) {\n+        switch (a) {\n+            case int[] ai -> sortRange(ai, m);\n+            case long[] al -> sortRange(al, m);\n+            case byte[] ab -> sortRange(ab, m);\n+            case char[] ac -> sortRange(ac, m);\n+            case short[] as -> sortRange(as, m);\n+            case float[] af -> sortRange(af, m);\n+            case double[] ad -> sortRange(ad, m);\n+            default -> fail(a);\n@@ -1123,6 +975,17 @@\n-    private void sortByInsertionSort(long[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            long ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+    private void sortRange(int[] a, int m) {\n+        try {\n+            sortingHelper.sort(a, m + 1, m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+        } catch (IllegalArgumentException iae) {\n+            try {\n+                sortingHelper.sort(a, -m, a.length);\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\n+                try {\n+                    sortingHelper.sort(a, 0, a.length + m);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1130,1 +993,0 @@\n-            a[j + 1] = ai;\n@@ -1134,6 +996,17 @@\n-    private void sortByInsertionSort(byte[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            byte ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+    private void sortRange(long[] a, int m) {\n+        try {\n+            sortingHelper.sort(a, m + 1, m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+        } catch (IllegalArgumentException iae) {\n+            try {\n+                sortingHelper.sort(a, -m, a.length);\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\n+                try {\n+                    sortingHelper.sort(a, 0, a.length + m);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1141,1 +1014,0 @@\n-            a[j + 1] = ai;\n@@ -1145,6 +1017,17 @@\n-    private void sortByInsertionSort(char[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            char ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n+    private void sortRange(byte[] a, int m) {\n+        try {\n+            sortingHelper.sort(a, m + 1, m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n+        } catch (IllegalArgumentException iae) {\n+            try {\n+                sortingHelper.sort(a, -m, a.length);\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n+            } catch (ArrayIndexOutOfBoundsException aoe) {\n+                try {\n+                    sortingHelper.sort(a, 0, a.length + m);\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1152,1 +1035,0 @@\n-            a[j + 1] = ai;\n@@ -1156,214 +1038,1 @@\n-    private void sortByInsertionSort(short[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            short ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(float[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            float ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void sortByInsertionSort(double[] a) {\n-        for (int j, i = 1; i < a.length; i++) {\n-            double ai = a[i];\n-\n-            for (j = i - 1; j >= 0 && ai < a[j]; j--) {\n-                a[j + 1] = a[j];\n-            }\n-            a[j + 1] = ai;\n-        }\n-    }\n-\n-    private void checkSubArray(Object a, int fromIndex, int toIndex) {\n-        if (a instanceof int[]) {\n-            checkSubArray((int[]) a, fromIndex, toIndex);\n-        } else if (a instanceof long[]) {\n-            checkSubArray((long[]) a, fromIndex, toIndex);\n-        } else if (a instanceof byte[]) {\n-            checkSubArray((byte[]) a, fromIndex, toIndex);\n-        } else if (a instanceof char[]) {\n-            checkSubArray((char[]) a, fromIndex, toIndex);\n-        } else if (a instanceof short[]) {\n-            checkSubArray((short[]) a, fromIndex, toIndex);\n-        } else if (a instanceof float[]) {\n-            checkSubArray((float[]) a, fromIndex, toIndex);\n-        } else if (a instanceof double[]) {\n-            checkSubArray((double[]) a, fromIndex, toIndex);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkSubArray(int[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(long[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (long) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (long) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(byte[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (byte) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (byte) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(char[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (char) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (char) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(short[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (short) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex(a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (short) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex(a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(float[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (float) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (float) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkSubArray(double[] a, int fromIndex, int toIndex) {\n-        for (int i = 0; i < fromIndex; i++) {\n-            if (a[i] != (double) A380) {\n-                fail(\"Range sort changes left element at position \" + i + hex((long) a[i], A380));\n-            }\n-        }\n-\n-        for (int i = fromIndex; i < toIndex - 1; i++) {\n-            if (a[i] > a[i + 1]) {\n-                fail(\"Array is not sorted at \" + i + \"-th position: \" + a[i] + \" and \" + a[i + 1]);\n-            }\n-        }\n-\n-        for (int i = toIndex; i < a.length; i++) {\n-            if (a[i] != (double) B747) {\n-                fail(\"Range sort changes right element at position \" + i + hex((long) a[i], B747));\n-            }\n-        }\n-    }\n-\n-    private void checkRange(Object a, int m) {\n-        if (a instanceof int[]) {\n-            checkRange((int[]) a, m);\n-        } else if (a instanceof long[]) {\n-            checkRange((long[]) a, m);\n-        } else if (a instanceof byte[]) {\n-            checkRange((byte[]) a, m);\n-        } else if (a instanceof char[]) {\n-            checkRange((char[]) a, m);\n-        } else if (a instanceof short[]) {\n-            checkRange((short[]) a, m);\n-        } else if (a instanceof float[]) {\n-            checkRange((float[]) a, m);\n-        } else if (a instanceof double[]) {\n-            checkRange((double[]) a, m);\n-        } else {\n-            fail(\"Unknown type of array: \" + a.getClass().getName());\n-        }\n-    }\n-\n-    private void checkRange(int[] a, int m) {\n+    private void sortRange(char[] a, int m) {\n@@ -1372,2 +1041,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1377,2 +1046,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1382,3 +1051,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1389,1 +1059,1 @@\n-    private void checkRange(long[] a, int m) {\n+    private void sortRange(short[] a, int m) {\n@@ -1392,2 +1062,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1397,2 +1067,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1402,3 +1072,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1409,1 +1080,1 @@\n-    private void checkRange(byte[] a, int m) {\n+    private void sortRange(float[] a, int m) {\n@@ -1412,2 +1083,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1417,2 +1088,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1422,3 +1093,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1429,1 +1101,1 @@\n-    private void checkRange(char[] a, int m) {\n+    private void sortRange(double[] a, int m) {\n@@ -1432,2 +1104,2 @@\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n+            fail(sortingHelper + \" must throw IllegalArgumentException: \" +\n+                    \"fromIndex = \" + (m + 1) + \", toIndex = \" + m);\n@@ -1437,2 +1109,2 @@\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n+                fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                        \"fromIndex = \" + (-m));\n@@ -1442,3 +1114,4 @@\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n+                    fail(sortingHelper + \" must throw ArrayIndexOutOfBoundsException: \" +\n+                            \"toIndex = \" + (a.length + m));\n+                } catch (ArrayIndexOutOfBoundsException expected) {\n+                }\n@@ -1449,17 +1122,5 @@\n-    private void checkRange(short[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n+    private void copy(Object dst, Object src) {\n+        switch (src) {\n+            case float[] sf -> System.arraycopy(sf, 0, dst, 0, sf.length);\n+            case double[] sd -> System.arraycopy(sd, 0, dst, 0, sd.length);\n+            default -> fail(src);\n@@ -1469,19 +1130,6 @@\n-    private void checkRange(float[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n-    }\n+    private void createArray(int length) {\n+        gold = new Object[]{\n+                new int[length], new long[length],\n+                new byte[length], new char[length], new short[length],\n+                new float[length], new double[length]\n+        };\n@@ -1489,18 +1137,5 @@\n-    private void checkRange(double[] a, int m) {\n-        try {\n-            sortingHelper.sort(a, m + 1, m);\n-            fail(sortingHelper + \" does not throw IllegalArgumentException \" +\n-                \"as expected: fromIndex = \" + (m + 1) + \" toIndex = \" + m);\n-        } catch (IllegalArgumentException iae) {\n-            try {\n-                sortingHelper.sort(a, -m, a.length);\n-                fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                    \"as expected: fromIndex = \" + (-m));\n-            } catch (ArrayIndexOutOfBoundsException aoe) {\n-                try {\n-                    sortingHelper.sort(a, 0, a.length + m);\n-                    fail(sortingHelper + \" does not throw ArrayIndexOutOfBoundsException \" +\n-                        \"as expected: toIndex = \" + (a.length + m));\n-                } catch (ArrayIndexOutOfBoundsException expected) {}\n-            }\n-        }\n+        test = new Object[]{\n+                new int[length], new long[length],\n+                new byte[length], new char[length], new short[length],\n+                new float[length], new double[length]\n+        };\n@@ -1509,7 +1144,15 @@\n-    private void copy(Object dst, Object src) {\n-        if (src instanceof float[]) {\n-            copy((float[]) dst, (float[]) src);\n-        } else if (src instanceof double[]) {\n-            copy((double[]) dst, (double[]) src);\n-        } else {\n-            fail(\"Unknown type of array: \" + src.getClass().getName());\n+    private void convertArray(int m) {\n+        int[] a = (int[]) gold[0];\n+\n+        for (int i = 0; i < m; ++i) {\n+            a[i] = A380;\n+        }\n+        for (int i = a.length - m; i < a.length; ++i) {\n+            a[i] = B747;\n+        }\n+        for (int i = 0; i < gold.length; ++i) {\n+            TypeConverter converter = TypeConverter.values()[i];\n+            converter.convert(a, gold[i], withMin, m);\n+        }\n+        for (int i = 0; i < gold.length; ++i) {\n+            System.arraycopy(gold[i], 0, test[i], 0, a.length);\n@@ -1519,2 +1162,2 @@\n-    private void copy(float[] dst, float[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n+    private String hex(long a, int b) {\n+        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\n@@ -1523,2 +1166,2 @@\n-    private void copy(double[] dst, double[] src) {\n-        System.arraycopy(src, 0, dst, 0, src.length);\n+    private void printTestName(String test, int length, String message) {\n+        out.println(\"[\" + sortingHelper + \"] '\" + test + \"' length = \" + length + message);\n@@ -1527,2 +1170,3 @@\n-    private void printTestName(String test, TestRandom random, int length) {\n-        printTestName(test, random, length, \"\");\n+    private void printTestName(String test, TestRandom random, int length, String message) {\n+        out.println(\"[\" + sortingHelper + \"] '\" + test +\n+                \"' length = \" + length + \", random = \" + random + message);\n@@ -1531,12 +1175,2 @@\n-    private void createData(int length) {\n-        gold = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n-\n-        test = new Object[] {\n-            new int[length], new long[length],\n-            new byte[length], new char[length], new short[length],\n-            new float[length], new double[length]\n-        };\n+    private void fail(Object a) {\n+        fail(\"Unknown type: \" + a.getClass().getName());\n@@ -1545,9 +1179,3 @@\n-    private void convertData(int length) {\n-        for (int i = 1; i < gold.length; i++) {\n-            TypeConverter converter = TypeConverter.values()[i - 1];\n-            converter.convert((int[])gold[0], gold[i]);\n-        }\n-\n-        for (int i = 0; i < gold.length; i++) {\n-            System.arraycopy(gold[i], 0, test[i], 0, length);\n-        }\n+    private void fail(String message) {\n+        err.format(\"*** TEST FAILED ***\\n\\n%s\\n\\n\", message);\n+        throw new RuntimeException(\"Test failed\");\n@@ -1556,2 +1184,2 @@\n-    private String hex(long a, int b) {\n-        return \": \" + Long.toHexString(a) + \", must be \" + Integer.toHexString(b);\n+    private static long toLong(int i) {\n+        return (((long) i) << 32) | i;\n@@ -1560,3 +1188,5 @@\n-    private void printTestName(String test, TestRandom random, int length, String message) {\n-        out.println( \"[\" + sortingHelper + \"] '\" + test +\n-            \"' length = \" + length + \", random = \" + random + message);\n+    private static double toDouble(int i) {\n+        long v = toLong(i);\n+        v = (v > 0) ? ~v : v & ~(1L << 63);\n+        double d = Double.longBitsToDouble(v);\n+        return Double.isNaN(d) ? 0.0d : d;\n@@ -1565,1 +1195,10 @@\n-    private static enum TypeConverter {\n+    private enum TypeConverter {\n+        INT {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n+                if (withMin) {\n+                    src[m] = Integer.MIN_VALUE;\n+                }\n+            }\n+        },\n+\n@@ -1567,1 +1206,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1570,2 +1210,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (long) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = toLong(src[i]);\n+                }\n+                if (withMin) {\n+                    b[m] = Long.MIN_VALUE;\n@@ -1577,1 +1220,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1580,1 +1224,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1583,0 +1227,3 @@\n+                if (withMin) {\n+                    b[m] = Byte.MIN_VALUE;\n+                }\n@@ -1587,1 +1234,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1590,1 +1238,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1593,0 +1241,3 @@\n+                if (withMin) {\n+                    b[m] = Character.MIN_VALUE;\n+                }\n@@ -1597,1 +1248,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1600,1 +1252,1 @@\n-                for (int i = 0; i < src.length; i++) {\n+                for (int i = 0; i < src.length; ++i) {\n@@ -1603,0 +1255,3 @@\n+                if (withMin) {\n+                    b[m] = Short.MIN_VALUE;\n+                }\n@@ -1607,1 +1262,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1610,2 +1266,5 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (float) src[i];\n+                for (int i = 0; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (withMin) {\n+                    b[m] = Float.NEGATIVE_INFINITY;\n@@ -1617,1 +1276,2 @@\n-            void convert(int[] src, Object dst) {\n+            @Override\n+            void convert(int[] src, Object dst, boolean withMin, int m) {\n@@ -1620,2 +1280,8 @@\n-                for (int i = 0; i < src.length; i++) {\n-                    b[i] = (double) src[i];\n+                for (int i = 0; i < src.length \/ 2; ++i) {\n+                    b[i] = toDouble(src[i]);\n+                }\n+                for (int i = src.length \/ 2; i < src.length; ++i) {\n+                    b[i] = src[i];\n+                }\n+                if (withMin) {\n+                    b[m] = Double.NEGATIVE_INFINITY;\n@@ -1626,1 +1292,1 @@\n-        abstract void convert(int[] src, Object dst);\n+        abstract void convert(int[] src, Object dst, boolean withMin, int m);\n@@ -1629,1 +1295,1 @@\n-    private static enum SortedBuilder {\n+    private enum SortedBuilder {\n@@ -1631,0 +1297,1 @@\n+            @Override\n@@ -1632,1 +1299,1 @@\n-                for (int i = 0; i < m; i++) {\n+                for (int i = 0; i < m; ++i) {\n@@ -1636,1 +1303,1 @@\n-                for (int i = m; i < a.length; i++) {\n+                for (int i = m; i < a.length; ++i) {\n@@ -1645,1 +1312,1 @@\n-    private static enum UnsortedBuilder {\n+    private enum UnsortedBuilder {\n@@ -1647,0 +1314,1 @@\n+            @Override\n@@ -1648,1 +1316,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1654,1 +1322,2 @@\n-        ASCENDING {\n+        PERMUTATION {\n+            @Override\n@@ -1656,2 +1325,10 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m + i;\n+                int mask = ~(0x000000FF << (random.nextInt(4) * 2));\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i & mask;\n+                }\n+                for (int i = a.length; i > 1; --i) {\n+                    int k = random.nextInt(i);\n+                    int t = a[i - 1];\n+                    a[i - 1] = a[k];\n+                    a[k] = t;\n@@ -1662,1 +1339,2 @@\n-        DESCENDING {\n+        UNIFORM {\n+            @Override\n@@ -1664,2 +1342,4 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = a.length - m - i;\n+                int mask = (m << 15) - 1;\n+\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt() & mask;\n@@ -1670,1 +1350,2 @@\n-        EQUAL {\n+        STAGGER {\n+            @Override\n@@ -1672,2 +1353,2 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = m;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = (i * m + i) % a.length;\n@@ -1678,1 +1359,20 @@\n-        SAW {\n+        REPEATED {\n+            @Override\n+            void build(int[] a, int m, Random random) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i % m;\n+                }\n+            }\n+        },\n+\n+        DUPLICATED {\n+            @Override\n+            void build(int[] a, int m, Random random) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m);\n+                }\n+            }\n+        },\n+\n+        SAWTOOTH {\n+            @Override\n@@ -1686,1 +1386,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1694,1 +1394,1 @@\n-                    for (int k = 1; k <= period; k++) {\n+                    for (int k = 1; k <= period; ++k) {\n@@ -1705,9 +1405,2 @@\n-        REPEATED {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % m;\n-                }\n-            }\n-        },\n-\n-        DUPLICATED {\n+        SHUFFLE {\n+            @Override\n@@ -1715,2 +1408,2 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextInt(m);\n+                for (int i = 0, j = 0, k = 1; i < a.length; ++i) {\n+                    a[i] = random.nextInt(m) > 0 ? (j += 2) : (k += 2);\n@@ -1719,5 +1412,1 @@\n-        },\n-\n-        ORGAN_PIPES {\n-            void build(int[] a, int m, Random random) {\n-                int middle = a.length \/ (m + 1);\n+        };\n@@ -1725,3 +1414,2 @@\n-                for (int i = 0; i < middle; i++) {\n-                    a[i] = i;\n-                }\n+        abstract void build(int[] a, int m, Random random);\n+    }\n@@ -1729,2 +1417,6 @@\n-                for (int i = middle; i < a.length; i++) {\n-                    a[i] = a.length - i - 1;\n+    private enum StructuredBuilder {\n+        ASCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = m + i;\n@@ -1735,4 +1427,5 @@\n-        STAGGER {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = (i * m + i) % a.length;\n+        DESCENDING {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = a.length - m - i;\n@@ -1743,5 +1436,4 @@\n-        PLATEAU {\n-            void build(int[] a, int m, Random random) {\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = Math.min(i, m);\n-                }\n+        EQUAL {\n+            @Override\n+            void build(int[] a, int m) {\n+                Arrays.fill(a, m);\n@@ -1751,6 +1443,5 @@\n-        SHUFFLE {\n-            void build(int[] a, int m, Random random) {\n-                int x = 0, y = 0;\n-\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = random.nextBoolean() ? (x += 2) : (y += 2);\n+        SHIFTED {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i << 10;\n@@ -1761,4 +1452,4 @@\n-        LATCH {\n-            void build(int[] a, int m, Random random) {\n-                int max = a.length \/ m;\n-                max = max < 2 ? 2 : max;\n+        ORGAN_PIPES {\n+            @Override\n+            void build(int[] a, int m) {\n+                int middle = a.length \/ (m + 1);\n@@ -1766,2 +1457,5 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = i % max;\n+                for (int i = 0; i < middle; ++i) {\n+                    a[i] = i;\n+                }\n+                for (int i = middle; i < a.length; ++i) {\n+                    a[i] = a.length - i - 1;\n@@ -1770,4 +1464,1 @@\n-        };\n-\n-        abstract void build(int[] a, int m, Random random);\n-    }\n+        },\n@@ -1775,2 +1466,2 @@\n-    private static enum MergingBuilder {\n-        ASCENDING {\n+        PLATEAU {\n+            @Override\n@@ -1778,13 +1469,2 @@\n-                int period = a.length \/ m;\n-                int v = 1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = 1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v++;\n-                    }\n-                }\n-\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v++;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = Math.min(i, m);\n@@ -1792,2 +1472,0 @@\n-\n-                a[a.length - 1] = 0;\n@@ -1797,1 +1475,2 @@\n-        DESCENDING {\n+        LATCH {\n+            @Override\n@@ -1799,10 +1478,1 @@\n-                int period = a.length \/ m;\n-                int v = -1, i = 0;\n-\n-                for (int k = 0; k < m; k++) {\n-                    v = -1;\n-\n-                    for (int p = 0; p < period; p++) {\n-                        a[i++] = v--;\n-                    }\n-                }\n+                int max = Math.max(a.length \/ m, 2);\n@@ -1810,2 +1480,2 @@\n-                for (int j = i; j < a.length - 1; j++) {\n-                    a[j] = v--;\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i % max;\n@@ -1813,2 +1483,0 @@\n-\n-                a[a.length - 1] = 0;\n@@ -1819,0 +1487,1 @@\n+            @Override\n@@ -1820,3 +1489,1 @@\n-                for (int i = 0; i < a.length; i++) {\n-                    a[i] = 0;\n-                }\n+                Arrays.fill(a, 0);\n@@ -1828,0 +1495,1 @@\n+            @Override\n@@ -1829,1 +1497,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1832,1 +1500,1 @@\n-                reverse(a, 0, a.length - 1);\n+                reverse(a, Math.max(0, a.length - m), a.length);\n@@ -1837,0 +1505,1 @@\n+            @Override\n@@ -1838,1 +1507,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1841,1 +1510,11 @@\n-                reverse(a, 0, 2);\n+                reverse(a, 0, Math.min(m, a.length));\n+            }\n+        },\n+\n+        TRAPEZIUM {\n+            @Override\n+            void build(int[] a, int m) {\n+                for (int i = 0; i < a.length; ++i) {\n+                    a[i] = i;\n+                }\n+                reverse(a, m, a.length - m);\n@@ -1846,0 +1525,1 @@\n+            @Override\n@@ -1851,1 +1531,1 @@\n-                for (int i = 0, k = level; i < k1; i++) {\n+                for (int i = 0, k = level; i < k1; ++i) {\n@@ -1854,2 +1534,1 @@\n-\n-                for (int i = k1; i < k2; i++) {\n+                for (int i = k1; i < k2; ++i) {\n@@ -1858,2 +1537,1 @@\n-\n-                for (int i = k2, k = level; i < a.length; i++) {\n+                for (int i = k2, k = level; i < a.length; ++i) {\n@@ -1876,1 +1554,1 @@\n-    private static enum NegativeZeroBuilder {\n+    private enum NegativeZeroBuilder {\n@@ -1878,0 +1556,1 @@\n+            @Override\n@@ -1881,1 +1560,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1888,0 +1567,1 @@\n+            @Override\n@@ -1891,1 +1571,1 @@\n-                for (int i = 0; i < a.length; i++) {\n+                for (int i = 0; i < a.length; ++i) {\n@@ -1900,1 +1580,1 @@\n-    private static enum FloatingPointBuilder {\n+    private enum FloatingPointBuilder {\n@@ -1902,1 +1582,2 @@\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n+            @Override\n+            void build(Object o, int k, int g, int z, int n, int p, Random random) {\n@@ -1904,2 +1585,2 @@\n-                float positiveValue =  random.nextFloat();\n-                float[] x = (float[]) o;\n+                float positiveValue = random.nextFloat();\n+                float[] a = (float[]) o;\n@@ -1908,1 +1589,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(a, Float.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, -Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, negativeValue, fromIndex, n);\n@@ -1911,1 +1598,1 @@\n-                writeValue(x, -0.0f, fromIndex, g);\n+                fillWithValue(a, -0.0f, fromIndex, g);\n@@ -1914,1 +1601,1 @@\n-                writeValue(x, 0.0f, fromIndex, z);\n+                fillWithValue(a, 0.0f, fromIndex, z);\n@@ -1917,1 +1604,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(a, positiveValue, fromIndex, p);\n@@ -1920,1 +1607,7 @@\n-                writeValue(x, Float.NaN, fromIndex, a);\n+                fillWithValue(a, Float.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Float.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Float.NaN, fromIndex, k);\n@@ -1925,1 +1618,2 @@\n-            void build(Object o, int a, int g, int z, int n, int p, Random random) {\n+            @Override\n+            void build(Object o, int k, int g, int z, int n, int p, Random random) {\n@@ -1927,2 +1621,2 @@\n-                double positiveValue =  random.nextFloat();\n-                double[] x = (double[]) o;\n+                double positiveValue = random.nextFloat();\n+                double[] a = (double[]) o;\n@@ -1931,1 +1625,7 @@\n-                writeValue(x, negativeValue, fromIndex, n);\n+                fillWithValue(a, Double.NEGATIVE_INFINITY, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(a, -Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex++;\n+\n+                fillWithValue(a, negativeValue, fromIndex, n);\n@@ -1934,1 +1634,1 @@\n-                writeValue(x, -0.0d, fromIndex, g);\n+                fillWithValue(a, -0.0d, fromIndex, g);\n@@ -1937,1 +1637,1 @@\n-                writeValue(x, 0.0d, fromIndex, z);\n+                fillWithValue(a, 0.0d, fromIndex, z);\n@@ -1940,1 +1640,1 @@\n-                writeValue(x, positiveValue, fromIndex, p);\n+                fillWithValue(a, positiveValue, fromIndex, p);\n@@ -1943,1 +1643,7 @@\n-                writeValue(x, Double.NaN, fromIndex, a);\n+                fillWithValue(a, Double.MAX_VALUE, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Double.POSITIVE_INFINITY, fromIndex, 1);\n+                fromIndex += 1;\n+\n+                fillWithValue(a, Double.NaN, fromIndex, k);\n@@ -1947,1 +1653,1 @@\n-        abstract void build(Object o, int a, int g, int z, int n, int p, Random random);\n+        abstract void build(Object o, int k, int g, int z, int n, int p, Random random);\n@@ -1949,2 +1655,2 @@\n-        private static void writeValue(float[] a, float value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(float[] a, float value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1955,2 +1661,2 @@\n-        private static void writeValue(double[] a, double value, int fromIndex, int count) {\n-            for (int i = fromIndex; i < fromIndex + count; i++) {\n+        private static void fillWithValue(double[] a, double value, int fromIndex, int count) {\n+            for (int i = fromIndex; i < fromIndex + count; ++i) {\n@@ -1962,37 +1668,0 @@\n-    private static Comparator<Pair> pairComparator = new Comparator<Pair>() {\n-\n-        @Override\n-        public int compare(Pair p1, Pair p2) {\n-            return p1.compareTo(p2);\n-        }\n-    };\n-\n-    private static class Pair implements Comparable<Pair> {\n-\n-        private Pair(int key, int value) {\n-            this.key = key;\n-            this.value = value;\n-        }\n-\n-        int getKey() {\n-            return key;\n-        }\n-\n-        int getValue() {\n-            return value;\n-        }\n-\n-        @Override\n-        public int compareTo(Pair pair) {\n-            return Integer.compare(key, pair.key);\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"(\" + key + \", \" + value + \")\";\n-        }\n-\n-        private int key;\n-        private int value;\n-    }\n-\n@@ -2001,1 +1670,0 @@\n-        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2003,0 +1671,1 @@\n+        private static final TestRandom BABA = new TestRandom(0xBABA);\n@@ -2015,1 +1684,1 @@\n-        private String seed;\n+        private final String seed;\n","filename":"test\/jdk\/java\/util\/Arrays\/Sorting.java","additions":786,"deletions":1117,"binary":false,"changes":1903,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,1 @@\n- * This class provides access to package-private\n- * methods of DualPivotQuicksort class.\n+ * This class provides access to package-private methods of DualPivotQuicksort class.\n@@ -32,1 +31,1 @@\n- * @version 2019.09.19\n+ * @version 2024.06.14\n@@ -34,1 +33,1 @@\n- * @since 14\n+ * @since 14 * 20 ^ 26\n@@ -38,2 +37,1 @@\n-    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\n-\n+    INSERTION_SORT(\"Insertion sort\") {\n@@ -41,17 +39,10 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.insertionSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.insertionSort(al, low, high);\n+                case byte[] ab -> DualPivotQuicksort.insertionSort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.insertionSort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.insertionSort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.insertionSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.insertionSort(ad, low, high);\n+                default -> fail(a);\n@@ -60,0 +51,1 @@\n+    },\n@@ -61,0 +53,1 @@\n+    MIXED_INSERTION_SORT(\"Mixed insertion sort\") {\n@@ -63,16 +56,9 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, SEQUENTIAL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, SEQUENTIAL, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.mixedInsertionSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.mixedInsertionSort(al, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.mixedInsertionSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.mixedInsertionSort(ad, low, high);\n+                default -> fail(a);\n@@ -81,10 +67,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -93,2 +69,1 @@\n-    PARALLEL_SORT(\"Parallel sort\") {\n-\n+    MERGING_SORT(\"Merging sort\") {\n@@ -96,17 +71,10 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, ai, low, high - low));\n+                case long[] al -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, al, low, high - low));\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, af, low, high - low));\n+                case double[] ad -> check(\"Merging\", DualPivotQuicksort.tryMergingSort(null, ad, low, high - low));\n+                default -> fail(a);\n@@ -115,0 +83,1 @@\n+    },\n@@ -116,0 +85,1 @@\n+    COUNTING_SORT(\"Counting sort\") {\n@@ -118,16 +88,9 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort((int[]) a, PARALLEL, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort((long[]) a, PARALLEL, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, PARALLEL, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, PARALLEL, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort((float[]) a, PARALLEL, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort((double[]) a, PARALLEL, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, 0, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, 0, low, high);\n+                case byte[] ab -> DualPivotQuicksort.countingSort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.countingSort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.countingSort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, 0, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, 0, low, high);\n+                default -> fail(a);\n@@ -136,10 +99,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n-\n-        @Override\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n-        }\n@@ -149,1 +102,0 @@\n-\n@@ -151,17 +103,10 @@\n-        public void sort(Object a) {\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, 0, ((int[]) a).length);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, 0, ((long[]) a).length);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, 0, ((byte[]) a).length);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, 0, ((char[]) a).length);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, 0, ((short[]) a).length);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, 0, ((float[]) a).length);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, 0, ((double[]) a).length);\n-            } else {\n-                fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.heapSort(ai, low, high);\n+                case long[] al -> DualPivotQuicksort.heapSort(al, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.heapSort(af, low, high);\n+                case double[] ad -> DualPivotQuicksort.heapSort(ad, low, high);\n+                default -> fail(a);\n@@ -170,0 +115,1 @@\n+    },\n@@ -171,0 +117,1 @@\n+    DUAL_PIVOT_QUICKSORT(\"Dual-Pivot Quicksort\") {\n@@ -173,16 +120,9 @@\n-            if (a instanceof int[]) {\n-                DualPivotQuicksort.sort(null, (int[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof long[]) {\n-                DualPivotQuicksort.sort(null, (long[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof byte[]) {\n-                DualPivotQuicksort.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                DualPivotQuicksort.sort((char[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof short[]) {\n-                DualPivotQuicksort.sort((short[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof float[]) {\n-                DualPivotQuicksort.sort(null, (float[]) a, BIG_DEPTH, low, high);\n-            } else if (a instanceof double[]) {\n-                DualPivotQuicksort.sort(null, (double[]) a, BIG_DEPTH, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, 0, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, 0, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as, low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, 0, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, 0, low, high);\n+                default -> fail(a);\n@@ -191,0 +131,1 @@\n+    },\n@@ -192,4 +133,2 @@\n-        @Override\n-        public void sort(Object[] a) {\n-            fail(a);\n-        }\n+    PARALLEL_QUICKSORT(\"Parallel Quicksort\") {\n+        final int parallel = 4;\n@@ -198,2 +137,11 @@\n-        public void sort(Object[] a, Comparator comparator) {\n-            fail(a);\n+        public void sort(Object a, int low, int high) {\n+            switch(a) {\n+                case int[] ai -> DualPivotQuicksort.sort(ai, parallel, low, high);\n+                case long[] al -> DualPivotQuicksort.sort(al, parallel, low, high);\n+                case byte[] ab -> DualPivotQuicksort.sort(ab, low, high);\n+                case char[] ac -> DualPivotQuicksort.sort(ac, low, high);\n+                case short[] as -> DualPivotQuicksort.sort(as,low, high);\n+                case float[] af -> DualPivotQuicksort.sort(af, parallel, low, high);\n+                case double[] ad -> DualPivotQuicksort.sort(ad, parallel, low, high);\n+                default -> fail(a);\n+            }\n@@ -204,1 +152,0 @@\n-\n@@ -207,16 +154,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.sort(ai);\n+                case long[] al -> Arrays.sort(al);\n+                case byte[] ab -> Arrays.sort(ab);\n+                case char[] ac -> Arrays.sort(ac);\n+                case short[] as -> Arrays.sort(as);\n+                case float[] af -> Arrays.sort(af);\n+                case double[] ad -> Arrays.sort(ad);\n+                default -> fail(a);\n@@ -228,16 +168,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.sort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.sort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.sort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.sort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.sort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.sort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.sort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.sort(ai, low, high);\n+                case long[] al -> Arrays.sort(al, low, high);\n+                case byte[] ab -> Arrays.sort(ab, low, high);\n+                case char[] ac -> Arrays.sort(ac, low, high);\n+                case short[] as -> Arrays.sort(as, low, high);\n+                case float[] af -> Arrays.sort(af, low, high);\n+                case double[] ad -> Arrays.sort(ad, low, high);\n+                default -> fail(a);\n@@ -246,11 +179,0 @@\n-\n-        @Override\n-        public void sort(Object[] a) {\n-            Arrays.sort(a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.sort(a, comparator);\n-        }\n@@ -260,1 +182,0 @@\n-\n@@ -263,16 +184,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.parallelSort(ai);\n+                case long[] al -> Arrays.parallelSort(al);\n+                case byte[] ab -> Arrays.parallelSort(ab);\n+                case char[] ac -> Arrays.parallelSort(ac);\n+                case short[] as -> Arrays.parallelSort(as);\n+                case float[] af -> Arrays.parallelSort(af);\n+                case double[] ad -> Arrays.parallelSort(ad);\n+                default -> fail(a);\n@@ -284,16 +198,9 @@\n-            if (a instanceof int[]) {\n-                Arrays.parallelSort((int[]) a, low, high);\n-            } else if (a instanceof long[]) {\n-                Arrays.parallelSort((long[]) a, low, high);\n-            } else if (a instanceof byte[]) {\n-                Arrays.parallelSort((byte[]) a, low, high);\n-            } else if (a instanceof char[]) {\n-                Arrays.parallelSort((char[]) a, low, high);\n-            } else if (a instanceof short[]) {\n-                Arrays.parallelSort((short[]) a, low, high);\n-            } else if (a instanceof float[]) {\n-                Arrays.parallelSort((float[]) a, low, high);\n-            } else if (a instanceof double[]) {\n-                Arrays.parallelSort((double[]) a, low, high);\n-            } else {\n-                fail(a);\n+            switch(a) {\n+                case int[] ai -> Arrays.parallelSort(ai, low, high);\n+                case long[] al -> Arrays.parallelSort(al, low, high);\n+                case byte[] ab -> Arrays.parallelSort(ab, low, high);\n+                case char[] ac -> Arrays.parallelSort(ac, low, high);\n+                case short[] as -> Arrays.parallelSort(as, low, high);\n+                case float[] af -> Arrays.parallelSort(af, low, high);\n+                case double[] ad -> Arrays.parallelSort(ad, low, high);\n+                default -> fail(a);\n@@ -302,12 +209,0 @@\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a) {\n-            Arrays.parallelSort((Comparable[]) a);\n-        }\n-\n-        @Override\n-        @SuppressWarnings(\"unchecked\")\n-        public void sort(Object[] a, Comparator comparator) {\n-            Arrays.parallelSort(a, comparator);\n-        }\n@@ -316,5 +211,3 @@\n-    abstract public void sort(Object a);\n-\n-    abstract public void sort(Object a, int low, int high);\n-\n-    abstract public void sort(Object[] a);\n+    SortingHelper(String name) {\n+        this.name = name;\n+    }\n@@ -322,1 +215,1 @@\n-    abstract public void sort(Object[] a, Comparator comparator);\n+    public abstract void sort(Object a, int low, int high);\n@@ -324,2 +217,11 @@\n-    private SortingHelper(String name) {\n-        this.name = name;\n+    public void sort(Object a) {\n+        switch(a) {\n+            case int[] ai -> sort(ai, 0, ai.length);\n+            case long[] al -> sort(al, 0, al.length);\n+            case byte[] ab -> sort(ab, 0, ab.length);\n+            case char[] ac -> sort(ac, 0, ac.length);\n+            case short[] as -> sort(as, 0, as.length);\n+            case float[] af -> sort(af, 0, af.length);\n+            case double[] ad -> sort(ad, 0, ad.length);\n+            default -> fail(a);\n+        }\n@@ -333,2 +235,4 @@\n-    private static void fail(Object a) {\n-        throw new RuntimeException(\"Unexpected type of array: \" + a.getClass().getName());\n+    private static void check(String name, boolean result) {\n+        if (!result) {\n+            fail(name + \" sort must return true\");\n+        }\n@@ -337,1 +241,3 @@\n-    private String name;\n+    private static void fail(Object a) {\n+        fail(\"Unknown array: \" + a.getClass().getName());\n+    }\n@@ -339,5 +245,3 @@\n-    \/**\n-     * Parallelism level for sequential and parallel sorting.\n-     *\/\n-    private static final int SEQUENTIAL = 0;\n-    private static final int PARALLEL = 87;\n+    private static void fail(String message) {\n+        throw new RuntimeException(message);\n+    }\n@@ -345,5 +249,1 @@\n-    \/**\n-     * Heap sort will be invoked, if recursion depth is too big.\n-     * Value is taken from DualPivotQuicksort.MAX_RECURSION_DEPTH.\n-     *\/\n-    private static final int BIG_DEPTH = 64 * (3 << 1);\n+    private final String name;\n","filename":"test\/jdk\/java\/util\/Arrays\/java.base\/java\/util\/SortingHelper.java","additions":145,"deletions":245,"binary":false,"changes":390,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -23,1 +23,6 @@\n-package org.openjdk.bench.java.lang;\n+\n+package org.openjdk.bench.java.util;\n+\n+import java.util.Arrays;\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n@@ -28,0 +33,1 @@\n+import org.openjdk.jmh.annotations.Level;\n@@ -30,1 +36,0 @@\n-import org.openjdk.jmh.annotations.OperationsPerInvocation;\n@@ -36,1 +41,0 @@\n-import org.openjdk.jmh.annotations.Level;\n@@ -38,8 +42,0 @@\n-import org.openjdk.jmh.infra.Blackhole;\n-import java.util.Arrays;\n-import java.util.Random;\n-import java.util.concurrent.TimeUnit;\n-import java.io.UnsupportedEncodingException;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.reflect.Method;\n@@ -48,1 +44,7 @@\n- * Performance test of Arrays.sort() methods\n+ * Microbenchmarking of Arrays.sort() and Arrays.parallelSort().\n+ *\n+ * @author Vladimir Yaroslavskiy\n+ *\n+ * @version 2024.06.14\n+ *\n+ * @since 26\n@@ -50,1 +52,1 @@\n-@Fork(value=1, jvmArgs={\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n+@State(Scope.Benchmark)\n@@ -53,3 +55,3 @@\n-@State(Scope.Thread)\n-@Warmup(iterations = 3, time=5)\n-@Measurement(iterations = 3, time=3)\n+@Warmup(iterations = 2, time = 4, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 4, time = 5, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 1, jvmArgsAppend = {\"-XX:CompileThreshold=1\", \"-XX:-TieredCompilation\"})\n@@ -58,43 +60,9 @@\n-    @Param({\"10\",\"25\",\"50\",\"75\",\"100\", \"1000\", \"10000\", \"100000\", \"1000000\"})\n-    private int size;\n-\n-    private int[] ints_unsorted;\n-    private long[] longs_unsorted;\n-    private float[] floats_unsorted;\n-    private double[] doubles_unsorted;\n-\n-    private int[] ints_sorted;\n-    private long[] longs_sorted;\n-    private float[] floats_sorted;\n-    private double[] doubles_sorted;\n-\n-\n-    public void initialize() {\n-        Random rnd = new Random(42);\n-\n-        ints_unsorted = new int[size];\n-        longs_unsorted = new long[size];\n-        floats_unsorted = new float[size];\n-        doubles_unsorted = new double[size];\n-\n-        int[] intSpecialCases = {Integer.MIN_VALUE, Integer.MAX_VALUE};\n-        long[] longSpecialCases = {Long.MIN_VALUE, Long.MAX_VALUE};\n-        float[] floatSpecialCases = {+0.0f, -0.0f, Float.POSITIVE_INFINITY, Float.NEGATIVE_INFINITY, Float.NaN};\n-        double[] doubleSpecialCases = {+0.0, -0.0, Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN};\n-\n-        for (int i = 0; i < size; i++) {\n-            ints_unsorted[i] = rnd.nextInt();\n-            longs_unsorted[i] = rnd.nextLong();\n-            if (i % 10 != 0) {\n-                ints_unsorted[i] = rnd.nextInt();\n-                longs_unsorted[i] = rnd.nextLong();\n-                floats_unsorted[i] = rnd.nextFloat();\n-                doubles_unsorted[i] = rnd.nextDouble();\n-            } else {\n-                ints_unsorted[i] = intSpecialCases[rnd.nextInt(intSpecialCases.length)];\n-                longs_unsorted[i] = longSpecialCases[rnd.nextInt(longSpecialCases.length)];\n-                floats_unsorted[i] = floatSpecialCases[rnd.nextInt(floatSpecialCases.length)];\n-                doubles_unsorted[i] = doubleSpecialCases[rnd.nextInt(doubleSpecialCases.length)];\n-            }\n-        }\n-    }\n+    private static final int PARALLELISM = java.util.concurrent.ForkJoinPool.getCommonPoolParallelism();\n+\n+    @Param({ \"600\", \"3000\", \"40000\", \"800000\", \"5000000\" })\n+    int size;\n+\n+    @Param\n+    Builder builder;\n+\n+    int[] b;\n@@ -103,2 +71,2 @@\n-    public void setup() throws UnsupportedEncodingException, ClassNotFoundException, NoSuchMethodException, Throwable {\n-        initialize();\n+    public void init() {\n+        b = new int[size];\n@@ -107,7 +75,1 @@\n-    @Setup(Level.Invocation)\n-    public void clear() {\n-        ints_sorted = ints_unsorted.clone();\n-        longs_sorted = longs_unsorted.clone();\n-        floats_sorted = floats_unsorted.clone();\n-        doubles_sorted = doubles_unsorted.clone();\n-    }\n+    public enum Builder {\n@@ -115,5 +77,10 @@\n-    @Benchmark\n-    public int[] intSort() throws Throwable {\n-        Arrays.sort(ints_sorted);\n-        return ints_sorted;\n-    }\n+        REPEATED {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x111);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt(5);\n+                }\n+            }\n+        },\n@@ -121,4 +88,32 @@\n-    @Benchmark\n-    public int[] intParallelSort() throws Throwable {\n-        Arrays.parallelSort(ints_sorted);\n-        return ints_sorted;\n+        STAGGER {\n+            @Override\n+            void build(int[] b) {\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = (i * 8) % b.length;\n+                }\n+            }\n+        },\n+\n+        SHUFFLE {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x999);\n+\n+                for (int i = 0, j = 0, k = 1; i < b.length; ++i) {\n+                    b[i] = random.nextInt(11) > 0 ? (j += 2) : (k += 2);\n+                }\n+            }\n+        },\n+\n+        RANDOM {\n+            @Override\n+            void build(int[] b) {\n+                Random random = new Random(0x777);\n+\n+                for (int i = 0; i < b.length; ++i) {\n+                    b[i] = random.nextInt();\n+                }\n+            }\n+        };\n+\n+        abstract void build(int[] b);\n@@ -127,4 +122,16 @@\n-    @Benchmark\n-    public long[] longSort() throws Throwable {\n-        Arrays.sort(longs_sorted);\n-        return longs_sorted;\n+    public static class Int extends ArraysSort {\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(b);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(b);\n+        }\n@@ -133,4 +140,26 @@\n-    @Benchmark\n-    public long[] longParallelSort() throws Throwable {\n-        Arrays.parallelSort(longs_sorted);\n-        return longs_sorted;\n+    public static class Long extends ArraysSort {\n+        long[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new long[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -139,4 +168,21 @@\n-    @Benchmark\n-    public float[] floatSort() throws Throwable {\n-        Arrays.sort(floats_sorted);\n-        return floats_sorted;\n+    public static class Short extends ArraysSort {\n+        short[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new short[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (short) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -145,4 +191,21 @@\n-    @Benchmark\n-    public float[] floatParallelSort() throws Throwable {\n-        Arrays.parallelSort(floats_sorted);\n-        return floats_sorted;\n+    public static class Byte extends ArraysSort {\n+        byte[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new byte[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (byte) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -151,4 +214,21 @@\n-    @Benchmark\n-    public double[] doubleSort() throws Throwable {\n-        Arrays.sort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Char extends ArraysSort {\n+        char[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new char[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = (char) b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n@@ -157,4 +237,26 @@\n-    @Benchmark\n-    public double[] doubleParallelSort() throws Throwable {\n-        Arrays.parallelSort(doubles_sorted);\n-        return doubles_sorted;\n+    public static class Float extends ArraysSort {\n+        float[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new float[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n@@ -163,0 +265,27 @@\n+    public static class Double extends ArraysSort {\n+        double[] a;\n+\n+        @Setup\n+        public void setup() {\n+            a = new double[size];\n+        }\n+\n+        @Setup(Level.Invocation)\n+        public void build() {\n+            builder.build(b);\n+\n+            for (int i = 0; i < size; ++i) {\n+                a[i] = b[i];\n+            }\n+        }\n+\n+        @Benchmark\n+        public void testSort() {\n+            Arrays.sort(a);\n+        }\n+\n+        @Benchmark\n+        public void testParallelSort() {\n+            Arrays.parallelSort(a);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/ArraysSort.java","additions":231,"deletions":102,"binary":false,"changes":333,"status":"modified"}]}