{"files":[{"patch":"@@ -160,0 +160,2 @@\n+  \/\/ StubRoutines::_unsafe_setmemory = nullptr;\n+\n@@ -2500,10 +2502,0 @@\n-  Label L_int_aligned, L_short_aligned, L_begin;\n-\n-  \/\/ Input registers\n-  const Register dest        = c_rarg0;  \/\/ destination array address\n-  const Register size        = c_rarg1;  \/\/ byte count (size_t)\n-  const Register value       = c_rarg2;  \/\/ byte value to fill\n-\n-  \/\/ Register used as a temp\n-  const Register bits        = rax;      \/\/ test copy of low bits\n-\n@@ -2517,4 +2509,3 @@\n-  \/\/ *_fill_entry requires broadcasted bytes\n-  __ movzbl(bits, value);\n-  __ mov64(value, 0x0101010101010101);\n-  __ imulq(value, bits);\n+#if 0\n+  {\n+    Label L_int_aligned, L_short_aligned, L_begin;\n@@ -2522,2 +2513,4 @@\n-  __ mov(bits, dest);\n-  __ orptr(bits, size);\n+    \/\/ Input registers\n+    const Register dest        = c_rarg0;  \/\/ destination array address\n+    const Register size        = c_rarg1;  \/\/ byte count (size_t)\n+    const Register value       = c_rarg2;  \/\/ byte value to fill\n@@ -2525,2 +2518,6 @@\n-  \/\/ Generated fill routines expect a different argument order\n-  __ xchgq(size, value);\n+    \/\/ Register used as a temp\n+    const Register bits        = rax;      \/\/ test copy of low bits\n+    \/\/ *_fill_entry requires broadcasted bytes\n+    __ movzbl(bits, value);\n+    __ mov64(value, 0x0101010101010101);\n+    __ imulq(value, bits);\n@@ -2528,2 +2525,2 @@\n-  __ testb(bits, BytesPerInt-1);\n-  __ jccb(Assembler::zero, L_int_aligned);\n+    __ mov(bits, dest);\n+    __ orptr(bits, size);\n@@ -2531,2 +2528,2 @@\n-  __ testb(bits, BytesPerShort-1);\n-  __ jump_cc(Assembler::notZero, RuntimeAddress(byte_fill_entry));\n+    \/\/ Generated fill routines expect a different argument order\n+    __ xchgq(size, value);\n@@ -2534,3 +2531,2 @@\n-  __ BIND(L_short_aligned);\n-  __ shrptr(value, LogBytesPerShort); \/\/ size => short_count\n-  __ jump(RuntimeAddress(short_fill_entry));\n+    __ testb(bits, BytesPerInt-1);\n+    __ jccb(Assembler::zero, L_int_aligned);\n@@ -2538,3 +2534,760 @@\n-  __ BIND(L_int_aligned);\n-  __ shrptr(value, LogBytesPerInt); \/\/ size => int_count\n-  __ jump(RuntimeAddress(int_fill_entry));\n+    __ testb(bits, BytesPerShort-1);\n+    __ jump_cc(Assembler::notZero, RuntimeAddress(byte_fill_entry));\n+\n+    __ BIND(L_short_aligned);\n+    __ shrptr(value, LogBytesPerShort); \/\/ size => short_count\n+    __ jump(RuntimeAddress(short_fill_entry));\n+\n+    __ BIND(L_int_aligned);\n+    __ shrptr(value, LogBytesPerInt); \/\/ size => int_count\n+    __ jump(RuntimeAddress(int_fill_entry));\n+  }\n+#else\n+#if 0\n+  {\n+    address jump_table_word[7];\n+    address jump_table_dword[7];\n+\n+    address jmp_table_word = nullptr;\n+    address jmp_table_dword = nullptr;\n+\n+    Label L_begin, L_BB0_30, L_BB0_1, L_BB0_9, L_BB0_22;\n+    Label L_BB0_20, L_BB0_19, L_BB0_5, L_BB0_4, L_BB0_7;\n+    Label L_BB0_13, L_BB0_12, L_byteByByte, L_Done, L_Loop;\n+\n+    setup_arg_regs(3);\n+#define dest rdi\n+#define size rsi\n+#define wide_value rcx\n+#define index rdx\n+#define savedSize rax\n+\n+    __ jmp(L_begin);\n+\n+    \/\/ .LBB0_23:\n+    \/\/         mov     word ptr [rdi + 4*rdx + 48], cx\n+    \/\/ .LBB0_24:\n+    \/\/         mov     word ptr [rdi + 4*rdx + 40], cx\n+    \/\/ .LBB0_25:\n+    \/\/         mov     word ptr [rdi + 4*rdx + 32], cx\n+    \/\/ .LBB0_26:\n+    \/\/         mov     word ptr [rdi + 4*rdx + 24], cx\n+    \/\/ .LBB0_27:\n+    \/\/         mov     word ptr [rdi + 4*rdx + 16], cx\n+    \/\/ .LBB0_28:\n+    \/\/         mov     word ptr [rdi + 4*rdx + 8], cx\n+    \/\/ .LBB0_29:\n+    \/\/         mov     word ptr [rdi + 4*rdx], cx\n+    \/\/         ret\n+    for (int i = 6; i >= 0; i--) {\n+      jump_table_word[i] = __ pc();\n+      __ movw(Address(dest, index, Address::times_4, i * 8), wide_value);\n+    }\n+    restore_arg_regs();\n+    __ ret(0);\n+\n+    \/\/ .LBB0_31:\n+    \/\/         mov     dword ptr [rdi + 4*rdx + 96], ecx\n+    \/\/ .LBB0_32:\n+    \/\/         mov     dword ptr [rdi + 4*rdx + 80], ecx\n+    \/\/ .LBB0_33:\n+    \/\/         mov     dword ptr [rdi + 4*rdx + 64], ecx\n+    \/\/ .LBB0_34:\n+    \/\/         mov     dword ptr [rdi + 4*rdx + 48], ecx\n+    \/\/ .LBB0_35:\n+    \/\/         mov     dword ptr [rdi + 4*rdx + 32], ecx\n+    \/\/ .LBB0_36:\n+    \/\/         mov     dword ptr [rdi + 4*rdx + 16], ecx\n+    \/\/ .LBB0_37:\n+    \/\/         mov     dword ptr [rdi + 4*rdx], ecx\n+    \/\/         ret\n+    for (int i = 6; i >= 0; i--) {\n+      jump_table_dword[i] = __ pc();\n+      __ movl(Address(dest, index, Address::times_4, i * 16), wide_value);\n+    }\n+    restore_arg_regs();\n+    __ ret(0);\n+\n+    \/\/ Emit jump tables\n+    __ align(8);\n+\n+    jmp_table_word = __ pc();\n+\n+    for (int i = 0; i < 7; i++) {\n+      __ emit_address(jump_table_word[i]);\n+    }\n+\n+    jmp_table_dword = __ pc();\n+\n+    for (int i = 0; i < 7; i++) {\n+      __ emit_address(jump_table_dword[i]);\n+    }\n+\n+    __ align(CodeEntryAlignment);\n+\n+    \/\/ fill_to_memory_atomic(void*, unsigned long, unsigned char):          #\n+    __ BIND(L_begin);\n+\n+    \/\/         test    rax, rax\n+    \/\/         je      .LBB0_30\n+    __ testq(size, size);\n+    __ jcc(Assembler::equal, L_BB0_30);\n+#undef index\n+#define value rdx\n+#define rScratch3 r8\n+    \/\/         mov     rax, rsi\n+    \/\/         mov     r8, rdi\n+    \/\/         or      r8, rsi\n+    \/\/         movzx   esi, dl\n+    \/\/         movabs  rcx, 72340172838076673\n+    \/\/         imul    rcx, rsi\n+    __ movq(savedSize, size);\n+    __ movq(rScratch3, dest);\n+    __ orq(rScratch3, size);\n+#undef size\n+#define rScratch2 rsi\n+    __ movzbl(rScratch2, value);\n+    __ mov64(wide_value, 0x0101010101010101);\n+    __ imulq(wide_value, rScratch2);\n+\n+#undef value\n+\n+    \/\/         test    r8b, 7\n+    \/\/         je      .LBB0_1\n+    __ testb(rScratch3, 7);\n+    __ jcc(Assembler::zero, L_BB0_1);\n+\n+    \/\/         test    r8b, 3\n+    \/\/         je      .LBB0_9\n+    __ testb(rScratch3, 3);\n+    __ jcc(Assembler::zero, L_BB0_9);\n+\n+    \/\/         test    r8b, 1\n+    \/\/         jne     .LBB0_22\n+    __ testb(rScratch3, 1);\n+    __ jcc(Assembler::notZero, L_BB0_22);\n+\n+    \/\/         lea     rdx, [rax + 1]\n+    \/\/         cmp     rdx, 16\n+    \/\/         jb      .LBB0_20\n+    \/\/         mov     rsi, rdx\n+    \/\/         shr     rsi, 4\n+    \/\/         lea     r8, [rdi + 56]\n+#define index rdx\n+\n+    __ leaq(index, Address(savedSize, 1));\n+    __ cmpq(index, 16);\n+    __ jccb(Assembler::below, L_BB0_20);\n+    __ movq(rScratch2, index);\n+    __ shrq(rScratch2, 4);\n+    __ leaq(rScratch3, Address(dest, 56));\n+\n+    __ BIND(L_BB0_19);\n+\n+    \/\/ .LBB0_19:                               # =>This Inner Loop Header:\n+    \/\/ Depth=1\n+    \/\/         mov     word ptr [r8 - 56], cx\n+    \/\/         mov     word ptr [r8 - 48], cx\n+    \/\/         mov     word ptr [r8 - 40], cx\n+    \/\/         mov     word ptr [r8 - 32], cx\n+    \/\/         mov     word ptr [r8 - 24], cx\n+    \/\/         mov     word ptr [r8 - 16], cx\n+    \/\/         mov     word ptr [r8 - 8], cx\n+    \/\/         mov     word ptr [r8], cx\n+    \/\/         add     r8, 64\n+    \/\/         dec     rsi\n+    \/\/         jne     .LBB0_19\n+    for (int i = 7; i >= 0; i--) {\n+      __ movw(Address(rScratch3, -(i * 8)), wide_value);\n+    }\n+    __ addq(rScratch3, 64);\n+    __ decrementq(rScratch2);\n+    __ jccb(Assembler::notEqual, L_BB0_19);\n+\n+    __ BIND(L_BB0_20);\n+    \/\/ .LBB0_20:\n+    \/\/         and     rdx, -16\n+    \/\/         mov     rsi, rdx\n+    \/\/         not     rsi\n+    \/\/         add     rsi, rax\n+    \/\/         shr     rsi\n+    \/\/         cmp     rsi, 6\n+    \/\/         ja      .LBB0_30\n+    \/\/         jmp     qword ptr [8*rsi + .LJTI0_0]\n+    __ andq(index, -16);\n+    __ movq(rScratch2, index);\n+    __ notq(rScratch2);\n+    __ addq(rScratch2, savedSize);\n+    __ shrq(rScratch2, 1);\n+    __ cmpq(rScratch2, 6);\n+    __ jcc(Assembler::above, L_BB0_30);\n+\n+    __ mov64(savedSize, (int64_t)jmp_table_word);\n+    __ jmp(Address(savedSize, rScratch2, Address::times_8));\n+\n+#define rScratch4 r11\n+    __ BIND(L_BB0_1);\n+    \/\/ .LBB0_1:\n+    \/\/         test    rax, rax\n+    \/\/         je      .LBB0_30\n+    \/\/         lea     rsi, [rax + 7]\n+    \/\/         mov     rdx, rsi\n+    \/\/         shr     rdx, 6\n+    \/\/         cmp     rsi, 64\n+    \/\/         jb      .LBB0_5\n+    \/\/         lea     r8, [rdi + 224]\n+    \/\/         mov     r9, rdx\n+    __ leaq(rScratch2, Address(savedSize, 7));\n+    __ movq(index, rScratch2);\n+    __ shrq(index, 6);\n+    __ cmpq(rScratch2, 64);\n+    __ jccb(Assembler::below, L_BB0_5);\n+    __ leaq(rScratch3, Address(dest, 224));\n+    __ movq(rScratch4, index);\n+\n+    __ BIND(L_BB0_4);\n+    \/\/ .LBB0_4:                                # =>This Inner Loop Header:\n+    \/\/ Depth=1\n+    \/\/         mov     qword ptr [r8 - 224], rcx\n+    \/\/         mov     qword ptr [r8 - 192], rcx\n+    \/\/         mov     qword ptr [r8 - 160], rcx\n+    \/\/         mov     qword ptr [r8 - 128], rcx\n+    \/\/         mov     qword ptr [r8 - 96], rcx\n+    \/\/         mov     qword ptr [r8 - 64], rcx\n+    \/\/         mov     qword ptr [r8 - 32], rcx\n+    \/\/         mov     qword ptr [r8], rcx\n+    \/\/         add     r8, 256\n+    \/\/         dec     r9\n+    \/\/         jne     .LBB0_4\n+    for (int i = 7; i >= 0; i--) {\n+      __ movq(Address(rScratch3, -(i * 32)), wide_value);\n+    }\n+    __ addq(rScratch3, 256);\n+    __ decrementq(rScratch4);\n+    __ jccb(Assembler::notZero, L_BB0_4);\n+\n+#undef rScratch4\n+    __ BIND(L_BB0_5);\n+    \/\/ .LBB0_5:\n+    \/\/         lea     r8, [8*rdx]\n+    \/\/         shr     rsi, 3\n+    \/\/         cmp     r8, rsi\n+    \/\/         jae     .LBB0_30\n+    \/\/         dec     rax\n+    \/\/         shr     rax, 3\n+    \/\/         shl     rdx, 8\n+    \/\/         add     rdi, rdx\n+    \/\/         sub     rax, r8\n+    \/\/         inc     rax\n+    __ leaq(rScratch3, Address(index, 0, Address::times_8));\n+    __ shrq(rScratch2, 3);\n+    __ cmpq(rScratch3, rScratch2);\n+    __ jccb(Assembler::aboveEqual, L_BB0_30);\n+    __ decrementq(savedSize);\n+    __ shrq(savedSize, 3);\n+    __ shlq(index, 8);\n+    __ addq(dest, index);\n+    __ subq(savedSize, rScratch3);\n+    __ incrementq(savedSize);\n+\n+    __ BIND(L_BB0_7);\n+    \/\/ .LBB0_7:                                # =>This Inner Loop Header:\n+    \/\/ Depth=1\n+    \/\/         mov     qword ptr [rdi], rcx\n+    \/\/         add     rdi, 32\n+    \/\/         dec     rax\n+    \/\/         jne     .LBB0_7\n+    __ movq(Address(dest, 0), wide_value);\n+    __ addq(dest, 32);\n+    __ decrementq(savedSize);\n+    __ jccb(Assembler::notEqual, L_BB0_7);\n+\n+    __ BIND(L_BB0_30);\n+    \/\/ .LBB0_30:\n+    \/\/         ret\n+    restore_arg_regs();\n+    __ ret(0);\n+\n+    __ BIND(L_BB0_9);\n+    \/\/ .LBB0_9:\n+    \/\/         test    rax, rax\n+    \/\/         je      .LBB0_30\n+    \/\/         lea     rdx, [rax + 3]\n+    \/\/         cmp     rdx, 32\n+    \/\/         jb      .LBB0_13\n+    \/\/         mov     rsi, rdx\n+    \/\/         shr     rsi, 5\n+    \/\/         lea     r8, [rdi + 112]\n+    __ leaq(index, Address(savedSize, 3));\n+    __ cmpq(index, 32);\n+    __ jccb(Assembler::below, L_BB0_13);\n+    __ movq(rScratch2, index);\n+    __ shrq(rScratch2, 5);\n+    __ leaq(rScratch3, Address(dest, 112));\n+\n+    __ BIND(L_BB0_12);\n+    \/\/ .LBB0_12:                               # =>This Inner Loop Header:\n+    \/\/ Depth=1\n+    \/\/         mov     dword ptr [r8 - 112], ecx\n+    \/\/         mov     dword ptr [r8 - 96], ecx\n+    \/\/         mov     dword ptr [r8 - 80], ecx\n+    \/\/         mov     dword ptr [r8 - 64], ecx\n+    \/\/         mov     dword ptr [r8 - 48], ecx\n+    \/\/         mov     dword ptr [r8 - 32], ecx\n+    \/\/         mov     dword ptr [r8 - 16], ecx\n+    \/\/         mov     dword ptr [r8], ecx\n+    \/\/         sub     r8, -128\n+    \/\/         dec     rsi\n+    \/\/         jne     .LBB0_12\n+    for (int i = 7; i >= 0; i--) {\n+      __ movl(Address(rScratch3, -(i * 16)), wide_value);\n+    }\n+    __ subq(rScratch3, -128);\n+    __ decrementq(rScratch2);\n+    __ jccb(Assembler::notEqual, L_BB0_12);\n+\n+    __ BIND(L_BB0_13);\n+    \/\/ .LBB0_13:\n+    \/\/         and     rdx, -32\n+    \/\/         mov     rsi, rdx\n+    \/\/         not     rsi\n+    \/\/         add     rsi, rax\n+    \/\/         shr     rsi, 2\n+    \/\/         cmp     rsi, 6\n+    \/\/         ja      .LBB0_30\n+    \/\/         jmp     qword ptr [8*rsi + .LJTI0_1]\n+    __ andq(index, -32);\n+    __ movq(rScratch2, index);\n+    __ notq(rScratch2);\n+    __ addq(rScratch2, savedSize);\n+    __ shrq(rScratch2, 2);\n+    __ cmpq(rScratch2, 6);\n+    __ jccb(Assembler::above, L_BB0_30);\n+\n+    __ mov64(savedSize, (int64_t)jmp_table_dword);\n+    __ jmp(Address(savedSize, rScratch2, Address::times_8));\n+\n+#undef index\n+#undef rScratch3\n+#undef rScratch2\n+\n+    __ BIND(L_BB0_22);\n+    __ cmpq(savedSize, 8);\n+    __ jccb(Assembler::below, L_byteByByte);\n+\n+    for (int i = 0; i < 8; i++) {\n+      __ movb(Address(dest, i), wide_value);\n+    }\n+    __ addptr(dest, 8);\n+    __ subptr(savedSize, 8);\n+    __ jmpb(L_BB0_22);\n+\n+    __ BIND(L_byteByByte);\n+    __ cmpq(savedSize, 0);\n+    __ jccb(Assembler::zero, L_Done);\n+\n+    __ BIND(L_Loop);\n+    __ movb(Address(dest, 0), wide_value);\n+    __ incrementq(dest);\n+    __ decrementq(savedSize);\n+    __ jccb(Assembler::notZero, L_Loop);\n+\n+    __ BIND(L_Done);\n+    restore_arg_regs();\n+    __ ret(0);\n+    \/\/ .LBB0_22:\n+    \/\/         mov     rdx, rax\n+    \/\/         jmp     _intel_fast_memset@PLT          # TAILCALL\n+    \/\/ .LJTI0_0:\n+    \/\/         .quad   .LBB0_29\n+    \/\/         .quad   .LBB0_28\n+    \/\/         .quad   .LBB0_27\n+    \/\/         .quad   .LBB0_26\n+    \/\/         .quad   .LBB0_25\n+    \/\/         .quad   .LBB0_24\n+    \/\/         .quad   .LBB0_23\n+    \/\/ .LJTI0_1:\n+    \/\/         .quad   .LBB0_37\n+    \/\/         .quad   .LBB0_36\n+    \/\/         .quad   .LBB0_35\n+    \/\/         .quad   .LBB0_34\n+    \/\/         .quad   .LBB0_33\n+    \/\/         .quad   .LBB0_32\n+    \/\/         .quad   .LBB0_31\n+#undef savedSize\n+#undef dest\n+#undef wide_value\n+  }\n+#else\n+  {\n+    Label L_exit, L_fillQuadwords, L_fillDwords, L_fillBytes;\n+\n+    setup_arg_regs(3);\n+#undef dest\n+#define dest rdi\n+#undef size\n+#define size rsi\n+#undef wide_value\n+#define wide_value rax\n+#undef rScratch1\n+#define rScratch1 rcx\n+#undef byteVal\n+#define byteVal rdx\n+#undef rScratch3\n+#define rScratch3 r8\n+#undef rScratch4\n+#define rScratch4 r11\n+\/\/     fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char):          #\n+\/\/         test    rsi, rsi\n+\/\/         je      .LBB0_17\n+    __ testq(size, size);\n+    __ jcc(Assembler::zero, L_exit);\n+\/\/         mov     rcx, rdi\n+\/\/         or      rcx, rsi\n+\/\/         movzx   r8d, dl\n+\/\/         movabs  rax, 72340172838076673\n+\/\/         imul    rax, r8\n+    __ movq(rScratch1, dest);\n+    __ orq(rScratch1, size);\n+    __ movzbl(rScratch3, byteVal);\n+    __ mov64(wide_value, 0x0101010101010101);\n+    __ imulq(wide_value, rScratch3);\n+\n+#undef byteVal\n+#define rScratch2 rdx\n+\/\/         test    cl, 7\n+\/\/         je      .LBB0_24\n+    __ testb(rScratch1, 7);\n+    __ jcc(Assembler::equal, L_fillQuadwords);\n+\n+\/\/         test    cl, 3\n+\/\/         je      .LBB0_3\n+    __ testb(rScratch1, 3);\n+    __ jcc(Assembler::equal, L_fillDwords);\n+\n+\/\/         test    cl, 1\n+\/\/         jne     .LBB0_10\n+    __ testb(rScratch1, 1);\n+    __ jcc(Assembler::notEqual, L_fillBytes);\n+\n+\/\/         lea     rdx, [rsi + 1]\n+\/\/         mov     rcx, rdx\n+\/\/         shr     rcx, 4\n+\/\/         cmp     rdx, 16\n+\/\/         jb      .LBB0_21\n+\/\/         lea     r8, [rdi + 14]\n+\/\/         mov     r9, rcx\n+\n+    {\n+      Label L_wordsTail, L_wordsLoop, L_wordsTailLoop;\n+      \/\/\/\/\/\/  Set words\n+      __ leaq(rScratch2, Address(size, 1));\n+      __ movq(rScratch1, rScratch2);\n+      __ shrq(rScratch1, 4);\n+      __ cmpq(rScratch2, 16);\n+      __ jccb(Assembler::below, L_wordsTail);\n+      __ leaq(rScratch3, Address(dest, 14));\n+      __ movq(rScratch4, rScratch1);\n+\n+      __ BIND(L_wordsLoop);\n+\n+      \/\/ .LBB0_20:                               # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     word ptr [r8 - 14], ax\n+      \/\/         mov     word ptr [r8 - 12], ax\n+      \/\/         mov     word ptr [r8 - 10], ax\n+      \/\/         mov     word ptr [r8 - 8], ax\n+      \/\/         mov     word ptr [r8 - 6], ax\n+      \/\/         mov     word ptr [r8 - 4], ax\n+      \/\/         mov     word ptr [r8 - 2], ax\n+      \/\/         mov     word ptr [r8], ax\n+      \/\/         add     r8, 16\n+      \/\/         dec     r9\n+      \/\/         jne     .LBB0_20\n+      for (int i = 7; i >= 0; i--) {\n+        __ movw(Address(rScratch3, -(2 * i)), wide_value);\n+      }\n+      __ addq(rScratch3, 16);\n+      __ decrementq(rScratch4);\n+      __ jccb(Assembler::notEqual, L_wordsLoop);\n+\n+      __ BIND(L_wordsTail);\n+\n+      \/\/ .LBB0_21:\n+      \/\/         shl     rcx, 3\n+      \/\/         shr     rdx\n+      \/\/         cmp     rcx, rdx\n+      \/\/         jae     .LBB0_17\n+      \/\/         dec     rsi\n+      \/\/         shr     rsi\n+      \/\/         inc     rsi\n+      __ shlq(rScratch1, 3);\n+      __ shrq(rScratch2, 1);\n+      __ cmpq(rScratch1, rScratch2);\n+      __ jcc(Assembler::aboveEqual, L_exit);\n+      __ decrementq(size);\n+      __ shrq(size, 1);\n+      __ incrementq(size);\n+\n+      __ BIND(L_wordsTailLoop);\n+\n+      \/\/ .LBB0_23:                               # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     word ptr [rdi + 2*rcx], ax\n+      \/\/         inc     rcx\n+      \/\/         cmp     rsi, rcx\n+      \/\/         jne     .LBB0_23\n+      \/\/         jmp     .LBB0_17\n+      __ movw(Address(dest, rScratch1, Address::times_2), wide_value);\n+      __ incrementq(rScratch1);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_wordsTailLoop);\n+      __ jmp(L_exit);\n+    }\n+\n+    __ BIND(L_fillQuadwords);\n+\n+    {\n+      Label L_qwordLoop, L_qwordsTail, L_qwordsTailLoop;\n+\n+      \/\/ .LBB0_24:\n+      \/\/         lea     rdx, [rsi + 7]\n+      \/\/         mov     rcx, rdx\n+      \/\/         shr     rcx, 6\n+      \/\/         cmp     rdx, 64\n+      \/\/         jb      .LBB0_27\n+      \/\/         lea     r8, [rdi + 56]\n+      \/\/         mov     r9, rcx\n+      __ leaq(rScratch2, Address(size, 7));\n+      __ movq(rScratch1, rScratch2);\n+      __ shrq(rScratch1, 6);\n+      __ cmpq(rScratch2, 64);\n+      __ jccb(Assembler::below, L_qwordsTail);\n+      __ leaq(rScratch3, Address(dest, 56));\n+      __ movq(rScratch4, rScratch1);\n+\n+      __ BIND(L_qwordLoop);\n+      \/\/ .LBB0_26:                               # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     qword ptr [r8 - 56], rax\n+      \/\/         mov     qword ptr [r8 - 48], rax\n+      \/\/         mov     qword ptr [r8 - 40], rax\n+      \/\/         mov     qword ptr [r8 - 32], rax\n+      \/\/         mov     qword ptr [r8 - 24], rax\n+      \/\/         mov     qword ptr [r8 - 16], rax\n+      \/\/         mov     qword ptr [r8 - 8], rax\n+      \/\/         mov     qword ptr [r8], rax\n+      \/\/         add     r8, 64\n+      \/\/         dec     r9\n+      \/\/         jne     .LBB0_26\n+      for (int i = 7; i >= 0; i--) {\n+        __ movq(Address(rScratch3, -(8 * i)), wide_value);\n+      }\n+      __ addq(rScratch3, 64);\n+      __ decrementq(rScratch4);\n+      __ jccb(Assembler::notZero, L_qwordLoop);\n+\n+      __ BIND(L_qwordsTail);\n+\n+      \/\/ .LBB0_27:\n+      \/\/         shl     rcx, 3\n+      \/\/         shr     rdx, 3\n+      \/\/         cmp     rcx, rdx\n+      \/\/         jae     .LBB0_17\n+      \/\/         dec     rsi\n+      \/\/         shr     rsi, 3\n+      \/\/         inc     rsi\n+      __ shlq(rScratch1, 3);\n+      __ shrq(rScratch2, 3);\n+      __ cmpq(rScratch1, rScratch2);\n+      __ jcc(Assembler::aboveEqual, L_exit);\n+      __ decrementq(size);\n+      __ shrq(size, 3);\n+      __ incrementq(size);\n+\n+      __ BIND(L_qwordsTailLoop);\n+\n+      \/\/ .LBB0_29:                               # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     qword ptr [rdi + 8*rcx], rax\n+      \/\/         inc     rcx\n+      \/\/         cmp     rsi, rcx\n+      \/\/         jne     .LBB0_29\n+      \/\/         jmp     .LBB0_17\n+      __ movq(Address(dest, rScratch1, Address::times_8), wide_value);\n+      __ incrementq(rScratch1);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_qwordsTailLoop);\n+      __ jmp(L_exit);\n+    }\n+\n+    __ BIND(L_fillDwords);\n+    {\n+      Label L_dwordLoop, L_dwordsTail, L_dwordsTailLoop;\n+      \/\/ .LBB0_3:\n+      \/\/         lea     rdx, [rsi + 3]\n+      \/\/         mov     rcx, rdx\n+      \/\/         shr     rcx, 5\n+      \/\/         cmp     rdx, 32\n+      \/\/         jb      .LBB0_6\n+      \/\/         lea     r8, [rdi + 28]\n+      \/\/         mov     r9, rcx\n+      __ leaq(rScratch2, Address(size, 3));\n+      __ movq(rScratch1, rScratch2);\n+      __ shrq(rScratch1, 5);\n+      __ cmpq(rScratch2, 32);\n+      __ jccb(Assembler::below, L_dwordsTail);\n+      __ leaq(rScratch3, Address(dest, 28));\n+      __ movq(rScratch4, rScratch1);\n+\n+      __ BIND(L_dwordLoop);\n+\n+      \/\/ .LBB0_5:                                # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     dword ptr [r8 - 28], eax\n+      \/\/         mov     dword ptr [r8 - 24], eax\n+      \/\/         mov     dword ptr [r8 - 20], eax\n+      \/\/         mov     dword ptr [r8 - 16], eax\n+      \/\/         mov     dword ptr [r8 - 12], eax\n+      \/\/         mov     dword ptr [r8 - 8], eax\n+      \/\/         mov     dword ptr [r8 - 4], eax\n+      \/\/         mov     dword ptr [r8], eax\n+      \/\/         add     r8, 32\n+      \/\/         dec     r9\n+      \/\/         jne     .LBB0_5\n+      for (int i = 7; i >= 0; i--) {\n+        __ movl(Address(rScratch3, -(i * 4)), wide_value);\n+      }\n+      __ addq(rScratch3, 32);\n+      __ decrementq(rScratch4);\n+      __ jccb(Assembler::notZero, L_dwordLoop);\n+\n+      __ BIND(L_dwordsTail);\n+\n+#undef rScratch3\n+#undef rScratch4\n+\n+      \/\/ .LBB0_6:\n+      \/\/         shl     rcx, 3\n+      \/\/         shr     rdx, 2\n+      \/\/         cmp     rcx, rdx\n+      \/\/         jae     .LBB0_17\n+      \/\/         dec     rsi\n+      \/\/         shr     rsi, 2\n+      \/\/         inc     rsi\n+      __ shlq(rScratch1, 3);\n+      __ shrq(rScratch2, 2);\n+      __ cmpq(rScratch1, rScratch2);\n+      __ jccb(Assembler::aboveEqual, L_exit);\n+      __ decrementq(size);\n+      __ shrq(size, 2);\n+      __ incrementq(size);\n+\n+      __ BIND(L_dwordsTailLoop);\n+\n+      \/\/ .LBB0_8:                                # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     dword ptr [rdi + 4*rcx], eax\n+      \/\/         inc     rcx\n+      \/\/         cmp     rsi, rcx\n+      \/\/         jne     .LBB0_8\n+      \/\/         jmp     .LBB0_17\n+      __ movl(Address(dest, rScratch1, Address::times_4), wide_value);\n+      __ incrementq(rScratch1);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_dwordsTailLoop);\n+      __ jmpb(L_exit);\n+    }\n+\n+    __ BIND(L_fillBytes);\n+    {\n+      Label L_byteLoop, L_longByteLoop, L_byteTail, L_byteTailLoop;\n+\n+#undef wide_value\n+#define savedSize rax\n+#undef rScratch2\n+#define byteVal rdx\n+      \/\/ .LBB0_10:\n+      \/\/         mov     eax, esi\n+      \/\/         and     eax, 7\n+      \/\/         cmp     rsi, 8\n+      \/\/         jae     .LBB0_12\n+      \/\/         xor     ecx, ecx\n+      \/\/         jmp     .LBB0_14\n+      __ movq(savedSize, size);\n+      __ andq(savedSize, 7);\n+      __ cmpq(size, 8);\n+      __ jccb(Assembler::aboveEqual, L_byteLoop);\n+      __ xorl(rScratch1, rScratch1);\n+      __ jmpb(L_byteTail);\n+\n+      __ BIND(L_byteLoop);\n+\n+      \/\/ .LBB0_12:\n+      \/\/         and     rsi, -8\n+      \/\/         xor     ecx, ecx\n+      __ andq(size, -8);\n+      __ xorl(rScratch1, rScratch1);\n+\n+      __ BIND(L_longByteLoop);\n+\n+      \/\/ .LBB0_13:                               # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     byte ptr [rdi + rcx], dl\n+      \/\/         mov     byte ptr [rdi + rcx + 1], dl\n+      \/\/         mov     byte ptr [rdi + rcx + 2], dl\n+      \/\/         mov     byte ptr [rdi + rcx + 3], dl\n+      \/\/         mov     byte ptr [rdi + rcx + 4], dl\n+      \/\/         mov     byte ptr [rdi + rcx + 5], dl\n+      \/\/         mov     byte ptr [rdi + rcx + 6], dl\n+      \/\/         mov     byte ptr [rdi + rcx + 7], dl\n+      \/\/         add     rcx, 8\n+      \/\/         cmp     rsi, rcx\n+      \/\/         jne     .LBB0_13\n+      for (int i = 0; i < 8; i++) {\n+        __ movb(Address(dest, rScratch1, Address::times_1, i), byteVal);\n+      }\n+      __ addq(rScratch1, 8);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_longByteLoop);\n+\n+      __ BIND(L_byteTail);\n+\n+      \/\/ .LBB0_14:\n+      \/\/         test    rax, rax\n+      \/\/         je      .LBB0_17\n+      \/\/         add     rdi, rcx\n+      \/\/         xor     ecx, ecx\n+      __ testq(savedSize, savedSize);\n+      __ jccb(Assembler::zero, L_exit);\n+      __ addq(dest, rScratch1);\n+      __ xorl(rScratch1, rScratch1);\n+\n+      __ BIND(L_byteTailLoop);\n+\n+      \/\/ .LBB0_16:                               # =>This Inner Loop Header:\n+      \/\/ Depth=1\n+      \/\/         mov     byte ptr [rdi + rcx], dl\n+      \/\/         inc     rcx\n+      \/\/         cmp     rax, rcx\n+      \/\/         jne     .LBB0_16\n+      __ movb(Address(dest, rScratch1, Address::times_1), byteVal);\n+      __ incrementq(rScratch1);\n+      __ cmpq(savedSize, rScratch1);\n+      __ jccb(Assembler::notEqual, L_byteTailLoop);\n+    }\n+    __ BIND(L_exit);\n+\n+    \/\/ .LBB0_17:\n+    \/\/         ret\n+    restore_arg_regs();\n+    __ ret(0);\n+\n+#undef dest\n+#undef size\n+#undef savedSize\n+#undef rScratch1\n+#undef byteVal\n+  }\n+#endif\n+#endif\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":781,"deletions":28,"binary":false,"changes":809,"status":"modified"},{"patch":"@@ -210,2 +210,2 @@\n-        \/\/ long seed = 6742745864802755133L;\n-        long seed = random.nextLong();\n+        long seed = 6742745864802755133L;\n+        \/\/ long seed = random.nextLong();\n","filename":"test\/jdk\/sun\/misc\/CopyMemory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}