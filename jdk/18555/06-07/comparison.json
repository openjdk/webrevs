{"files":[{"patch":"@@ -5968,1 +5968,1 @@\n-  cmpl(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n+  cmpptr(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n@@ -6045,1 +6045,1 @@\n-          cmpl(count, VM_Version::avx3_threshold());\n+          cmpptr(count, VM_Version::avx3_threshold());\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4016,0 +4016,5 @@\n+  \/\/ Initialize table for unsafe set memeory check.\n+  if (UnsafeSetMemory::_table == nullptr) {\n+    UnsafeSetMemory::create_table(16);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -735,0 +735,1 @@\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, false, ucme_exit_pc);\n@@ -2550,0 +2551,1 @@\n+      UnsafeSetMemoryMark usmm(this, true, true);\n@@ -2587,1 +2589,0 @@\n-      __ jmp(L_exit);\n@@ -2589,0 +2590,1 @@\n+    __ jmp(L_exit);\n@@ -2595,0 +2597,1 @@\n+      UnsafeSetMemoryMark usmm(this, true, true);\n@@ -2631,1 +2634,0 @@\n-      __ jmp(L_exit);\n@@ -2633,0 +2635,4 @@\n+    __ BIND(L_exit);\n+\n+    restore_arg_regs();\n+    __ ret(0);\n@@ -2639,0 +2645,1 @@\n+      UnsafeSetMemoryMark usmm(this, true, true);\n@@ -2678,1 +2685,0 @@\n-      __ jmpb(L_exit);\n@@ -2680,0 +2686,1 @@\n+    __ jmpb(L_exit);\n@@ -2685,0 +2692,1 @@\n+      UnsafeSetMemoryMark usmm(this, true, true);\n@@ -2741,1 +2749,14 @@\n-      __ jump(RuntimeAddress(byte_fill_entry));\n+      \/\/ generate_unsafe_fill(T_BYTE, false, \"unsafe_set_memory\");\n+      __ mov(r11, c_rarg2);\n+\n+      __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+      {\n+        UnsafeSetMemoryMark usmm(this, true, true);\n+\n+        __ generate_fill(T_BYTE, false, c_rarg0, c_rarg1, r11, rax, xmm0);\n+      }\n+\n+      __ vzeroupper();\n+      __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+      __ ret(0);\n@@ -2744,4 +2765,0 @@\n-    __ BIND(L_exit);\n-\n-    restore_arg_regs();\n-    __ ret(0);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":25,"deletions":8,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2791,1 +2791,2 @@\n-      if (((in_vm || in_native || is_unsafe_arraycopy) && thread->doing_unsafe_access()) ||\n+      bool is_unsafe_setmemory = (in_native || in_java) && UnsafeSetMemory::contains_pc(pc);\n+      if (((in_vm || in_native || is_unsafe_arraycopy || is_unsafe_setmemory) && thread->doing_unsafe_access()) ||\n@@ -2797,0 +2798,3 @@\n+        if (is_unsafe_setmemory) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -445,1 +445,3 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc);\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy ||\n+            is_unsafe_setmemory) {\n@@ -450,0 +452,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -452,3 +457,1 @@\n-      }\n-      else\n-\n+      } else\n@@ -456,1 +459,1 @@\n-      if (sig == SIGFPE  &&\n+      if (sig == SIGFPE &&\n@@ -529,0 +532,3 @@\n+        if (UnsafeSetMemory::contains_pc(pc)) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -264,1 +264,3 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc);\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy ||\n+            is_unsafe_setmemory) {\n@@ -269,0 +271,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -271,3 +276,1 @@\n-      }\n-      else\n-\n+      } else\n@@ -275,1 +278,1 @@\n-      if (sig == SIGFPE  &&\n+      if (sig == SIGFPE &&\n@@ -323,0 +326,3 @@\n+        if (UnsafeSetMemory::contains_pc(pc)) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -4954,1 +4954,1 @@\n-  C->set_has_unsafe_access(true);  \/\/ Mark eventual nmethod as \"unsafe\".\n+  if (StubRoutines::unsafe_setmemory() == nullptr) return false;\n@@ -4956,1 +4956,1 @@\n-  \/\/ printf(\"In inline_unsafe_setMemory\\n\");\n+  C->set_has_unsafe_access(true);  \/\/ Mark eventual nmethod as \"unsafe\".\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+UnsafeSetMemory* UnsafeSetMemory::_table                       = nullptr;\n+int UnsafeSetMemory::_table_length                             = 0;\n+int UnsafeSetMemory::_table_max_length                         = 0;\n+address UnsafeSetMemory::_common_exit_stub_pc                  = nullptr;\n+\n@@ -229,0 +234,25 @@\n+void UnsafeSetMemory::create_table(int max_size) {\n+  UnsafeSetMemory::_table = new UnsafeSetMemory[max_size];\n+  UnsafeSetMemory::_table_max_length = max_size;\n+}\n+\n+bool UnsafeSetMemory::contains_pc(address pc) {\n+  for (int i = 0; i < UnsafeSetMemory::_table_length; i++) {\n+    UnsafeSetMemory* entry = &UnsafeSetMemory::_table[i];\n+    if (pc >= entry->start_pc() && pc < entry->end_pc()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+address UnsafeSetMemory::page_error_continue_pc(address pc) {\n+  for (int i = 0; i < UnsafeSetMemory::_table_length; i++) {\n+    UnsafeSetMemory* entry = &UnsafeSetMemory::_table[i];\n+    if (pc >= entry->start_pc() && pc < entry->end_pc()) {\n+      return entry->error_exit_pc();\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -542,0 +572,22 @@\n+\n+UnsafeSetMemoryMark::UnsafeSetMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc) {\n+  _cgen = cgen;\n+  _ucm_entry = nullptr;\n+  if (add_entry) {\n+    address err_exit_pc = nullptr;\n+    if (!continue_at_scope_end) {\n+      err_exit_pc = error_exit_pc != nullptr ? error_exit_pc : UnsafeSetMemory::common_exit_stub_pc();\n+    }\n+    assert(err_exit_pc != nullptr || continue_at_scope_end, \"error exit not set\");\n+    _ucm_entry = UnsafeSetMemory::add_to_table(_cgen->assembler()->pc(), nullptr, err_exit_pc);\n+  }\n+}\n+\n+UnsafeSetMemoryMark::~UnsafeSetMemoryMark() {\n+  if (_ucm_entry != nullptr) {\n+    _ucm_entry->set_end_pc(_cgen->assembler()->pc());\n+    if (_ucm_entry->error_exit_pc() == nullptr) {\n+      _ucm_entry->set_error_exit_pc(_cgen->assembler()->pc());\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -125,0 +125,46 @@\n+class UnsafeSetMemory : public CHeapObj<mtCode> {\n+ private:\n+  address _start_pc;\n+  address _end_pc;\n+  address _error_exit_pc;\n+ public:\n+  static address           _common_exit_stub_pc;\n+  static UnsafeSetMemory* _table;\n+  static int               _table_length;\n+  static int               _table_max_length;\n+  UnsafeSetMemory() : _start_pc(nullptr), _end_pc(nullptr), _error_exit_pc(nullptr) {}\n+  void    set_start_pc(address pc)      { _start_pc = pc; }\n+  void    set_end_pc(address pc)        { _end_pc = pc; }\n+  void    set_error_exit_pc(address pc) { _error_exit_pc = pc; }\n+  address start_pc()      const { return _start_pc; }\n+  address end_pc()        const { return _end_pc; }\n+  address error_exit_pc() const { return _error_exit_pc; }\n+\n+  static void    set_common_exit_stub_pc(address pc) { _common_exit_stub_pc = pc; }\n+  static address common_exit_stub_pc()               { return _common_exit_stub_pc; }\n+\n+  static UnsafeSetMemory* add_to_table(address start_pc, address end_pc, address error_exit_pc) {\n+    guarantee(_table_length < _table_max_length, \"Incorrect UnsafeSetMemory::_table_max_length\");\n+    UnsafeSetMemory* entry = &_table[_table_length];\n+    entry->set_start_pc(start_pc);\n+    entry->set_end_pc(end_pc);\n+    entry->set_error_exit_pc(error_exit_pc);\n+\n+    _table_length++;\n+    return entry;\n+  }\n+\n+  static bool    contains_pc(address pc);\n+  static address page_error_continue_pc(address pc);\n+  static void    create_table(int max_size);\n+};\n+\n+class UnsafeSetMemoryMark : public StackObj {\n+ private:\n+  UnsafeSetMemory*  _ucm_entry;\n+  StubCodeGenerator* _cgen;\n+ public:\n+  UnsafeSetMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = nullptr);\n+  ~UnsafeSetMemoryMark();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":46,"deletions":0,"binary":false,"changes":46,"status":"modified"}]}