{"files":[{"patch":"@@ -8339,0 +8339,5 @@\n+    \/\/ Initialize table for fill memory check.\n+    if (UnsafeCopyMemory::_table == nullptr) {\n+      UnsafeCopyMemory::create_table(8);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3141,0 +3141,4 @@\n+    if (UnsafeSetMemory::_table == nullptr) {\n+      UnsafeSetMemory::create_table(32);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -4752,0 +4752,4 @@\n+    if (UnsafeSetMemory::_table == nullptr) {\n+      UnsafeSetMemory::create_table(8);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -5486,0 +5486,4 @@\n+    if (UnsafeSetMemory::_table == nullptr) {\n+      UnsafeSetMemory::create_table(8);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -937,0 +937,1 @@\n+    case 0xD6: \/\/ movq\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -5968,1 +5968,1 @@\n-  cmpl(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n+  cmpptr(count, 2<<shift); \/\/ Short arrays (< 8 bytes) fill by element\n@@ -5988,1 +5988,1 @@\n-    subl(count, 1<<(shift-1));\n+    subptr(count, 1<<(shift-1));\n@@ -5994,1 +5994,1 @@\n-    subl(count, 8 << shift);\n+    subptr(count, 8 << shift);\n@@ -6005,1 +6005,1 @@\n-    subl(count, 8 << shift);\n+    subptr(count, 8 << shift);\n@@ -6008,1 +6008,1 @@\n-    addl(count, 8 << shift);\n+    addptr(count, 8 << shift);\n@@ -6020,1 +6020,1 @@\n-    subl(count, 1 << (shift + 1));\n+    subptr(count, 1 << (shift + 1));\n@@ -6031,1 +6031,1 @@\n-      subl(count, 1<<shift);\n+      subptr(count, 1<<shift);\n@@ -6045,1 +6045,1 @@\n-          cmpl(count, VM_Version::avx3_threshold());\n+          cmpptr(count, VM_Version::avx3_threshold());\n@@ -6050,1 +6050,1 @@\n-          subl(count, 16 << shift);\n+          subptr(count, 16 << shift);\n@@ -6057,1 +6057,1 @@\n-          subl(count, 16 << shift);\n+          subptr(count, 16 << shift);\n@@ -6067,1 +6067,1 @@\n-        subl(count, 16 << shift);\n+        subptr(count, 16 << shift);\n@@ -6075,1 +6075,1 @@\n-        subl(count, 16 << shift);\n+        subptr(count, 16 << shift);\n@@ -6079,1 +6079,1 @@\n-        addl(count, 8 << shift);\n+        addptr(count, 8 << shift);\n@@ -6083,1 +6083,1 @@\n-        subl(count, 8 << shift);\n+        subptr(count, 8 << shift);\n@@ -6093,1 +6093,1 @@\n-        subl(count, 8 << shift);\n+        subptr(count, 8 << shift);\n@@ -6110,1 +6110,1 @@\n-        subl(count, 8 << shift);\n+        subptr(count, 8 << shift);\n@@ -6115,1 +6115,1 @@\n-      addl(count, 8 << shift);\n+      addptr(count, 8 << shift);\n@@ -6126,1 +6126,1 @@\n-      subl(count, 1 << (shift + 1));\n+      subptr(count, 1 << (shift + 1));\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -4128,0 +4128,5 @@\n+    \/\/ Initialize table for fill memory check.\n+    if (UnsafeSetMemory::_table == nullptr) {\n+      UnsafeSetMemory::create_table(8);\n+    }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -4016,0 +4016,5 @@\n+  \/\/ Initialize table for unsafe set memeory check.\n+  if (UnsafeSetMemory::_table == nullptr) {\n+    UnsafeSetMemory::create_table(16);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -271,0 +271,8 @@\n+  \/\/ Generate 'unsafe' set memory stub\n+  \/\/ Though just as safe as the other stubs, it takes an unscaled\n+  \/\/ size_t argument instead of an element count.\n+  \/\/\n+  \/\/ Examines the alignment of the operands and dispatches\n+  \/\/ to an int, short, or byte copy loop.\n+  address generate_unsafe_setmemory(const char *name, address byte_fill_entry);\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -155,0 +155,5 @@\n+\/\/ #ifdef _LP64\n+  StubRoutines::_unsafe_setmemory =\n+      generate_unsafe_setmemory(\"unsafe_setmemory\", StubRoutines::_jbyte_fill);\n+\/\/ #endif\n+\n@@ -730,0 +735,1 @@\n+    UnsafeCopyMemoryMark ucmm(this, !is_oop && !aligned, false, ucme_exit_pc);\n@@ -2479,0 +2485,291 @@\n+\/\/  Generate 'unsafe' set memory stub\n+\/\/  Though just as safe as the other stubs, it takes an unscaled\n+\/\/  size_t argument instead of an element count.\n+\/\/\n+\/\/  Input:\n+\/\/    c_rarg0   - destination array address\n+\/\/    c_rarg1   - byte count (size_t)\n+\/\/    c_rarg2   - byte value\n+\/\/\n+\/\/ Examines the alignment of the operands and dispatches\n+\/\/ to an int, short, or byte fill loop.\n+\/\/\n+address StubGenerator::generate_unsafe_setmemory(const char *name,\n+                                                 address byte_fill_entry) {\n+  __ align(CodeEntryAlignment);\n+  StubCodeMark mark(this, \"StubRoutines\", name);\n+  address start = __ pc();\n+\n+  \/\/ bump this on entry, not on exit:\n+  INC_COUNTER_NP(SharedRuntime::_unsafe_set_memory_ctr, rscratch1);\n+\n+  {\n+    Label L_exit, L_fillQuadwords, L_fillDwords, L_fillBytes;\n+\n+    setup_arg_regs(3);\n+#undef dest\n+#define dest rdi\n+#undef size\n+#define size rsi\n+#undef wide_value\n+#define wide_value rax\n+#undef rScratch1\n+#define rScratch1 rcx\n+#undef byteVal\n+#define byteVal rdx\n+#undef rScratch3\n+#define rScratch3 r8\n+#undef rScratch4\n+#define rScratch4 r11\n+\n+    \/\/     fill_to_memory_atomic(unsigned char*, unsigned long, unsigned char)\n+\n+    __ testq(size, size);\n+    __ jcc(Assembler::zero, L_exit);\n+\n+    \/\/ Propagate byte to full register\n+    __ movq(rScratch1, dest);\n+    __ orq(rScratch1, size);\n+    __ movzbl(rScratch3, byteVal);\n+    __ mov64(wide_value, 0x0101010101010101);\n+    __ imulq(wide_value, rScratch3);\n+\n+#undef byteVal\n+#define rScratch2 rdx\n+    __ testb(rScratch1, 7);\n+    __ jcc(Assembler::equal, L_fillQuadwords);\n+\n+    __ testb(rScratch1, 3);\n+    __ jcc(Assembler::equal, L_fillDwords);\n+\n+    __ testb(rScratch1, 1);\n+    __ jcc(Assembler::notEqual, L_fillBytes);\n+\n+    \/\/ Fill words\n+    {\n+      Label L_wordsTail, L_wordsLoop, L_wordsTailLoop;\n+      UnsafeSetMemoryMark usmm(this, true, true);\n+      \/\/\/\/\/\/  Set words\n+      __ leaq(rScratch2, Address(size, 1));\n+      __ movq(rScratch1, rScratch2);\n+      __ shrq(rScratch1, 4);\n+      __ cmpq(rScratch2, 16);\n+      __ jccb(Assembler::below, L_wordsTail);\n+      __ leaq(rScratch3, Address(dest, 14));\n+      __ movq(rScratch4, rScratch1);\n+\n+      __ BIND(L_wordsLoop);\n+\n+      \/\/ Unroll 8 word stores\n+      for (int i = 7; i >= 0; i--) {\n+        __ movw(Address(rScratch3, -(2 * i)), wide_value);\n+      }\n+\n+      __ addq(rScratch3, 16);\n+      __ decrementq(rScratch4);\n+      __ jccb(Assembler::notEqual, L_wordsLoop);\n+\n+      __ BIND(L_wordsTail);\n+\n+      \/\/ Handle leftovers\n+      __ shlq(rScratch1, 3);\n+      __ shrq(rScratch2, 1);\n+      __ cmpq(rScratch1, rScratch2);\n+      __ jcc(Assembler::aboveEqual, L_exit);\n+      __ decrementq(size);\n+      __ shrq(size, 1);\n+      __ incrementq(size);\n+\n+      __ BIND(L_wordsTailLoop);\n+\n+      __ movw(Address(dest, rScratch1, Address::times_2), wide_value);\n+      __ incrementq(rScratch1);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_wordsTailLoop);\n+    }\n+    __ jmp(L_exit);\n+\n+    __ BIND(L_fillQuadwords);\n+\n+    \/\/ Fill QUADWORDs\n+    {\n+      Label L_qwordLoop, L_qwordsTail, L_qwordsTailLoop;\n+      UnsafeSetMemoryMark usmm(this, true, true);\n+\n+      __ leaq(rScratch2, Address(size, 7));\n+      __ movq(rScratch1, rScratch2);\n+      __ shrq(rScratch1, 6);\n+      __ cmpq(rScratch2, 64);\n+      __ jccb(Assembler::below, L_qwordsTail);\n+      __ leaq(rScratch3, Address(dest, 56));\n+      __ movq(rScratch4, rScratch1);\n+\n+      __ BIND(L_qwordLoop);\n+\n+      \/\/ Unroll 8 qword stores\n+      for (int i = 7; i >= 0; i--) {\n+        __ movq(Address(rScratch3, -(8 * i)), wide_value);\n+      }\n+      __ addq(rScratch3, 64);\n+      __ decrementq(rScratch4);\n+      __ jccb(Assembler::notZero, L_qwordLoop);\n+\n+      __ BIND(L_qwordsTail);\n+\n+      \/\/ Handle leftovers\n+      __ shlq(rScratch1, 3);\n+      __ shrq(rScratch2, 3);\n+      __ cmpq(rScratch1, rScratch2);\n+      __ jcc(Assembler::aboveEqual, L_exit);\n+      __ decrementq(size);\n+      __ shrq(size, 3);\n+      __ incrementq(size);\n+\n+      __ BIND(L_qwordsTailLoop);\n+\n+      __ movq(Address(dest, rScratch1, Address::times_8), wide_value);\n+      __ incrementq(rScratch1);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_qwordsTailLoop);\n+    }\n+    __ BIND(L_exit);\n+\n+    restore_arg_regs();\n+    __ ret(0);\n+\n+    __ BIND(L_fillDwords);\n+\n+    \/\/ Fill DWORDs\n+    {\n+      Label L_dwordLoop, L_dwordsTail, L_dwordsTailLoop;\n+      UnsafeSetMemoryMark usmm(this, true, true);\n+\n+      __ leaq(rScratch2, Address(size, 3));\n+      __ movq(rScratch1, rScratch2);\n+      __ shrq(rScratch1, 5);\n+      __ cmpq(rScratch2, 32);\n+      __ jccb(Assembler::below, L_dwordsTail);\n+      __ leaq(rScratch3, Address(dest, 28));\n+      __ movq(rScratch4, rScratch1);\n+\n+      __ BIND(L_dwordLoop);\n+\n+      \/\/ Unroll 8 dword stores\n+      for (int i = 7; i >= 0; i--) {\n+        __ movl(Address(rScratch3, -(i * 4)), wide_value);\n+      }\n+      __ addq(rScratch3, 32);\n+      __ decrementq(rScratch4);\n+      __ jccb(Assembler::notZero, L_dwordLoop);\n+\n+      __ BIND(L_dwordsTail);\n+\n+#undef rScratch3\n+#undef rScratch4\n+\n+      \/\/ Handle leftovers\n+      __ shlq(rScratch1, 3);\n+      __ shrq(rScratch2, 2);\n+      __ cmpq(rScratch1, rScratch2);\n+      __ jccb(Assembler::aboveEqual, L_exit);\n+      __ decrementq(size);\n+      __ shrq(size, 2);\n+      __ incrementq(size);\n+\n+      __ BIND(L_dwordsTailLoop);\n+\n+      __ movl(Address(dest, rScratch1, Address::times_4), wide_value);\n+      __ incrementq(rScratch1);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_dwordsTailLoop);\n+    }\n+    __ jmpb(L_exit);\n+\n+    __ BIND(L_fillBytes);\n+#ifdef MUSL_LIBC\n+    {\n+      Label L_byteLoop, L_longByteLoop, L_byteTail, L_byteTailLoop;\n+      UnsafeSetMemoryMark usmm(this, true, true);\n+\n+#undef wide_value\n+#define savedSize rax\n+#undef rScratch2\n+#define byteVal rdx\n+\n+      __ movq(savedSize, size);\n+      __ andq(savedSize, 7);\n+      __ cmpq(size, 8);\n+      __ jccb(Assembler::aboveEqual, L_byteLoop);\n+      __ xorl(rScratch1, rScratch1);\n+      __ jmpb(L_byteTail);\n+\n+      __ BIND(L_byteLoop);\n+\n+      __ andq(size, -8);\n+      __ xorl(rScratch1, rScratch1);\n+\n+      __ BIND(L_longByteLoop);\n+\n+      \/\/ Unroll 8 byte stores\n+      for (int i = 0; i < 8; i++) {\n+        __ movb(Address(dest, rScratch1, Address::times_1, i), byteVal);\n+      }\n+\n+      __ addq(rScratch1, 8);\n+      __ cmpq(size, rScratch1);\n+      __ jccb(Assembler::notEqual, L_longByteLoop);\n+\n+      __ BIND(L_byteTail);\n+\n+      __ testq(savedSize, savedSize);\n+      __ jccb(Assembler::zero, L_exit);\n+      __ addq(dest, rScratch1);\n+      __ xorl(rScratch1, rScratch1);\n+\n+      __ BIND(L_byteTailLoop);\n+\n+      __ movb(Address(dest, rScratch1, Address::times_1), byteVal);\n+      __ incrementq(rScratch1);\n+      __ cmpq(savedSize, rScratch1);\n+      __ jccb(Assembler::notEqual, L_byteTailLoop);\n+    }\n+#else  \/\/ MUSL_LIBC\n+#define byteVal rdx\n+    {\n+#ifdef _WIN32\n+      __ movq(rcx, rdi); \/\/ Restore c_rarg*\n+      __ movq(rdx, rsi);\n+      __ movq(r8, rdx);\n+      restore_arg_regs();\n+#endif\n+      \/\/ rax has expanded byte value\n+      __ movq(c_rarg2, rax);\n+\n+      __ xchgq(c_rarg1, c_rarg2);\n+      \/\/ generate_unsafe_fill(T_BYTE, false, \"unsafe_set_memory\");\n+      __ mov(r11, c_rarg2);\n+\n+      __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+      {\n+        UnsafeSetMemoryMark usmm(this, true, true);\n+\n+        __ generate_fill(T_BYTE, false, c_rarg0, c_rarg1, r11, rax, xmm0);\n+      }\n+\n+      __ vzeroupper();\n+      __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+      __ ret(0);\n+    }\n+#endif  \/\/ MUSL_LIBC\n+\n+#undef dest\n+#undef size\n+#undef savedSize\n+#undef rScratch1\n+#undef byteVal\n+  }\n+\n+  return start;\n+}\n+\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":297,"deletions":0,"binary":false,"changes":297,"status":"modified"},{"patch":"@@ -151,0 +151,3 @@\n+    \/\/ Shared code tests for \"null\" to discover the stub is not generated.\n+    StubRoutines::_unsafe_setmemory          = nullptr;\n+\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2791,1 +2791,2 @@\n-      if (((in_vm || in_native || is_unsafe_arraycopy) && thread->doing_unsafe_access()) ||\n+      bool is_unsafe_setmemory = (in_native || in_java) && UnsafeSetMemory::contains_pc(pc);\n+      if (((in_vm || in_native || is_unsafe_arraycopy || is_unsafe_setmemory) && thread->doing_unsafe_access()) ||\n@@ -2797,0 +2798,3 @@\n+        if (is_unsafe_setmemory) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -344,1 +344,2 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = (thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy || is_unsafe_setmemory) {\n@@ -349,0 +350,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -374,0 +378,3 @@\n+        if (UnsafeSetMemory::contains_pc(pc)) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os_cpu\/aix_ppc\/os_aix_ppc.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -261,1 +261,2 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = (thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy || is_unsafe_setmemory) {\n@@ -266,0 +267,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -305,0 +309,3 @@\n+      if (UnsafeSetMemory::contains_pc(pc)) {\n+        next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+      }\n","filename":"src\/hotspot\/os_cpu\/bsd_aarch64\/os_bsd_aarch64.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -445,1 +445,3 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc);\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy ||\n+            is_unsafe_setmemory) {\n@@ -450,0 +452,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -452,3 +457,1 @@\n-      }\n-      else\n-\n+      } else\n@@ -456,1 +459,1 @@\n-      if (sig == SIGFPE  &&\n+      if (sig == SIGFPE &&\n@@ -529,0 +532,3 @@\n+        if (UnsafeSetMemory::contains_pc(pc)) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os_cpu\/bsd_x86\/os_bsd_x86.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -244,0 +244,1 @@\n+        bool is_unsafe_setmemory = (thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc));\n@@ -249,0 +250,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -292,0 +296,3 @@\n+      if (UnsafeSetMemory::contains_pc(pc)) {\n+        next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+      }\n","filename":"src\/hotspot\/os_cpu\/linux_aarch64\/os_linux_aarch64.cpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -327,1 +327,4 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || (thread->doing_unsafe_access() && UnsafeCopyMemory::contains_pc(pc))) {\n+        if ((nm != nullptr && nm->has_unsafe_access()) ||\n+            (thread->doing_unsafe_access() &&\n+             (UnsafeCopyMemory::contains_pc(pc) ||\n+              UnsafeSetMemory::contains_pc(pc)))) {\n@@ -332,6 +335,9 @@\n-          \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n-          CodeBlob* cb = CodeCache::find_blob(pc);\n-          if (cb != nullptr) {\n-            stub = SharedRuntime::continuation_for_implicit_exception(thread, pc, SharedRuntime::IMPLICIT_NULL);\n-          }\n-      } else if (sig == SIGILL && *(int *)pc == NativeInstruction::not_entrant_illegal_instruction) {\n+        \/\/ Determination of interpreter\/vtable stub\/compiled code null exception\n+        CodeBlob* cb = CodeCache::find_blob(pc);\n+        if (cb != nullptr) {\n+          stub = SharedRuntime::continuation_for_implicit_exception(\n+              thread, pc, SharedRuntime::IMPLICIT_NULL);\n+        }\n+      } else if (sig == SIGILL &&\n+                 *(int*)pc ==\n+                     NativeInstruction::not_entrant_illegal_instruction) {\n@@ -365,0 +371,3 @@\n+    if (UnsafeSetMemory::contains_pc(pc)) {\n+      next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+    }\n","filename":"src\/hotspot\/os_cpu\/linux_arm\/os_linux_arm.cpp","additions":16,"deletions":7,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -359,1 +359,2 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = (thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy || is_unsafe_setmemory) {\n@@ -364,0 +365,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -385,0 +389,3 @@\n+        if (UnsafeSetMemory::contains_pc(pc)) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os_cpu\/linux_ppc\/os_linux_ppc.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -234,1 +234,2 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = (thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc));\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy || is_unsafe_setmemory) {\n@@ -239,0 +240,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -278,0 +282,3 @@\n+      if (UnsafeSetMemory::contains_pc(pc)) {\n+        next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+      }\n","filename":"src\/hotspot\/os_cpu\/linux_riscv\/os_linux_riscv.cpp","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -264,1 +264,3 @@\n-        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy) {\n+        bool is_unsafe_setmemory = thread->doing_unsafe_access() && UnsafeSetMemory::contains_pc(pc);\n+        if ((nm != nullptr && nm->has_unsafe_access()) || is_unsafe_arraycopy ||\n+            is_unsafe_setmemory) {\n@@ -269,0 +271,3 @@\n+          if (is_unsafe_setmemory) {\n+            next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+          }\n@@ -271,3 +276,1 @@\n-      }\n-      else\n-\n+      } else\n@@ -275,1 +278,1 @@\n-      if (sig == SIGFPE  &&\n+      if (sig == SIGFPE &&\n@@ -323,0 +326,3 @@\n+        if (UnsafeSetMemory::contains_pc(pc)) {\n+          next_pc = UnsafeSetMemory::page_error_continue_pc(pc);\n+        }\n","filename":"src\/hotspot\/os_cpu\/linux_x86\/os_linux_x86.cpp","additions":11,"deletions":5,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -509,0 +509,3 @@\n+  case vmIntrinsics::_setMemory:\n+    if (!InlineUnsafeOps) return true;\n+    break;\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -623,0 +623,3 @@\n+  do_intrinsic(_setMemory,                jdk_internal_misc_Unsafe,     setMemory_name,  setMemory_signature,          F_RN)     \\\n+   do_name(     setMemory_name,                                         \"setMemory0\")                                            \\\n+   do_signature(setMemory_signature,                                    \"(Ljava\/lang\/Object;JJB)V\")                              \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -345,0 +345,1 @@\n+  static_field(StubRoutines,                _unsafe_setmemory,                                address)                               \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -260,0 +260,3 @@\n+  case vmIntrinsics::_setMemory:\n+    if (StubRoutines::unsafe_setmemory() == nullptr) return false;\n+    break;\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -510,0 +510,1 @@\n+  case vmIntrinsics::_setMemory:                return inline_unsafe_setMemory();\n@@ -4944,0 +4945,51 @@\n+\n+  return true;\n+}\n+\n+bool LibraryCallKit::inline_unsafe_setMemory() {\n+  if (callee()->is_static())  return false;  \/\/ caller must have the capability!\n+  null_check_receiver();  \/\/ null-check receiver\n+  if (stopped())  return true;\n+\n+  if (StubRoutines::unsafe_setmemory() == nullptr) return false;\n+\n+  C->set_has_unsafe_access(true);  \/\/ Mark eventual nmethod as \"unsafe\".\n+\n+  Node* dst_base =         argument(1);  \/\/ type: oop\n+  Node* dst_off  = ConvL2X(argument(2)); \/\/ type: long\n+  Node* size     = ConvL2X(argument(4)); \/\/ type: long\n+  Node* byte     =         argument(6);  \/\/ type: byte\n+\n+  assert(Unsafe_field_offset_to_byte_offset(11) == 11,\n+         \"fieldOffset must be byte-scaled\");\n+\n+  Node* dst_addr = make_unsafe_address(dst_base, dst_off);\n+\n+  Node* thread = _gvn.transform(new ThreadLocalNode());\n+  Node* doing_unsafe_access_addr = basic_plus_adr(top(), thread, in_bytes(JavaThread::doing_unsafe_access_offset()));\n+  BasicType doing_unsafe_access_bt = T_BYTE;\n+  assert((sizeof(bool) * CHAR_BIT) == 8, \"not implemented\");\n+\n+  \/\/ update volatile field\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(1), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  int flags = RC_LEAF | RC_NO_FP;\n+\n+  const TypePtr* dst_type = TypePtr::BOTTOM;\n+\n+  \/\/ Adjust memory effects of the runtime call based on input values.\n+  if (!has_wide_mem(_gvn, dst_addr, dst_base)) {\n+    dst_type = _gvn.type(dst_addr)->is_ptr(); \/\/ narrow out memory\n+\n+    flags |= RC_NARROW_MEM; \/\/ narrow in memory\n+  }\n+\n+  \/\/ Call it.  Note that the length argument is not scaled.\n+  make_runtime_call(flags,\n+                    OptoRuntime::make_setmemory_Type(),\n+                    StubRoutines::unsafe_setmemory(),\n+                    \"unsafe_setmemory\",\n+                    dst_type,\n+                    dst_addr, size XTOP, byte);\n+\n+  store_to_memory(control(), doing_unsafe_access_addr, intcon(0), doing_unsafe_access_bt, Compile::AliasIdxRaw, MemNode::unordered);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -234,0 +234,1 @@\n+  bool inline_unsafe_setMemory();\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -775,0 +775,20 @@\n+const TypeFunc* OptoRuntime::make_setmemory_Type() {\n+  \/\/ create input type (domain)\n+  int num_args      = 4;\n+  int argcnt = num_args;\n+  const Type** fields = TypeTuple::fields(argcnt);\n+  int argp = TypeFunc::Parms;\n+  fields[argp++] = TypePtr::NOTNULL;    \/\/ dest\n+  fields[argp++] = TypeLong::LONG;      \/\/ size\n+  fields[argp++] = Type::HALF;          \/\/ size\n+  fields[argp++] = TypeInt::INT;        \/\/ bytevalue\n+  assert(argp == TypeFunc::Parms+argcnt, \"correct decoding\");\n+  const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);\n+\n+  \/\/ no result type needed\n+  fields = TypeTuple::fields(1);\n+  fields[TypeFunc::Parms+0] = nullptr; \/\/ void\n+  const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);\n+  return TypeFunc::make(domain, range);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -269,0 +269,2 @@\n+  static const TypeFunc* make_setmemory_Type();\n+\n","filename":"src\/hotspot\/share\/opto\/runtime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -396,1 +396,6 @@\n-    Copy::fill_to_memory_atomic(p, sz, value);\n+    if (StubRoutines::unsafe_setmemory() != nullptr) {\n+      MACOS_AARCH64_ONLY(ThreadWXEnable wx(WXExec, thread));\n+      StubRoutines::UnsafeSetMemory_stub()(p, sz, value);\n+    } else {\n+      Copy::fill_to_memory_atomic(p, sz, value);\n+    }\n","filename":"src\/hotspot\/share\/prims\/unsafe.cpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -180,0 +180,2 @@\n+uint SharedRuntime::_unsafe_set_memory_ctr=0;\n+\n@@ -1992,0 +1994,2 @@\n+  if (_unsafe_set_memory_ctr) tty->print_cr(\"%5u unsafe set memorys\", _unsafe_set_memory_ctr);\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -545,0 +545,2 @@\n+  static uint _unsafe_set_memory_ctr;      \/\/ Slow-path includes alignment checks\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,0 +48,5 @@\n+UnsafeSetMemory* UnsafeSetMemory::_table                       = nullptr;\n+int UnsafeSetMemory::_table_length                             = 0;\n+int UnsafeSetMemory::_table_max_length                         = 0;\n+address UnsafeSetMemory::_common_exit_stub_pc                  = nullptr;\n+\n@@ -112,0 +117,2 @@\n+address StubRoutines::_unsafe_setmemory                  = nullptr;\n+\n@@ -227,0 +234,25 @@\n+void UnsafeSetMemory::create_table(int max_size) {\n+  UnsafeSetMemory::_table = new UnsafeSetMemory[max_size];\n+  UnsafeSetMemory::_table_max_length = max_size;\n+}\n+\n+bool UnsafeSetMemory::contains_pc(address pc) {\n+  for (int i = 0; i < UnsafeSetMemory::_table_length; i++) {\n+    UnsafeSetMemory* entry = &UnsafeSetMemory::_table[i];\n+    if (pc >= entry->start_pc() && pc < entry->end_pc()) {\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+address UnsafeSetMemory::page_error_continue_pc(address pc) {\n+  for (int i = 0; i < UnsafeSetMemory::_table_length; i++) {\n+    UnsafeSetMemory* entry = &UnsafeSetMemory::_table[i];\n+    if (pc >= entry->start_pc() && pc < entry->end_pc()) {\n+      return entry->error_exit_pc();\n+    }\n+  }\n+  return nullptr;\n+}\n+\n@@ -540,0 +572,22 @@\n+\n+UnsafeSetMemoryMark::UnsafeSetMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc) {\n+  _cgen = cgen;\n+  _ucm_entry = nullptr;\n+  if (add_entry) {\n+    address err_exit_pc = nullptr;\n+    if (!continue_at_scope_end) {\n+      err_exit_pc = error_exit_pc != nullptr ? error_exit_pc : UnsafeSetMemory::common_exit_stub_pc();\n+    }\n+    assert(err_exit_pc != nullptr || continue_at_scope_end, \"error exit not set\");\n+    _ucm_entry = UnsafeSetMemory::add_to_table(_cgen->assembler()->pc(), nullptr, err_exit_pc);\n+  }\n+}\n+\n+UnsafeSetMemoryMark::~UnsafeSetMemoryMark() {\n+  if (_ucm_entry != nullptr) {\n+    _ucm_entry->set_end_pc(_cgen->assembler()->pc());\n+    if (_ucm_entry->error_exit_pc() == nullptr) {\n+      _ucm_entry->set_error_exit_pc(_cgen->assembler()->pc());\n+    }\n+  }\n+}\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":54,"deletions":0,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -125,0 +125,46 @@\n+class UnsafeSetMemory : public CHeapObj<mtCode> {\n+ private:\n+  address _start_pc;\n+  address _end_pc;\n+  address _error_exit_pc;\n+ public:\n+  static address           _common_exit_stub_pc;\n+  static UnsafeSetMemory* _table;\n+  static int               _table_length;\n+  static int               _table_max_length;\n+  UnsafeSetMemory() : _start_pc(nullptr), _end_pc(nullptr), _error_exit_pc(nullptr) {}\n+  void    set_start_pc(address pc)      { _start_pc = pc; }\n+  void    set_end_pc(address pc)        { _end_pc = pc; }\n+  void    set_error_exit_pc(address pc) { _error_exit_pc = pc; }\n+  address start_pc()      const { return _start_pc; }\n+  address end_pc()        const { return _end_pc; }\n+  address error_exit_pc() const { return _error_exit_pc; }\n+\n+  static void    set_common_exit_stub_pc(address pc) { _common_exit_stub_pc = pc; }\n+  static address common_exit_stub_pc()               { return _common_exit_stub_pc; }\n+\n+  static UnsafeSetMemory* add_to_table(address start_pc, address end_pc, address error_exit_pc) {\n+    guarantee(_table_length < _table_max_length, \"Incorrect UnsafeSetMemory::_table_max_length\");\n+    UnsafeSetMemory* entry = &_table[_table_length];\n+    entry->set_start_pc(start_pc);\n+    entry->set_end_pc(end_pc);\n+    entry->set_error_exit_pc(error_exit_pc);\n+\n+    _table_length++;\n+    return entry;\n+  }\n+\n+  static bool    contains_pc(address pc);\n+  static address page_error_continue_pc(address pc);\n+  static void    create_table(int max_size);\n+};\n+\n+class UnsafeSetMemoryMark : public StackObj {\n+ private:\n+  UnsafeSetMemory*  _ucm_entry;\n+  StubCodeGenerator* _cgen;\n+ public:\n+  UnsafeSetMemoryMark(StubCodeGenerator* cgen, bool add_entry, bool continue_at_scope_end, address error_exit_pc = nullptr);\n+  ~UnsafeSetMemoryMark();\n+};\n+\n@@ -196,0 +242,2 @@\n+  static address _unsafe_setmemory;\n+\n@@ -384,0 +432,5 @@\n+  static address unsafe_setmemory()     { return _unsafe_setmemory; }\n+\n+  typedef void (*UnsafeSetMemoryStub)(const void* src, size_t count, char byte);\n+  static UnsafeSetMemoryStub UnsafeSetMemory_stub()         { return CAST_TO_FN_PTR(UnsafeSetMemoryStub,  _unsafe_setmemory); }\n+\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":53,"deletions":0,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -214,2 +214,2 @@\n-  address dst = (address) to;\n-  uintptr_t bits = (uintptr_t) to | (uintptr_t) size;\n+  address dst = (address)to;\n+  uintptr_t bits = (uintptr_t)to | (uintptr_t)size;\n@@ -217,1 +217,1 @@\n-    jlong fill = (julong)( (jubyte)value ); \/\/ zero-extend\n+    jlong fill = (julong)((jubyte)value);  \/\/ zero-extend\n@@ -223,1 +223,1 @@\n-    \/\/Copy::fill_to_jlongs_atomic((jlong*) dst, size \/ sizeof(jlong));\n+    \/\/ Copy::fill_to_jlongs_atomic((jlong*) dst, size \/ sizeof(jlong));\n@@ -228,1 +228,1 @@\n-    jint fill = (juint)( (jubyte)value ); \/\/ zero-extend\n+    jint fill = (juint)((jubyte)value);  \/\/ zero-extend\n@@ -233,1 +233,1 @@\n-    \/\/Copy::fill_to_jints_atomic((jint*) dst, size \/ sizeof(jint));\n+    \/\/ Copy::fill_to_jints_atomic((jint*) dst, size \/ sizeof(jint));\n@@ -238,1 +238,1 @@\n-    jshort fill = (jushort)( (jubyte)value ); \/\/ zero-extend\n+    jshort fill = (jushort)((jubyte)value);  \/\/ zero-extend\n@@ -240,1 +240,1 @@\n-    \/\/Copy::fill_to_jshorts_atomic((jshort*) dst, size \/ sizeof(jshort));\n+    \/\/ Copy::fill_to_jshorts_atomic((jshort*) dst, size \/ sizeof(jshort));\n@@ -247,3 +247,4 @@\n-    \/\/ This code is used by Unsafe and may hit the next page after truncation of mapped memory.\n-    \/\/ Therefore, we use volatile to prevent compilers from replacing the loop by memset which\n-    \/\/ may not trigger SIGBUS as needed (observed on Alpine Linux x86_64)\n+    \/\/ This code is used by Unsafe and may hit the next page after truncation\n+    \/\/ of mapped memory. Therefore, we use volatile to prevent compilers from\n+    \/\/ replacing the loop by memset which may not trigger SIGBUS as needed\n+    \/\/ (observed on Alpine Linux x86_64)\n","filename":"src\/hotspot\/share\/utilities\/copy.cpp","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -286,1 +286,1 @@\n-\n+  \n@@ -303,1 +303,0 @@\n-\n","filename":"src\/hotspot\/share\/utilities\/copy.hpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -3827,0 +3827,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/Unsafe.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -210,0 +210,5 @@\n+        \/\/ long seed = 6742745864802755133L;\n+        long seed = random.nextLong();\n+        random.setSeed(seed);\n+        System.out.println(\"Seed set to \"+ seed);\n+\n","filename":"test\/jdk\/sun\/misc\/CopyMemory.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import sun.misc.Unsafe;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Setup;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(org.openjdk.jmh.annotations.Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3, jvmArgsAppend = {\"--enable-native-access=ALL-UNNAMED\"})\n+public class MemorySegmentZeroUnsafe {\n+\n+    static final Unsafe UNSAFE = Utils.unsafe;\n+    long src;\n+\n+    @Param({\"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"15\", \"16\", \"63\", \"64\", \"255\", \"256\"})\n+    public int size;\n+\n+    @Param({\"true\", \"false\"})\n+    public boolean aligned;\n+\n+    private MemorySegment segment;\n+    private long address;\n+\n+    @Setup\n+    public void setup() throws Throwable {\n+        Arena arena = Arena.global();\n+        long alignment = 1;\n+        \/\/ this complex logic is to ensure that if in the future we decide to batch writes with different\n+        \/\/ batches based on alignment, we would spot it here\n+        if (size == 2 || size == 3) {\n+            alignment = 2;\n+        } else if (size >= 4 && size <= 7) {\n+            alignment = 4;\n+        } else {\n+            alignment = 8;\n+        }\n+        if (aligned) {\n+            segment = arena.allocate(size, alignment);\n+        } else {\n+            \/\/ forcibly misaligned in both address AND size, given that would be the worst case\n+            segment = arena.allocate(size + 1, alignment).asSlice(1);\n+        }\n+        address = segment.address();\n+    }\n+\n+    @Benchmark\n+    public void panama() {\n+        segment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void unsafe() {\n+        UNSAFE.setMemory(address, size, (byte) 0);\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/MemorySegmentZeroUnsafe.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}