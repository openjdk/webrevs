{"files":[{"patch":"@@ -2485,0 +2485,85 @@\n+\/\/ Static enum for helper\n+enum USM_TYPE {USM_SHORT, USM_DWORD, USM_QUADWORD};\n+\/\/ Helper for generate_unsafe_setmemory\n+\/\/\n+\/\/ Atomically fill an array of memory using 2-, 4-, or 8-byte chunks\n+static void do_setmemory_atomic_loop(USM_TYPE type, Register dest,\n+                                     Register size, Register wide_value,\n+                                     Register tmp, Label& L_exit,\n+                                     MacroAssembler *_masm) {\n+  Label L_Loop, L_Tail, L_TailLoop;\n+\n+  int shiftval = 0;\n+  int incr = 0;\n+\n+  switch (type) {\n+    case USM_SHORT:\n+      shiftval = 1;\n+      incr = 16;\n+      break;\n+    case USM_DWORD:\n+      shiftval = 2;\n+      incr = 32;\n+      break;\n+    case USM_QUADWORD:\n+      shiftval = 3;\n+      incr = 64;\n+      break;\n+  }\n+\n+  \/\/ At this point, we know the lower bits of size are zero\n+  __ shrq(size, shiftval);\n+  \/\/ size now has number of X-byte chunks (2, 4 or 8)\n+  __ cmpq(size, 8);\n+  __ jccb(Assembler::below, L_Tail);\n+\n+  \/\/ Number of (8*X)-byte chunks into rScratch1\n+  __ movq(tmp, size);\n+  __ shrq(tmp, 3);\n+\n+  __ BIND(L_Loop);\n+\n+  \/\/ Unroll 8 stores\n+  for (int i = 0; i < 8; i++) {\n+    switch (type) {\n+      case USM_SHORT:\n+        __ movw(Address(dest, (2 * i)), wide_value);\n+        break;\n+      case USM_DWORD:\n+        __ movl(Address(dest, (4 * i)), wide_value);\n+        break;\n+      case USM_QUADWORD:\n+        __ movq(Address(dest, (8 * i)), wide_value);\n+        break;\n+    }\n+  }\n+  __ addq(dest, incr);\n+  __ decrementq(tmp);\n+  __ jccb(Assembler::notZero, L_Loop);\n+\n+  __ BIND(L_Tail);\n+\n+  \/\/ Find number of remaining X-byte chunks\n+  __ andq(size, 0x7);\n+\n+  \/\/ If zero, then we're done\n+  __ jccb(Assembler::zero, L_exit);\n+\n+  __ BIND(L_TailLoop);\n+\n+    switch (type) {\n+      case USM_SHORT:\n+        __ movw(Address(dest, 0), wide_value);\n+        break;\n+      case USM_DWORD:\n+        __ movl(Address(dest, 0), wide_value);\n+        break;\n+      case USM_QUADWORD:\n+        __ movq(Address(dest, 0), wide_value);\n+        break;\n+    }\n+  __ addq(dest, incr >> 3);\n+  __ decrementq(size);\n+  __ jccb(Assembler::notZero, L_TailLoop);\n+}\n+\n@@ -2487,1 +2572,1 @@\n-\/\/  size_t argument instead of an element count.\n+\/\/  size_t (# bytes) argument instead of an element count.\n@@ -2497,1 +2582,2 @@\n-address StubGenerator::generate_unsafe_setmemory(const char *name, address unsafe_byte_fill) {\n+address StubGenerator::generate_unsafe_setmemory(const char *name,\n+                                                 address unsafe_byte_fill) {\n@@ -2520,2 +2606,0 @@\n-    const Register rScratch3 = r8;\n-    const Register rScratch4 = r11;\n@@ -2531,0 +2615,5 @@\n+      \/\/ Propagate byte to full Register\n+      __ movzbl(rScratch1, byteVal);\n+      __ mov64(wide_value, 0x0101010101010101);\n+      __ imulq(wide_value, rScratch1);\n+\n@@ -2534,5 +2623,0 @@\n-\n-      \/\/ Propagate byte to full Register\n-      __ movzbl(rScratch3, byteVal);\n-      __ mov64(wide_value, 0x0101010101010101);\n-      __ imulq(wide_value, rScratch3);\n@@ -2541,37 +2625,2 @@\n-    {\n-      const Register rScratch2 = rdx;\n-\n-      __ testb(rScratch1, 7);\n-      __ jcc(Assembler::equal, L_fillQuadwords);\n-\n-      __ testb(rScratch1, 3);\n-      __ jcc(Assembler::equal, L_fillDwords);\n-\n-      __ testb(rScratch1, 1);\n-      __ jcc(Assembler::notEqual, L_fillBytes);\n-\n-      \/\/ Fill words\n-      {\n-        Label L_wordsTail, L_wordsLoop, L_wordsTailLoop;\n-        UnsafeSetMemoryMark usmm(this, true, true);\n-        \/\/\/\/\/\/  Set words\n-        __ leaq(rScratch2, Address(size, 1));\n-        __ movq(rScratch1, rScratch2);\n-        __ shrq(rScratch1, 4);\n-        __ cmpq(rScratch2, 16);\n-        __ jccb(Assembler::below, L_wordsTail);\n-        __ leaq(rScratch3, Address(dest, 14));\n-        __ movq(rScratch4, rScratch1);\n-\n-        __ BIND(L_wordsLoop);\n-\n-        \/\/ Unroll 8 word stores\n-        for (int i = 7; i >= 0; i--) {\n-          __ movw(Address(rScratch3, -(2 * i)), wide_value);\n-        }\n-\n-        __ addq(rScratch3, 16);\n-        __ decrementq(rScratch4);\n-        __ jccb(Assembler::notEqual, L_wordsLoop);\n-\n-        __ BIND(L_wordsTail);\n+    __ testb(rScratch1, 7);\n+    __ jcc(Assembler::equal, L_fillQuadwords);\n@@ -2579,8 +2628,2 @@\n-        \/\/ Handle leftovers\n-        __ shlq(rScratch1, 3);\n-        __ shrq(rScratch2, 1);\n-        __ cmpq(rScratch1, rScratch2);\n-        __ jccb(Assembler::aboveEqual, L_exit);\n-        __ decrementq(size);\n-        __ shrq(size, 1);\n-        __ incrementq(size);\n+    __ testb(rScratch1, 3);\n+    __ jcc(Assembler::equal, L_fillDwords);\n@@ -2588,1 +2631,2 @@\n-        __ BIND(L_wordsTailLoop);\n+    __ testb(rScratch1, 1);\n+    __ jcc(Assembler::notEqual, L_fillBytes);\n@@ -2590,23 +2634,4 @@\n-        __ movw(Address(dest, rScratch1, Address::times_2), wide_value);\n-        __ incrementq(rScratch1);\n-        __ cmpq(size, rScratch1);\n-        __ jccb(Assembler::notEqual, L_wordsTailLoop);\n-      }\n-      __ jmp(L_exit);\n-\n-      __ BIND(L_fillQuadwords);\n-\n-      \/\/ Fill QUADWORDs\n-      {\n-        Label L_qwordLoop, L_qwordsTail, L_qwordsTailLoop;\n-        UnsafeSetMemoryMark usmm(this, true, true);\n-\n-        __ leaq(rScratch2, Address(size, 7));\n-        __ movq(rScratch1, rScratch2);\n-        __ shrq(rScratch1, 6);\n-        __ cmpq(rScratch2, 64);\n-        __ jccb(Assembler::below, L_qwordsTail);\n-        __ leaq(rScratch3, Address(dest, 56));\n-        __ movq(rScratch4, rScratch1);\n-\n-        __ BIND(L_qwordLoop);\n+    \/\/ Fill words\n+    {\n+      Label L_wordsTail, L_wordsLoop, L_wordsTailLoop;\n+      UnsafeSetMemoryMark usmm(this, true, true);\n@@ -2614,27 +2639,6 @@\n-        \/\/ Unroll 8 qword stores\n-        for (int i = 7; i >= 0; i--) {\n-          __ movq(Address(rScratch3, -(8 * i)), wide_value);\n-        }\n-        __ addq(rScratch3, 64);\n-        __ decrementq(rScratch4);\n-        __ jccb(Assembler::notZero, L_qwordLoop);\n-\n-        __ BIND(L_qwordsTail);\n-\n-        \/\/ Handle leftovers\n-        __ shlq(rScratch1, 3);\n-        __ shrq(rScratch2, 3);\n-        __ cmpq(rScratch1, rScratch2);\n-        __ jccb(Assembler::aboveEqual, L_exit);\n-        __ decrementq(size);\n-        __ shrq(size, 3);\n-        __ incrementq(size);\n-\n-        __ BIND(L_qwordsTailLoop);\n-\n-        __ movq(Address(dest, rScratch1, Address::times_8), wide_value);\n-        __ incrementq(rScratch1);\n-        __ cmpq(size, rScratch1);\n-        __ jccb(Assembler::notEqual, L_qwordsTailLoop);\n-      }\n-      __ BIND(L_exit);\n+      \/\/ At this point, we know the lower bit of size is zero and a\n+      \/\/ multiple of 2\n+      do_setmemory_atomic_loop(USM_SHORT, dest, size, wide_value, rScratch1,\n+                               L_exit, _masm);\n+    }\n+    __ jmp(L_exit);\n@@ -2642,2 +2646,1 @@\n-      restore_arg_regs();\n-      __ ret(0);\n+    __ BIND(L_fillQuadwords);\n@@ -2645,1 +2648,4 @@\n-      __ BIND(L_fillDwords);\n+    \/\/ Fill QUADWORDs\n+    {\n+      Label L_qwordLoop, L_qwordsTail, L_qwordsTailLoop;\n+      UnsafeSetMemoryMark usmm(this, true, true);\n@@ -2647,4 +2653,6 @@\n-      \/\/ Fill DWORDs\n-      {\n-        Label L_dwordLoop, L_dwordsTail, L_dwordsTailLoop;\n-        UnsafeSetMemoryMark usmm(this, true, true);\n+      \/\/ At this point, we know the lower 3 bits of size are zero and a\n+      \/\/ multiple of 8\n+      do_setmemory_atomic_loop(USM_QUADWORD, dest, size, wide_value, rScratch1,\n+                               L_exit, _masm);\n+    }\n+    __ BIND(L_exit);\n@@ -2652,7 +2660,2 @@\n-        __ leaq(rScratch2, Address(size, 3));\n-        __ movq(rScratch1, rScratch2);\n-        __ shrq(rScratch1, 5);\n-        __ cmpq(rScratch2, 32);\n-        __ jccb(Assembler::below, L_dwordsTail);\n-        __ leaq(rScratch3, Address(dest, 28));\n-        __ movq(rScratch4, rScratch1);\n+    restore_arg_regs();\n+    __ ret(0);\n@@ -2660,1 +2663,1 @@\n-        __ BIND(L_dwordLoop);\n+    __ BIND(L_fillDwords);\n@@ -2662,27 +2665,4 @@\n-        \/\/ Unroll 8 dword stores\n-        for (int i = 7; i >= 0; i--) {\n-          __ movl(Address(rScratch3, -(i * 4)), wide_value);\n-        }\n-        __ addq(rScratch3, 32);\n-        __ decrementq(rScratch4);\n-        __ jccb(Assembler::notZero, L_dwordLoop);\n-\n-        __ BIND(L_dwordsTail);\n-\n-        \/\/ Handle leftovers\n-        __ shlq(rScratch1, 3);\n-        __ shrq(rScratch2, 2);\n-        __ cmpq(rScratch1, rScratch2);\n-        __ jccb(Assembler::aboveEqual, L_exit);\n-        __ decrementq(size);\n-        __ shrq(size, 2);\n-        __ incrementq(size);\n-\n-        __ BIND(L_dwordsTailLoop);\n-\n-        __ movl(Address(dest, rScratch1, Address::times_4), wide_value);\n-        __ incrementq(rScratch1);\n-        __ cmpq(size, rScratch1);\n-        __ jccb(Assembler::notEqual, L_dwordsTailLoop);\n-      }\n-      __ jmp(L_exit);\n+    \/\/ Fill DWORDs\n+    {\n+      Label L_dwordLoop, L_dwordsTail, L_dwordsTailLoop;\n+      UnsafeSetMemoryMark usmm(this, true, true);\n@@ -2690,1 +2670,4 @@\n-      __ BIND(L_fillBytes);\n+      \/\/ At this point, we know the lower 2 bits of size are zero and a\n+      \/\/ multiple of 4\n+      do_setmemory_atomic_loop(USM_DWORD, dest, size, wide_value, rScratch1,\n+                               L_exit, _masm);\n@@ -2692,0 +2675,3 @@\n+    __ jmp(L_exit);\n+\n+    __ BIND(L_fillBytes);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":134,"deletions":148,"binary":false,"changes":282,"status":"modified"}]}