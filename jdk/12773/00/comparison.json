{"files":[{"patch":"@@ -179,0 +179,4 @@\n+    case StorageType::INTEGER:\n+      assert(to_reg.segment_mask() == REG64_MASK, \"only moves to 64-bit registers supported\");\n+      masm->fmovd(as_Register(to_reg), from_reg);\n+      break;\n","filename":"src\/hotspot\/cpu\/aarch64\/foreignGlobals_aarch64.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64VaList;\n@@ -108,1 +109,1 @@\n-public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, LinuxRISCV64VaList, SharedUtils.EmptyVaList {\n+public sealed interface VaList permits WinVaList, SysVVaList, LinuxAArch64VaList, MacOsAArch64VaList, WindowsAArch64VaList, LinuxRISCV64VaList, SharedUtils.EmptyVaList {\n@@ -303,1 +304,1 @@\n-    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder, LinuxRISCV64VaList.Builder {\n+    sealed interface Builder permits WinVaList.Builder, SysVVaList.Builder, LinuxAArch64VaList.Builder, MacOsAArch64VaList.Builder, WindowsAArch64VaList.Builder, LinuxRISCV64VaList.Builder {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/VaList.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+    WIN_AARCH_64,\n@@ -58,0 +59,2 @@\n+            } else if (OS.startsWith(\"Windows\")) {\n+                ABI = WIN_AARCH_64;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/CABI.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-                case WIN_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n+                case WIN_64, WIN_AARCH_64 -> makeWindowsLookup(); \/\/ out of line to workaround javac crash\n@@ -123,1 +123,1 @@\n-            case WIN_64 -> \"bin\";\n+            case WIN_64, WIN_AARCH_64 -> \"bin\";\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/SystemLookup.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -47,1 +48,1 @@\n-                                                                      SysVx64Linker, Windowsx64Linker, LinuxRISCV64Linker {\n+                                                                      SysVx64Linker, WindowsAArch64Linker, Windowsx64Linker, LinuxRISCV64Linker {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -84,0 +84,5 @@\n+    public boolean isVariadicFunction() {\n+        FirstVariadicArg fva = getOption(FirstVariadicArg.class);\n+        return fva != null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/LinkerOptions.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64Linker;\n@@ -187,0 +188,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.getInstance();\n@@ -300,0 +302,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaList(actions, scope);\n@@ -310,0 +313,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.newVaListOfAddress(address, scope);\n@@ -320,0 +324,1 @@\n+            case WIN_AARCH_64 -> WindowsAArch64Linker.emptyVaList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/SharedUtils.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+import jdk.internal.foreign.abi.aarch64.windows.WindowsAArch64CallArranger;\n@@ -63,1 +64,1 @@\n- * public constants CallArranger.LINUX and CallArranger.MACOS.\n+ * public constants CallArranger.LINUX, CallArranger.MACOS, and CallArranger.WINDOWS.\n@@ -82,1 +83,1 @@\n-    private static final ABIDescriptor C = abiFor(\n+    protected static final ABIDescriptor C = abiFor(\n@@ -101,0 +102,1 @@\n+    public static final CallArranger WINDOWS = new WindowsAArch64CallArranger();\n@@ -115,0 +117,25 @@\n+    \/**\n+     * Are floating point arguments to variadic functions passed in general purpose registers\n+     * instead of floating point registers?\n+     *\n+     * {@return true if this ABI uses general purpose registers for variadic floating point arguments.}\n+     *\/\n+    protected abstract boolean useIntRegsForVariadicFloatingPointArgs();\n+\n+    \/**\n+     * Should some fields of structs that assigned to registers be passed in registers when there\n+     * are not enough registers for all the fields of the struct?\n+     *\n+     * {@return true if this ABI passes some fields of a struct in registers.}\n+     *\/\n+    protected abstract boolean spillsVariadicStructsPartially();\n+\n+    \/**\n+     * @return The ABIDescriptor used by the CallArranger for the current platform.\n+     *\/\n+    protected abstract ABIDescriptor abiDescriptor();\n+\n+    protected TypeClass getArgumentClassForBindings(MemoryLayout layout, boolean forVariadicFunction) {\n+        return TypeClass.classifyLayout(layout);\n+    }\n+\n@@ -122,1 +149,3 @@\n-        CallingSequenceBuilder csb = new CallingSequenceBuilder(C, forUpcall, options);\n+        CallingSequenceBuilder csb = new CallingSequenceBuilder(abiDescriptor(), forUpcall, options);\n+\n+        boolean forVariadicFunction = options.isVariadicFunction();\n@@ -124,2 +153,2 @@\n-        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true);\n-        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false) : new BoxBindingCalculator(false);\n+        BindingCalculator argCalc = forUpcall ? new BoxBindingCalculator(true) : new UnboxBindingCalculator(true, forVariadicFunction);\n+        BindingCalculator retCalc = forUpcall ? new UnboxBindingCalculator(false, forVariadicFunction) : new BoxBindingCalculator(false);\n@@ -152,1 +181,1 @@\n-        MethodHandle handle = new DowncallLinker(C, bindings.callingSequence).getBoundMethodHandle();\n+        MethodHandle handle = new DowncallLinker(abiDescriptor(), bindings.callingSequence).getBoundMethodHandle();\n@@ -168,1 +197,1 @@\n-        return UpcallLinker.make(C, target, bindings.callingSequence, session);\n+        return UpcallLinker.make(abiDescriptor(), target, bindings.callingSequence, session);\n@@ -180,0 +209,1 @@\n+        private final boolean forVariadicFunction;\n@@ -185,1 +215,1 @@\n-        public StorageCalculator(boolean forArguments) {\n+        public StorageCalculator(boolean forArguments, boolean forVariadicFunction) {\n@@ -187,0 +217,1 @@\n+            this.forVariadicFunction = forVariadicFunction;\n@@ -215,0 +246,1 @@\n+                ABIDescriptor abiDescriptor = abiDescriptor();\n@@ -216,1 +248,1 @@\n-                    (forArguments ? C.inputStorage : C.outputStorage)[type];\n+                    (forArguments ? abiDescriptor.inputStorage : abiDescriptor.outputStorage)[type];\n@@ -231,1 +263,19 @@\n-            return regAlloc(type, (int)Utils.alignUp(layout.byteSize(), 8) \/ 8);\n+            boolean spillRegistersPartially = forVariadicFunction && spillsVariadicStructsPartially();\n+\n+            return spillRegistersPartially ?\n+                regAllocPartial(type, layout) :\n+                regAlloc(type, requiredRegisters(layout));\n+        }\n+\n+        int requiredRegisters(MemoryLayout layout) {\n+            return (int)Utils.alignUp(layout.byteSize(), 8) \/ 8;\n+        }\n+\n+        VMStorage[] regAllocPartial(int type, MemoryLayout layout) {\n+            int availableRegisters = MAX_REGISTER_ARGUMENTS - nRegs[type];\n+            if (availableRegisters <= 0) {\n+                return null;\n+            }\n+\n+            int requestRegisters = Math.min(requiredRegisters(layout), availableRegisters);\n+            return regAlloc(type, requestRegisters);\n@@ -235,0 +285,9 @@\n+            if (type == StorageType.VECTOR) {\n+                boolean forVariadicFunctionArgs = forArguments && forVariadicFunction;\n+                boolean useIntRegsForFloatingPointArgs = forVariadicFunctionArgs && useIntRegsForVariadicFloatingPointArgs();\n+\n+                if (useIntRegsForFloatingPointArgs) {\n+                    type = StorageType.INTEGER;\n+                }\n+            }\n+\n@@ -275,2 +334,2 @@\n-        protected BindingCalculator(boolean forArguments) {\n-            this.storageCalculator = new StorageCalculator(forArguments);\n+        protected BindingCalculator(boolean forArguments, boolean forVariadicFunction) {\n+            this.storageCalculator = new StorageCalculator(forArguments, forVariadicFunction);\n@@ -285,1 +344,4 @@\n-            long offset = 0;\n+            spillPartialStructUnbox(bindings, layout, 0);\n+        }\n+\n+        protected void spillPartialStructUnbox(Binding.Builder bindings, MemoryLayout layout, long offset) {\n@@ -337,2 +399,7 @@\n-        UnboxBindingCalculator(boolean forArguments) {\n-            super(forArguments);\n+        protected final boolean forArguments;\n+        protected final boolean forVariadicFunction;\n+\n+        UnboxBindingCalculator(boolean forArguments, boolean forVariadicFunction) {\n+            super(forArguments, forVariadicFunction);\n+            this.forArguments = forArguments;\n+            this.forVariadicFunction = forVariadicFunction;\n@@ -351,1 +418,1 @@\n-            TypeClass argumentClass = TypeClass.classifyLayout(layout);\n+            TypeClass argumentClass = getArgumentClassForBindings(layout, forVariadicFunction);\n@@ -353,0 +420,1 @@\n+\n@@ -356,2 +424,2 @@\n-                    VMStorage[] regs = storageCalculator.regAlloc(\n-                        StorageType.INTEGER, layout);\n+                    VMStorage[] regs = storageCalculator.regAlloc(StorageType.INTEGER, layout);\n+\n@@ -361,1 +429,1 @@\n-                        while (offset < layout.byteSize()) {\n+                        while (offset < layout.byteSize() && regIndex < regs.length) {\n@@ -364,2 +432,1 @@\n-                            boolean useFloat = storage.type() == StorageType.VECTOR;\n-                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, useFloat);\n+                            Class<?> type = SharedUtils.primitiveCarrierForSize(copy, false);\n@@ -373,0 +440,5 @@\n+\n+                        final long bytesLeft = Math.min(layout.byteSize() - offset, 8);\n+                        if (bytesLeft > 0) {\n+                            spillPartialStructUnbox(bindings, layout, offset);\n+                        }\n@@ -438,1 +510,1 @@\n-            super(forArguments);\n+            super(forArguments, false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/CallArranger.java","additions":94,"deletions":22,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.ABIDescriptor;\n@@ -46,0 +47,15 @@\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return C;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/linux\/LinuxAArch64CallArranger.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import jdk.internal.foreign.abi.ABIDescriptor;\n@@ -46,0 +47,15 @@\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return C;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return false;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64CallArranger.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,115 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import jdk.internal.foreign.abi.aarch64.TypeClass;\n+import jdk.internal.foreign.abi.ABIDescriptor;\n+import jdk.internal.foreign.abi.VMStorage;\n+\n+import java.lang.foreign.MemoryLayout;\n+\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+\n+\/**\n+ * AArch64 CallArranger specialized for Windows ABI.\n+ *\/\n+public class WindowsAArch64CallArranger extends CallArranger {\n+\n+    private static final VMStorage INDIRECT_RESULT = r8;\n+\n+    \/\/ This is derived from the AAPCS64 spec, restricted to what's\n+    \/\/ possible when calling to\/from C code.\n+    \/\/\n+    \/\/ The indirect result register, r8, is used to return a large\n+    \/\/ struct by value. It's treated as an input here as the caller is\n+    \/\/ responsible for allocating storage and passing this into the\n+    \/\/ function.\n+    \/\/\n+    \/\/ Although the AAPCS64 says r0-7 and v0-7 are all valid return\n+    \/\/ registers, it's not possible to generate a C function that uses\n+    \/\/ r2-7 and v4-7 so they are omitted here.\n+    private static final ABIDescriptor WindowsAArch64AbiDescriptor = abiFor(\n+        new VMStorage[] { r0, r1, r2, r3, r4, r5, r6, r7, INDIRECT_RESULT},\n+        new VMStorage[] { v0, v1, v2, v3, v4, v5, v6, v7 },\n+        new VMStorage[] { r0, r1 },\n+        new VMStorage[] { v0, v1, v2, v3 },\n+        new VMStorage[] { r9, r10, r11, r12, r13, r14, r15, r16, r17 },\n+        new VMStorage[] { v16, v17, v18, v19, v20, v21, v22, v23, v24, v25,\n+                          v26, v27, v28, v29, v30, v31 },\n+        16,  \/\/ Stack is always 16 byte aligned on AArch64\n+        0,   \/\/ No shadow space\n+        r9,  \/\/ target addr reg\n+        r10  \/\/ return buffer addr reg\n+    );\n+\n+    @Override\n+    protected ABIDescriptor abiDescriptor() {\n+        return WindowsAArch64AbiDescriptor;\n+    }\n+\n+    @Override\n+    protected boolean varArgsOnStack() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean requiresSubSlotStackPacking() {\n+        return false;\n+    }\n+\n+    @Override\n+    protected boolean useIntRegsForVariadicFloatingPointArgs() {\n+        \/\/ The Windows ABI requires floating point arguments to be passed in\n+        \/\/ general purpose registers when calling variadic functions.\n+        return true;\n+    }\n+\n+    @Override\n+    protected boolean spillsVariadicStructsPartially() {\n+        return true;\n+    }\n+\n+    @Override\n+    protected TypeClass getArgumentClassForBindings(MemoryLayout layout, boolean forVariadicFunction) {\n+        TypeClass argumentClass = TypeClass.classifyLayout(layout);\n+\n+        \/\/ HFA struct arguments are classified as STRUCT_REGISTER when\n+        \/\/ general purpose registers are being used to pass floating point\n+        \/\/ arguments. If the HFA is too big to pass entirely in general\n+        \/\/ purpose registers, it is classified as an ordinary struct\n+        \/\/ (i.e. as a STRUCT_REFERENCE).\n+        if (argumentClass == TypeClass.STRUCT_HFA && forVariadicFunction) {\n+            \/\/ The Windows ABI requires the members of the variadic HFA to be\n+            \/\/ passed in general purpose registers but only a STRUCT_HFA that\n+            \/\/ is at most 16 bytes can be passed in general purpose registers.\n+            argumentClass = layout.byteSize() <= 16 ? TypeClass.STRUCT_REGISTER : TypeClass.STRUCT_REFERENCE;\n+        }\n+\n+        return argumentClass;\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64CallArranger.java","additions":115,"deletions":0,"binary":false,"changes":115,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, Arm Limited. All rights reserved.\n+ * Copyright (c) 2021, 2022, Microsoft. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.internal.foreign.abi.aarch64.windows;\n+\n+import jdk.internal.foreign.abi.AbstractLinker;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.SegmentScope;\n+import java.lang.foreign.VaList;\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Consumer;\n+\n+\/**\n+ * ABI implementation for Windows\/AArch64. Based on AAPCS with\n+ * changes to va_list.\n+ *\/\n+public final class WindowsAArch64Linker extends AbstractLinker {\n+    private static WindowsAArch64Linker instance;\n+\n+    public static WindowsAArch64Linker getInstance() {\n+        if (instance == null) {\n+            instance = new WindowsAArch64Linker();\n+        }\n+        return instance;\n+    }\n+\n+    @Override\n+    protected MethodHandle arrangeDowncall(MethodType inferredMethodType, FunctionDescriptor function, LinkerOptions options) {\n+        return CallArranger.WINDOWS.arrangeDowncall(inferredMethodType, function, options);\n+    }\n+\n+    @Override\n+    protected MemorySegment arrangeUpcall(MethodHandle target, MethodType targetType, FunctionDescriptor function, SegmentScope scope) {\n+        return  CallArranger.WINDOWS.arrangeUpcall(target, targetType, function, scope);\n+    }\n+\n+    public static VaList newVaList(Consumer<VaList.Builder> actions, SegmentScope scope) {\n+        WindowsAArch64VaList.Builder builder = WindowsAArch64VaList.builder(scope);\n+        actions.accept(builder);\n+        return builder.build();\n+    }\n+\n+    public static VaList newVaListOfAddress(long address, SegmentScope scope) {\n+        return WindowsAArch64VaList.ofAddress(address, scope);\n+    }\n+\n+    public static VaList emptyVaList() {\n+        return WindowsAArch64VaList.empty();\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64Linker.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -26,1 +26,1 @@\n-package jdk.internal.foreign.abi.aarch64.macos;\n+package jdk.internal.foreign.abi.aarch64.windows;\n@@ -48,6 +48,10 @@\n-\/**\n- * Simplified va_list implementation used on macOS where all variadic\n- * parameters are passed on the stack and the type of va_list decays to\n- * char* instead of the structure defined in the AAPCS.\n- *\/\n-public non-sealed class MacOsAArch64VaList implements VaList {\n+\/\/ see vadefs.h (VC header) for the ARM64 va_arg impl\n+\/\/\n+\/\/    typedef char* va_list;\n+\/\/\n+\/\/    #define __crt_va_arg(ap, t)                                                \\\n+\/\/        ((sizeof(t) > (2 * sizeof(__int64)))                                   \\\n+\/\/            ? **(t**)((ap += sizeof(__int64)) - sizeof(__int64))               \\\n+\/\/            : *(t*)((ap += _SLOTSIZEOF(t) + _APALIGN(t,ap)) - _SLOTSIZEOF(t)))\n+\/\/\n+public non-sealed class WindowsAArch64VaList implements VaList {\n@@ -61,1 +65,1 @@\n-    private MacOsAArch64VaList(MemorySegment segment) {\n+    private WindowsAArch64VaList(MemorySegment segment) {\n@@ -159,1 +163,1 @@\n-    static MacOsAArch64VaList ofAddress(long address, SegmentScope session) {\n+    static WindowsAArch64VaList ofAddress(long address, SegmentScope session) {\n@@ -161,1 +165,1 @@\n-        return new MacOsAArch64VaList(segment);\n+        return new WindowsAArch64VaList(segment);\n@@ -171,1 +175,1 @@\n-        return new MacOsAArch64VaList(segment);\n+        return new WindowsAArch64VaList(segment);\n@@ -243,1 +247,1 @@\n-                            cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n+                            cursor = cursor.copyFrom(msArg.asSlice(0, arg.layout.byteSize()))\n@@ -254,1 +258,1 @@\n-            return new MacOsAArch64VaList(segment);\n+            return new WindowsAArch64VaList(segment);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/windows\/WindowsAArch64VaList.java","additions":17,"deletions":13,"binary":false,"changes":30,"previous_filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/aarch64\/macos\/MacOsAArch64VaList.java","status":"copied"},{"patch":"@@ -35,0 +35,1 @@\n+import java.lang.foreign.GroupLayout;\n@@ -37,0 +38,2 @@\n+import java.lang.foreign.PaddingLayout;\n+import java.lang.foreign.ValueLayout;\n@@ -38,0 +41,1 @@\n+import org.testng.annotations.DataProvider;\n@@ -49,0 +53,1 @@\n+import static org.testng.Assert.*;\n@@ -68,1 +73,1 @@\n-    @Test(dataProvider = \"functions\")\n+    @Test(dataProvider = \"variadicFunctions\")\n@@ -109,0 +114,52 @@\n+    private static List<ParamType> createParameterTypesForStruct(int extraIntArgs) {\n+        List<ParamType> paramTypes = new ArrayList<ParamType>();\n+        for (int i = 0; i < extraIntArgs; i++) {\n+            paramTypes.add(ParamType.INT);\n+        }\n+        paramTypes.add(ParamType.STRUCT);\n+        return paramTypes;\n+    }\n+\n+    private static List<StructFieldType> createFieldsForStruct(int fieldCount, StructFieldType fieldType) {\n+        List<StructFieldType> fields = new ArrayList<StructFieldType>();\n+        for (int i = 0; i < fieldCount; i++) {\n+            fields.add(fieldType);\n+        }\n+        return fields;\n+    }\n+\n+    @DataProvider(name = \"variadicFunctions\")\n+    public static Object[][] variadicFunctions() {\n+        List<Object[]> downcalls = new ArrayList<>();\n+\n+        var functionsDowncalls = functions();\n+        for (var array : functionsDowncalls) {\n+            downcalls.add(array);\n+        }\n+\n+        \/\/ Test struct with 4 floats\n+        int extraIntArgs = 0;\n+        List<StructFieldType> fields = createFieldsForStruct(4, StructFieldType.FLOAT);\n+        List<ParamType> paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        \/\/ Test struct with 4 floats without enough registers for all fields\n+        extraIntArgs = 6;\n+        fields = createFieldsForStruct(4, StructFieldType.FLOAT);\n+        paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        \/\/ Test struct with 2 doubles without enough registers for all fields\n+        extraIntArgs = 7;\n+        fields = createFieldsForStruct(2, StructFieldType.DOUBLE);\n+        paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        \/\/ Test struct with 2 ints without enough registers for all fields\n+        fields = createFieldsForStruct(2, StructFieldType.INT);\n+        paramTypes = createParameterTypesForStruct(extraIntArgs);\n+        downcalls.add(new Object[] { 0, \"\", Ret.VOID, paramTypes, fields });\n+\n+        return downcalls.toArray(new Object[0][]);\n+    }\n+\n@@ -265,0 +322,1 @@\n+            S_FFFF,\n","filename":"test\/jdk\/java\/foreign\/TestVarArgs.java","additions":59,"deletions":1,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -1,649 +0,0 @@\n-\/*\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n- *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- *  This code is free software; you can redistribute it and\/or modify it\n- *  under the terms of the GNU General Public License version 2 only, as\n- *  published by the Free Software Foundation.\n- *\n- *  This code is distributed in the hope that it will be useful, but WITHOUT\n- *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- *  version 2 for more details (a copy is included in the LICENSE file that\n- *  accompanied this code).\n- *\n- *  You should have received a copy of the GNU General Public License version\n- *  2 along with this work; if not, write to the Free Software Foundation,\n- *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- *  or visit www.oracle.com if you need additional information or have any\n- *  questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @enablePreview\n- * @requires sun.arch.data.model == \"64\"\n- * @modules java.base\/jdk.internal.foreign\n- *          java.base\/jdk.internal.foreign.abi\n- *          java.base\/jdk.internal.foreign.abi.aarch64\n- * @build CallArrangerTestBase\n- * @run testng TestAarch64CallArranger\n- *\/\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.MemoryLayout;\n-import java.lang.foreign.StructLayout;\n-import java.lang.foreign.MemorySegment;\n-import jdk.internal.foreign.abi.Binding;\n-import jdk.internal.foreign.abi.CallingSequence;\n-import jdk.internal.foreign.abi.LinkerOptions;\n-import jdk.internal.foreign.abi.StubLocations;\n-import jdk.internal.foreign.abi.VMStorage;\n-import jdk.internal.foreign.abi.aarch64.CallArranger;\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import java.lang.invoke.MethodType;\n-\n-import static java.lang.foreign.Linker.Option.firstVariadicArg;\n-import static java.lang.foreign.ValueLayout.ADDRESS;\n-import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n-import static jdk.internal.foreign.abi.Binding.*;\n-import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n-import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n-\n-import static org.testng.Assert.assertEquals;\n-import static org.testng.Assert.assertFalse;\n-import static org.testng.Assert.assertTrue;\n-\n-public class TestAarch64CallArranger extends CallArrangerTestBase {\n-\n-    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n-    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n-\n-    @Test\n-    public void testEmpty() {\n-        MethodType mt = MethodType.methodType(void.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testInteger() {\n-        MethodType mt = MethodType.methodType(void.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(r2, int.class) },\n-            { vmStore(r3, int.class) },\n-            { vmStore(r4, int.class) },\n-            { vmStore(r5, int.class) },\n-            { vmStore(r6, int.class) },\n-            { vmStore(r7, int.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            { vmStore(stackStorage((short) 4, 8), int.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testTwoIntTwoFloat() {\n-        MethodType mt = MethodType.methodType(void.class,\n-                int.class, int.class, float.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_INT, C_INT, C_FLOAT, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(v0, float.class) },\n-            { vmStore(v1, float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test(dataProvider = \"structs\")\n-    public void testStruct(MemoryLayout struct, Binding[] expectedBindings) {\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            expectedBindings\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @DataProvider\n-    public static Object[][] structs() {\n-        MemoryLayout struct2 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n-        return new Object[][]{\n-            \/\/ struct s { int32_t a, b; double c; };\n-            { MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE), new Binding[] {\n-                dup(),\n-                    \/\/ s.a & s.b\n-                    bufferLoad(0, long.class), vmStore(r0, long.class),\n-                    \/\/ s.c --> note AArch64 passes this in an *integer* register\n-                    bufferLoad(8, long.class), vmStore(r1, long.class),\n-            }},\n-            \/\/ struct s { int32_t a, b; double c; int32_t d };\n-            { struct2, new Binding[] {\n-                copy(struct2),\n-                unboxAddress(),\n-                vmStore(r0, long.class)\n-            }},\n-            \/\/ struct s { int32_t a[2]; float b[2] };\n-            { MemoryLayout.structLayout(C_INT, C_INT, C_FLOAT, C_FLOAT), new Binding[] {\n-                dup(),\n-                    \/\/ s.a[0] & s.a[1]\n-                    bufferLoad(0, long.class), vmStore(r0, long.class),\n-                    \/\/ s.b[0] & s.b[1]\n-                    bufferLoad(8, long.class), vmStore(r1, long.class),\n-            }},\n-            \/\/ struct s { float a; \/* padding *\/ double b };\n-            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n-              new Binding[] {\n-                dup(),\n-                \/\/ s.a\n-                bufferLoad(0, long.class), vmStore(r0, long.class),\n-                \/\/ s.b\n-                bufferLoad(8, long.class), vmStore(r1, long.class),\n-            }},\n-        };\n-    }\n-\n-    @Test\n-    public void testMultipleStructs() {\n-        MemoryLayout struct1 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n-        MemoryLayout struct2 = MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG);\n-\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, int.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct1, struct2, C_INT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            {\n-                copy(struct1),\n-                unboxAddress(),\n-                vmStore(r0, long.class)\n-            },\n-            {\n-                copy(struct2),\n-                unboxAddress(),\n-                vmStore(r1, long.class)\n-            },\n-            { vmStore(r2, int.class) }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testReturnStruct1() {\n-        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG, C_FLOAT);\n-\n-        MethodType mt = MethodType.methodType(MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertTrue(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            {\n-                unboxAddress(),\n-                vmStore(r8, long.class)\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testReturnStruct2() {\n-        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG);\n-\n-        MethodType mt = MethodType.methodType(MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{\n-            allocate(struct),\n-            dup(),\n-            vmLoad(r0, long.class),\n-            bufferStore(0, long.class),\n-            dup(),\n-            vmLoad(r1, long.class),\n-            bufferStore(8, long.class),\n-        });\n-    }\n-\n-    @Test\n-    public void testStructHFA1() {\n-        MemoryLayout hfa = MemoryLayout.structLayout(C_FLOAT, C_FLOAT);\n-\n-        MethodType mt = MethodType.methodType(MemorySegment.class, float.class, int.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.of(hfa, C_FLOAT, C_INT, hfa);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(v0, float.class) },\n-            { vmStore(r0, int.class) },\n-            {\n-                dup(),\n-                bufferLoad(0, float.class),\n-                vmStore(v1, float.class),\n-                bufferLoad(4, float.class),\n-                vmStore(v2, float.class)\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{\n-            allocate(hfa),\n-            dup(),\n-            vmLoad(v0, float.class),\n-            bufferStore(0, float.class),\n-            dup(),\n-            vmLoad(v1, float.class),\n-            bufferStore(4, float.class),\n-        });\n-    }\n-\n-    @Test\n-    public void testStructHFA3() {\n-        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT);\n-\n-        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, struct, struct);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            {\n-                dup(),\n-                bufferLoad(0, float.class),\n-                vmStore(v0, float.class),\n-                dup(),\n-                bufferLoad(4, float.class),\n-                vmStore(v1, float.class),\n-                bufferLoad(8, float.class),\n-                vmStore(v2, float.class)\n-            },\n-            {\n-                dup(),\n-                bufferLoad(0, float.class),\n-                vmStore(v3, float.class),\n-                dup(),\n-                bufferLoad(4, float.class),\n-                vmStore(v4, float.class),\n-                bufferLoad(8, float.class),\n-                vmStore(v5, float.class)\n-            },\n-            {\n-                dup(),\n-                bufferLoad(0, long.class),\n-                vmStore(stackStorage((short) 8, 0), long.class),\n-                bufferLoad(8, int.class),\n-                vmStore(stackStorage((short) 4, 8), int.class),\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testStructStackSpill() {\n-        \/\/ A large (> 16 byte) struct argument that is spilled to the\n-        \/\/ stack should be passed as a pointer to a copy and occupy one\n-        \/\/ stack slot.\n-\n-        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n-\n-        MethodType mt = MethodType.methodType(\n-            void.class, MemorySegment.class, MemorySegment.class, int.class, int.class,\n-            int.class, int.class, int.class, int.class, MemorySegment.class, int.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-            struct, struct, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, struct, C_INT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n-            { copy(struct), unboxAddress(), vmStore(r1, long.class) },\n-            { vmStore(r2, int.class) },\n-            { vmStore(r3, int.class) },\n-            { vmStore(r4, int.class) },\n-            { vmStore(r5, int.class) },\n-            { vmStore(r6, int.class) },\n-            { vmStore(r7, int.class) },\n-            { copy(struct), unboxAddress(), vmStore(stackStorage((short) 8, 0), long.class) },\n-            { vmStore(stackStorage((short) 4, 8), int.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testVarArgsInRegs() {\n-        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n-        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fdExpected);\n-\n-        \/\/ This is identical to the non-variadic calling sequence\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(v0, float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testVarArgsOnStack() {\n-        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n-        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fdExpected);\n-\n-        \/\/ The two variadic arguments should be allocated on the stack\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            { vmStore(stackStorage((short) 4, 8), float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack() {\n-        MethodType mt = MethodType.methodType(void.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class, int.class, int.class,\n-                int.class, int.class, short.class, byte.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT, C_INT, C_INT,\n-                C_INT, C_INT, C_SHORT, C_CHAR);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, int.class) },\n-            { vmStore(r1, int.class) },\n-            { vmStore(r2, int.class) },\n-            { vmStore(r3, int.class) },\n-            { vmStore(r4, int.class) },\n-            { vmStore(r5, int.class) },\n-            { vmStore(r6, int.class) },\n-            { vmStore(r7, int.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            { vmStore(stackStorage((short) 4, 4), int.class) },\n-            { cast(short.class, int.class), vmStore(stackStorage((short) 2, 8), int.class) },\n-            { cast(byte.class, int.class), vmStore(stackStorage((short) 1, 10), int.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack2() {\n-        StructLayout struct = MemoryLayout.structLayout(\n-            C_FLOAT,\n-            C_FLOAT\n-        );\n-        MethodType mt = MethodType.methodType(void.class,\n-                long.class, long.class, long.class, long.class,\n-                long.class, long.class, long.class, long.class,\n-                double.class, double.class, double.class, double.class,\n-                double.class, double.class, double.class, double.class,\n-                int.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_INT, struct);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, long.class) },\n-            { vmStore(r1, long.class) },\n-            { vmStore(r2, long.class) },\n-            { vmStore(r3, long.class) },\n-            { vmStore(r4, long.class) },\n-            { vmStore(r5, long.class) },\n-            { vmStore(r6, long.class) },\n-            { vmStore(r7, long.class) },\n-            { vmStore(v0, double.class) },\n-            { vmStore(v1, double.class) },\n-            { vmStore(v2, double.class) },\n-            { vmStore(v3, double.class) },\n-            { vmStore(v4, double.class) },\n-            { vmStore(v5, double.class) },\n-            { vmStore(v6, double.class) },\n-            { vmStore(v7, double.class) },\n-            { vmStore(stackStorage((short) 4, 0), int.class) },\n-            {\n-                dup(),\n-                bufferLoad(0, int.class),\n-                vmStore(stackStorage((short) 4, 4), int.class),\n-                bufferLoad(4, int.class),\n-                vmStore(stackStorage((short) 4, 8), int.class),\n-            }\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack3() {\n-        StructLayout struct = MemoryLayout.structLayout(\n-            C_POINTER,\n-            C_POINTER\n-        );\n-        MethodType mt = MethodType.methodType(void.class,\n-                long.class, long.class, long.class, long.class,\n-                long.class, long.class, long.class, long.class,\n-                double.class, double.class, double.class, double.class,\n-                double.class, double.class, double.class, double.class,\n-                MemorySegment.class, float.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                struct, C_FLOAT);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, long.class) },\n-            { vmStore(r1, long.class) },\n-            { vmStore(r2, long.class) },\n-            { vmStore(r3, long.class) },\n-            { vmStore(r4, long.class) },\n-            { vmStore(r5, long.class) },\n-            { vmStore(r6, long.class) },\n-            { vmStore(r7, long.class) },\n-            { vmStore(v0, double.class) },\n-            { vmStore(v1, double.class) },\n-            { vmStore(v2, double.class) },\n-            { vmStore(v3, double.class) },\n-            { vmStore(v4, double.class) },\n-            { vmStore(v5, double.class) },\n-            { vmStore(v6, double.class) },\n-            { vmStore(v7, double.class) },\n-            { dup(),\n-                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 0), long.class),\n-                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 8), long.class) },\n-            { vmStore(stackStorage((short) 4, 16), float.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-\n-    @Test\n-    public void testMacArgsOnStack4() {\n-        StructLayout struct = MemoryLayout.structLayout(\n-            C_INT,\n-            C_INT,\n-            C_POINTER\n-        );\n-        MethodType mt = MethodType.methodType(void.class,\n-                long.class, long.class, long.class, long.class,\n-                long.class, long.class, long.class, long.class,\n-                double.class, double.class, double.class, double.class,\n-                double.class, double.class, double.class, double.class,\n-                float.class, MemorySegment.class);\n-        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n-                C_FLOAT, struct);\n-        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n-\n-        assertFalse(bindings.isInMemoryReturn());\n-        CallingSequence callingSequence = bindings.callingSequence();\n-        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n-        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n-\n-        checkArgumentBindings(callingSequence, new Binding[][]{\n-            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n-            { vmStore(r0, long.class) },\n-            { vmStore(r1, long.class) },\n-            { vmStore(r2, long.class) },\n-            { vmStore(r3, long.class) },\n-            { vmStore(r4, long.class) },\n-            { vmStore(r5, long.class) },\n-            { vmStore(r6, long.class) },\n-            { vmStore(r7, long.class) },\n-            { vmStore(v0, double.class) },\n-            { vmStore(v1, double.class) },\n-            { vmStore(v2, double.class) },\n-            { vmStore(v3, double.class) },\n-            { vmStore(v4, double.class) },\n-            { vmStore(v5, double.class) },\n-            { vmStore(v6, double.class) },\n-            { vmStore(v7, double.class) },\n-            { vmStore(stackStorage((short) 4, 0), float.class) },\n-            { dup(),\n-                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 8), long.class),\n-                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 16), long.class) },\n-        });\n-\n-        checkReturnBindings(callingSequence, new Binding[]{});\n-    }\n-}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestAarch64CallArranger.java","additions":0,"deletions":649,"binary":false,"changes":649,"status":"deleted"},{"patch":"@@ -0,0 +1,429 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @requires sun.arch.data.model == \"64\"\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n+ * @build CallArrangerTestBase\n+ * @run testng TestLinuxAArch64CallArranger\n+ *\/\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.MemorySegment;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestLinuxAArch64CallArranger extends CallArrangerTestBase {\n+\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n+\n+    @Test\n+    public void testEmpty() {\n+        MethodType mt = MethodType.methodType(void.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid();\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testInteger() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testTwoIntTwoFloat() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, float.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_FLOAT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(v1, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test(dataProvider = \"structs\")\n+    public void testStruct(MemoryLayout struct, Binding[] expectedBindings) {\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            expectedBindings\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @DataProvider\n+    public static Object[][] structs() {\n+        MemoryLayout struct2 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+        return new Object[][]{\n+            \/\/ struct s { int32_t a, b; double c; };\n+            { MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE), new Binding[] {\n+                dup(),\n+                    \/\/ s.a & s.b\n+                    bufferLoad(0, long.class), vmStore(r0, long.class),\n+                    \/\/ s.c --> note AArch64 passes this in an *integer* register\n+                    bufferLoad(8, long.class), vmStore(r1, long.class),\n+            }},\n+            \/\/ struct s { int32_t a, b; double c; int32_t d };\n+            { struct2, new Binding[] {\n+                copy(struct2),\n+                unboxAddress(),\n+                vmStore(r0, long.class)\n+            }},\n+            \/\/ struct s { int32_t a[2]; float b[2] };\n+            { MemoryLayout.structLayout(C_INT, C_INT, C_FLOAT, C_FLOAT), new Binding[] {\n+                dup(),\n+                    \/\/ s.a[0] & s.a[1]\n+                    bufferLoad(0, long.class), vmStore(r0, long.class),\n+                    \/\/ s.b[0] & s.b[1]\n+                    bufferLoad(8, long.class), vmStore(r1, long.class),\n+            }},\n+            \/\/ struct s { float a; \/* padding *\/ double b };\n+            { MemoryLayout.structLayout(C_FLOAT, MemoryLayout.paddingLayout(32), C_DOUBLE),\n+              new Binding[] {\n+                dup(),\n+                \/\/ s.a\n+                bufferLoad(0, long.class), vmStore(r0, long.class),\n+                \/\/ s.b\n+                bufferLoad(8, long.class), vmStore(r1, long.class),\n+            }},\n+        };\n+    }\n+\n+    @Test\n+    public void testMultipleStructs() {\n+        MemoryLayout struct1 = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+        MemoryLayout struct2 = MemoryLayout.structLayout(C_LONG, C_LONG, C_LONG);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct1, struct2, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                copy(struct1),\n+                unboxAddress(),\n+                vmStore(r0, long.class)\n+            },\n+            {\n+                copy(struct2),\n+                unboxAddress(),\n+                vmStore(r1, long.class)\n+            },\n+            { vmStore(r2, int.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testReturnStruct1() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertTrue(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), FunctionDescriptor.ofVoid(ADDRESS, C_POINTER));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                unboxAddress(),\n+                vmStore(r8, long.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testReturnStruct2() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_LONG, C_LONG);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(struct),\n+            dup(),\n+            vmLoad(r0, long.class),\n+            bufferStore(0, long.class),\n+            dup(),\n+            vmLoad(r1, long.class),\n+            bufferStore(8, long.class),\n+        });\n+    }\n+\n+    @Test\n+    public void testStructHFA1() {\n+        MemoryLayout hfa = MemoryLayout.structLayout(C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(MemorySegment.class, float.class, int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.of(hfa, C_FLOAT, C_INT, hfa);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(RETURN_BUFFER_STORAGE, long.class) },\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(r0, int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(4, float.class),\n+                vmStore(v2, float.class)\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{\n+            allocate(hfa),\n+            dup(),\n+            vmLoad(v0, float.class),\n+            bufferStore(0, float.class),\n+            dup(),\n+            vmLoad(v1, float.class),\n+            bufferStore(4, float.class),\n+        });\n+    }\n+\n+    @Test\n+    public void testStructHFA3() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, MemorySegment.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, struct, struct);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v3, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v4, float.class),\n+                bufferLoad(8, float.class),\n+                vmStore(v5, float.class)\n+            },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(stackStorage((short) 8, 0), long.class),\n+                bufferLoad(8, int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testStructStackSpill() {\n+        \/\/ A large (> 16 byte) struct argument that is spilled to the\n+        \/\/ stack should be passed as a pointer to a copy and occupy one\n+        \/\/ stack slot.\n+\n+        MemoryLayout struct = MemoryLayout.structLayout(C_INT, C_INT, C_DOUBLE, C_INT);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, MemorySegment.class, int.class, int.class,\n+            int.class, int.class, int.class, int.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+            struct, struct, C_INT, C_INT, C_INT, C_INT, C_INT, C_INT, struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r1, long.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { copy(struct), unboxAddress(), vmStore(stackStorage((short) 8, 0), long.class) },\n+            { vmStore(stackStorage((short) 4, 8), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.LINUX.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ This is identical to the non-variadic calling sequence\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestLinuxAArch64CallArranger.java","additions":429,"deletions":0,"binary":false,"changes":429,"status":"added"},{"patch":"@@ -0,0 +1,283 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n+ * @build CallArrangerTestBase\n+ * @run testng TestMacOsAArch64CallArranger\n+ *\/\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.MemorySegment;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestMacOsAArch64CallArranger extends CallArrangerTestBase {\n+\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+\n+    @Test\n+    public void testVarArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        \/\/ The two variadic arguments should be allocated on the stack\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 8), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack() {\n+        MethodType mt = MethodType.methodType(void.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, int.class, int.class,\n+                int.class, int.class, short.class, byte.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_INT, C_INT,\n+                C_INT, C_INT, C_SHORT, C_CHAR);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, int.class) },\n+            { vmStore(r3, int.class) },\n+            { vmStore(r4, int.class) },\n+            { vmStore(r5, int.class) },\n+            { vmStore(r6, int.class) },\n+            { vmStore(r7, int.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            { vmStore(stackStorage((short) 4, 4), int.class) },\n+            { cast(short.class, int.class), vmStore(stackStorage((short) 2, 8), int.class) },\n+            { cast(byte.class, int.class), vmStore(stackStorage((short) 1, 10), int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack2() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_FLOAT,\n+            C_FLOAT\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                int.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_INT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), int.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, int.class),\n+                vmStore(stackStorage((short) 4, 4), int.class),\n+                bufferLoad(4, int.class),\n+                vmStore(stackStorage((short) 4, 8), int.class),\n+            }\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack3() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_POINTER,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                MemorySegment.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                struct, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 0), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 8), long.class) },\n+            { vmStore(stackStorage((short) 4, 16), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testMacArgsOnStack4() {\n+        StructLayout struct = MemoryLayout.structLayout(\n+            C_INT,\n+            C_INT,\n+            C_POINTER\n+        );\n+        MethodType mt = MethodType.methodType(void.class,\n+                long.class, long.class, long.class, long.class,\n+                long.class, long.class, long.class, long.class,\n+                double.class, double.class, double.class, double.class,\n+                double.class, double.class, double.class, double.class,\n+                float.class, MemorySegment.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_LONG_LONG, C_LONG_LONG, C_LONG_LONG, C_LONG_LONG,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_DOUBLE, C_DOUBLE, C_DOUBLE, C_DOUBLE,\n+                C_FLOAT, struct);\n+        CallArranger.Bindings bindings = CallArranger.MACOS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, long.class) },\n+            { vmStore(r1, long.class) },\n+            { vmStore(r2, long.class) },\n+            { vmStore(r3, long.class) },\n+            { vmStore(r4, long.class) },\n+            { vmStore(r5, long.class) },\n+            { vmStore(r6, long.class) },\n+            { vmStore(r7, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(v1, double.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, double.class) },\n+            { vmStore(v4, double.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, double.class) },\n+            { vmStore(v7, double.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { dup(),\n+                bufferLoad(0, long.class), vmStore(stackStorage((short) 8, 8), long.class),\n+                bufferLoad(8, long.class), vmStore(stackStorage((short) 8, 16), long.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestMacOsAArch64CallArranger.java","additions":283,"deletions":0,"binary":false,"changes":283,"status":"added"},{"patch":"@@ -0,0 +1,350 @@\n+\/*\n+ * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+\/*\n+ * @test\n+ * @enablePreview\n+ * @modules java.base\/jdk.internal.foreign\n+ *          java.base\/jdk.internal.foreign.abi\n+ *          java.base\/jdk.internal.foreign.abi.aarch64\n+ * @build CallArrangerTestBase\n+ * @run testng TestWindowsAArch64CallArranger\n+ *\/\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.MemoryLayout;\n+import java.lang.foreign.StructLayout;\n+import java.lang.foreign.MemorySegment;\n+import jdk.internal.foreign.abi.Binding;\n+import jdk.internal.foreign.abi.CallingSequence;\n+import jdk.internal.foreign.abi.LinkerOptions;\n+import jdk.internal.foreign.abi.StubLocations;\n+import jdk.internal.foreign.abi.VMStorage;\n+import jdk.internal.foreign.abi.aarch64.CallArranger;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.lang.invoke.MethodType;\n+\n+import static java.lang.foreign.Linker.Option.firstVariadicArg;\n+import static java.lang.foreign.ValueLayout.ADDRESS;\n+import static jdk.internal.foreign.PlatformLayouts.AArch64.*;\n+import static jdk.internal.foreign.abi.Binding.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.*;\n+import static jdk.internal.foreign.abi.aarch64.AArch64Architecture.Regs.*;\n+import static org.testng.Assert.assertEquals;\n+import static org.testng.Assert.assertFalse;\n+import static org.testng.Assert.assertTrue;\n+\n+public class TestWindowsAArch64CallArranger extends CallArrangerTestBase {\n+\n+    private static final VMStorage TARGET_ADDRESS_STORAGE = StubLocations.TARGET_ADDRESS.storage(StorageType.PLACEHOLDER);\n+    private static final VMStorage RETURN_BUFFER_STORAGE = StubLocations.RETURN_BUFFER.storage(StorageType.PLACEHOLDER);\n+\n+    @Test\n+    public void testWindowsArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class, double.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(v0, float.class) },\n+            { vmStore(v1, double.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVarArgsInRegs() {\n+        MethodType mt = MethodType.methodType(void.class, int.class, int.class, float.class, double.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_INT, C_INT, C_FLOAT, C_DOUBLE);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, float.class) },\n+            { vmStore(r3, double.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsArgsInRegsAndOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, double.class, int.class, float.class,\n+                                              double.class, float.class, float.class, double.class,\n+                                              float.class, float.class, float.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_DOUBLE, C_INT, C_FLOAT,\n+                                              C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE,\n+                                              C_FLOAT, C_FLOAT, C_FLOAT, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(v0, double.class) },\n+            { vmStore(r0, int.class) },\n+            { vmStore(v1, float.class) },\n+            { vmStore(v2, double.class) },\n+            { vmStore(v3, float.class) },\n+            { vmStore(v4, float.class) },\n+            { vmStore(v5, double.class) },\n+            { vmStore(v6, float.class) },\n+            { vmStore(v7, float.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { vmStore(r1, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVarArgsInRegsAndOnStack() {\n+        MethodType mt = MethodType.methodType(void.class, double.class, int.class, float.class,\n+                                              double.class, float.class, float.class, double.class,\n+                                              float.class, float.class, float.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(C_DOUBLE, C_INT, C_FLOAT,\n+                                              C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE,\n+                                              C_FLOAT, C_FLOAT, C_FLOAT);\n+        FunctionDescriptor fdExpected = FunctionDescriptor.ofVoid(ADDRESS, C_DOUBLE, C_INT, C_FLOAT, C_DOUBLE, C_FLOAT, C_FLOAT, C_DOUBLE, C_FLOAT, C_FLOAT, C_FLOAT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(1)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fdExpected);\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { vmStore(r0, double.class) },\n+            { vmStore(r1, int.class) },\n+            { vmStore(r2, float.class) },\n+            { vmStore(r3, double.class) },\n+            { vmStore(r4, float.class) },\n+            { vmStore(r5, float.class) },\n+            { vmStore(r6, double.class) },\n+            { vmStore(r7, float.class) },\n+            { vmStore(stackStorage((short) 4, 0), float.class) },\n+            { vmStore(stackStorage((short) 4, 8), float.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa4FloatsInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, float.class),\n+                vmStore(v0, float.class),\n+                dup(),\n+                bufferLoad(4, float.class),\n+                vmStore(v1, float.class),\n+                dup(),\n+                bufferLoad(8, float.class),\n+                vmStore(v2, float.class),\n+                bufferLoad(12, float.class),\n+                vmStore(v3, float.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa4FloatsInIntRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_FLOAT, C_FLOAT, C_FLOAT, C_FLOAT);\n+\n+        MethodType mt = MethodType.methodType(void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(r0, long.class),\n+                bufferLoad(8, long.class),\n+                vmStore(r1, long.class),\n+            },\n+            { vmStore(r2, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa2DoublesInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, double.class),\n+                vmStore(v0, double.class),\n+                bufferLoad(8, double.class),\n+                vmStore(v1, double.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa2DoublesInIntRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, long.class),\n+                vmStore(r0, long.class),\n+                bufferLoad(8, long.class),\n+                vmStore(r1, long.class),\n+            },\n+            { vmStore(r2, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsHfa3DoublesInFloatRegs() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false);\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            {\n+                dup(),\n+                bufferLoad(0, double.class),\n+                vmStore(v0, double.class),\n+                dup(),\n+                bufferLoad(8, double.class),\n+                vmStore(v1, double.class),\n+                bufferLoad(16, double.class),\n+                vmStore(v2, double.class),\n+            },\n+            { vmStore(r0, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+\n+    @Test\n+    public void testWindowsVariadicHfa3DoublesAsReferenceStruct() {\n+        MemoryLayout struct = MemoryLayout.structLayout(C_DOUBLE, C_DOUBLE, C_DOUBLE);\n+\n+        MethodType mt = MethodType.methodType(\n+            void.class, MemorySegment.class, int.class);\n+        FunctionDescriptor fd = FunctionDescriptor.ofVoid(struct, C_INT);\n+        CallArranger.Bindings bindings = CallArranger.WINDOWS.getBindings(mt, fd, false, LinkerOptions.forDowncall(fd, firstVariadicArg(0)));\n+\n+        assertFalse(bindings.isInMemoryReturn());\n+        CallingSequence callingSequence = bindings.callingSequence();\n+        assertEquals(callingSequence.callerMethodType(), mt.insertParameterTypes(0, MemorySegment.class));\n+        assertEquals(callingSequence.functionDesc(), fd.insertArgumentLayouts(0, ADDRESS));\n+\n+        checkArgumentBindings(callingSequence, new Binding[][]{\n+            { unboxAddress(), vmStore(TARGET_ADDRESS_STORAGE, long.class) },\n+            { copy(struct), unboxAddress(), vmStore(r0, long.class) },\n+            { vmStore(r1, int.class) },\n+        });\n+\n+        checkReturnBindings(callingSequence, new Binding[]{});\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/callarranger\/TestWindowsAArch64CallArranger.java","additions":350,"deletions":0,"binary":false,"changes":350,"status":"added"},{"patch":"@@ -131,0 +131,1 @@\n+    T_S_FFFF,\n@@ -230,0 +231,1 @@\n+            CASE(T_S_FFFF, struct S_FFFF)\n","filename":"test\/jdk\/java\/foreign\/libVarArgs.c","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+struct S_FFFF { float p0; float p1; float p2; float p3; };\n","filename":"test\/jdk\/java\/foreign\/shared.h","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}