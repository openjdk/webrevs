{"files":[{"patch":"@@ -32,0 +32,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -86,0 +87,11 @@\n+\/\/ Iterate over all proxy classes\n+void RunTimeLambdaProxyClassInfo::iterate_klasses(ConstKlassClosure* cl) const {\n+  const Klass* k = proxy_klass_head();\n+  if (k != nullptr && k->lambda_proxy_is_available()) {\n+    while (k != nullptr) {\n+      cl->do_klass(k);\n+      k = k->next_link();\n+    }\n+  }\n+}\n+\n@@ -490,15 +502,8 @@\n-class SharedLambdaDictionaryPrinter : StackObj {\n-  outputStream* _st;\n-  int _index;\n-public:\n-  SharedLambdaDictionaryPrinter(outputStream* st, int idx) : _st(st), _index(idx) {}\n-\n-  void do_value(const RunTimeLambdaProxyClassInfo* record) {\n-    if (record->proxy_klass_head()->lambda_proxy_is_available()) {\n-      ResourceMark rm;\n-      Klass* k = record->proxy_klass_head();\n-      while (k != nullptr) {\n-        _st->print_cr(\"%4d: %s %s\", _index++, k->external_name(),\n-                      SystemDictionaryShared::loader_type_for_shared_class(k));\n-        k = k->next_link();\n-      }\n+\/\/ iterate all klasses of all lambdas\n+void LambdaProxyClassDictionary::iterate_klasses(ConstKlassClosure* cl, bool is_static_archive) {\n+  \/\/ Needed for RunTimeLambdaProxyClassInfo->Klass translation\n+  struct ValueIterator {\n+    ConstKlassClosure* const _cl;\n+    ValueIterator(ConstKlassClosure* cl) : _cl(cl) {}\n+    void do_value(const RunTimeLambdaProxyClassInfo* record) {\n+      record->iterate_klasses(_cl);\n@@ -506,2 +511,1 @@\n-  }\n-};\n+  } vit(cl);\n@@ -509,10 +513,4 @@\n-void LambdaProxyClassDictionary::print_on(const char* prefix,\n-                                          outputStream* st,\n-                                          int start_index,\n-                                          bool is_static_archive) {\n-  LambdaProxyClassDictionary* dictionary = is_static_archive ? &_runtime_static_table : &_runtime_dynamic_table;\n-  if (!dictionary->empty()) {\n-    st->print_cr(\"%sShared Lambda Dictionary\", prefix);\n-    SharedLambdaDictionaryPrinter ldp(st, start_index);\n-    dictionary->iterate(&ldp);\n-  }\n+  const LambdaProxyClassDictionary* const dictionary =\n+      is_static_archive ? &_runtime_static_table : &_runtime_dynamic_table;\n+\n+  dictionary->iterate(&vit);\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.cpp","additions":25,"deletions":27,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+class KlassClosure;\n@@ -249,0 +250,2 @@\n+\n+  void iterate_klasses(ConstKlassClosure* cl) const;\n@@ -330,2 +333,2 @@\n-  static void print_on(const char* prefix, outputStream* st,\n-                       int start_index, bool is_static_archive);\n+  \/\/ iterate all klasses of all lambdas\n+  static void iterate_klasses(ConstKlassClosure* cl, bool is_static_archive);\n","filename":"src\/hotspot\/share\/cds\/lambdaProxyClassDictionary.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,0 +29,3 @@\n+#include \"memory\/iterator.hpp\"\n+#include \"oops\/instanceKlass.hpp\"\n+#include \"oops\/objArrayKlass.hpp\"\n@@ -88,0 +91,12 @@\n+\n+\/\/ Iterate over the klass and all its array classes, in order of dimension\n+void RunTimeClassInfo::iterate_klasses(ConstKlassClosure* c) const {\n+  const InstanceKlass* const ik = klass();\n+  c->do_klass(ik);\n+  for (ObjArrayKlass* oak = ik->array_klasses(); oak != nullptr; oak = oak->higher_dimension()) {\n+    if (oak->is_shared()) {\n+      c->do_klass(oak);\n+    }\n+  }\n+}\n+\n@@ -95,0 +110,13 @@\n+\n+void RunTimeSharedDictionary::iterate_klasses(ConstKlassClosure* cl) const {\n+  \/\/ Needed for RunTimeClassInfo->Klass translation\n+  struct ValueIterator {\n+    ConstKlassClosure* const _cl;\n+    ValueIterator(ConstKlassClosure* cl) : _cl(cl) {}\n+    void do_value(const RunTimeClassInfo* record) {\n+      record->iterate_klasses(_cl);\n+    }\n+  } vit(cl);\n+\n+  iterate(&vit);\n+}\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.cpp","additions":28,"deletions":0,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+class KlassClosure;\n@@ -269,0 +270,3 @@\n+\n+  \/\/ Iterate over the klass and all its array classes, in order of dimension\n+  void iterate_klasses(ConstKlassClosure* c) const;\n@@ -274,1 +278,6 @@\n-  RunTimeClassInfo::EQUALS> {};\n+  RunTimeClassInfo::EQUALS>\n+{\n+public:\n+  \/\/ Iterate over all classes in this dictionary.\n+  void iterate_klasses(ConstKlassClosure* cl) const;\n+};\n","filename":"src\/hotspot\/share\/cds\/runTimeClassInfo.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -58,0 +58,1 @@\n+#include \"memory\/iterator.hpp\"\n@@ -1107,1 +1108,1 @@\n-const char* SystemDictionaryShared::loader_type_for_shared_class(Klass* k) {\n+const char* SystemDictionaryShared::loader_type_for_shared_class(const Klass* k) {\n@@ -1109,3 +1110,2 @@\n-  assert(k->is_shared(), \"Must be\");\n-  assert(k->is_instance_klass(), \"Must be\");\n-  InstanceKlass* ik = InstanceKlass::cast(k);\n+  assert(k->is_shared(), \"Must be (%s)\", k->external_name());\n+  const InstanceKlass* ik = InstanceKlass::cast(k);\n@@ -1125,1 +1125,1 @@\n-class SharedDictionaryPrinter : StackObj {\n+class SharedDictionaryPrinter : public ConstKlassClosure {\n@@ -1128,0 +1128,1 @@\n+  const char* _next_header;\n@@ -1129,1 +1130,2 @@\n-  SharedDictionaryPrinter(outputStream* st) : _st(st), _index(0) {}\n+  SharedDictionaryPrinter(outputStream* st) :\n+    _st(st), _index(0), _next_header(nullptr) {}\n@@ -1131,1 +1133,1 @@\n-  void do_value(const RunTimeClassInfo* record) {\n+  void do_klass(const Klass* k) override {\n@@ -1133,5 +1135,8 @@\n-    _st->print_cr(\"%4d: %s %s\", _index++, record->klass()->external_name(),\n-        SystemDictionaryShared::loader_type_for_shared_class(record->klass()));\n-    if (record->klass()->array_klasses() != nullptr) {\n-      record->klass()->array_klasses()->cds_print_value_on(_st);\n-      _st->cr();\n+    if (k->is_instance_klass()) {\n+      _st->print_cr(\"%4d: %s %s\", _index++, k->external_name(),\n+          SystemDictionaryShared::loader_type_for_shared_class(k));\n+    } else if (k->is_array_klass()) {\n+      _st->print_cr(\"      - array: %s\", k->internal_name());\n+    } else {\n+      \/\/ We should see either IK or OAK; TAKs are instantiated by the JVM.\n+      ShouldNotReachHere();\n@@ -1140,1 +1145,0 @@\n-  int index() const { return _index; }\n@@ -1149,1 +1153,1 @@\n-  _builtin_dictionary.iterate(&p);\n+  _builtin_dictionary.iterate_klasses(&p);\n@@ -1151,2 +1155,8 @@\n-  _unregistered_dictionary.iterate(&p);\n-  LambdaProxyClassDictionary::print_on(prefix, st, p.index(), is_static_archive);\n+  _unregistered_dictionary.iterate_klasses(&p);\n+  st->print_cr(\"%sShared Lambda Dictionary\", prefix);\n+  LambdaProxyClassDictionary::iterate_klasses(&p, is_static_archive);\n+}\n+\n+void SystemDictionaryShared::ArchiveInfo::iterate_klasses(ConstKlassClosure* cl) const {\n+  _builtin_dictionary.iterate_klasses(cl);\n+  _unregistered_dictionary.iterate_klasses(cl);\n@@ -1176,0 +1186,13 @@\n+void SystemDictionaryShared::iterate_klasses_in_shared_archive(ConstKlassClosure* cl, bool is_static) {\n+  if (CDSConfig::is_using_archive()) {\n+    if (is_static) {\n+      _static_archive.iterate_klasses(cl);\n+    } else {\n+      if (DynamicArchive::is_mapped()) {\n+        _dynamic_archive.iterate_klasses(cl);\n+      }\n+    }\n+  }\n+  LambdaProxyClassDictionary::iterate_klasses(cl, is_static);\n+}\n+\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.cpp","additions":39,"deletions":16,"binary":false,"changes":55,"status":"modified"},{"patch":"@@ -115,0 +115,1 @@\n+class KlassClosure;\n@@ -144,0 +145,1 @@\n+    void iterate_klasses(ConstKlassClosure* klassClosure) const;\n@@ -267,1 +269,1 @@\n-  static const char* loader_type_for_shared_class(Klass* k);\n+  static const char* loader_type_for_shared_class(const Klass* k);\n@@ -271,0 +273,1 @@\n+  static void iterate_klasses_in_shared_archive(ConstKlassClosure* klassClosure, bool is_static);\n","filename":"src\/hotspot\/share\/classfile\/systemDictionaryShared.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -144,0 +144,5 @@\n+class ConstKlassClosure : public Closure {\n+ public:\n+  virtual void do_klass(const Klass* k) = 0;\n+};\n+\n","filename":"src\/hotspot\/share\/memory\/iterator.hpp","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -100,0 +100,2 @@\n+    \/\/ While we have the name and an RM, log\n+    log_info(class, load)(\"%s: Created.\", name->as_C_string());\n","filename":"src\/hotspot\/share\/oops\/objArrayKlass.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,58 @@\n+\/*\n+ * Copyright (c) 2025, Red Hat Inc. All rights reserved.\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"classfile\/systemDictionaryShared.hpp\"\n+#include \"memory\/iterator.hpp\"\n+#include \"memory\/metaspace.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"oops\/klass.hpp\"\n+#include \"unittest.hpp\"\n+#include \"testutils.hpp\"\n+\n+\/\/ Test a repeated cycle of sample task works.\n+TEST_VM(SystemDictionaryShared, iterate_klasses) {\n+\n+  if (!CDSConfig::is_using_archive()) {\n+    tty->print_cr(\"Skipping, CDS inactive.\");\n+    return;\n+  }\n+\n+  struct Closure : public ConstKlassClosure {\n+    int _c;\n+    Closure() : _c(0) {}\n+    void do_klass(const Klass* k) override {\n+      ResourceMark rm;\n+      LOG_HERE(\"%s\", k->external_name());\n+      EXPECT_TRUE(k->is_shared()) << k->external_name();\n+      EXPECT_TRUE(Metaspace::is_in_shared_metaspace(k)) << k->external_name();\n+      _c++;\n+    }\n+  } cl_static, cl_dynamic;\n+\n+  SystemDictionaryShared::iterate_klasses_in_shared_archive(&cl_static, true);\n+  ASSERT_GT(cl_static._c, 0);\n+\n+  SystemDictionaryShared::iterate_klasses_in_shared_archive(&cl_static, false);\n+}\n","filename":"test\/hotspot\/gtest\/cds\/test_klass_iteration.cpp","additions":58,"deletions":0,"binary":false,"changes":58,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -703,0 +703,1 @@\n+          output.reportDiagnosticSummary();\n","filename":"test\/lib\/jdk\/test\/lib\/cds\/CDSTestUtils.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"}]}