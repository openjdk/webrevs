{"files":[{"patch":"@@ -57,0 +57,1 @@\n+\n@@ -72,0 +73,5 @@\n+  \/\/ We use this as the time period for tracking minimum mutator utilization (MMU).\n+  if (FLAG_IS_DEFAULT(GCPauseIntervalMillis)) {\n+    FLAG_SET_DEFAULT(GCPauseIntervalMillis, 5000);\n+  }\n+\n@@ -170,0 +176,5 @@\n+\n+  uint active_processors = os::initial_active_processor_count();\n+  GCTimeLimit = (ShenandoahGCTimeLimit * ParallelGCThreads) \/ active_processors;\n+  log_info(gc)(\"GCTimeLimit set to %u based on ShenandoahGCTimeLimit: %u, ParallelGCThreads: %u, active_processors: %u)\",\n+               GCTimeLimit, ShenandoahGCTimeLimit, ParallelGCThreads, active_processors);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahArguments.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -404,0 +404,4 @@\n+  if (!heap->cancelled_gc()) {\n+    ShenandoahMmuTracker* mmu_tracker = heap->mmu_tracker();\n+    mmu_tracker->record_global(get_gc_id());\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahControlThread.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n@@ -52,0 +53,1 @@\n+  heap->mmu_tracker()->record_degenerated(GCId::current());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -102,0 +102,1 @@\n+  ShenandoahHeap* heap = ShenandoahHeap::heap();\n@@ -108,0 +109,1 @@\n+  heap->mmu_tracker()->record_full(GCId::current());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFullGC.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -443,0 +443,3 @@\n+  _gc_historical_utilization = NEW_C_HEAP_ARRAY(double, GCOverheadLimitThreshold, mtGC);\n+  _gc_historical_duration = NEW_C_HEAP_ARRAY(double, GCOverheadLimitThreshold, mtGC);\n+\n@@ -508,0 +511,1 @@\n+  _gc_history_first(0),\n@@ -547,1 +551,1 @@\n-                                                ParallelGCThreads);\n+                                                     ParallelGCThreads);\n@@ -650,0 +654,2 @@\n+  _mmu_tracker.initialize();\n+\n@@ -863,1 +869,21 @@\n-HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest& req) {\n+void ShenandoahHeap::report_gc_utilization(double utilization, double duration) {\n+  _gc_historical_utilization[_gc_history_first] = utilization;\n+  _gc_historical_duration[_gc_history_first] = duration;\n+  _gc_history_first++;\n+  if (_gc_history_first >= GCOverheadLimitThreshold) {\n+    _gc_history_first = 0;\n+  }\n+}\n+\n+bool ShenandoahHeap::gc_overhead_exceeds_limit() {\n+  double weighted_sum = 0.0;\n+  double total_duration = 0.0;\n+  for (uint i = 0; i < GCOverheadLimitThreshold; i++) {\n+    weighted_sum = _gc_historical_utilization[i] * _gc_historical_duration[i];\n+    total_duration += _gc_historical_duration[i];\n+  }\n+  uint weighted_avg = (uint) ((total_duration > 0)? 100 * weighted_sum \/ total_duration: 0.0);\n+  return (weighted_avg > GCTimeLimit);\n+}\n+\n+HeapWord* ShenandoahHeap::allocate_memory(ShenandoahAllocRequest& req, bool* gc_overhead_limit_was_exceeded) {\n@@ -878,12 +904,0 @@\n-    \/\/ Check that gc overhead is not exceeded.\n-    \/\/\n-    \/\/ Shenandoah will grind along for quite a while allocating one\n-    \/\/ object at a time using shared (non-tlab) allocations. This check\n-    \/\/ is testing that the GC overhead limit has not been exceeded.\n-    \/\/ This will notify the collector to start a cycle, but will raise\n-    \/\/ an OOME to the mutator if the last Full GCs have not made progress.\n-    if (result == nullptr && !req.is_lab_alloc() && get_gc_no_progress_count() > ShenandoahNoProgressThreshold) {\n-      control_thread()->handle_alloc_failure(req, false);\n-      return nullptr;\n-    }\n-\n@@ -900,0 +914,5 @@\n+\n+      if (gc_overhead_exceeds_limit()) {\n+        *gc_overhead_limit_was_exceeded = true;\n+        break;\n+      }\n@@ -951,1 +970,1 @@\n-                                        bool*  gc_overhead_limit_was_exceeded) {\n+                                       bool*  gc_overhead_limit_was_exceeded) {\n@@ -953,1 +972,1 @@\n-  return allocate_memory(req);\n+  return allocate_memory(req, gc_overhead_limit_was_exceeded);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":35,"deletions":16,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n@@ -249,0 +250,2 @@\n+  inline ShenandoahMmuTracker* mmu_tracker() { return &_mmu_tracker; };\n+\n@@ -294,0 +297,5 @@\n+  \n+  double* _gc_historical_utilization;\n+  double* _gc_historical_duration;\n+  size_t _gc_history_first;;\n+\n@@ -391,0 +399,2 @@\n+  ShenandoahMmuTracker       _mmu_tracker;\n+\n@@ -525,0 +535,1 @@\n+  bool gc_overhead_exceeds_limit();\n@@ -527,1 +538,1 @@\n-  HeapWord* allocate_memory(ShenandoahAllocRequest& request);\n+  HeapWord* allocate_memory(ShenandoahAllocRequest& request, bool* gc_overhead_limit_was_exceeded = nullptr);\n@@ -546,1 +557,2 @@\n-\n+  void report_gc_utilization(double utilization, double duration);\n+  \n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,157 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+#include \"precompiled.hpp\"\n+\n+#include \"gc\/shenandoah\/shenandoahAsserts.hpp\"\n+#include \"gc\/shenandoah\/shenandoahMmuTracker.hpp\"\n+#include \"gc\/shenandoah\/shenandoahHeap.inline.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/task.hpp\"\n+\n+class ShenandoahMmuTask : public PeriodicTask {\n+  ShenandoahMmuTracker* _mmu_tracker;\n+public:\n+  explicit ShenandoahMmuTask(ShenandoahMmuTracker* mmu_tracker) :\n+    PeriodicTask(GCPauseIntervalMillis), _mmu_tracker(mmu_tracker) {}\n+\n+  void task() override {\n+    _mmu_tracker->report();\n+  }\n+};\n+\n+class ThreadTimeAccumulator : public ThreadClosure {\n+ public:\n+  size_t total_time;\n+  ThreadTimeAccumulator() : total_time(0) {}\n+  void do_thread(Thread* thread) override {\n+    total_time += os::thread_cpu_time(thread);\n+  }\n+};\n+\n+ShenandoahMmuTracker::ShenandoahMmuTracker() :\n+    _most_recent_timestamp(0.0),\n+    _most_recent_gc_time(0.0),\n+    _most_recent_gcu(0.0),\n+    _most_recent_mutator_time(0.0),\n+    _most_recent_mu(0.0),\n+    _most_recent_periodic_time_stamp(0.0),\n+    _most_recent_periodic_gc_time(0.0),\n+    _most_recent_periodic_mutator_time(0.0),\n+    _mmu_periodic_task(new ShenandoahMmuTask(this)) {\n+}\n+\n+ShenandoahMmuTracker::~ShenandoahMmuTracker() {\n+  _mmu_periodic_task->disenroll();\n+  delete _mmu_periodic_task;\n+}\n+\n+void ShenandoahMmuTracker::fetch_cpu_times(double &gc_time, double &mutator_time) {\n+  ThreadTimeAccumulator cl;\n+  \/\/ We include only the gc threads because those are the only threads\n+  \/\/ we are responsible for.\n+  ShenandoahHeap::heap()->gc_threads_do(&cl);\n+  double most_recent_gc_thread_time = double(cl.total_time) \/ NANOSECS_PER_SEC;\n+  gc_time = most_recent_gc_thread_time;\n+\n+  double process_real_time(0.0), process_user_time(0.0), process_system_time(0.0);\n+  bool valid = os::getTimesSecs(&process_real_time, &process_user_time, &process_system_time);\n+  assert(valid, \"sanity\");\n+  mutator_time =(process_user_time + process_system_time) - most_recent_gc_thread_time;\n+}\n+\n+void ShenandoahMmuTracker::update_utilization(size_t gcid, const char* msg) {\n+  double current = os::elapsedTime();\n+  _most_recent_gcid = gcid;\n+  _most_recent_is_full = false;\n+\n+  if (gcid == 0) {\n+    fetch_cpu_times(_most_recent_gc_time, _most_recent_mutator_time);\n+\n+    _most_recent_timestamp = current;\n+  } else {\n+    double gc_cycle_period = current - _most_recent_timestamp;\n+    _most_recent_timestamp = current;\n+\n+    double gc_thread_time, mutator_thread_time;\n+    fetch_cpu_times(gc_thread_time, mutator_thread_time);\n+    double gc_time = gc_thread_time - _most_recent_gc_time;\n+    _most_recent_gc_time = gc_thread_time;\n+    _most_recent_gcu = gc_time \/ (_active_processors * gc_cycle_period);\n+    double mutator_time = mutator_thread_time - _most_recent_mutator_time;\n+    _most_recent_mutator_time = mutator_thread_time;\n+    _most_recent_mu = mutator_time \/ (_active_processors * gc_cycle_period);\n+    ShenandoahHeap::heap()->report_gc_utilization(_most_recent_gcu, gc_cycle_period);\n+    log_info(gc, ergo)(\"At end of %s: GCU: %.1f%%, MU: %.1f%% during period of %.3fs\",\n+                       msg, _most_recent_gcu * 100, _most_recent_mu * 100, gc_cycle_period);\n+  }\n+}\n+\n+void ShenandoahMmuTracker::record_global(size_t gcid) {\n+  update_utilization(gcid, \"Concurrent Global GC\");\n+}\n+\n+void ShenandoahMmuTracker::record_degenerated(size_t gcid) {\n+  if ((gcid == _most_recent_gcid) && _most_recent_is_full) {\n+    \/\/ Do nothing.  This is a redundant recording for the full gc that just completed.\n+    \/\/ TODO: avoid making the call to record_degenerated() in the case that this degenerated upgraded to full gc.\n+  } else {\n+    update_utilization(gcid, \"Degenerated Global GC\");\n+  }\n+}\n+\n+void ShenandoahMmuTracker::record_full(size_t gcid) {\n+  update_utilization(gcid, \"Full GC\");\n+  _most_recent_is_full = true;\n+}\n+\n+void ShenandoahMmuTracker::report() {\n+  \/\/ This is only called by the periodic thread.\n+  double current = os::elapsedTime();\n+  double time_delta = current - _most_recent_periodic_time_stamp;\n+  _most_recent_periodic_time_stamp = current;\n+\n+  double gc_time, mutator_time;\n+  fetch_cpu_times(gc_time, mutator_time);\n+\n+  double gc_delta = gc_time - _most_recent_periodic_gc_time;\n+  _most_recent_periodic_gc_time = gc_time;\n+\n+  double mutator_delta = mutator_time - _most_recent_periodic_mutator_time;\n+  _most_recent_periodic_mutator_time = mutator_time;\n+\n+  double mu = mutator_delta \/ (_active_processors * time_delta);\n+  double gcu = gc_delta \/ (_active_processors * time_delta);\n+  log_info(gc)(\"Periodic Sample: GCU = %.3f%%, MU = %.3f%% during most recent %.1fs\", gcu * 100, mu * 100, time_delta);\n+}\n+\n+void ShenandoahMmuTracker::initialize() {\n+  \/\/ initialize static data\n+  _active_processors = os::initial_active_processor_count();\n+\n+  _most_recent_periodic_time_stamp = os::elapsedTime();\n+  fetch_cpu_times(_most_recent_periodic_gc_time, _most_recent_periodic_mutator_time);\n+  _mmu_periodic_task->enroll();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.cpp","additions":157,"deletions":0,"binary":false,"changes":157,"status":"added"},{"patch":"@@ -0,0 +1,94 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+#define SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n+\n+#include \"runtime\/mutex.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+\n+class ShenandoahMmuTask;\n+\n+\/**\n+ * This class is responsible for tracking the (minimum) mutator\n+ * utilization (MMU). MMU is defined as the percentage of CPU time available\n+ * to mutator threads over an arbitrary fixed interval of time. This interval\n+ * defaults to 5 seconds and is configured by GCPauseIntervalMillis.  MMU is\n+ * measured by summing all of the time given to the GC threads and comparing\n+ * this to the total CPU time for the process. There are OS APIs to support\n+ * this on all major platforms.\n+ *\/\n+class ShenandoahMmuTracker {\n+private:\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for calculating\n+  \/\/ CPU time consumed by GC and mutator threads during each GC cycle.\n+  double _most_recent_timestamp;\n+  double _most_recent_gc_time;\n+  double _most_recent_gcu;\n+  double _most_recent_mutator_time;\n+  double _most_recent_mu;\n+\n+  \/\/ These variables hold recent snapshots of cumulative quantities that are used for reporting\n+  \/\/ periodic consumption of CPU time by GC and mutator threads.\n+  double _most_recent_periodic_time_stamp;\n+  double _most_recent_periodic_gc_time;\n+  double _most_recent_periodic_mutator_time;\n+\n+  size_t _most_recent_gcid;\n+  uint _active_processors;\n+\n+  bool _most_recent_is_full;\n+\n+  ShenandoahMmuTask* _mmu_periodic_task;\n+  TruncatedSeq _mmu_average;\n+\n+  void update_utilization(size_t gcid, const char* msg);\n+  static void fetch_cpu_times(double &gc_time, double &mutator_time);\n+\n+public:\n+  explicit ShenandoahMmuTracker();\n+  ~ShenandoahMmuTracker();\n+\n+  \/\/ This enrolls the periodic task after everything is initialized.\n+  void initialize();\n+\n+  \/\/ At completion of each GC cycle (not including interrupted cycles), we invoke one of the following to record the\n+  \/\/ GC utilization during this cycle.  Incremental efforts spent in an interrupted GC cycle will be accumulated into\n+  \/\/ the CPU time reports for the subsequent completed [degenerated or full] GC cycle.\n+  \/\/\n+  \/\/ We may redundantly record degen and full in the case that a degen upgrades to full.  When this happens, we will invoke\n+  \/\/ both record_full() and record_degenerated() with the same value of gcid.  record_full() is called first and the log\n+  \/\/ reports such a cycle as a FULL cycle.\n+  void record_global(size_t gcid);\n+  void record_full(size_t gcid);\n+  void record_degenerated(size_t gcid);\n+\n+  \/\/ This is called by the periodic task timer. The interval is defined by\n+  \/\/ GCPauseIntervalMillis and defaults to 5 seconds. This method computes\n+  \/\/ the MMU over the elapsed interval and records it in a running average.\n+  void report();\n+};\n+\n+\n+#endif \/\/SHARE_GC_SHENANDOAH_SHENANDOAHMMUTRACKER_HPP\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMmuTracker.hpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"added"},{"patch":"@@ -336,0 +336,8 @@\n+                                                                            \\\n+  product(uint, ShenandoahGCTimeLimit, 75, EXPERIMENTAL,                    \\\n+          \"The percentage of CPU consumed by GC at which GC considers \"     \\\n+          \"itself to have exceeded the reasonable threshold.  This \"        \\\n+          \"replaces GCTimeLimit.  The denominator is calculated from \"      \\\n+          \"authorized ParallelGCThreads as a fraction of total available \"  \\\n+          \"CPU cores.\")                                                     \\\n+          range(0, 100)                                                     \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}