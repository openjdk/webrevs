{"files":[{"patch":"@@ -110,2 +110,3 @@\n-                                                      Deoptimization::DeoptReason reason,\n-                                                      int opcode, bool if_cont_is_true_proj) {\n+                                                      Deoptimization::DeoptReason reason, int opcode,\n+                                                      bool if_cont_is_true_proj, Node_List* old_new,\n+                                                      UnswitchingAction unswitching_action) {\n@@ -196,1 +197,17 @@\n-      use->add_req(use->in(proj_index));\n+      Node* phi_input = use->in(proj_index);\n+      if (unswitching_action == UnswitchingAction::FastLoopCloning\n+          && !phi_input->is_CFG() && !phi_input->is_Phi() && get_ctrl(phi_input) == uncommon_proj) {\n+        \/\/ There are some control dependent nodes on the uncommon projection and we are currently copying predicates\n+        \/\/ to the fast loop in loop unswitching (first step, slow loop is processed afterwards). For the fast loop,\n+        \/\/ we need to clone all the data nodes in the chain from the phi ('use') up until the node whose control input\n+        \/\/ is the uncommon_proj. The slow loop can reuse the old data nodes and thus only needs to update the control\n+        \/\/ input to the uncommon_proj (done on the next invocation of this method when 'unswitch_is_slow_loop' is true.\n+        assert(LoopUnswitching, \"sanity check\");\n+        phi_input = clone_data_nodes_for_fast_loop(phi_input, uncommon_proj, if_uct, old_new);\n+      } else if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n+        \/\/ Replace phi input for the old predicate path with TOP as the predicate is dying anyways. This avoids the need\n+        \/\/ to clone the data nodes again for the slow loop.\n+        assert(LoopUnswitching, \"sanity check\");\n+        _igvn.replace_input_of(use, proj_index, C->top());\n+      }\n+      use->add_req(phi_input);\n@@ -201,0 +218,13 @@\n+  if (unswitching_action == UnswitchingAction::SlowLoopRewiring) {\n+    \/\/ Rewire the control dependent data nodes for the slow loop from the old to the new uncommon projection.\n+    assert(uncommon_proj->outcnt() > 1 && old_new == NULL, \"sanity\");\n+    for (DUIterator_Fast jmax, j = uncommon_proj->fast_outs(jmax); j < jmax; j++) {\n+      Node* data = uncommon_proj->fast_out(j);\n+      if (!data->is_CFG()) {\n+        _igvn.replace_input_of(data, 0, if_uct);\n+        set_ctrl(data, if_uct);\n+        --j;\n+        --jmax;\n+      }\n+    }\n+  }\n@@ -212,0 +242,51 @@\n+\/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate. Returns the node which is\n+\/\/ used for the uncommon trap phi input.\n+Node* PhaseIdealLoop::clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new) {\n+  \/\/ Step 1: Clone all nodes on the data chain but do not rewire anything, yet. Keep track of the cloned nodes\n+  \/\/ by using the old_new mapping. This mapping is then used in step 2 to rewire the cloned nodes accordingly.\n+  DEBUG_ONLY(uint last_idx = C->unique();)\n+  Unique_Node_List list;\n+  list.push(phi_input);\n+  for (uint j = 0; j < list.size(); j++) {\n+    Node* next = list.at(j);\n+    Node* clone = next->clone();\n+    _igvn.register_new_node_with_optimizer(clone);\n+    old_new->map(next->_idx, clone);\n+    for (uint k = 1; k < next->req(); k++) {\n+      Node* in = next->in(k);\n+      if (!in->is_Phi() && get_ctrl(in) == uncommon_proj) {\n+        list.push(in);\n+      }\n+    }\n+  }\n+\n+  \/\/ Step 2: All nodes are cloned. Rewire them by using the old_new mapping.\n+  for (uint j = 0; j < list.size(); j++) {\n+    Node* next = list.at(j);\n+    Node* clone = old_new->at(next->_idx);\n+    assert(clone != NULL && clone->_idx >= last_idx, \"must exist and be a proper clone\");\n+    if (next->in(0) == uncommon_proj) {\n+      \/\/ All data nodes with a control input to the uncommon projection in the chain need to be rewired to the new uncommon\n+      \/\/ projection (could not only be the last data node in the chain but also, for example, a DivNode within the chain).\n+      _igvn.replace_input_of(clone, 0, if_uct);\n+      set_ctrl(clone, if_uct);\n+    }\n+\n+    \/\/ Rewire the inputs of the cloned nodes to the old nodes to the new clones.\n+    for (uint k = 1; k < next->req(); k++) {\n+      Node* in = next->in(k);\n+      if (!in->is_Phi()) {\n+        assert(!in->is_CFG(), \"must be data node\");\n+        Node* in_clone = old_new->at(in->_idx);\n+        if (in_clone != NULL) {\n+          assert(in_clone->_idx >= last_idx, \"must be a valid clone\");\n+          _igvn.replace_input_of(clone, k, in_clone);\n+          set_ctrl(clone, if_uct);\n+        }\n+      }\n+    }\n+  }\n+  Node* clone_phi_input = old_new->at(phi_input->_idx);\n+  assert(clone_phi_input != NULL && clone_phi_input->_idx >= last_idx, \"must exist and be a proper clone\");\n+  return clone_phi_input;\n+}\n@@ -213,2 +294,12 @@\n-ProjNode* PhaseIdealLoop::clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason) {\n-  ProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If);\n+ProjNode* PhaseIdealLoop::clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry,\n+                                                             Deoptimization::DeoptReason reason, Node_List* old_new) {\n+  UnswitchingAction unswitching_action;\n+  if (predicate_proj->other_if_proj()->outcnt() > 1) {\n+    \/\/ There are some data dependencies that need to be taken care of when cloning a predicate.\n+    unswitching_action = old_new == NULL ? UnswitchingAction::SlowLoopRewiring : UnswitchingAction::FastLoopCloning;\n+  } else {\n+    unswitching_action = UnswitchingAction::None;\n+  }\n+\n+  ProjNode* new_predicate_proj = create_new_if_for_predicate(predicate_proj, new_entry, reason, Op_If,\n+                                                             true, old_new, unswitching_action);\n@@ -322,1 +413,1 @@\n-void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred) {\n+void PhaseIdealLoop::clone_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred) {\n@@ -346,1 +437,1 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(predicate_proj, iffast_pred, Deoptimization::Reason_predicate, &old_new);\n@@ -355,1 +446,1 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate);\n+    iffast_pred = clone_predicate_to_unswitched_loop(profile_predicate_proj, iffast_pred, Deoptimization::Reason_profile_predicate, &old_new);\n@@ -366,1 +457,1 @@\n-    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check);\n+    iffast_pred = clone_predicate_to_unswitched_loop(limit_check_proj, iffast_pred, Deoptimization::Reason_loop_limit_check, &old_new);\n@@ -375,1 +466,1 @@\n-void PhaseIdealLoop::check_created_predicate_for_unswitching(const Node* new_entry) const {\n+void PhaseIdealLoop::check_created_predicate_for_unswitching(const Node* new_entry) {\n","filename":"src\/hotspot\/share\/opto\/loopPredicate.cpp","additions":101,"deletions":10,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -1278,0 +1278,7 @@\n+  \/\/ Enum to determine the action to be performed in create_new_if_for_predicate() when processing phis of UCT regions.\n+  enum class UnswitchingAction {\n+    None,            \/\/ No special action.\n+    FastLoopCloning, \/\/ Need to clone nodes for the fast loop.\n+    SlowLoopRewiring \/\/ Need to rewire nodes for the slow loop.\n+  };\n+\n@@ -1280,1 +1287,5 @@\n-                                        int opcode, bool if_cont_is_true_proj = true);\n+                                        int opcode, bool if_cont_is_true_proj = true, Node_List* old_new = NULL,\n+                                        UnswitchingAction unswitching_action = UnswitchingAction::None);\n+\n+  \/\/ Clone data nodes for the fast loop while creating a new If with create_new_if_for_predicate.\n+  Node* clone_data_nodes_for_fast_loop(Node* phi_input, ProjNode* uncommon_proj, Node* if_uct, Node_List* old_new);\n@@ -1566,2 +1577,3 @@\n-  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, const Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred);\n-  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason);\n+  void clone_predicates_to_unswitched_loop(IdealLoopTree* loop, Node_List& old_new, ProjNode*& iffast_pred, ProjNode*& ifslow_pred);\n+  ProjNode* clone_predicate_to_unswitched_loop(ProjNode* predicate_proj, Node* new_entry, Deoptimization::DeoptReason reason,\n+                                               Node_List* old_new = NULL);\n@@ -1572,1 +1584,1 @@\n-  void check_created_predicate_for_unswitching(const Node* new_entry) const PRODUCT_RETURN;\n+  static void check_created_predicate_for_unswitching(const Node* new_entry) PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8271954\n+ * @requires vm.compiler2.enabled\n+ * @summary A pinned Cast node on the UCT projection of a predicate is as input for the UCT phi node for the original\n+ *          loop, the fast and slow loop resulting in a dominance failure. These data nodes need to be updated while\n+ *          unswitching a loop.\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileCommand=compileonly,compiler.loopopts.TestUnswitchWithSunkNodes::test*\n+ *                   compiler.loopopts.TestUnswitchWithSunkNodes\n+ *\/\n+\n+package compiler.loopopts;\n+\n+public class TestUnswitchWithSunkNodes {\n+    static int iFld, iFld2, iFld3 = 1, iFld4 = 1;\n+    static long instanceCount;\n+    static double dFld;\n+    static boolean bFld;\n+    static int iArrFld[] = new int[10];\n+\n+    static {\n+        init(iArrFld);\n+    }\n+\n+    public static void main(String[] strArr) {\n+        \/\/ The testcases with Divisions have additional control inputs which need to be taken care of\n+        testNoDiamond();\n+        testNoDiamondDiv();\n+        testWithDiamond();\n+        testWithDiamondDiv1();\n+        testWithDiamondDiv2();\n+        testWithDiamondOneLongOneShortPath();\n+        testWithDiamondComplex();\n+        testWithDiamondComplexDiv();\n+    }\n+\n+    static void testNoDiamond() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    i2 = (((i2 + 3) + iFld2) + iFld3) - iFld4;\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testNoDiamondDiv() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    i2 = (((i2 + 3) + iFld2) + iFld3) \/ iFld4;\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamond() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    double d1 = (double) i2;\n+                    i2 = (int)((d1 + iFld4) - (d1 + iFld));\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondDiv1() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    i2 = (i2 \/ iFld4) - (i2 \/ iFld3);\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondDiv2() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    int i3 = (int)d;\n+                    i2 = (i3 \/ iFld4) - (i3 \/ iFld3);\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondOneLongOneShortPath() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    double d1 = (double)i2;\n+                    i2 = (int)((d1 + 3 + iFld2 + iFld3 + iFld4) - (d1 + iFld));\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondComplex() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    i2 += 4;\n+                    float l = (float)i2;\n+                    i2 = (int)((l + 3) - (l + iFld));\n+                    double d1 = (double)i2;\n+                    i2 = (int)((d1 + 3) - (d1 + iFld) - (d1 * iFld2));\n+                    i2 = (int)((l + 3) - (l + iFld) - (l * iFld2) + (d1 - iFld2) + (d1 \/ iFld3));\n+                    d1 = (double)i2;\n+                    i2 = (int)((d1 + 3) - (d1 + iFld) - (d1 * iFld2) + (d1 - iFld2) + (d1 \/ iFld3));\n+                    i2 += dFld;\n+                    l = (float)i2;\n+                    i2 = (int)((l + 3) - (l + iFld) - (l * iFld2) + (d1 - iFld2) + (d1 \/ iFld3) - (d1 + iFld) - (d1 * iFld2) + (d1 - iFld2) + (d1 \/ iFld3));\n+                    d1 = (double)i2;\n+                    i2 = (int)((d1 + 3) - (d1 + iFld) - (d1 * iFld2) + (d1 - iFld2) + (d1 \/ iFld3) + (d1 + 3) - (d1 + iFld) - (d1 * iFld2) + (d1 - iFld2) + (d1 \/ iFld3));\n+                    d1 = (double) i2;\n+                    i2 = (int) ((d1 + 3 + iFld2 + iFld3 + iFld4) - (d1 + iFld));\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    static void testWithDiamondComplexDiv() {\n+        int i, i2 = 10, i21, i22, i24, i26 = 41724, iArr2[] = new int[10];\n+        double d;\n+        float f2;\n+        init(iArr2);\n+        i = 1;\n+        while (++i < 219) {\n+            for (d = 15; 305 > d; ++d) {\n+                if (bFld) {\n+                    instanceCount = i2;\n+                    int i3 = (int)d;\n+                    i2 = (i3 \/ iFld4) - (i3 \/ iFld3);\n+                    double d1 = (double) i2;\n+                    i3 = (int)((d1 + iFld4) - (d1 + iFld));\n+                    i2 = (i3 \/ iFld4) - (i3 \/ iFld3);\n+                }\n+                for (f2 = 5; 87 > f2; ++f2) {\n+                    i2 = (int) instanceCount;\n+                    for (i22 = 1; 2 > i22; i22++) {\n+                        if (bFld) {\n+                            iArr2[1] += 190L;\n+                        }\n+                    }\n+                    for (i24 = 1; 2 > i24; i24++) {\n+                        switch (i) {\n+                            case 88:\n+                                i26 += (i24);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public static void init(int[] a) {\n+        for (int j = 0; j < a.length; j++) {\n+            a[j] = j;\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestUnswitchWithSunkNodes.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"}]}