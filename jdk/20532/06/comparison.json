{"files":[{"patch":"@@ -0,0 +1,321 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8338103\n+ * @key headful\n+ * @summary Verifies that the OpenGL pipeline does not create artifacts\n+ * with swing components after window is zoomed to maximum size and then\n+ * resized back to normal. The test case simulates this operation using\n+ * a JButton. A file image of the component will be saved before and after\n+ * window resize. The test passes if both button images are the same.\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=true SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.d3d=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.d3d=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.xrender=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.xrender=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.metal=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.metal=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+public class SwingButtonResizeTestWithOpenGL {\n+    private static Robot robot;\n+    private static CountDownLatch focusGainedLatch;\n+    private JFrame frame;\n+    private JButton button;\n+\n+    public SwingButtonResizeTestWithOpenGL() {\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> createGUI());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems creating GUI\");\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"SwingButtonResizeTestWithOpenGL\");\n+        button = new JButton(\"Button A\");\n+        frame.setLocation(200, 200);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        button.setPreferredSize(new Dimension(300, 300));\n+        button.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                focusGainedLatch.countDown();\n+            }\n+        });\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.getContentPane().add(button);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.toFront();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        focusGainedLatch = new CountDownLatch(1);\n+        SwingButtonResizeTestWithOpenGL test = new SwingButtonResizeTestWithOpenGL();\n+        test.runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        BufferedImage bimage1;\n+        BufferedImage bimage2;\n+\n+        try {\n+            robot = new Robot();\n+            robot.setAutoWaitForIdle(true);\n+            robot.setAutoDelay(200);\n+\n+            if (focusGainedLatch.await(3, TimeUnit.SECONDS)) {\n+                System.out.println(\"Button focus gained...\");\n+            } else {\n+                System.out.println(\"Button focus not gained...\");\n+                throw new RuntimeException(\"Can't gain focus on button even after waiting too long..\");\n+            }\n+\n+            System.out.println(\"Getting initial button image..image1\");\n+            bimage1 = getButtonImage();\n+\n+            \/\/ some platforms may not support maximize frame\n+            if (frame.getToolkit().isFrameStateSupported(JFrame.MAXIMIZED_BOTH)) {\n+                robot.waitForIdle();\n+                \/\/ maximize frame from normal size\n+                frame.setExtendedState(JFrame.MAXIMIZED_BOTH);\n+                System.out.println(\"Frame is maximized\");\n+                robot.waitForIdle();\n+\n+                if (frame.getToolkit().isFrameStateSupported(JFrame.NORMAL)) {\n+                    System.out.println(\"Frame is back to normal\");\n+                    \/\/ resize from maximum size to normal\n+                    frame.setExtendedState(JFrame.NORMAL);\n+\n+                    \/\/ capture image of JButton after resize\n+                    System.out.println(\"Getting image of JButton after resize..image2\");\n+                    bimage2 = getButtonImage();\n+\n+                    \/\/ compare button images from before and after frame resize\n+                    DiffImage di = new DiffImage(bimage1.getWidth(), bimage1.getHeight());\n+                    System.out.println(\"Taking the diff of two images, image1 and image2\");\n+                    if (!di.compare(bimage1, bimage2)) {\n+                        throw new RuntimeException(\"Button renderings are different after window resize, num of Diff Pixels=\" + di.getNumDiffPixels());\n+                    } else {\n+                        System.out.println(\"Test passed...\");\n+                    }\n+\n+                } else {\n+                    System.out.println(\"Test skipped: JFrame.NORMAL resize is not supported\");\n+                }\n+\n+            } else {\n+                System.out.println(\"Test skipped: JFrame.MAXIMIZED_BOTH resize is not supported\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> disposeFrame());\n+        }\n+    }\n+\n+    \/\/ Capture button rendering as a BufferedImage\n+    private BufferedImage getButtonImage() {\n+        BufferedImage bimage;\n+        try {\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            AtomicReference<Point> buttonLocRef = new AtomicReference<>();\n+            SwingUtilities.invokeAndWait(() -> buttonLocRef.set(button.getLocationOnScreen()));\n+            Point buttonLoc = buttonLocRef.get();\n+            System.out.println(\"Button loc: \" + buttonLoc);\n+            bimage = robot.createScreenCapture(new Rectangle(buttonLoc.x, buttonLoc.y, button.getWidth(), button.getHeight()));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems capturing button image from Robot\", e);\n+        }\n+        return bimage;\n+    }\n+\n+    private void disposeFrame() {\n+        if (frame != null) {\n+            frame.dispose();\n+            frame = null;\n+        }\n+    }\n+\n+    \/\/ Save BufferedImage to PNG file\n+    private void saveButtonImage(BufferedImage image, File file) {\n+        if (image != null) {\n+            try {\n+                System.out.println(\"Saving button image to \" + file.getAbsolutePath());\n+                ImageIO.write(image, \"PNG\", file);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not write image file\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"BufferedImage was set to null\");\n+        }\n+    }\n+\n+    private class DiffImage extends BufferedImage {\n+\n+        public boolean diff = false;\n+        public int nDiff = -1;\n+\n+        Color bgColor;\n+\n+        int threshold = 0;\n+\n+        public DiffImage(int w, int h) {\n+            super(w, h, BufferedImage.TYPE_INT_ARGB);\n+            bgColor = Color.LIGHT_GRAY;\n+        }\n+\n+        public int getNumDiffPixels() {\n+            return nDiff;\n+        }\n+\n+        public boolean compare(BufferedImage img1, BufferedImage img2) throws IOException {\n+\n+            int minx1 = img1.getMinX();\n+            int minx2 = img2.getMinX();\n+            int miny1 = img1.getMinY();\n+            int miny2 = img2.getMinY();\n+\n+            int w1 = img1.getWidth();\n+            int w2 = img2.getWidth();\n+            int h1 = img1.getHeight();\n+            int h2 = img2.getHeight();\n+\n+            if ((minx1 != minx2) || (miny1 != miny2) || (w1 != w2) || (h1 != h2)) {\n+                \/\/ image sizes are different\n+                throw new RuntimeException(\"img1: <\" + minx1 + \",\" + miny1 + \",\" + w1 + \"x\" + h1 + \">\" + \" img2: \" + minx2 + \",\" + miny2 + \",\" + w2 + \"x\" + h2 + \">\" + \" are different sizes\");\n+            }\n+            \/\/ Get the actual data behind the images\n+            Raster ras1 = img1.getData();\n+            Raster ras2 = img2.getData();\n+\n+            ColorModel cm1 = img1.getColorModel();\n+            ColorModel cm2 = img2.getColorModel();\n+\n+            int r1;  \/\/ red\n+            int r2;\n+            int g1;  \/\/ green\n+            int g2;\n+            int b1;  \/\/ blue\n+            int b2;\n+\n+            Object o1 = null;\n+            Object o2 = null;\n+            nDiff = 0;\n+            for (int x = minx1; x < (minx1 + w1); x++) {\n+                for (int y = miny1; y < (miny1 + h1); y++) {\n+                    \/\/ Causes rasters to allocate data\n+                    o1 = ras1.getDataElements(x, y, o1);\n+                    \/\/ and we reuse the data on every loop\n+                    o2 = ras2.getDataElements(x, y, o2);\n+\n+                    r1 = cm1.getRed(o1);\n+                    r2 = cm2.getRed(o2);\n+                    g1 = cm1.getGreen(o1);\n+                    g2 = cm2.getGreen(o2);\n+                    b1 = cm1.getBlue(o1);\n+                    b2 = cm2.getBlue(o2);\n+\n+                    if ((Math.abs(r1 - r2) > threshold) || (Math.abs(g1 - g2) > threshold) || (Math.abs(b1 - b2) > threshold)) {\n+                        \/\/ pixel is different\n+                        setDiffPixel(x, y, Math.abs(r1 - r2), Math.abs(g1 - g2), Math.abs(b1 - b2));\n+                        nDiff++;\n+                    } else {\n+                        setSamePixel(x, y);\n+                    }\n+\n+                }\n+            }\n+            if (nDiff != 0) {\n+                ImageIO.write(this, \"png\", new File(\"diffImage.png\"));\n+                saveButtonImage(img1, new File(\"image1.png\"));\n+                saveButtonImage(img2, new File(\"image2.png\"));\n+            }\n+            return nDiff == 0;\n+        }\n+\n+        void setDiffPixel(int x, int y, int r, int g, int b) {\n+            diff = true;\n+            setPixelValue(x, y, 255, r, g, b);\n+        }\n+\n+        void setSamePixel(int x, int y) {\n+            if (bgColor != null) {\n+                setPixelValue(x, y, 255, bgColor.getRed(), bgColor.getGreen(), bgColor.getBlue());\n+            } else {\n+                setPixelValue(x, y, 255, Color.black.getRed(), Color.black.getGreen(), Color.black.getBlue());\n+            }\n+        }\n+\n+        void setPixelValue(int x, int y, int a, int r, int g, int b) {\n+            \/\/ setRGB uses BufferedImage.TYPE_INT_ARGB format\n+            int pixel = ((a & 0xff) << 24) + ((r & 0xff) << 16) + ((g & 0xff) << 8) + ((b & 0xff));\n+            setRGB(x, y, pixel);\n+        }\n+\n+    }\n+\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/JButton\/SwingButtonResizeTestWithOpenGL.java","additions":321,"deletions":0,"binary":false,"changes":321,"status":"added"}]}