{"files":[{"patch":"@@ -4881,23 +4881,1 @@\n-  \/\/ might fork and exec without closing all appropriate file descriptors,\n-  \/\/ and this in turn might:\n-  \/\/\n-  \/\/ - cause end-of-file to fail to be detected on some file\n-  \/\/   descriptors, resulting in mysterious hangs, or\n-  \/\/\n-  \/\/ - might cause an fopen in the subprocess to fail on a system\n-  \/\/   suffering from bug 1085341.\n-  \/\/\n-  \/\/ (Yes, the default setting of the close-on-exec flag is a Unix\n-  \/\/ design flaw)\n-  \/\/\n-  \/\/ See:\n-  \/\/ 1085341: 32-bit stdio routines should support file descriptors >255\n-  \/\/ 4843136: (process) pipe file descriptor from Runtime.exec not being closed\n-  \/\/ 6339493: (process) Runtime.exec does not close all file descriptors on Solaris 9\n-  \/\/\n-  \/\/ Modern Linux kernels (after 2.6.23 2007) support O_CLOEXEC with open().\n-  \/\/ O_CLOEXEC is preferable to using FD_CLOEXEC on an open file descriptor\n-  \/\/ because it saves a system call and removes a small window where the flag\n-  \/\/ is unset.  On ancient Linux kernels the O_CLOEXEC flag will be ignored\n-  \/\/ and we fall back to using FD_CLOEXEC (see below).\n-#ifdef O_CLOEXEC\n+  \/\/ might fork and exec without closing all appropriate file descriptors.\n@@ -4905,1 +4883,0 @@\n-#endif\n@@ -4928,15 +4905,0 @@\n-#ifdef FD_CLOEXEC\n-  \/\/ Validate that the use of the O_CLOEXEC flag on open above worked.\n-  \/\/ With recent kernels, we will perform this check exactly once.\n-  static sig_atomic_t O_CLOEXEC_is_known_to_work = 0;\n-  if (!O_CLOEXEC_is_known_to_work) {\n-    int flags = ::fcntl(fd, F_GETFD);\n-    if (flags != -1) {\n-      if ((flags & FD_CLOEXEC) != 0)\n-        O_CLOEXEC_is_known_to_work = 1;\n-      else\n-        ::fcntl(fd, F_SETFD, flags | FD_CLOEXEC);\n-    }\n-  }\n-#endif\n-\n","filename":"src\/hotspot\/os\/linux\/os_linux.cpp","additions":1,"deletions":39,"binary":false,"changes":40,"status":"modified"}]}