{"files":[{"patch":"@@ -284,34 +284,50 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulINode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeInt *r0 = t0->is_int(); \/\/ Handy access\n-  const TypeInt *r1 = t1->is_int();\n-\n-  \/\/ Fetch endpoints of all ranges\n-  jint lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jint hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jint lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jint hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  int32_t A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeInt::INT; \/\/ Overflow?\n-  int32_t D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeInt::INT; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n+\/\/ Classes to perform mul_ring() for MulI\/MulLNode.\n+\/\/\n+\/\/ This class checks if all cross products of the left and right input of a multiplication have the same \"overflow value\".\n+\/\/ Without overflow\/underflow:\n+\/\/ Product is positive? High signed multiplication result: 0\n+\/\/ Product is negative? High signed multiplication result: -1\n+\/\/\n+\/\/ We normalize these values (see normalize_overflow_value()) such that we get the same \"overflow value\" by adding 1 if\n+\/\/ the product is negative. This allows us to compare all the cross product \"overflow values\". If one is different,\n+\/\/ compared to the others, then we know that this multiplication has a different number of over- or underflows compared\n+\/\/ to the others. In this case, we need to use bottom type and cannot guarantee a better type. Otherwise, we can take\n+\/\/ the min und max of all computed cross products as type of this Mul node.\n+template<typename IntegerType>\n+class IntegerMulRing {\n+  using NativeType = std::conditional_t<std::is_same<TypeInt, IntegerType>::value, jint, jlong>;\n+\n+  NativeType _lo_left;\n+  NativeType _lo_right;\n+  NativeType _hi_left;\n+  NativeType _hi_right;\n+  NativeType _lo_lo_product;\n+  NativeType _lo_hi_product;\n+  NativeType _hi_lo_product;\n+  NativeType _hi_hi_product;\n+  short _widen_left;\n+  short _widen_right;\n+\n+  static const Type* overflow_type();\n+  static NativeType multiply_high_signed_overflow_value(NativeType x, NativeType y);\n+\n+  \/\/ Pre-compute cross products which are used at several places\n+  void compute_cross_products() {\n+    _lo_lo_product = java_multiply(_lo_left, _lo_right);\n+    _lo_hi_product = java_multiply(_lo_left, _hi_right);\n+    _hi_lo_product = java_multiply(_hi_left, _lo_right);\n+    _hi_hi_product = java_multiply(_hi_left, _hi_right);\n+  }\n+\n+  bool cross_products_not_same_overflow() const {\n+    const NativeType lo_lo_high_product = multiply_high_signed_overflow_value(_lo_left, _lo_right);\n+    const NativeType lo_hi_high_product = multiply_high_signed_overflow_value(_lo_left, _hi_right);\n+    const NativeType hi_lo_high_product = multiply_high_signed_overflow_value(_hi_left, _lo_right);\n+    const NativeType hi_hi_high_product = multiply_high_signed_overflow_value(_hi_left, _hi_right);\n+    return lo_lo_high_product != lo_hi_high_product ||\n+           lo_hi_high_product != hi_lo_high_product ||\n+           hi_lo_high_product != hi_hi_high_product;\n+  }\n+\n+  static NativeType normalize_overflow_value(const NativeType x, const NativeType y, NativeType result) {\n+    return java_multiply(x, y) < 0 ? result + 1 : result;\n@@ -319,1 +335,45 @@\n-  return TypeInt::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n+\n+ public:\n+  IntegerMulRing(const IntegerType* left, const IntegerType* right) : _lo_left(left->_lo), _lo_right(right->_lo),\n+    _hi_left(left->_hi), _hi_right(right->_hi), _widen_left(left->_widen), _widen_right(right->_widen)  {\n+    compute_cross_products();\n+  }\n+\n+  \/\/ Compute the product type by multiplying the two input type ranges. We take the minimum and maximum of all possible\n+  \/\/ values (requires 4 multiplications of all possible combinations of the two range boundary values). If any of these\n+  \/\/ multiplications overflows\/underflows, we need to make sure that they all have the same number of overflows\/underflows\n+  \/\/ If that is not the case, we return the bottom type to cover all values due to the inconsistent overflows\/underflows).\n+  const Type* compute() const {\n+    if (cross_products_not_same_overflow()) {\n+      return overflow_type();\n+    }\n+    const NativeType min = MIN4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    const NativeType max = MAX4(_lo_lo_product, _lo_hi_product, _hi_lo_product, _hi_hi_product);\n+    return IntegerType::make(min, max, MAX2(_widen_left, _widen_right));\n+  }\n+};\n+\n+\n+template <>\n+const Type* IntegerMulRing<TypeInt>::overflow_type() {\n+  return TypeInt::INT;\n+}\n+\n+template <>\n+jint IntegerMulRing<TypeInt>::multiply_high_signed_overflow_value(const jint x, const jint y) {\n+  const jlong x_64 = x;\n+  const jlong y_64 = y;\n+  const jlong product = x_64 * y_64;\n+  const jint result = (jint)((uint64_t)product >> 32u);\n+  return normalize_overflow_value(x, y, result);\n+}\n+\n+template <>\n+const Type* IntegerMulRing<TypeLong>::overflow_type() {\n+  return TypeLong::LONG;\n+}\n+\n+template <>\n+jlong IntegerMulRing<TypeLong>::multiply_high_signed_overflow_value(const jlong x, const jlong y) {\n+  const jlong result = multiply_high_signed(x, y);\n+  return normalize_overflow_value(x, y, result);\n@@ -322,0 +382,11 @@\n+\/\/ Compute the product type of two integer ranges into this node.\n+const Type* MulINode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeInt> integer_mul_ring(type_left->is_int(), type_right->is_int());\n+  return integer_mul_ring.compute();\n+}\n+\n+\/\/ Compute the product type of two long ranges into this node.\n+const Type* MulLNode::mul_ring(const Type* type_left, const Type* type_right) const {\n+  const IntegerMulRing<TypeLong> integer_mul_ring(type_left->is_long(), type_right->is_long());\n+  return integer_mul_ring.compute();\n+}\n@@ -380,38 +451,0 @@\n-\/\/------------------------------mul_ring---------------------------------------\n-\/\/ Compute the product type of two integer ranges into this node.\n-const Type *MulLNode::mul_ring(const Type *t0, const Type *t1) const {\n-  const TypeLong *r0 = t0->is_long(); \/\/ Handy access\n-  const TypeLong *r1 = t1->is_long();\n-\n-  \/\/ Fetch endpoints of all ranges\n-  jlong lo0 = r0->_lo;\n-  double a = (double)lo0;\n-  jlong hi0 = r0->_hi;\n-  double b = (double)hi0;\n-  jlong lo1 = r1->_lo;\n-  double c = (double)lo1;\n-  jlong hi1 = r1->_hi;\n-  double d = (double)hi1;\n-\n-  \/\/ Compute all endpoints & check for overflow\n-  jlong A = java_multiply(lo0, lo1);\n-  if( (double)A != a*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong B = java_multiply(lo0, hi1);\n-  if( (double)B != a*d ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong C = java_multiply(hi0, lo1);\n-  if( (double)C != b*c ) return TypeLong::LONG; \/\/ Overflow?\n-  jlong D = java_multiply(hi0, hi1);\n-  if( (double)D != b*d ) return TypeLong::LONG; \/\/ Overflow?\n-\n-  if( A < B ) { lo0 = A; hi0 = B; } \/\/ Sort range endpoints\n-  else { lo0 = B; hi0 = A; }\n-  if( C < D ) {\n-    if( C < lo0 ) lo0 = C;\n-    if( D > hi0 ) hi0 = D;\n-  } else {\n-    if( D < lo0 ) lo0 = D;\n-    if( C > hi0 ) hi0 = C;\n-  }\n-  return TypeLong::make(lo0, hi0, MAX2(r0->_widen,r1->_widen));\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":106,"deletions":73,"binary":false,"changes":179,"status":"modified"},{"patch":"@@ -1238,0 +1238,1 @@\n+\n@@ -1239,0 +1240,14 @@\n+\/\/\n+\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n+\/\/ and a negative value, the resulting value is implementation-defined.\"\n+\/\/\n+\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n+\/\/ requiring two's-complement behavior.\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n+\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n+\/\/ arithmetic right shift, which performs sign-extension.\"\n+\/\/\n+\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n+\/\/ already behave that way. And it is unlikely any would go off and do something\n+\/\/ different now, with C++20 tightening things up.\n@@ -1269,0 +1284,32 @@\n+\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n+  const uint64_t x1 = x >> 32u;\n+  const uint64_t x2 = x & 0xFFFFFFFF;\n+  const uint64_t y1 = y >> 32u;\n+  const uint64_t y2 = y & 0xFFFFFFFF;\n+  const uint64_t z2 = x2 * y2;\n+  const uint64_t t = x1 * y2 + (z2 >> 32u);\n+  uint64_t z1 = t & 0xFFFFFFFF;\n+  const uint64_t z0 = t >> 32u;\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + (z1 >> 32u);\n+}\n+\n+\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n+\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n+inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n+  const jlong x1 = java_shift_right(x, 32);\n+  const jlong x2 = x & 0xFFFFFFFF;\n+  const jlong y1 = java_shift_right(y, 32);\n+  const jlong y2 = y & 0xFFFFFFFF;\n+\n+  const uint64_t z2 = x2 * y2;\n+  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n+  int64_t z1 = t & 0xFFFFFFFF;\n+  const int64_t z0 = java_shift_right(t, 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right(z1, 32);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":47,"deletions":0,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -0,0 +1,820 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.irTests.igvn;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8299546\n+ * @summary Test that IntegerMulRing works correctly and returns correct (and optimized) types.\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.igvn.TestIntegerMulRing\n+ *\/\n+public class TestIntegerMulRing {\n+    public static int iFld, iFld2, iFld3, iFld4;\n+    public static long lFld, lFld2, lFld3, lFld4;\n+\n+    public static void main(String[] args) {\n+        TestFramework.runWithFlags(\"-XX:-SplitIfBlocks\");\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongPositive() {\n+        long l = 111111111111111111L;\n+        if (l * 81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * 81 == 8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * 83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * 83 == 9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongPositive2() {\n+        long l = -111111111111111111L;\n+        if (l * -81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * -81 == 8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * -83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * -83 == 9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongNegative() {\n+        long l = -111111111111111111L;\n+        if (l * 81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * 81 == -8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * 83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * 83 == -9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = {IRNode.STORE_I, IRNode.IF}, counts = {IRNode.STORE_L, \"2\"})\n+    public static void testLongNegative2() {\n+        long l = 111111111111111111L;\n+        if (l * -81 == 1L) {\n+            iFld = 23;\n+        }\n+        if (l * -81 == -8999999999999999991L) {\n+            lFld = 23;\n+        }\n+        if (l * -83 == 1L) {\n+            iFld2 = 34;\n+        }\n+        if (l * -83 == -9222222222222222213L) {\n+            lFld2 = 23;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMinValueMinus1(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        int x = flag2 ? -1 : 0;\n+\n+        if (l * x != 2L) { \/\/ Type of multiplication is LONG as Long.MIN_VALUE * -1 does overflow. If cannot be removed.\n+            lFld = 23;\n+        } else {\n+            lFld = 34; \/\/ Emits StoreL since warmup is 0 and no UCT will be emitted.\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValuePlus1(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        int x = flag2 ? 1 : 0;\n+\n+        if (l * x <= 0L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValueUnderflowOnce(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 4 : 6;\n+\n+        if (l * x <= 4L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMinValueUnderflowOnceTwice(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 6 : 8;\n+\n+        if (l * x <= 4L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMinValueUnderflowTwice(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/2 : Long.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 8 : 10;\n+\n+        if (l * x <= 8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMaxValueOverflowOnce(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 4 : 6;\n+\n+        if (l * x >= -8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_L, \"1\"})\n+    public static void testLongMaxValueOverflowOnceTwice(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 6 : 8;\n+\n+        if (l * x >= -8L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_L, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testLongMaxValueOverflowTwice(boolean flag, boolean flag2) {\n+        long l = flag2 ? Long.MAX_VALUE\/2 - 1 : Long.MAX_VALUE\/2;\n+        int x = flag ? 8 : 10;\n+\n+        if (l * x >= -16L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsOverflowOnceAtMin(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MAX_VALUE\/2 + 1 : Long.MAX_VALUE\/2 + 2;\n+        int x = flag2 ? 2 : 3;\n+\n+        \/\/ [MAX_VALUE\/2 + 1, MAX_VALUE\/2 + 2] * [2,3]: All cross products overflow exactly once.\n+        \/\/ Result: [MIN_VALUE, MIN_VALUE\/2 + 3] -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsOverflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ 88971434439113593 * 311 = Long.MAX_VALUE*3 + 2 --cast to long--> Long.MAX_VALUE\n+        long l = flag ? 88971434439113592L : 88971434439113593L;\n+        int x = flag2 ? 310 : 311;\n+\n+        \/\/ All cross products overflow exactly once.\n+        \/\/ Result: [y, MAX_VALUE], where y > 2 -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsUnderflowOnceAtMin(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE\/3 - 1 : Long.MIN_VALUE\/3 - 2;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ [MIN_VALUE\/3 - 1, MIN_VALUE\/3 - 2] * [3,4]: All cross products underflow exactly once.\n+        \/\/ Result: [MAX_VALUE + MIN_VALUE\/3 - 5, MAX_VALUE] -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_L, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testLongProductsUnderflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ -6917529027641081856 * 4 = Long.MIN_VALUE*3 --cast to long--> Long.MIN_VALUE\n+        long l = flag ? -6917529027641081856L : -6917529027641081855L;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ All cross products underflow exactly once.\n+        \/\/ Result: [MIN_VALUE, y], where y < 2 -> 2L outside range and If can be optimized away.\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongProductsDifferentNumberOfOverflow(boolean flag, boolean flag2) {\n+        \/\/ 88971434439113593 * 311 = Long.MAX_VALUE*3 + 2 --cast to long--> Long.MAX_VALUE \/\/ Overflown once\n+        \/\/ 88971434439113594 * 311 = (Long.MAX_VALUE*3 + 311) + 2 --cast to long--> Long.MIN_VALUE + 310 \/\/ Overflown twice\n+        long l = flag ? 88971434439113593L : 88971434439113594L;\n+        int x = flag2 ? 310 : 311;\n+\n+        \/\/ Different number of overflows -> cannot optimize If away\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongProductsDifferentNumberOfUnderflows(boolean flag, boolean flag2) {\n+        \/\/ -6917529027641081856 * 4 = Long.MIN_VALUE*3 --cast to long--> Long.MIN_VALUE \/\/ Underflown once\n+        \/\/ -6917529027641081857 * 4 = (Long.MIN_VALUE*3 - 4) --cast to long--> Long.MAX_VALUE - 3 \/\/ Underflown twice\n+        long l = flag ? -6917529027641081856L : -6917529027641081857L;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ Different number of underflows -> cannot optimize If away\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow1(boolean flag, boolean flag2) {\n+        long l = flag ? 1 : Long.MAX_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow2(boolean flag, boolean flag2) {\n+        long l = flag ? 1 : Long.MIN_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow3(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MIN_VALUE;\n+        long x = flag2 ? Long.MIN_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow4(boolean flag, boolean flag2) {\n+        long l = flag ? -1 : Long.MAX_VALUE;\n+        long x = flag2 ? Long.MAX_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_L, \"1\"})\n+    public static void testLongNotSameOverflow5(boolean flag, boolean flag2) {\n+        long l = flag ? Long.MIN_VALUE : Long.MAX_VALUE;\n+        long x = flag2 ? Long.MAX_VALUE : -1;\n+\n+        if (l * x != 2L) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    \/\/ Int cases\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntPositive() {\n+        int i = 26000000;\n+        if (i * 81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * 81 == 2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * 83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * 83 == -2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntPositive2() {\n+        int i = -26000000;\n+        if (i * -81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * -81 == 2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * -83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * -83 == -2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntNegative() {\n+        int i = 26000000;\n+        if (i * -81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * -81 == -2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * -83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * -83 == 2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.IF, counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\"})\n+    public static void testIntNegative2() {\n+        int i = -26000000;\n+        if (i * 81 == 1) {\n+            iFld = 23;\n+        }\n+        if (i * 81 == -2106000000) {\n+            iFld = 34;\n+        }\n+\n+        if (i * 83 == 1) {\n+            lFld = 23;\n+        }\n+        if (i * 83 == 2136967296) {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMinValueMinus1(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? -1 : 0;\n+\n+        if (l * x != 2) { \/\/ Type of multiplication is INT as Integer.MIN_VALUE * -1 does overflow. If cannot be removed.\n+            lFld = 23;\n+        } else {\n+            lFld = 34; \/\/ Emits StoreL since warmup is 0 and no UCT will be emitted.\n+        }\n+    }\n+\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValuePlus1(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? 1 : 0;\n+\n+        if (l * x <= 0) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValueUnderflowOnce(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 4 : 6;\n+\n+        if (l * x <= 4) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMinValueUnderflowOnceTwice(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 6 : 8;\n+\n+        if (l * x <= 4) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMinValueUnderflowTwice(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/2 : Integer.MIN_VALUE\/2 + 1;\n+        int x = flag2 ? 8 : 10;\n+\n+        if (l * x <= 8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMaxValueOverflowOnce(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 4 : 6;\n+\n+        if (l * x >= -8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_I, \"1\", IRNode.STORE_L, \"1\", IRNode.MUL_I, \"1\"})\n+    public static void testIntMaxValueOverflowOnceTwice(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 6 : 8;\n+\n+        if (l * x >= -8) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = {IRNode.MUL_I, IRNode.STORE_L, IRNode.LSHIFT}, counts = {IRNode.STORE_I, \"1\"})\n+    public static void testIntMaxValueOverflowTwice(boolean flag, boolean flag2) {\n+        int l = flag2 ? Integer.MAX_VALUE\/2 - 1 : Integer.MAX_VALUE\/2;\n+        int x = flag ? 8 : 10;\n+\n+        if (l * x >= -16L) {\n+            iFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsOverflowOnceAtMin(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MAX_VALUE\/2 + 1 : Integer.MAX_VALUE\/2 + 2;\n+        int x = flag2 ? 2 : 3;\n+\n+        \/\/ [MAX_VALUE\/2 + 1, MAX_VALUE\/2 + 2] * [2,3]: All cross products overflow exactly once.\n+        \/\/ Result: [MIN_VALUE, MIN_VALUE\/2 + 3] -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsOverflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ 63786643 * 101 = Integer.MAX_VALUE*3 + 2 --cast to int--> Integer.MAX_VALUE\n+        int l = flag ? 63786642 : 63786643;\n+        int x = flag2 ? 100 : 101;\n+\n+        \/\/ All cross products overflow exactly once.\n+        \/\/ Result: [y, MAX_VALUE], where y > 2 -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsUnderflowOnceAtMin(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE\/3 - 1 : Integer.MIN_VALUE\/3 - 2;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ [MIN_VALUE\/3 - 1, MIN_VALUE\/3 - 2] * [3,4]: All cross products underflow exactly once.\n+        \/\/ Result: [MAX_VALUE + MIN_VALUE\/3 - 5, MAX_VALUE] -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(failOn = IRNode.MUL_I, counts = {IRNode.STORE_L, \"1\"})\n+    public static void testIntProductsUnderflowOnceAtMax(boolean flag, boolean flag2) {\n+        \/\/ -1610612736 * 4 = Integer.MIN_VALUE*3 --cast to int--> Integer.MIN_VALUE\n+        int l = flag ? -1610612736 : -1610612735;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ All cross products underflow exactly once.\n+        \/\/ Result: [MIN_VALUE, y], where y < 2 -> 2 outside range and If can be optimized away.\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntProductsDifferentNumberOfOverflow(boolean flag, boolean flag2) {\n+        \/\/ 63786643 * 101 = Integer.MAX_VALUE*3 + 2 --cast to int--> Integer.MAX_VALUE \/\/ Overflown once\n+        \/\/ 63786644 * 101 = (Integer.MAX_VALUE*3 + 101) + 2 --cast to int--> Integer.MIN_VALUE + 100 \/\/ Overflown twice\n+        int l = flag ? 63786643 : 63786644;\n+        int x = flag2 ? 100 : 101;\n+\n+        \/\/ Different number of overflows -> cannot optimize If away\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntProductsDifferentNumberOfUnderflows(boolean flag, boolean flag2) {\n+        \/\/ -1610612736 * 4 = Integer.MIN_VALUE*3 --cast to int--> Integer.MIN_VALUE \/\/ Underflown once\n+        \/\/ -1610612737 * 4 = (Integer.MIN_VALUE*3 - 4) --cast to int--> Integer.MAX_VALUE - 3 \/\/ Underflown twice\n+        int l = flag ? -1610612736 : -1610612737;\n+        int x = flag2 ? 3 : 4;\n+\n+        \/\/ Different number of underflows -> cannot optimize If away\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow1(boolean flag, boolean flag2) {\n+        int l = flag ? 1 : Integer.MAX_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow2(boolean flag, boolean flag2) {\n+        int l = flag ? 1 : Integer.MIN_VALUE;\n+        int x = flag2 ? -1 : 2;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow3(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MIN_VALUE;\n+        int x = flag2 ? Integer.MIN_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow4(boolean flag, boolean flag2) {\n+        int l = flag ? -1 : Integer.MAX_VALUE;\n+        int x = flag2 ? Integer.MAX_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    @Test\n+    @Warmup(0)\n+    @Arguments({Argument.TRUE, Argument.FALSE})\n+    @IR(counts = {IRNode.STORE_L, \"2\", IRNode.MUL_I, \"1\"})\n+    public static void testIntNotSameOverflow5(boolean flag, boolean flag2) {\n+        int l = flag ? Integer.MIN_VALUE : Integer.MAX_VALUE;\n+        int x = flag2 ? Integer.MAX_VALUE : -1;\n+\n+        if (l * x != 2) {\n+            lFld = 23;\n+        } else {\n+            lFld = 34;\n+        }\n+    }\n+\n+    \/\/ Just some sanity testing.\n+    @Test\n+    public static void test() {\n+        iFld = 1073741823 * 2;\n+        iFld2 = 1073741824 * 2; \/\/ overflow\n+        iFld3 = -1073741824 * 2;\n+        iFld4 = -1073741825 * 2; \/\/ underflow\n+        lFld = 4611686018427387903L * 2;\n+        lFld2 = 4611686018427387904L * 2; \/\/ overflow\n+        lFld3 = -4611686018427387904L * 2;\n+        lFld4 = -4611686018427387905L * 2; \/\/ underflow\n+    }\n+\n+    @Run(test = \"test\")\n+    public static void run() {\n+        test();\n+        Asserts.assertEQ(iFld, 2147483646);\n+        Asserts.assertEQ(iFld2, -2147483648);\n+        Asserts.assertEQ(iFld3, -2147483648);\n+        Asserts.assertEQ(iFld4, 2147483646);\n+        Asserts.assertEQ(lFld, 9223372036854775806L);\n+        Asserts.assertEQ(lFld2, -9223372036854775808L);\n+        Asserts.assertEQ(lFld3, -9223372036854775808L);\n+        Asserts.assertEQ(lFld4, 9223372036854775806L);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/igvn\/TestIntegerMulRing.java","additions":820,"deletions":0,"binary":false,"changes":820,"status":"added"},{"patch":"@@ -0,0 +1,68 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8299546\n+ * @summary Tests that MulL::Value() does not return bottom type and then an optimized type again in CCP.\n+ * @run main\/othervm -Xcomp -XX:CompileCommand=compileonly,compiler.ccp.TestMissingMulLOptimization::*\n+ *                   -XX:CompileCommand=dontinline,compiler.ccp.TestMissingMulLOptimization::*\n+ *                   compiler.ccp.TestMissingMulLOptimization\n+ *\/\n+package compiler.ccp;\n+\n+public class TestMissingMulLOptimization {\n+    static int N;\n+    static long x;\n+\n+    public static void main(String[] strArr) {\n+        try {\n+            test();\n+        } catch (RuntimeException e) {\n+            \/\/ Expected\n+        }\n+    }\n+\n+    static int test() {\n+        int i6 = 2, i10 = 3, i11, iArr[] = new int[N];\n+        long l = 3151638515L;\n+        double dArr[] = new double[N];\n+        dontInline();\n+        int i;\n+        for (i = 7; i < 221; i++) {\n+            i6 *= i6;\n+        }\n+        for (int j = 9; 83 > j; ) {\n+            for (i11 = 1; i11 < 6; ++i11) {\n+                l *= i;\n+                l += 3;\n+            }\n+        }\n+        x += i6;\n+        return 34;\n+    }\n+\n+    static int dontInline() {\n+        throw new RuntimeException();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/ccp\/TestMissingMulLOptimization.java","additions":68,"deletions":0,"binary":false,"changes":68,"status":"added"}]}