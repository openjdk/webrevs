{"files":[{"patch":"@@ -1167,38 +1167,0 @@\n-\/\/ Right shifts with signed integers are compiler implementation specific according to the C++ standard.\n-\/\/ Use a portable version instead.\n-inline int64_t shift_right_arithmetic(int64_t value, uint8_t shift_amount) {\n-  return value < 0 ? (int64_t)(~(~(uint64_t)value >> shift_amount)) : (int64_t)((uint64_t)value >> shift_amount);\n-}\n-\n-\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n-inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n-  const uint64_t x1 = x >> 32u;\n-  const uint64_t x2 = x & 0xFFFFFFFF;\n-  const uint64_t y1 = y >> 32u;\n-  const uint64_t y2 = y & 0xFFFFFFFF;\n-  const uint64_t z2 = x2 * y2;\n-  const uint64_t t = x1 * y2 + (z2 >> 32u);\n-  uint64_t z1 = t & 0xFFFFFFFF;\n-  const uint64_t z0 = t >> 32u;\n-  z1 += x2 * y1;\n-\n-  return x1 * y1 + z0 + (z1 >> 32u);\n-}\n-\n-\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n-\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n-inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n-  const jlong x1 = shift_right_arithmetic(x, 32);\n-  const jlong x2 = x & 0xFFFFFFFF;\n-  const jlong y1 = shift_right_arithmetic(y, 32);\n-  const jlong y2 = y & 0xFFFFFFFF;\n-\n-  const uint64_t z2 = x2 * y2;\n-  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n-  int64_t z1 = t & 0xFFFFFFFF;\n-  const int64_t z0 = shift_right_arithmetic(t, 32);\n-  z1 += x2 * y1;\n-\n-  return x1 * y1 + z0 + shift_right_arithmetic(z1, 32);\n-}\n-\n@@ -1276,0 +1238,1 @@\n+\n@@ -1277,0 +1240,14 @@\n+\/\/\n+\/\/ C++14 5.8\/3: In the description of \"E1 >> E2\" it says \"If E1 has a signed type\n+\/\/ and a negative value, the resulting value is implementation-defined.\"\n+\/\/\n+\/\/ However, C++20 7.6.7\/3 further defines integral arithmetic, as part of\n+\/\/ requiring two's-complement behavior.\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p0907r3.html\n+\/\/ https:\/\/www.open-std.org\/jtc1\/sc22\/wg21\/docs\/papers\/2018\/p1236r1.html\n+\/\/ The corresponding C++20 text is \"Right-shift on signed integral types is an\n+\/\/ arithmetic right shift, which performs sign-extension.\"\n+\/\/\n+\/\/ As discussed in the two's complement proposal, all known modern C++ compilers\n+\/\/ already behave that way. And it is unlikely any would go off and do something\n+\/\/ different now, with C++20 tightening things up.\n@@ -1307,0 +1284,32 @@\n+\/\/ Taken from rom section 8-2 of Henry S. Warren, Jr., Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174.\n+inline uint64_t multiply_high_unsigned(const uint64_t x, const uint64_t y) {\n+  const uint64_t x1 = x >> 32u;\n+  const uint64_t x2 = x & 0xFFFFFFFF;\n+  const uint64_t y1 = y >> 32u;\n+  const uint64_t y2 = y & 0xFFFFFFFF;\n+  const uint64_t z2 = x2 * y2;\n+  const uint64_t t = x1 * y2 + (z2 >> 32u);\n+  uint64_t z1 = t & 0xFFFFFFFF;\n+  const uint64_t z0 = t >> 32u;\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + (z1 >> 32u);\n+}\n+\n+\/\/ Taken from java.lang.Math::multiplyHigh which uses the technique from section 8-2 of Henry S. Warren, Jr.,\n+\/\/ Hacker's Delight (2nd ed.) (Addison Wesley, 2013), 173-174 but adapted for signed longs.\n+inline int64_t multiply_high_signed(const int64_t x, const int64_t y) {\n+  const jlong x1 = java_shift_right(x, 32);\n+  const jlong x2 = x & 0xFFFFFFFF;\n+  const jlong y1 = java_shift_right(y, 32);\n+  const jlong y2 = y & 0xFFFFFFFF;\n+\n+  const uint64_t z2 = x2 * y2;\n+  const int64_t t = x1 * y2 + (z2 >> 32u); \/\/ Unsigned shift\n+  int64_t z1 = t & 0xFFFFFFFF;\n+  const int64_t z0 = java_shift_right(t, 32);\n+  z1 += x2 * y1;\n+\n+  return x1 * y1 + z0 + java_shift_right(z1, 32);\n+}\n+\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":47,"deletions":38,"binary":false,"changes":85,"status":"modified"}]}