{"files":[{"patch":"@@ -232,5 +232,1 @@\n-    if (LockingMode == LM_MONITOR) {\n-      __ branch_optimized(Assembler::bcondAlways, *stub->entry());\n-    } else {\n-      __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n-    }\n+    __ unlock_object(Rtmp1, Rtmp2, lock->as_register(), *stub->entry());\n@@ -2717,7 +2713,1 @@\n-  if (LockingMode == LM_MONITOR) {\n-    if (op->info() != nullptr) {\n-      add_debug_info_for_null_check_here(op->info());\n-      __ null_check(obj);\n-    }\n-    __ branch_optimized(Assembler::bcondAlways, *op->stub()->entry());\n-  } else if (op->code() == lir_lock) {\n+  if (op->code() == lir_lock) {\n","filename":"src\/hotspot\/cpu\/s390\/c1_LIRAssembler_s390.cpp","additions":2,"deletions":12,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -61,2 +61,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -72,54 +70,1 @@\n-  assert(LockingMode != LM_MONITOR, \"LM_MONITOR is already handled, by emit_lock()\");\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, Roop);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      branch_optimized(Assembler::bcondAllOne, slow_case);\n-    }\n-\n-    NearLabel done;\n-\n-    \/\/ Load object header.\n-    z_lg(Rmark, Address(Roop, hdr_offset));\n-\n-    \/\/ and mark it as unlocked.\n-    z_oill(Rmark, markWord::unlocked_value);\n-    \/\/ Save unlocked object header into the displaced header location on the stack.\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Test if object header is still the same (i.e. unlocked), and if so, store the\n-    \/\/ displaced header address in the object header. If it is not the same, get the\n-    \/\/ object header instead.\n-    z_csg(Rmark, Rbox, hdr_offset, Roop);\n-    \/\/ If the object header was the same, we're done.\n-    branch_optimized(Assembler::bcondEqual, done);\n-    \/\/ If the object header was not the same, it is now in the Rmark register.\n-    \/\/ => Test if it is a stack pointer into the same stack (recursive locking), i.e.:\n-    \/\/\n-    \/\/ 1) (Rmark & markWord::lock_mask_in_place) == 0\n-    \/\/ 2) rsp <= Rmark\n-    \/\/ 3) Rmark <= rsp + page_size\n-    \/\/\n-    \/\/ These 3 tests can be done by evaluating the following expression:\n-    \/\/\n-    \/\/ (Rmark - Z_SP) & (~(page_size-1) | markWord::lock_mask_in_place)\n-    \/\/\n-    \/\/ assuming both the stack pointer and page_size have their least\n-    \/\/ significant 2 bits cleared and page_size is a power of 2\n-    z_sgr(Rmark, Z_SP);\n-\n-    load_const_optimized(Z_R0_scratch, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Rmark, Z_R0_scratch); \/\/ AND sets CC (result eq\/ne 0).\n-    \/\/ For recursive locking, the result is zero. => Save it in the displaced header\n-    \/\/ location (null in the displaced Rmark location indicates recursive locking).\n-    z_stg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ Otherwise we don't care about the result and handle locking via runtime call.\n-    branch_optimized(Assembler::bcondNotZero, slow_case);\n-    \/\/ done\n-    bind(done);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n+  lightweight_lock(Rbox, Roop, Rmark, tmp, slow_case);\n@@ -129,2 +74,0 @@\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -133,9 +76,0 @@\n-  NearLabel done;\n-\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Load displaced header.\n-    z_ltg(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));\n-    \/\/ If the loaded Rmark is null we had recursive locking, and we are done.\n-    z_bre(done);\n-  }\n-\n@@ -146,15 +80,1 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-    \/\/ Test if object header is pointing to the displaced header, and if so, restore\n-    \/\/ the displaced header in the object. If the object header is not pointing to\n-    \/\/ the displaced header, get the object header instead.\n-    z_csg(Rbox, Rmark, hdr_offset, Roop);\n-    \/\/ If the object header was not pointing to the displaced header,\n-    \/\/ we do unlocking via runtime call.\n-    branch_optimized(Assembler::bcondNotEqual, slow_case);\n-  } else {\n-    assert(false, \"Unhandled LockingMode:%d\", LockingMode);\n-  }\n-  \/\/ done\n-  bind(done);\n+  lightweight_unlock(Roop, Rmark, Z_R1_scratch, slow_case);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":2,"deletions":82,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -1011,22 +1011,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    return;\n-  }\n-\n-  \/\/ template code: (for LM_LEGACY)\n-  \/\/\n-  \/\/ markWord displaced_header = obj->mark().set_unlocked();\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-  \/\/   \/\/ We stored the monitor address into the object's mark word.\n-  \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-  \/\/   \/\/ Simple recursive case.\n-  \/\/   monitor->lock()->set_displaced_header(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1034,2 +1012,0 @@\n-  const Register object_mark_addr = Z_ARG4;\n-  const Register current_header   = Z_ARG5;\n@@ -1040,61 +1016,1 @@\n-  \/\/ markWord header = obj->mark().set_unlocked();\n-\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    lightweight_lock(monitor, object, header, tmp, slow_case);\n-  } else if (LockingMode == LM_LEGACY) {\n-\n-    if (DiagnoseSyncOnValueBasedClasses != 0) {\n-      load_klass(tmp, object);\n-      z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-      z_btrue(slow_case);\n-    }\n-\n-    \/\/ Load markWord from object into header.\n-    z_lg(header, hdr_offset, object);\n-\n-    \/\/ Set header to be (markWord of object | UNLOCK_VALUE).\n-    \/\/ This will not change anything if it was unlocked before.\n-    z_oill(header, markWord::unlocked_value);\n-\n-    \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-    const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-    const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n-    \/\/ Initialize the box (Must happen before we update the object mark!).\n-    z_stg(header, mark_offset, monitor);\n-\n-    \/\/ if (Atomic::cmpxchg(\/*addr*\/obj->mark_addr(), \/*cmp*\/displaced_header, \/*ex=*\/monitor) == displaced_header) {\n-\n-    \/\/ not necessary, use offset in instruction directly.\n-    \/\/ add2reg(object_mark_addr, hdr_offset, object);\n-\n-    \/\/ Store stack address of the BasicObjectLock (this is monitor) into object.\n-    z_csg(header, monitor, hdr_offset, object);\n-    assert(current_header == header,\n-           \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-\n-    z_bre(done);\n-\n-    \/\/ } else if (THREAD->is_lock_owned((address)displaced_header))\n-    \/\/   \/\/ Simple recursive case.\n-    \/\/   monitor->lock()->set_displaced_header(nullptr);\n-\n-    \/\/ We did not see an unlocked object so try the fast recursive case.\n-\n-    \/\/ Check if owner is self by comparing the value in the markWord of object\n-    \/\/ (current_header) with the stack pointer.\n-    z_sgr(current_header, Z_SP);\n-\n-    assert(os::vm_page_size() > 0xfff, \"page size too small - change the constant\");\n-\n-    \/\/ The prior sequence \"LGR, NGR, LTGR\" can be done better\n-    \/\/ (Z_R1 is temp and not used after here).\n-    load_const_optimized(Z_R0, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-    z_ngr(Z_R0, current_header); \/\/ AND sets CC (result eq\/ne 0)\n-\n-    \/\/ If condition is true we are done and hence we can store 0 in the displaced\n-    \/\/ header indicating it is a recursive lock and be done.\n-    z_brne(slow_case);\n-    z_release();  \/\/ Member unnecessary on zarch AND because the above csg does a sync before and after.\n-    z_stg(Z_R0\/*==0!*\/, mark_offset, monitor);\n-  }\n+  lightweight_lock(monitor, object, header, tmp, slow_case);\n@@ -1102,3 +1018,0 @@\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorenter(THREAD, monitor);\n@@ -1106,2 +1019,0 @@\n-  \/\/ None of the above fast optimizations worked so we have to get into the\n-  \/\/ slow case of monitor enter.\n@@ -1112,2 +1023,0 @@\n-  \/\/ }\n-\n@@ -1125,22 +1034,0 @@\n-\n-  if (LockingMode == LM_MONITOR) {\n-    call_VM_leaf(CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorexit), monitor);\n-    return;\n-  }\n-\n-\/\/ else {\n-  \/\/ template code: (for LM_LEGACY):\n-  \/\/\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n-  \/\/ }\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n@@ -1162,8 +1049,0 @@\n-  \/\/ if ((displaced_header = monitor->displaced_header()) == nullptr) {\n-  \/\/   \/\/ Recursive unlock. Mark the monitor unlocked by setting the object field to null.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ monitor->lock()->set_displaced_header(displaced_header);\n-  const int lock_offset = in_bytes(BasicObjectLock::lock_offset());\n-  const int mark_offset = lock_offset + BasicLock::displaced_header_offset_in_bytes();\n-\n@@ -1171,5 +1050,0 @@\n-  if (LockingMode != LM_LIGHTWEIGHT) {\n-    \/\/ Test first if we are in the fast recursive case.\n-    MacroAssembler::load_and_test_long(header, Address(monitor, mark_offset));\n-    z_bre(done); \/\/ header == 0 -> goto done\n-  }\n@@ -1177,26 +1051,2 @@\n-  \/\/ } else if (Atomic::cmpxchg(obj->mark_addr(), monitor, displaced_header) == monitor) {\n-  \/\/   \/\/ We swapped the unlocked mark in displaced_header into the object's mark word.\n-  \/\/   monitor->set_obj(nullptr);\n-\n-  \/\/ If we still have a lightweight lock, unlock the object and be done.\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-\n-    lightweight_unlock(object, header, current_header, slow_case);\n-\n-    z_bru(done);\n-  } else {\n-    \/\/ The markword is expected to be at offset 0.\n-    \/\/ This is not required on s390, at least not here.\n-    assert(hdr_offset == 0, \"unlock_object: review code below\");\n-\n-    \/\/ We have the displaced header in header. If the lock is still\n-    \/\/ lightweight, it will contain the monitor address and we'll store the\n-    \/\/ displaced header back into the object's mark word.\n-    z_lgr(current_header, monitor);\n-    z_csg(current_header, header, hdr_offset, object);\n-    z_bre(done);\n-  }\n-\n-  \/\/ } else {\n-  \/\/   \/\/ Slow path.\n-  \/\/   InterpreterRuntime::monitorexit(monitor);\n+  lightweight_unlock(object, header, current_header, slow_case);\n+  z_bru(done);\n@@ -1209,3 +1059,0 @@\n-\n-  \/\/ }\n-\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":3,"deletions":156,"binary":false,"changes":159,"status":"modified"},{"patch":"@@ -3769,205 +3769,0 @@\n-\/\/ \"The box\" is the space on the stack where we copy the object mark.\n-void MacroAssembler::compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_lock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp1;\n-  Register temp            = temp2;\n-\n-  NearLabel done, object_has_monitor;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  BLOCK_COMMENT(\"compiler_fast_lock_object {\");\n-\n-  \/\/ Load markWord from oop into mark.\n-  z_lg(displacedHeader, hdr_offset, oop);\n-\n-  if (DiagnoseSyncOnValueBasedClasses != 0) {\n-    load_klass(temp, oop);\n-    z_tm(Address(temp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n-    z_brne(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-  z_tmll(displacedHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    \/\/ From loading the markWord, we know that oop != nullptr\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Set mark to markWord | markWord::unlocked_value.\n-    z_oill(displacedHeader, markWord::unlocked_value);\n-\n-    \/\/ Load Compare Value application register.\n-\n-    \/\/ Initialize the box (must happen before we update the object mark).\n-    z_stg(displacedHeader, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    \/\/ Compare object markWord with mark and if equal, exchange box with object markWork.\n-    \/\/ If the compare-and-swap succeeds, then we found an unlocked object and have now locked it.\n-    z_csg(displacedHeader, box, hdr_offset, oop);\n-    assert(currentHeader == displacedHeader, \"must be same register\"); \/\/ Identified two registers from z\/Architecture.\n-    z_bre(done);\n-\n-    \/\/ We did not see an unlocked object\n-    \/\/ currentHeader contains what is currently stored in the oop's markWord.\n-    \/\/ We might have a recursive case. Verify by checking if the owner is self.\n-    \/\/ To do so, compare the value in the markWord (currentHeader) with the stack pointer.\n-    z_sgr(currentHeader, Z_SP);\n-    load_const_optimized(temp, (~(os::vm_page_size() - 1) | markWord::lock_mask_in_place));\n-\n-    z_ngr(currentHeader, temp);\n-\n-    \/\/ result zero: owner is self -> recursive lock. Indicate that by storing 0 in the box.\n-    \/\/ result not-zero: attempt failed. We don't hold the lock -> go for slow case.\n-\n-    z_stg(currentHeader\/*==0 or not 0*\/, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-    z_bru(done);\n-  }\n-\n-  bind(object_has_monitor);\n-\n-  Register zero = temp;\n-  Register monitor_tagged = displacedHeader; \/\/ Tagged with markWord::monitor_value.\n-\n-  \/\/ Try to CAS owner (no owner => current thread's _monitor_owner_id).\n-  \/\/ If csg succeeds then CR=EQ, otherwise, register zero is filled\n-  \/\/ with the current owner.\n-  z_lghi(zero, 0);\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_csg(zero, Z_R0_scratch, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor_tagged);\n-\n-  \/\/ Store a non-null value into the box.\n-  z_stg(box, BasicLock::displaced_header_offset_in_bytes(), box);\n-\n-  z_bre(done); \/\/ acquired the lock for the first time.\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_lock {\");\n-  \/\/ Check if we are already the owner (recursive lock)\n-  z_cgr(Z_R0_scratch, zero); \/\/ owner is stored in zero by \"z_csg\" above\n-  z_brne(done); \/\/ not a recursive lock\n-\n-  \/\/ Current thread already owns the lock. Just increment recursion count.\n-  z_agsi(Address(monitor_tagged, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-  z_cgr(zero, zero); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_lock\");\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_lock_object\");\n-  \/\/ If locking was successful, CR should indicate 'EQ'.\n-  \/\/ The compiler or the native wrapper generates a branch to the runtime call\n-  \/\/ _complete_monitor_locking_Java.\n-}\n-\n-void MacroAssembler::compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2) {\n-\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"uses fast_unlock_lightweight\");\n-  assert_different_registers(oop, box, temp1, temp2, Z_R0_scratch);\n-\n-  Register displacedHeader = temp1;\n-  Register currentHeader   = temp2;\n-  Register temp            = temp1;\n-\n-  const int hdr_offset = oopDesc::mark_offset_in_bytes();\n-\n-  Label done, object_has_monitor, not_recursive;\n-\n-  BLOCK_COMMENT(\"compiler_fast_unlock_object {\");\n-\n-  if (LockingMode == LM_LEGACY) {\n-    \/\/ Find the lock address and load the displaced header from the stack.\n-    \/\/ if the displaced header is zero, we have a recursive unlock.\n-    load_and_test_long(displacedHeader, Address(box, BasicLock::displaced_header_offset_in_bytes()));\n-    z_bre(done);\n-  }\n-\n-  \/\/ Handle existing monitor.\n-  \/\/ The object has an existing monitor iff (mark & monitor_value) != 0.\n-  z_lg(currentHeader, hdr_offset, oop);\n-  guarantee(Immediate::is_uimm16(markWord::monitor_value), \"must be half-word\");\n-\n-  z_tmll(currentHeader, markWord::monitor_value);\n-  z_brnaz(object_has_monitor);\n-\n-  if (LockingMode == LM_MONITOR) {\n-    \/\/ Set NE to indicate 'failure' -> take slow-path\n-    z_ltgr(oop, oop);\n-    z_bru(done);\n-  } else {\n-    assert(LockingMode == LM_LEGACY, \"must be\");\n-    \/\/ Check if it is still a lightweight lock, this is true if we see\n-    \/\/ the stack address of the basicLock in the markWord of the object\n-    \/\/ copy box to currentHeader such that csg does not kill it.\n-    z_lgr(currentHeader, box);\n-    z_csg(currentHeader, displacedHeader, hdr_offset, oop);\n-    z_bru(done); \/\/ csg sets CR as desired.\n-  }\n-\n-  \/\/ In case of LM_LIGHTWEIGHT, we may reach here with (temp & ObjectMonitor::ANONYMOUS_OWNER) != 0.\n-  \/\/ This is handled like owner thread mismatches: We take the slow path.\n-\n-  \/\/ Handle existing monitor.\n-  bind(object_has_monitor);\n-\n-  z_lg(Z_R0_scratch, Address(Z_thread, JavaThread::monitor_owner_id_offset()));\n-  z_cg(Z_R0_scratch, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-  z_brne(done);\n-\n-  BLOCK_COMMENT(\"fast_path_recursive_unlock {\");\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-  z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n-\n-  \/\/ Recursive inflated unlock\n-  z_agsi(Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-  z_cgr(currentHeader, currentHeader); \/\/ set the CC to EQUAL\n-  BLOCK_COMMENT(\"} fast_path_recursive_unlock\");\n-  z_bru(done);\n-\n-  bind(not_recursive);\n-\n-  NearLabel set_eq_unlocked;\n-\n-  \/\/ Set owner to null.\n-  \/\/ Release to satisfy the JMM\n-  z_release();\n-  z_lghi(temp, 0);\n-  z_stg(temp, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), currentHeader);\n-  \/\/ We need a full fence after clearing owner to avoid stranding.\n-  z_fence();\n-\n-  \/\/ Check if the entry_list is empty.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(entry_list)));\n-  z_bre(done); \/\/ If so we are done.\n-\n-  \/\/ Check if there is a successor.\n-  load_and_test_long(temp, Address(currentHeader, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)));\n-  z_brne(set_eq_unlocked); \/\/ If so we are done.\n-\n-  \/\/ Save the monitor pointer in the current thread, so we can try to\n-  \/\/ reacquire the lock in SharedRuntime::monitor_exit_helper().\n-  z_xilf(currentHeader, markWord::monitor_value);\n-  z_stg(currentHeader, Address(Z_thread, JavaThread::unlocked_inflated_monitor_offset()));\n-\n-  z_ltgr(oop, oop); \/\/ Set flag = NE\n-  z_bru(done);\n-\n-  bind(set_eq_unlocked);\n-  z_cr(temp, temp); \/\/ Set flag = EQ\n-\n-  bind(done);\n-\n-  BLOCK_COMMENT(\"} compiler_fast_unlock_object\");\n-  \/\/ flag == EQ indicates success\n-  \/\/ flag == NE indicates failure\n-}\n-\n@@ -6352,1 +6147,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n@@ -6418,1 +6212,0 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"only used with new lightweight locking\");\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":0,"deletions":207,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -793,2 +793,0 @@\n-  void compiler_fast_lock_object(Register oop, Register box, Register temp1, Register temp2);\n-  void compiler_fast_unlock_object(Register oop, Register box, Register temp1, Register temp2);\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-\/\/ Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+\/\/ Copyright (c) 2017, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -10164,22 +10164,0 @@\n-instruct cmpFastLock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastLock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(VARIABLE_SIZE); \/\/ Uses load_const_optimized.\n-  format %{ \"FASTLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_lock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n-instruct cmpFastUnlock(flagsReg pcc, iRegP_N2P oop, iRegP_N2P box, iRegP tmp1, iRegP tmp2) %{\n-  predicate(LockingMode != LM_LIGHTWEIGHT);\n-  match(Set pcc (FastUnlock oop box));\n-  effect(TEMP tmp1, TEMP tmp2);\n-  ins_cost(100);\n-  \/\/ TODO: s390 port size(FIXED_SIZE);\n-  format %{ \"FASTUNLOCK  $oop, $box; KILL Z_ARG4, Z_ARG5\" %}\n-  ins_encode %{ __ compiler_fast_unlock_object($oop$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register); %}\n-  ins_pipe(pipe_class_dummy);\n-%}\n-\n@@ -10187,1 +10165,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n@@ -10203,1 +10180,0 @@\n-  predicate(LockingMode == LM_LIGHTWEIGHT);\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":1,"deletions":25,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -1767,7 +1767,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_lock kills r_temp_1, r_temp_2.\n-      __ compiler_fast_lock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_lock kills r_temp_1, r_temp_2.\n+    __ compiler_fast_lock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n@@ -1968,7 +1963,2 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    } else {\n-      \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n-      __ compiler_fast_unlock_object(r_oop, r_box, r_tmp1, r_tmp2);\n-    }\n+    \/\/ Fast_unlock kills r_tmp1, r_tmp2.\n+    __ compiler_fast_unlock_lightweight_object(r_oop, r_box, r_tmp1, r_tmp2);\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":4,"deletions":14,"binary":false,"changes":18,"status":"modified"}]}