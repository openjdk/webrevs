{"files":[{"patch":"@@ -488,33 +488,44 @@\n-     * Converts 4 bytes from a long input into an 8-character hexadecimal string encoded as a long value,\n-     * using vectorized bitwise operations for high performance.\n-     *\n-     * Algorithm Description:\n-     * 1. Byte Expansion Phase:\n-     *    - Extracts 8 nibbles (4-bit values) from the 4 input bytes using 0x0F mask pattern\n-     *    - Expands each byte into two 16-bit sections using Long.expand()\n-     *    - Final layout: 0xAABBCCDD -> 0x0A0B0C0D0A0B0C0D (nibble separation)\n-     *\n-     * 2. Hex Conversion Phase (Parallel Computation):\n-     *    a. Carry Detection: Adds 6 to each nibble (0x06 per byte)\n-     *       - Generates carry bit (0x10) for values >= 10\n-     *       - Mask: 0x1010_1010_1010_1010 identifies hex letters (a-f)\n-     *    b. ASCII Calculation:\n-     *       - Base value: 0x30 ('0' character)\n-     *       - Letter adjustment: 39 (0x27) for values >=10 using bitwise magic:\n-     *         (carry_mask << 1) + (carry_mask >> 1) - (carry_mask >> 4) = 0x27\n-     *    c. Parallel Addition: Combines base\/letter adjustment with original nibbles\n-     *\n-     * 3. Byte Order Correction:\n-     *    - Reverses byte order to match big-endian string representation\n-     *\n-     * Performance Considerations:\n-     * - Processes all 8 nibbles simultaneously using bitwise operations (~1 cycle)\n-     * - Eliminates:\n-     *   - Loop overhead (traditional 8-iteration approach)\n-     *   - Branch mispredictions (no if\/else for letter\/digit)\n-     *   - Multiple memory accesses (works entirely in registers)\n-     * - Achieves O(1) time complexity vs O(n) for iterative approaches\n-     * - Uses 6 arithmetic\/logical operations vs 40+ for naive implementation\n-     *\n-     * @param i The input value containing up to 4 bytes of data in its least significant bits\n-     * @return A long value representing the concatenated hexadecimal string of the 4 input bytes\n+     * Efficiently converts 8 hexadecimal digits to their ASCII representation using SIMD-style vector operations.\n+     * This method processes multiple digits in parallel by treating a long value as eight 8-bit lanes,\n+     * achieving significantly better performance compared to traditional loop-based conversion.\n+     *\n+     * <p>The conversion algorithm works as follows:\n+     * <pre>\n+     * 1. Input expansion: Each 4-bit hex digit is expanded to 8 bits\n+     * 2. Vector processing:\n+     *    - Add 6 to each digit: triggers carry flag for a-f digits\n+     *    - Mask with 0x10 pattern to isolate carry flags\n+     *    - Calculate ASCII adjustment: (carry << 1) + (carry >> 1) - (carry >> 4)\n+     *    - Add ASCII '0' base (0x30) and original value\n+     * 3. Byte order adjustment for final output\n+     * <\/pre>\n+     *\n+     * <p>Performance characteristics:\n+     * <ul>\n+     *   <li>Processes 8 digits in parallel using vector operations\n+     *   <li>Avoids branching and loops completely\n+     *   <li>Uses only integer arithmetic and bit operations\n+     *   <li>Constant time execution regardless of input values\n+     * <\/ul>\n+     *\n+     * <p>ASCII conversion mapping:\n+     * <ul>\n+     *   <li>Digits 0-9 → ASCII '0'-'9' (0x30-0x39)\n+     *   <li>Digits a-f → ASCII 'a'-'f' (0x61-0x66)\n+     * <\/ul>\n+     *\n+     * @param input A long containing 8 hex digits (each digit must be 0-15)\n+     * @return A long containing 8 ASCII bytes representing the hex digits\n+     *\n+     * @implNote The implementation leverages CPU vector processing capabilities through\n+     *           long integer operations. The algorithm is based on the observation that\n+     *           ASCII hex digits have a specific pattern that can be computed efficiently\n+     *           using carry flag manipulation.\n+     *\n+     * @example\n+     * <pre>\n+     * Input:  0x0123456789ABCDEF\n+     * Output: 0x3031323334353637 ('0','1','2','3','4','5','6','7' in ASCII)\n+     * <\/pre>\n+     *\n+     * @see Long#reverseBytes(long)\n@@ -523,1 +534,1 @@\n-        \/\/ Expand bytes to separated nibbles: 0xAABBCCDD -> 0x0A0B0C0D0A0B0C0D\n+        \/\/ Expand each 4-bit group into 8 bits, spreading them out in the long value: 0xAABBCCDD -> 0x0A0B0C0D0A0B0C0D\n@@ -527,18 +538,15 @@\n-            Use long to simulate vector operations and generate 8 hexadecimal characters at a time.\n-            ------------\n-            0  = 0b0000_0000 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '0'\n-            1  = 0b0000_0001 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '1'\n-            2  = 0b0000_0010 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '2'\n-            3  = 0b0000_0011 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '3'\n-            4  = 0b0000_0100 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '4'\n-            5  = 0b0000_0101 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '5'\n-            6  = 0b0000_0110 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '6'\n-            7  = 0b0000_0111 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '7'\n-            8  = 0b0000_1000 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '8'\n-            9  = 0b0000_1001 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '9'\n-            10 = 0b0000_1010 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'a'\n-            11 = 0b0000_1011 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'b'\n-            12 = 0b0000_1100 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'c'\n-            13 = 0b0000_1101 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'd'\n-            14 = 0b0000_1110 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'e'\n-            15 = 0b0000_1111 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'f'\n+         * This method efficiently converts 8 hexadecimal digits simultaneously using vector operations\n+         * The algorithm works as follows:\n+         *\n+         * For input values 0-15:\n+         * - For digits 0-9: converts to ASCII '0'-'9' (0x30-0x39)\n+         * - For digits 10-15: converts to ASCII 'a'-'f' (0x61-0x66)\n+         *\n+         * The conversion process:\n+         * 1. Add 6 to each 4-bit group: i + 0x0606_0606_0606_0606L\n+         * 2. Mask to get the adjustment flags: & 0x1010_1010_1010_1010L\n+         * 3. Calculate the offset: (m << 1) + (m >> 1) - (m >> 4)\n+         *    - For 0-9: offset = 0\n+         *    - For a-f: offset = 39 (to bridge the gap between '9' and 'a' in ASCII)\n+         * 4. Add ASCII '0' base (0x30) and the original value\n+         * 5. Reverse byte order for correct positioning\n@@ -546,2 +554,0 @@\n-\n-        \/\/ Detect nibbles >= 10 using carry propagation (0x06 addition per nibble)\n@@ -550,1 +556,1 @@\n-        \/\/ Vectorized ASCII conversion: (0x30 base + nibble) + (0x27 adjustment if >=10)\n+        \/\/ Calculate final ASCII values and reverse bytes for proper ordering\n@@ -552,3 +558,3 @@\n-                ((m << 1) + (m >> 1) - (m >> 4))  \/\/ 0x27 mask generator\n-                + 0x3030_3030_3030_3030L          \/\/ Base '0' characters\n-                + i                               \/\/ Nibble values\n+                ((m << 1) + (m >> 1) - (m >> 4))\n+                + 0x3030_3030_3030_3030L \/\/ Add ASCII '0' base to all digits\n+                + i                      \/\/ Add original values\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":64,"deletions":58,"binary":false,"changes":122,"status":"modified"}]}