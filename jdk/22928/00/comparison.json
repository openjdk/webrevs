{"files":[{"patch":"@@ -34,1 +34,1 @@\n-import jdk.internal.util.HexDigits;\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -79,1 +79,0 @@\n-\n@@ -465,5 +464,0 @@\n-        int i0 = (int) (mostSigBits >> 32);\n-        int i1 = (int) mostSigBits;\n-        int i2 = (int) (leastSigBits >> 32);\n-        int i3 = (int) leastSigBits;\n-\n@@ -471,2 +465,0 @@\n-        HexDigits.put4(buf, 0, i0 >> 16);\n-        HexDigits.put4(buf, 4, i0);\n@@ -474,1 +466,0 @@\n-        HexDigits.put4(buf, 9, i1 >> 16);\n@@ -476,1 +467,0 @@\n-        HexDigits.put4(buf, 14, i1);\n@@ -478,1 +468,0 @@\n-        HexDigits.put4(buf, 19, i2 >> 16);\n@@ -480,3 +469,17 @@\n-        HexDigits.put4(buf, 24, i2);\n-        HexDigits.put4(buf, 28, i3 >> 16);\n-        HexDigits.put4(buf, 32, i3);\n+\n+\/\/        Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+        long x  = mostSigBits,\n+             x0 = hex8(x >>> 32),\n+             x1 = hex8(x);\n+        ByteArrayLittleEndian.setLong(buf, 0, x0);\n+        ByteArrayLittleEndian.setInt(buf, 9, (int) x1);\n+        ByteArrayLittleEndian.setInt(buf, 14, (int) (x1 >>> 32));\n+\n+        x  = leastSigBits;\n+        x0 = hex8(x >>> 32);\n+        x1 = hex8(x);\n+        ByteArrayLittleEndian.setInt(buf, 19, (int) (x0));\n+        ByteArrayLittleEndian.setInt(buf, 24, (int) (x0 >>> 32));\n+        ByteArrayLittleEndian.setLong(buf, 28, x1);\n+\n@@ -490,0 +493,33 @@\n+    \/**\n+     * Extract the least significant 4 bytes from the input integer i, convert each byte into its corresponding 2-digit\n+     * hexadecimal representation, concatenate these hexadecimal strings into one continuous string, and then interpret\n+     * this string as a hexadecimal number to form and return a long value.\n+     *\/\n+    private static long hex8(long i) {\n+        i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+        \/*\n+            Use long to simulate vector operations and generate 8 hexadecimal characters at a time.\n+            ------------\n+            0  = 0b0000_0000 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '0'\n+            1  = 0b0000_0001 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '1'\n+            2  = 0b0000_0010 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '2'\n+            3  = 0b0000_0011 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '3'\n+            4  = 0b0000_0100 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '4'\n+            5  = 0b0000_0101 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '5'\n+            6  = 0b0000_0110 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '6'\n+            7  = 0b0000_0111 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '7'\n+            8  = 0b0000_1000 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '8'\n+            9  = 0b0000_1001 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '9'\n+            10 = 0b0000_1010 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'a'\n+            11 = 0b0000_1011 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'b'\n+            12 = 0b0000_1100 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'c'\n+            13 = 0b0000_1101 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'd'\n+            14 = 0b0000_1110 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'e'\n+            15 = 0b0000_1111 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'f'\n+         *\/\n+        long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+        return Long.reverseBytes(((m << 1) + (m >> 1) - (m >> 4))\n+                + 0x3030_3030_3030_3030L\n+                + i);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":51,"deletions":15,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -116,16 +116,0 @@\n-    \/**\n-     * Insert the unsigned 2-byte integer into the buffer as 4 hexadecimal digit ASCII bytes,\n-     * only least significant 16 bits of {@code value} are used.\n-     * @param buffer byte buffer to copy into\n-     * @param index insert point\n-     * @param value to convert\n-     *\/\n-    public static void put4(byte[] buffer, int index, int value) {\n-        \/\/ Prepare an int value so C2 generates a 4-byte write instead of two 2-byte writes\n-        int v = (DIGITS[value & 0xff] << 16) | DIGITS[(value >> 8) & 0xff];\n-        buffer[index]     = (byte)  v;\n-        buffer[index + 1] = (byte) (v >> 8);\n-        buffer[index + 2] = (byte) (v >> 16);\n-        buffer[index + 3] = (byte) (v >> 24);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}