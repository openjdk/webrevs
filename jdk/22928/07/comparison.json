{"files":[{"patch":"@@ -34,1 +34,1 @@\n-import jdk.internal.util.HexDigits;\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -79,1 +79,0 @@\n-\n@@ -465,5 +464,0 @@\n-        int i0 = (int) (mostSigBits >> 32);\n-        int i1 = (int) mostSigBits;\n-        int i2 = (int) (leastSigBits >> 32);\n-        int i3 = (int) leastSigBits;\n-\n@@ -471,2 +465,0 @@\n-        HexDigits.put4(buf, 0, i0 >> 16);\n-        HexDigits.put4(buf, 4, i0);\n@@ -474,1 +466,0 @@\n-        HexDigits.put4(buf, 9, i1 >> 16);\n@@ -476,1 +467,0 @@\n-        HexDigits.put4(buf, 14, i1);\n@@ -478,1 +468,0 @@\n-        HexDigits.put4(buf, 19, i2 >> 16);\n@@ -480,3 +469,13 @@\n-        HexDigits.put4(buf, 24, i2);\n-        HexDigits.put4(buf, 28, i3 >> 16);\n-        HexDigits.put4(buf, 32, i3);\n+\n+        \/\/ Although the UUID byte ordering is defined to be big-endian, ByteArrayLittleEndian is used here to optimize\n+        \/\/ for the most common architectures. hex8 reverses the order internally.\n+        ByteArrayLittleEndian.setLong(buf, 0, hex8(mostSigBits >>> 32));\n+        long x0 = hex8(mostSigBits);\n+        ByteArrayLittleEndian.setInt(buf, 9, (int) x0);\n+        ByteArrayLittleEndian.setInt(buf, 14, (int) (x0 >>> 32));\n+\n+        long x1 = hex8(leastSigBits >>> 32);\n+        ByteArrayLittleEndian.setInt(buf, 19, (int) (x1));\n+        ByteArrayLittleEndian.setInt(buf, 24, (int) (x1 >>> 32));\n+        ByteArrayLittleEndian.setLong(buf, 28, hex8(leastSigBits));\n+\n@@ -490,0 +489,77 @@\n+    \/**\n+     * Efficiently converts 8 hexadecimal digits to their ASCII representation using SIMD-style vector operations.\n+     * This method processes multiple digits in parallel by treating a long value as eight 8-bit lanes,\n+     * achieving significantly better performance compared to traditional loop-based conversion.\n+     *\n+     * <p>The conversion algorithm works as follows:\n+     * <pre>\n+     * 1. Input expansion: Each 4-bit hex digit is expanded to 8 bits\n+     * 2. Vector processing:\n+     *    - Add 6 to each digit: triggers carry flag for a-f digits\n+     *    - Mask with 0x10 pattern to isolate carry flags\n+     *    - Calculate ASCII adjustment: (carry << 1) + (carry >> 1) - (carry >> 4)\n+     *    - Add ASCII '0' base (0x30) and original value\n+     * 3. Byte order adjustment for final output\n+     * <\/pre>\n+     *\n+     * <p>Performance characteristics:\n+     * <ul>\n+     *   <li>Processes 8 digits in parallel using vector operations\n+     *   <li>Avoids branching and loops completely\n+     *   <li>Uses only integer arithmetic and bit operations\n+     *   <li>Constant time execution regardless of input values\n+     * <\/ul>\n+     *\n+     * <p>ASCII conversion mapping:\n+     * <ul>\n+     *   <li>Digits 0-9 → ASCII '0'-'9' (0x30-0x39)\n+     *   <li>Digits a-f → ASCII 'a'-'f' (0x61-0x66)\n+     * <\/ul>\n+     *\n+     * @param input A long containing 8 hex digits (each digit must be 0-15)\n+     * @return A long containing 8 ASCII bytes representing the hex digits\n+     *\n+     * @implNote The implementation leverages CPU vector processing capabilities through\n+     *           long integer operations. The algorithm is based on the observation that\n+     *           ASCII hex digits have a specific pattern that can be computed efficiently\n+     *           using carry flag manipulation.\n+     *\n+     * @example\n+     * <pre>\n+     * Input:  0xABCDEF01\n+     * Output: 3130666564636261 ('1','0','f','e','d','c','b','a' in ASCII)\n+     * <\/pre>\n+     *\n+     * @see Long#reverseBytes(long)\n+     *\/\n+    private static long hex8(long i) {\n+        \/\/ Expand each 4-bit group into 8 bits, spreading them out in the long value: 0xAABBCCDD -> 0xA0A0B0B0C0C0D0D\n+        i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+\n+        \/*\n+         * This method efficiently converts 8 hexadecimal digits simultaneously using vector operations\n+         * The algorithm works as follows:\n+         *\n+         * For input values 0-15:\n+         * - For digits 0-9: converts to ASCII '0'-'9' (0x30-0x39)\n+         * - For digits 10-15: converts to ASCII 'a'-'f' (0x61-0x66)\n+         *\n+         * The conversion process:\n+         * 1. Add 6 to each 4-bit group: i + 0x0606_0606_0606_0606L\n+         * 2. Mask to get the adjustment flags: & 0x1010_1010_1010_1010L\n+         * 3. Calculate the offset: (m << 1) + (m >> 1) - (m >> 4)\n+         *    - For 0-9: offset = 0\n+         *    - For a-f: offset = 39 (to bridge the gap between '9' and 'a' in ASCII)\n+         * 4. Add ASCII '0' base (0x30) and the original value\n+         * 5. Reverse byte order for correct positioning\n+         *\/\n+        long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+\n+        \/\/ Calculate final ASCII values and reverse bytes for proper ordering\n+        return Long.reverseBytes(\n+                ((m << 1) + (m >> 1) - (m >> 4))\n+                + 0x3030_3030_3030_3030L \/\/ Add ASCII '0' base to all digits\n+                + i                      \/\/ Add original values\n+        );\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":91,"deletions":15,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -116,16 +116,0 @@\n-    \/**\n-     * Insert the unsigned 2-byte integer into the buffer as 4 hexadecimal digit ASCII bytes,\n-     * only least significant 16 bits of {@code value} are used.\n-     * @param buffer byte buffer to copy into\n-     * @param index insert point\n-     * @param value to convert\n-     *\/\n-    public static void put4(byte[] buffer, int index, int value) {\n-        \/\/ Prepare an int value so C2 generates a 4-byte write instead of two 2-byte writes\n-        int v = (DIGITS[value & 0xff] << 16) | DIGITS[(value >> 8) & 0xff];\n-        buffer[index]     = (byte)  v;\n-        buffer[index + 1] = (byte) (v >> 8);\n-        buffer[index + 2] = (byte) (v >> 16);\n-        buffer[index + 3] = (byte) (v >> 24);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}