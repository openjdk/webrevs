{"files":[{"patch":"@@ -488,3 +488,33 @@\n-     * Extract the least significant 4 bytes from the input integer i, convert each byte into its corresponding 2-digit\n-     * hexadecimal representation, concatenate these hexadecimal strings into one continuous string, and then interpret\n-     * this string as a hexadecimal number to form and return a long value.\n+     * Converts 4 bytes from a long input into an 8-character hexadecimal string encoded as a long value,\n+     * using vectorized bitwise operations for high performance.\n+     *\n+     * Algorithm Description:\n+     * 1. Byte Expansion Phase:\n+     *    - Extracts 8 nibbles (4-bit values) from the 4 input bytes using 0x0F mask pattern\n+     *    - Expands each byte into two 16-bit sections using Long.expand()\n+     *    - Final layout: 0xAABBCCDD -> 0x0A0B0C0D0A0B0C0D (nibble separation)\n+     *\n+     * 2. Hex Conversion Phase (Parallel Computation):\n+     *    a. Carry Detection: Adds 6 to each nibble (0x06 per byte)\n+     *       - Generates carry bit (0x10) for values >= 10\n+     *       - Mask: 0x1010_1010_1010_1010 identifies hex letters (a-f)\n+     *    b. ASCII Calculation:\n+     *       - Base value: 0x30 ('0' character)\n+     *       - Letter adjustment: 39 (0x27) for values >=10 using bitwise magic:\n+     *         (carry_mask << 1) + (carry_mask >> 1) - (carry_mask >> 4) = 0x27\n+     *    c. Parallel Addition: Combines base\/letter adjustment with original nibbles\n+     *\n+     * 3. Byte Order Correction:\n+     *    - Reverses byte order to match big-endian string representation\n+     *\n+     * Performance Considerations:\n+     * - Processes all 8 nibbles simultaneously using bitwise operations (~1 cycle)\n+     * - Eliminates:\n+     *   - Loop overhead (traditional 8-iteration approach)\n+     *   - Branch mispredictions (no if\/else for letter\/digit)\n+     *   - Multiple memory accesses (works entirely in registers)\n+     * - Achieves O(1) time complexity vs O(n) for iterative approaches\n+     * - Uses 6 arithmetic\/logical operations vs 40+ for naive implementation\n+     *\n+     * @param i The input value containing up to 4 bytes of data in its least significant bits\n+     * @return A long value representing the concatenated hexadecimal string of the 4 input bytes\n@@ -493,0 +523,1 @@\n+        \/\/ Expand bytes to separated nibbles: 0xAABBCCDD -> 0x0A0B0C0D0A0B0C0D\n@@ -494,0 +525,1 @@\n+\n@@ -514,0 +546,2 @@\n+\n+        \/\/ Detect nibbles >= 10 using carry propagation (0x06 addition per nibble)\n@@ -515,3 +549,7 @@\n-        return Long.reverseBytes(((m << 1) + (m >> 1) - (m >> 4))\n-                + 0x3030_3030_3030_3030L\n-                + i);\n+\n+        \/\/ Vectorized ASCII conversion: (0x30 base + nibble) + (0x27 adjustment if >=10)\n+        return Long.reverseBytes(\n+                ((m << 1) + (m >> 1) - (m >> 4))  \/\/ 0x27 mask generator\n+                + 0x3030_3030_3030_3030L          \/\/ Base '0' characters\n+                + i                               \/\/ Nibble values\n+        );\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":44,"deletions":6,"binary":false,"changes":50,"status":"modified"}]}