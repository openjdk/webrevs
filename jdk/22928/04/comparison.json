{"files":[{"patch":"@@ -34,1 +34,1 @@\n-import jdk.internal.util.HexDigits;\n+import jdk.internal.util.ByteArrayLittleEndian;\n@@ -79,1 +79,0 @@\n-\n@@ -465,5 +464,0 @@\n-        int i0 = (int) (mostSigBits >> 32);\n-        int i1 = (int) mostSigBits;\n-        int i2 = (int) (leastSigBits >> 32);\n-        int i3 = (int) leastSigBits;\n-\n@@ -471,2 +465,0 @@\n-        HexDigits.put4(buf, 0, i0 >> 16);\n-        HexDigits.put4(buf, 4, i0);\n@@ -474,1 +466,0 @@\n-        HexDigits.put4(buf, 9, i1 >> 16);\n@@ -476,1 +467,0 @@\n-        HexDigits.put4(buf, 14, i1);\n@@ -478,1 +468,0 @@\n-        HexDigits.put4(buf, 19, i2 >> 16);\n@@ -480,3 +469,11 @@\n-        HexDigits.put4(buf, 24, i2);\n-        HexDigits.put4(buf, 28, i3 >> 16);\n-        HexDigits.put4(buf, 32, i3);\n+\n+        ByteArrayLittleEndian.setLong(buf, 0, hex8(mostSigBits >>> 32));\n+        long x0 = hex8(mostSigBits);\n+        ByteArrayLittleEndian.setInt(buf, 9, (int) x0);\n+        ByteArrayLittleEndian.setInt(buf, 14, (int) (x0 >>> 32));\n+\n+        long x1 = hex8(leastSigBits >>> 32);\n+        ByteArrayLittleEndian.setInt(buf, 19, (int) (x1));\n+        ByteArrayLittleEndian.setInt(buf, 24, (int) (x1 >>> 32));\n+        ByteArrayLittleEndian.setLong(buf, 28, hex8(leastSigBits));\n+\n@@ -490,0 +487,71 @@\n+    \/**\n+     * Converts 4 bytes from a long input into an 8-character hexadecimal string encoded as a long value,\n+     * using vectorized bitwise operations for high performance.\n+     *\n+     * Algorithm Description:\n+     * 1. Byte Expansion Phase:\n+     *    - Extracts 8 nibbles (4-bit values) from the 4 input bytes using 0x0F mask pattern\n+     *    - Expands each byte into two 16-bit sections using Long.expand()\n+     *    - Final layout: 0xAABBCCDD -> 0x0A0B0C0D0A0B0C0D (nibble separation)\n+     *\n+     * 2. Hex Conversion Phase (Parallel Computation):\n+     *    a. Carry Detection: Adds 6 to each nibble (0x06 per byte)\n+     *       - Generates carry bit (0x10) for values >= 10\n+     *       - Mask: 0x1010_1010_1010_1010 identifies hex letters (a-f)\n+     *    b. ASCII Calculation:\n+     *       - Base value: 0x30 ('0' character)\n+     *       - Letter adjustment: 39 (0x27) for values >=10 using bitwise magic:\n+     *         (carry_mask << 1) + (carry_mask >> 1) - (carry_mask >> 4) = 0x27\n+     *    c. Parallel Addition: Combines base\/letter adjustment with original nibbles\n+     *\n+     * 3. Byte Order Correction:\n+     *    - Reverses byte order to match big-endian string representation\n+     *\n+     * Performance Considerations:\n+     * - Processes all 8 nibbles simultaneously using bitwise operations (~1 cycle)\n+     * - Eliminates:\n+     *   - Loop overhead (traditional 8-iteration approach)\n+     *   - Branch mispredictions (no if\/else for letter\/digit)\n+     *   - Multiple memory accesses (works entirely in registers)\n+     * - Achieves O(1) time complexity vs O(n) for iterative approaches\n+     * - Uses 6 arithmetic\/logical operations vs 40+ for naive implementation\n+     *\n+     * @param i The input value containing up to 4 bytes of data in its least significant bits\n+     * @return A long value representing the concatenated hexadecimal string of the 4 input bytes\n+     *\/\n+    private static long hex8(long i) {\n+        \/\/ Expand bytes to separated nibbles: 0xAABBCCDD -> 0x0A0B0C0D0A0B0C0D\n+        i = Long.expand(i, 0x0F0F_0F0F_0F0F_0F0FL);\n+\n+        \/*\n+            Use long to simulate vector operations and generate 8 hexadecimal characters at a time.\n+            ------------\n+            0  = 0b0000_0000 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '0'\n+            1  = 0b0000_0001 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '1'\n+            2  = 0b0000_0010 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '2'\n+            3  = 0b0000_0011 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '3'\n+            4  = 0b0000_0100 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '4'\n+            5  = 0b0000_0101 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '5'\n+            6  = 0b0000_0110 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '6'\n+            7  = 0b0000_0111 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '7'\n+            8  = 0b0000_1000 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '8'\n+            9  = 0b0000_1001 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 0  + 0x30 + (i & 0xF) => '9'\n+            10 = 0b0000_1010 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'a'\n+            11 = 0b0000_1011 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'b'\n+            12 = 0b0000_1100 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'c'\n+            13 = 0b0000_1101 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'd'\n+            14 = 0b0000_1110 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'e'\n+            15 = 0b0000_1111 => m = ((i + 6) & 0x10); (m << 1) + (m >> 1) - (m >> 4) => 39 + 0x30 + (i & 0xF) => 'f'\n+         *\/\n+\n+        \/\/ Detect nibbles >= 10 using carry propagation (0x06 addition per nibble)\n+        long m = (i + 0x0606_0606_0606_0606L) & 0x1010_1010_1010_1010L;\n+\n+        \/\/ Vectorized ASCII conversion: (0x30 base + nibble) + (0x27 adjustment if >=10)\n+        return Long.reverseBytes(\n+                ((m << 1) + (m >> 1) - (m >> 4))  \/\/ 0x27 mask generator\n+                + 0x3030_3030_3030_3030L          \/\/ Base '0' characters\n+                + i                               \/\/ Nibble values\n+        );\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/UUID.java","additions":83,"deletions":15,"binary":false,"changes":98,"status":"modified"},{"patch":"@@ -116,16 +116,0 @@\n-    \/**\n-     * Insert the unsigned 2-byte integer into the buffer as 4 hexadecimal digit ASCII bytes,\n-     * only least significant 16 bits of {@code value} are used.\n-     * @param buffer byte buffer to copy into\n-     * @param index insert point\n-     * @param value to convert\n-     *\/\n-    public static void put4(byte[] buffer, int index, int value) {\n-        \/\/ Prepare an int value so C2 generates a 4-byte write instead of two 2-byte writes\n-        int v = (DIGITS[value & 0xff] << 16) | DIGITS[(value >> 8) & 0xff];\n-        buffer[index]     = (byte)  v;\n-        buffer[index + 1] = (byte) (v >> 8);\n-        buffer[index + 2] = (byte) (v >> 16);\n-        buffer[index + 3] = (byte) (v >> 24);\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/HexDigits.java","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"}]}