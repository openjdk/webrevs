{"files":[{"patch":"@@ -438,2 +438,4 @@\n-  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator); }\n-  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);     }\n+  inline size_t capacity()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Mutator);   }\n+  inline size_t used()      const { return _partitions.used_by(ShenandoahFreeSetPartitionId::Mutator);       }\n+  inline size_t reserved()  const { return _partitions.capacity_of(ShenandoahFreeSetPartitionId::Collector); }\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -49,2 +49,4 @@\n-  size_t free_actual   = _heap->free_set()->available();\n-  size_t free_expected = _heap->max_capacity() \/ 100 * ShenandoahCriticalFreeThreshold;\n+  ShenandoahFreeSet* free_set = _heap->free_set();\n+  size_t free_actual   = free_set->available();\n+  \/\/ The sum of free_set->capacity() and ->reserved represents capacity of young in generational, heap in non-generational.\n+  size_t free_expected = ((free_set->capacity() + free_set->reserved()) \/ 100) * ShenandoahCriticalFreeThreshold;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMetrics.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}