{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -411,0 +412,1 @@\n+    mem_zap_end_padding(mem);\n@@ -416,0 +418,18 @@\n+#ifndef PRODUCT\n+void ObjArrayAllocator::mem_zap_end_padding(HeapWord* mem) const {\n+  const size_t length_in_bytes = static_cast<size_t>(_length) << ArrayKlass::cast(_klass)->log2_element_size();\n+  const BasicType element_type = ArrayKlass::cast(_klass)->element_type();\n+  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t size_in_bytes = _word_size * BytesPerWord;\n+\n+  const address obj_end = reinterpret_cast<address>(mem) + size_in_bytes;\n+  const address base = reinterpret_cast<address>(mem) + base_offset_in_bytes;\n+  const address elements_end = base + length_in_bytes;\n+  assert(elements_end <= obj_end, \"payload must fit in object\");\n+  if (elements_end < obj_end) {\n+    const size_t padding_in_bytes = obj_end - elements_end;\n+    Copy::fill_to_bytes(elements_end, padding_in_bytes, heapPaddingByteVal);\n+  }\n+}\n+#endif\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.cpp","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -101,0 +101,2 @@\n+  void mem_zap_end_padding(HeapWord* mem) const PRODUCT_RETURN;\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/memAllocator.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -135,0 +135,2 @@\n+  mem_zap_end_padding(mem);\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1028,13 +1028,14 @@\n-const jint     badInt           = -3;                       \/\/ generic \"bad int\" value\n-const intptr_t badAddressVal    = -2;                       \/\/ generic \"bad address\" value\n-const intptr_t badOopVal        = -1;                       \/\/ generic \"bad oop\" value\n-const intptr_t badHeapOopVal    = (intptr_t) CONST64(0x2BAD4B0BBAADBABE); \/\/ value used to zap heap after GC\n-const int      badStackSegVal   = 0xCA;                     \/\/ value used to zap stack segments\n-const int      badHandleValue   = 0xBC;                     \/\/ value used to zap vm handle area\n-const int      badResourceValue = 0xAB;                     \/\/ value used to zap resource area\n-const int      freeBlockPad     = 0xBA;                     \/\/ value used to pad freed blocks.\n-const int      uninitBlockPad   = 0xF1;                     \/\/ value used to zap newly malloc'd blocks.\n-const juint    uninitMetaWordVal= 0xf7f7f7f7;               \/\/ value used to zap newly allocated metachunk\n-const juint    badHeapWordVal   = 0xBAADBABE;               \/\/ value used to zap heap after GC\n-const juint    badMetaWordVal   = 0xBAADFADE;               \/\/ value used to zap metadata heap after GC\n-const int      badCodeHeapNewVal= 0xCC;                     \/\/ value used to zap Code heap at allocation\n+const jint     badInt             = -3;                     \/\/ generic \"bad int\" value\n+const intptr_t badAddressVal      = -2;                     \/\/ generic \"bad address\" value\n+const intptr_t badOopVal          = -1;                     \/\/ generic \"bad oop\" value\n+const intptr_t badHeapOopVal      = (intptr_t) CONST64(0x2BAD4B0BBAADBABE); \/\/ value used to zap heap after GC\n+const int      badStackSegVal     = 0xCA;                   \/\/ value used to zap stack segments\n+const int      badHandleValue     = 0xBC;                   \/\/ value used to zap vm handle area\n+const int      badResourceValue   = 0xAB;                   \/\/ value used to zap resource area\n+const int      freeBlockPad       = 0xBA;                   \/\/ value used to pad freed blocks.\n+const int      uninitBlockPad     = 0xF1;                   \/\/ value used to zap newly malloc'd blocks.\n+const juint    uninitMetaWordVal  = 0xf7f7f7f7;             \/\/ value used to zap newly allocated metachunk\n+const jubyte   heapPaddingByteVal = 0xBD;                   \/\/ value used to zap object padding in the heap\n+const juint    badHeapWordVal     = 0xBAADBABE;             \/\/ value used to zap heap after GC\n+const juint    badMetaWordVal     = 0xBAADFADE;             \/\/ value used to zap metadata heap after GC\n+const int      badCodeHeapNewVal  = 0xCC;                   \/\/ value used to zap Code heap at allocation\n","filename":"src\/hotspot\/share\/utilities\/globalDefinitions.hpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"}]}