{"files":[{"patch":"@@ -858,0 +858,22 @@\n+\n+  if (range_checks.size() > 0) {\n+    \/\/ This transformation requires peeling one iteration. Also, if it has range checks and they are eliminated by Loop\n+    \/\/ Predication, then 2 Hoisted Check Predicates are added for one range check. Finally, transforming a long range\n+    \/\/ check requires extra logic to be executed before the loop is entered and for the outer loop. As a result, the\n+    \/\/ transformations can't pay off for a small number of iterations: roughly, if the loop runs for 3 iterations, it's\n+    \/\/ going to execute as many range checks once transformed with range checks eliminated (1 peeled iteration with\n+    \/\/ range checks + 2 predicates per range checks) as it would have not transformed. It also has to pay for the extra\n+    \/\/ logic on loop entry and for the outer loop.\n+    loop->compute_trip_count(this);\n+    if (head->is_CountedLoop() && head->as_CountedLoop()->has_exact_trip_count()) {\n+      if (head->as_CountedLoop()->trip_count() <= 3) {\n+        return false;\n+      }\n+    } else {\n+      loop->compute_profile_trip_cnt(this);\n+      if (!head->is_profile_trip_failed() && head->profile_trip_cnt() <= 3) {\n+        return false;\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * @bug 8259609 8276116\n+ * @bug 8259609 8276116 8311932\n@@ -41,3 +41,3 @@\n-        TestFramework.runWithFlags(\"-XX:-UseCountedLoopSafepoints\");\n-        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\");\n-        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\");\n+        TestFramework.runWithFlags(\"-XX:+TieredCompilation\", \"-XX:-UseCountedLoopSafepoints\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:+TieredCompilation\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:+TieredCompilation\", \"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopUnrollLimit=0\");\n@@ -249,0 +249,54 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LONG_COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP })\n+    public static void testStridePosScalePosShortLoop(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+\n+        \/\/ Loop runs for too few iterations. Transforming it wouldn't pay off.\n+        for (long i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosShortLoop\")\n+    private void testStridePosScalePosShortLoop_runner() {\n+        testStridePosScalePosShortLoop(0, 2, 2, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testStridePosScalePosInIntLoopShortLoop1(int start, int stop, long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+\n+        \/\/ Same but with int loop\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosInIntLoopShortLoop1\")\n+    private void testStridePosScalePosInIntLoopShortLoop1_runner() {\n+        testStridePosScalePosInIntLoopShortLoop1(0, 2, 4, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP })\n+    public static void testStridePosScalePosInIntLoopShortLoop2(long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+\n+        \/\/ Same but with int loop\n+        for (int i = 0; i < 3; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosInIntLoopShortLoop2\")\n+    private void testStridePosScalePosInIntLoopShortLoop2_runner() {\n+        testStridePosScalePosInIntLoopShortLoop2(6, 0);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":58,"deletions":4,"binary":false,"changes":62,"status":"modified"}]}