{"files":[{"patch":"@@ -858,0 +858,22 @@\n+\n+  if (range_checks.size() > 0) {\n+    \/\/ This transformation requires peeling one iteration. Also, if it has range checks and they are eliminated by\n+    \/\/ predication, then 2 predicates are added for one range check. Finally, transforming a long range check requires\n+    \/\/ extra logic to be executed before the loop is entered and for the outer loop. As a result, the transformations\n+    \/\/ can't pay off for a small number of iterations: roughly, if the loop runs for 3 iterations, it's going to execute\n+    \/\/ as many range checks once transformed with range checks eliminated (1 peeled iteration with range checks\n+    \/\/ + 2 predicates per range checks) as it would have not transformed. It also has to pay for the extra logic on loop\n+    \/\/ entry and for the outer loop.\n+    loop->compute_trip_count(this);\n+    if (head->is_CountedLoop() && head->as_CountedLoop()->has_exact_trip_count()) {\n+      if (head->as_CountedLoop()->trip_count() <= 3) {\n+        return false;\n+      }\n+    } else {\n+      loop->compute_profile_trip_cnt(this);\n+      if (!head->is_profile_trip_failed() && head->profile_trip_cnt() <= 3) {\n+        return false;\n+      }\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -41,3 +41,3 @@\n-        TestFramework.runWithFlags(\"-XX:-UseCountedLoopSafepoints\");\n-        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\");\n-        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\");\n+        TestFramework.runWithFlags(\"-XX:-UseCountedLoopSafepoints\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1\", \"-XX:LoopUnrollLimit=0\");\n+        TestFramework.runWithFlags(\"-XX:+UseCountedLoopSafepoints\", \"-XX:LoopStripMiningIter=1000\", \"-XX:LoopUnrollLimit=0\");\n@@ -249,0 +249,54 @@\n+\n+    @Test\n+    @IR(counts = { IRNode.LONG_COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.COUNTED_LOOP, IRNode.LOOP })\n+    public static void testStridePosScalePosShortLoop(long start, long stop, long length, long offset) {\n+        final long scale = 1;\n+        final long stride = 1;\n+\n+        \/\/ Loop runs for too few iterations. Transforming it wouldn't pay off.\n+        for (long i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosShortLoop\")\n+    private void testStridePosScalePosShortLoop_runner() {\n+        testStridePosScalePosShortLoop(0, 2, 2, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP})\n+    public static void testStridePosScalePosInIntLoopShortLoop1(int start, int stop, long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+\n+        \/\/ Same but with int loop\n+        for (int i = start; i < stop; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosInIntLoopShortLoop1\")\n+    private void testStridePosScalePosInIntLoopShortLoop1_runner() {\n+        testStridePosScalePosInIntLoopShortLoop1(0, 2, 4, 0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.COUNTED_LOOP, \"1\" })\n+    @IR(failOn = { IRNode.LOOP})\n+    public static void testStridePosScalePosInIntLoopShortLoop2(long length, long offset) {\n+        final long scale = 2;\n+        final int stride = 1;\n+\n+        \/\/ Same but with int loop\n+        for (int i = 0; i < 3; i += stride) {\n+            Objects.checkIndex(scale * i + offset, length);\n+        }\n+    }\n+\n+    @Run(test = \"testStridePosScalePosInIntLoopShortLoop2\")\n+    private void testStridePosScalePosInIntLoopShortLoop2_runner() {\n+        testStridePosScalePosInIntLoopShortLoop2(6, 0);\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/TestLongRangeChecks.java","additions":57,"deletions":3,"binary":false,"changes":60,"status":"modified"}]}