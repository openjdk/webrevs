{"files":[{"patch":"@@ -47,0 +47,1 @@\n+import sun.net.util.IPAddressUtil;\n@@ -474,1 +475,7 @@\n-                    if (!(s instanceof SSLSocketImpl)) {\n+                    if (!(s instanceof SSLSocketImpl) &&\n+                            !IPAddressUtil.isIPv4LiteralAddress(host) &&\n+                            !(host.charAt(0) == '[' && host.charAt(host.length() - 1) == ']' &&\n+                                IPAddressUtil.isIPv6LiteralAddress(host.substring(1, host.length() - 1))\n+                            )) {\n+                        \/\/ Fully qualified DNS hostname of the server, as per section 3, RFC 6066\n+                        \/\/ Literal IPv4 and IPv6 addresses are not permitted in \"HostName\".\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -0,0 +1,396 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8369950\n+ * @library \/test\/lib\n+ * @summary TLS connection to IPv6 address fails with BCJSSE due to IllegalArgumentException\n+ * @run main\/othervm SubjectAltNameIPv6\n+ *\/\n+\n+import javax.net.ssl.*;\n+import java.io.*;\n+import java.net.*;\n+\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jtreg.SkippedException;\n+\n+public class SubjectAltNameIPv6 {\n+    \/*\n+     * =============================================================\n+     * Set the various variables needed for the tests, then\n+     * specify what tests to run on each side.\n+     *\/\n+\n+    \/*\n+     * Should we run the client or server in a separate thread?\n+     * Both sides can throw exceptions, but do you have a preference\n+     * as to which side should be the main thread.\n+     *\/\n+    static boolean separateServerThread = true;\n+\n+    \/*\n+     * Is the server ready to serve?\n+     *\/\n+    volatile static boolean serverReady = false;\n+\n+    \/*\n+     * Turn on SSL debugging?\n+     *\/\n+    static boolean debug = false;\n+\n+    \/*\n+     * If the client or server is doing some kind of object creation\n+     * that the other side depends on, and that thread prematurely\n+     * exits, you may experience a hang.  The test harness will\n+     * terminate all hung threads after its timeout has expired,\n+     * currently 3 minutes by default, but you might try to be\n+     * smart about it....\n+     *\/\n+\n+    \/*\n+     * Define the server side of the test.\n+     *\n+     * If the server prematurely exits, serverReady will be set to true\n+     * to avoid infinite hangs.\n+     *\/\n+    void doServerSide() throws Exception {\n+        SSLServerSocketFactory sslssf =\n+            new SimpleSSLContext().get().getServerSocketFactory();\n+        SSLServerSocket sslServerSocket =\n+            (SSLServerSocket) sslssf.createServerSocket(serverPort, 0, InetAddress.getByName(\"[::1]\"));\n+        sslServerSocket.setEnabledProtocols(new String[]{\"TLSv1.3\"});\n+        serverPort = sslServerSocket.getLocalPort();\n+\n+        \/*\n+         * Signal Client, we're ready for his connect.\n+         *\/\n+        serverReady = true;\n+\n+        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n+        OutputStream sslOS = sslSocket.getOutputStream();\n+        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(sslOS));\n+        bw.write(\"HTTP\/1.1 200 OK\\r\\n\\r\\n\\r\\n\");\n+        bw.flush();\n+        Thread.sleep(5000);\n+        sslSocket.close();\n+    }\n+\n+    \/*\n+     * Define the client side of the test.\n+     *\n+     * If the server prematurely exits, serverReady will be set to true\n+     * to avoid infinite hangs.\n+     *\/\n+    void doClientSide() throws Exception {\n+\n+        \/*\n+         * Wait for server to get started.\n+         *\/\n+        while (!serverReady) {\n+            Thread.sleep(50);\n+        }\n+\n+        SSLSocketFactory sf = new SimpleSSLContext().get().getSocketFactory();\n+        URL url = new URL(\"https:\/\/[::1]:\" + serverPort + \"\/index.html\");\n+        HttpsURLConnection conn = (HttpsURLConnection)url.openConnection();\n+\n+        \/*\n+         * Simulate an external JSSE implementation.\n+         *\/\n+        conn.setSSLSocketFactory(wrapSocketFactory(sf));\n+        conn.getInputStream();\n+\n+        if (conn.getResponseCode() == -1) {\n+            throw new RuntimeException(\"getResponseCode() returns -1\");\n+        }\n+    }\n+\n+    \/*\n+     * =============================================================\n+     * The remainder is just support stuff\n+     *\/\n+\n+    \/\/ use any free port by default\n+    volatile int serverPort = 0;\n+\n+    volatile Exception serverException = null;\n+    volatile Exception clientException = null;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!IPSupport.hasIPv6()) {\n+            throw new SkippedException(\"Skipping test - IPv6 is not supported\");\n+        }\n+        if (debug) {\n+            System.setProperty(\"javax.net.debug\", \"all\");\n+        }\n+        \/*\n+         * Start the tests.\n+         *\/\n+        new SubjectAltNameIPv6();\n+    }\n+\n+    Thread clientThread = null;\n+    Thread serverThread = null;\n+\n+    \/*\n+     * Primary constructor, used to drive remainder of the test.\n+     *\n+     * Fork off the other side, then do your work.\n+     *\/\n+    SubjectAltNameIPv6() throws Exception {\n+        if (separateServerThread) {\n+            startServer(true);\n+            startClient(false);\n+        } else {\n+            startClient(true);\n+            startServer(false);\n+        }\n+\n+        \/*\n+         * Wait for other side to close down.\n+         *\/\n+        if (separateServerThread) {\n+            serverThread.join();\n+        } else {\n+            clientThread.join();\n+        }\n+\n+        \/*\n+         * When we get here, the test is pretty much over.\n+         *\n+         * If the main thread excepted, that propagates back\n+         * immediately.  If the other thread threw an exception, we\n+         * should report back.\n+         *\/\n+        if (serverException != null)\n+            throw serverException;\n+        if (clientException != null)\n+            throw clientException;\n+    }\n+\n+    void startServer(boolean newThread) throws Exception {\n+        if (newThread) {\n+            serverThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doServerSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our server thread just died.\n+                         *\n+                         * Release the client, if not active already...\n+                         *\/\n+                        System.err.println(\"Server died:\");\n+                        serverReady = true;\n+                        serverException = e;\n+                    }\n+                }\n+            };\n+            serverThread.start();\n+        } else {\n+            doServerSide();\n+        }\n+    }\n+\n+    void startClient(boolean newThread) throws Exception {\n+        if (newThread) {\n+            clientThread = new Thread() {\n+                public void run() {\n+                    try {\n+                        doClientSide();\n+                    } catch (Exception e) {\n+                        \/*\n+                         * Our client thread just died.\n+                         *\/\n+                        System.err.println(\"Client died...\");\n+                        clientException = e;\n+                    }\n+                }\n+            };\n+            clientThread.start();\n+        } else {\n+            doClientSide();\n+        }\n+    }\n+\n+    \/*\n+     * Wraps SSLSocketImpl to simulate a different JSSE implementation\n+     *\/\n+    private static SSLSocketFactory wrapSocketFactory(final SSLSocketFactory wrap) {\n+        return new SSLSocketFactory() {\n+            @Override\n+            public String[] getDefaultCipherSuites() {\n+                return wrap.getDefaultCipherSuites();\n+            }\n+            @Override\n+            public String[] getSupportedCipherSuites() {\n+                return wrap.getSupportedCipherSuites();\n+            }\n+            @Override\n+            public Socket createSocket(Socket s, String host, int port, boolean autoClose) throws IOException {\n+                final SSLSocket so = (SSLSocket) wrap.createSocket(s, host, port, autoClose);\n+                return new SSLSocket() {\n+                    @Override\n+                    public void connect(SocketAddress endpoint,\n+                                        int timeout) throws IOException {\n+                        so.connect(endpoint, timeout);\n+                    }\n+                    @Override\n+                    public String[] getSupportedCipherSuites() {\n+                        return so.getSupportedCipherSuites();\n+                    }\n+                    @Override\n+                    public String[] getEnabledCipherSuites() {\n+                        return so.getEnabledCipherSuites();\n+                    }\n+                    @Override\n+                    public void setEnabledCipherSuites(String[] suites) {\n+                        so.setEnabledCipherSuites(suites);\n+                    }\n+                    @Override\n+                    public String[] getSupportedProtocols() {\n+                        return so.getSupportedProtocols();\n+                    }\n+                    @Override\n+                    public String[] getEnabledProtocols() {\n+                        return so.getEnabledProtocols();\n+                    }\n+                    @Override\n+                    public void setEnabledProtocols(String[] protocols) {\n+                        so.setEnabledProtocols(protocols);\n+                    }\n+                    @Override\n+                    public SSLSession getSession() {\n+                        return so.getSession();\n+                    }\n+                    @Override\n+                    public SSLSession getHandshakeSession() {\n+                        return so.getHandshakeSession();\n+                    }\n+                    @Override\n+                    public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {\n+                        so.addHandshakeCompletedListener(listener);\n+                    }\n+                    @Override\n+                    public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {\n+                        so.removeHandshakeCompletedListener(listener);\n+                    }\n+                    @Override\n+                    public void startHandshake() throws IOException {\n+                        so.startHandshake();\n+                    }\n+                    @Override\n+                    public void setUseClientMode(boolean mode) {\n+                        so.setUseClientMode(mode);\n+                    }\n+                    @Override\n+                    public boolean getUseClientMode() {\n+                        return so.getUseClientMode();\n+                    }\n+                    @Override\n+                    public void setNeedClientAuth(boolean need) {\n+                    }\n+                    @Override\n+                    public boolean getNeedClientAuth() {\n+                        return false;\n+                    }\n+                    @Override\n+                    public void setWantClientAuth(boolean want) {\n+                    }\n+                    @Override\n+                    public boolean getWantClientAuth() {\n+                        return false;\n+                    }\n+                    @Override\n+                    public void setEnableSessionCreation(boolean flag) {\n+                        so.setEnableSessionCreation(flag);\n+                    }\n+                    @Override\n+                    public boolean getEnableSessionCreation() {\n+                        return so.getEnableSessionCreation();\n+                    }\n+                    @Override\n+                    public void close() throws IOException {\n+                        so.close();\n+                    }\n+                    @Override\n+                    public boolean isClosed() {\n+                        return so.isClosed();\n+                    }\n+                    @Override\n+                    public void shutdownInput() throws IOException {\n+                        so.shutdownInput();\n+                    }\n+                    @Override\n+                    public boolean isInputShutdown() {\n+                        return so.isInputShutdown();\n+                    }\n+                    @Override\n+                    public void shutdownOutput() throws IOException {\n+                        so.shutdownOutput();\n+                    }\n+                    @Override\n+                    public boolean isOutputShutdown() {\n+                        return so.isOutputShutdown();\n+                    }\n+                    @Override\n+                    public InputStream getInputStream() throws IOException {\n+                        return so.getInputStream();\n+                    }\n+                    @Override\n+                    public OutputStream getOutputStream() throws IOException {\n+                        return so.getOutputStream();\n+                    }\n+                    @Override\n+                    public SSLParameters getSSLParameters() {\n+                        return so.getSSLParameters();\n+                    }\n+                    @Override\n+                    public void setSSLParameters(SSLParameters params) {\n+                        so.setSSLParameters(params);\n+                    }\n+                };\n+            }\n+            @Override\n+            public Socket createSocket(String h, int p) throws IOException, UnknownHostException {\n+                return null;\n+            }\n+            @Override\n+            public Socket createSocket(String h, int p, InetAddress ipa, int lp) throws IOException, UnknownHostException {\n+                return null;\n+            }\n+            @Override\n+            public Socket createSocket(InetAddress h, int p) throws IOException {\n+                return null;\n+            }\n+            @Override\n+            public Socket createSocket(InetAddress a, int p, InetAddress l, int lp) throws IOException {\n+                return null;\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/SubjectAltNameIPv6.java","additions":396,"deletions":0,"binary":false,"changes":396,"status":"added"}]}