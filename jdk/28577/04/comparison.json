{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import sun.net.util.IPAddressUtil;\n@@ -474,1 +475,7 @@\n-                    if (!(s instanceof SSLSocketImpl)) {\n+                    if (!(s instanceof SSLSocketImpl) &&\n+                            !IPAddressUtil.isIPv4LiteralAddress(host) &&\n+                            !(host.charAt(0) == '[' && host.charAt(host.length() - 1) == ']' &&\n+                                IPAddressUtil.isIPv6LiteralAddress(host.substring(1, host.length() - 1))\n+                            )) {\n+                        \/\/ Fully qualified DNS hostname of the server, as per section 3, RFC 6066\n+                        \/\/ Literal IPv4 and IPv6 addresses are not permitted in \"HostName\".\n","filename":"src\/java.base\/share\/classes\/sun\/net\/www\/protocol\/https\/HttpsClient.java","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,361 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8369950\n+ * @summary Test that the HttpsURLConnection does not set IPv6 address literals for\n+ *          SNI hostname during TLS handshake\n+ * @library \/test\/lib\n+ * @comment Insert -Djavax.net.debug=all into the following lines to enable SSL debugging\n+ * @run main\/othervm SubjectAltNameIPv6 127.0.0.1\n+ * @run main\/othervm SubjectAltNameIPv6 [::1]\n+ *\/\n+\n+import javax.net.ssl.HandshakeCompletedListener;\n+import javax.net.ssl.HttpsURLConnection;\n+import javax.net.ssl.SSLParameters;\n+import javax.net.ssl.SSLServerSocket;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.SSLSession;\n+import javax.net.ssl.SSLSocket;\n+import javax.net.ssl.SSLSocketFactory;\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.net.InetAddress;\n+import java.net.Socket;\n+import java.net.SocketAddress;\n+import java.net.URI;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import jdk.test.lib.net.IPSupport;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jtreg.SkippedException;\n+\n+public class SubjectAltNameIPv6 {\n+\n+    \/*\n+     * Is the server ready to serve?\n+     *\/\n+    private final CountDownLatch serverReady = new CountDownLatch(1);\n+\n+    \/\/ use any free port by default\n+    volatile int serverPort = 0;\n+\n+    \/\/ stores an exception thrown by server in a separate thread\n+    volatile Exception serverException = null;\n+\n+    \/\/ SSLSocket object created by HttpsClient internally\n+    SSLSocket clientSSLSocket = null;\n+\n+    \/\/ the hostname the server socket is bound to\n+    String hostName;\n+\n+    \/*\n+     * Define the server side of the test.\n+     *\n+     * If the server prematurely exits, serverReady will be set to true\n+     * to avoid infinite hangs.\n+     *\/\n+    void doServerSide() throws Exception {\n+        SSLServerSocketFactory sslssf =\n+            new SimpleSSLContext().get().getServerSocketFactory();\n+        SSLServerSocket sslServerSocket =\n+            (SSLServerSocket) sslssf.createServerSocket(\n+                    serverPort, 0,\n+                    InetAddress.getByName(hostName));\n+        sslServerSocket.setEnabledProtocols(new String[]{\"TLSv1.3\"});\n+        serverPort = sslServerSocket.getLocalPort();\n+\n+        \/*\n+         * Signal the client, the server is ready to accept connection.\n+         *\/\n+        serverReady.countDown();\n+\n+        SSLSocket sslSocket = (SSLSocket) sslServerSocket.accept();\n+        OutputStream sslOS = sslSocket.getOutputStream();\n+        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(sslOS));\n+        bw.write(\"HTTP\/1.1 200 OK\\r\\n\\r\\n\\r\\n\");\n+        bw.flush();\n+        sslSocket.close();\n+    }\n+\n+    \/*\n+     * Define the client side of the test.\n+     *\n+     * If the server prematurely exits, serverReady will be set to true\n+     * to avoid infinite hangs.\n+     *\/\n+    void doClientSide() throws Exception {\n+\n+        \/*\n+         * Wait for server to get started.\n+         *\/\n+        boolean ready = serverReady.await(10, TimeUnit.SECONDS);\n+        if (!ready) {\n+            throw new RuntimeException(\"Server timed out.\");\n+        }\n+        if (serverException != null) {\n+            throw new RuntimeException(\"Server failed to start.\", serverException);\n+        }\n+\n+        SSLSocketFactory sf = new SimpleSSLContext().get().getSocketFactory();\n+        URI uri = new URI(\"https:\/\/\" + hostName + \":\" + serverPort + \"\/index.html\");\n+        HttpsURLConnection conn = (HttpsURLConnection)uri.toURL().openConnection();\n+\n+        \/*\n+         * Simulate an external JSSE implementation and store the client SSLSocket\n+         * used internally.\n+         *\/\n+        conn.setSSLSocketFactory(wrapSocketFactory(sf,\n+                sslSocket -> clientSSLSocket = sslSocket));\n+        conn.getInputStream();\n+\n+        var sniSN = clientSSLSocket.getSSLParameters().getServerNames();\n+        if( sniSN != null && !sniSN.isEmpty()) {\n+            throw new RuntimeException(\"SNI server name '\" +\n+                    sniSN.getFirst() + \"' must not be set.\");\n+        }\n+\n+        if (conn.getResponseCode() == -1) {\n+            throw new RuntimeException(\"getResponseCode() returns -1\");\n+        }\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!IPSupport.hasIPv6()) {\n+            throw new SkippedException(\"Skipping test - IPv6 is not supported\");\n+        }\n+        \/*\n+         * Start the tests.\n+         *\/\n+        new SubjectAltNameIPv6(args[0]);\n+    }\n+\n+    Thread serverThread = null;\n+\n+    \/*\n+     * Primary constructor, used to drive remainder of the test.\n+     *\n+     * Fork off the other side, then do your work.\n+     *\/\n+    SubjectAltNameIPv6(String host) throws Exception {\n+        hostName = host;\n+        startServer();\n+        doClientSide();\n+\n+        \/*\n+         * Wait for other side to close down.\n+         *\/\n+        serverThread.join();\n+\n+        if (serverException != null)\n+            throw serverException;\n+    }\n+\n+    void startServer() {\n+        serverThread = new Thread(() -> {\n+            try {\n+                doServerSide();\n+            } catch (Exception e) {\n+                \/*\n+                 * Our server thread just died.\n+                 *\n+                 * Store the exception and release the client.\n+                 *\/\n+                serverException = e;\n+                serverReady.countDown();\n+            }\n+        });\n+        serverThread.start();\n+    }\n+\n+    \/*\n+     * Wraps SSLSocketImpl to simulate a different JSSE implementation\n+     *\/\n+    private static SSLSocketFactory wrapSocketFactory(final SSLSocketFactory wrap, final Consumer<SSLSocket> store) {\n+        return new SSLSocketFactory() {\n+            @Override\n+            public String[] getDefaultCipherSuites() {\n+                return wrap.getDefaultCipherSuites();\n+            }\n+            @Override\n+            public String[] getSupportedCipherSuites() {\n+                return wrap.getSupportedCipherSuites();\n+            }\n+            @Override\n+            public Socket createSocket(Socket s, String host, int port, boolean autoClose)\n+                    throws IOException {\n+                final SSLSocket so =\n+                        (SSLSocket) wrap.createSocket(s, host, port, autoClose);\n+\n+                \/\/ store the underlying SSLSocket for later use\n+                store.accept(so);\n+\n+                return new SSLSocket() {\n+                    @Override\n+                    public void connect(SocketAddress endpoint,\n+                                        int timeout) throws IOException {\n+                        so.connect(endpoint, timeout);\n+                    }\n+                    @Override\n+                    public String[] getSupportedCipherSuites() {\n+                        return so.getSupportedCipherSuites();\n+                    }\n+                    @Override\n+                    public String[] getEnabledCipherSuites() {\n+                        return so.getEnabledCipherSuites();\n+                    }\n+                    @Override\n+                    public void setEnabledCipherSuites(String[] suites) {\n+                        so.setEnabledCipherSuites(suites);\n+                    }\n+                    @Override\n+                    public String[] getSupportedProtocols() {\n+                        return so.getSupportedProtocols();\n+                    }\n+                    @Override\n+                    public String[] getEnabledProtocols() {\n+                        return so.getEnabledProtocols();\n+                    }\n+                    @Override\n+                    public void setEnabledProtocols(String[] protocols) {\n+                        so.setEnabledProtocols(protocols);\n+                    }\n+                    @Override\n+                    public SSLSession getSession() {\n+                        return so.getSession();\n+                    }\n+                    @Override\n+                    public SSLSession getHandshakeSession() {\n+                        return so.getHandshakeSession();\n+                    }\n+                    @Override\n+                    public void addHandshakeCompletedListener(HandshakeCompletedListener listener) {\n+                        so.addHandshakeCompletedListener(listener);\n+                    }\n+                    @Override\n+                    public void removeHandshakeCompletedListener(HandshakeCompletedListener listener) {\n+                        so.removeHandshakeCompletedListener(listener);\n+                    }\n+                    @Override\n+                    public void startHandshake() throws IOException {\n+                        so.startHandshake();\n+                    }\n+                    @Override\n+                    public void setUseClientMode(boolean mode) {\n+                        so.setUseClientMode(mode);\n+                    }\n+                    @Override\n+                    public boolean getUseClientMode() {\n+                        return so.getUseClientMode();\n+                    }\n+                    @Override\n+                    public void setNeedClientAuth(boolean need) {\n+                    }\n+                    @Override\n+                    public boolean getNeedClientAuth() {\n+                        return false;\n+                    }\n+                    @Override\n+                    public void setWantClientAuth(boolean want) {\n+                    }\n+                    @Override\n+                    public boolean getWantClientAuth() {\n+                        return false;\n+                    }\n+                    @Override\n+                    public void setEnableSessionCreation(boolean flag) {\n+                        so.setEnableSessionCreation(flag);\n+                    }\n+                    @Override\n+                    public boolean getEnableSessionCreation() {\n+                        return so.getEnableSessionCreation();\n+                    }\n+                    @Override\n+                    public void close() throws IOException {\n+                        so.close();\n+                    }\n+                    @Override\n+                    public boolean isClosed() {\n+                        return so.isClosed();\n+                    }\n+                    @Override\n+                    public void shutdownInput() throws IOException {\n+                        so.shutdownInput();\n+                    }\n+                    @Override\n+                    public boolean isInputShutdown() {\n+                        return so.isInputShutdown();\n+                    }\n+                    @Override\n+                    public void shutdownOutput() throws IOException {\n+                        so.shutdownOutput();\n+                    }\n+                    @Override\n+                    public boolean isOutputShutdown() {\n+                        return so.isOutputShutdown();\n+                    }\n+                    @Override\n+                    public InputStream getInputStream() throws IOException {\n+                        return so.getInputStream();\n+                    }\n+                    @Override\n+                    public OutputStream getOutputStream() throws IOException {\n+                        return so.getOutputStream();\n+                    }\n+                    @Override\n+                    public SSLParameters getSSLParameters() {\n+                        return so.getSSLParameters();\n+                    }\n+                    @Override\n+                    public void setSSLParameters(SSLParameters params) {\n+                        so.setSSLParameters(params);\n+                    }\n+                };\n+            }\n+            @Override\n+            public Socket createSocket(String h, int p) {\n+                return null;\n+            }\n+            @Override\n+            public Socket createSocket(String h, int p, InetAddress ipa, int lp) {\n+                return null;\n+            }\n+            @Override\n+            public Socket createSocket(InetAddress h, int p) {\n+                return null;\n+            }\n+            @Override\n+            public Socket createSocket(InetAddress a, int p, InetAddress l, int lp) {\n+                return null;\n+            }\n+        };\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/HttpsURLConnection\/SubjectAltNameIPv6.java","additions":361,"deletions":0,"binary":false,"changes":361,"status":"added"}]}