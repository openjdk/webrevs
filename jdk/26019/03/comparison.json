{"files":[{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.ref.Reference;\n@@ -31,2 +32,0 @@\n-import java.lang.ref.Reference;\n-import java.util.concurrent.StructuredTaskScope;\n@@ -34,0 +33,2 @@\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.function.IntSupplier;\n@@ -37,0 +38,1 @@\n+import jdk.internal.vm.ScopedValueContainer;\n@@ -39,1 +41,1 @@\n-import jdk.internal.vm.ScopedValueContainer;\n+import jdk.internal.vm.annotation.Stable;\n@@ -247,0 +249,3 @@\n+    @Stable\n+    static IntSupplier hashGenerator;\n+\n@@ -529,1 +534,1 @@\n-        this.hash = generateKey();\n+        this.hash = hashGenerator != null ? hashGenerator.getAsInt() : generateKey();\n@@ -555,1 +560,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -559,1 +564,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -583,1 +588,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -587,1 +592,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -691,4 +696,4 @@\n-    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has full period, so\n-    \/\/ it generates 2**32 - 1 hashes before it repeats. We're going to use the lowest n bits\n-    \/\/ and the next n bits as cache indexes, so we make sure that those indexes map\n-    \/\/ to different slots in the cache.\n+    \/\/ A Marsaglia xor-shift generator used to generate hashes. This one has\n+    \/\/ full period, so it generates 2**32 - 1 hashes before it repeats. We're\n+    \/\/ going to use the lowest n bits and the next n bits as cache indexes, so\n+    \/\/ we make sure that those indexes map to different slots in the cache.\n@@ -701,1 +706,1 @@\n-        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        } while (((Cache.primaryIndex(x) ^ Cache.secondaryIndex(x)) & 1) == 0);\n@@ -712,1 +717,1 @@\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+        return (1 << Cache.primaryIndex(hash)) | (1 << (Cache.secondaryIndex(hash) + Cache.TABLE_SIZE));\n@@ -730,18 +735,62 @@\n-        \/\/ The number of elements in the cache array, and a bit mask used to\n-        \/\/ select elements from it.\n-        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n-        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n-        \/\/ or equal to 2.\n-        private static final int MAX_CACHE_SIZE = 16;\n-\n-        static {\n-            final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n-            var sizeString = System.getProperty(propertyName, \"16\");\n-            var cacheSize = Integer.valueOf(sizeString);\n-            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n-            }\n-            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+\n+        \/\/ This class serves to defer initialization of some values until they\n+        \/\/ are needed. In particular, we must not invoke System.getProperty\n+        \/\/ early in the JDK boot process, because that leads to a circular class\n+        \/\/ initialization dependency.\n+        \/\/\n+        \/\/ In more detail:\n+        \/\/\n+        \/\/  The size of the cache depends on System.getProperty. Generating the\n+        \/\/  hash of an instance of ScopedValue depends on ThreadLocalRandom.\n+        \/\/\n+        \/\/  Invoking either of these early in the JDK boot process will cause\n+        \/\/  startup to fail with an unrecoverable circular dependency.\n+        \/\/\n+        \/\/ To break these cycles we allow scoped values to be created (but not\n+        \/\/ used) without invoking either System.getProperty or\n+        \/\/ ThreadLocalRandom. To do this we defer querying System.getProperty\n+        \/\/ until the first reference to CACHE_TABLE_SIZE, and we define a local\n+        \/\/ hash generator which is used until CACHE_TABLE_SIZE is initialized.\n+\n+        private static class Constants {\n+            \/\/ The number of elements in the cache array, and a bit mask used to\n+            \/\/ select elements from it.\n+            private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+            \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+            \/\/ or equal to 2.\n+            private static final int MAX_CACHE_SIZE = 16;\n+\n+            private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n+            static {\n+                final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n+                var sizeString = System.getProperty(propertyName, \"16\");\n+                var cacheSize = Integer.valueOf(sizeString);\n+                if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+                }\n+                if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+                }\n+                CACHE_TABLE_SIZE = cacheSize;\n+                SLOT_MASK = cacheSize - 1;\n+\n+                \/\/ hashGenerator is set here in order not to initialize\n+                \/\/ j.u.c.ThreadLocalRandom early in the JDK boot process.\n+                \/\/ After this static initialization, new instances of\n+                \/\/ ScopedValue will be initialized by a thread-local\n+                \/\/ random generator.\n+                hashGenerator = new IntSupplier() {\n+                    @Override\n+                    public int getAsInt() {\n+                        int x;\n+                        do {\n+                            x = THREAD_LOCAL_RANDOM_ACCESS\n+                                .nextSecondaryThreadLocalRandomSeed();\n+                        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+                        return x;\n+                    }\n+                };\n@@ -749,2 +798,0 @@\n-            CACHE_TABLE_SIZE = cacheSize;\n-            SLOT_MASK = cacheSize - 1;\n@@ -753,2 +800,2 @@\n-        static int primaryIndex(ScopedValue<?> key) {\n-            return key.hash & TABLE_MASK;\n+        static int primaryIndex(int hash) {\n+            return hash & Cache.TABLE_MASK;\n@@ -757,2 +804,2 @@\n-        static int secondaryIndex(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        static int secondaryIndex(int hash) {\n+            return (hash >> INDEX_BITS) & Cache.TABLE_MASK;\n@@ -762,1 +809,1 @@\n-            return key.hashCode() & SLOT_MASK;\n+            return key.hashCode() & Constants.SLOT_MASK;\n@@ -766,1 +813,1 @@\n-            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+            return (key.hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -770,1 +817,1 @@\n-            return hash & SLOT_MASK;\n+            return hash & Constants.SLOT_MASK;\n@@ -774,1 +821,1 @@\n-            return (hash >> INDEX_BITS) & SLOT_MASK;\n+            return (hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -780,1 +827,1 @@\n-                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                theCache = new Object[Constants.CACHE_TABLE_SIZE * 2];\n@@ -816,3 +863,0 @@\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n@@ -824,1 +868,1 @@\n-            int r = THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n+            int r = Constants.THREAD_LOCAL_RANDOM_ACCESS.nextSecondaryThreadLocalRandomSeed();\n@@ -830,1 +874,1 @@\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            toClearBits = ((toClearBits >>> Cache.TABLE_SIZE) | toClearBits) & PRIMARY_MASK;\n@@ -835,1 +879,1 @@\n-                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    setKeyAndObjectAt(objects, index & Constants.SLOT_MASK, null, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":93,"deletions":49,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -83,0 +83,10 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandUnboundQueries(Blackhole bh) throws Exception {\n+        var result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.unbound.isBound() ? 1 : 0;\n+        }\n+        return result;\n+    }\n+\n@@ -216,0 +226,7 @@\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object newInstance() {\n+        ScopedValue<Integer> val = ScopedValue.newInstance();\n+        return val;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValues.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -60,1 +60,0 @@\n-            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n@@ -64,1 +63,4 @@\n-                  .run(action);\n+                  .run(() -> {\n+                      sl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+                      action.run();\n+                  });\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesData.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"}]}