{"files":[{"patch":"@@ -34,0 +34,1 @@\n+import java.util.function.IntSupplier;\n@@ -242,0 +243,3 @@\n+    private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n+        = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n+\n@@ -529,1 +533,1 @@\n-        this.hash = generateKey();\n+        this.hash = hashGenerator.getAsInt();\n@@ -555,1 +559,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -559,1 +563,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -583,1 +587,1 @@\n-            int n = (hash & Cache.SLOT_MASK) * 2;\n+            int n = (hash & Cache.Constants.SLOT_MASK) * 2;\n@@ -587,1 +591,1 @@\n-            n = ((hash >>> Cache.INDEX_BITS) & Cache.SLOT_MASK) * 2;\n+            n = ((hash >>> Cache.INDEX_BITS) & Cache.Constants.SLOT_MASK) * 2;\n@@ -701,1 +705,1 @@\n-        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+        } while (((Cache.primaryIndex(x) ^ Cache.secondaryIndex(x)) & 1) == 0);\n@@ -705,0 +709,10 @@\n+    \/\/ This method exists only so that we can generate keys early in\n+    \/\/ the boot cycle, before the class j.u.c.ThreadLocalRandom has\n+    \/\/ been initialized.\n+    private static IntSupplier hashGenerator = new IntSupplier() {\n+        @Override\n+        public int getAsInt() {\n+            return generateKey();\n+        }\n+    };\n+\n@@ -712,1 +726,1 @@\n-        return (1 << Cache.primaryIndex(this)) | (1 << (Cache.secondaryIndex(this) + Cache.TABLE_SIZE));\n+        return (1 << Cache.primaryIndex(hash)) | (1 << (Cache.secondaryIndex(hash) + Cache.TABLE_SIZE));\n@@ -730,18 +744,42 @@\n-        \/\/ The number of elements in the cache array, and a bit mask used to\n-        \/\/ select elements from it.\n-        private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n-        \/\/ The largest cache we allow. Must be a power of 2 and greater than\n-        \/\/ or equal to 2.\n-        private static final int MAX_CACHE_SIZE = 16;\n-\n-        static {\n-            final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n-            var sizeString = System.getProperty(propertyName, \"16\");\n-            var cacheSize = Integer.valueOf(sizeString);\n-            if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" is out of range: is \" + sizeString);\n-            }\n-            if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n-                cacheSize = MAX_CACHE_SIZE;\n-                System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+        \/\/ This class serves to defer initialization of some values\n+        \/\/ until they are needed. In particular, we must not invoke\n+        \/\/ System.getProperty early in the JVM boot process.\n+        private static class Constants {\n+            \/\/ The number of elements in the cache array, and a bit mask used to\n+            \/\/ select elements from it.\n+            private static final int CACHE_TABLE_SIZE, SLOT_MASK;\n+            \/\/ The largest cache we allow. Must be a power of 2 and greater than\n+            \/\/ or equal to 2.\n+            private static final int MAX_CACHE_SIZE = 16;\n+\n+            static {\n+                final String propertyName = \"java.lang.ScopedValue.cacheSize\";\n+                var sizeString = System.getProperty(propertyName, \"16\");\n+                var cacheSize = Integer.valueOf(sizeString);\n+                if (cacheSize < 2 || cacheSize > MAX_CACHE_SIZE) {\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" is out of range: is \" + sizeString);\n+                }\n+                if ((cacheSize & (cacheSize - 1)) != 0) {  \/\/ a power of 2\n+                    cacheSize = MAX_CACHE_SIZE;\n+                    System.err.println(propertyName + \" must be an integer power of 2: is \" + sizeString);\n+                }\n+                CACHE_TABLE_SIZE = cacheSize;\n+                SLOT_MASK = cacheSize - 1;\n+\n+                \/\/ hashGenerator is set here in order not to initialize\n+                \/\/ j.u.c.ThreadLocalRandom early in the JDK boot\n+                \/\/ process. After this static initialization block,\n+                \/\/ new instances of ScopedValue will be initialized by a\n+                \/\/ thread-local random generator.\n+                hashGenerator = new IntSupplier() {\n+                    @Override\n+                    public int getAsInt() {\n+                        int x;\n+                        do {\n+                            x = THREAD_LOCAL_RANDOM_ACCESS\n+                                .nextSecondaryThreadLocalRandomSeed();\n+                        } while (Cache.primarySlot(x) == Cache.secondarySlot(x));\n+                        return x;\n+                    }\n+                };\n@@ -749,2 +787,0 @@\n-            CACHE_TABLE_SIZE = cacheSize;\n-            SLOT_MASK = cacheSize - 1;\n@@ -753,2 +789,2 @@\n-        static int primaryIndex(ScopedValue<?> key) {\n-            return key.hash & TABLE_MASK;\n+        static int primaryIndex(int hash) {\n+            return hash & Cache.TABLE_MASK;\n@@ -757,2 +793,2 @@\n-        static int secondaryIndex(ScopedValue<?> key) {\n-            return (key.hash >> INDEX_BITS) & TABLE_MASK;\n+        static int secondaryIndex(int hash) {\n+            return (hash >> INDEX_BITS) & Cache.TABLE_MASK;\n@@ -762,1 +798,1 @@\n-            return key.hashCode() & SLOT_MASK;\n+            return key.hashCode() & Constants.SLOT_MASK;\n@@ -766,1 +802,1 @@\n-            return (key.hash >> INDEX_BITS) & SLOT_MASK;\n+            return (key.hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -770,1 +806,1 @@\n-            return hash & SLOT_MASK;\n+            return hash & Constants.SLOT_MASK;\n@@ -774,1 +810,1 @@\n-            return (hash >> INDEX_BITS) & SLOT_MASK;\n+            return (hash >> INDEX_BITS) & Constants.SLOT_MASK;\n@@ -780,1 +816,1 @@\n-                theCache = new Object[CACHE_TABLE_SIZE * 2];\n+                theCache = new Object[Constants.CACHE_TABLE_SIZE * 2];\n@@ -816,3 +852,0 @@\n-        private static final JavaUtilConcurrentTLRAccess THREAD_LOCAL_RANDOM_ACCESS\n-                = SharedSecrets.getJavaUtilConcurrentTLRAccess();\n-\n@@ -830,1 +863,1 @@\n-            toClearBits = (toClearBits >>> TABLE_SIZE) | (toClearBits & PRIMARY_MASK);\n+            toClearBits = ((toClearBits >>> Cache.TABLE_SIZE) | toClearBits) & PRIMARY_MASK;\n@@ -835,1 +868,1 @@\n-                    setKeyAndObjectAt(objects, index & SLOT_MASK, null, null);\n+                    setKeyAndObjectAt(objects, index & Constants.SLOT_MASK, null, null);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":74,"deletions":41,"binary":false,"changes":115,"status":"modified"},{"patch":"@@ -83,0 +83,10 @@\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public int thousandUnboundQueries(Blackhole bh) throws Exception {\n+        var result = 0;\n+        for (int i = 0; i < 1_000; i++) {\n+            result += ScopedValuesData.unbound.isBound() ? 1 : 0;\n+        }\n+        return result;\n+    }\n+\n@@ -216,0 +226,7 @@\n+\n+    @Benchmark\n+    @OutputTimeUnit(TimeUnit.NANOSECONDS)\n+    public Object newInstance() {\n+        ScopedValue<Integer> val = ScopedValue.newInstance();\n+        return val;\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValues.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            tl1.get();  \/\/ Create the ScopedValue cache as a side effect\n+            sl1.get();  \/\/ Create the ScopedValue cache as a side effect\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/ScopedValuesData.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}