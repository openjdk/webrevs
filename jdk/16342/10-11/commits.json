[{"commit":{"message":"Merge tag 'jdk-22+22' into 8318706-implementation-of-region-pinning-in-g1\n\nAdded tag jdk-22+22 for changeset d354141a"},"files":[],"sha":"2ad396804a97c9304237cddc61948e9bf8cafb5e"},{"commit":{"message":"Merge tag 'jdk-22+21' into 8318706-implementation-of-region-pinning-in-g1\n\nAdded tag jdk-22+21 for changeset d96f38b8"},"files":[],"sha":"251f4d38a927602c20313a248991113063810e9a"},{"commit":{"message":"iwalulya review"},"files":[],"sha":"d0c2c3f5c5f868a041635a6fd83c2b7bad54e3e3"},{"commit":{"message":"typos"},"files":[],"sha":"f973553923a66dae0a4cfaa5d1814391c5914df1"},{"commit":{"message":"ayang review - renamings + documentation"},"files":[],"sha":"8342b80ba3dbe823970f520d05b1b89704be7e55"},{"commit":{"message":"Add documentation about why and how we handle pinned regions in the young\/old generation."},"files":[],"sha":"5ae05e4c697285158b99d7a61d46762241feaa21"},{"commit":{"message":"Renamings to (almost) consistently use the following nomenclature for evacuation failure and types of it:\n\n* evacuation failure is the general concept. It includes\n  * pinned regions\n  * allocation failure\n\nOne region can both be pinned and experience an allocation failure.\n\nG1 GC messages use tags \"(Pinned)\" and \"(Allocation Failure)\" now instead of \"(Evacuation Failure)\"\n\nDid not rename the G1EvacFailureInjector since this adds a lot of noise."},"files":[],"sha":"73f61da9a6e32082155ea310481dc69ffd14b133"},{"commit":{"message":"NULL -> nullptr"},"files":[],"sha":"fb1deac423c7aa320e3892c7404a3da3ed232f0c"},{"commit":{"message":"Fix compilation"},"files":[],"sha":"e5dfbb73f8c05d484e7fefc88568ecf0de1d2f22"},{"commit":{"message":"Improve TestPinnedOldObjectsEvacuation test"},"files":[],"sha":"78cb9df060a04b5465337c19f75fb9db85ece025"},{"commit":{"message":"Move tests into gc.g1.pinnedobjs package"},"files":[],"sha":"1b1d8ba9dad88224632bfb1691541c67418518dd"},{"commit":{"message":"ayang review1"},"files":[],"sha":"e66463995fe6986124f50370053663ecbf40c9f0"},{"commit":{"message":"Improve somewhat unstable test"},"files":[],"sha":"b882dd60cbbdd9fa5c6fe61ca20e320803332dfb"},{"commit":{"message":"Fix typo in src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/gc\/g1\/HeapRegion.java so that resourcehogs\/serviceability\/sa\/ClhsdbRegionDetailsScanOopsForG1.java does not fail"},"files":[],"sha":"fddb8912081c3584ed7785ad1d841d6b294ec07d"},{"commit":{"message":"Fix minimal build"},"files":[],"sha":"8b9e9a0e3a4ae148214c4e80c8219206b91d403a"},{"commit":{"message":"Region pinning in G1\/JEP-423\n\nThe JEP covers the idea very well, so I'm only covering some implementation details here:\n\n* regions get a \"pin count\" (reference count). As long as it is non-zero, we conservatively\n  never reclaim that region even if there is no reference in there. JNI code might have\n  references to it.\n\n* the JNI spec only requires us to provide pinning support for typeArrays, nothing else.\n  This implementation uses this in various ways:\n\n  * when evacuating from a pinned region, we evacuate everything live but the typeArrays to\n    get more empty regions to clean up later.\n\n  * when formatting dead space within pinned regions we use filler objects. Pinned regions\n    may be referenced by JNI code only, so we can't overwrite contents of any dead typeArray\n    either.\n    These dead but referenced typeArrays luckily have the same header size of our filler\n    objects, so we can use their headers for our fillers. The problem is that previously\n    there has been that restriction that filler objects are half a region size at most, so\n    we can end up with the need for placing a filler object header inside a typeArray.\n    The code could be clever and handle this situation by splitting the to be filled area\n    so that this can't happen, but the solution taken here is allowing filler arrays to\n    cover a whole region. They are not referenced by Java code anyway, so there is no harm\n    in doing so (i.e. gc code never touches them anyway).\n\n* G1 currently only ever actually evacuates young pinned regions. Old pinned regions of any kind\n  are never put into the collection set and automatically skipped. However assuming that the\n  pinning is of short length, we put them into the candidates when we can.\n\n  * there is the problem that if an applications pins a region for a long time g1 will skip\n    evacuating that region over and over. that may lead to issues with the current policy\n    in marking regions (only exit mixed phase when there are no marking candidates) and\n    just waste of processing time (when the candidate stays in the retained candidates)\n\n    The cop-out chosen here is to \"age out\" the regions from the candidates and wait until\n    the next marking happens.\n\n    I.e. pinned marking candidates are immediately moved to retained candidates, and if\n    in total the region has been pinned for `G1NumCollectionsKeepUnreclaimable` collections\n    it is dropped from the candidates. Its current value is fairly random.\n\n* G1 pauses got a new tag if there were pinned regions in the collection set. I.e. in addition\n  to something like:\n\n`GC(6) Pause Young (Normal) (Evacuation Failure) 1M->1M(22M) 36.16ms`\n\n  there is that new tag `(Pinned)` that indicates that one or more regions that were pinned\n  were encountered during gc. E.g.\n\n`GC(6) Pause Young (Normal) (Pinned) (Evacuation Failure) 1M->1M(22M) 36.16ms`\n\n  `Pinned` and `Evacuation Failure` tags are not exclusive. GC might have encountered both pinned\n  regions and evacuation failed regions in the same collection or even in the same region.\n\nwhitespace fixes"},"files":[],"sha":"44d430a3ed54da2aa7d9adeaca37a309add96824"}]