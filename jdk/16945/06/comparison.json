{"files":[{"patch":"@@ -44,0 +44,3 @@\n+  bool use_caller = task->caller_can_run();\n+  uint num_worker_tasks = use_caller ? (num_workers - 1) : num_workers;\n+\n@@ -48,2 +51,9 @@\n-  \/\/ Dispatch 'num_workers' number of tasks.\n-  _start_semaphore.signal(num_workers);\n+  \/\/ Dispatch tasks to workers.\n+  if (num_worker_tasks > 0) {\n+    _start_semaphore.signal(num_worker_tasks);\n+  }\n+\n+  \/\/ If possible, execute tasks in caller.\n+  if (use_caller) {\n+    caller_run_task();\n+  }\n@@ -60,0 +70,8 @@\n+void WorkerTaskDispatcher::caller_run_task() {\n+  \/\/ Run at least one task in the caller.\n+  \/\/ Then see if we have other tasks that caller can run.\n+  do {\n+    internal_run_task(false);\n+  } while (_start_semaphore.trywait());\n+}\n+\n@@ -63,0 +81,2 @@\n+  internal_run_task(true);\n+}\n@@ -64,0 +84,1 @@\n+void WorkerTaskDispatcher::internal_run_task(bool is_worker) {\n@@ -66,1 +87,3 @@\n-  WorkerThread::set_worker_id(worker_id);\n+  if (is_worker) {\n+    WorkerThread::set_worker_id(worker_id);\n+  }\n@@ -69,2 +92,6 @@\n-  GCIdMark gc_id_mark(_task->gc_id());\n-  _task->work(worker_id);\n+  if (is_worker || Thread::current()->is_Named_thread()) {\n+    GCIdMark gc_id_mark(_task->gc_id());\n+    _task->work(worker_id);\n+  } else {\n+    _task->work(worker_id);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.cpp","additions":32,"deletions":5,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+  const bool _caller_can_run;\n@@ -45,2 +46,2 @@\n- public:\n-  explicit WorkerTask(const char* name) :\n+public:\n+  explicit WorkerTask(const char* name, bool caller_can_run = false) :\n@@ -48,1 +49,2 @@\n-    _gc_id(GCId::current_or_undefined()) {}\n+    _gc_id(GCId::current_or_undefined()),\n+    _caller_can_run(caller_can_run) {}\n@@ -52,0 +54,1 @@\n+  bool caller_can_run() const { return _caller_can_run; }\n@@ -81,0 +84,3 @@\n+  void caller_run_task();\n+\n+  \/\/ Sees if there is a task and runs it.\n@@ -82,0 +88,2 @@\n+\n+  void internal_run_task(bool is_worker);\n","filename":"src\/hotspot\/share\/gc\/shared\/workerThread.hpp","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/workerThread.hpp\"\n+#include \"memory\/universe.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/thread.hpp\"\n+#include \"utilities\/numberSeq.hpp\"\n+#include \"utilities\/spinYield.hpp\"\n+#include \"unittest.hpp\"\n+\n+\n+class ParallelTask : public WorkerTask {\n+protected:\n+  const uint _expected_workers;\n+  volatile uint _actual_workers;\n+  volatile uint _actual_ids_bitset;\n+  const Thread* _caller_thread;\n+  bool _seen_caller;\n+\n+public:\n+  ParallelTask(int expected_workers, bool can_caller_execute) :\n+      WorkerTask(\"Parallel Task\", can_caller_execute),\n+      _expected_workers(expected_workers),\n+      _actual_workers(0),\n+      _actual_ids_bitset(0),\n+      _caller_thread(Thread::current()),\n+      _seen_caller(false) {}\n+\n+  void record_worker(uint worker_id) {\n+    if (!_seen_caller && Thread::current() == _caller_thread) {\n+      _seen_caller = true;\n+    }\n+    while (true) {\n+      uint cur_ids = Atomic::load(&_actual_ids_bitset);\n+      uint new_ids = cur_ids | (1 << worker_id);\n+      if (cur_ids == new_ids) {\n+        return;\n+      }\n+      if (Atomic::cmpxchg(&_actual_ids_bitset, cur_ids, new_ids) == cur_ids) {\n+        return;\n+      }\n+    }\n+  }\n+\n+  void work(uint worker_id) {\n+    record_worker(worker_id);\n+\n+    Atomic::inc(&_actual_workers);\n+    SpinYield sp;\n+    while (Atomic::load(&_actual_workers) < _expected_workers) {\n+      sp.wait();\n+    }\n+  }\n+\n+  uint actual_workers() {\n+    return Atomic::load(&_actual_workers);\n+  }\n+\n+  uint actual_ids_bitset() {\n+    return Atomic::load(&_actual_ids_bitset);\n+  }\n+\n+  bool seen_caller() {\n+    return _seen_caller;\n+  }\n+};\n+\n+class PerfTask : public WorkerTask {\n+public:\n+  PerfTask(bool can_caller_execute) :\n+    WorkerTask(\"Parallel Perf Task\", can_caller_execute) {}\n+\n+  void work(uint worker_id) {\n+    \/\/ Do nothing, pretend the work is very small.\n+  }\n+};\n+\n+static uint expected_ids_bitset(int expected_workers) {\n+  return (1 << expected_workers) - 1;\n+}\n+\n+static void basic_run_with(WorkerThreads* workers, uint num_workers, bool caller_runs) {\n+  ParallelTask task(num_workers, caller_runs);\n+  workers->run_task(&task);\n+  EXPECT_EQ(num_workers, task.actual_workers());\n+  EXPECT_EQ(expected_ids_bitset(num_workers), task.actual_ids_bitset());\n+  if (!caller_runs) {\n+    EXPECT_FALSE(task.seen_caller());\n+  }\n+}\n+\n+TEST_VM(WorkerThreads, basic) {\n+  static const int TRIES = 1000;\n+  static const uint MAX_WORKERS = MIN2(31, os::processor_count()); \/\/ ID bitmap limits the max CPU\n+\n+  WorkerThreads* workers = new WorkerThreads(\"test\", MAX_WORKERS);\n+  workers->initialize_workers();\n+\n+  for (uint w = 1; w <= MAX_WORKERS; w++) {\n+    tty->print_cr(\"Test with %u workers\", w);\n+    workers->set_active_workers(w);\n+    for (int t = 0; t < TRIES; t++) {\n+      basic_run_with(workers, w, false);\n+      basic_run_with(workers, w, true);\n+    }\n+  }\n+}\n+\n+static void perf_iteration(WorkerThreads* workers, bool caller_runs) {\n+  static const int TRIES = 10000;\n+  NumberSeq seq;\n+\n+  for (int t = 0; t < TRIES; t++) {\n+    PerfTask task(caller_runs);\n+    jlong start = os::javaTimeNanos();\n+    workers->run_task(&task);\n+    seq.add(os::javaTimeNanos() - start);\n+  }\n+\n+  tty->print_cr(\"    %12.3f us total; %10.3f us avg; %10.3f us max\", seq.sum() \/ 1000, seq.sum() \/ TRIES \/ 1000, seq.maximum() \/ 1000);\n+}\n+\n+TEST_VM(WorkerThreads, perf) {\n+  static const int ITERS = 5;\n+  static const uint MAX_WORKERS = os::processor_count();\n+\n+  WorkerThreads* workers = new WorkerThreads(\"test\", MAX_WORKERS);\n+  workers->initialize_workers();\n+\n+  for (uint w = MAX_WORKERS; w > 0; w \/= 2) {\n+    workers->set_active_workers(w);\n+    tty->print_cr(\"Test with %u workers:\", w);\n+    tty->print_cr(\"  only workers:\");\n+    for (int i = 0; i < ITERS; i++) {\n+      perf_iteration(workers, false);\n+    }\n+    tty->print_cr(\"  workers + caller:\");\n+    for (int i = 0; i < ITERS; i++) {\n+      perf_iteration(workers, true);\n+    }\n+    tty->cr();\n+  }\n+}\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_workerThreads.cpp","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"}]}