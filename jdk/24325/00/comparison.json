{"files":[{"patch":"@@ -2576,5 +2576,4 @@\n-        \/\/ now transform the new nodes, and return the mergemem\n-        for (MergeMemStream mms(result); mms.next_non_empty(); ) {\n-          Node* phi = mms.memory();\n-          mms.set_memory(phase->transform(phi));\n-        }\n+        \/\/ We could immediately transform the new Phi nodes here, but that can\n+        \/\/ result in creating an excessive number of new nodes within a single\n+        \/\/ IGVN iteration. We have put the Phi nodes on the IGVN worklist, so\n+        \/\/ they are transformed later on in any case.\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":4,"deletions":5,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1027,0 +1027,7 @@\n+  \/\/ The node count check in the loop below (check_node_count) assumes that we\n+  \/\/ increase the live node count with at most\n+  \/\/ max_live_nodes_increase_per_iteration in between checks. If this\n+  \/\/ assumption does not hold, there is a risk that we exceed the max node\n+  \/\/ limit in between checks and trigger an assert during node creation.\n+  const int max_live_nodes_increase_per_iteration = NodeLimitFudgeFactor * 2;\n+\n@@ -1031,1 +1038,1 @@\n-    if (C->check_node_count(NodeLimitFudgeFactor * 2, \"Out of nodes\")) {\n+    if (C->check_node_count(max_live_nodes_increase_per_iteration, \"Out of nodes\")) {\n@@ -1046,0 +1053,1 @@\n+      DEBUG_ONLY(int live_nodes_before = C->live_nodes();)\n@@ -1047,0 +1055,8 @@\n+      DEBUG_ONLY(int live_nodes_after = C->live_nodes();)\n+      \/\/ Ensure we did not increase the live node count with more than\n+      \/\/ max_live_nodes_increase_per_iteration during the call to transform_old\n+      DEBUG_ONLY(int increase = live_nodes_after - live_nodes_before;)\n+      assert(increase < max_live_nodes_increase_per_iteration,\n+             \"excessive live node increase in single iteration of IGVN: %d \"\n+             \"(should be at most %d)\",\n+             increase, max_live_nodes_increase_per_iteration);\n","filename":"src\/hotspot\/share\/opto\/phaseX.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+  compiler\/itergvn\/ \\\n","filename":"test\/hotspot\/jtreg\/TEST.groups","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,70 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8351833\n+ * @summary Splitting Phi memory nodes through MergeMem nodes in PhiNode::Ideal\n+ *          could sometimes result in a too large number of added nodes within\n+ *          a single iteration of the main loop in PhaseIterGVN::optimize. This\n+ *          test, reduced from TestScalarReplacementMaxLiveNodes, triggers an\n+ *          assert added as part of the fix for the linked bug\/issue (the\n+ *          assert naturally triggers only before the fix). The test's ability\n+ *          to trigger the issue is quite sensitive to the specific String\n+ *          constants used. The current set of chosen String constants happened\n+ *          to work particularly well.\n+ * @run main\/othervm -Xbatch\n+ *                   -XX:CompileCommand=CompileOnly,compiler.itergvn.TestSplitPhiThroughMergeMem::test\n+ *                   compiler.itergvn.TestSplitPhiThroughMergeMem\n+ * @run main compiler.itergvn.TestSplitPhiThroughMergeMem\n+ *\/\n+\n+package compiler.itergvn;\n+\n+public class TestSplitPhiThroughMergeMem {\n+\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 10_000; i++) {\n+            int val = i % 50;\n+            test(val == 0, val % 10, val % 20);\n+        }\n+    }\n+\n+    static void test(boolean flag, int param1, int param2) {\n+        if (flag) {\n+            new String(\"tenth\" + param1);\n+            new String(\"eleventh\" + param2);\n+            new String(\"fifteenth\" + param2);\n+            new String(\"sixteenth\" + param1);\n+            new String(\"seventeenth\" + param1);\n+            new String(\"nineteenth\" + param2);\n+            new String(\"tweenth\" + param1);\n+            new String(\"nineth\" + param1);\n+            new String(\"nineth\" + param1);\n+            new String(\"eighteenth\" + param1);\n+            new String(\"abcdef\" + param2);\n+            new String(\"ghijklmn\" + param1);\n+            new String(\"ghijklmn\" + param1);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/itergvn\/TestSplitPhiThroughMergeMem.java","additions":70,"deletions":0,"binary":false,"changes":70,"status":"added"}]}