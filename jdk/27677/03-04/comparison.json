{"files":[{"patch":"@@ -1447,9 +1447,2 @@\n-                    \/\/ NewSessionTicket message presence in the final flight\n-                    \/\/ should only be expected on the client side, and only\n-                    \/\/ if stateless resumption is enabled.\n-                    boolean isReady = hasFinishedMessage(bufferedFragments)\n-                            && (!tc.sslConfig.isClientMode\n-                            || !tc.handshakeContext.statelessResumption\n-                            || hasCompleted(\n-                            SSLHandshake.NEW_SESSION_TICKET.id));\n-\n+                    \/\/ Have the ChangeCipherSpec\/Finished flight been received?\n+                    boolean isReady = hasFinishedMessage();\n@@ -1457,2 +1450,3 @@\n-                        SSLLogger.fine(\"Has the final flight been received? \"\n-                                + isReady);\n+                        SSLLogger.fine(\n+                                \"Has the final flight been received? \"\n+                                        + isReady);\n@@ -1502,1 +1496,1 @@\n-                if (hasFinishedMessage(bufferedFragments)) {\n+                if (hasFinishedMessage()) {\n@@ -1575,1 +1569,1 @@\n-                if (!hasFinishedMessage(bufferedFragments)) {\n+                if (!hasFinishedMessage()) {\n@@ -1611,1 +1605,2 @@\n-        \/\/ Looking for the ChangeCipherSpec and Finished messages.\n+        \/\/ Looking for the ChangeCipherSpec, Finished and\n+        \/\/ NewSessionTicket messages.\n@@ -1618,2 +1613,1 @@\n-        private boolean hasFinishedMessage(Set<RecordFragment> fragments) {\n-\n+        private boolean hasFinishedMessage() {\n@@ -1622,1 +1616,2 @@\n-            for (RecordFragment fragment : fragments) {\n+\n+            for (RecordFragment fragment : bufferedFragments) {\n@@ -1624,3 +1619,0 @@\n-                    if (hasFin) {\n-                        return true;\n-                    }\n@@ -1628,8 +1620,3 @@\n-                } else if (fragment.contentType == ContentType.HANDSHAKE.id) {\n-                    \/\/ Finished is the first expected message of a new epoch.\n-                    if (fragment.isCiphertext) {\n-                        if (hasCCS) {\n-                            return true;\n-                        }\n-                        hasFin = true;\n-                    }\n+                } else if (fragment.contentType == ContentType.HANDSHAKE.id\n+                        && fragment.isCiphertext) {\n+                    hasFin = true;\n@@ -1639,1 +1626,7 @@\n-            return false;\n+            return hasCCS && hasFin\n+                    \/\/ NewSessionTicket message presence in the finished flight\n+                    \/\/ should only be expected on the client side, and only\n+                    \/\/ if stateless resumption is enabled.\n+                    && (!tc.sslConfig.isClientMode\n+                    || !tc.handshakeContext.statelessResumption\n+                    || hasCompleted(SSLHandshake.NEW_SESSION_TICKET.id));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSInputRecord.java","additions":22,"deletions":29,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n-\/\/ system properties in samevm\/agentvm mode.\n-\n@@ -64,0 +61,3 @@\n+    protected static final String HOST = \"localhost\";\n+    protected static final int CLIENT_PORT = findAvailablePort();\n+    protected static final int SERVER_PORT = findAvailablePort();\n@@ -135,2 +135,4 @@\n-        SSLContext context = getDTLSContext();\n-        SSLEngine engine = context.createSSLEngine();\n+        SSLContext context =\n+                isClient ? getClientDTLSContext() : getServerDTLSContext();\n+        SSLEngine engine = context.createSSLEngine(HOST,\n+                isClient ? CLIENT_PORT : SERVER_PORT);\n@@ -510,1 +512,1 @@\n-    SSLContext getDTLSContext() throws Exception {\n+    static SSLContext getDTLSContext() throws Exception {\n@@ -520,0 +522,8 @@\n+    protected SSLContext getServerDTLSContext() throws Exception {\n+        return getDTLSContext();\n+    }\n+\n+    protected SSLContext getClientDTLSContext() throws Exception {\n+        return getDTLSContext();\n+    }\n+\n@@ -528,4 +538,4 @@\n-        InetSocketAddress serverSocketAddress = new InetSocketAddress\n-                (InetAddress.getLoopbackAddress(), 0);\n-        InetSocketAddress clientSocketAddress = new InetSocketAddress\n-                (InetAddress.getLoopbackAddress(), 0);\n+        InetSocketAddress serverSocketAddress =\n+                new InetSocketAddress(HOST, SERVER_PORT);\n+        InetSocketAddress clientSocketAddress =\n+                new InetSocketAddress(HOST, CLIENT_PORT);\n@@ -539,6 +549,0 @@\n-            InetSocketAddress serverSocketAddr = new InetSocketAddress(\n-                    InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n-\n-            InetSocketAddress clientSocketAddr = new InetSocketAddress(\n-                    InetAddress.getLoopbackAddress(), clientSocket.getLocalPort());\n-\n@@ -549,1 +553,1 @@\n-                        testCase, serverSocket, clientSocketAddr));\n+                    testCase, serverSocket, clientSocketAddress));\n@@ -552,1 +556,1 @@\n-            runClient(testCase, clientSocket, serverSocketAddr);\n+            runClient(testCase, clientSocket, serverSocketAddress);\n@@ -623,0 +627,8 @@\n+\n+    static int findAvailablePort() {\n+        try (var socket = new DatagramSocket(0)) {\n+            return socket.getLocalPort();\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSOverDatagram.java","additions":30,"deletions":18,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n-\/\/ system properties in samevm\/agentvm mode.\n-\n@@ -35,12 +32,20 @@\n- * @run main\/othervm PacketLossRetransmission client 1 client_hello\n- * @run main\/othervm PacketLossRetransmission client 16 client_key_exchange\n- * @run main\/othervm PacketLossRetransmission client 20 finished\n- * @run main\/othervm PacketLossRetransmission client -1 change_cipher_spec\n- * @run main\/othervm PacketLossRetransmission server 2 server_hello\n- * @run main\/othervm PacketLossRetransmission server 3 hello_verify_request\n- * @run main\/othervm PacketLossRetransmission server 11 certificate\n- * @run main\/othervm PacketLossRetransmission server 12 server_key_exchange\n- * @run main\/othervm PacketLossRetransmission server 14 server_hello_done\n- * @run main\/othervm PacketLossRetransmission server 20 finished\n- * @run main\/othervm PacketLossRetransmission server -1 change_cipher_spec\n- * @run main\/othervm PacketLossRetransmission server 4 new_session_ticket\n+ * @run main\/othervm PacketLossRetransmission client full 1 client_hello\n+ * @run main\/othervm PacketLossRetransmission client full 16 client_key_exchange\n+ * @run main\/othervm PacketLossRetransmission client full 20 finished\n+ * @run main\/othervm PacketLossRetransmission client full -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server full 2 server_hello\n+ * @run main\/othervm PacketLossRetransmission server full 3 hello_verify_request\n+ * @run main\/othervm PacketLossRetransmission server full 11 certificate\n+ * @run main\/othervm PacketLossRetransmission server full 12 server_key_exchange\n+ * @run main\/othervm PacketLossRetransmission server full 14 server_hello_done\n+ * @run main\/othervm PacketLossRetransmission server full 20 finished\n+ * @run main\/othervm PacketLossRetransmission server full -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server full 4 new_session_ticket\n+ * @run main\/othervm PacketLossRetransmission client resume 1 client_hello\n+ * @run main\/othervm PacketLossRetransmission client resume 20 finished\n+ * @run main\/othervm PacketLossRetransmission client resume -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server resume 2 server_hello\n+ * @run main\/othervm PacketLossRetransmission server resume 3 hello_verify_request\n+ * @run main\/othervm PacketLossRetransmission server resume 20 finished\n+ * @run main\/othervm PacketLossRetransmission server resume -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server resume 4 new_session_ticket\n@@ -49,0 +54,2 @@\n+\n+import java.nio.ByteBuffer;\n@@ -52,0 +59,1 @@\n+import javax.net.ssl.SSLContext;\n@@ -53,0 +61,4 @@\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n@@ -59,0 +71,1 @@\n+\n@@ -64,0 +77,7 @@\n+    private final SSLContext clientContext;\n+    private final SSLContext serverContext;\n+\n+    protected PacketLossRetransmission() throws Exception {\n+        this.clientContext = getDTLSContext();\n+        this.serverContext = getDTLSContext();\n+    }\n@@ -67,1 +87,2 @@\n-        handshakeType = Byte.parseByte(args[1]);\n+        boolean isResume = args[1].equals(\"resume\");\n+        handshakeType = Byte.parseByte(args[2]);\n@@ -71,0 +92,17 @@\n+\n+        if (isResume) {\n+            \/\/ Note: we must use the same context, host and port for initial\n+            \/\/ and resuming sessions.\n+            SSLEngine clientEngine = testCase.clientContext.createSSLEngine(\n+                    HOST, CLIENT_PORT);\n+            clientEngine.setUseClientMode(true);\n+\n+            SSLEngine serverEngine = testCase.serverContext.createSSLEngine(\n+                    HOST, SERVER_PORT);\n+            serverEngine.setUseClientMode(false);\n+\n+            \/\/ The initial session will populate the TLS session cache.\n+            System.out.println(\"Starting initial handshake\");\n+            initialSession(clientEngine, serverEngine);\n+        }\n+\n@@ -74,0 +112,10 @@\n+    @Override\n+    protected SSLContext getClientDTLSContext() throws Exception {\n+        return clientContext;\n+    }\n+\n+    @Override\n+    protected SSLContext getServerDTLSContext() throws Exception {\n+        return serverContext;\n+    }\n+\n@@ -93,0 +141,166 @@\n+\n+    private static void initialSession(SSLEngine clientEngine,\n+            SSLEngine serverEngine) throws SSLException {\n+        boolean clientDone = false;\n+        boolean serverDone = false;\n+        boolean cliDataReady = false;\n+        boolean servDataReady = false;\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+        ByteBuffer clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        ByteBuffer serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+        ByteBuffer cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        ByteBuffer sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+        HandshakeStatus hsStat;\n+        final ByteBuffer clientOut = ByteBuffer.wrap(\n+                \"Hi Server, I'm Client\".getBytes());\n+        final ByteBuffer serverOut = ByteBuffer.wrap(\n+                \"Hello Client, I'm Server\".getBytes());\n+\n+        clientEngine.beginHandshake();\n+        serverEngine.beginHandshake();\n+        while (!clientDone && !serverDone) {\n+            \/\/ Client processing\n+            hsStat = clientEngine.getHandshakeStatus();\n+            log(\"Client HS Stat: \" + hsStat);\n+            switch (hsStat) {\n+                case NOT_HANDSHAKING:\n+                    log(\"Closing client engine\");\n+                    clientEngine.closeOutbound();\n+                    clientDone = true;\n+                    break;\n+                case NEED_WRAP:\n+                    log(String.format(\"CTOS: p:%d, l:%d, c:%d\", cTOs.position(),\n+                            cTOs.limit(), cTOs.capacity()));\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    log(\"client wrap: \", clientResult);\n+                    if (clientResult.getStatus()\n+                            == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n+                        \/\/ Get a larger buffer and try again\n+                        int updateSize = 2 * netBufferMax;\n+                        log(\"Resizing buffer to \" + updateSize + \" bytes\");\n+                        cTOs = ByteBuffer.allocate(updateSize);\n+                        clientResult = clientEngine.wrap(clientOut, cTOs);\n+                        log(\"client wrap (resized): \", clientResult);\n+                    }\n+                    runDelegatedTasks(clientResult, clientEngine);\n+                    cTOs.flip();\n+                    cliDataReady = true;\n+                    break;\n+                case NEED_UNWRAP:\n+                    if (servDataReady) {\n+                        log(String.format(\"STOC: p:%d, l:%d, c:%d\",\n+                                sTOc.position(),\n+                                sTOc.limit(), sTOc.capacity()));\n+                        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+                        log(\"client unwrap: \", clientResult);\n+                        runDelegatedTasks(clientResult, clientEngine);\n+                        servDataReady = sTOc.hasRemaining();\n+                        sTOc.compact();\n+                    } else {\n+                        log(\"Server-to-client data not ready, skipping client\" +\n+                                \" unwrap\");\n+                    }\n+                    break;\n+                case NEED_UNWRAP_AGAIN:\n+                    clientResult = clientEngine.unwrap(ByteBuffer.allocate(0),\n+                            clientIn);\n+                    log(\"client unwrap (again): \", clientResult);\n+                    runDelegatedTasks(clientResult, clientEngine);\n+                    break;\n+            }\n+\n+            \/\/ Server processing\n+            hsStat = serverEngine.getHandshakeStatus();\n+            log(\"Server HS Stat: \" + hsStat);\n+            switch (hsStat) {\n+                case NEED_WRAP:\n+                    log(String.format(\"STOC: p:%d, l:%d, c:%d\", sTOc.position(),\n+                            sTOc.limit(), sTOc.capacity()));\n+                    serverResult = serverEngine.wrap(serverOut, sTOc);\n+                    log(\"server wrap: \", serverResult);\n+                    if (serverResult.getStatus()\n+                            == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n+                        \/\/ Get a new buffer and try again\n+                        int updateSize = 2 * netBufferMax;\n+                        log(\"Resizing buffer to \" + updateSize + \" bytes\");\n+                        sTOc = ByteBuffer.allocate(updateSize);\n+                        serverResult = serverEngine.wrap(clientOut, sTOc);\n+                        log(\"server wrap (resized): \", serverResult);\n+                    }\n+                    runDelegatedTasks(serverResult, serverEngine);\n+                    sTOc.flip();\n+                    servDataReady = true;\n+                    break;\n+                case NOT_HANDSHAKING:\n+                    log(\"Closing server engine\");\n+                    serverEngine.closeOutbound();\n+                    serverDone = true;\n+                    break;\n+                case NEED_UNWRAP:\n+                    if (cliDataReady) {\n+                        log(String.format(\"CTOS: p:%d, l:%d, c:%d\",\n+                                cTOs.position(),\n+                                cTOs.limit(), cTOs.capacity()));\n+                        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+                        log(\"server unwrap: \", serverResult);\n+                        runDelegatedTasks(serverResult, serverEngine);\n+                        cliDataReady = cTOs.hasRemaining();\n+                        cTOs.compact();\n+                    } else {\n+                        log(\"Client-to-server data not ready, skipping server\" +\n+                                \" unwrap\");\n+                    }\n+                    break;\n+                case NEED_UNWRAP_AGAIN:\n+                    serverResult = serverEngine.unwrap(ByteBuffer.allocate(0),\n+                            serverIn);\n+                    log(\"server unwrap (again): \", serverResult);\n+                    runDelegatedTasks(serverResult, serverEngine);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        System.out.println(str);\n+    }\n+\n+    private static void log(String str, SSLEngineResult result) {\n+        System.out.println(\"The format of the SSLEngineResult is: \\n\" +\n+                \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n+                \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+\n+        log(str +\n+                result.getStatus() + \"\/\" + hsStatus + \", \" +\n+                result.bytesConsumed() + \"\/\" + result.bytesProduced() +\n+                \" bytes\");\n+\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            log(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private static void runDelegatedTasks(SSLEngineResult result,\n+            SSLEngine engine) {\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+\n+        if (hsStatus == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"\\trunning delegated task...\");\n+                runnable.run();\n+            }\n+            hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new RuntimeException(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n+        }\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/PacketLossRetransmission.java","additions":230,"deletions":16,"binary":false,"changes":246,"status":"modified"}]}