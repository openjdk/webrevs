{"files":[{"patch":"@@ -173,1 +173,1 @@\n-            \/\/ Discard the record younger than the current epcoh if:\n+            \/\/ Discard the record younger than the current epoch if:\n@@ -1448,1 +1448,1 @@\n-                    boolean isReady = hasFinishedMessage(bufferedFragments);\n+                    boolean isReady = hasFinishedMessage();\n@@ -1495,1 +1495,1 @@\n-                if (hasFinishedMessage(bufferedFragments)) {\n+                if (hasFinishedMessage()) {\n@@ -1568,1 +1568,1 @@\n-                if (!hasFinishedMessage(bufferedFragments)) {\n+                if (!hasFinishedMessage()) {\n@@ -1604,1 +1604,2 @@\n-        \/\/ Looking for the ChangeCipherSpec and Finished messages.\n+        \/\/ Looking for the ChangeCipherSpec, Finished and\n+        \/\/ NewSessionTicket messages.\n@@ -1611,2 +1612,1 @@\n-        private boolean hasFinishedMessage(Set<RecordFragment> fragments) {\n-\n+        private boolean hasFinishedMessage() {\n@@ -1615,1 +1615,2 @@\n-            for (RecordFragment fragment : fragments) {\n+\n+            for (RecordFragment fragment : bufferedFragments) {\n@@ -1617,3 +1618,0 @@\n-                    if (hasFin) {\n-                        return true;\n-                    }\n@@ -1621,8 +1619,3 @@\n-                } else if (fragment.contentType == ContentType.HANDSHAKE.id) {\n-                    \/\/ Finished is the first expected message of a new epoch.\n-                    if (fragment.isCiphertext) {\n-                        if (hasCCS) {\n-                            return true;\n-                        }\n-                        hasFin = true;\n-                    }\n+                } else if (fragment.contentType == ContentType.HANDSHAKE.id\n+                        && fragment.isCiphertext) {\n+                    hasFin = true;\n@@ -1632,1 +1625,6 @@\n-            return false;\n+            \/\/ NewSessionTicket message presence in the Finished flight\n+            \/\/ should only be expected on the client side, and only\n+            \/\/ if stateless resumption is enabled.\n+            return hasCCS && hasFin && (!tc.sslConfig.isClientMode\n+                    || !tc.handshakeContext.statelessResumption\n+                    || hasCompleted(SSLHandshake.NEW_SESSION_TICKET.id));\n@@ -1677,1 +1675,1 @@\n-            \/\/ present handshake message.  Need not to check it again.\n+            \/\/ present handshake message.  Need not check it again.\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSInputRecord.java","additions":19,"deletions":21,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -289,1 +289,1 @@\n-            null,\n+            SessionTicketExtension.shOnLoadAbsence,\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLExtension.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -75,0 +75,2 @@\n+    static final HandshakeAbsence shOnLoadAbsence =\n+            new T12SHSessionTicketOnLoadAbsence();\n@@ -532,0 +534,23 @@\n+\n+    \/**\n+     * The absence processing if a \"session_ticket\" extension is\n+     * not present in the ServerHello handshake message.\n+     *\/\n+    private static final class T12SHSessionTicketOnLoadAbsence\n+            implements HandshakeAbsence {\n+\n+        @Override\n+        public void absent(ConnectionContext context,\n+                HandshakeMessage message) {\n+            ClientHandshakeContext chc = (ClientHandshakeContext) context;\n+\n+            \/\/ Disable stateless resumption if server doesn't send the extension.\n+            if (chc.statelessResumption) {\n+                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                    SSLLogger.info(\n+                            \"Server doesn't support stateless resumption\");\n+                }\n+                chc.statelessResumption = false;\n+            }\n+        }\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SessionTicketExtension.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -0,0 +1,47 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8367059\n+ * @summary DTLS: loss of NewSessionTicket message results in handshake failure\n+ * @modules java.base\/sun.security.util\n+ * @library \/test\/lib\n+ * @build DTLSOverDatagram\n+ *\n+ * @comment Make sure client doesn't expect NewSessionTicket in the final\n+ * flight if server doesn't send the \"session_ticket\" extension with\n+ * ServerHello handshake message.\n+ *\n+ * @run main\/othervm -Djdk.tls.client.enableSessionTicketExtension=false\n+ *                   DTLSNoNewSessionTicket\n+ * @run main\/othervm -Djdk.tls.server.enableSessionTicketExtension=false\n+ *                   DTLSNoNewSessionTicket\n+ *\/\n+\n+public class DTLSNoNewSessionTicket extends DTLSOverDatagram {\n+    public static void main(String[] args) throws Exception {\n+        var testCase = new DTLSNoNewSessionTicket();\n+        testCase.runTest(testCase);\n+    }\n+}\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSNoNewSessionTicket.java","additions":47,"deletions":0,"binary":false,"changes":47,"status":"added"},{"patch":"@@ -24,3 +24,0 @@\n-\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n-\/\/ system properties in samevm\/agentvm mode.\n-\n@@ -135,2 +132,9 @@\n-        SSLContext context = getDTLSContext();\n-        SSLEngine engine = context.createSSLEngine();\n+        SSLContext context =\n+                isClient ? getClientDTLSContext() : getServerDTLSContext();\n+\n+        \/\/ Note: client and server ports are not to be used for network\n+        \/\/ communication, but only to be set in client and server SSL engines.\n+        \/\/ We must use the same context, host and port for initial and resuming\n+        \/\/ sessions when testing session resumption (abbreviated handshake).\n+        SSLEngine engine = context.createSSLEngine(\"localhost\",\n+                isClient ? 51111 : 52222);\n@@ -510,1 +514,1 @@\n-    SSLContext getDTLSContext() throws Exception {\n+    static SSLContext getDTLSContext() throws Exception {\n@@ -520,0 +524,8 @@\n+    protected SSLContext getServerDTLSContext() throws Exception {\n+        return getDTLSContext();\n+    }\n+\n+    protected SSLContext getClientDTLSContext() throws Exception {\n+        return getDTLSContext();\n+    }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSOverDatagram.java","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -24,3 +24,0 @@\n-\/\/ SunJSSE does not support dynamic system properties, no way to re-use\n-\/\/ system properties in samevm\/agentvm mode.\n-\n@@ -29,1 +26,1 @@\n- * @bug 8161086\n+ * @bug 8161086 8367059\n@@ -35,11 +32,20 @@\n- * @run main\/othervm PacketLossRetransmission client 1 client_hello\n- * @run main\/othervm PacketLossRetransmission client 16 client_key_exchange\n- * @run main\/othervm PacketLossRetransmission client 20 finished\n- * @run main\/othervm PacketLossRetransmission client -1 change_cipher_spec\n- * @run main\/othervm PacketLossRetransmission server 2 server_hello\n- * @run main\/othervm PacketLossRetransmission server 3 hello_verify_request\n- * @run main\/othervm PacketLossRetransmission server 11 certificate\n- * @run main\/othervm PacketLossRetransmission server 12 server_key_exchange\n- * @run main\/othervm PacketLossRetransmission server 14 server_hello_done\n- * @run main\/othervm PacketLossRetransmission server 20 finished\n- * @run main\/othervm PacketLossRetransmission server -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission client full 1 client_hello\n+ * @run main\/othervm PacketLossRetransmission client full 16 client_key_exchange\n+ * @run main\/othervm PacketLossRetransmission client full 20 finished\n+ * @run main\/othervm PacketLossRetransmission client full -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server full 2 server_hello\n+ * @run main\/othervm PacketLossRetransmission server full 3 hello_verify_request\n+ * @run main\/othervm PacketLossRetransmission server full 11 certificate\n+ * @run main\/othervm PacketLossRetransmission server full 12 server_key_exchange\n+ * @run main\/othervm PacketLossRetransmission server full 14 server_hello_done\n+ * @run main\/othervm PacketLossRetransmission server full 20 finished\n+ * @run main\/othervm PacketLossRetransmission server full -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server full 4 new_session_ticket\n+ * @run main\/othervm PacketLossRetransmission client resume 1 client_hello\n+ * @run main\/othervm PacketLossRetransmission client resume 20 finished\n+ * @run main\/othervm PacketLossRetransmission client resume -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server resume 2 server_hello\n+ * @run main\/othervm PacketLossRetransmission server resume 3 hello_verify_request\n+ * @run main\/othervm PacketLossRetransmission server resume 20 finished\n+ * @run main\/othervm PacketLossRetransmission server resume -1 change_cipher_spec\n+ * @run main\/othervm PacketLossRetransmission server resume 4 new_session_ticket\n@@ -48,0 +54,2 @@\n+\n+import java.nio.ByteBuffer;\n@@ -49,1 +57,0 @@\n-import java.util.ArrayList;\n@@ -52,0 +59,1 @@\n+import javax.net.ssl.SSLContext;\n@@ -53,0 +61,4 @@\n+import javax.net.ssl.SSLEngineResult;\n+import javax.net.ssl.SSLEngineResult.HandshakeStatus;\n+import javax.net.ssl.SSLException;\n+import javax.net.ssl.SSLSession;\n@@ -59,0 +71,1 @@\n+\n@@ -64,0 +77,7 @@\n+    private final SSLContext clientContext;\n+    private final SSLContext serverContext;\n+\n+    protected PacketLossRetransmission() throws Exception {\n+        this.clientContext = getDTLSContext();\n+        this.serverContext = getDTLSContext();\n+    }\n@@ -67,1 +87,2 @@\n-        handshakeType = Byte.parseByte(args[1]);\n+        boolean isResume = args[1].equals(\"resume\");\n+        handshakeType = Byte.parseByte(args[2]);\n@@ -71,0 +92,8 @@\n+\n+        if (isResume) {\n+            System.out.println(\"Starting initial handshake\");\n+            \/\/ The initial session will populate the TLS session cache.\n+            initialSession(testCase.createSSLEngine(true),\n+                    testCase.createSSLEngine(false));\n+        }\n+\n@@ -74,0 +103,10 @@\n+    @Override\n+    protected SSLContext getClientDTLSContext() throws Exception {\n+        return clientContext;\n+    }\n+\n+    @Override\n+    protected SSLContext getServerDTLSContext() throws Exception {\n+        return serverContext;\n+    }\n+\n@@ -93,0 +132,166 @@\n+\n+    private static void initialSession(SSLEngine clientEngine,\n+            SSLEngine serverEngine) throws SSLException {\n+        boolean clientDone = false;\n+        boolean serverDone = false;\n+        boolean cliDataReady = false;\n+        boolean servDataReady = false;\n+        SSLEngineResult clientResult;\n+        SSLEngineResult serverResult;\n+        SSLSession session = clientEngine.getSession();\n+        int appBufferMax = session.getApplicationBufferSize();\n+        int netBufferMax = session.getPacketBufferSize();\n+        ByteBuffer clientIn = ByteBuffer.allocate(appBufferMax + 50);\n+        ByteBuffer serverIn = ByteBuffer.allocate(appBufferMax + 50);\n+        ByteBuffer cTOs = ByteBuffer.allocateDirect(netBufferMax);\n+        ByteBuffer sTOc = ByteBuffer.allocateDirect(netBufferMax);\n+        HandshakeStatus hsStat;\n+        final ByteBuffer clientOut = ByteBuffer.wrap(\n+                \"Hi Server, I'm Client\".getBytes());\n+        final ByteBuffer serverOut = ByteBuffer.wrap(\n+                \"Hello Client, I'm Server\".getBytes());\n+\n+        clientEngine.beginHandshake();\n+        serverEngine.beginHandshake();\n+        while (!clientDone && !serverDone) {\n+            \/\/ Client processing\n+            hsStat = clientEngine.getHandshakeStatus();\n+            log(\"Client HS Stat: \" + hsStat);\n+            switch (hsStat) {\n+                case NOT_HANDSHAKING:\n+                    log(\"Closing client engine\");\n+                    clientEngine.closeOutbound();\n+                    clientDone = true;\n+                    break;\n+                case NEED_WRAP:\n+                    log(String.format(\"CTOS: p:%d, l:%d, c:%d\", cTOs.position(),\n+                            cTOs.limit(), cTOs.capacity()));\n+                    clientResult = clientEngine.wrap(clientOut, cTOs);\n+                    log(\"client wrap: \", clientResult);\n+                    if (clientResult.getStatus()\n+                            == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n+                        \/\/ Get a larger buffer and try again\n+                        int updateSize = 2 * netBufferMax;\n+                        log(\"Resizing buffer to \" + updateSize + \" bytes\");\n+                        cTOs = ByteBuffer.allocate(updateSize);\n+                        clientResult = clientEngine.wrap(clientOut, cTOs);\n+                        log(\"client wrap (resized): \", clientResult);\n+                    }\n+                    runDelegatedTasks(clientResult, clientEngine);\n+                    cTOs.flip();\n+                    cliDataReady = true;\n+                    break;\n+                case NEED_UNWRAP:\n+                    if (servDataReady) {\n+                        log(String.format(\"STOC: p:%d, l:%d, c:%d\",\n+                                sTOc.position(),\n+                                sTOc.limit(), sTOc.capacity()));\n+                        clientResult = clientEngine.unwrap(sTOc, clientIn);\n+                        log(\"client unwrap: \", clientResult);\n+                        runDelegatedTasks(clientResult, clientEngine);\n+                        servDataReady = sTOc.hasRemaining();\n+                        sTOc.compact();\n+                    } else {\n+                        log(\"Server-to-client data not ready, skipping client\" +\n+                                \" unwrap\");\n+                    }\n+                    break;\n+                case NEED_UNWRAP_AGAIN:\n+                    clientResult = clientEngine.unwrap(ByteBuffer.allocate(0),\n+                            clientIn);\n+                    log(\"client unwrap (again): \", clientResult);\n+                    runDelegatedTasks(clientResult, clientEngine);\n+                    break;\n+            }\n+\n+            \/\/ Server processing\n+            hsStat = serverEngine.getHandshakeStatus();\n+            log(\"Server HS Stat: \" + hsStat);\n+            switch (hsStat) {\n+                case NEED_WRAP:\n+                    log(String.format(\"STOC: p:%d, l:%d, c:%d\", sTOc.position(),\n+                            sTOc.limit(), sTOc.capacity()));\n+                    serverResult = serverEngine.wrap(serverOut, sTOc);\n+                    log(\"server wrap: \", serverResult);\n+                    if (serverResult.getStatus()\n+                            == SSLEngineResult.Status.BUFFER_OVERFLOW) {\n+                        \/\/ Get a new buffer and try again\n+                        int updateSize = 2 * netBufferMax;\n+                        log(\"Resizing buffer to \" + updateSize + \" bytes\");\n+                        sTOc = ByteBuffer.allocate(updateSize);\n+                        serverResult = serverEngine.wrap(clientOut, sTOc);\n+                        log(\"server wrap (resized): \", serverResult);\n+                    }\n+                    runDelegatedTasks(serverResult, serverEngine);\n+                    sTOc.flip();\n+                    servDataReady = true;\n+                    break;\n+                case NOT_HANDSHAKING:\n+                    log(\"Closing server engine\");\n+                    serverEngine.closeOutbound();\n+                    serverDone = true;\n+                    break;\n+                case NEED_UNWRAP:\n+                    if (cliDataReady) {\n+                        log(String.format(\"CTOS: p:%d, l:%d, c:%d\",\n+                                cTOs.position(),\n+                                cTOs.limit(), cTOs.capacity()));\n+                        serverResult = serverEngine.unwrap(cTOs, serverIn);\n+                        log(\"server unwrap: \", serverResult);\n+                        runDelegatedTasks(serverResult, serverEngine);\n+                        cliDataReady = cTOs.hasRemaining();\n+                        cTOs.compact();\n+                    } else {\n+                        log(\"Client-to-server data not ready, skipping server\" +\n+                                \" unwrap\");\n+                    }\n+                    break;\n+                case NEED_UNWRAP_AGAIN:\n+                    serverResult = serverEngine.unwrap(ByteBuffer.allocate(0),\n+                            serverIn);\n+                    log(\"server unwrap (again): \", serverResult);\n+                    runDelegatedTasks(serverResult, serverEngine);\n+                    break;\n+            }\n+        }\n+    }\n+\n+    private static void log(String str) {\n+        System.out.println(str);\n+    }\n+\n+    private static void log(String str, SSLEngineResult result) {\n+        System.out.println(\"The format of the SSLEngineResult is: \\n\" +\n+                \"\\t\\\"getStatus() \/ getHandshakeStatus()\\\" +\\n\" +\n+                \"\\t\\\"bytesConsumed() \/ bytesProduced()\\\"\\n\");\n+\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+\n+        log(str +\n+                result.getStatus() + \"\/\" + hsStatus + \", \" +\n+                result.bytesConsumed() + \"\/\" + result.bytesProduced() +\n+                \" bytes\");\n+\n+        if (hsStatus == HandshakeStatus.FINISHED) {\n+            log(\"\\t...ready for application data\");\n+        }\n+    }\n+\n+    private static void runDelegatedTasks(SSLEngineResult result,\n+            SSLEngine engine) {\n+        HandshakeStatus hsStatus = result.getHandshakeStatus();\n+\n+        if (hsStatus == HandshakeStatus.NEED_TASK) {\n+            Runnable runnable;\n+            while ((runnable = engine.getDelegatedTask()) != null) {\n+                log(\"\\trunning delegated task...\");\n+                runnable.run();\n+            }\n+            hsStatus = engine.getHandshakeStatus();\n+            if (hsStatus == HandshakeStatus.NEED_TASK) {\n+                throw new RuntimeException(\n+                        \"handshake shouldn't need additional tasks\");\n+            }\n+            log(\"\\tnew HandshakeStatus: \" + hsStatus);\n+        }\n+    }\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/PacketLossRetransmission.java","additions":222,"deletions":17,"binary":false,"changes":239,"status":"modified"}]}