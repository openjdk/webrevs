{"files":[{"patch":"@@ -1451,2 +1451,1 @@\n-                                \"Has the final flight been received? \"\n-                                        + isReady);\n+                            \"Has the final flight been received? \" + isReady);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/DTLSInputRecord.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,3 +61,0 @@\n-    protected static final String HOST = \"localhost\";\n-    protected static final int CLIENT_PORT = findAvailablePort();\n-    protected static final int SERVER_PORT = findAvailablePort();\n@@ -134,1 +131,1 @@\n-    SSLEngine createSSLEngine(boolean isClient) throws Exception {\n+    protected SSLEngine createSSLEngine(boolean isClient) throws Exception {\n@@ -137,2 +134,7 @@\n-        SSLEngine engine = context.createSSLEngine(HOST,\n-                isClient ? CLIENT_PORT : SERVER_PORT);\n+\n+        \/\/ Note: client and server ports are not to be used for network\n+        \/\/ communication, but only to be set in client and server SSL engines.\n+        \/\/ We must use the same context, host and port for initial and resuming\n+        \/\/ sessions when testing session resumption (abbreviated handshake).\n+        SSLEngine engine = context.createSSLEngine(\"localhost\",\n+                isClient ? 51111 : 52222);\n@@ -538,4 +540,4 @@\n-        InetSocketAddress serverSocketAddress =\n-                new InetSocketAddress(HOST, SERVER_PORT);\n-        InetSocketAddress clientSocketAddress =\n-                new InetSocketAddress(HOST, CLIENT_PORT);\n+        InetSocketAddress serverSocketAddress = new InetSocketAddress\n+                (InetAddress.getLoopbackAddress(), 0);\n+        InetSocketAddress clientSocketAddress = new InetSocketAddress\n+                (InetAddress.getLoopbackAddress(), 0);\n@@ -549,0 +551,6 @@\n+            InetSocketAddress serverSocketAddr = new InetSocketAddress(\n+                    InetAddress.getLoopbackAddress(), serverSocket.getLocalPort());\n+\n+            InetSocketAddress clientSocketAddr = new InetSocketAddress(\n+                    InetAddress.getLoopbackAddress(), clientSocket.getLocalPort());\n+\n@@ -553,1 +561,1 @@\n-                    testCase, serverSocket, clientSocketAddress));\n+                        testCase, serverSocket, clientSocketAddr));\n@@ -556,1 +564,1 @@\n-            runClient(testCase, clientSocket, serverSocketAddress);\n+            runClient(testCase, clientSocket, serverSocketAddr);\n@@ -627,8 +635,0 @@\n-\n-    static int findAvailablePort() {\n-        try (var socket = new DatagramSocket(0)) {\n-            return socket.getLocalPort();\n-        } catch (IOException e) {\n-            throw new RuntimeException(e);\n-        }\n-    }\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/DTLSOverDatagram.java","additions":20,"deletions":20,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -94,11 +94,0 @@\n-            \/\/ Note: we must use the same context, host and port for initial\n-            \/\/ and resuming sessions.\n-            SSLEngine clientEngine = testCase.clientContext.createSSLEngine(\n-                    HOST, CLIENT_PORT);\n-            clientEngine.setUseClientMode(true);\n-\n-            SSLEngine serverEngine = testCase.serverContext.createSSLEngine(\n-                    HOST, SERVER_PORT);\n-            serverEngine.setUseClientMode(false);\n-\n-            \/\/ The initial session will populate the TLS session cache.\n@@ -106,1 +95,3 @@\n-            initialSession(clientEngine, serverEngine);\n+            \/\/ The initial session will populate the TLS session cache.\n+            initialSession(testCase.createSSLEngine(true),\n+                    testCase.createSSLEngine(false));\n","filename":"test\/jdk\/javax\/net\/ssl\/DTLS\/PacketLossRetransmission.java","additions":3,"deletions":12,"binary":false,"changes":15,"status":"modified"}]}