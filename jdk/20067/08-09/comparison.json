{"files":[{"patch":"@@ -1091,1 +1091,1 @@\n-    \/\/ If we were to use wait() instead of waitUninterruptibly() then\n+    \/\/ If we were to use wait() instead of waitInterruptibly() then\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  \/\/ Used as a cache the ObjectMonitor* used when locking. Must either\n+  \/\/ Used as a cache of the ObjectMonitor* used when locking. Must either\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-class ObjectMonitorWorld : public CHeapObj<MEMFLAGS::mtObjectMonitor> {\n+class ObjectMonitorTable : public CHeapObj<MEMFLAGS::mtObjectMonitor> {\n@@ -67,1 +67,1 @@\n-      reinterpret_cast<ObjectMonitorWorld*>(context)->inc_table_count();\n+      reinterpret_cast<ObjectMonitorTable*>(context)->inc_items_count();\n@@ -71,1 +71,1 @@\n-      reinterpret_cast<ObjectMonitorWorld*>(context)->dec_table_count();\n+      reinterpret_cast<ObjectMonitorTable*>(context)->dec_items_count();\n@@ -77,2 +77,2 @@\n-  ConcurrentTable* _table;\n-  volatile size_t _table_count;\n+  ConcurrentTable _table;\n+  volatile size_t _items_count;\n@@ -125,2 +125,2 @@\n-  void inc_table_count() {\n-    Atomic::inc(&_table_count);\n+  void inc_items_count() {\n+    Atomic::inc(&_items_count);\n@@ -129,2 +129,2 @@\n-  void dec_table_count() {\n-    Atomic::inc(&_table_count);\n+  void dec_items_count() {\n+    Atomic::inc(&_items_count);\n@@ -134,1 +134,1 @@\n-    return (double)_table_count\/(double)_table_size;\n+    return (double)_items_count\/(double)_table_size;\n@@ -138,1 +138,1 @@\n-    return ((size_t)1) << _table->get_size_log2(current);\n+    return ((size_t)1) << _table.get_size_log2(current);\n@@ -174,8 +174,8 @@\n-  ObjectMonitorWorld()\n-  : _table(new ConcurrentTable(initial_log_size(),\n-                               max_log_size(),\n-                               grow_hint(),\n-                               ConcurrentTable::DEFAULT_ENABLE_STATISTICS,\n-                               ConcurrentTable::DEFAULT_MUTEX_RANK,\n-                               this)),\n-    _table_count(0),\n+  ObjectMonitorTable()\n+  : _table(ConcurrentTable(initial_log_size(),\n+                           max_log_size(),\n+                           grow_hint(),\n+                           ConcurrentTable::DEFAULT_ENABLE_STATISTICS,\n+                           ConcurrentTable::DEFAULT_MUTEX_RANK,\n+                           this)),\n+    _items_count(0),\n@@ -203,1 +203,1 @@\n-    _table->get(current, lookup_f, found_f);\n+    _table.get(current, lookup_f, found_f);\n@@ -209,1 +209,1 @@\n-    if (!_table->is_max_size_reached() && !Atomic::load(&_resize)) {\n+    if (!_table.is_max_size_reached() && !Atomic::load(&_resize)) {\n@@ -226,1 +226,1 @@\n-    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n+    return get_load_factor() > GROW_LOAD_FACTOR && !_table.is_max_size_reached();\n@@ -252,1 +252,1 @@\n-    ConcurrentTable::GrowTask grow_task(_table);\n+    ConcurrentTable::GrowTask grow_task(&_table);\n@@ -262,1 +262,1 @@\n-    ConcurrentTable::BulkDeleteTask clean_task(_table);\n+    ConcurrentTable::BulkDeleteTask clean_task(&_table);\n@@ -279,1 +279,1 @@\n-      if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n+      if (!_table.is_max_size_reached() && Atomic::load(&_resize)) {\n@@ -300,1 +300,1 @@\n-    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n+    _table.insert_get(current, lookup_f, monitor, found_f, &grow);\n@@ -310,1 +310,1 @@\n-    return _table->remove(current, lookup_f);\n+    return _table.remove(current, lookup_f);\n@@ -319,1 +319,1 @@\n-    _table->get(current, lookup_f, found_f);\n+    _table.get(current, lookup_f, found_f);\n@@ -334,1 +334,1 @@\n-      _table->do_safepoint_scan(printer);\n+      _table.do_safepoint_scan(printer);\n@@ -336,1 +336,1 @@\n-      _table->do_scan(Thread::current(), printer);\n+      _table.do_scan(Thread::current(), printer);\n@@ -341,1 +341,1 @@\n-ObjectMonitorWorld* LightweightSynchronizer::_omworld = nullptr;\n+ObjectMonitorTable* LightweightSynchronizer::_omworld = nullptr;\n@@ -366,1 +366,1 @@\n-static void log_inflate(Thread* current, oop object, const ObjectSynchronizer::InflateCause cause) {\n+static void log_inflate(Thread* current, oop object, ObjectSynchronizer::InflateCause cause) {\n@@ -387,1 +387,1 @@\n-ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, const ObjectSynchronizer::InflateCause cause) {\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n@@ -446,1 +446,1 @@\n-  _omworld = new ObjectMonitorWorld();\n+  _omworld = new ObjectMonitorTable();\n@@ -472,1 +472,0 @@\n-        \/\/ assert(VM_Version::supports_recursive_lightweight_locking(), \"must be\");\n@@ -548,4 +547,0 @@\n-  union {\n-    struct {} _dummy;\n-    NoSafepointVerifier _nsv;\n-  };\n@@ -558,1 +553,1 @@\n-      ::new (&_nsv) NoSafepointVerifier();\n+      JavaThread::current()->inc_no_safepoint_count();\n@@ -563,1 +558,1 @@\n-      _nsv.~NoSafepointVerifier();\n+      JavaThread::current()->dec_no_safepoint_count();\n@@ -777,1 +772,1 @@\n-ObjectMonitor* LightweightSynchronizer::inflate_locked_or_imse(oop obj, const ObjectSynchronizer::InflateCause cause, TRAPS) {\n+ObjectMonitor* LightweightSynchronizer::inflate_locked_or_imse(oop obj, ObjectSynchronizer::InflateCause cause, TRAPS) {\n@@ -821,1 +816,1 @@\n-ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, const ObjectSynchronizer::InflateCause cause) {\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, ObjectSynchronizer::InflateCause cause) {\n@@ -945,1 +940,1 @@\n-ObjectMonitor* LightweightSynchronizer::inflate_fast_locked_object(oop object, JavaThread* locking_thread, JavaThread* current, const ObjectSynchronizer::InflateCause cause) {\n+ObjectMonitor* LightweightSynchronizer::inflate_fast_locked_object(oop object, JavaThread* locking_thread, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n@@ -1002,1 +997,1 @@\n-ObjectMonitor* LightweightSynchronizer::inflate_and_enter(oop object, JavaThread* locking_thread, JavaThread* current, const ObjectSynchronizer::InflateCause cause) {\n+ObjectMonitor* LightweightSynchronizer::inflate_and_enter(oop object, JavaThread* locking_thread, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":40,"deletions":45,"binary":false,"changes":85,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-class ObjectMonitorWorld;\n+class ObjectMonitorTable;\n@@ -37,1 +37,1 @@\n-  static ObjectMonitorWorld* _omworld;\n+  static ObjectMonitorTable* _omworld;\n@@ -40,1 +40,1 @@\n-  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, const ObjectSynchronizer::InflateCause cause);\n+  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n@@ -68,4 +68,4 @@\n-  static ObjectMonitor* inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, const ObjectSynchronizer::InflateCause cause);\n-  static ObjectMonitor* inflate_locked_or_imse(oop object, const ObjectSynchronizer::InflateCause cause, TRAPS);\n-  static ObjectMonitor* inflate_fast_locked_object(oop object, JavaThread* locking_thread, JavaThread* current, const ObjectSynchronizer::InflateCause cause);\n-  static ObjectMonitor* inflate_and_enter(oop object, JavaThread* locking_thread, JavaThread* current, const ObjectSynchronizer::InflateCause cause);\n+  static ObjectMonitor* inflate_into_object_header(Thread* current, JavaThread* inflating_thread, oop object, ObjectSynchronizer::InflateCause cause);\n+  static ObjectMonitor* inflate_locked_or_imse(oop object, ObjectSynchronizer::InflateCause cause, TRAPS);\n+  static ObjectMonitor* inflate_fast_locked_object(oop object, JavaThread* locking_thread, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n+  static ObjectMonitor* inflate_and_enter(oop object, JavaThread* locking_thread, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -126,1 +126,1 @@\n-                    throw new RuntimeException(\"WaitNotifyTest: Invalid Count \"  + count +\n+                    throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count +\n@@ -136,1 +136,1 @@\n-                throw new RuntimeException(\"WaitNotifyTest: Invalid Count \"  + count);\n+                throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count);\n@@ -217,1 +217,1 @@\n-                throw new RuntimeException(\"RandomDepthTest: Invalid Count \"  + count);\n+                throw new RuntimeException(\"RandomDepthTest: Invalid Count \" + count);\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/UseObjectMonitorTableTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"}]}