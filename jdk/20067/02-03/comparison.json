{"files":[{"patch":"@@ -42,0 +42,1 @@\n+#if defined(X86) || defined(AARCH64)\n@@ -43,0 +44,6 @@\n+#else\n+  \/\/ Other platforms does not make use of the cache yet,\n+  \/\/ and are not as careful with maintaining the invariant\n+  \/\/ that the metadata either is nullptr or ObjectMonitor*.\n+  return nullptr;\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -254,2 +254,2 @@\n-  if (!UseObjectMonitorTable) {\n-    return;\n+  if (UseObjectMonitorTable) {\n+    _om_cache.clear();\n@@ -257,2 +257,0 @@\n-\n-  _om_cache.clear();\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(UseObjectMonitorTable, \"must be\");\n@@ -732,1 +732,1 @@\n-  assert(!mark.is_unlocked(), \"must be unlocked\");\n+  assert(!mark.is_unlocked(), \"must be\");\n@@ -773,0 +773,10 @@\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an inflated\n+\/\/ ObjectMonitor* with LM_LIGHTWEIGHT. It is used from contexts which requires\n+\/\/ an inflated ObjectMonitor* for a monitor, and expects to throw a\n+\/\/ java.lang.IllegalMonitorStateException if it is not held by the current\n+\/\/ thread. Such as notify\/wait and jni_exit. LM_LIGHTWEIGHT keeps it invariant\n+\/\/ that it only inflates if it is already locked by the current thread or the\n+\/\/ current thread is in the process of entering. To maintain this invariant we\n+\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n+\/\/ the current thread is not the owner.\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse facilitates this.\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"}]}