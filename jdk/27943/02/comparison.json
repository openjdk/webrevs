{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,4 +57,1 @@\n-     * the interface method invoked on the proxy instance.  The declaring\n-     * class of the {@code Method} object will be the interface that\n-     * the method was declared in, which may be a superinterface of the\n-     * proxy interface that the proxy class inherits the method through.\n+     * the method invoked on the proxy instance; may be a duplicate method\n@@ -64,1 +61,1 @@\n-     * or {@code null} if interface method takes no arguments.\n+     * or {@code null} if the invoked method takes no arguments.\n@@ -70,1 +67,1 @@\n-     * proxy instance.  If the declared return type of the interface\n+     * proxy instance.  If the declared return type of the invoked\n@@ -75,1 +72,1 @@\n-     * {@code null} and the interface method's return type is\n+     * {@code null} and the invoked method's return type is\n@@ -79,1 +76,1 @@\n-     * the interface method's declared return type as described above,\n+     * the invoked method's declared return type as described above,\n@@ -86,1 +83,1 @@\n-     * {@code throws} clause of the interface method or to the\n+     * {@code throws} clause of the invoked method or to the\n@@ -91,1 +88,1 @@\n-     * the interface method, then an\n+     * the invoked method, then an\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/InvocationHandler.java","additions":8,"deletions":11,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -72,17 +72,3 @@\n- * A <em>proxy class<\/em> is a class created at runtime that implements a specified\n- * list of interfaces, known as <em>proxy interfaces<\/em>. A <em>proxy instance<\/em>\n- * is an instance of a proxy class.\n- *\n- * Each proxy instance has an associated <i>invocation handler<\/i>\n- * object, which implements the interface {@link InvocationHandler}.\n- * A method invocation on a proxy instance through one of its proxy\n- * interfaces will be dispatched to the {@link InvocationHandler#invoke\n- * invoke} method of the instance's invocation handler, passing the proxy\n- * instance, a {@code java.lang.reflect.Method} object identifying\n- * the method that was invoked, and an array of type {@code Object}\n- * containing the arguments.  The invocation handler processes the\n- * encoded method invocation as appropriate and the result that it\n- * returns will be returned as the result of the method invocation on\n- * the proxy instance.\n- *\n- * <p>A proxy class has the following properties:\n+ * A <em>proxy class<\/em> is a class created at runtime that implements a\n+ * specified list of interfaces, known as <em>proxy interfaces<\/em>. It has\n+ * the following properties:\n@@ -100,1 +86,2 @@\n- * <li>A proxy class extends {@code java.lang.reflect.Proxy}.\n+ * <li>A proxy class extends {@code java.lang.reflect.Proxy}.  Note that\n+ * {@code Proxy} itself is not a proxy class.\n@@ -103,7 +90,10 @@\n- * creation, in the same order. Invoking {@link Class#getInterfaces() getInterfaces}\n- * on its {@code Class} object will return an array containing the same\n- * list of interfaces (in the order specified at its creation), invoking\n- * {@link Class#getMethods getMethods} on its {@code Class} object will return\n- * an array of {@code Method} objects that include all of the\n- * methods in those interfaces, and invoking {@code getMethod} will\n- * find methods in the proxy interfaces as would be expected.\n+ * creation, in the same order. This order is reflected by {@link\n+ * Class#getInterfaces() getInterfaces} on its {@code Class} object.\n+ *\n+ * <li>A proxy class contains all public non-static methods from {@link Object}\n+ * and its proxy interfaces, discoverable by {@link Class#getMethods()\n+ * getMethods} on its {@code Class} object. The {@code Object} class and the\n+ * proxy interfaces may contain public non-static methods with the same name and\n+ * parameter types, known as <em>duplicate methods<\/em>; they are {@linkplain\n+ * ##restrictions restricted} in that one of them has a return type assignable\n+ * to the return types of all of them.\n@@ -119,2 +109,16 @@\n- * <p>A proxy instance has the following properties:\n- *\n+ * <p>A <em>proxy instance<\/em> is an instance of a proxy class.\n+ * Each proxy instance has an associated <i>invocation handler<\/i>\n+ * object, which implements the interface {@link InvocationHandler}.\n+ * {@link #newProxyInstance Proxy::newProxyInstance} associates an invocation\n+ * handler to a newly created proxy instance.  The static {@link\n+ * Proxy#getInvocationHandler Proxy::getInvocationHandler} method returns the\n+ * invocation handler associated with a proxy instance.\n+ * <p>\n+ * For a proxy instance, invocation of a public non-final method declared in\n+ * {@link Object} or one of the proxy interfaces will be dispatched to\n+ * the {@link InvocationHandler#invoke invoke} method of the instance's\n+ * invocation handler, passing the proxy instance, a {@link Method} object\n+ * identifying the method that was invoked, and an array of type {@code Object}\n+ * representing the arguments.\n+ * <p>\n+ * Details of the invocation dispatching are as follows:\n@@ -122,40 +126,54 @@\n- * <li>Given a proxy instance {@code proxy} and one of the\n- * interfaces, {@code Foo}, implemented by its proxy class, the\n- * following expression will return true:\n- * <pre>\n- *     {@code proxy instanceof Foo}\n- * <\/pre>\n- * and the following cast operation will succeed (rather than throwing\n- * a {@code ClassCastException}):\n- * <pre>\n- *     {@code (Foo) proxy}\n- * <\/pre>\n- *\n- * <li>Each proxy instance has an associated invocation handler, the one\n- * that was passed to its constructor.  The static\n- * {@link Proxy#getInvocationHandler Proxy.getInvocationHandler} method\n- * will return the invocation handler associated with the proxy instance\n- * passed as its argument.\n- *\n- * <li>An interface method invocation on a proxy instance will be\n- * encoded and dispatched to the invocation handler's {@link\n- * InvocationHandler#invoke invoke} method as described in the\n- * documentation for that method.\n- *\n- * <li>A proxy interface may define a default method or inherit\n- * a default method from its superinterface directly or indirectly.\n- * An invocation handler can invoke a default method of a proxy interface\n- * by calling {@link InvocationHandler#invokeDefault(Object, Method, Object...)\n- * InvocationHandler::invokeDefault}.\n- *\n- * <li>An invocation of the {@code hashCode},\n- * {@code equals}, or {@code toString} methods declared in\n- * {@code java.lang.Object} on a proxy instance will be encoded and\n- * dispatched to the invocation handler's {@code invoke} method in\n- * the same manner as interface method invocations are encoded and\n- * dispatched, as described above.  The declaring class of the\n- * {@code Method} object passed to {@code invoke} will be\n- * {@code java.lang.Object}.  Other public methods of a proxy\n- * instance inherited from {@code java.lang.Object} are not\n- * overridden by a proxy class, so invocations of those methods behave\n- * like they do for instances of {@code java.lang.Object}.\n+ * <li>The public non-final methods declared in {@code Object} include\n+ *     {@link Object#hashCode() hashCode}, {@link Object#equals(Object) equals},\n+ *     and {@link Object#toString() toString}. Other public methods of a proxy\n+ *     instance inherited from {@code Object} are final, so invocations of those\n+ *     methods are not dispatched to the invocation handler.\n+ * <li>Invocations to default methods in proxy interfaces are also dispatched\n+ *     to the invocation handler. An invocation handler can invoke a default\n+ *     method of a proxy interface by calling {@link\n+ *     InvocationHandler#invokeDefault InvocationHandler::invokeDefault}.\n+ * <li>One {@code Method} object is shared for all duplicate methods of each\n+ *     name and parameter types pair.  It represents the method from the first\n+ *     class or interface that contains one of these duplicate methods, in the\n+ *     sequence of the {@code Object} class followed by the proxy interfaces in\n+ *     their specified order.\n+ * <li>The array representing the arguments may be null if the invoked method\n+ *     takes no argument. Primitive arguments to the invoked method are\n+ *     converted to references by boxing conversion (JLS {@jls 5.1.7}) before\n+ *     storing into the array.\n+ * <li>If the dispatch to invocation handler via the {@code invoke} method\n+ *     throws an exception:\n+ *     <ul>\n+ *     <li>If the exception is unchecked, that it is an instance of a subclass\n+ *         of {@link Error} or {@link RuntimeException}, it is thrown by the\n+ *         invoked method.\n+ *     <li>Otherwise, the exception is checked. If the invoked method is not\n+ *         a duplicate method, and the checked exception is allowed by the\n+ *         {@code throws} clause of the invoked method, it is thrown by the\n+ *         invoked method.\n+ *     <li>If the invoked method is a duplicate method, and the checked\n+ *         exception is allowed by the {@code throws} clause of those duplicate\n+ *         methods with the same method descriptor, it is thrown by the invoked\n+ *         method.  This may be more restrictive than or be unrelated to the\n+ *         declared exceptions on the passed {@code Method} object, which may\n+ *         represent a duplicate method with a different method descriptor.\n+ *     <li>Otherwise, the invoked method throws an {@link\n+ *         UndeclaredThrowableException} caused by the checked exception thrown\n+ *         by the {@code invoke} method.\n+ *     <\/ul>\n+ * <li>The return value of the {@code invoke} method is converted to the invoked\n+ *     method's return type, or the return type assignable to all return types\n+ *     (see {@linkplain ##restrictions restrictions}) if this invoked method is\n+ *     a duplicate method:\n+ *     <ul>\n+ *     <li>If the return type is a reference type, the return value is converted\n+ *         by a narrowing reference conversion (JLS {@jls 5.1.6}) from {@code\n+ *         Object} to the return type, which may throw a {@link\n+ *         ClassCastException}.\n+ *     <li>If the return type is a primitive type, the return value is converted\n+ *         by a narrowing reference conversion from {@code Object} to the\n+ *         corresponding wrapper class type, which may throw a {@code\n+ *         ClassCastException}, followed by an unboxing conversion (JLS {@jls\n+ *         5.1.8}), which may throw a {@link NullPointerException}.\n+ *     <li>If the return type is void, the return value is discarded.\n+ *     <\/ul>\n@@ -240,42 +258,30 @@\n- * <h3>Methods Duplicated in Multiple Proxy Interfaces<\/h3>\n- *\n- * <p>When two or more proxy interfaces contain a method with\n- * the same name and parameter signature, the order of the proxy class's\n- * interfaces becomes significant.  When such a <i>duplicate method<\/i>\n- * is invoked on a proxy instance, the {@code Method} object passed\n- * to the invocation handler will not necessarily be the one whose\n- * declaring class is assignable from the reference type of the interface\n- * that the proxy's method was invoked through.  This limitation exists\n- * because the corresponding method implementation in the generated proxy\n- * class cannot determine which interface it was invoked through.\n- * Therefore, when a duplicate method is invoked on a proxy instance,\n- * the {@code Method} object for the method in the foremost interface\n- * that contains the method (either directly or inherited through a\n- * superinterface) in the proxy class's list of interfaces is passed to\n- * the invocation handler's {@code invoke} method, regardless of the\n- * reference type through which the method invocation occurred.\n- *\n- * <p>If a proxy interface contains a method with the same name and\n- * parameter signature as the {@code hashCode}, {@code equals},\n- * or {@code toString} methods of {@code java.lang.Object},\n- * when such a method is invoked on a proxy instance, the\n- * {@code Method} object passed to the invocation handler will have\n- * {@code java.lang.Object} as its declaring class.  In other words,\n- * the public, non-final methods of {@code java.lang.Object}\n- * logically precede all of the proxy interfaces for the determination of\n- * which {@code Method} object to pass to the invocation handler.\n- *\n- * <p>Note also that when a duplicate method is dispatched to an\n- * invocation handler, the {@code invoke} method may only throw\n- * checked exception types that are assignable to one of the exception\n- * types in the {@code throws} clause of the method in <i>all<\/i> of\n- * the proxy interfaces that it can be invoked through.  If the\n- * {@code invoke} method throws a checked exception that is not\n- * assignable to any of the exception types declared by the method in one\n- * of the proxy interfaces that it can be invoked through, then an\n- * unchecked {@code UndeclaredThrowableException} will be thrown by\n- * the invocation on the proxy instance.  This restriction means that not\n- * all of the exception types returned by invoking\n- * {@code getExceptionTypes} on the {@code Method} object\n- * passed to the {@code invoke} method can necessarily be thrown\n- * successfully by the {@code invoke} method.\n+ * @apiNote\n+ * The protected methods declared in {@code java.lang.Object}, such as {@link\n+ * Object#clone() clone}, are not dispatched to the invocation handler, and are\n+ * not considered for duplicate methods if proxy interfaces contain public\n+ * non-static methods of the same name and parameter types.\n+ * {@snippet :\n+ * interface Baz { int clone(); }\n+ * Baz baz = (Baz) Proxy.newProxyInstance(Baz.class.getClassLoader(),\n+ *                                        new Class<?>[] { Baz.class },\n+ *                                        (_, _, _) -> 42);\n+ * baz.clone();  \/\/ Returns 42, not a duplicate method with Object::clone\n+ * }\n+ * <p>\n+ * They can still be dispatched to the invocation handler if proxy interfaces\n+ * contain methods with the same name and method descriptor, causing method\n+ * overriding (JVMS {@jvms 5.4.5}).\n+ * <p>\n+ * Duplicate methods with the same name and parameter types can have different\n+ * behaviors when the invocation handler throws the same exception, because\n+ * their method descriptors are different. For example:\n+ * {@snippet :\n+ * interface Foo extends java.util.concurrent.Callable<String> {\n+ *     String call(); \/\/ covariant override, descriptor changed to ()Ljava\/lang\/String;\n+ * }\n+ * Object foo = Proxy.newProxyInstance(Foo.class.getClassLoader(),\n+ *                                     new Class<?>[] { Foo.class },\n+ *                                     (_, _, _) -> { throw new Exception(); });\n+ * ((Foo) foo).call();  \/\/ Throws UndeclaredThrowableException\n+ * ((Callable<?>) foo).call();  \/\/ Throws Exception - allowed by the bridge method\n+ * }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Proxy.java","additions":115,"deletions":109,"binary":false,"changes":224,"status":"modified"}]}