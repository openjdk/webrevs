{"files":[{"patch":"@@ -212,5 +212,7 @@\n-        final int ITERATIONS = 50; \/\/ Number of simulation iterations.\n-        final double REPULSION_CONSTANT = 1000; \/\/ Magnitude of repulsive forces.\n-        final double SPRING_CONSTANT = 0.2; \/\/ Strength of attractive forces to neighbors.\n-        final double DAMPING = 0.8; \/\/ Damping factor to reduce displacement and ensure convergence.\n-        final double IDEAL_LENGTH = 100; \/\/ Ideal distance between a node and its neighbors.\n+        final int ITERATIONS = 50; \/\/ Number of simulation iterations\n+        final double REPULSION_CONSTANT = 1000; \/\/ Magnitude of repulsive forces (Coulomb's law)\n+        final double SPRING_CONSTANT = 0.2; \/\/ Strength of attractive forces to neighbors (Hooke's law)\n+        final double DAMPING = 0.8; \/\/ Factor to reduce displacement and ensure stability\n+        final double IDEAL_LENGTH = 100; \/\/ Desired distance between a node and its neighbors\n+        final double MAX_FORCE = 1000; \/\/ Upper limit for the magnitude of applied forces\n+        final double CONVERGENCE_THRESHOLD = 0.01; \/\/ Force threshold for stopping early\n@@ -235,3 +237,3 @@\n-                \/\/ If distance is zero, add small random noise to deltaX and deltaY\n-                if (distance == 0) {\n-                    deltaX = random.nextDouble() * 0.1 - 0.05; \/\/ Random value between -0.05 and 0.05\n+                \/\/ Avoid division by zero by introducing a minimum distance\n+                if (distance < 1e-6) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05;\n@@ -245,0 +247,4 @@\n+\n+                \/\/ Normalize force to prevent large displacements\n+                if (repulsiveForce > MAX_FORCE) repulsiveForce = MAX_FORCE;\n+\n@@ -255,3 +261,2 @@\n-                \/\/ If distance is zero, add small random noise to deltaX and deltaY\n-                if (distance == 0) {\n-                    deltaX = random.nextDouble() * 0.1 - 0.05; \/\/ Random value between -0.05 and 0.05\n+                if (distance < 1e-6) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05;\n@@ -265,0 +270,3 @@\n+\n+                if (attractiveForce > MAX_FORCE) attractiveForce = MAX_FORCE;\n+\n@@ -269,1 +277,1 @@\n-            \/\/ Update displacement with damping\n+            \/\/ Apply damping and update displacement\n@@ -273,1 +281,8 @@\n-            \/\/ Update node position\n+            \/\/ Scale displacement if it's too large\n+            double displacementMagnitude = Math.sqrt(dx * dx + dy * dy);\n+            if (displacementMagnitude > MAX_FORCE) {\n+                dx *= MAX_FORCE \/ displacementMagnitude;\n+                dy *= MAX_FORCE \/ displacementMagnitude;\n+            }\n+\n+            \/\/ Update position\n@@ -276,0 +291,12 @@\n+\n+            \/\/ Stop early if the net force is negligible\n+            if (Math.abs(netForceX) < CONVERGENCE_THRESHOLD && Math.abs(netForceY) < CONVERGENCE_THRESHOLD) {\n+                break;\n+            }\n+\n+            \/\/ Validate position to avoid invalid or extreme values\n+            if (Double.isNaN(posX) || Double.isInfinite(posX) || Double.isNaN(posY) || Double.isInfinite(posY)) {\n+                posX = node.getX(); \/\/ Reset to original position\n+                posY = node.getY();\n+                break;\n+            }\n@@ -279,2 +306,2 @@\n-        node.setX((int) posX);\n-        node.setY((int) posY);\n+        node.setX((int) Math.round(posX));\n+        node.setY((int) Math.round(posY));\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/FreeInteractiveLayoutManager.java","additions":42,"deletions":15,"binary":false,"changes":57,"status":"modified"}]}