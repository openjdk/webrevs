{"files":[{"patch":"@@ -0,0 +1,357 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.hierarchicallayout;\n+\n+import static com.sun.hotspot.igv.hierarchicallayout.LayoutNode.LAYOUT_NODE_DEGREE_COMPARATOR;\n+import com.sun.hotspot.igv.layout.Link;\n+import com.sun.hotspot.igv.layout.Vertex;\n+import java.awt.Point;\n+import java.util.*;\n+\n+public class FreeInteractiveLayoutManager extends LayoutManager implements LayoutMover {\n+\n+    private boolean cutEdges = false;\n+\n+    private static final int LINE_OFFSET = 10;\n+\n+    private Map<Vertex, LayoutNode> layoutNodes;\n+\n+    private LayoutGraph prevGraph;\n+\n+    private final Random random = new Random(42);\n+\n+    \/\/ Constants for offsets and displacements\n+    private static final int MAX_OFFSET_AROUND_NEIGHBOR = 200; \/\/ Max offset for random positioning around a neighbor\n+    private static final int MAX_OFFSET_AROUND_ORIGIN = 200; \/\/ Max offset for random positioning around origin\n+    private static final int DISPLACEMENT_RANGE_BARYCENTER = 100; \/\/ Displacement range for barycenter calculation\n+    private static final int DISPLACEMENT_RANGE_SINGLE = 200;\n+\n+    \/\/ Create a comparator to sort nodes by the number of unassigned neighbors\n+    private final Comparator<LayoutNode> LeastUnassignedNeighborsComparator = Comparator.comparingInt(node -> {\n+        Vertex vertex = node.getVertex();\n+        int unassignedNeighbors = 0;\n+        for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+            if (!layoutNodes.containsKey(neighborVertex)) {\n+                unassignedNeighbors++;\n+            }\n+        }\n+        return unassignedNeighbors;\n+    });\n+\n+    public FreeInteractiveLayoutManager() {\n+        this.cutEdges = false;\n+        this.layoutNodes = new HashMap<>();\n+        this.prevGraph = null;\n+    }\n+\n+    @Override\n+    public void moveLink(Point linkPos, int shiftX) {}\n+\n+    @Override\n+    public void moveVertices(Set<? extends Vertex> movedVertices) {\n+        for (Vertex v : movedVertices) {\n+            moveVertex(v);\n+        }\n+    }\n+\n+    @Override\n+    public void moveVertex(Vertex vertex) {\n+        assert prevGraph.containsVertex(vertex);\n+        LayoutNode layoutNode = layoutNodes.get(vertex);\n+        layoutNode.setX(vertex.getPosition().x);\n+        layoutNode.setY(vertex.getPosition().y);\n+        for (Link link : prevGraph.getAllLinks(vertex)) {\n+            setLinkControlPoints(link);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isFreeForm() {\n+        return true;\n+    }\n+\n+    public void setCutEdges(boolean enable) {\n+        this.cutEdges = enable;\n+    }\n+\n+    @Override\n+    public void doLayout(LayoutGraph graph) {\n+        prevGraph = graph;\n+        if (layoutNodes.isEmpty()) {\n+            HierarchicalLayoutManager manager = new HierarchicalLayoutManager();\n+            manager.doLayout(graph);\n+            for (LayoutNode node : graph.getLayoutNodes()) {\n+                node.initSize();\n+                layoutNodes.put(node.getVertex(), node);\n+            }\n+            graph.clearLayout();\n+        } else {\n+            \/\/ add new vertices to layoutNodes, x\/y from barycenter\n+            List<LayoutNode> newLayoutNodes = new ArrayList<>();\n+\n+            \/\/ Set up layout nodes for each vertex\n+            for (Vertex vertex : prevGraph.getVertices()) {\n+                if (!layoutNodes.containsKey(vertex)) {\n+                    LayoutNode addedNode = new LayoutNode(vertex);\n+                    addedNode.initSize();\n+                    newLayoutNodes.add(addedNode);\n+                }\n+            }\n+\n+            positionNewLayoutNodes(newLayoutNodes);\n+        }\n+\n+        \/\/ Write back vertices\n+        for (Vertex vertex : prevGraph.getVertices()) {\n+            LayoutNode layoutNode = layoutNodes.get(vertex);\n+            layoutNode.setVertex(vertex);\n+            vertex.setPosition(new Point(layoutNode.getLeft(), layoutNode.getTop()));\n+        }\n+\n+        \/\/ Write back links\n+        for (Link link : prevGraph.getLinks()) {\n+            setLinkControlPoints(link);\n+        }\n+    }\n+\n+    public void positionNewLayoutNodes(List<LayoutNode> newLayoutNodes) {\n+        \/\/ First pass: Initial positioning based on unassigned neighbors\n+        newLayoutNodes.sort(LeastUnassignedNeighborsComparator);\n+\n+        for (LayoutNode node : newLayoutNodes) {\n+            Vertex vertex = node.getVertex();\n+\n+            \/\/ Gather assigned neighbors\n+            List<LayoutNode> assignedNeighbors = new ArrayList<>();\n+            for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+                if (layoutNodes.containsKey(neighborVertex)) {\n+                    assignedNeighbors.add(layoutNodes.get(neighborVertex));\n+                }\n+            }\n+\n+            if (!assignedNeighbors.isEmpty()) {\n+                if (assignedNeighbors.size() == 1) {\n+                    \/\/ Single neighbor: position around the neighbor\n+                    setPositionAroundSingleNode(node, assignedNeighbors.get(0), DISPLACEMENT_RANGE_SINGLE);\n+                } else {\n+                    \/\/ Multiple neighbors: Calculate barycenter with displacement\n+                    calculateBarycenterWithDisplacement(node, assignedNeighbors, DISPLACEMENT_RANGE_BARYCENTER);\n+                }\n+            } else {\n+                \/\/ No neighbors: Position randomly around (0, 0)\n+                setRandomPositionAroundOrigin(node, random);\n+            }\n+\n+            \/\/ Add the new node to the layout\n+            layoutNodes.put(vertex, node);\n+        }\n+\n+        \/\/ Second pass: Refine positions based on neighbor degree\n+        newLayoutNodes.sort(LAYOUT_NODE_DEGREE_COMPARATOR.reversed());\n+\n+        \/\/ Collect all nodes (existing and new)\n+        Collection<LayoutNode> allNodes = layoutNodes.values();\n+\n+        for (LayoutNode node : newLayoutNodes) {\n+            Vertex vertex = node.getVertex();\n+\n+            \/\/ Gather assigned neighbors\n+            List<LayoutNode> assignedNeighbors = new ArrayList<>();\n+            for (Vertex neighborVertex : prevGraph.getNeighborVertices(vertex)) {\n+                if (layoutNodes.containsKey(neighborVertex)) {\n+                    assignedNeighbors.add(layoutNodes.get(neighborVertex));\n+                }\n+            }\n+\n+            if (!assignedNeighbors.isEmpty()) {\n+                \/\/ Refine position based on force-based method\n+                applyForceBasedAdjustment(node, assignedNeighbors, allNodes);\n+            }\n+\n+            \/\/ Ensure node's position remains updated in the layout\n+            layoutNodes.put(vertex, node);\n+        }\n+    }\n+\n+    \/**\n+     * Applies a force-based adjustment to the position of a given layout node\n+     * based on repulsive forces from all other nodes and attractive forces from its assigned neighbors.\n+     * <p>\n+     * This method simulates a physical system where nodes repel each other to maintain spacing\n+     * and are pulled towards their neighbors to maintain connectivity. The forces are calculated\n+     * using Coulomb's law for repulsion and Hooke's law for attraction. The system iterates for\n+     * a fixed number of iterations to stabilize the position of the node.\n+     *\n+     * @param node               The node whose position is being adjusted.\n+     * @param assignedNeighbors  A list of neighboring nodes that attract this node.\n+     * @param allNodes           A collection of all nodes in the layout, used for repulsive forces.\n+     *\/\n+    private void applyForceBasedAdjustment(LayoutNode node, List<LayoutNode> assignedNeighbors, Collection<LayoutNode> allNodes) {\n+        \/\/ Constants for force-based adjustment\n+        final int ITERATIONS = 50; \/\/ Number of simulation iterations.\n+        final double REPULSION_CONSTANT = 1000; \/\/ Magnitude of repulsive forces.\n+        final double SPRING_CONSTANT = 0.2; \/\/ Strength of attractive forces to neighbors.\n+        final double DAMPING = 0.8; \/\/ Damping factor to reduce displacement and ensure convergence.\n+        final double IDEAL_LENGTH = 100; \/\/ Ideal distance between a node and its neighbors.\n+\n+        double posX = node.getX();\n+        double posY = node.getY();\n+        double dx = 0, dy = 0; \/\/ Displacement\n+\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            double netForceX = 0;\n+            double netForceY = 0;\n+\n+            \/\/ Repulsive forces from all other nodes\n+            for (LayoutNode otherNode : allNodes) {\n+                if (otherNode == node) continue; \/\/ Skip self\n+\n+                double deltaX = posX - otherNode.getX();\n+                double deltaY = posY - otherNode.getY();\n+                double distanceSquared = deltaX * deltaX + deltaY * deltaY;\n+                double distance = Math.sqrt(distanceSquared);\n+\n+                \/\/ If distance is zero, add small random noise to deltaX and deltaY\n+                if (distance == 0) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05; \/\/ Random value between -0.05 and 0.05\n+                    deltaY = random.nextDouble() * 0.1 - 0.05;\n+                    distanceSquared = deltaX * deltaX + deltaY * deltaY;\n+                    distance = Math.sqrt(distanceSquared);\n+                }\n+\n+                \/\/ Repulsive force (Coulomb's law)\n+                double repulsiveForce = REPULSION_CONSTANT \/ distanceSquared;\n+                netForceX += (deltaX \/ distance) * repulsiveForce;\n+                netForceY += (deltaY \/ distance) * repulsiveForce;\n+            }\n+\n+            \/\/ Attractive forces to assigned neighbors\n+            for (LayoutNode neighbor : assignedNeighbors) {\n+                double deltaX = neighbor.getX() - posX;\n+                double deltaY = neighbor.getY() - posY;\n+                double distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n+\n+                \/\/ If distance is zero, add small random noise to deltaX and deltaY\n+                if (distance == 0) {\n+                    deltaX = random.nextDouble() * 0.1 - 0.05; \/\/ Random value between -0.05 and 0.05\n+                    deltaY = random.nextDouble() * 0.1 - 0.05;\n+                    distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);\n+                }\n+\n+                \/\/ Attractive force (Hooke's law)\n+                double displacement = distance - IDEAL_LENGTH;\n+                double attractiveForce = SPRING_CONSTANT * displacement;\n+                netForceX += (deltaX \/ distance) * attractiveForce;\n+                netForceY += (deltaY \/ distance) * attractiveForce;\n+            }\n+\n+            \/\/ Update displacement with damping\n+            dx = (dx + netForceX) * DAMPING;\n+            dy = (dy + netForceY) * DAMPING;\n+\n+            \/\/ Update node position\n+            posX += dx;\n+            posY += dy;\n+        }\n+\n+        \/\/ Set final position\n+        node.setX((int) posX);\n+        node.setY((int) posY);\n+    }\n+\n+    \/\/ Utility method: position around a given node\n+    private void setPositionAroundSingleNode(LayoutNode node, LayoutNode neighbor, int displacement) {\n+        boolean neighborIsPredecessor = prevGraph.isPredecessorVertex(node.getVertex(), neighbor.getVertex());\n+        boolean neighborIsSuccessor = prevGraph.isSuccessorVertex(node.getVertex(), neighbor.getVertex());\n+\n+        int shiftY = 0;\n+        if (neighborIsPredecessor) {\n+            shiftY = displacement;\n+        } else if (neighborIsSuccessor) {\n+            shiftY = -displacement;\n+        }\n+        assert shiftY != 0;\n+\n+        int randomY = neighbor.getY() + random.nextInt(MAX_OFFSET_AROUND_NEIGHBOR + 1) + shiftY;\n+        int randomX = neighbor.getX() + random.nextInt(MAX_OFFSET_AROUND_NEIGHBOR + 1);\n+        node.setX(randomX);\n+        node.setY(randomY);\n+    }\n+\n+    \/\/ Utility method: Random position around origin\n+    private void setRandomPositionAroundOrigin(LayoutNode node, Random random) {\n+        int randomX = random.nextInt(MAX_OFFSET_AROUND_ORIGIN + 1);\n+        int randomY = random.nextInt(MAX_OFFSET_AROUND_ORIGIN + 1);\n+        node.setX(randomX);\n+        node.setY(randomY);\n+    }\n+\n+    \/\/ Utility method: Calculate barycenter with displacement\n+    private void calculateBarycenterWithDisplacement(LayoutNode node, List<LayoutNode> neighbors, int displacementRange) {\n+        double barycenterX = 0, barycenterY = 0;\n+        for (LayoutNode neighbor : neighbors) {\n+            barycenterX += neighbor.getX();\n+            barycenterY += neighbor.getY();\n+        }\n+        barycenterX \/= neighbors.size();\n+        barycenterY \/= neighbors.size();\n+\n+        \/\/ Add random displacement for slight separation\n+        int displacementX = random.nextInt(displacementRange + 1);\n+        int displacementY = random.nextInt(displacementRange + 1);\n+        node.setX((int) barycenterX + displacementX);\n+        node.setY((int) barycenterY + displacementY);\n+    }\n+\n+    \/**\n+     * Sets control points for a given link based on its start and end layout nodes.\n+     * <p>\n+     * Calculates the start and end points, applies offsets for curvature, and updates\n+     * the link's control points.\n+     *\n+     * @param link The link to process.\n+     *\/\n+    private void setLinkControlPoints(Link link) {\n+        if (link.getFrom().getVertex() == link.getTo().getVertex()) return; \/\/ Skip self-links\n+\n+        LayoutNode from = layoutNodes.get(link.getFrom().getVertex());\n+        from.setVertex(link.getFrom().getVertex());\n+        from.updateSize();\n+\n+        LayoutNode to = layoutNodes.get(link.getTo().getVertex());\n+        to.setVertex(link.getTo().getVertex());\n+        to.updateSize();\n+\n+        Point startPoint = new Point(from.getLeft() + link.getFrom().getRelativePosition().x, from.getBottom());\n+        Point endPoint = new Point(to.getLeft() + link.getTo().getRelativePosition().x, to.getTop());\n+\n+        List<Point> controlPoints = new ArrayList<>();\n+        controlPoints.add(startPoint);\n+        controlPoints.add(new Point(startPoint.x, startPoint.y + LINE_OFFSET));\n+        controlPoints.add(new Point(endPoint.x, endPoint.y - LINE_OFFSET));\n+        controlPoints.add(endPoint);\n+\n+        link.setControlPoints(controlPoints);\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/FreeInteractiveLayoutManager.java","additions":357,"deletions":0,"binary":false,"changes":357,"status":"added"},{"patch":"@@ -56,0 +56,5 @@\n+   @Override\n+    public boolean isFreeForm() {\n+        return false;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/HierarchicalLayoutManager.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -450,0 +450,57 @@\n+    \/**\n+     * Checks if the given predecessorVertex is a direct predecessor of the specified vertex.\n+     *\n+     * @param vertex The vertex to check for predecessors.\n+     * @param predecessorVertex The vertex to verify as a predecessor of the given vertex.\n+     * @return true if predecessorVertex is a direct predecessor of vertex, false otherwise.\n+     *\/\n+    public boolean isPredecessorVertex(Vertex vertex, Vertex predecessorVertex) {\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link inputLink : portLinks.getOrDefault(inputPort, Collections.emptySet())) {\n+                Vertex fromVertex = inputLink.getFrom().getVertex();\n+                if (fromVertex.equals(predecessorVertex)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Checks if the given successorVertex is a direct successor of the specified vertex.\n+     *\n+     * @param vertex The vertex to check for successors.\n+     * @param successorVertex The vertex to verify as a successor of the given vertex.\n+     * @return true if successorVertex is a direct successor of vertex, false otherwise.\n+     *\/\n+    public boolean isSuccessorVertex(Vertex vertex, Vertex successorVertex) {\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link outputLink : portLinks.getOrDefault(outputPort, Collections.emptySet())) {\n+                Vertex toVertex = outputLink.getTo().getVertex();\n+                if (toVertex.equals(successorVertex)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public List<Vertex> getNeighborVertices(Vertex vertex) {\n+        List<Vertex> neighborVertices = new ArrayList<>();\n+        for (Port inputPort : inputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link inputLink : portLinks.getOrDefault(inputPort, Collections.emptySet())) {\n+                Vertex fromVertex = inputLink.getFrom().getVertex();\n+                assert fromVertex != null;\n+                neighborVertices.add(fromVertex);\n+            }\n+        }\n+        for (Port outputPort : outputPorts.getOrDefault(vertex, Collections.emptySet())) {\n+            for (Link outputLink : portLinks.getOrDefault(outputPort, Collections.emptySet())) {\n+                Vertex toVertex = outputLink.getTo().getVertex();\n+                assert toVertex != null;\n+                neighborVertices.add(toVertex);\n+            }\n+        }\n+        return neighborVertices;\n+    }\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutGraph.java","additions":58,"deletions":1,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -52,0 +52,2 @@\n+\n+    boolean isFreeForm();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutMover.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,6 +110,1 @@\n-    \/**\n-     * Initializes the size and margins of the node.\n-     * If the node represents a real vertex, it uses the vertex's size.\n-     * Dummy nodes use default dimensions.\n-     *\/\n-    public void initSize() {\n+    public void updateSize() {\n@@ -124,0 +119,9 @@\n+    }\n+\n+    \/**\n+     * Initializes the size and margins of the node.\n+     * If the node represents a real vertex, it uses the vertex's size.\n+     * Dummy nodes use default dimensions.\n+     *\/\n+    public void initSize() {\n+        updateSize();\n","filename":"src\/utils\/IdealGraphVisualizer\/HierarchicalLayout\/src\/main\/java\/com\/sun\/hotspot\/igv\/hierarchicallayout\/LayoutNode.java","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+        public static final int INTERACTIVE_FREE_NODES = 4;\n","filename":"src\/utils\/IdealGraphVisualizer\/Settings\/src\/main\/java\/com\/sun\/hotspot\/igv\/settings\/Settings.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -92,0 +92,1 @@\n+    private final FreeInteractiveLayoutManager freeInteractiveLayoutManager;\n@@ -514,0 +515,1 @@\n+        freeInteractiveLayoutManager = new FreeInteractiveLayoutManager();\n@@ -646,0 +648,2 @@\n+                if (layoutMover.isFreeForm()) return;\n+\n@@ -705,2 +709,6 @@\n-                int shiftY = magnetToStartLayerY(widget, location);\n-\n+                int shiftY;\n+                if (layoutMover.isFreeForm()) {\n+                    shiftY = location.y - widget.getLocation().y;\n+                } else {\n+                    shiftY = magnetToStartLayerY(widget, location);\n+                }\n@@ -716,1 +724,0 @@\n-                                Point toPt = lw.getTo();\n@@ -718,4 +725,8 @@\n-                                if (toPt != null && fromPt != null) {\n-                                    int xTo = toPt.x + shiftX;\n-                                    int yTo = toPt.y + shiftY;\n-                                    lw.setTo(new Point(xTo, yTo));\n+                                Point toPt = lw.getTo();\n+                                if (toPt == null || fromPt == null) {\n+                                    continue;\n+                                }\n+                                int xTo = toPt.x + shiftX;\n+                                int yTo = toPt.y + shiftY;\n+                                lw.setTo(new Point(xTo, yTo));\n+                                if (!layoutMover.isFreeForm()) {\n@@ -738,4 +749,7 @@\n-                                if (toPt != null && fromPt != null) {\n-                                    int xFrom = fromPt.x + shiftX;\n-                                    int yFrom = fromPt.y + shiftY;\n-                                    lw.setFrom(new Point(xFrom, yFrom));\n+                                if (toPt == null || fromPt == null) {\n+                                    continue;\n+                                }\n+                                int xFrom = fromPt.x + shiftX;\n+                                int yFrom = fromPt.y + shiftY;\n+                                lw.setFrom(new Point(xFrom, yFrom));\n+                                if (!layoutMover.isFreeForm()) {\n@@ -756,4 +770,6 @@\n-                FigureWidget fw = getWidget(selectedFigures.iterator().next());\n-                pointerWidget.setVisible(true);\n-                Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n-                ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                if (selectedFigures.size() == 1 && !layoutMover.isFreeForm()) {\n+                    FigureWidget fw = getWidget(selectedFigures.iterator().next());\n+                    pointerWidget.setVisible(true);\n+                    Point newLocation = new Point(fw.getLocation().x + shiftX -3, fw.getLocation().y + shiftY);\n+                    ActionFactory.createDefaultMoveProvider().setNewLocation(pointerWidget, newLocation);\n+                }\n@@ -837,1 +853,3 @@\n-        if (getModel().getShowStableSea()) {\n+        if (getModel().getShowFreeInteractive()) {\n+            doFreeInteractiveLayout(visibleFigures, visibleConnections);\n+        } else if (getModel().getShowStableSea()) {\n@@ -907,0 +925,6 @@\n+    private void doFreeInteractiveLayout(Set<Figure> visibleFigures, Set<Connection> visibleConnections) {\n+        layoutMover = freeInteractiveLayoutManager;\n+        freeInteractiveLayoutManager.setCutEdges(model.getCutEdges());\n+        freeInteractiveLayoutManager.doLayout(new LayoutGraph(visibleConnections, visibleFigures));\n+    }\n+\n@@ -1111,0 +1135,46 @@\n+    private void processFreeForm(OutputSlot outputSlot, List<FigureConnection> connections) {\n+        for (FigureConnection connection : connections) {\n+            if (isVisibleFigureConnection(connection)) {\n+                boolean isBold = false;\n+                boolean isDashed = true;\n+                boolean isVisible = true;\n+                if (connection.getStyle() == Connection.ConnectionStyle.BOLD) {\n+                    isBold = true;\n+                } else if (connection.getStyle() == Connection.ConnectionStyle.INVISIBLE) {\n+                    isVisible = false;\n+                }\n+                if (connection.getStyle() != Connection.ConnectionStyle.DASHED) {\n+                    isDashed = false;\n+                }\n+\n+\n+                List<Point> controlPoints = connection.getControlPoints();\n+                if (controlPoints.size() <= 2) continue;\n+                Point firstPoint = controlPoints.get(0); \/\/ First point\n+                Point lastPoint = controlPoints.get(controlPoints.size() - 1); \/\/ Last point\n+                List<FigureConnection> connectionList = new ArrayList<>(Collections.singleton(connection));\n+                LineWidget line = new LineWidget(this, outputSlot, connectionList, firstPoint, lastPoint, null, isBold, isDashed);\n+                line.setFromControlYOffset(50);\n+                line.setToControlYOffset(-50);\n+                line.setVisible(isVisible);\n+                connectionLayer.addChild(line);\n+\n+                addObject(new ConnectionSet(connectionList), line);\n+                line.getActions().addAction(hoverAction);\n+\n+                if (outputSlotToLineWidget.containsKey(outputSlot)) {\n+                    outputSlotToLineWidget.get(outputSlot).add(line);\n+                } else {\n+                    outputSlotToLineWidget.put(outputSlot, new HashSet<>(Collections.singleton(line)));\n+                }\n+\n+                InputSlot inputSlot = connection.getInputSlot();\n+                if (inputSlotToLineWidget.containsKey(inputSlot)) {\n+                    inputSlotToLineWidget.get(inputSlot).add(line);\n+                } else {\n+                    inputSlotToLineWidget.put(inputSlot, new HashSet<>(Collections.singleton(line)));\n+                }\n+            }\n+        }\n+    }\n+\n@@ -1284,1 +1354,5 @@\n-                processOutputSlot(outputSlot, connectionList, 0, null, null);\n+                if (layoutMover != null && layoutMover.isFreeForm()) {\n+                    processFreeForm(outputSlot, connectionList);\n+                } else {\n+                    processOutputSlot(outputSlot, connectionList, 0, null, null);\n+                }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramScene.java","additions":91,"deletions":17,"binary":false,"changes":108,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+    private boolean showFreeInteractive;\n@@ -107,0 +108,11 @@\n+    public boolean getShowFreeInteractive() {\n+        return showFreeInteractive;\n+    }\n+\n+    public void setShowFreeInteractive(boolean enable) {\n+        showFreeInteractive = enable;\n+        if (enable) {\n+            diagramChangedEvent.fire();\n+        }\n+    }\n+\n@@ -227,0 +239,1 @@\n+        showFreeInteractive = Settings.get().getInt(Settings.DEFAULT_VIEW, Settings.DEFAULT_VIEW_DEFAULT) == Settings.DefaultView.INTERACTIVE_FREE_NODES;\n@@ -269,1 +282,1 @@\n-        if (nodes.size() >= 1) {\n+        if (!nodes.isEmpty()) {\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/DiagramViewModel.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -179,0 +179,5 @@\n+        JToggleButton freeInteractiveLayoutButton = new JToggleButton(new EnableFreeLayoutAction(this));\n+        freeInteractiveLayoutButton.setSelected(diagramViewModel.getShowFreeInteractive());\n+        layoutButtons.add(freeInteractiveLayoutButton);\n+        toolBar.add(freeInteractiveLayoutButton);\n+\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/EditorTopComponent.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,49 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+package com.sun.hotspot.igv.view.actions;\n+\n+import com.sun.hotspot.igv.view.EditorTopComponent;\n+import java.beans.PropertyChangeEvent;\n+\n+public class EnableFreeLayoutAction extends EnableLayoutAction {\n+\n+    public EnableFreeLayoutAction(EditorTopComponent etc) {\n+        super(etc);\n+    }\n+\n+    @Override\n+    protected String iconResource() {\n+        return \"com\/sun\/hotspot\/igv\/view\/images\/dynamic.png\";\n+    }\n+\n+    @Override\n+    protected String getDescription() {\n+        return \"Show dynamic free layout\";\n+    }\n+\n+    @Override\n+    public void propertyChange(PropertyChangeEvent evt) {\n+        editor.getModel().setShowFreeInteractive(this.isSelected());\n+    }\n+}\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/actions\/EnableFreeLayoutAction.java","additions":49,"deletions":0,"binary":false,"changes":49,"status":"added"},{"patch":"@@ -33,1 +33,0 @@\n-import com.sun.hotspot.igv.view.actions.CustomSelectAction;\n@@ -35,0 +34,1 @@\n+import java.awt.geom.CubicCurve2D;\n@@ -41,0 +41,2 @@\n+\n+import com.sun.hotspot.igv.view.actions.CustomSelectAction;\n@@ -73,0 +75,2 @@\n+    private int fromControlYOffset;\n+    private int toControlYOffset;\n@@ -175,0 +179,10 @@\n+    public void setFromControlYOffset(int fromControlYOffset) {\n+        this.fromControlYOffset = fromControlYOffset;\n+        computeClientArea();\n+    }\n+\n+    public void setToControlYOffset(int toControlYOffset) {\n+        this.toControlYOffset = toControlYOffset;\n+        computeClientArea();\n+    }\n+\n@@ -228,1 +242,35 @@\n-        g.drawLine(from.x, from.y, to.x, to.y);\n+        \/\/ Define S-shaped curve with control points\n+        if (fromControlYOffset != 0 && toControlYOffset != 0) {\n+            if (from.y < to.y) { \/\/ non-reversed edges\n+                if (Math.abs(from.x - to.x) > 10) {\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x, from.y + fromControlYOffset,\n+                            to.x, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                } else {\n+                    g.drawLine(from.x, from.y, to.x, to.y);\n+                }\n+            } else {  \/\/ reverse edges\n+                if (from.x - to.x > 0) {\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x - 150, from.y + fromControlYOffset,\n+                            to.x + 150, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                } else {\n+                    \/\/ add x offset\n+                    CubicCurve2D.Float sShape = new CubicCurve2D.Float();\n+                    sShape.setCurve(from.x, from.y,\n+                            from.x + 150, from.y + fromControlYOffset,\n+                            to.x - 150, to.y + toControlYOffset,\n+                            to.x, to.y);\n+                    g.draw(sShape);\n+                }\n+            }\n+        } else {\n+            \/\/ Fallback to straight line if control points are not set\n+            g.drawLine(from.x, from.y, to.x, to.y);\n+        }\n","filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/java\/com\/sun\/hotspot\/igv\/view\/widgets\/LineWidget.java","additions":50,"deletions":2,"binary":false,"changes":52,"status":"modified"},{"filename":"src\/utils\/IdealGraphVisualizer\/View\/src\/main\/resources\/com\/sun\/hotspot\/igv\/view\/images\/dynamic.png","binary":true,"status":"added"}]}