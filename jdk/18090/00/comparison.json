{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,0 +121,8 @@\n+  if (MemTracker::tracking_level() == NMT_summary) {\n+    size_t committed = _cmr_map.commit(addr, size);\n+    if (committed != 0) {\n+      VirtualMemorySummary::record_committed_memory(committed, flag());\n+    }\n+    return true;\n+  }\n+\n@@ -206,0 +214,7 @@\n+  if (MemTracker::tracking_level() == NMT_summary) {\n+    size_t uncommitted = _cmr_map.uncommit(addr, sz);\n+    if (uncommitted != 0)\n+      VirtualMemorySummary::record_uncommitted_memory(uncommitted, flag());\n+    return true;\n+  }\n+\n@@ -288,0 +303,3 @@\n+  if (MemTracker::tracking_level() == NMT_summary) {\n+    return _cmr_map.committed_size();\n+  }\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.cpp","additions":19,"deletions":1,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,2 @@\n+#include \"runtime\/os.hpp\"\n+#include \"utilities\/bitMap.hpp\"\n@@ -54,1 +56,1 @@\n-    assert(_committed <= _reserved, \"Sanity check\");\n+    assert(_committed <= _reserved, \"Sanity check \" SIZE_FORMAT \" \" SIZE_FORMAT \" \" SIZE_FORMAT, _committed, _reserved, sz);\n@@ -64,1 +66,1 @@\n-    assert(_committed >= sz, \"Negative amount\");\n+    assert(_committed >= sz, \"Negative amount \" SIZE_FORMAT \" \" SIZE_FORMAT, _committed, sz);\n@@ -288,0 +290,46 @@\n+\/\/ CommittedMemoryRegion (CMR) Map holds Bitmap for every page inside a reserved region.\n+\/\/ When a page is committed, the corresponding bit is set, otherwise the bit is clear.\n+\/\/ Size of committed pages is count of 1 bits within a region.\n+\/\/ To find the actual change in committed size, it is enough to count the bits before and after changing the bits.\n+class CMRMap {\n+ private:\n+  CHeapBitMap _map;\n+  address _base;\n+\n+ public:\n+  CMRMap(address base, size_t size_in_bits)  : _map(size_in_bits, mtNMT), _base(base) { }\n+  inline void copy_from(const CMRMap* map) { _map.set_from(*map->bitmap()); }\n+  inline void copy_to(BitMap* map) { map->set_from(_map); }\n+  inline address bit_to_address(BitMap::idx_t index) { return index * os::vm_page_size() + _base; }\n+  inline BitMap::idx_t address_to_bit(address addr) { return (addr - _base) \/ os::vm_page_size(); }\n+\n+  inline size_t commit(address addr, size_t size) {\n+    BitMap::idx_t from_index = address_to_bit(addr);\n+    BitMap::idx_t to_index = address_to_bit(addr + size);\n+    if (to_index >= _map.size())\n+      to_index = _map.size();\n+    assert(from_index <= _map.size(), \"Index out of range. \" SIZE_FORMAT \" \" SIZE_FORMAT \" \" SIZE_FORMAT, from_index, _map.size(), to_index);\n+    BitMap::idx_t already_committed = _map.count_one_bits(from_index, to_index);\n+    _map.set_large_range(from_index, to_index);\n+    return ((size \/ os::vm_page_size()) - already_committed) * os::vm_page_size();\n+  }\n+\n+  inline size_t uncommit(address addr, size_t size) {\n+    BitMap::idx_t from_index = address_to_bit(addr);\n+    BitMap::idx_t to_index = address_to_bit(addr + size);\n+    if (to_index >= _map.size())\n+      to_index = _map.size();\n+    assert(from_index <= _map.size(), SIZE_FORMAT \" \" SIZE_FORMAT \" \" SIZE_FORMAT, from_index, _map.size(), to_index);\n+    BitMap::idx_t already_committed = _map.count_one_bits(from_index, to_index);\n+    _map.clear_large_range(from_index, to_index);\n+    return already_committed * os::vm_page_size();\n+  }\n+\n+  inline size_t committed_size() const {\n+    auto count = _map.count_one_bits();\n+    return count * os::vm_page_size();\n+  }\n+\n+  const CHeapBitMap* bitmap() const { return &_map; }\n+};\n+\n@@ -296,0 +344,1 @@\n+  CMRMap           _cmr_map;\n@@ -300,1 +349,1 @@\n-    VirtualMemoryRegion(base, size), _stack(stack), _flag(flag) { }\n+    VirtualMemoryRegion(base, size), _stack(stack), _flag(flag) , _cmr_map(base, size \/ os::vm_page_size()) { }\n@@ -304,1 +353,1 @@\n-    VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _flag(mtNone) { }\n+    VirtualMemoryRegion(base, size), _stack(NativeCallStack::empty_stack()), _flag(mtNone) , _cmr_map(base, size \/ os::vm_page_size()) { }\n@@ -308,1 +357,1 @@\n-    VirtualMemoryRegion(rr.base(), rr.size()) {\n+    VirtualMemoryRegion(rr.base(), rr.size()) , _cmr_map(rr.base(), rr.size() \/ os::vm_page_size()) {\n","filename":"src\/hotspot\/share\/nmt\/virtualMemoryTracker.hpp","additions":55,"deletions":6,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -3,1 +3,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024 Oracle and\/or its affiliates. All rights reserved.\n@@ -33,0 +33,4 @@\n+  if (MemTracker::tracking_level() != NMT_detail) {\n+    tty->print_cr(\"skipped.\");\n+    return;\n+  }\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_reserved_region.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"}]}