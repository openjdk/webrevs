{"files":[{"patch":"@@ -1867,0 +1867,126 @@\n+\/\/ Look up the method for a megamorphic invokeinterface call in a single pass over itable:\n+\/\/ - check recv_klass (actual object class) is a subtype of resolved_klass from CompiledICHolder\n+\/\/ - find a holder_klass (class that implements the method) vtable offset and get the method from vtable by index\n+\/\/ The target method is determined by <holder_klass, itable_index>.\n+\/\/ The receiver klass is in recv_klass.\n+\/\/ On success, the result will be in method_result, and execution falls through.\n+\/\/ On failure, execution transfers to the given label.\n+void MacroAssembler::lookup_interface_method_stub(Register recv_klass,\n+                                                  Register holder_klass,\n+                                                  Register resolved_klass,\n+                                                  Register method_result,\n+                                                  Register temp_itbl_klass,\n+                                                  Register scan_temp,\n+                                                  int itable_index,\n+                                                  Label& L_no_such_interface) {\n+  \/\/ 'method_result' is only used as output register at the very end of this method.\n+  \/\/ Until then, we can reuse it as 'holder_offset'.\n+  Register holder_offset = method_result;\n+\n+  assert_different_registers(resolved_klass, recv_klass, holder_klass, temp_itbl_klass, scan_temp, holder_offset);\n+\n+  BLOCK_COMMENT(\"lookup_interface_method_stub {\");\n+\n+  int vtable_start_offset = in_bytes(Klass::vtable_start_offset());\n+  int itable_offset_entry_size = itableOffsetEntry::size() * wordSize;\n+  int ioffset = in_bytes(itableOffsetEntry::interface_offset());\n+  int ooffset = in_bytes(itableOffsetEntry::offset_offset());\n+\n+  Label L_loop_search_resolved_entry, L_resolved_found, L_holder_found;\n+\n+  lwz(scan_temp, in_bytes(Klass::vtable_length_offset()), recv_klass);\n+  add_const_optimized(recv_klass, recv_klass, vtable_start_offset + ioffset);\n+\n+  \/\/ itableOffsetEntry[] itable = recv_klass + Klass::vtable_start_offset() + sizeof(vtableEntry) * recv_klass->_vtable_len;\n+  \/\/ temp_itbl_klass = itable[0]._interface;\n+  int vtblEntrySize = vtableEntry::size_in_bytes();\n+  sldi(scan_temp, scan_temp, exact_log2(vtblEntrySize));\n+\n+  ld(temp_itbl_klass, scan_temp, recv_klass);\n+\n+  li(holder_offset, 0);\n+\n+  \/\/ scan_temp = &(itable[0]._interface)\n+  add(scan_temp, scan_temp, recv_klass);\n+\n+  \/\/ Initial checks:\n+  \/\/   - if (holder_klass != resolved_klass), go to \"scan for resolved\"\n+  \/\/   - if (itable[0] == holder_klass), shortcut to \"holder found\"\n+  \/\/   - if (itable[0] == 0), no such interface\n+  cmpd(CCR0, holder_klass, resolved_klass);\n+  bne(CCR0, L_loop_search_resolved_entry);\n+\n+  cmpd(CCR0, temp_itbl_klass, holder_klass);\n+  beq(CCR0, L_holder_found);\n+\n+  cmpdi(CCR0, temp_itbl_klass, 0);\n+  beq(CCR0, L_no_such_interface);\n+\n+  \/\/ Loop: Look for holder_klass record in itable\n+  \/\/   do {\n+  \/\/     scan_temp += itable_offset_entry_size\n+  \/\/     temp_itbl_klass = *(scan_temp);\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/       goto holder_found; \/\/ Found!\n+  \/\/     }\n+  \/\/   } while (temp_itbl_klass != 0);\n+  \/\/   goto no_such_interface \/\/ Not found.\n+  Label L_search_holder;\n+  bind(L_search_holder);\n+  add_const_optimized(scan_temp, scan_temp, itable_offset_entry_size);\n+  ld(temp_itbl_klass, 0, scan_temp);\n+  cmpd(CCR0, holder_klass, temp_itbl_klass);\n+  beq(CCR0, L_holder_found);\n+  cmpdi(CCR0, temp_itbl_klass, 0);\n+  bne(CCR0, L_search_holder);\n+\n+  b(L_no_such_interface);\n+\n+  \/\/ Loop: Look for resolved_class record in itable\n+  \/\/   while (true) {\n+  \/\/     scan_temp += itable_offset_entry_size\n+  \/\/     temp_itbl_klass = *(scan_temp);\n+  \/\/     if (temp_itbl_klass == 0) {\n+  \/\/       goto L_no_such_interface;\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == resolved_klass) {\n+  \/\/        goto L_resolved_found;  \/\/ Found!\n+  \/\/     }\n+  \/\/     if (temp_itbl_klass == holder_klass) {\n+  \/\/        holder_offset = scan_temp;\n+  \/\/     }\n+  \/\/   }\n+  \/\/\n+  Label L_loop_search_resolved;\n+  bind(L_loop_search_resolved);\n+  add_const_optimized(scan_temp, scan_temp, itable_offset_entry_size);\n+  ld(temp_itbl_klass, 0, scan_temp);\n+\n+  bind(L_loop_search_resolved_entry);\n+\n+  cmpdi(CCR0, temp_itbl_klass, 0);\n+  beq(CCR0, L_no_such_interface);\n+\n+  cmpd(CCR0, temp_itbl_klass, resolved_klass);\n+  bne(CCR0, L_resolved_found);\n+\n+  cmpd(CCR0, temp_itbl_klass, holder_klass);\n+  bne(CCR0, L_loop_search_resolved);\n+\n+  mr(holder_offset, scan_temp);\n+  b(L_loop_search_resolved);\n+\n+  \/\/ See if we already have a holder klass. If not, go and scan for it.\n+  bind(L_resolved_found);\n+  cmpdi(CCR0, holder_offset, 0);\n+  beq(CCR0, L_search_holder);\n+  mr(scan_temp, holder_offset);\n+\n+  \/\/ Finally, scan_temp contains holder_klass vtable offset\n+  bind(L_holder_found);\n+  lwz(method_result, ooffset - ioffset, scan_temp);\n+  add_const_optimized(recv_klass, recv_klass, itable_index * wordSize + in_bytes(itableMethodEntry::method_offset())\n+        - vtable_start_offset - ioffset); \/\/ subtract offsets to restore the original value of recv_klass\n+  ld(method_result, method_result, recv_klass);\n+}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":126,"deletions":0,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -566,0 +566,8 @@\n+  void lookup_interface_method_stub(Register recv_klass,\n+                                    Register holder_klass,\n+                                    Register resolved_klass,\n+                                    Register method_result,\n+                                    Register temp,\n+                                    Register temp2,\n+                                    int      itable_index,\n+                                    Label&   L_no_such_interface);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,2 +2,2 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * Copyright (c) 2012, 2021 SAP SE. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024 SAP SE. All rights reserved.\n@@ -171,1 +171,1 @@\n-  \/\/  R19_method: Interface\n+  \/\/  R19_method: CompiledICData\n@@ -175,4 +175,5 @@\n-  const Register rcvr_klass = R11_scratch1,\n-                 interface  = R12_scratch2,\n-                 tmp1       = R21_tmp1,\n-                 tmp2       = R22_tmp2;\n+  const Register recv_klass     = R11_scratch1,\n+                 holder_klass   = R12_scratch2, \/\/ declaring interface klass (DEFC)\n+                 resolved_klass = R21_tmp1,     \/\/ resolved  interface klass (REFC)\n+                 temp           = R22_tmp2,\n+                 temp2          = R23_tmp3;\n@@ -181,1 +182,1 @@\n-  __ load_klass_check_null(rcvr_klass, R3_ARG1);\n+  __ load_klass_check_null(recv_klass, R3_ARG1);\n@@ -184,4 +185,2 @@\n-  __ ld(interface, CompiledICData::itable_refc_klass_offset(), R19_method);\n-  __ lookup_interface_method(rcvr_klass, interface, noreg,\n-                             R0, tmp1, tmp2,\n-                             L_no_such_interface, \/*return_method=*\/ false);\n+  __ ld(resolved_klass, CompiledICData::itable_refc_klass_offset(), R19_method);\n+  __ ld(holder_klass,   CompiledICData::itable_defc_klass_offset(), R19_method);\n@@ -190,4 +189,2 @@\n-  __ ld(interface, CompiledICData::itable_defc_klass_offset(), R19_method);\n-  __ lookup_interface_method(rcvr_klass, interface, itable_index,\n-                             R19_method, tmp1, tmp2,\n-                             L_no_such_interface, \/*return_method=*\/ true);\n+  __ lookup_interface_method_stub(recv_klass, holder_klass, resolved_klass, R19_method,\n+                                  temp, temp2, itable_index, L_no_such_interface);\n@@ -197,1 +194,0 @@\n-    Label ok;\n@@ -199,3 +195,1 @@\n-    __ bne(CCR0, ok);\n-    __ stop(\"method is null\");\n-    __ bind(ok);\n+    __ asm_assert(false \/* check_equal *\/, \"method is null\");\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":14,"deletions":20,"binary":false,"changes":34,"status":"modified"}]}