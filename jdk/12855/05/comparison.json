{"files":[{"patch":"@@ -258,1 +258,1 @@\n-  _flags = ciFlags(fd->access_flags());\n+  _flags = ciFlags(fd->access_flags(), fd->field_flags().is_stable(), fd->field_status().is_initialized_final_update());\n","filename":"src\/hotspot\/share\/ci\/ciField.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,2 @@\n+  bool _stable;\n+  bool _intialized_final_update;\n@@ -44,2 +46,3 @@\n-  ciFlags()                  { _flags = 0; }\n-  ciFlags(AccessFlags flags) { _flags = flags.as_int(); }\n+  ciFlags() :_flags(0), _stable(false), _intialized_final_update(false) { }\n+  ciFlags(AccessFlags flags, bool is_stable = false, bool is_initialized_final_update = false) :\n+    _flags(flags.as_int()), _stable(is_stable), _intialized_final_update(is_initialized_final_update) { }\n@@ -61,1 +64,1 @@\n-  bool is_stable               () const { return (_flags & JVM_ACC_FIELD_STABLE              ) != 0; }\n+  bool is_stable               () const { return _stable; }\n@@ -66,1 +69,1 @@\n-  bool has_initialized_final_update() const { return (_flags & JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE) != 0; };\n+  bool has_initialized_final_update() const { return _intialized_final_update; };\n","filename":"src\/hotspot\/share\/ci\/ciFlags.hpp","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -1474,1 +1475,0 @@\n-  assert(nullptr == _fields, \"invariant\");\n@@ -1487,24 +1487,3 @@\n-  \/\/ The field array starts with tuples of shorts\n-  \/\/ [access, name index, sig index, initial value index, byte offset].\n-  \/\/ A generic signature slot only exists for field with generic\n-  \/\/ signature attribute. And the access flag is set with\n-  \/\/ JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE for that field. The generic\n-  \/\/ signature slots are at the end of the field array and after all\n-  \/\/ other fields data.\n-  \/\/\n-  \/\/   f1: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/   f2: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/       ...\n-  \/\/   fn: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/       [generic signature index]\n-  \/\/       [generic signature index]\n-  \/\/       ...\n-  \/\/\n-  \/\/ Allocate a temporary resource array for field data. For each field,\n-  \/\/ a slot is reserved in the temporary array for the generic signature\n-  \/\/ index. After parsing all fields, the data are copied to a permanent\n-  \/\/ array and any unused slots will be discarded.\n-  ResourceMark rm(THREAD);\n-  u2* const fa = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD,\n-                                              u2,\n-                                              total_fields * (FieldInfo::field_slots + 1));\n+  \/\/ Allocate a temporary resource array to collect field data.\n+  \/\/ After parsing all fields, data are stored in a UNSIGNED5 compressed stream.\n+  _temp_field_info = new GrowableArray<FieldInfo>(total_fields);\n@@ -1512,3 +1491,1 @@\n-  \/\/ The generic signature slots start after all other fields' data.\n-  int generic_signature_slot = total_fields * FieldInfo::field_slots;\n-  int num_generic_signature = 0;\n+  ResourceMark rm(THREAD);\n@@ -1523,0 +1500,1 @@\n+    FieldInfo::FieldFlags fieldFlags(0);\n@@ -1581,4 +1559,1 @@\n-        access_flags.set_field_has_generic_signature();\n-        fa[generic_signature_slot] = generic_signature_index;\n-        generic_signature_slot ++;\n-        num_generic_signature ++;\n+        fieldFlags.update_generic(true);\n@@ -1588,5 +1563,0 @@\n-    FieldInfo* const field = FieldInfo::from_field_array(fa, n);\n-    field->initialize(access_flags.as_short(),\n-                      name_index,\n-                      signature_index,\n-                      constantvalue_index);\n@@ -1598,6 +1568,4 @@\n-    \/\/ After field is initialized with type, we can augment it with aux info\n-    if (parsed_annotations.has_any_annotations()) {\n-      parsed_annotations.apply_to(field);\n-      if (field->is_contended()) {\n-        _has_contended_fields = true;\n-      }\n+    FieldInfo fi(access_flags, name_index, signature_index, constantvalue_index, fieldFlags);\n+    fi.set_index(n);\n+    if (fieldFlags.is_generic()) {\n+      fi.set_generic_signature_index(generic_signature_index);\n@@ -1605,0 +1573,5 @@\n+    parsed_annotations.apply_to(&fi);\n+    if (fi.field_flags().is_contended()) {\n+      _has_contended_fields = true;\n+    }\n+    _temp_field_info->append(fi);\n@@ -1606,0 +1579,1 @@\n+  assert(_temp_field_info->length() == length, \"Must be\");\n@@ -1616,1 +1590,1 @@\n-          const FieldInfo* const f = FieldInfo::from_field_array(fa, i);\n+          const FieldInfo* const f = _temp_field_info->adr_at(i);\n@@ -1631,7 +1605,6 @@\n-      FieldInfo* const field = FieldInfo::from_field_array(fa, index);\n-      field->initialize((u2)JVM_ACC_FIELD_INTERNAL,\n-                        (u2)(injected[n].name_index),\n-                        (u2)(injected[n].signature_index),\n-                        0);\n-\n-      const BasicType type = Signature::basic_type(injected[n].signature());\n+      FieldInfo::FieldFlags fflags(0);\n+      fflags.update_injected(true);\n+      AccessFlags aflags;\n+      FieldInfo fi(aflags, (u2)(injected[n].name_index), (u2)(injected[n].signature_index), 0, fflags);\n+      fi.set_index(index);\n+      _temp_field_info->append(fi);\n@@ -1640,0 +1613,1 @@\n+      const BasicType type = Signature::basic_type(injected[n].signature());\n@@ -1645,21 +1619,1 @@\n-  assert(nullptr == _fields, \"invariant\");\n-\n-  _fields =\n-    MetadataFactory::new_array<u2>(_loader_data,\n-                                   index * FieldInfo::field_slots + num_generic_signature,\n-                                   CHECK);\n-  \/\/ Sometimes injected fields already exist in the Java source so\n-  \/\/ the fields array could be too long.  In that case the\n-  \/\/ fields array is trimmed. Also unused slots that were reserved\n-  \/\/ for generic signature indexes are discarded.\n-  {\n-    int i = 0;\n-    for (; i < index * FieldInfo::field_slots; i++) {\n-      _fields->at_put(i, fa[i]);\n-    }\n-    for (int j = total_fields * FieldInfo::field_slots;\n-         j < generic_signature_slot; j++) {\n-      _fields->at_put(i++, fa[j]);\n-    }\n-    assert(_fields->length() == i, \"\");\n-  }\n+  assert(_temp_field_info->length() == index, \"Must be\");\n@@ -1678,3 +1632,3 @@\n-      for (AllFieldStream fs(_fields, cp); !fs.done(); fs.next()) {\n-        name = fs.name();\n-        sig = fs.signature();\n+      for (int i = 0; i < _temp_field_info->length(); i++) {\n+        name = _temp_field_info->adr_at(i)->name(_cp);\n+        sig = _temp_field_info->adr_at(i)->signature(_cp);\n@@ -2058,0 +2012,1 @@\n+    \/\/ Setting the contended group also sets the contended bit in field flags\n@@ -2060,1 +2015,1 @@\n-    f->set_stable(true);\n+    (f->field_flags_addr())->update_stable(true);\n@@ -3972,1 +3927,2 @@\n-  this_klass->set_fields(_fields, java_fields_count);\n+  this_klass->set_fieldinfo_stream(_fieldinfo_stream);\n+  this_klass->set_fields_status(_fields_status);\n@@ -5319,1 +5275,2 @@\n-  assert(nullptr == _fields, \"invariant\");\n+  assert(nullptr == _fieldinfo_stream, \"invariant\");\n+  assert(nullptr == _fields_status, \"invariant\");\n@@ -5551,1 +5508,2 @@\n-  _fields(nullptr),\n+  _fieldinfo_stream(nullptr),\n+  _fields_status(nullptr),\n@@ -5570,0 +5528,1 @@\n+  _temp_field_info(nullptr),\n@@ -5641,1 +5600,2 @@\n-  _fields = nullptr;\n+  _fieldinfo_stream = nullptr;\n+  _fields_status = nullptr;\n@@ -5659,2 +5619,7 @@\n-  if (_fields != nullptr) {\n-    MetadataFactory::free_array<u2>(_loader_data, _fields);\n+\n+  if (_fieldinfo_stream != nullptr) {\n+    MetadataFactory::free_array<u1>(_loader_data, _fieldinfo_stream);\n+  }\n+\n+  if (_fields_status != nullptr) {\n+    MetadataFactory::free_array<FieldStatus>(_loader_data, _fields_status);\n@@ -5897,1 +5862,1 @@\n-  assert(_fields != nullptr, \"invariant\");\n+  assert(_temp_field_info != nullptr, \"invariant\");\n@@ -6053,1 +6018,1 @@\n-  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, _fields,\n+  FieldLayoutBuilder lb(class_name(), super_klass(), _cp, \/*_fields*\/ _temp_field_info,\n@@ -6056,0 +6021,8 @@\n+\n+  int injected_fields_count = _temp_field_info->length() - _java_fields_count;\n+  _fieldinfo_stream =\n+    FieldInfoStream::create_FieldInfoStream(_temp_field_info, _java_fields_count,\n+                                            injected_fields_count, loader_data(), CHECK);\n+  _fields_status =\n+    MetadataFactory::new_array<FieldStatus>(_loader_data, _temp_field_info->length(),\n+                                            FieldStatus(0), CHECK);\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":57,"deletions":84,"binary":false,"changes":141,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -124,1 +125,2 @@\n-  Array<u2>* _fields;\n+  Array<u1>* _fieldinfo_stream;\n+  Array<FieldStatus>* _fields_status;\n@@ -144,0 +146,1 @@\n+  GrowableArray<FieldInfo>* _temp_field_info;\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-void FieldGroup::add_primitive_field(AllFieldStream fs, BasicType type) {\n+void FieldGroup::add_primitive_field(int idx, BasicType type) {\n@@ -85,1 +85,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for primitive types *\/, false);\n@@ -92,1 +92,1 @@\n-void FieldGroup::add_oop_field(AllFieldStream fs) {\n+void FieldGroup::add_oop_field(int idx) {\n@@ -94,1 +94,1 @@\n-  LayoutRawBlock* block = new LayoutRawBlock(fs.index(), LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n+  LayoutRawBlock* block = new LayoutRawBlock(idx, LayoutRawBlock::REGULAR, size, size \/* alignment == size for oops *\/, true);\n@@ -108,2 +108,2 @@\n-FieldLayout::FieldLayout(Array<u2>* fields, ConstantPool* cp) :\n-  _fields(fields),\n+FieldLayout::FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp) :\n+  _field_info(field_info),\n@@ -234,1 +234,1 @@\n-      FieldInfo::from_field_array(_fields, block->field_index())->set_offset(block->offset());\n+      _field_info->adr_at(block->field_index())->set_offset(block->offset());\n@@ -293,1 +293,1 @@\n-  FieldInfo::from_field_array(_fields, block->field_index())->set_offset(block->offset());\n+  _field_info->adr_at(block->field_index())->set_offset(block->offset());\n@@ -301,1 +301,1 @@\n-    for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+    for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n@@ -433,1 +433,1 @@\n-        FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n+        FieldInfo* fi = _field_info->adr_at(b->field_index());\n@@ -444,1 +444,1 @@\n-        FieldInfo* fi = FieldInfo::from_field_array(_fields, b->field_index());\n+        FieldInfo* fi = _field_info->adr_at(b->field_index());\n@@ -467,1 +467,1 @@\n-          for (AllFieldStream fs(ik->fields(), ik->constants()); !fs.done(); fs.next()) {\n+          for (AllFieldStream fs(ik->fieldinfo_stream(), ik->constants()); !fs.done(); fs.next()) {\n@@ -502,1 +502,1 @@\n-      Array<u2>* fields, bool is_contended, FieldLayoutInfo* info) :\n+      GrowableArray<FieldInfo>* field_info, bool is_contended, FieldLayoutInfo* info) :\n@@ -506,1 +506,1 @@\n-  _fields(fields),\n+  _field_info(field_info),\n@@ -532,1 +532,1 @@\n-  _layout = new FieldLayout(_fields, _constant_pool);\n+  _layout = new FieldLayout(_field_info, _constant_pool);\n@@ -538,1 +538,1 @@\n-  _static_layout = new FieldLayout(_fields, _constant_pool);\n+  _static_layout = new FieldLayout(_field_info, _constant_pool);\n@@ -550,1 +550,3 @@\n-  for (AllFieldStream fs(_fields, _constant_pool); !fs.done(); fs.next()) {\n+  int idx = 0;\n+  for (GrowableArrayIterator<FieldInfo> it = _field_info->begin(); it != _field_info->end(); ++it, ++idx) {\n+    FieldInfo ctrl = _field_info->at(0);\n@@ -552,1 +554,2 @@\n-    if (fs.access_flags().is_static()) {\n+    FieldInfo fieldinfo = *it;\n+    if (fieldinfo.access_flags().is_static()) {\n@@ -556,2 +559,2 @@\n-      if (fs.is_contended()) {\n-        int g = fs.contended_group();\n+      if (fieldinfo.field_flags().is_contended()) {\n+        int g = fieldinfo.contended_group();\n@@ -569,1 +572,1 @@\n-    BasicType type = Signature::basic_type(fs.signature());\n+    BasicType type = Signature::basic_type(fieldinfo.signature(_constant_pool));\n@@ -579,1 +582,1 @@\n-        group->add_primitive_field(fs, type);\n+        group->add_primitive_field(idx, type);\n@@ -584,1 +587,1 @@\n-        group->add_oop_field(fs);\n+        group->add_oop_field(idx);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.cpp","additions":26,"deletions":23,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -144,2 +144,2 @@\n-  void add_primitive_field(AllFieldStream fs, BasicType type);\n-  void add_oop_field(AllFieldStream fs);\n+  void add_primitive_field(int idx, BasicType type);\n+  void add_oop_field(int idx);\n@@ -167,1 +167,1 @@\n-  Array<u2>* _fields;\n+  GrowableArray<FieldInfo>* _field_info;\n@@ -174,1 +174,1 @@\n-  FieldLayout(Array<u2>* fields, ConstantPool* cp);\n+  FieldLayout(GrowableArray<FieldInfo>* field_info, ConstantPool* cp);\n@@ -233,1 +233,1 @@\n-  Array<u2>* _fields;\n+  GrowableArray<FieldInfo>* _field_info;\n@@ -247,1 +247,1 @@\n-                     Array<u2>* fields, bool is_contended, FieldLayoutInfo* info);\n+                     GrowableArray<FieldInfo>* field_info, bool is_contended, FieldLayoutInfo* info);\n","filename":"src\/hotspot\/share\/classfile\/fieldLayoutBuilder.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -864,4 +865,16 @@\n-      for (JavaFieldStream fs(InstanceKlass::cast(k)); !fs.done(); fs.next()) {\n-        if (fs.access_flags().is_static()) {\n-          int real_offset = fs.offset() + InstanceMirrorKlass::offset_of_static_fields();\n-          fs.set_offset(real_offset);\n+\n+      \/\/ Unfortunately, the FieldInfo stream is encoded with UNSIGNED5 which doesn't allow\n+      \/\/ content updates. So the FieldInfo stream has to be decompressed into a temporary array,\n+      \/\/ static fields offsets are updated in this array before reencoding everything into\n+      \/\/ a new UNSIGNED5 stream, and substitute it to the old FieldInfo stream.\n+\n+      int java_fields;\n+      int injected_fields;\n+      InstanceKlass* ik = InstanceKlass::cast(k);\n+      GrowableArray<FieldInfo>* fields =\n+        FieldInfoStream::create_FieldInfoArray(ik->fieldinfo_stream(),\n+                                               &java_fields, &injected_fields);\n+      for (int i = 0; i < fields->length(); i++) {\n+        FieldInfo* fi = fields->adr_at(i);\n+        if (fi->access_flags().is_static()) {\n+          fi->set_offset(fi->offset() + InstanceMirrorKlass::offset_of_static_fields());\n@@ -870,0 +883,5 @@\n+      Array<u1>* old_stream = ik->fieldinfo_stream();\n+      assert(fields->length() == (java_fields + injected_fields), \"Must be\");\n+      Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, k->class_loader_data(), CHECK);\n+      ik->set_fieldinfo_stream(new_fis);\n+      MetadataFactory::free_array<u1>(k->class_loader_data(), old_stream);\n@@ -5335,1 +5353,1 @@\n-    if (!may_be_java && !fs.access_flags().is_internal()) {\n+    if (!may_be_java && !fs.field_flags().is_injected()) {\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":23,"deletions":5,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -1158,1 +1158,1 @@\n-  if ((ik->field_access_flags(index) & JVM_ACC_FIELD_ACCESS_WATCHED) == 0) return;\n+  if (!ik->field_status(index).is_access_watched()) return;\n@@ -1183,1 +1183,1 @@\n-  if ((ik->field_access_flags(index) & JVM_ACC_FIELD_MODIFICATION_WATCHED) == 0) return;\n+  if (!ik->field_status(index).is_modification_watched()) return;\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -794,2 +794,2 @@\n-  if (info.is_null() || JVMCIENV->get_length(info) != 3) {\n-    JVMCI_ERROR_NULL(\"info must not be null and have a length of 3\");\n+  if (info.is_null() || JVMCIENV->get_length(info) != 4) {\n+    JVMCI_ERROR_NULL(\"info must not be null and have a length of 4\");\n@@ -800,0 +800,1 @@\n+  JVMCIENV->put_int_at(info, 3, fd.field_flags().as_uint());\n@@ -1947,0 +1948,19 @@\n+C2V_VMENTRY_NULL(jobjectArray, getDeclaredFieldsInfo, (JNIEnv* env, jobject, ARGUMENT_PAIR(klass)))\n+  Klass* klass = UNPACK_PAIR(Klass, klass);\n+  if (klass == nullptr) {\n+    JVMCI_THROW_0(NullPointerException);\n+  }\n+  if (!klass->is_instance_klass()) {\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"not an InstanceKlass\");\n+  }\n+  InstanceKlass* iklass = InstanceKlass::cast(klass);\n+  int java_fields, injected_fields;\n+  GrowableArray<FieldInfo>* fields = FieldInfoStream::create_FieldInfoArray(iklass->fieldinfo_stream(), &java_fields, &injected_fields);\n+  JVMCIObjectArray array = JVMCIENV->new_FieldInfo_array(fields->length(), JVMCIENV);\n+  for (int i = 0; i < fields->length(); i++) {\n+    JVMCIObject field_info = JVMCIENV->new_FieldInfo(fields->adr_at(i), JVMCI_CHECK_NULL);\n+    JVMCIENV->put_object_at(array, i, field_info);\n+  }\n+  return array.as_jobject();\n+C2V_END\n+\n@@ -2633,2 +2653,1 @@\n-  Array<u2>* fields = iklass->fields();\n-  if (index < 0 ||index > fields->length()) {\n+  if (index < 0 || index > iklass->total_fields_count()) {\n@@ -2798,0 +2817,1 @@\n+#define FIELDINFO               \"Ljdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl$FieldInfo;\"\n@@ -2895,0 +2915,1 @@\n+  {CC \"getDeclaredFieldsInfo\",                        CC \"(\" HS_KLASS2 \")[\" FIELDINFO,                                                      FN_PTR(getDeclaredFieldsInfo)},\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":25,"deletions":4,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -1423,0 +1423,27 @@\n+JVMCIObject JVMCIEnv::new_FieldInfo(FieldInfo* fieldinfo, JVMCI_TRAPS) {\n+  JavaThread* THREAD = JavaThread::current(); \/\/ For exception macros.\n+  if (is_hotspot()) {\n+    HotSpotJVMCI::FieldInfo::klass()->initialize(CHECK_(JVMCIObject()));\n+    oop obj = HotSpotJVMCI::FieldInfo::klass()->allocate_instance(CHECK_(JVMCIObject()));\n+    Handle obj_h(THREAD, obj);\n+    HotSpotJVMCI::FieldInfo::set_nameIndex(JVMCIENV, obj_h(), (jint)fieldinfo->name_index());\n+    HotSpotJVMCI::FieldInfo::set_signatureIndex(JVMCIENV, obj_h(), (jint)fieldinfo->signature_index());\n+    HotSpotJVMCI::FieldInfo::set_offset(JVMCIENV, obj_h(), (jint)fieldinfo->offset());\n+    HotSpotJVMCI::FieldInfo::set_classfileFlags(JVMCIENV, obj_h(), (jint)fieldinfo->access_flags().as_int());\n+    HotSpotJVMCI::FieldInfo::set_internalFlags(JVMCIENV, obj_h(), (jint)fieldinfo->field_flags().as_uint());\n+    HotSpotJVMCI::FieldInfo::set_initializerIndex(JVMCIENV, obj_h(), (jint)fieldinfo->initializer_index());\n+    return wrap(obj_h());\n+  } else {\n+    JNIAccessMark jni(this, THREAD);\n+    jobject result = jni()->NewObject(JNIJVMCI::FieldInfo::clazz(),\n+                                      JNIJVMCI::FieldInfo::constructor(),\n+                                      (jint)fieldinfo->name_index(),\n+                                      (jint)fieldinfo->signature_index(),\n+                                      (jint)fieldinfo->offset(),\n+                                      (jint)fieldinfo->access_flags().as_int(),\n+                                      (jint)fieldinfo->field_flags().as_uint(),\n+                                      (jint)fieldinfo->initializer_index());\n+\n+    return wrap(result);\n+  }\n+}\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.cpp","additions":27,"deletions":0,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -406,0 +406,1 @@\n+  JVMCIObject new_FieldInfo(FieldInfo* fieldinfo, JVMCI_TRAPS);\n","filename":"src\/hotspot\/share\/jvmci\/jvmciEnv.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -77,1 +77,9 @@\n-    int_field(HotSpotResolvedJavaFieldImpl, modifiers)                                                        \\\n+  end_class                                                                                                   \\\n+  start_class(FieldInfo, jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl_FieldInfo)                           \\\n+    int_field(FieldInfo, nameIndex)                                                                           \\\n+    int_field(FieldInfo, signatureIndex)                                                                      \\\n+    int_field(FieldInfo, offset)                                                                              \\\n+    int_field(FieldInfo, classfileFlags)                                                                      \\\n+    int_field(FieldInfo, internalFlags)                                                                       \\\n+    int_field(FieldInfo, initializerIndex)                                                                    \\\n+    jvmci_constructor(FieldInfo, \"(IIIIII)V\")                                                                 \\\n","filename":"src\/hotspot\/share\/jvmci\/jvmciJavaClasses.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  nonstatic_field(InstanceKlass,               _fields,                                       Array<u2>*)                            \\\n+  nonstatic_field(InstanceKlass,               _fieldinfo_stream,                             Array<u1>*)                            \\\n@@ -396,1 +396,0 @@\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_SIZE\", FIELDINFO_TAG_SIZE) \\\n@@ -414,3 +413,0 @@\n-  declare_constant(JVM_ACC_FIELD_INTERNAL)                                \\\n-  declare_constant(JVM_ACC_FIELD_STABLE)                                  \\\n-  declare_constant(JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE)                   \\\n@@ -418,0 +414,2 @@\n+  declare_constant(FieldInfo::FieldFlags::_ff_injected)                   \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_stable)                     \\\n@@ -424,1 +422,0 @@\n-  declare_preprocessor_constant(\"JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE\", JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE) \\\n@@ -638,7 +635,0 @@\n-  declare_constant(FieldInfo::access_flags_offset)                        \\\n-  declare_constant(FieldInfo::name_index_offset)                          \\\n-  declare_constant(FieldInfo::signature_index_offset)                     \\\n-  declare_constant(FieldInfo::initval_index_offset)                       \\\n-  declare_constant(FieldInfo::low_packed_offset)                          \\\n-  declare_constant(FieldInfo::high_packed_offset)                         \\\n-  declare_constant(FieldInfo::field_slots)                                \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":3,"deletions":13,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,0 +41,1 @@\n+  template(jdk_vm_ci_hotspot_HotSpotResolvedObjectTypeImpl_FieldInfo, \"jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl$FieldInfo\")        \\\n","filename":"src\/hotspot\/share\/jvmci\/vmSymbols_jvmci.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,0 +44,1 @@\n+  friend class FieldInfoStream;\n","filename":"src\/hotspot\/share\/oops\/array.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,143 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/fieldInfo.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+\n+void FieldInfo::print(outputStream* os, ConstantPool* cp) {\n+  os->print_cr(\"index=%d name_index=%d name=%s signature_index=%d signature=%s offset=%d \"\n+               \"AccessFlags=%d FieldFlags=%d \"\n+               \"initval_index=%d gen_signature_index=%d, gen_signature=%s contended_group=%d\",\n+                index(),\n+                name_index(), name(cp)->as_utf8(),\n+                signature_index(), signature(cp)->as_utf8(),\n+                offset(),\n+                access_flags().as_int(),\n+                field_flags().as_uint(),\n+                initializer_index(),\n+                generic_signature_index(),\n+                _field_flags.is_injected() ? lookup_symbol(generic_signature_index())->as_utf8() : cp->symbol_at(generic_signature_index())->as_utf8(),\n+                contended_group());\n+}\n+\n+void FieldInfo::print_from_growable_array(outputStream* os, GrowableArray<FieldInfo>* array, ConstantPool* cp) {\n+  for (int i = 0; i < array->length(); i++) {\n+    array->adr_at(i)->print(os, cp);\n+  }\n+}\n+\n+Array<u1>* FieldInfoStream::create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+                                                          ClassLoaderData* loader_data, TRAPS) {\n+  \/\/ The stream format described in fieldInfo.hpp is:\n+  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+  \/\/   Field := name sig offset access flags Optionals(flags)\n+  \/\/   Optionals(i) := initval?[i&is_init]     \/\/ ConstantValue attr\n+  \/\/                   gsig?[i&is_generic]     \/\/ signature attr\n+  \/\/                   group?[i&is_contended]  \/\/ Contended anno (group)\n+  \/\/   End = 0\n+\n+  using StreamSizer = UNSIGNED5::Sizer<>;\n+  using StreamFieldSizer = Mapper<StreamSizer>;\n+  StreamSizer s;\n+  StreamFieldSizer sizer(&s);\n+\n+  sizer.consumer()->accept_uint(java_fields);\n+  sizer.consumer()->accept_uint(injected_fields);\n+  for (int i = 0; i < fields->length(); i++) {\n+    FieldInfo* fi = fields->adr_at(i);\n+    sizer.map_field_info(*fi);\n+  }\n+  int storage_size = sizer.consumer()->position() + 1;\n+  Array<u1>* const fis = MetadataFactory::new_array<u1>(loader_data, storage_size, CHECK_NULL);\n+\n+  using StreamWriter = UNSIGNED5::Writer<Array<u1>*, int, ArrayHelper<Array<u1>*, int>>;\n+  using StreamFieldWriter = Mapper<StreamWriter>;\n+  StreamWriter w(fis);\n+  StreamFieldWriter writer(&w);\n+\n+  writer.consumer()->accept_uint(java_fields);\n+  writer.consumer()->accept_uint(injected_fields);\n+  for (int i = 0; i < fields->length(); i++) {\n+    FieldInfo* fi = fields->adr_at(i);\n+    writer.map_field_info(*fi);\n+  }\n+\n+#ifdef ASSERT\n+  FieldInfoReader r(fis);\n+  u2 jfc = r.next_uint();\n+  assert(jfc == java_fields, \"Must be\");\n+  int ifc = r.next_uint();\n+  assert(ifc == injected_fields, \"Must be\");\n+  for (int i = 0; i < jfc + ifc; i++) {\n+    FieldInfo fi;\n+    r.read_field_info(fi);\n+    FieldInfo* fi_ref = fields->adr_at(i);\n+    assert(fi_ref->name_index() == fi.name_index(), \"Must be\");\n+    assert(fi_ref->signature_index() == fi.signature_index(), \"Must be\");\n+    assert(fi_ref->offset() == fi.offset(), \"Must be\");\n+    assert(fi_ref->access_flags().as_int() == fi.access_flags().as_int(), \"Must be\");\n+    assert(fi_ref->field_flags().as_uint() == fi.field_flags().as_uint(), \" Must be\");\n+    if(fi_ref->field_flags().is_initialized()) {\n+      assert(fi_ref->initializer_index() == fi.initializer_index(), \"Must be\");\n+    }\n+    if (fi_ref->field_flags().is_generic()) {\n+      assert(fi_ref->generic_signature_index() == fi.generic_signature_index(), \"Must be\");\n+    }\n+    if (fi_ref->field_flags().is_contended()) {\n+      assert(fi_ref->contended_group() == fi.contended_group(), \"Must be\");\n+    }\n+  }\n+#endif \/\/ ASSERT\n+\n+  return fis;\n+}\n+\n+GrowableArray<FieldInfo>* FieldInfoStream::create_FieldInfoArray(const Array<u1>* fis, int* java_fields_count, int* injected_fields_count) {\n+  int length = FieldInfoStream::num_total_fields(fis);\n+  GrowableArray<FieldInfo>* array = new GrowableArray<FieldInfo>(length);\n+  FieldInfoReader r(fis);\n+  *java_fields_count = r.next_uint();\n+  *injected_fields_count = r.next_uint();\n+  while (r.has_next()) {\n+    FieldInfo fi;\n+    r.read_field_info(fi);\n+    array->append(fi);\n+  }\n+  assert(array->length() == length, \"Must be\");\n+  assert(array->length() == *java_fields_count + *injected_fields_count, \"Must be\");\n+  return array;\n+}\n+\n+void FieldInfoStream::print_from_fieldinfo_stream(Array<u1>* fis, outputStream* os, ConstantPool* cp) {\n+  int length = FieldInfoStream::num_total_fields(fis);\n+  FieldInfoReader r(fis);\n+  int java_field_count = r.next_uint();\n+  int injected_fields_count = r.next_uint();\n+  while (r.has_next()) {\n+    FieldInfo fi;\n+    r.read_field_info(fi);\n+    fi.print(os, cp);\n+  }\n+}\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.cpp","additions":143,"deletions":0,"binary":false,"changes":143,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,1 @@\n-#include \"oops\/constantPool.hpp\"\n-#include \"oops\/symbol.hpp\"\n+#include \"memory\/allocation.hpp\"\n@@ -31,0 +30,1 @@\n+#include \"utilities\/unsigned5.hpp\"\n@@ -33,0 +33,16 @@\n+static constexpr u4 flag_mask(int pos) {\n+  return (u4)1 << pos;\n+}\n+\n+\n+\/\/ Helper class for access to the underlying Array<u1> used to\n+\/\/ store the compressed stream of FieldInfo\n+template<typename ARR, typename OFF>\n+struct ArrayHelper {\n+  uint8_t operator()(ARR a, OFF i) const { return a->at(i); };\n+  void operator()(ARR a, OFF i, uint8_t b) const { a->at_put(i,b); };\n+  \/\/ So, an expression ArrayWriterHelper() acts like these lambdas:\n+  \/\/ auto get = [&](ARR a, OFF i){ return a[i]; };\n+  \/\/ auto set = [&](ARR a, OFF i, uint8_t x){ a[i] = x; };\n+};\n+\n@@ -43,0 +59,4 @@\n+  friend class FieldInfoStream;\n+  friend class FieldStreamBase;\n+  friend class FieldInfoReader;\n+  friend class VMStructs;\n@@ -45,29 +65,0 @@\n-  \/\/ fields\n-  \/\/ Field info extracted from the class file and stored\n-  \/\/ as an array of 6 shorts.\n-\n-#define FIELDINFO_TAG_SIZE             2\n-#define FIELDINFO_TAG_OFFSET           1 << 0\n-#define FIELDINFO_TAG_CONTENDED        1 << 1\n-\n-  \/\/ Packed field has the tag, and can be either of:\n-  \/\/    hi bits <--------------------------- lo bits\n-  \/\/   |---------high---------|---------low---------|\n-  \/\/    ..........................................CO\n-  \/\/    ..........................................00  - non-contended field\n-  \/\/    [--contention_group--]....................10  - contended field with contention group\n-  \/\/    [------------------offset----------------]01  - real field offset\n-\n-  \/\/ Bit O indicates if the packed field contains an offset (O=1) or not (O=0)\n-  \/\/ Bit C indicates if the field is contended (C=1) or not (C=0)\n-  \/\/       (if it is contended, the high packed field contains the contention group)\n-\n-  enum FieldOffset {\n-    access_flags_offset      = 0,\n-    name_index_offset        = 1,\n-    signature_index_offset   = 2,\n-    initval_index_offset     = 3,\n-    low_packed_offset        = 4,\n-    high_packed_offset       = 5,\n-    field_slots              = 6\n-  };\n@@ -75,2 +66,21 @@\n- private:\n-  u2 _shorts[field_slots];\n+  class FieldFlags {\n+    friend class VMStructs;\n+    friend class JVMCIVMStructs;\n+\n+    \/\/ The ordering of this enum is totally internal.  More frequent\n+    \/\/ flags should come earlier than less frequent ones, because\n+    \/\/ earlier ones compress better.\n+    enum FieldFlagBitPosition {\n+      _ff_initialized,  \/\/ has ConstantValue initializer attribute\n+      _ff_injected,     \/\/ internal field injected by the JVM\n+      _ff_generic,      \/\/ has a generic signature\n+      _ff_stable,       \/\/ trust as stable b\/c declared as @Stable\n+      _ff_contended,    \/\/ is contended, may have contention-group\n+    };\n+\n+    \/\/ Some but not all of the flag bits signal the presence of an\n+    \/\/ additional 32-bit item in the field record.\n+    static const u4 _optional_item_bit_mask =\n+      flag_mask((int)_ff_initialized) |\n+      flag_mask((int)_ff_generic)     |\n+      flag_mask((int)_ff_contended);\n@@ -78,3 +88,2 @@\n-  void set_name_index(u2 val)                    { _shorts[name_index_offset] = val;         }\n-  void set_signature_index(u2 val)               { _shorts[signature_index_offset] = val;    }\n-  void set_initval_index(u2 val)                 { _shorts[initval_index_offset] = val;      }\n+    \/\/ boilerplate:\n+    u4 _flags;\n@@ -82,3 +91,46 @@\n-  u2 name_index() const                          { return _shorts[name_index_offset];        }\n-  u2 signature_index() const                     { return _shorts[signature_index_offset];   }\n-  u2 initval_index() const                       { return _shorts[initval_index_offset];     }\n+    bool test_flag(FieldFlagBitPosition pos) const {\n+      return (_flags & flag_mask(pos)) != 0;\n+    }\n+    void update_flag(FieldFlagBitPosition pos, bool z) {\n+      if (z)    _flags |=  flag_mask(pos);\n+      else      _flags &= ~flag_mask(pos);\n+    }\n+\n+   public:\n+    FieldFlags(u4 flags) {\n+      _flags = flags;\n+    }\n+    u4 as_uint() const { return _flags; }\n+    bool has_any_optionals() const {\n+      return (_flags & _optional_item_bit_mask) != 0;\n+    }\n+\n+    bool is_initialized() const     { return test_flag(_ff_initialized); }\n+    bool is_injected() const        { return test_flag(_ff_injected); }\n+    bool is_generic() const         { return test_flag(_ff_generic); }\n+    bool is_stable() const          { return test_flag(_ff_stable); }\n+    bool is_contended() const       { return test_flag(_ff_contended); }\n+\n+    void update_initialized(bool z) { update_flag(_ff_initialized, z); }\n+    void update_injected(bool z)    { update_flag(_ff_injected, z); }\n+    void update_generic(bool z)     { update_flag(_ff_generic, z); }\n+    void update_stable(bool z)      { update_flag(_ff_stable, z); }\n+    void update_contended(bool z)   { update_flag(_ff_contended, z); }\n+  };\n+\n+ private:\n+  \/\/ The following items are the unpacked bitwise information content\n+  \/\/ of a field record.  Per-field metadata extracted from the class\n+  \/\/ file are stored logically as a group of these items.  The\n+  \/\/ classfile parser produces these records in a temporary array, and\n+  \/\/ then compresses them into a FieldInfoStream.\n+  \/\/\n+  u4 _index;                    \/\/ which field it is\n+  u2 _name_index;               \/\/ index in CP of name\n+  u2 _signature_index;          \/\/ index in CP of descriptor\n+  u4 _offset;                   \/\/ offset in object layout\n+  AccessFlags _access_flags;    \/\/ access flags (JVM spec)\n+  FieldFlags _field_flags;      \/\/ VM defined flags (not JVM spec)\n+  u2 _initializer_index;        \/\/ index from ConstantValue attr (or 0)\n+  u2 _generic_signature_index;  \/\/ index from GenericSignature attr (or 0)\n+  u2 _contention_group;         \/\/ index from @Contended group item (or 0)\n@@ -87,6 +139,0 @@\n-  static FieldInfo* from_field_array(Array<u2>* fields, int index) {\n-    return ((FieldInfo*)fields->adr_at(index * field_slots));\n-  }\n-  static FieldInfo* from_field_array(u2* fields, int index) {\n-    return ((FieldInfo*)(fields + index * field_slots));\n-  }\n@@ -94,11 +140,8 @@\n-  void initialize(u2 access_flags,\n-                  u2 name_index,\n-                  u2 signature_index,\n-                  u2 initval_index) {\n-    _shorts[access_flags_offset] = access_flags;\n-    _shorts[name_index_offset] = name_index;\n-    _shorts[signature_index_offset] = signature_index;\n-    _shorts[initval_index_offset] = initval_index;\n-    _shorts[low_packed_offset] = 0;\n-    _shorts[high_packed_offset] = 0;\n-  }\n+  FieldInfo() : _name_index(0),\n+                _signature_index(0),\n+                _offset(0),\n+                _access_flags(AccessFlags(0)),\n+                _field_flags(FieldFlags(0)),\n+                _initializer_index(0),\n+                _generic_signature_index(0),\n+                _contention_group(0) { }\n@@ -106,5 +149,30 @@\n-  u2 access_flags() const                        { return _shorts[access_flags_offset];            }\n-  u4 offset() const {\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) != 0, \"Offset must have been set\");\n-    return build_int_from_shorts(_shorts[low_packed_offset], _shorts[high_packed_offset]) >> FIELDINFO_TAG_SIZE;\n-  }\n+  FieldInfo(AccessFlags access_flags, u2 name_index, u2 signature_index, u2 initval_index, FieldInfo::FieldFlags fflags) :\n+            _name_index(name_index),\n+            _signature_index(signature_index),\n+            _offset(0),\n+            _access_flags(access_flags),\n+            _field_flags(fflags),\n+            _initializer_index(initval_index),\n+            _generic_signature_index(0),\n+            _contention_group(0) {\n+              if (initval_index != 0) {\n+                _field_flags.update_initialized(true);\n+              }\n+            }\n+\n+  u4 index() const                           { return _index; }\n+  void set_index(u4 index)                   { _index = index; }\n+  u2 name_index() const                      { return _name_index; }\n+  void set_name_index(u2 index)              { _name_index = index; }\n+  u2 signature_index() const                 { return _signature_index; }\n+  void set_signature_index(u2 index)         { _signature_index = index; }\n+  u4 offset() const                          { return _offset; }\n+  void set_offset(u4 offset)                 { _offset = offset; }\n+  AccessFlags access_flags() const           { return _access_flags; }\n+  FieldFlags field_flags() const             { return _field_flags; }\n+  FieldFlags* field_flags_addr()             { return &_field_flags; }\n+  u2 initializer_index() const               { return _initializer_index; }\n+  void set_initializer_index(u2 index)       { _initializer_index = index; }\n+  u2 generic_signature_index() const         { return _generic_signature_index; }\n+  void set_generic_signature_index(u2 index) { _generic_signature_index = index; }\n+  u2 contention_group() const                { return _contention_group; }\n@@ -113,1 +181,1 @@\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0;\n+    return _field_flags.is_contended();\n@@ -117,7 +185,2 @@\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) != 0, \"Field must be contended\");\n-    return _shorts[high_packed_offset];\n- }\n-\n-  bool is_offset_set() const {\n-    return (_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET)!= 0;\n+    assert(is_contended(), \"\");\n+    return _contention_group;\n@@ -126,6 +189,3 @@\n-  Symbol* name(ConstantPool* cp) const {\n-    int index = name_index();\n-    if (is_internal()) {\n-      return lookup_symbol(index);\n-    }\n-    return cp->symbol_at(index);\n+  void set_contended_group(u2 group) {\n+    _field_flags.update_contended(true);\n+    _contention_group = group;\n@@ -134,6 +194,2 @@\n-  Symbol* signature(ConstantPool* cp) const {\n-    int index = signature_index();\n-    if (is_internal()) {\n-      return lookup_symbol(index);\n-    }\n-    return cp->symbol_at(index);\n+  bool is_offset_set() const {\n+    return _offset != 0;\n@@ -142,6 +198,1 @@\n-  void set_access_flags(u2 val)                  { _shorts[access_flags_offset] = val;             }\n-  void set_offset(u4 val)                        {\n-    val = val << FIELDINFO_TAG_SIZE; \/\/ make room for tag\n-    _shorts[low_packed_offset] = extract_low_short_from_int(val) | FIELDINFO_TAG_OFFSET;\n-    _shorts[high_packed_offset] = extract_high_short_from_int(val);\n-  }\n+  inline Symbol* name(ConstantPool* cp) const;\n@@ -149,6 +200,1 @@\n-  void set_contended_group(u2 val) {\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_OFFSET) == 0, \"Offset must not have been set\");\n-    assert((_shorts[low_packed_offset] & FIELDINFO_TAG_CONTENDED) == 0, \"Overwriting contended group\");\n-    _shorts[low_packed_offset] |= FIELDINFO_TAG_CONTENDED;\n-    _shorts[high_packed_offset] = val;\n-  }\n+  inline Symbol* signature(ConstantPool* cp) const;\n@@ -156,3 +202,1 @@\n-  bool is_internal() const {\n-    return (access_flags() & JVM_ACC_FIELD_INTERNAL) != 0;\n-  }\n+  inline Symbol* lookup_symbol(int symbol_index) const;\n@@ -160,7 +204,3 @@\n-  bool is_stable() const {\n-    return (access_flags() & JVM_ACC_FIELD_STABLE) != 0;\n-  }\n-  void set_stable(bool z) {\n-    if (z) _shorts[access_flags_offset] |=  JVM_ACC_FIELD_STABLE;\n-    else   _shorts[access_flags_offset] &= ~JVM_ACC_FIELD_STABLE;\n-  }\n+  void print(outputStream* os, ConstantPool* cp);\n+  void static print_from_growable_array(outputStream* os, GrowableArray<FieldInfo>* array, ConstantPool* cp);\n+};\n@@ -168,4 +208,105 @@\n-  Symbol* lookup_symbol(int symbol_index) const {\n-    assert(is_internal(), \"only internal fields\");\n-    return Symbol::vm_symbol_at(static_cast<vmSymbolID>(symbol_index));\n-  }\n+class FieldInfoStream;\n+\n+\/\/ Gadget for sizing and\/or writing a stream of field records.\n+template<typename CON>\n+class Mapper {\n+  CON* _consumer;  \/\/ can be UNSIGNED5::Writer or UNSIGNED5::Sizer\n+  int _next_index;\n+public:\n+  Mapper(CON* consumer) : _consumer(consumer) { _next_index = 0; }\n+  int next_index() const { return _next_index; }\n+  void set_next_index(int next_index) { _next_index = next_index; }\n+  CON* consumer() const { return _consumer; }\n+  void map_field_info(const FieldInfo& fi);\n+};\n+\n+\n+\/\/ Gadget for decoding and reading the stream of field records.\n+class FieldInfoReader {\n+  friend class FieldInfoStream;\n+  friend class ClassFileParser;\n+  friend class FieldStreamBase;\n+  friend class FieldInfo;\n+\n+  UNSIGNED5::Reader<const u1*, int> _r;\n+  int _next_index;\n+\n+  public:\n+  FieldInfoReader(const Array<u1>* fi);\n+\n+  private:\n+  uint32_t next_uint() { return _r.next_uint(); }\n+  void skip(int n) { int s = _r.try_skip(n); assert(s == n,\"\"); }\n+\n+public:\n+  int has_next() { return _r.has_next(); }\n+  int position() { return _r.position(); }\n+  int next_index() { return _next_index; }\n+  void read_field_info(FieldInfo& fi);\n+  \/\/ skip a whole field record, both required and optional bits\n+  FieldInfoReader&  skip_field_info();\n+\n+  \/\/ Skip to the nth field.  If the reader is freshly initialized to\n+  \/\/ the zero index, this will call skip_field_info() n times.\n+  FieldInfoReader& skip_to_field_info(int n);\n+\n+  \/\/ for random access, if you know where to go up front:\n+  FieldInfoReader& set_position_and_next_index(int position, int next_index);\n+};\n+\n+\/\/ The format of the stream, after decompression, is a series of\n+\/\/ integers organized like this:\n+\/\/\n+\/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+\/\/   Field := name sig offset access flags Optionals(flags)\n+\/\/   Optionals(i) := initval?[i&is_init]     \/\/ ConstantValue attr\n+\/\/                   gsig?[i&is_generic]     \/\/ signature attr\n+\/\/                   group?[i&is_contended]  \/\/ Contended anno (group)\n+\/\/   End = 0\n+\/\/\n+class FieldInfoStream : AllStatic {\n+  friend class fieldDescriptor;\n+  friend class JavaFieldStream;\n+  friend class FieldStreamBase;\n+  friend class ClassFileParser;\n+\n+ public:\n+  static int num_java_fields(const Array<u1>* fis);\n+  static int num_injected_java_fields(const Array<u1>* fis);\n+  static int num_total_fields(const Array<u1>* fis);\n+\n+  static Array<u1>* create_FieldInfoStream(GrowableArray<FieldInfo>* fields, int java_fields, int injected_fields,\n+                                                          ClassLoaderData* loader_data, TRAPS);\n+  static GrowableArray<FieldInfo>* create_FieldInfoArray(const Array<u1>* fis, int* java_fields_count, int* injected_fields_count);\n+  static void print_from_fieldinfo_stream(Array<u1>* fis, outputStream* os, ConstantPool* cp);\n+};\n+\n+class FieldStatus {\n+  enum FieldStatusBitPosition {\n+    _fs_access_watched,       \/\/ field access is watched by JVMTI\n+    _fs_modification_watched, \/\/ field modification is watched by JVMTI\n+    _initialized_final_update \/\/ (static) final field updated outside (class) initializer\n+  };\n+\n+  \/\/ boilerplate:\n+  u1 _flags;\n+  static constexpr u1 flag_mask(FieldStatusBitPosition pos) { return (u1)1 << (int)pos; }\n+  bool test_flag(FieldStatusBitPosition pos) { return (_flags & flag_mask(pos)) != 0; }\n+  \/\/ this performs an atomic update on a live status byte!\n+  void update_flag(FieldStatusBitPosition pos, bool z);\n+  \/\/ out-of-line functions do a CAS-loop\n+  static void atomic_set_bits(u1& flags, u1 mask);\n+  static void atomic_clear_bits(u1& flags, u1 mask);\n+\n+  public:\n+  FieldStatus() { _flags = 0; }\n+  FieldStatus(u1 flags) { _flags = flags; }\n+  u1 as_uint() { return _flags; }\n+\n+  bool is_access_watched()        { return test_flag(_fs_access_watched); }\n+  bool is_modification_watched()  { return test_flag(_fs_modification_watched); }\n+  bool is_initialized_final_update() { return test_flag(_initialized_final_update); }\n+\n+  void update_access_watched(bool z);\n+  void update_modification_watched(bool z);\n+  void update_initialized_final_update(bool z);\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.hpp","additions":249,"deletions":108,"binary":false,"changes":357,"status":"modified"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_FIELDINFO_INLINE_HPP\n+#define SHARE_OOPS_FIELDINFO_INLINE_HPP\n+\n+#include \"oops\/fieldInfo.hpp\"\n+\n+#include \"memory\/metadataFactory.hpp\"\n+#include \"oops\/constantPool.hpp\"\n+#include \"oops\/symbol.hpp\"\n+\n+inline Symbol* FieldInfo::name(ConstantPool* cp) const {\n+  int index = _name_index;\n+  if (_field_flags.is_injected()) {\n+    return lookup_symbol(index);\n+  }\n+  return cp->symbol_at(index);\n+}\n+\n+inline Symbol* FieldInfo::signature(ConstantPool* cp) const {\n+  int index = _signature_index;\n+  if (_field_flags.is_injected()) {\n+    return lookup_symbol(index);\n+  }\n+  return cp->symbol_at(index);\n+}\n+\n+inline Symbol* FieldInfo::lookup_symbol(int symbol_index) const {\n+  assert(_field_flags.is_injected(), \"only injected fields\");\n+  return Symbol::vm_symbol_at(static_cast<vmSymbolID>(symbol_index));\n+}\n+\n+inline int FieldInfoStream::num_injected_java_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  fir.skip(1);\n+  return fir.next_uint();\n+}\n+\n+inline int FieldInfoStream::num_total_fields(const Array<u1>* fis) {\n+  FieldInfoReader fir(fis);\n+  return fir.next_uint() + fir.next_uint();\n+}\n+\n+inline int FieldInfoStream::num_java_fields(const Array<u1>* fis) { return FieldInfoReader(fis).next_uint(); }\n+\n+template<typename CON>\n+inline void Mapper<CON>::map_field_info(const FieldInfo& fi) {\n+  _next_index++;  \/\/ pre-increment\n+  _consumer->accept_uint(fi.name_index());\n+  _consumer->accept_uint(fi.signature_index());\n+  _consumer->accept_uint(fi.offset());\n+  _consumer->accept_uint(fi.access_flags().as_int());\n+  _consumer->accept_uint(fi.field_flags().as_uint());\n+  if(fi.field_flags().has_any_optionals()) {\n+    if (fi.field_flags().is_initialized()) {\n+      _consumer->accept_uint(fi.initializer_index());\n+    }\n+    if (fi.field_flags().is_generic()) {\n+      _consumer->accept_uint(fi.generic_signature_index());\n+    }\n+    if (fi.field_flags().is_contended()) {\n+      _consumer->accept_uint(fi.contention_group());\n+    }\n+  } else {\n+    assert(fi.initializer_index() == 0, \"\");\n+    assert(fi.generic_signature_index() == 0, \"\");\n+    assert(fi.contention_group() == 0, \"\");\n+  }\n+}\n+\n+\n+inline FieldInfoReader::FieldInfoReader(const Array<u1>* fi)\n+  : _r(fi->data(), 0),\n+    _next_index(0) { }\n+\n+inline void FieldInfoReader::read_field_info(FieldInfo& fi) {\n+  fi._index = _next_index++;\n+  fi._name_index = next_uint();\n+  fi._signature_index = next_uint();\n+  fi._offset = next_uint();\n+  fi._access_flags = AccessFlags(next_uint());\n+  fi._field_flags = FieldInfo::FieldFlags(next_uint());\n+  if (fi._field_flags.is_initialized()) {\n+    fi._initializer_index = next_uint();\n+  } else {\n+    fi._initializer_index = 0;\n+  }\n+  if (fi._field_flags.is_generic()) {\n+    fi._generic_signature_index = next_uint();\n+  } else {\n+    fi._generic_signature_index = 0;\n+  }\n+  if (fi._field_flags.is_contended()) {\n+    fi._contention_group = next_uint();\n+  } else {\n+    fi._contention_group = 0;\n+  }\n+}\n+\n+inline FieldInfoReader&  FieldInfoReader::skip_field_info() {\n+  _next_index++;\n+  const int name_sig_af_off = 4;  \/\/ four items\n+  skip(name_sig_af_off);\n+  FieldInfo::FieldFlags ff(next_uint());\n+  if (ff.has_any_optionals()) {\n+    const int init_gen_cont = (ff.is_initialized() +\n+                                ff.is_generic() +\n+                                ff.is_contended());\n+    skip(init_gen_cont);  \/\/ up to three items\n+  }\n+  return *this;\n+}\n+\n+\/\/ Skip to the nth field.  If the reader is freshly initialized to\n+\/\/ the zero index, this will call skip_field_info() n times.\n+inline FieldInfoReader& FieldInfoReader::skip_to_field_info(int n) {\n+  assert(n >= _next_index, \"already past that index\");\n+  const int count = n - _next_index;\n+  for (int i = 0; i < count; i++)  skip_field_info();\n+  assert(_next_index == n, \"\");\n+  return *this;\n+}\n+\n+\/\/ for random access, if you know where to go up front:\n+inline FieldInfoReader& FieldInfoReader::set_position_and_next_index(int position, int next_index) {\n+  _r.set_position(position);\n+  _next_index = next_index;\n+  return *this;\n+}\n+\n+inline void FieldStatus::atomic_set_bits(u1& flags, u1 mask) {\n+  \/\/ Atomically update the flags with the bits given\n+  u1 old_flags, new_flags, witness;\n+  do {\n+    old_flags = flags;\n+    new_flags = old_flags | mask;\n+    witness = Atomic::cmpxchg(&flags, old_flags, new_flags);\n+  } while (witness != old_flags);\n+}\n+\n+inline void FieldStatus::atomic_clear_bits(u1& flags, u1 mask) {\n+  \/\/ Atomically update the flags with the bits given\n+  u1 old_flags, new_flags, witness;\n+  do {\n+    old_flags = flags;\n+    new_flags = old_flags & ~mask;\n+    witness = Atomic::cmpxchg(&flags, old_flags, new_flags);\n+  } while (witness != old_flags);\n+}\n+\n+inline void FieldStatus::update_flag(FieldStatusBitPosition pos, bool z) {\n+  if (z) atomic_set_bits(_flags, flag_mask(pos));\n+  else atomic_clear_bits(_flags, flag_mask(pos));\n+}\n+\n+inline void FieldStatus::update_access_watched(bool z) { update_flag(_fs_access_watched, z); }\n+inline void FieldStatus::update_modification_watched(bool z) { update_flag(_fs_modification_watched, z); }\n+inline void FieldStatus::update_initialized_final_update(bool z) { update_flag(_initialized_final_update, z); }\n+\n+#endif \/\/ SHARE_OOPS_FIELDINFO_INLINE_HPP\n","filename":"src\/hotspot\/share\/oops\/fieldInfo.inline.hpp","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -42,1 +42,2 @@\n-  Array<u2>*          _fields;\n+  const Array<u1>*    _fieldinfo_stream;\n+  FieldInfoReader     _reader;\n@@ -46,1 +47,2 @@\n-  int                 _generic_signature_slot;\n+\n+  FieldInfo           _fi_buf;\n@@ -49,30 +51,3 @@\n-  FieldInfo* field() const { return FieldInfo::from_field_array(_fields, _index); }\n-\n-  int init_generic_signature_start_slot() {\n-    int length = _fields->length();\n-    int num_fields = _index;\n-    int skipped_generic_signature_slots = 0;\n-    FieldInfo* fi;\n-    AccessFlags flags;\n-    \/* Scan from 0 to the current _index. Count the number of generic\n-       signature slots for field[0] to field[_index - 1]. *\/\n-    for (int i = 0; i < _index; i++) {\n-      fi = FieldInfo::from_field_array(_fields, i);\n-      flags.set_flags(fi->access_flags());\n-      if (flags.field_has_generic_signature()) {\n-        length --;\n-        skipped_generic_signature_slots ++;\n-      }\n-    }\n-    \/* Scan from the current _index. *\/\n-    for (int i = _index; i*FieldInfo::field_slots < length; i++) {\n-      fi = FieldInfo::from_field_array(_fields, i);\n-      flags.set_flags(fi->access_flags());\n-      if (flags.field_has_generic_signature()) {\n-        length --;\n-      }\n-      num_fields ++;\n-    }\n-    _generic_signature_slot = length + skipped_generic_signature_slots;\n-    assert(_generic_signature_slot <= _fields->length(), \"\");\n-    return num_fields;\n+  FieldInfo const * field() const {\n+    assert(!done(), \"no more fields\");\n+    return &_fi_buf;\n@@ -81,1 +56,3 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit);\n+  inline FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants, int start, int limit);\n+\n+  inline FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants);\n@@ -83,1 +60,9 @@\n-  inline FieldStreamBase(Array<u2>* fields, ConstantPool* constants);\n+  private:\n+   void initialize() {\n+    int java_fields_count = _reader.next_uint();\n+    int injected_fields_count = _reader.next_uint();\n+    assert( _limit <= java_fields_count + injected_fields_count, \"Safety check\");\n+    if (_limit != 0) {\n+      _reader.read_field_info(_fi_buf);\n+    }\n+   }\n@@ -92,4 +77,0 @@\n-    if (access_flags().field_has_generic_signature()) {\n-      _generic_signature_slot ++;\n-      assert(_generic_signature_slot <= _fields->length(), \"\");\n-    }\n@@ -97,0 +78,2 @@\n+    if (done()) return;\n+    _reader.read_field_info(_fi_buf);\n@@ -102,3 +85,1 @@\n-    AccessFlags flags;\n-    flags.set_flags(field()->access_flags());\n-    return flags;\n+    return field()->access_flags();\n@@ -107,6 +88,2 @@\n-  void set_access_flags(u2 flags) const {\n-    field()->set_access_flags(flags);\n-  }\n-\n-  void set_access_flags(AccessFlags flags) const {\n-    set_access_flags(flags.as_short());\n+  FieldInfo::FieldFlags field_flags() const {\n+    return field()->field_flags();\n@@ -124,4 +101,2 @@\n-    if (access_flags().field_has_generic_signature()) {\n-      assert(_generic_signature_slot < _fields->length(), \"out of bounds\");\n-      int index = _fields->at(_generic_signature_slot);\n-      return _constants->symbol_at(index);\n+    if (field()->field_flags().is_generic()) {\n+      return _constants->symbol_at(field()->generic_signature_index());\n@@ -137,8 +112,0 @@\n-  void set_offset(int offset) {\n-    field()->set_offset(offset);\n-  }\n-\n-  bool is_offset_set() const {\n-    return field()->is_offset_set();\n-  }\n-\n@@ -153,0 +120,10 @@\n+  \/\/ Convenient methods\n+\n+  FieldInfo to_FieldInfo() {\n+    return _fi_buf;\n+  }\n+\n+  int num_total_fields() const {\n+    return FieldInfoStream::num_total_fields(_fieldinfo_stream);\n+  }\n+\n@@ -164,1 +141,1 @@\n-  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fields(), k->constants(), 0, k->java_fields_count()) {}\n+  JavaFieldStream(const InstanceKlass* k): FieldStreamBase(k->fieldinfo_stream(), k->constants(), 0, k->java_fields_count()) {}\n@@ -167,1 +144,1 @@\n-    assert(!field()->is_internal(), \"regular only\");\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n@@ -170,4 +147,1 @@\n-  void set_name_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    field()->set_name_index(index);\n-  }\n+\n@@ -175,1 +149,1 @@\n-    assert(!field()->is_internal(), \"regular only\");\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n@@ -177,0 +151,1 @@\n+    return -1;\n@@ -178,4 +153,1 @@\n-  void set_signature_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    field()->set_signature_index(index);\n-  }\n+\n@@ -183,13 +155,3 @@\n-    assert(!field()->is_internal(), \"regular only\");\n-    if (access_flags().field_has_generic_signature()) {\n-      assert(_generic_signature_slot < _fields->length(), \"out of bounds\");\n-      return _fields->at(_generic_signature_slot);\n-    } else {\n-      return 0;\n-    }\n-  }\n-  void set_generic_signature_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    if (access_flags().field_has_generic_signature()) {\n-      assert(_generic_signature_slot < _fields->length(), \"out of bounds\");\n-      _fields->at_put(_generic_signature_slot, index);\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n+    if (field()->field_flags().is_generic()) {\n+      return field()->generic_signature_index();\n@@ -197,0 +159,1 @@\n+    return 0;\n@@ -198,0 +161,1 @@\n+\n@@ -199,6 +163,2 @@\n-    assert(!field()->is_internal(), \"regular only\");\n-    return field()->initval_index();\n-  }\n-  void set_initval_index(int index) {\n-    assert(!field()->is_internal(), \"regular only\");\n-    return field()->set_initval_index(index);\n+    assert(!field()->field_flags().is_injected(), \"regular only\");\n+    return field()->initializer_index();\n@@ -212,1 +172,1 @@\n-  InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants(), k->java_fields_count(), 0) {}\n+  InternalFieldStream(InstanceKlass* k):      FieldStreamBase(k->fieldinfo_stream(), k->constants(), k->java_fields_count(), 0) {}\n@@ -218,2 +178,2 @@\n-  AllFieldStream(Array<u2>* fields, ConstantPool* constants): FieldStreamBase(fields, constants) {}\n-  AllFieldStream(InstanceKlass* k):      FieldStreamBase(k->fields(), k->constants()) {}\n+  AllFieldStream(Array<u1>* fieldinfo, ConstantPool* constants): FieldStreamBase(fieldinfo, constants) {}\n+  AllFieldStream(const InstanceKlass* k):      FieldStreamBase(k->fieldinfo_stream(), k->constants()) {}\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.hpp","additions":52,"deletions":92,"binary":false,"changes":144,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -32,1 +33,3 @@\n-FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants, int start, int limit) : _fields(fields),\n+FieldStreamBase::FieldStreamBase(const Array<u1>* fieldinfo_stream, ConstantPool* constants, int start, int limit) :\n+         _fieldinfo_stream(fieldinfo_stream),\n+         _reader(FieldInfoReader(_fieldinfo_stream)),\n@@ -35,1 +38,0 @@\n-  int num_fields = init_generic_signature_start_slot();\n@@ -37,1 +39,1 @@\n-    _limit = num_fields;\n+    _limit = FieldInfoStream::num_total_fields(_fieldinfo_stream);\n@@ -41,0 +43,1 @@\n+  initialize();\n@@ -43,3 +46,7 @@\n-FieldStreamBase::FieldStreamBase(Array<u2>* fields, ConstantPool* constants) : _fields(fields),\n-         _constants(constantPoolHandle(Thread::current(), constants)), _index(0) {\n-  _limit = init_generic_signature_start_slot();\n+FieldStreamBase::FieldStreamBase(Array<u1>* fieldinfo_stream, ConstantPool* constants) :\n+        _fieldinfo_stream(fieldinfo_stream),\n+        _reader(FieldInfoReader(_fieldinfo_stream)),\n+        _constants(constantPoolHandle(Thread::current(), constants)),\n+        _index(0),\n+        _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n+  initialize();\n@@ -48,4 +55,6 @@\n-FieldStreamBase::FieldStreamBase(InstanceKlass* klass) : _fields(klass->fields()),\n-         _constants(constantPoolHandle(Thread::current(), klass->constants())), _index(0),\n-         _limit(klass->java_fields_count()) {\n-  init_generic_signature_start_slot();\n+FieldStreamBase::FieldStreamBase(InstanceKlass* klass) :\n+         _fieldinfo_stream(klass->fieldinfo_stream()),\n+         _reader(FieldInfoReader(_fieldinfo_stream)),\n+         _constants(constantPoolHandle(Thread::current(), klass->constants())),\n+         _index(0),\n+         _limit(FieldInfoStream::num_total_fields(_fieldinfo_stream)) {\n@@ -53,0 +62,1 @@\n+  initialize();\n","filename":"src\/hotspot\/share\/oops\/fieldStreams.inline.hpp","additions":21,"deletions":11,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -649,2 +649,2 @@\n-  if (fields() != nullptr && !fields()->is_shared()) {\n-    MetadataFactory::free_array<jushort>(loader_data, fields());\n+  if (fieldinfo_stream() != nullptr && !fieldinfo_stream()->is_shared()) {\n+    MetadataFactory::free_array<u1>(loader_data, fieldinfo_stream());\n@@ -652,1 +652,6 @@\n-  set_fields(nullptr, 0);\n+  set_fieldinfo_stream(nullptr);\n+\n+  if (fields_status() != nullptr && !fields_status()->is_shared()) {\n+    MetadataFactory::free_array<FieldStatus>(loader_data, fields_status());\n+  }\n+  set_fields_status(nullptr);\n@@ -1518,0 +1523,10 @@\n+FieldInfo InstanceKlass::field(int index) const {\n+  for (AllFieldStream fs(this); !fs.done(); fs.next()) {\n+    if (fs.index() == index) {\n+      return fs.to_FieldInfo();\n+    }\n+  }\n+  fatal(\"Field not found\");\n+  return FieldInfo();\n+}\n+\n@@ -2420,2 +2435,3 @@\n-  \/\/ _fields might be written into by Rewriter::scan_method() -> fd.set_has_initialized_final_update()\n-  it->push(&_fields, MetaspaceClosure::_writable);\n+  it->push(&_fieldinfo_stream);\n+  \/\/ _fields_status might be written into by Rewriter::scan_method() -> fd.set_has_initialized_final_update()\n+  it->push(&_fields_status, MetaspaceClosure::_writable);\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":21,"deletions":5,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"oops\/constantPool.hpp\"\n@@ -221,1 +222,0 @@\n-  u2              _java_fields_count;       \/\/ The number of declared Java fields\n@@ -274,14 +274,3 @@\n-  \/\/ Instance and static variable information, starts with 6-tuples of shorts\n-  \/\/ [access, name index, sig index, initval index, low_offset, high_offset]\n-  \/\/ for all fields, followed by the generic signature data at the end of\n-  \/\/ the array. Only fields with generic signature attributes have the generic\n-  \/\/ signature data set in the array. The fields array looks like following:\n-  \/\/\n-  \/\/ f1: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/ f2: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/      ...\n-  \/\/ fn: [access, name index, sig index, initial value index, low_offset, high_offset]\n-  \/\/     [generic signature index]\n-  \/\/     [generic signature index]\n-  \/\/     ...\n-  Array<u2>*      _fields;\n+  \/\/ Fields information is stored in an UNSIGNED5 encoded stream (see fieldInfo.hpp)\n+  Array<u1>*          _fieldinfo_stream;\n+  Array<FieldStatus>* _fields_status;\n@@ -396,1 +385,1 @@\n-  FieldInfo* field(int index) const { return FieldInfo::from_field_array(_fields, index); }\n+  FieldInfo field(int index) const;\n@@ -399,4 +388,6 @@\n-  int     field_offset      (int index) const { return field(index)->offset(); }\n-  int     field_access_flags(int index) const { return field(index)->access_flags(); }\n-  Symbol* field_name        (int index) const { return field(index)->name(constants()); }\n-  Symbol* field_signature   (int index) const { return field(index)->signature(constants()); }\n+  int     field_offset      (int index) const { return field(index).offset(); }\n+  int     field_access_flags(int index) const { return field(index).access_flags().as_int(); }\n+  FieldInfo::FieldFlags field_flags(int index) const { return field(index).field_flags(); }\n+  FieldStatus field_status(int index)   const { return fields_status()->at(index); }\n+  inline Symbol* field_name        (int index) const;\n+  inline Symbol* field_signature   (int index) const;\n@@ -405,1 +396,2 @@\n-  int java_fields_count() const           { return (int)_java_fields_count; }\n+  int java_fields_count() const;\n+  int total_fields_count() const;\n@@ -407,6 +399,5 @@\n-  Array<u2>* fields() const            { return _fields; }\n-  void set_fields(Array<u2>* f, u2 java_fields_count) {\n-    guarantee(_fields == nullptr || f == nullptr, \"Just checking\");\n-    _fields = f;\n-    _java_fields_count = java_fields_count;\n-  }\n+  Array<u1>* fieldinfo_stream() const { return _fieldinfo_stream; }\n+  void set_fieldinfo_stream(Array<u1>* fis) { _fieldinfo_stream = fis; }\n+\n+  Array<FieldStatus>* fields_status() const {return _fields_status; }\n+  void set_fields_status(Array<FieldStatus>* array) { _fields_status = array; }\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":18,"deletions":27,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -33,0 +33,1 @@\n+#include \"oops\/fieldInfo.inline.hpp\"\n@@ -48,0 +49,6 @@\n+inline Symbol* InstanceKlass::field_name(int index) const { return field(index).name(constants()); }\n+inline Symbol* InstanceKlass::field_signature(int index) const { return field(index).signature(constants()); }\n+\n+inline int InstanceKlass::java_fields_count() const { return FieldInfoStream::num_java_fields(fieldinfo_stream()); }\n+inline int InstanceKlass::total_fields_count() const { return FieldInfoStream::num_total_fields(fieldinfo_stream()); }\n+\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.inline.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n","filename":"src\/hotspot\/share\/prims\/jvmtiClassFileReconstituter.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -3546,2 +3546,7 @@\n-  for (JavaFieldStream fs(scratch_class); !fs.done(); fs.next()) {\n-    jshort cur_index = fs.name_index();\n+  int java_fields;\n+  int injected_fields;\n+  bool update_required = false;\n+  GrowableArray<FieldInfo>* fields = FieldInfoStream::create_FieldInfoArray(scratch_class->fieldinfo_stream(), &java_fields, &injected_fields);\n+  for (int i = 0; i < java_fields; i++) {\n+    FieldInfo* fi = fields->adr_at(i);\n+    jshort cur_index = fi->name_index();\n@@ -3551,1 +3556,2 @@\n-      fs.set_name_index(new_index);\n+      fi->set_name_index(new_index);\n+      update_required = true;\n@@ -3553,1 +3559,1 @@\n-    cur_index = fs.signature_index();\n+    cur_index = fi->signature_index();\n@@ -3557,1 +3563,2 @@\n-      fs.set_signature_index(new_index);\n+      fi->set_signature_index(new_index);\n+      update_required = true;\n@@ -3559,1 +3566,1 @@\n-    cur_index = fs.initval_index();\n+    cur_index = fi->initializer_index();\n@@ -3563,1 +3570,2 @@\n-      fs.set_initval_index(new_index);\n+      fi->set_initializer_index(new_index);\n+      update_required = true;\n@@ -3565,1 +3573,1 @@\n-    cur_index = fs.generic_signature_index();\n+    cur_index = fi->generic_signature_index();\n@@ -3569,1 +3577,2 @@\n-      fs.set_generic_signature_index(new_index);\n+      fi->set_generic_signature_index(new_index);\n+      update_required = true;\n@@ -3571,1 +3580,8 @@\n-  } \/\/ end for each field\n+  }\n+  if (update_required) {\n+    Array<u1>* old_stream = scratch_class->fieldinfo_stream();\n+    assert(fields->length() == (java_fields + injected_fields), \"Must be\");\n+    Array<u1>* new_fis = FieldInfoStream::create_FieldInfoStream(fields, java_fields, injected_fields, scratch_class->class_loader_data(), CHECK);\n+    scratch_class->set_fieldinfo_stream(new_fis);\n+    MetadataFactory::free_array<u1>(scratch_class->class_loader_data(), old_stream);\n+  }\n","filename":"src\/hotspot\/share\/prims\/jvmtiRedefineClasses.cpp","additions":26,"deletions":10,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -1331,1 +1331,1 @@\n-      if (!fs.access_flags().is_static() && (!skip_internal || !fs.access_flags().is_internal())) {\n+      if (!fs.access_flags().is_static() && (!skip_internal || !fs.field_flags().is_injected())) {\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,12 +42,1 @@\n-\n-  int idx = 0;\n-  InstanceKlass* ik = field_holder();\n-  for (AllFieldStream fs(ik); !fs.done(); fs.next()) {\n-    if (idx == _index) {\n-      return fs.generic_signature();\n-    } else {\n-      idx ++;\n-    }\n-  }\n-  assert(false, \"should never happen\");\n-  return vmSymbols::void_signature(); \/\/ return a default value (for code analyzers)\n+  return _cp->symbol_at(_fieldinfo.generic_signature_index());\n@@ -109,17 +98,3 @@\n-  FieldInfo* f = ik->field(index);\n-  _access_flags = accessFlags_from(f->access_flags());\n-  guarantee(f->name_index() != 0 && f->signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n-  _index = index;\n-  verify();\n-}\n-\n-#ifndef PRODUCT\n-\n-void fieldDescriptor::verify() const {\n-  if (_cp.is_null()) {\n-    assert(_index == badInt, \"constructor must be called\");  \/\/ see constructor\n-  } else {\n-    assert(_index >= 0, \"good index\");\n-    assert(access_flags().is_internal() ||\n-           _index < field_holder()->java_fields_count(), \"oob\");\n-  }\n+  _fieldinfo= ik->field(index);\n+  assert((int)_fieldinfo.index() == index, \"just checking\");\n+  guarantee(_fieldinfo.name_index() != 0 && _fieldinfo.signature_index() != 0, \"bad constant pool index for fieldDescriptor\");\n@@ -128,2 +103,0 @@\n-#endif \/* PRODUCT *\/\n-\n@@ -132,1 +105,1 @@\n-  if (access_flags().is_internal()) st->print(\"internal \");\n+  if (field_flags().is_injected()) st->print(\"injected \");\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.cpp","additions":5,"deletions":32,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,1 @@\n-  AccessFlags         _access_flags;\n-  int                 _index; \/\/ the field index\n+  FieldInfo           _fieldinfo;\n@@ -45,4 +44,1 @@\n-  \/\/ update the access_flags for the field in the klass\n-  inline void update_klass_field_access_flag();\n-\n-  inline FieldInfo* field() const;\n+  inline FieldInfo field() const { return _fieldinfo; };\n@@ -51,3 +47,1 @@\n-  fieldDescriptor() {\n-    DEBUG_ONLY(_index = badInt);\n-  }\n+  fieldDescriptor() {}\n@@ -55,1 +49,0 @@\n-    DEBUG_ONLY(_index = badInt);\n@@ -60,1 +53,1 @@\n-  inline InstanceKlass* field_holder() const;\n+  inline InstanceKlass* field_holder() const {return _cp->pool_holder(); };\n@@ -63,1 +56,4 @@\n-  AccessFlags access_flags()      const    { return _access_flags; }\n+  AccessFlags access_flags()      const    { return _fieldinfo.access_flags(); }\n+  FieldInfo::FieldFlags field_flags() const { return _fieldinfo.field_flags(); }\n+  FieldStatus field_status()      const    { return field_holder()->fields_status()->at(_fieldinfo.index()); }\n+  oop loader()                    const;\n@@ -67,1 +63,1 @@\n-  int index()                     const    { return _index; }\n+  int index()                     const    { return _fieldinfo.index(); }\n@@ -90,1 +86,3 @@\n-  bool is_stable()                const    { return access_flags().is_stable(); }\n+  bool is_stable()                const    { return field_flags().is_stable(); }\n+  bool is_volatile()              const    { return access_flags().is_volatile(); }\n+  bool is_transient()             const    { return access_flags().is_transient(); }\n@@ -94,1 +92,1 @@\n-  bool is_field_access_watched()  const    { return access_flags().is_field_access_watched(); }\n+  bool is_field_access_watched()  const    { return field_status().is_access_watched(); }\n@@ -96,3 +94,3 @@\n-                                           { return access_flags().is_field_modification_watched(); }\n-  bool has_initialized_final_update() const { return access_flags().has_field_initialized_final_update(); }\n-  bool has_generic_signature()    const    { return access_flags().field_has_generic_signature(); }\n+                                           { return field_status().is_modification_watched(); }\n+  bool has_initialized_final_update() const { return field_status().is_initialized_final_update(); }\n+  bool has_generic_signature()    const    { return field_flags().is_generic(); }\n@@ -113,1 +111,0 @@\n-  void verify() const                           PRODUCT_RETURN;\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.hpp","additions":17,"deletions":20,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+#include \"oops\/fieldInfo.inline.hpp\"\n@@ -37,1 +38,1 @@\n-  return field()->name(_cp());\n+  return field().name(_cp());\n@@ -41,5 +42,1 @@\n-  return field()->signature(_cp());\n-}\n-\n-inline InstanceKlass* fieldDescriptor::field_holder() const {\n-  return _cp->pool_holder();\n+  return field().signature(_cp());\n@@ -52,13 +49,3 @@\n-inline FieldInfo* fieldDescriptor::field() const {\n-  InstanceKlass* ik = field_holder();\n-  return ik->field(_index);\n-}\n-\n-inline int fieldDescriptor::offset()                    const    { return field()->offset(); }\n-inline bool fieldDescriptor::has_initial_value()        const    { return field()->initval_index() != 0; }\n-inline int fieldDescriptor::initial_value_index()       const    { return field()->initval_index(); }\n-\n-inline void fieldDescriptor::update_klass_field_access_flag() {\n-  InstanceKlass* ik = field_holder();\n-  ik->field(index())->set_access_flags(_access_flags.as_short());\n-}\n+inline int fieldDescriptor::offset()                    const    { return field().offset(); }\n+inline bool fieldDescriptor::has_initial_value()        const    { return field().field_flags().is_initialized(); }\n+inline int fieldDescriptor::initial_value_index()       const    { return field().initializer_index(); }\n@@ -67,2 +54,1 @@\n-  _access_flags.set_is_field_access_watched(value);\n-  update_klass_field_access_flag();\n+  field_holder()->fields_status()->adr_at(index())->update_access_watched(value);\n@@ -72,2 +58,1 @@\n-  _access_flags.set_is_field_modification_watched(value);\n-  update_klass_field_access_flag();\n+  field_holder()->fields_status()->adr_at(index())->update_modification_watched(value);\n@@ -77,2 +62,1 @@\n-  _access_flags.set_has_field_initialized_final_update(value);\n-  update_klass_field_access_flag();\n+  field_holder()->fields_status()->adr_at(index())->update_initialized_final_update(value);\n","filename":"src\/hotspot\/share\/runtime\/fieldDescriptor.inline.hpp","additions":10,"deletions":26,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"oops\/instanceKlass.inline.hpp\"\n@@ -71,0 +72,1 @@\n+int FieldStream::length() { return _klass->java_fields_count(); }\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,1 @@\n-  int length() { return _klass->java_fields_count(); }\n+  int length();\n","filename":"src\/hotspot\/share\/runtime\/reflectionUtils.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,0 +69,1 @@\n+#include \"oops\/fieldInfo.hpp\"\n@@ -228,2 +229,1 @@\n-  nonstatic_field(InstanceKlass,               _fields,                                       Array<u2>*)                            \\\n-  nonstatic_field(InstanceKlass,               _java_fields_count,                            u2)                                    \\\n+  nonstatic_field(InstanceKlass,               _fieldinfo_stream,                             Array<u1>*)                            \\\n@@ -2095,5 +2095,0 @@\n-  declare_constant(JVM_ACC_FIELD_ACCESS_WATCHED)                          \\\n-  declare_constant(JVM_ACC_FIELD_MODIFICATION_WATCHED)                    \\\n-  declare_constant(JVM_ACC_FIELD_INTERNAL)                                \\\n-  declare_constant(JVM_ACC_FIELD_STABLE)                                  \\\n-  declare_constant(JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE)                   \\\n@@ -2231,18 +2226,0 @@\n-  \/*************************************\/                                 \\\n-  \/* FieldInfo FieldOffset enum        *\/                                 \\\n-  \/*************************************\/                                 \\\n-                                                                          \\\n-  declare_constant(FieldInfo::access_flags_offset)                        \\\n-  declare_constant(FieldInfo::name_index_offset)                          \\\n-  declare_constant(FieldInfo::signature_index_offset)                     \\\n-  declare_constant(FieldInfo::initval_index_offset)                       \\\n-  declare_constant(FieldInfo::low_packed_offset)                          \\\n-  declare_constant(FieldInfo::high_packed_offset)                         \\\n-  declare_constant(FieldInfo::field_slots)                                \\\n-                                                                          \\\n-  \/*************************************\/                                 \\\n-  \/* FieldInfo tag constants           *\/                                 \\\n-  \/*************************************\/                                 \\\n-                                                                          \\\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_SIZE\", FIELDINFO_TAG_SIZE) \\\n-  declare_preprocessor_constant(\"FIELDINFO_TAG_OFFSET\", FIELDINFO_TAG_OFFSET) \\\n@@ -2318,0 +2295,11 @@\n+                                                                          \\\n+  \/******************************\/                                        \\\n+  \/* FieldFlags enum            *\/                                        \\\n+  \/******************************\/                                        \\\n+                                                                          \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_initialized)                \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_injected)                   \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_generic)                    \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_stable)                     \\\n+  declare_constant(FieldInfo::FieldFlags::_ff_contended)                  \\\n+                                                                          \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":13,"deletions":25,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,24 +77,0 @@\n-\n-  \/\/ field flags\n-  \/\/ Note: these flags must be defined in the low order 16 bits because\n-  \/\/ InstanceKlass only stores a ushort worth of information from the\n-  \/\/ AccessFlags value.\n-  \/\/ These bits must not conflict with any other field-related access flags\n-  \/\/ (e.g., ACC_ENUM).\n-  \/\/ Note that the class-related ACC_ANNOTATION bit conflicts with these flags.\n-  JVM_ACC_FIELD_ACCESS_WATCHED            = 0x00002000, \/\/ field access is watched by JVMTI\n-  JVM_ACC_FIELD_MODIFICATION_WATCHED      = 0x00008000, \/\/ field modification is watched by JVMTI\n-  JVM_ACC_FIELD_INTERNAL                  = 0x00000400, \/\/ internal field, same as JVM_ACC_ABSTRACT\n-  JVM_ACC_FIELD_STABLE                    = 0x00000020, \/\/ @Stable field, same as JVM_ACC_SYNCHRONIZED and JVM_ACC_SUPER\n-  JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE  = 0x00000100, \/\/ (static) final field updated outside (class) initializer, same as JVM_ACC_NATIVE\n-  JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE     = 0x00000800, \/\/ field has generic signature\n-\n-  JVM_ACC_FIELD_INTERNAL_FLAGS       = JVM_ACC_FIELD_ACCESS_WATCHED |\n-                                       JVM_ACC_FIELD_MODIFICATION_WATCHED |\n-                                       JVM_ACC_FIELD_INTERNAL |\n-                                       JVM_ACC_FIELD_STABLE |\n-                                       JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE,\n-\n-                                                    \/\/ flags accepted by set_field_flags()\n-  JVM_ACC_FIELD_FLAGS                = JVM_RECOGNIZED_FIELD_MODIFIERS | JVM_ACC_FIELD_INTERNAL_FLAGS\n-\n@@ -169,6 +145,0 @@\n-  \/\/ field flags\n-  bool is_field_access_watched() const  { return (_flags & JVM_ACC_FIELD_ACCESS_WATCHED) != 0; }\n-  bool is_field_modification_watched() const\n-                                        { return (_flags & JVM_ACC_FIELD_MODIFICATION_WATCHED) != 0; }\n-  bool has_field_initialized_final_update() const\n-                                        { return (_flags & JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE) != 0; }\n@@ -176,4 +146,0 @@\n-  bool is_internal() const              { return (_flags & JVM_ACC_FIELD_INTERNAL) != 0; }\n-  bool is_stable() const                { return (_flags & JVM_ACC_FIELD_STABLE) != 0; }\n-  bool field_has_generic_signature() const\n-                                        { return (_flags & JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE) != 0; }\n@@ -186,2 +152,2 @@\n-    assert((flags & JVM_ACC_FIELD_FLAGS) == flags, \"only recognized flags\");\n-    _flags = (flags & JVM_ACC_FIELD_FLAGS);\n+    assert((flags & JVM_RECOGNIZED_FIELD_MODIFIERS) == flags, \"only recognized flags\");\n+    _flags = (flags & JVM_RECOGNIZED_FIELD_MODIFIERS);\n@@ -238,31 +204,0 @@\n-  \/\/ field flags\n-  void set_is_field_access_watched(const bool value)\n-                                       {\n-                                         if (value) {\n-                                           atomic_set_bits(JVM_ACC_FIELD_ACCESS_WATCHED);\n-                                         } else {\n-                                           atomic_clear_bits(JVM_ACC_FIELD_ACCESS_WATCHED);\n-                                         }\n-                                       }\n-  void set_is_field_modification_watched(const bool value)\n-                                       {\n-                                         if (value) {\n-                                           atomic_set_bits(JVM_ACC_FIELD_MODIFICATION_WATCHED);\n-                                         } else {\n-                                           atomic_clear_bits(JVM_ACC_FIELD_MODIFICATION_WATCHED);\n-                                         }\n-                                       }\n-\n-  void set_has_field_initialized_final_update(const bool value) {\n-    if (value) {\n-      atomic_set_bits(JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE);\n-    } else {\n-      atomic_clear_bits(JVM_ACC_FIELD_INITIALIZED_FINAL_UPDATE);\n-    }\n-  }\n-\n-  void set_field_has_generic_signature()\n-                                       {\n-                                         atomic_set_bits(JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE);\n-                                       }\n-\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":3,"deletions":68,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -261,2 +261,2 @@\n-    const ARR _array;\n-    const OFF _limit;\n+    ARR _array;\n+    OFF _limit;\n","filename":"src\/hotspot\/share\/utilities\/unsigned5.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2012, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -81,5 +81,0 @@\n-  \/\/ field flags\n-  public boolean fieldAccessWatched () { return (flags & JVM_ACC_FIELD_ACCESS_WATCHED) != 0; }\n-  public boolean fieldModificationWatched() { return (flags & JVM_ACC_FIELD_MODIFICATION_WATCHED) != 0; }\n-  public boolean fieldHasGenericSignature() { return (flags & JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE)!= 0; }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/AccessFlags.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import sun.jvm.hotspot.code.CompressedReadStream;\n@@ -43,1 +44,1 @@\n-  Field(InstanceKlass holder, int fieldIndex) {\n+  private Field(InstanceKlass holder, int fieldIndex, FieldInfoValues values) {\n@@ -46,0 +47,2 @@\n+    this.values = values;\n+    offset = values.offset;\n@@ -47,4 +50,2 @@\n-    offset               = holder.getFieldOffset(fieldIndex);\n-    genericSignature     = holder.getFieldGenericSignature(fieldIndex);\n-\n-    name                 = holder.getFieldName(fieldIndex);\n+    name = holder.getSymbolFromIndex(values.nameIndex, isInjected());\n+    signature = holder.getSymbolFromIndex(values.signatureIndex, isInjected());\n@@ -52,2 +53,0 @@\n-\n-    signature            = holder.getFieldSignature(fieldIndex);\n@@ -55,0 +54,6 @@\n+    accessFlags = new AccessFlags(values.accessFlags);\n+\n+    if (isGeneric()) {\n+      genericSignature = holder.getSymbolFromIndex(values.genericSignatureIndex, isInjected());\n+    }\n+  }\n@@ -56,2 +61,3 @@\n-    short access         = holder.getFieldAccessFlags(fieldIndex);\n-    accessFlags = new AccessFlags(access);\n+  \/** Constructor for cloning an existing Field object *\/\n+  Field(InstanceKlass holder, int fieldIndex) {\n+      this(holder, fieldIndex, holder.getField(fieldIndex).values);\n@@ -60,0 +66,57 @@\n+\n+  static class FieldInfoValues {\n+    int nameIndex;\n+    int signatureIndex;\n+    int offset;\n+    int accessFlags;\n+    int fieldFlags;\n+    int initialValueIndex;\n+    int genericSignatureIndex;\n+    int contendedGroup;\n+  }\n+\n+  \/\/ The format of the stream, after decompression, is a series of\n+  \/\/ integers organized like this:\n+  \/\/\n+  \/\/   FieldInfoStream := j=num_java_fields k=num_injected_fields Field[j+k] End\n+  \/\/   Field := name sig offset access flags Optionals(flags)\n+  \/\/   Optionals(i) := initval?[i&is_init]     \/\/ ConstantValue attr\n+  \/\/                   gsig?[i&is_generic]     \/\/ signature attr\n+  \/\/                   group?[i&is_contended]  \/\/ Contended anno (group)\n+  \/\/   End = 0\n+  \/\/\n+\n+  static FieldInfoValues readFieldInfoValues(CompressedReadStream crs) {\n+    FieldInfoValues fieldInfoValues = new FieldInfoValues();\n+    fieldInfoValues.nameIndex = crs.readInt();                 \/\/ read name_index\n+    fieldInfoValues.signatureIndex = crs.readInt();            \/\/ read signature index\n+    fieldInfoValues.offset = crs.readInt();                    \/\/ read offset\n+    fieldInfoValues.accessFlags = crs.readInt();               \/\/ read access flags\n+    fieldInfoValues.fieldFlags = crs.readInt();                \/\/ read field flags\n+                                                               \/\/ Optional reads:\n+    if (fieldIsInitialized(fieldInfoValues.fieldFlags)) {\n+        fieldInfoValues.initialValueIndex = crs.readInt();     \/\/ read initial value index\n+    }\n+    if (fieldIsGeneric(fieldInfoValues.fieldFlags)) {\n+        fieldInfoValues.genericSignatureIndex = crs.readInt(); \/\/ read generic signature index\n+    }\n+    if (fieldIsContended(fieldInfoValues.fieldFlags)) {\n+        fieldInfoValues.contendedGroup = crs.readInt();        \/\/ read contended group\n+    }\n+    return fieldInfoValues;\n+  }\n+\n+  public static Field[] getFields(InstanceKlass kls) {\n+    CompressedReadStream crs = new CompressedReadStream(kls.getFieldInfoStream().getDataStart());\n+    int numJavaFields = crs.readInt();     \/\/ read num_java_fields\n+    int numInjectedFields = crs.readInt(); \/\/ read num_injected_fields;\n+    int numFields = numJavaFields + numInjectedFields;\n+    Field[] fields = new Field[numFields];\n+    for (int i = 0; i < numFields; i++) {\n+      FieldInfoValues values = readFieldInfoValues(crs);\n+      fields[i] = new Field(kls, i, values);\n+    }\n+    return fields;\n+  }\n+\n+  FieldInfoValues         values;\n@@ -79,0 +142,1 @@\n+  public int getNameIndex() { return values.nameIndex; }\n@@ -114,0 +178,1 @@\n+  public int getSignatureIndex() { return values.signatureIndex; }\n@@ -115,0 +180,1 @@\n+  public int getGenericSignatureIndex() { return values.genericSignatureIndex; }\n@@ -117,0 +183,1 @@\n+  public int getInitialValueIndex()        { return values.initialValueIndex; }\n@@ -134,0 +201,13 @@\n+  private static boolean fieldIsInitialized(int flags) { return ((flags >> InstanceKlass.FIELD_FLAG_IS_INITIALIZED) & 1 ) != 0; }\n+  private static boolean fieldIsInjected(int flags)    { return ((flags >> InstanceKlass.FIELD_FLAG_IS_INJECTED   ) & 1 ) != 0; }\n+  private static boolean fieldIsGeneric(int flags)     { return ((flags >> InstanceKlass.FIELD_FLAG_IS_GENERIC    ) & 1 ) != 0; }\n+  private static boolean fieldIsStable(int flags)      { return ((flags >> InstanceKlass.FIELD_FLAG_IS_STABLE     ) & 1 ) != 0; }\n+  private static boolean fieldIsContended(int flags)   { return ((flags >> InstanceKlass.FIELD_FLAG_IS_CONTENDED  ) & 1 ) != 0; }\n+\n+\n+  public boolean isInitialized()             { return fieldIsInitialized(values.fieldFlags); }\n+  public boolean isInjected()                { return fieldIsInjected(values.fieldFlags); }\n+  public boolean isGeneric()                 { return fieldIsGeneric(values.fieldFlags); }\n+  public boolean isStable()                  { return fieldIsStable(values.fieldFlags); }\n+  public boolean isContended()               { return fieldIsContended(values.fieldFlags); }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":90,"deletions":10,"binary":false,"changes":100,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,1 @@\n+import sun.jvm.hotspot.code.CompressedReadStream;\n@@ -49,10 +50,6 @@\n-  \/\/ field offset constants\n-  private static int ACCESS_FLAGS_OFFSET;\n-  private static int NAME_INDEX_OFFSET;\n-  private static int SIGNATURE_INDEX_OFFSET;\n-  private static int INITVAL_INDEX_OFFSET;\n-  private static int LOW_OFFSET;\n-  private static int HIGH_OFFSET;\n-  private static int FIELD_SLOTS;\n-  private static short FIELDINFO_TAG_SIZE;\n-  private static short FIELDINFO_TAG_OFFSET;\n+  \/\/ internal field flags constants\n+  static int FIELD_FLAG_IS_INITIALIZED;\n+  static int FIELD_FLAG_IS_INJECTED;\n+  static int FIELD_FLAG_IS_GENERIC;\n+  static int FIELD_FLAG_IS_STABLE;\n+  static int FIELD_FLAG_IS_CONTENDED;\n@@ -78,2 +75,1 @@\n-    fields               = type.getAddressField(\"_fields\");\n-    javaFieldsCount      = new CIntField(type.getCIntegerField(\"_java_fields_count\"), 0);\n+    fieldinfoStream      = type.getAddressField(\"_fieldinfo_stream\");\n@@ -95,10 +91,7 @@\n-    \/\/ read field offset constants\n-    ACCESS_FLAGS_OFFSET            = db.lookupIntConstant(\"FieldInfo::access_flags_offset\").intValue();\n-    NAME_INDEX_OFFSET              = db.lookupIntConstant(\"FieldInfo::name_index_offset\").intValue();\n-    SIGNATURE_INDEX_OFFSET         = db.lookupIntConstant(\"FieldInfo::signature_index_offset\").intValue();\n-    INITVAL_INDEX_OFFSET           = db.lookupIntConstant(\"FieldInfo::initval_index_offset\").intValue();\n-    LOW_OFFSET                     = db.lookupIntConstant(\"FieldInfo::low_packed_offset\").intValue();\n-    HIGH_OFFSET                    = db.lookupIntConstant(\"FieldInfo::high_packed_offset\").intValue();\n-    FIELD_SLOTS                    = db.lookupIntConstant(\"FieldInfo::field_slots\").intValue();\n-    FIELDINFO_TAG_SIZE             = db.lookupIntConstant(\"FIELDINFO_TAG_SIZE\").shortValue();\n-    FIELDINFO_TAG_OFFSET           = db.lookupIntConstant(\"FIELDINFO_TAG_OFFSET\").shortValue();\n+    \/\/ read internal field flags constants\n+    FIELD_FLAG_IS_INITIALIZED      = db.lookupIntConstant(\"FieldInfo::FieldFlags::_ff_initialized\");\n+    FIELD_FLAG_IS_INJECTED         = db.lookupIntConstant(\"FieldInfo::FieldFlags::_ff_injected\");\n+    FIELD_FLAG_IS_GENERIC          = db.lookupIntConstant(\"FieldInfo::FieldFlags::_ff_generic\");\n+    FIELD_FLAG_IS_STABLE           = db.lookupIntConstant(\"FieldInfo::FieldFlags::_ff_stable\");\n+    FIELD_FLAG_IS_CONTENDED        = db.lookupIntConstant(\"FieldInfo::FieldFlags::_ff_contended\");\n+\n@@ -114,0 +107,2 @@\n+    \/\/ We need a new fieldsCache each time we attach.\n+    fieldsCache = new WeakHashMap<Address, Field[]>();\n@@ -145,2 +140,1 @@\n-  private static AddressField fields;\n-  private static CIntField javaFieldsCount;\n+  private static AddressField  fieldinfoStream;\n@@ -267,0 +261,18 @@\n+  \/\/ Each InstanceKlass mirror instance will cache the Field[] array after it is decoded,\n+  \/\/ but since there can be multiple InstanceKlass mirror instances per hotspot InstanceKlass,\n+  \/\/ we also have a global cache that uses the Address of the hotspot InstanceKlass as the key.\n+  private Field[] fields;\n+  private static Map<Address, Field[]> fieldsCache;\n+\n+  Field getField(int index) {\n+    synchronized(this) {\n+      fields = fieldsCache.get(this.getAddress());\n+      if (fields == null) {\n+        fields = Field.getFields(this);\n+        fieldsCache.put(this.getAddress(), fields);\n+      } else {\n+      }\n+    }\n+    return fields[index];\n+  }\n+\n@@ -268,1 +280,1 @@\n-    return getFields().at(index * FIELD_SLOTS + ACCESS_FLAGS_OFFSET);\n+    return (short)getField(index).getAccessFlags();\n@@ -271,1 +283,1 @@\n-  public short getFieldNameIndex(int index) {\n+  public int getFieldNameIndex(int index) {\n@@ -273,1 +285,1 @@\n-    return getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);\n+    return getField(index).getNameIndex();\n@@ -277,3 +289,7 @@\n-    int nameIndex = getFields().at(index * FIELD_SLOTS + NAME_INDEX_OFFSET);\n-    if (index < getJavaFieldsCount()) {\n-      return getConstants().getSymbolAt(nameIndex);\n+    \/\/ Cannot use getFieldNameIndex() because this method is also used for injected fields\n+    return getField(index).getName();\n+  }\n+\n+  public Symbol getSymbolFromIndex(int cpIndex, boolean injected) {\n+    if (injected) {\n+      return vmSymbols.symbolAt(cpIndex);\n@@ -281,1 +297,1 @@\n-      return vmSymbols.symbolAt(nameIndex);\n+      return getConstants().getSymbolAt(cpIndex);\n@@ -285,1 +301,1 @@\n-  public short getFieldSignatureIndex(int index) {\n+  public int getFieldSignatureIndex(int index) {\n@@ -287,1 +303,1 @@\n-    return getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);\n+    return getField(index).getGenericSignatureIndex();\n@@ -291,28 +307,6 @@\n-    int signatureIndex = getFields().at(index * FIELD_SLOTS + SIGNATURE_INDEX_OFFSET);\n-    if (index < getJavaFieldsCount()) {\n-      return getConstants().getSymbolAt(signatureIndex);\n-    } else {\n-      return vmSymbols.symbolAt(signatureIndex);\n-    }\n-  }\n-\n-  public short getFieldGenericSignatureIndex(int index) {\n-    \/\/ int len = getFields().length();\n-    int allFieldsCount = getAllFieldsCount();\n-    int generic_signature_slot = allFieldsCount * FIELD_SLOTS;\n-    for (int i = 0; i < allFieldsCount; i++) {\n-      short flags = getFieldAccessFlags(i);\n-      AccessFlags access = new AccessFlags(flags);\n-      if (i == index) {\n-        if (access.fieldHasGenericSignature()) {\n-           return getFields().at(generic_signature_slot);\n-        } else {\n-          return 0;\n-        }\n-      } else {\n-        if (access.fieldHasGenericSignature()) {\n-          generic_signature_slot ++;\n-        }\n-      }\n-    }\n-    return 0;\n+    \/\/ Cannot use getFieldSignatureIndex() because this method is also use for injected fields\n+    return getField(index).getSignature();\n+  }\n+\n+  public int getFieldGenericSignatureIndex(int index) {\n+    return getField(index).getGenericSignatureIndex();\n@@ -322,5 +316,1 @@\n-    short genericSignatureIndex = getFieldGenericSignatureIndex(index);\n-    if (genericSignatureIndex != 0)  {\n-      return getConstants().getSymbolAt(genericSignatureIndex);\n-    }\n-    return null;\n+    return getField(index).getGenericSignature();\n@@ -329,1 +319,1 @@\n-  public short getFieldInitialValueIndex(int index) {\n+  public int getFieldInitialValueIndex(int index) {\n@@ -331,1 +321,1 @@\n-    return getFields().at(index * FIELD_SLOTS + INITVAL_INDEX_OFFSET);\n+    return getField(index).getInitialValueIndex();\n@@ -335,7 +325,1 @@\n-    U2Array fields = getFields();\n-    short lo = fields.at(index * FIELD_SLOTS + LOW_OFFSET);\n-    short hi = fields.at(index * FIELD_SLOTS + HIGH_OFFSET);\n-    if ((lo & FIELDINFO_TAG_OFFSET) == FIELDINFO_TAG_OFFSET) {\n-      return VM.getVM().buildIntFromShorts(lo, hi) >> FIELDINFO_TAG_SIZE;\n-    }\n-    throw new RuntimeException(\"should not reach here\");\n+    return (int)getField(index).getOffset();\n@@ -361,12 +345,19 @@\n-  public KlassArray   getLocalInterfaces()      { return new KlassArray(localInterfaces.getValue(getAddress())); }\n-  public KlassArray   getTransitiveInterfaces() { return new KlassArray(transitiveInterfaces.getValue(getAddress())); }\n-  public int       getJavaFieldsCount()     { return                (int) javaFieldsCount.getValue(this); }\n-  public int       getAllFieldsCount()      {\n-    int len = getFields().length();\n-    int allFieldsCount = 0;\n-    for (; allFieldsCount*FIELD_SLOTS < len; allFieldsCount++) {\n-      short flags = getFieldAccessFlags(allFieldsCount);\n-      AccessFlags access = new AccessFlags(flags);\n-      if (access.fieldHasGenericSignature()) {\n-        len --;\n-      }\n+  private int javaFieldsCount = -1;\n+  private int allFieldsCount = -1;\n+\n+  private void initFieldCounts() {\n+    CompressedReadStream crs = new CompressedReadStream(getFieldInfoStream().getDataStart());\n+    javaFieldsCount = crs.readInt(); \/\/ read num_java_fields\n+    allFieldsCount = javaFieldsCount + crs.readInt(); \/\/ read num_injected_fields;\n+  }\n+\n+  public int getJavaFieldsCount() {\n+    if (javaFieldsCount == -1) {\n+      initFieldCounts();\n+    }\n+    return javaFieldsCount;\n+  }\n+\n+  public int getAllFieldsCount() {\n+    if (allFieldsCount == -1) {\n+      initFieldCounts();\n@@ -376,0 +367,3 @@\n+\n+  public KlassArray   getLocalInterfaces()      { return new KlassArray(localInterfaces.getValue(getAddress())); }\n+  public KlassArray   getTransitiveInterfaces() { return new KlassArray(transitiveInterfaces.getValue(getAddress())); }\n@@ -625,1 +619,0 @@\n-    U2Array fields = getFields();\n@@ -863,3 +856,3 @@\n-  public U2Array getFields() {\n-    Address addr = getAddress().getAddressAt(fields.getOffset());\n-    return VMObjectFactory.newObject(U2Array.class, addr);\n+  public U1Array getFieldInfoStream() {\n+    Address addr = getAddress().getAddressAt(fieldinfoStream.getOffset());\n+    return VMObjectFactory.newObject(U1Array.class, addr);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":85,"deletions":92,"binary":false,"changes":177,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -140,11 +140,0 @@\n-    \/\/ field flags\n-    \/\/ Note: these flags must be defined in the low order 16 bits because\n-    \/\/ InstanceKlass only stores a ushort worth of information from the\n-    \/\/ AccessFlags value.\n-    \/\/ field access is watched by JVMTI\n-    public static final long JVM_ACC_FIELD_ACCESS_WATCHED         = 0x00002000;\n-    \/\/ field modification is watched by JVMTI\n-    public static final long JVM_ACC_FIELD_MODIFICATION_WATCHED   = 0x00008000;\n-    \/\/ field has generic signature\n-    public static final long JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE  = 0x00000800;\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ClassConstants.java","additions":1,"deletions":12,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -274,1 +274,1 @@\n-      size += arraySize(k.getFields());\n+      size += arraySize(k.getFieldInfoStream());\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/ClassLoaderStats.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -380,1 +380,1 @@\n-            short nameIndex    = klass.getFieldNameIndex(index);\n+            int nameIndex    = klass.getFieldNameIndex(index);\n@@ -383,1 +383,1 @@\n-            short signatureIndex = klass.getFieldSignatureIndex(index);\n+            int signatureIndex = klass.getFieldSignatureIndex(index);\n@@ -392,1 +392,1 @@\n-            short initvalIndex = klass.getFieldInitialValueIndex(index);\n+            int initvalIndex = klass.getFieldInitialValueIndex(index);\n@@ -396,1 +396,1 @@\n-            short genSigIndex = klass.getFieldGenericSignatureIndex(index);\n+            int genSigIndex = klass.getFieldGenericSignatureIndex(index);\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/tools\/jcore\/ClassWriter.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -1123,2 +1123,1 @@\n-                U2Array klfields = kls.getFields();\n-                int klen = klfields.length();\n+                sun.jvm.hotspot.oops.Field[] fields = sun.jvm.hotspot.oops.Field.getFields(kls);\n@@ -1126,9 +1125,6 @@\n-                for (int index = 0; index < klen; index++) {\n-                    int accsFlags = kls.getFieldAccessFlags(index);\n-                    Symbol f_name = kls.getFieldName(index);\n-                    AccessFlags access = new AccessFlags(accsFlags);\n-                    if (!access.isStatic()) {\n-                        ScopeValue svf = ov.getFieldAt(findex++);\n-                        String    fstr = scopeValueAsString(sd, svf);\n-                        buf.append(\" [\" + f_name.asString() + \" :\"+ index + \"]=(#\" + fstr + \")\");\n-                    }\n+                for (int index = 0; index < fields.length; index++) {\n+                  if (!fields[index].getAccessFlagsObj().isStatic()) {\n+                     ScopeValue svf = ov.getFieldAt(findex++);\n+                     String    fstr = scopeValueAsString(sd, svf);\n+                     buf.append(\" [\" + fields[index].getName().asString() + \" :\"+ index + \"]=(#\" + fstr + \")\");\n+                  }\n@@ -1683,2 +1679,2 @@\n-      U2Array fields = klass.getFields();\n-      int numFields = klass.getAllFieldsCount();\n+      sun.jvm.hotspot.oops.Field[] fields = sun.jvm.hotspot.oops.Field.getFields(klass);\n+      int numFields = fields.length;\n@@ -1689,3 +1685,3 @@\n-           sun.jvm.hotspot.oops.Field field = klass.getFieldByIndex(f);\n-           String f_name = ((NamedFieldIdentifier)field.getID()).getName();\n-           Symbol f_sig  = field.getSignature();\n+           sun.jvm.hotspot.oops.Field field = fields[f];\n+           String f_name = field.getName().asString();\n+           Symbol f_sig = field.getSignature();\n@@ -1705,1 +1701,1 @@\n-           if (f_genSig != null) {\n+           if (field.isGeneric()) {\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/ui\/classbrowser\/HTMLGenerator.java","additions":14,"deletions":18,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,0 +77,4 @@\n+  public Address getDataStart() {\n+    return getAddress().addOffsetTo(dataFieldOffset);\n+  }\n+\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/utilities\/GenericArray.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -464,3 +464,4 @@\n-     *     [ flags,  \/\/ fieldDescriptor::access_flags()\n-     *       offset, \/\/ fieldDescriptor::offset()\n-     *       index   \/\/ fieldDescriptor::index()\n+     *     [ aflags,  \/\/ fieldDescriptor::access_flags()\n+     *       offset,  \/\/ fieldDescriptor::offset()\n+     *       index,   \/\/ fieldDescriptor::index()\n+     *       fflags   \/\/ fieldDescriptor::field_flags()\n@@ -1044,0 +1045,6 @@\n+    HotSpotResolvedObjectTypeImpl.FieldInfo[] getDeclaredFieldsInfo(HotSpotResolvedObjectTypeImpl klass) {\n+        return getDeclaredFieldsInfo(klass, klass.getKlassPointer());\n+    }\n+\n+    native HotSpotResolvedObjectTypeImpl.FieldInfo[] getDeclaredFieldsInfo(HotSpotResolvedObjectTypeImpl klass, long klassPointer);\n+\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/CompilerToVM.java","additions":11,"deletions":4,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -811,1 +811,1 @@\n-            int[] info = new int[3];\n+            int[] info = new int[4];\n@@ -825,1 +825,2 @@\n-            HotSpotResolvedJavaField result = resolvedHolder.createField(type, offset, flags, fieldIndex);\n+            final int fieldFlags = info[3];\n+            HotSpotResolvedJavaField result = resolvedHolder.createField(type, offset, flags, fieldFlags, fieldIndex);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotConstantPool.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-     * This value contains all flags as stored in the VM including internal ones.\n+     * This value contains all flags from the class file\n@@ -61,1 +61,1 @@\n-    private final int modifiers;\n+    private final int classfileFlags;\n@@ -63,1 +63,6 @@\n-    HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int modifiers, int index) {\n+    \/**\n+     * This value contains VM internal flags\n+     *\/\n+    private final int internalFlags;\n+\n+    HotSpotResolvedJavaFieldImpl(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int classfileFlags, int internalFlags, int index) {\n@@ -66,1 +71,0 @@\n-        this.index = index;\n@@ -68,1 +72,3 @@\n-        this.modifiers = modifiers;\n+        this.classfileFlags = classfileFlags;\n+        this.internalFlags = internalFlags;\n+        this.index = index;\n@@ -94,1 +100,1 @@\n-        return modifiers & HotSpotModifiers.jvmFieldModifiers();\n+        return classfileFlags & HotSpotModifiers.jvmFieldModifiers();\n@@ -99,1 +105,1 @@\n-        return (modifiers & config().jvmAccFieldInternal) != 0;\n+        return (internalFlags & (1 << config().jvmFieldFlagInternalShift)) != 0;\n@@ -124,1 +130,1 @@\n-        return holder.createFieldInfo(index).getName();\n+        return holder.getFieldInfo(index).getName(holder);\n@@ -168,1 +174,1 @@\n-        return (config().jvmAccSynthetic & modifiers) != 0;\n+        return (config().jvmAccSynthetic & classfileFlags) != 0;\n@@ -178,1 +184,1 @@\n-        return (config().jvmAccFieldStable & modifiers) != 0;\n+        return (1 << (config().jvmFieldFlagStableShift ) & internalFlags) != 0;\n@@ -222,1 +228,1 @@\n-        return holder.createFieldInfo(index).getConstantValue();\n+        return holder.getFieldInfo(index).getConstantValue(holder);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldImpl.java","additions":18,"deletions":12,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,0 +87,5 @@\n+    \/**\n+     * Lazily initialized cache for FieldInfo.\n+     *\/\n+    private FieldInfo[] fieldInfo;\n+\n@@ -579,2 +584,2 @@\n-    HotSpotResolvedJavaField createField(JavaType type, int offset, int rawFlags, int index) {\n-        return new HotSpotResolvedJavaFieldImpl(this, type, offset, rawFlags, index);\n+    HotSpotResolvedJavaField createField(JavaType type, int offset, int classfileFlags, int internalFlags, int index) {\n+        return new HotSpotResolvedJavaFieldImpl(this, type, offset, classfileFlags, internalFlags, index);\n@@ -626,2 +631,9 @@\n-    FieldInfo createFieldInfo(int index) {\n-        return new FieldInfo(index);\n+    private FieldInfo[] getFieldInfo() {\n+        if (fieldInfo == null) {\n+            fieldInfo = runtime().compilerToVm.getDeclaredFieldsInfo(this);\n+        }\n+        return fieldInfo;\n+    }\n+\n+    FieldInfo getFieldInfo(int index) {\n+        return getFieldInfo()[index];\n@@ -660,5 +672,8 @@\n-    class FieldInfo {\n-        \/**\n-         * Native pointer into the array of Java shorts.\n-         *\/\n-        private final long metaspaceData;\n+    static class FieldInfo {\n+\n+        private final int nameIndex;\n+        private final int signatureIndex;\n+        private final int offset;\n+        private final int classfileFlags;\n+        private final int internalFlags;\n+        private final int initializerIndex;\n@@ -667,1 +682,1 @@\n-         * Creates a field info for the field in the fields array at index {@code index}.\n+         * Creates a field info with the provided indices.\n@@ -669,1 +684,6 @@\n-         * @param index index to the fields array\n+         * @param nameIndex index of field's name in the constant pool\n+         * @param signatureIndex index of field's signature in the constant pool\n+         * @param offset field's offset\n+         * @param classfileFlags field's access flags (from the class file)\n+         * @param internalFlags field's internal flags (from the VM)\n+         * @param initializerIndex field's initial value index in the constant pool\n@@ -671,7 +691,7 @@\n-        FieldInfo(int index) {\n-            HotSpotVMConfig config = config();\n-            \/\/ Get Klass::_fields\n-            final long metaspaceFields = UNSAFE.getAddress(getKlassPointer() + config.instanceKlassFieldsOffset);\n-            assert config.fieldInfoFieldSlots == 6 : \"revisit the field parsing code\";\n-            int offset = config.fieldInfoFieldSlots * Short.BYTES * index;\n-            metaspaceData = metaspaceFields + config.arrayU2DataOffset + offset;\n+        FieldInfo(int nameIndex, int signatureIndex, int offset, int classfileFlags, int internalFlags, int initializerIndex) {\n+            this.nameIndex = nameIndex;\n+            this.signatureIndex = signatureIndex;\n+            this.offset = offset;\n+            this.classfileFlags = classfileFlags;\n+            this.internalFlags = internalFlags;\n+            this.initializerIndex = initializerIndex;\n@@ -680,2 +700,6 @@\n-        private int getAccessFlags() {\n-            return readFieldSlot(config().fieldInfoAccessFlagsOffset);\n+        private int getClassfileFlags() {\n+            return classfileFlags;\n+        }\n+\n+        private int getInternalFlags() {\n+            return internalFlags;\n@@ -685,1 +709,1 @@\n-            return readFieldSlot(config().fieldInfoNameIndexOffset);\n+            return nameIndex;\n@@ -689,1 +713,1 @@\n-            return readFieldSlot(config().fieldInfoSignatureIndexOffset);\n+            return signatureIndex;\n@@ -693,1 +717,1 @@\n-            return readFieldSlot(config().fieldInfoConstantValueIndexOffset);\n+            return initializerIndex;\n@@ -697,4 +721,0 @@\n-            HotSpotVMConfig config = config();\n-            final int lowPacked = readFieldSlot(config.fieldInfoLowPackedOffset);\n-            final int highPacked = readFieldSlot(config.fieldInfoHighPackedOffset);\n-            final int offset = ((highPacked << Short.SIZE) | lowPacked) >> config.fieldInfoTagSize;\n@@ -704,9 +724,0 @@\n-        \/**\n-         * Helper method to read an entry (slot) from the field array. Currently field info is laid\n-         * on top an array of Java shorts.\n-         *\/\n-        private int readFieldSlot(int index) {\n-            int offset = Short.BYTES * index;\n-            return UNSAFE.getChar(metaspaceData + offset);\n-        }\n-\n@@ -716,0 +727,1 @@\n+         * @param klass field's holder class\n@@ -717,3 +729,2 @@\n-        public String getName() {\n-            final int nameIndex = getNameIndex();\n-            return isInternal() ? config().symbolAt(nameIndex) : getConstantPool().lookupUtf8(nameIndex);\n+        public String getName(HotSpotResolvedObjectTypeImpl klass) {\n+            return isInternal() ? config().symbolAt(nameIndex) : klass.getConstantPool().lookupUtf8(nameIndex);\n@@ -725,0 +736,1 @@\n+         * @param klass field's holder class\n@@ -726,3 +738,2 @@\n-        public String getSignature() {\n-            final int signatureIndex = getSignatureIndex();\n-            return isInternal() ? config().symbolAt(signatureIndex) : getConstantPool().lookupUtf8(signatureIndex);\n+        public String getSignature(HotSpotResolvedObjectTypeImpl klass) {\n+            return isInternal() ? config().symbolAt(signatureIndex) : klass.getConstantPool().lookupUtf8(signatureIndex);\n@@ -736,3 +747,2 @@\n-        public JavaConstant getConstantValue() {\n-            int cvIndex = getConstantValueIndex();\n-            if (cvIndex == 0) {\n+        public JavaConstant getConstantValue(HotSpotResolvedObjectTypeImpl klass) {\n+            if (initializerIndex == 0) {\n@@ -741,1 +751,1 @@\n-            return constantPool.getStaticFieldConstantValue(cvIndex);\n+            return klass.constantPool.getStaticFieldConstantValue(initializerIndex);\n@@ -744,3 +754,3 @@\n-        public JavaType getType() {\n-            String signature = getSignature();\n-            return runtime().lookupType(signature, HotSpotResolvedObjectTypeImpl.this, false);\n+        public JavaType getType(HotSpotResolvedObjectTypeImpl klass) {\n+            String signature = getSignature(klass);\n+            return runtime().lookupType(signature, klass, false);\n@@ -750,1 +760,1 @@\n-            return (getAccessFlags() & config().jvmAccFieldInternal) != 0;\n+            return (getInternalFlags() & (1 << config().jvmFieldFlagInternalShift)) != 0;\n@@ -754,5 +764,1 @@\n-            return Modifier.isStatic(getAccessFlags());\n-        }\n-\n-        public boolean hasGenericSignature() {\n-            return (getAccessFlags() & config().jvmAccFieldHasGenericSignature) != 0;\n+            return Modifier.isStatic(getClassfileFlags());\n@@ -823,2 +829,0 @@\n-        final long metaspaceFields = UNSAFE.getAddress(getKlassPointer() + config.instanceKlassFieldsOffset);\n-        int metaspaceFieldsLength = UNSAFE.getInt(metaspaceFields + config.arrayU1LengthOffset);\n@@ -827,5 +831,0 @@\n-        for (int i = 0; i < metaspaceFieldsLength; i += config.fieldInfoFieldSlots, index++) {\n-            FieldInfo field = new FieldInfo(index);\n-            if (field.hasGenericSignature()) {\n-                metaspaceFieldsLength--;\n-            }\n@@ -833,1 +832,2 @@\n-            if (field.isStatic() == retrieveStaticFields) {\n+        for (index = 0; index < getFieldInfo().length; index++) {\n+            if (getFieldInfo(index).isStatic() == retrieveStaticFields) {\n@@ -854,2 +854,2 @@\n-        for (int i = 0; i < index; ++i) {\n-            FieldInfo field = new FieldInfo(i);\n+        for (int i = 0; i < getFieldInfo().length; ++i) {\n+            FieldInfo field = getFieldInfo(i);\n@@ -858,1 +858,1 @@\n-                HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(), offset, field.getAccessFlags(), i);\n+                HotSpotResolvedJavaField resolvedJavaField = createField(field.getType(this), offset, field.getClassfileFlags(), field.getInternalFlags(), i);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":67,"deletions":67,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -102,1 +102,1 @@\n-    final int instanceKlassFieldsOffset = getFieldOffset(\"InstanceKlass::_fields\", Integer.class, \"Array<u2>*\");\n+    final int instanceKlassFieldInfoStreamOffset = getFieldOffset(\"InstanceKlass::_fieldinfo_stream\", Integer.class, \"Array<u1>*\");\n@@ -119,10 +119,0 @@\n-    final int fieldInfoAccessFlagsOffset = getConstant(\"FieldInfo::access_flags_offset\", Integer.class);\n-    final int fieldInfoNameIndexOffset = getConstant(\"FieldInfo::name_index_offset\", Integer.class);\n-    final int fieldInfoSignatureIndexOffset = getConstant(\"FieldInfo::signature_index_offset\", Integer.class);\n-    final int fieldInfoConstantValueIndexOffset = getConstant(\"FieldInfo::initval_index_offset\", Integer.class);\n-    final int fieldInfoLowPackedOffset = getConstant(\"FieldInfo::low_packed_offset\", Integer.class);\n-    final int fieldInfoHighPackedOffset = getConstant(\"FieldInfo::high_packed_offset\", Integer.class);\n-    final int fieldInfoFieldSlots = getConstant(\"FieldInfo::field_slots\", Integer.class);\n-\n-    final int fieldInfoTagSize = getConstant(\"FIELDINFO_TAG_SIZE\", Integer.class);\n-\n@@ -130,3 +120,2 @@\n-    final int jvmAccFieldInternal = getConstant(\"JVM_ACC_FIELD_INTERNAL\", Integer.class);\n-    final int jvmAccFieldStable = getConstant(\"JVM_ACC_FIELD_STABLE\", Integer.class);\n-    final int jvmAccFieldHasGenericSignature = getConstant(\"JVM_ACC_FIELD_HAS_GENERIC_SIGNATURE\", Integer.class);\n+    final int jvmFieldFlagInternalShift = getConstant(\"FieldInfo::FieldFlags::_ff_injected\", Integer.class);\n+    final int jvmFieldFlagStableShift = getConstant(\"FieldInfo::FieldFlags::_ff_stable\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":14,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/meta\/ResolvedJavaField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-  ASSERT_TRUE(strstr(st.as_string(), \"internal 'loader_data'\") != NULL) << \"Must contain internal fields\";\n+  ASSERT_TRUE(strstr(st.as_string(), \"injected 'loader_data'\") != NULL) << \"Must contain injected fields\";\n@@ -59,1 +59,1 @@\n-  ASSERT_TRUE(strstr(st.as_string(), \"internal 'protection_domain'\") != NULL) << \"Must contain internal fields\";\n+  ASSERT_TRUE(strstr(st.as_string(), \"injected 'protection_domain'\") != NULL) << \"Must contain injected fields\";\n","filename":"test\/hotspot\/gtest\/oops\/test_instanceKlass.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -30,2 +30,2 @@\n-    public static ResolvedJavaField createField(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int modifiers, int index) {\n-        return new HotSpotResolvedJavaFieldImpl(holder, type, offset, modifiers, index);\n+    public static ResolvedJavaField createField(HotSpotResolvedObjectTypeImpl holder, JavaType type, int offset, int modifiers, int internalModifiers, int index) {\n+        return new HotSpotResolvedJavaFieldImpl(holder, type, offset, modifiers, internalModifiers, index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/common\/patches\/jdk.internal.vm.ci\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedJavaFieldHelper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,1 @@\n-            int[] info = new int[3];\n+            int[] info = new int[4];\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/compilerToVM\/ResolveFieldInPoolTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,8 +25,0 @@\n-import static java.lang.reflect.Modifier.FINAL;\n-import static java.lang.reflect.Modifier.PRIVATE;\n-import static java.lang.reflect.Modifier.PROTECTED;\n-import static java.lang.reflect.Modifier.PUBLIC;\n-import static java.lang.reflect.Modifier.STATIC;\n-import static java.lang.reflect.Modifier.TRANSIENT;\n-import static java.lang.reflect.Modifier.VOLATILE;\n-\n@@ -41,0 +33,1 @@\n+import jdk.vm.ci.hotspot.HotSpotModifiers;\n@@ -42,1 +35,0 @@\n-import jdk.vm.ci.hotspot.HotSpotVMConfigAccess;\n@@ -66,0 +58,1 @@\n+    private static final Field internalFlagsField;\n@@ -69,1 +62,2 @@\n-        Field f = null;\n+        Field f1 = null;\n+        Field f2 = null;\n@@ -72,1 +66,1 @@\n-            m = typeImpl.getDeclaredMethod(\"createField\", JavaType.class, int.class, int.class, int.class);\n+            m = typeImpl.getDeclaredMethod(\"createField\", JavaType.class, int.class, int.class, int.class, int.class);\n@@ -75,2 +69,4 @@\n-            f = fieldImpl.getDeclaredField(\"index\");\n-            f.setAccessible(true);\n+            f1 = fieldImpl.getDeclaredField(\"index\");\n+            f1.setAccessible(true);\n+            f2 = fieldImpl.getDeclaredField(\"internalFlags\");\n+            f2.setAccessible(true);\n@@ -82,13 +78,2 @@\n-        indexField = f;\n-    }\n-\n-    \/**\n-     * Same as {@code HotSpotModifiers.jvmFieldModifiers()} but works when using a JVMCI version\n-     * prior to the introduction of that method.\n-     *\/\n-    private int jvmFieldModifiers() {\n-        HotSpotJVMCIRuntime runtime = runtime();\n-        HotSpotVMConfigAccess access = new HotSpotVMConfigAccess(runtime.getConfigStore());\n-        int accEnum = access.getConstant(\"JVM_ACC_ENUM\", Integer.class, 0x4000);\n-        int accSynthetic = access.getConstant(\"JVM_ACC_SYNTHETIC\", Integer.class, 0x1000);\n-        return PUBLIC | PRIVATE | PROTECTED | STATIC | FINAL | VOLATILE | TRANSIENT | accEnum | accSynthetic;\n+        indexField = f1;\n+        internalFlagsField = f2;\n@@ -116,1 +101,1 @@\n-                    Assert.assertEquals(0, ~jvmFieldModifiers() & field.getModifiers());\n+                    Assert.assertEquals(0, ~HotSpotModifiers.jvmFieldModifiers() & field.getModifiers());\n@@ -123,1 +108,1 @@\n-     * Tests that {@code HotSpotResolvedObjectTypeImpl#createField(String, JavaType, long, int)}\n+     * Tests that {@code HotSpotResolvedObjectTypeImpl#createField(String, JavaType, int, int)}\n@@ -139,1 +124,2 @@\n-                    ResolvedJavaField actual = (ResolvedJavaField) createFieldMethod.invoke(type, expected.getType(), expected.getOffset(), expected.getModifiers(), index);\n+                    int internalFlags = internalFlagsField.getInt(expected);\n+                    ResolvedJavaField actual = (ResolvedJavaField) createFieldMethod.invoke(type, expected.getType(), expected.getOffset(), expected.getModifiers(), internalFlags, index);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/HotSpotResolvedJavaFieldTest.java","additions":16,"deletions":30,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, 0, 0, index);\n+            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, 0, 0, 0, index);\n@@ -62,1 +62,1 @@\n-            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, offset, 0, 0);\n+            ResolvedJavaField field = HotSpotResolvedJavaFieldHelper.createField(null, null, offset, 0, 0, 0);\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.hotspot.test\/src\/jdk\/vm\/ci\/hotspot\/test\/TestHotSpotResolvedJavaField.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/hotspot\/jtreg\/compiler\/jvmci\/jdk.vm.ci.runtime.test\/src\/jdk\/vm\/ci\/runtime\/test\/TestResolvedJavaField.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}