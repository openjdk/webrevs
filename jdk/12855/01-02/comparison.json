{"files":[{"patch":"@@ -44,18 +44,0 @@\n-  Field(InstanceKlass holder, int fieldIndex) {\n-    Field field = holder.getField(fieldIndex);\n-    this.holder = holder;\n-    this.fieldIndex = fieldIndex;\n-    this.values = field.values;\n-    offset = values.offset;\n-\n-    name = holder.getSymbolFromIndex(values.nameIndex, isInjected());\n-    signature = holder.getSymbolFromIndex(values.signatureIndex, isInjected());\n-    id          = new NamedFieldIdentifier(name.asString());\n-    fieldType   = new FieldType(signature);\n-    accessFlags = new AccessFlags(values.accessFlags);\n-\n-    if (isGeneric()) {\n-      genericSignature = holder.getSymbolFromIndex(values.genericSignatureIndex, isInjected());\n-    }\n-  }\n-\n@@ -79,0 +61,6 @@\n+  \/** Constructor for cloning an existing Field object *\/\n+  Field(InstanceKlass holder, int fieldIndex) {\n+      this(holder, fieldIndex, holder.getField(fieldIndex).values);\n+  }\n+\n+\n@@ -115,11 +103,0 @@\n-  private static FieldInfoValues getFieldInfoValues(CompressedReadStream crs, int fieldIndex) {\n-    int javafieldsCount = crs.readInt(); \/\/ read num_java_fields\n-    int VMFieldsCount = crs.readInt(); \/\/ read num_injected_fields;\n-    if (fieldIndex < 0 || fieldIndex >= javafieldsCount + VMFieldsCount) throw new IndexOutOfBoundsException();\n-    FieldInfoValues fieldInfoValues = null;\n-    for (int i = 0; i <= fieldIndex; i++) {\n-      fieldInfoValues = readFieldInfoValues(crs);\n-    }\n-    return fieldInfoValues;\n-  }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Field.java","additions":6,"deletions":29,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -107,0 +107,2 @@\n+    \/\/ We need a new fieldsCache each time we attach.\n+    fieldsCache = new HashMap<Address, Field[]>();\n@@ -259,1 +261,5 @@\n-  private Field[] fieldCache;\n+  \/\/ Each InstanceKlass mirror instance will cache the Field[] array after it is decoded,\n+  \/\/ but since there can be multiple InstanceKlass mirror instances per hotspot InstanceKlass,\n+  \/\/ we also have a global cache that uses the Address of the hotspot InstanceKlass as the key.\n+  private Field[] fields;\n+  private static Map<Address, Field[]> fieldsCache;\n@@ -262,2 +268,7 @@\n-    if (fieldCache == null) {\n-      fieldCache = Field.getFields(this);\n+    synchronized(this) {\n+      fields = fieldsCache.get(this.getAddress());\n+      if (fields == null) {\n+        fields = Field.getFields(this);\n+        fieldsCache.put(this.getAddress(), fields);\n+      } else {\n+      }\n@@ -265,1 +276,1 @@\n-    return fieldCache[index];\n+    return fields[index];\n@@ -334,4 +345,4 @@\n-  public KlassArray   getLocalInterfaces()      { return new KlassArray(localInterfaces.getValue(getAddress())); }\n-  public KlassArray   getTransitiveInterfaces() { return new KlassArray(transitiveInterfaces.getValue(getAddress())); }\n-  public int          getJavaFieldsCount()      { return new CompressedReadStream(getFieldInfoStream().getDataStart()).readInt(); }\n-  public int          getAllFieldsCount() {\n+  private int javaFieldsCount = -1;\n+  private int allFieldsCount = -1;\n+\n+  private void initFieldCounts() {\n@@ -339,1 +350,9 @@\n-    return crs.readInt() + crs.readInt();\n+    javaFieldsCount = crs.readInt(); \/\/ read num_java_fields\n+    allFieldsCount = javaFieldsCount + crs.readInt(); \/\/ read num_injected_fields;\n+  }\n+\n+  public int getJavaFieldsCount() {\n+    if (javaFieldsCount == -1) {\n+      initFieldCounts();\n+    }\n+    return javaFieldsCount;\n@@ -341,0 +360,10 @@\n+\n+  public int getAllFieldsCount() {\n+    if (allFieldsCount == -1) {\n+      initFieldCounts();\n+    }\n+    return allFieldsCount;\n+  }\n+\n+  public KlassArray   getLocalInterfaces()      { return new KlassArray(localInterfaces.getValue(getAddress())); }\n+  public KlassArray   getTransitiveInterfaces() { return new KlassArray(transitiveInterfaces.getValue(getAddress())); }\n@@ -832,5 +861,0 @@\n-  \/\/ public U2Array getFields() {\n-  \/\/   Address addr = getAddress().getAddressAt(fields.getOffset());\n-  \/\/   return VMObjectFactory.newObject(U2Array.class, addr);\n-  \/\/ }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/InstanceKlass.java","additions":38,"deletions":14,"binary":false,"changes":52,"status":"modified"}]}