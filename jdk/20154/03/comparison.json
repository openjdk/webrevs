{"files":[{"patch":"@@ -38,1 +38,1 @@\n-    private static Throwable agentError;\n+    private static Throwable agentError; \/\/ to be accessed\/updated in a synchronized block\n@@ -40,1 +40,3 @@\n-    public static void checkErrors() {\n+    private static final String CLASS_TO_TRANSFORM = \"NativeMethodPrefixApp$Dummy\";\n+\n+    public static synchronized void checkErrors() {\n@@ -46,0 +48,10 @@\n+    private static synchronized void trackError(final Throwable t) {\n+        if (agentError == null) {\n+            agentError = t;\n+            return;\n+        }\n+        if (agentError != t) {\n+            agentError.addSuppressed(t);\n+        }\n+    }\n+\n@@ -51,0 +63,1 @@\n+        private final String nativeMethodPrefix;\n@@ -55,0 +68,1 @@\n+            this.nativeMethodPrefix = \"wrapped_\" + trname + \"_\";\n@@ -57,31 +71,3 @@\n-        public byte[]\n-        transform(\n-            ClassLoader loader,\n-            String className,\n-            Class<?> classBeingRedefined,\n-            ProtectionDomain    protectionDomain,\n-            byte[] classfileBuffer) {\n-            boolean redef = classBeingRedefined != null;\n-            System.out.println(trname + \": \" +\n-                               (redef? \"Retransforming \" : \"Loading \") + className);\n-            if (className != null) {\n-                try {\n-                    byte[] newcf = Instrumentor.instrFor(classfileBuffer)\n-                                   .addNativeMethodTrackingInjection(\n-                                        \"wrapped_\" + trname + \"_\", (name, h) -> {\n-                                            h.loadConstant(name);\n-                                            h.loadConstant(transformId);\n-                                            h.invokestatic(\n-                                                    CD_StringIdCallbackReporter,\n-                                                    \"tracker\",\n-                                                    MTD_void_String_int);\n-                                        })\n-                                   .apply();\n-                    \/*** debugging ...\n-                    if (newcf != null) {\n-                        String fname = trname + (redef?\"_redef\" : \"\") + \"\/\" + className;\n-                        System.err.println(\"dumping to: \" + fname);\n-                        write_buffer(fname + \"_before.class\", classfileBuffer);\n-                        write_buffer(fname + \"_instr.class\", newcf);\n-                    }\n-                    ***\/\n+        @Override\n+        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n+                                ProtectionDomain protectionDomain, byte[] classfileBuffer) {\n@@ -89,7 +75,6 @@\n-                    return redef? null : newcf;\n-                } catch (Throwable ex) {\n-                    if (agentError == null) {\n-                        agentError = ex;\n-                    }\n-                    System.err.println(\"ERROR: Injection failure: \" + ex);\n-                    ex.printStackTrace();\n+            try {\n+                \/\/ we only transform a specific application class\n+                if (!className.equals(CLASS_TO_TRANSFORM)) {\n+                    return null;\n+                }\n+                if (classBeingRedefined != null) {\n@@ -98,0 +83,16 @@\n+                \/\/ use a byte code generator which creates wrapper methods,\n+                \/\/ with a configured native method prefix, for each native method on the\n+                \/\/ class being transformed\n+                final Instrumentor byteCodeGenerator = Instrumentor.instrFor(classfileBuffer)\n+                        .addNativeMethodTrackingInjection(nativeMethodPrefix,\n+                                (name, cb) -> {\n+                                    cb.loadConstant(name);\n+                                    cb.loadConstant(transformId);\n+                                    cb.invokestatic(CD_StringIdCallbackReporter,\n+                                            \"tracker\", MTD_void_String_int);\n+                                });\n+                \/\/ generate the bytecode\n+                return byteCodeGenerator.apply();\n+            } catch (Throwable t) {\n+                trackError(t);\n+                return null;\n@@ -99,1 +100,0 @@\n-            return null;\n@@ -101,1 +101,0 @@\n-\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixAgent.java","additions":41,"deletions":42,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import java.io.File;\n@@ -27,2 +26,0 @@\n-import java.lang.management.*;\n-import java.util.zip.CRC32;\n@@ -37,1 +34,1 @@\n- * @bug 6263319\n+ * @bug 6263319 8334167\n@@ -40,2 +37,1 @@\n- * @modules java.management\n- *          java.instrument\n+ * @modules java.instrument\n@@ -47,2 +43,1 @@\n- * @run driver\/timeout=240 NativeMethodPrefixApp roleDriver\n- * @comment The test uses a higher timeout to prevent test timeouts noted in JDK-6528548\n+ * @run main\/native NativeMethodPrefixApp roleDriver\n@@ -52,5 +47,3 @@\n-    \/\/ This test is fragile like a golden file test.\n-    \/\/ It assumes that a specific non-native library method will call a specific\n-    \/\/ native method.  The below may need to be updated based on library changes.\n-    static String goldenNativeMethodName = \"getStartupTime\";\n-\n+    \/\/ we expect this native method, which is part of this test's application,\n+    \/\/ to be instrumented and invoked\n+    static String goldenNativeMethodName = \"fooBarNativeMethod\";\n@@ -58,0 +51,1 @@\n+    private static final String testLibraryPath = System.getProperty(\"test.nativepath\");\n@@ -72,0 +66,1 @@\n+            System.loadLibrary(\"NativeMethodPrefix\"); \/\/ load the native library\n@@ -77,1 +72,0 @@\n-        final String testClassesDir = System.getProperty(\"test.classes\");\n@@ -84,3 +78,1 @@\n-                \"\"\"\n-                + \"Boot-Class-Path: \" + testClassesDir.replace(File.separatorChar, '\/') + \"\/\"\n-                + \"\\n\";\n+                \"\"\";\n@@ -100,4 +92,1 @@\n-                \/\/ We disable CheckIntrinsic because the NativeMethodPrefixAgent modifies\n-                \/\/ the native method names, which then causes a failure in the VM check\n-                \/\/ for the presence of an intrinsic on a @IntrinsicCandidate native method.\n-                \"-XX:+UnlockDiagnosticVMOptions\", \"-XX:-CheckIntrinsics\",\n+                \"-Djava.library.path=\" + testLibraryPath,\n@@ -113,8 +102,5 @@\n-\n-        java.lang.reflect.Array.getLength(new short[5]);\n-        RuntimeMXBean mxbean = ManagementFactory.getRuntimeMXBean();\n-        System.err.println(mxbean.getVmVendor());\n-        \/\/ Simply load a class containing an @IntrinsicCandidate on a native method\n-        \/\/ to exercise the VM code which verifies the presence of the intrinsic\n-        \/\/ implementation for that method.\n-        System.err.println(new CRC32());\n+        final long val = new Dummy().callSomeNativeMethod();\n+        if (val != 42) {\n+            throw new RuntimeException(\"unexpected return value \" + val\n+                    + \" from native method, expected 42\");\n+        }\n@@ -140,0 +126,9 @@\n+\n+    private static class Dummy {\n+\n+        private long callSomeNativeMethod() {\n+            return fooBarNativeMethod();\n+        }\n+\n+        private native long fooBarNativeMethod();\n+    }\n","filename":"test\/jdk\/java\/lang\/instrument\/NativeMethodPrefixApp.java","additions":24,"deletions":29,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -0,0 +1,39 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <stdio.h>\n+#include \"jni.h\"\n+\n+JNIEXPORT jlong JNICALL\n+Java_NativeMethodPrefixApp_00024Dummy_fooBarNativeMethod(JNIEnv *env, jclass clazz)\n+{\n+    fprintf(stderr, \"native method called\\n\");\n+    return 42;\n+}\n+\n+JNIEXPORT jint JNICALL\n+JNI_OnLoad(JavaVM *vm, void *reserved)\n+{\n+    fprintf(stderr, \"native library loaded\\n\");\n+    return JNI_VERSION_1_1; \/\/ this native library needs the very basic JNI support\n+}\n","filename":"test\/jdk\/java\/lang\/instrument\/libNativeMethodPrefix.c","additions":39,"deletions":0,"binary":false,"changes":39,"status":"added"}]}