{"files":[{"patch":"@@ -612,4 +612,17 @@\n-                                    int numCases = (Integer) name.function.intrinsicData();\n-                                    onStack = emitTableSwitch(cob, i, numCases);\n-                                    i += 2; \/\/ jump to the end of the TS idiom\n-                                    continue;\n+                                    var customized = lambdaForm.customized;\n+                                    if (customized != null) {\n+                                        List<MethodHandle> cases;\n+                                        var gotList = (Name) lambdaForm.names[i].arguments[2];\n+                                        var getter = gotList.function.resolvedHandle();\n+                                        try {\n+                                            @SuppressWarnings(\"unchecked\")\n+                                            var c0 = (List<MethodHandle>) getter.invokeBasic(customized);\n+                                            cases = c0;\n+                                        } catch (Throwable ex) {\n+                                            throw uncaughtException(ex);\n+                                        }\n+                                        onStack = emitTableSwitch(cob, i, cases.size());\n+                                        i += 1; \/\/ jump to the end of the TS idiom\n+                                        continue;\n+                                    }\n+                                    break; \/\/ Only inline target MHs if this is customized\n@@ -1125,3 +1138,2 @@\n-        Name args    = lambdaForm.names[pos];\n-        Name invoker = lambdaForm.names[pos + 1];\n-        Name result  = lambdaForm.names[pos + 2];\n+        Name selectCase = lambdaForm.names[pos];\n+        Name invocation = lambdaForm.names[pos + 1];\n@@ -1129,4 +1141,2 @@\n-        Class<?> returnType = result.function.resolvedHandle().type().returnType();\n-        MethodType caseType = args.function.resolvedHandle().type()\n-            .dropParameterTypes(0, 1) \/\/ drop collector\n-            .changeReturnType(returnType);\n+        MethodType caseType = invocation.function.resolvedHandle().type()\n+            .dropParameterTypes(0, 1); \/\/ drop MH receiver\n@@ -1134,5 +1144,1 @@\n-\n-        emitPushArgument(cob, invoker, 2); \/\/ push cases\n-        cob.getfield(CD_CasesHolder, \"cases\", CD_MethodHandle_array);\n-        int casesLocal = extendLocalsMap(new Class<?>[] { MethodHandle[].class });\n-        emitStoreInsn(cob, TypeKind.REFERENCE, casesLocal);\n+        var invokeBasic = cob.constantPool().methodRefEntry(CD_MethodHandle, \"invokeBasic\", caseDescriptor);\n@@ -1142,1 +1148,1 @@\n-        List<SwitchCase> cases = new ArrayList<>(numCases);\n+        List<SwitchCase> switchItems = new ArrayList<>(numCases);\n@@ -1144,1 +1150,1 @@\n-            cases.add(SwitchCase.of(i, cob.newLabel()));\n+            switchItems.add(SwitchCase.of(i, cob.newLabel()));\n@@ -1147,2 +1153,2 @@\n-        emitPushArgument(cob, invoker, 0); \/\/ push switch input\n-        cob.tableswitch(0, numCases - 1, defaultLabel, cases)\n+        emitPushArgument(cob, selectCase, 0); \/\/ push switch input\n+        cob.tableswitch(0, numCases - 1, defaultLabel, switchItems)\n@@ -1150,3 +1156,3 @@\n-        emitPushArgument(cob, invoker, 1); \/\/ push default handle\n-        emitPushArguments(cob, args, 1); \/\/ again, skip collector\n-        cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor)\n+        emitPushArgument(cob, selectCase, 1); \/\/ push default handle\n+        emitPushArguments(cob, invocation, 1); \/\/ again, skip collector\n+        cob.invokevirtual(invokeBasic)\n@@ -1155,0 +1161,1 @@\n+        var listGet = cob.constantPool().interfaceMethodRefEntry(CD_List, \"get\", MTD_Object_int);\n@@ -1156,1 +1163,1 @@\n-            cob.labelBinding(cases.get(i).target());\n+            cob.labelBinding(switchItems.get(i).target());\n@@ -1158,1 +1165,1 @@\n-            emitLoadInsn(cob, TypeKind.REFERENCE, casesLocal);\n+            emitPushArgument(cob, selectCase, 2);\n@@ -1160,1 +1167,2 @@\n-               .aaload();\n+               .invokeinterface(listGet)\n+               .checkcast(CD_MethodHandle);\n@@ -1163,2 +1171,2 @@\n-            emitPushArguments(cob, args, 1); \/\/ again, skip collector\n-            cob.invokevirtual(CD_MethodHandle, \"invokeBasic\", caseDescriptor)\n+            emitPushArguments(cob, invocation, 1); \/\/ again, skip collector\n+            cob.invokevirtual(invokeBasic)\n@@ -1170,1 +1178,1 @@\n-        return result;\n+        return invocation;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":37,"deletions":29,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -698,4 +698,2 @@\n-        \/\/   t_{n}:L=MethodHandle.invokeBasic(...)     \/\/ args\n-        \/\/   t_{n+1}:L=MethodHandleImpl.tableSwitch(*, *, *, t_{n})\n-        \/\/   t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})\n-        if (pos + 2 >= names.length)  return false;\n+        \/\/   t_{n}:L=MethodHandleImpl.selectCase(*, *, *)\n+        \/\/   t_{n+1}:?=MethodHandle.invokeBasic(t_{n}, args)\n@@ -703,3 +701,3 @@\n-        final int POS_COLLECT_ARGS = pos;\n-        final int POS_TABLE_SWITCH = pos + 1;\n-        final int POS_UNBOX_RESULT = pos + 2;\n+        final int SELECTED_MH  = pos;\n+        final int INVOKE       = pos + 1;\n+        assert INVOKE + 1 <= names.length;\n@@ -707,10 +705,9 @@\n-        Name collectArgs = names[POS_COLLECT_ARGS];\n-        Name tableSwitch = names[POS_TABLE_SWITCH];\n-        Name unboxResult = names[POS_UNBOX_RESULT];\n-        return tableSwitch.refersTo(MethodHandleImpl.class, \"tableSwitch\") &&\n-                collectArgs.isInvokeBasic() &&\n-                unboxResult.isInvokeBasic() &&\n-                tableSwitch.lastUseIndex(collectArgs) == 3 &&     \/\/ t_{n+1}:L=MethodHandleImpl.<invoker>(*, *, *, t_{n});\n-                lastUseIndex(collectArgs) == POS_TABLE_SWITCH &&  \/\/ t_{n} is local: used only in t_{n+1}\n-                unboxResult.lastUseIndex(tableSwitch) == 1 &&     \/\/ t_{n+2}:?=MethodHandle.invokeBasic(*, t_{n+1})\n-                lastUseIndex(tableSwitch) == POS_UNBOX_RESULT;    \/\/ t_{n+1} is local: used only in t_{n+2}\n+        Name selectCase = names[SELECTED_MH];\n+        Name invocation = names[INVOKE];\n+        return selectCase.refersTo(MethodHandleImpl.class, \"selectCase\") &&\n+                selectCase.arguments[2] instanceof Name bmhGet &&\n+                bmhGet.arguments.length == 1 &&\n+                bmhGet.type == L_TYPE &&\n+                BoundMethodHandle.class.isAssignableFrom(bmhGet.function.memberDeclaringClassOrNull()) &&\n+                invocation.isInvokeBasic() &&\n+                invocation.lastUseIndex(selectCase) == 0;\n@@ -1263,6 +1260,0 @@\n-\n-        public Object intrinsicData() {\n-            return resolvedHandle != null\n-                ? resolvedHandle.intrinsicData()\n-                : null;\n-        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":14,"deletions":23,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1782,5 +1782,0 @@\n-    \/*non-public*\/\n-    Object intrinsicData() {\n-        return null;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandle.java","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -58,1 +58,0 @@\n-import java.util.concurrent.ConcurrentHashMap;\n@@ -1355,1 +1354,0 @@\n-        private final Object intrinsicData;\n@@ -1358,4 +1356,0 @@\n-           this(target, intrinsicName, null);\n-        }\n-\n-        IntrinsicMethodHandle(MethodHandle target, Intrinsic intrinsicName, Object intrinsicData) {\n@@ -1365,1 +1359,0 @@\n-            this.intrinsicData = intrinsicData;\n@@ -1378,5 +1371,0 @@\n-        @Override\n-        Object intrinsicData() {\n-            return intrinsicData;\n-        }\n-\n@@ -1408,4 +1396,0 @@\n-        return makeIntrinsic(target, intrinsicName, null);\n-    }\n-\n-    static MethodHandle makeIntrinsic(MethodHandle target, Intrinsic intrinsicName, Object intrinsicData) {\n@@ -1414,1 +1398,1 @@\n-        return new IntrinsicMethodHandle(target, intrinsicName, intrinsicData);\n+        return new IntrinsicMethodHandle(target, intrinsicName);\n@@ -1490,2 +1474,1 @@\n-            NF_tableSwitch = 6,\n-            NF_LIMIT = 7;\n+            NF_LIMIT = 6;\n@@ -1519,2 +1502,0 @@\n-                case NF_tableSwitch         -> new NamedFunction(MethodHandleImpl.class\n-                                                .getDeclaredMethod(\"tableSwitch\", int.class, MethodHandle.class, CasesHolder.class, Object[].class));\n@@ -2103,18 +2084,3 @@\n-    \/\/ use a wrapper because we need this array to be @Stable\n-    static class CasesHolder {\n-        @Stable\n-        final MethodHandle[] cases;\n-\n-        public CasesHolder(MethodHandle[] cases) {\n-            this.cases = cases;\n-        }\n-    }\n-\n-    static MethodHandle makeTableSwitch(MethodType type, MethodHandle defaultCase, MethodHandle[] caseActions) {\n-        MethodType varargsType = type.changeReturnType(Object[].class);\n-        MethodHandle collectArgs = varargsArray(type.parameterCount()).asType(varargsType);\n-\n-        MethodHandle unboxResult = unboxResultHandle(type.returnType());\n-\n-        BoundMethodHandle.SpeciesData data = BoundMethodHandle.speciesData_LLLL();\n-        LambdaForm form = makeTableSwitchForm(type.basicType(), data, caseActions.length);\n+    static MethodHandle makeTableSwitch(MethodType type, MethodHandle defaultCase, List<MethodHandle> caseActions) {\n+        var species = BoundMethodHandle.speciesData_LL();\n+        LambdaForm form = makeTableSwitchForm(type.basicType());\n@@ -2122,1 +2088,0 @@\n-        CasesHolder caseHolder =  new CasesHolder(caseActions);\n@@ -2124,2 +2089,1 @@\n-            mh = (BoundMethodHandle) data.factory().invokeBasic(type, form, (Object) defaultCase, (Object) collectArgs,\n-                                                                (Object) unboxResult, (Object) caseHolder);\n+            mh = (BoundMethodHandle) species.factory().invokeBasic(type, form, (Object) defaultCase, (Object) caseActions);\n@@ -2133,5 +2097,3 @@\n-    private static class TableSwitchCacheKey {\n-        private static final Map<TableSwitchCacheKey, LambdaForm> CACHE = new ConcurrentHashMap<>();\n-\n-        private final MethodType basicType;\n-        private final int numberOfCases;\n+    private static LambdaForm makeTableSwitchForm(MethodType basicType) {\n+        var lform = basicType.form().cachedLambdaForm(MethodTypeForm.LF_SWITCH);\n+        if (lform != null) return lform;\n@@ -2139,35 +2101,5 @@\n-        public TableSwitchCacheKey(MethodType basicType, int numberOfCases) {\n-            this.basicType = basicType;\n-            this.numberOfCases = numberOfCases;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) return true;\n-            if (o == null || getClass() != o.getClass()) return false;\n-            TableSwitchCacheKey that = (TableSwitchCacheKey) o;\n-            return numberOfCases == that.numberOfCases && Objects.equals(basicType, that.basicType);\n-        }\n-        @Override\n-        public int hashCode() {\n-            return Objects.hash(basicType, numberOfCases);\n-        }\n-    }\n-\n-    private static LambdaForm makeTableSwitchForm(MethodType basicType, BoundMethodHandle.SpeciesData data,\n-                                                  int numCases) {\n-        \/\/ We need to cache based on the basic type X number of cases,\n-        \/\/ since the number of cases is used when generating bytecode.\n-        \/\/ This also means that we can't use the cache in MethodTypeForm,\n-        \/\/ which only uses the basic type as a key.\n-        TableSwitchCacheKey key = new TableSwitchCacheKey(basicType, numCases);\n-        LambdaForm lform = TableSwitchCacheKey.CACHE.get(key);\n-        if (lform != null) {\n-            return lform;\n-        }\n-\n-        final int THIS_MH       = 0;\n-        final int ARG_BASE      = 1;  \/\/ start of incoming arguments\n-        final int ARG_LIMIT     = ARG_BASE + basicType.parameterCount();\n-        final int ARG_SWITCH_ON = ARG_BASE;\n-        assert ARG_SWITCH_ON < ARG_LIMIT;\n+        final int THIS_MH      = 0;\n+        final int ARG_BASE     = 1;  \/\/ start of incoming arguments\n+        final int ARG_LIMIT    = ARG_BASE + basicType.parameterCount();\n+        final int ARG_SELECTOR = ARG_BASE; \/\/ int selector\n+        assert ARG_SELECTOR < ARG_LIMIT;\n@@ -2176,15 +2108,4 @@\n-        final int GET_COLLECT_ARGS  = nameCursor++;\n-        final int GET_DEFAULT_CASE  = nameCursor++;\n-        final int GET_UNBOX_RESULT  = nameCursor++;\n-        final int GET_CASES         = nameCursor++;\n-        final int BOXED_ARGS        = nameCursor++;\n-        final int TABLE_SWITCH      = nameCursor++;\n-        final int UNBOXED_RESULT    = nameCursor++;\n-\n-        int fieldCursor = 0;\n-        final int FIELD_DEFAULT_CASE  = fieldCursor++;\n-        final int FIELD_COLLECT_ARGS  = fieldCursor++;\n-        final int FIELD_UNBOX_RESULT  = fieldCursor++;\n-        final int FIELD_CASES         = fieldCursor++;\n-\n-        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n+        final int DEFAULT_CASE = nameCursor++;\n+        final int CASES        = nameCursor++;\n+        final int SELECTED_MH  = nameCursor++;\n+        final int INVOKE       = nameCursor++;\n@@ -2192,5 +2113,2 @@\n-        names[THIS_MH] = names[THIS_MH].withConstraint(data);\n-        names[GET_DEFAULT_CASE] = new Name(data.getterFunction(FIELD_DEFAULT_CASE), names[THIS_MH]);\n-        names[GET_COLLECT_ARGS]  = new Name(data.getterFunction(FIELD_COLLECT_ARGS), names[THIS_MH]);\n-        names[GET_UNBOX_RESULT]  = new Name(data.getterFunction(FIELD_UNBOX_RESULT), names[THIS_MH]);\n-        names[GET_CASES] = new Name(data.getterFunction(FIELD_CASES), names[THIS_MH]);\n+        \/\/ 0: defaultCase; 1: cases\n+        final var species = BoundMethodHandle.speciesData_LL();\n@@ -2198,8 +2116,3 @@\n-        {\n-            MethodType collectArgsType = basicType.changeReturnType(Object.class);\n-            MethodHandle invokeBasic = MethodHandles.basicInvoker(collectArgsType);\n-            Object[] args = new Object[invokeBasic.type().parameterCount()];\n-            args[0] = names[GET_COLLECT_ARGS];\n-            System.arraycopy(names, ARG_BASE, args, 1, ARG_LIMIT - ARG_BASE);\n-            names[BOXED_ARGS] = new Name(new NamedFunction(makeIntrinsic(invokeBasic, Intrinsic.TABLE_SWITCH, numCases)), args);\n-        }\n+        Name[] names = invokeArguments(nameCursor - ARG_LIMIT, basicType);\n+        names[THIS_MH] = names[THIS_MH].withConstraint(species);\n+        assert names[ARG_SELECTOR].type == BasicType.I_TYPE;\n@@ -2207,5 +2120,4 @@\n-        {\n-            Object[] tfArgs = new Object[]{\n-                names[ARG_SWITCH_ON], names[GET_DEFAULT_CASE], names[GET_CASES], names[BOXED_ARGS]};\n-            names[TABLE_SWITCH] = new Name(getFunction(NF_tableSwitch), tfArgs);\n-        }\n+        names[DEFAULT_CASE] = new Name(species.getterFunction(0), names[THIS_MH]);\n+        names[CASES] = new Name(species.getterFunction(1), names[THIS_MH]);\n+        names[SELECTED_MH] = new Name(new NamedFunction(makeIntrinsic(getConstantHandle(MH_selectCase), Intrinsic.TABLE_SWITCH)),\n+                names[ARG_SELECTOR], names[DEFAULT_CASE], names[CASES]);\n@@ -2214,3 +2126,3 @@\n-            MethodHandle invokeBasic = MethodHandles.basicInvoker(MethodType.methodType(basicType.rtype(), Object.class));\n-            Object[] unboxArgs = new Object[]{names[GET_UNBOX_RESULT], names[TABLE_SWITCH]};\n-            names[UNBOXED_RESULT] = new Name(invokeBasic, unboxArgs);\n+            Object[] targetArgs = Arrays.copyOfRange(names, THIS_MH, ARG_LIMIT, Object[].class);\n+            targetArgs[THIS_MH] = names[SELECTED_MH];  \/\/ overwrite this MH with selected MH\n+            names[INVOKE] = new LambdaForm.Name(basicType, targetArgs);\n@@ -2219,3 +2131,2 @@\n-        lform = LambdaForm.create(basicType.parameterCount() + 1, names, Kind.TABLE_SWITCH);\n-        LambdaForm prev = TableSwitchCacheKey.CACHE.putIfAbsent(key, lform);\n-        return prev != null ? prev : lform;\n+        lform = LambdaForm.create(ARG_LIMIT, names, Kind.TABLE_SWITCH);\n+        return basicType.form().setCachedLambdaForm(MethodTypeForm.LF_SWITCH, lform);\n@@ -2225,2 +2136,3 @@\n-    static Object tableSwitch(int input, MethodHandle defaultCase, CasesHolder holder, Object[] args) throws Throwable {\n-        MethodHandle[] caseActions = holder.cases;\n+    @ForceInline\n+    static MethodHandle selectCase(int input, MethodHandle defaultCase, List<MethodHandle> handles) {\n+        \/\/ handles must be immutable List.of\n@@ -2228,1 +2140,1 @@\n-        if (input < 0 || input >= caseActions.length) {\n+        if (input < 0 || input >= handles.size()) {\n@@ -2231,1 +2143,1 @@\n-            selectedCase = caseActions[input];\n+            selectedCase = handles.get(input);\n@@ -2233,1 +2145,1 @@\n-        return selectedCase.invokeWithArguments(args);\n+        return selectedCase;\n@@ -2247,1 +2159,2 @@\n-            MH_LIMIT                 =              9;\n+            MH_selectCase            =              9,\n+            MH_LIMIT                 =             10;\n@@ -2272,3 +2185,2 @@\n-            switch (idx) {\n-                case MH_cast:\n-                    return IMPL_LOOKUP.findVirtual(Class.class, \"cast\",\n+            return switch (idx) {\n+                case MH_cast -> IMPL_LOOKUP.findVirtual(Class.class, \"cast\",\n@@ -2276,2 +2188,1 @@\n-                case MH_selectAlternative:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"selectAlternative\",\n+                case MH_selectAlternative -> IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"selectAlternative\",\n@@ -2279,2 +2190,1 @@\n-                case MH_countedLoopPred:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"countedLoopPredicate\",\n+                case MH_countedLoopPred -> IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"countedLoopPredicate\",\n@@ -2282,2 +2192,1 @@\n-                case MH_countedLoopStep:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"countedLoopStep\",\n+                case MH_countedLoopStep -> IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"countedLoopStep\",\n@@ -2285,2 +2194,1 @@\n-                case MH_initIterator:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"initIterator\",\n+                case MH_initIterator -> IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"initIterator\",\n@@ -2288,2 +2196,1 @@\n-                case MH_iteratePred:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"iteratePredicate\",\n+                case MH_iteratePred -> IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"iteratePredicate\",\n@@ -2291,2 +2198,1 @@\n-                case MH_iterateNext:\n-                    return IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"iterateNext\",\n+                case MH_iterateNext -> IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"iterateNext\",\n@@ -2294,2 +2200,1 @@\n-                case MH_Array_newInstance:\n-                    return IMPL_LOOKUP.findStatic(Array.class, \"newInstance\",\n+                case MH_Array_newInstance -> IMPL_LOOKUP.findStatic(Array.class, \"newInstance\",\n@@ -2297,2 +2202,1 @@\n-                case MH_VarHandles_handleCheckedExceptions:\n-                    return IMPL_LOOKUP.findStatic(VarHandles.class, \"handleCheckedExceptions\",\n+                case MH_VarHandles_handleCheckedExceptions -> IMPL_LOOKUP.findStatic(VarHandles.class, \"handleCheckedExceptions\",\n@@ -2300,1 +2204,4 @@\n-            }\n+                case MH_selectCase -> IMPL_LOOKUP.findStatic(MethodHandleImpl.class, \"selectCase\",\n+                            MethodType.methodType(MethodHandle.class, int.class, MethodHandle.class, List.class));\n+                default -> throw newInternalError(\"Unknown function index: \" + idx);\n+            };\n@@ -2304,1 +2211,0 @@\n-        throw newInternalError(\"Unknown function index: \" + idx);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandleImpl.java","additions":54,"deletions":148,"binary":false,"changes":202,"status":"modified"},{"patch":"@@ -7646,4 +7646,3 @@\n-        Objects.requireNonNull(targets);\n-        targets = targets.clone();\n-        MethodType type = tableSwitchChecks(fallback, targets);\n-        return MethodHandleImpl.makeTableSwitch(type, fallback, targets);\n+        var targetList = List.of(targets); \/\/ deep null checks\n+        MethodType type = tableSwitchChecks(fallback, targetList);\n+        return MethodHandleImpl.makeTableSwitch(type, fallback, targetList);\n@@ -7652,3 +7651,3 @@\n-    private static MethodType tableSwitchChecks(MethodHandle defaultCase, MethodHandle[] caseActions) {\n-        if (caseActions.length == 0)\n-            throw new IllegalArgumentException(\"Not enough cases: \" + Arrays.toString(caseActions));\n+    private static MethodType tableSwitchChecks(MethodHandle defaultCase, List<MethodHandle> caseActions) {\n+        if (caseActions.isEmpty())\n+            throw new IllegalArgumentException(\"At least one target required\");\n@@ -7658,1 +7657,1 @@\n-        if (!(expectedType.parameterCount() >= 1) || expectedType.parameterType(0) != int.class)\n+        if (expectedType.parameterCount() < 1 || expectedType.parameterType(0) != int.class)\n@@ -7660,1 +7659,1 @@\n-                \"Case actions must have int as leading parameter: \" + Arrays.toString(caseActions));\n+                \"Switch method handles must have int as leading parameter: \" + expectedType);\n@@ -7663,1 +7662,0 @@\n-            Objects.requireNonNull(mh);\n@@ -7666,1 +7664,1 @@\n-                    \"Case actions must have the same type: \" + Arrays.toString(caseActions));\n+                    \"Some targets do not have the expected type \" + expectedType + \": \" + caseActions);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodHandles.java","additions":9,"deletions":11,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-            LF_LIMIT                   = 26;\n+            LF_SWITCH                  = 26,  \/\/ switches handles to invoke\n+            LF_LIMIT                   = 27;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/MethodTypeForm.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+import jdk.internal.vm.annotation.ForceInline;\n@@ -588,0 +589,1 @@\n+        @ForceInline\n@@ -688,0 +690,1 @@\n+        @ForceInline\n","filename":"src\/java.base\/share\/classes\/java\/util\/ImmutableCollections.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,220 @@\n+\/*\n+ * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8263087 8350617\n+ * @run junit\/othervm -Xverify:all TableSwitchTest\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.IntConsumer;\n+import java.util.function.IntFunction;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class TableSwitchTest {\n+\n+    static final MethodHandle MH_IntConsumer_accept;\n+    static final MethodHandle MH_check;\n+\n+    static {\n+        try {\n+            MethodHandles.Lookup lookup = MethodHandles.lookup();\n+            MH_IntConsumer_accept = lookup.findVirtual(IntConsumer.class, \"accept\",\n+                    MethodType.methodType(void.class, int.class));\n+            MH_check = lookup.findStatic(TableSwitchTest.class, \"check\",\n+                    MethodType.methodType(void.class, List.class, Object[].class));\n+        } catch (ReflectiveOperationException e) {\n+            throw new ExceptionInInitializerError(e);\n+        }\n+    }\n+\n+    public static MethodHandle simpleTestCase(String value) {\n+        return simpleTestCase(String.class, value);\n+    }\n+\n+    public static MethodHandle simpleTestCase(Class<?> type, Object value) {\n+        return MethodHandles.dropArguments(MethodHandles.constant(type, value), 0, int.class);\n+    }\n+\n+    public static Object testValue(Class<?> type) {\n+        if (type == String.class) {\n+            return \"X\";\n+        } else if (type == byte.class) {\n+            return (byte) 42;\n+        } else if (type == short.class) {\n+            return (short) 84;\n+        } else if (type == char.class) {\n+            return 'Y';\n+        } else if (type == int.class) {\n+            return 168;\n+        } else if (type == long.class) {\n+            return 336L;\n+        } else if (type == float.class) {\n+            return 42F;\n+        } else if (type == double.class) {\n+            return 84D;\n+        } else if (type == boolean.class) {\n+            return true;\n+        }\n+        return null;\n+    }\n+\n+    static final Class<?>[] TEST_TYPES = {\n+        Object.class,\n+        String.class,\n+        byte.class,\n+        short.class,\n+        char.class,\n+        int.class,\n+        long.class,\n+        float.class,\n+        double.class,\n+        boolean.class\n+    };\n+\n+    public static Object[] testArguments(int caseNum, List<Object> testValues) {\n+        Object[] args = new Object[testValues.size() + 1];\n+        args[0] = caseNum;\n+        int insertPos = 1;\n+        for (Object testValue : testValues) {\n+            args[insertPos++] = testValue;\n+        }\n+        return args;\n+    }\n+\n+    public static Object[][] nonVoidCases() {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        for (Class<?> returnType : TEST_TYPES) {\n+            for (int numCases = 1; numCases < 5; numCases++) {\n+                tests.add(new Object[] { returnType, numCases, List.of() });\n+                tests.add(new Object[] { returnType, numCases, List.of(TEST_TYPES) });\n+            }\n+        }\n+\n+        return tests.toArray(Object[][]::new);\n+    }\n+\n+    private static void check(List<Object> testValues, Object[] collectedValues) {\n+        assertEquals(testValues, Arrays.asList(collectedValues));\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"nonVoidCases\")\n+    public void testNonVoidHandles(Class<?> type, int numCases, List<Class<?>> additionalTypes) throws Throwable {\n+        MethodHandle collector = MH_check;\n+        List<Object> testArguments = new ArrayList<>();\n+        collector = MethodHandles.insertArguments(collector, 0, testArguments);\n+        collector = collector.asCollector(Object[].class, additionalTypes.size());\n+\n+        Object defaultReturnValue = testValue(type);\n+        MethodHandle defaultCase = simpleTestCase(type, defaultReturnValue);\n+        defaultCase = MethodHandles.collectArguments(defaultCase, 1, collector);\n+        Object[] returnValues = new Object[numCases];\n+        MethodHandle[] cases = new MethodHandle[numCases];\n+        for (int i = 0; i < cases.length; i++) {\n+            Object returnValue = testValue(type);\n+            returnValues[i] = returnValue;\n+            MethodHandle theCase = simpleTestCase(type, returnValue);\n+            theCase = MethodHandles.collectArguments(theCase, 1, collector);\n+            cases[i] = theCase;\n+        }\n+\n+        MethodHandle mhSwitch = MethodHandles.tableSwitch(\n+            defaultCase,\n+            cases\n+        );\n+\n+        for (Class<?> additionalType : additionalTypes) {\n+            testArguments.add(testValue(additionalType));\n+        }\n+\n+        assertEquals(defaultReturnValue, mhSwitch.invokeWithArguments(testArguments(-1, testArguments)));\n+\n+        for (int i = 0; i < numCases; i++) {\n+            assertEquals(returnValues[i], mhSwitch.invokeWithArguments(testArguments(i, testArguments)));\n+        }\n+\n+        assertEquals(defaultReturnValue, mhSwitch.invokeWithArguments(testArguments(numCases, testArguments)));\n+    }\n+\n+    @Test\n+    public void testVoidHandles() throws Throwable {\n+        IntFunction<MethodHandle> makeTestCase = expectedIndex -> {\n+            IntConsumer test = actualIndex -> assertEquals(expectedIndex, actualIndex);\n+            return MH_IntConsumer_accept.bindTo(test);\n+        };\n+\n+        MethodHandle mhSwitch = MethodHandles.tableSwitch(\n+            \/* default: *\/ makeTestCase.apply(-1),\n+            \/* case 0: *\/  makeTestCase.apply(0),\n+            \/* case 1: *\/  makeTestCase.apply(1),\n+            \/* case 2: *\/  makeTestCase.apply(2)\n+        );\n+\n+        mhSwitch.invokeExact((int) -1);\n+        mhSwitch.invokeExact((int) 0);\n+        mhSwitch.invokeExact((int) 1);\n+        mhSwitch.invokeExact((int) 2);\n+    }\n+\n+    @Test\n+    public void testNullPointers() {\n+        assertThrows(NullPointerException.class, () -> MethodHandles.tableSwitch(null, simpleTestCase(\"test\")), \"defaultCase\");\n+\n+        MethodHandle[] cases = null;\n+        assertThrows(NullPointerException.class, () -> MethodHandles.tableSwitch(simpleTestCase(\"default\"), cases), \"cases array\");\n+        assertThrows(NullPointerException.class, () -> MethodHandles.tableSwitch(simpleTestCase(\"default\"), simpleTestCase(\"case\"), null), \"cases item\");\n+    }\n+\n+    @Test\n+    public void testTableSwitchChecks() {\n+        assertThrows(IllegalArgumentException.class, () -> MethodHandles.tableSwitch(simpleTestCase(\"default\")), \"zero cases\");\n+\n+        MethodHandle tooFewArgsMh = MethodHandles.empty(MethodType.methodType(void.class));\n+        var tooFewEx = assertThrows(IllegalArgumentException.class, () -> MethodHandles.tableSwitch(tooFewArgsMh, tooFewArgsMh, tooFewArgsMh), \"too few args ex\");\n+        assertTrue(tooFewEx.getMessage().contains(\"int\") && tooFewEx.getMessage().contains(\"leading\"), \"too few args message\");\n+        assertTrue(tooFewEx.getMessage().contains(tooFewArgsMh.type().toString()), \"too few args message - bad type\");\n+\n+        var noIntMh = MethodHandles.empty(MethodType.methodType(void.class, double.class));\n+        var noIntEx = assertThrows(IllegalArgumentException.class, () -> MethodHandles.tableSwitch(noIntMh, noIntMh, noIntMh), \"no leading int ex\");\n+        assertTrue(noIntEx.getMessage().contains(\"int\") && noIntEx.getMessage().contains(\"leading\"), \"leading int message\");\n+        assertTrue(noIntEx.getMessage().contains(noIntMh.type().toString()), \"leading int message - bad type\");\n+\n+        var wrongTypeMh = MethodHandles.empty(MethodType.methodType(void.class, int.class));\n+        var wrongTypeEx = assertThrows(IllegalArgumentException.class, () -> MethodHandles.tableSwitch(simpleTestCase(\"default\"), simpleTestCase(\"case\"), wrongTypeMh), \"wrong MH types ex\");\n+        assertTrue(wrongTypeEx.getMessage().contains(simpleTestCase(\"default\").type().toString()), \"common case type\");\n+        assertTrue(wrongTypeEx.getMessage().contains(wrongTypeMh.type().toString()), \"bad case type\");\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/TableSwitchTest.java","additions":220,"deletions":0,"binary":false,"changes":220,"status":"added"},{"patch":"@@ -1,234 +0,0 @@\n-\/*\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @run testng\/othervm -Xverify:all TestTableSwitch\n- *\/\n-\n-import org.testng.annotations.DataProvider;\n-import org.testng.annotations.Test;\n-\n-import javax.management.ObjectName;\n-import java.lang.invoke.MethodHandle;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.IntConsumer;\n-import java.util.function.IntFunction;\n-\n-import static org.testng.Assert.assertEquals;\n-\n-public class TestTableSwitch {\n-\n-    static final MethodHandle MH_IntConsumer_accept;\n-    static final MethodHandle MH_check;\n-\n-    static {\n-        try {\n-            MethodHandles.Lookup lookup = MethodHandles.lookup();\n-            MH_IntConsumer_accept = lookup.findVirtual(IntConsumer.class, \"accept\",\n-                    MethodType.methodType(void.class, int.class));\n-            MH_check = lookup.findStatic(TestTableSwitch.class, \"check\",\n-                    MethodType.methodType(void.class, List.class, Object[].class));\n-        } catch (ReflectiveOperationException e) {\n-            throw new ExceptionInInitializerError(e);\n-        }\n-    }\n-\n-    public static MethodHandle simpleTestCase(String value) {\n-        return simpleTestCase(String.class, value);\n-    }\n-\n-    public static MethodHandle simpleTestCase(Class<?> type, Object value) {\n-        return MethodHandles.dropArguments(MethodHandles.constant(type, value), 0, int.class);\n-    }\n-\n-    public static Object testValue(Class<?> type) {\n-        if (type == String.class) {\n-            return \"X\";\n-        } else if (type == byte.class) {\n-            return (byte) 42;\n-        } else if (type == short.class) {\n-            return (short) 84;\n-        } else if (type == char.class) {\n-            return 'Y';\n-        } else if (type == int.class) {\n-            return 168;\n-        } else if (type == long.class) {\n-            return 336L;\n-        } else if (type == float.class) {\n-            return 42F;\n-        } else if (type == double.class) {\n-            return 84D;\n-        } else if (type == boolean.class) {\n-            return true;\n-        }\n-        return null;\n-    }\n-\n-    static final Class<?>[] TEST_TYPES = {\n-        Object.class,\n-        String.class,\n-        byte.class,\n-        short.class,\n-        char.class,\n-        int.class,\n-        long.class,\n-        float.class,\n-        double.class,\n-        boolean.class\n-    };\n-\n-    public static Object[] testArguments(int caseNum, List<Object> testValues) {\n-        Object[] args = new Object[testValues.size() + 1];\n-        args[0] = caseNum;\n-        int insertPos = 1;\n-        for (Object testValue : testValues) {\n-            args[insertPos++] = testValue;\n-        }\n-        return args;\n-    }\n-\n-    @DataProvider\n-    public static Object[][] nonVoidCases() {\n-        List<Object[]> tests = new ArrayList<>();\n-\n-        for (Class<?> returnType : TEST_TYPES) {\n-            for (int numCases = 1; numCases < 5; numCases++) {\n-                tests.add(new Object[] { returnType, numCases, List.of() });\n-                tests.add(new Object[] { returnType, numCases, List.of(TEST_TYPES) });\n-            }\n-        }\n-\n-        return tests.toArray(Object[][]::new);\n-    }\n-\n-    private static void check(List<Object> testValues, Object[] collectedValues) {\n-        assertEquals(collectedValues, testValues.toArray());\n-    }\n-\n-    @Test(dataProvider = \"nonVoidCases\")\n-    public void testNonVoidHandles(Class<?> type, int numCases, List<Class<?>> additionalTypes) throws Throwable {\n-        MethodHandle collector = MH_check;\n-        List<Object> testArguments = new ArrayList<>();\n-        collector = MethodHandles.insertArguments(collector, 0, testArguments);\n-        collector = collector.asCollector(Object[].class, additionalTypes.size());\n-\n-        Object defaultReturnValue = testValue(type);\n-        MethodHandle defaultCase = simpleTestCase(type, defaultReturnValue);\n-        defaultCase = MethodHandles.collectArguments(defaultCase, 1, collector);\n-        Object[] returnValues = new Object[numCases];\n-        MethodHandle[] cases = new MethodHandle[numCases];\n-        for (int i = 0; i < cases.length; i++) {\n-            Object returnValue = testValue(type);\n-            returnValues[i] = returnValue;\n-            MethodHandle theCase = simpleTestCase(type, returnValue);\n-            theCase = MethodHandles.collectArguments(theCase, 1, collector);\n-            cases[i] = theCase;\n-        }\n-\n-        MethodHandle mhSwitch = MethodHandles.tableSwitch(\n-            defaultCase,\n-            cases\n-        );\n-\n-        for (Class<?> additionalType : additionalTypes) {\n-            testArguments.add(testValue(additionalType));\n-        }\n-\n-        assertEquals(mhSwitch.invokeWithArguments(testArguments(-1, testArguments)), defaultReturnValue);\n-\n-        for (int i = 0; i < numCases; i++) {\n-            assertEquals(mhSwitch.invokeWithArguments(testArguments(i, testArguments)), returnValues[i]);\n-        }\n-\n-        assertEquals(mhSwitch.invokeWithArguments(testArguments(numCases, testArguments)), defaultReturnValue);\n-    }\n-\n-    @Test\n-    public void testVoidHandles() throws Throwable {\n-        IntFunction<MethodHandle> makeTestCase = expectedIndex -> {\n-            IntConsumer test = actualIndex -> assertEquals(actualIndex, expectedIndex);\n-            return MH_IntConsumer_accept.bindTo(test);\n-        };\n-\n-        MethodHandle mhSwitch = MethodHandles.tableSwitch(\n-            \/* default: *\/ makeTestCase.apply(-1),\n-            \/* case 0: *\/  makeTestCase.apply(0),\n-            \/* case 1: *\/  makeTestCase.apply(1),\n-            \/* case 2: *\/  makeTestCase.apply(2)\n-        );\n-\n-        mhSwitch.invokeExact((int) -1);\n-        mhSwitch.invokeExact((int) 0);\n-        mhSwitch.invokeExact((int) 1);\n-        mhSwitch.invokeExact((int) 2);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullDefaultHandle() {\n-        MethodHandles.tableSwitch(null, simpleTestCase(\"test\"));\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullCases() {\n-        MethodHandle[] cases = null;\n-        MethodHandles.tableSwitch(simpleTestCase(\"default\"), cases);\n-    }\n-\n-    @Test(expectedExceptions = NullPointerException.class)\n-    public void testNullCase() {\n-        MethodHandles.tableSwitch(simpleTestCase(\"default\"), simpleTestCase(\"case\"), null);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class,\n-          expectedExceptionsMessageRegExp = \".*Not enough cases.*\")\n-    public void testNotEnoughCases() {\n-        MethodHandles.tableSwitch(simpleTestCase(\"default\"));\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class,\n-          expectedExceptionsMessageRegExp = \".*Case actions must have int as leading parameter.*\")\n-    public void testNotEnoughParameters() {\n-        MethodHandle empty = MethodHandles.empty(MethodType.methodType(void.class));\n-        MethodHandles.tableSwitch(empty, empty, empty);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class,\n-          expectedExceptionsMessageRegExp = \".*Case actions must have int as leading parameter.*\")\n-    public void testNoLeadingIntParameter() {\n-        MethodHandle empty = MethodHandles.empty(MethodType.methodType(void.class, double.class));\n-        MethodHandles.tableSwitch(empty, empty, empty);\n-    }\n-\n-    @Test(expectedExceptions = IllegalArgumentException.class,\n-          expectedExceptionsMessageRegExp = \".*Case actions must have the same type.*\")\n-    public void testWrongCaseType() {\n-        \/\/ doesn't return a String\n-        MethodHandle wrongType = MethodHandles.empty(MethodType.methodType(void.class, int.class));\n-        MethodHandles.tableSwitch(simpleTestCase(\"default\"), simpleTestCase(\"case\"), wrongType);\n-    }\n-\n-}\n","filename":"test\/jdk\/java\/lang\/invoke\/MethodHandles\/TestTableSwitch.java","additions":0,"deletions":234,"binary":false,"changes":234,"status":"deleted"}]}