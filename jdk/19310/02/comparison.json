{"files":[{"patch":"@@ -1626,0 +1626,17 @@\n+  \/\/ Change \"bool eq\/ne (cmp (and (urshift X 4) 1) 0)\" into \"bool ne\/eq (cmp (and X 8) 0)\".\n+  \/\/ Note: rshift gets converted to urshift in AndNode Ideal\n+  if (cmp2_type == TypeInt::ZERO &&\n+      (_test._test == BoolTest::eq || _test._test == BoolTest::ne) &&\n+      cmp1_op == Op_AndI && cmp1->in(1)->Opcode() == Op_URShiftI) {\n+    const TypeInt* shift_val_type = phase->type(cmp1->in(1)->in(2))->isa_int();\n+    const TypeInt* mask_type = phase->type(cmp1->in(2))->isa_int();\n+    if (shift_val_type != nullptr && shift_val_type->is_con() && mask_type != nullptr && mask_type->is_con()) {\n+      jint shift = shift_val_type->get_con();\n+      jint mask = mask_type->get_con();\n+      Node* nmask = phase->intcon(java_shift_left(mask, shift));\n+      Node* new_and = phase->transform(new AndINode(cmp1->in(1)->in(1), nmask));\n+      Node* ncmp = phase->transform(new CmpINode(new_and, cmp2));\n+      return new BoolNode(ncmp, _test._test);\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,180 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+import java.util.Random;\n+import jdk.test.lib.Utils;\n+\n+\/*\n+ * @test\n+ * @bug 8332856\n+ * @summary Test that Ideal transformations of converting eq\/ne (cmp (and (urshift X const1) const2) 0) work as expected\n+ * @library \/test\/lib \/\n+ * @run main compiler.c2.irTests.ConstantShiftAndEqZeroTests\n+ *\/\n+public class ConstantShiftAndEqZeroTests {\n+    private static final Random RANDOM = Utils.getRandomInstance();\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testBitTest(int a) {\n+        return ((a >> 12) & 0b1) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testMaskTest(int a) {\n+        return ((a >> 12) & 0b101) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testLargeShiftBitTest(int a) {\n+        return ((a >> 300) & 0b1) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testLargeShiftMaskTest(int a) {\n+        return ((a >> 300) & 0b101) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean test30ShiftBitTest(int a) {\n+        return ((a >> 30) & 0b1) == 0;\n+    }\n+\n+    \/\/ We expect a RShift here as the shift cannot be converted to a URShiftI without changing behavior\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\", IRNode.RSHIFT_I, \"1\"})\n+    public boolean test30ShiftMaskTest(int a) {\n+        return ((a >> 30) & 0b101) == 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.AND_I, \"1\", IRNode.RSHIFT_I, \"1\"})\n+    public boolean test31ShiftMaskTest(int a) {\n+        return ((a >> 31) & 0b101) == 0;\n+    }\n+\n+    \/\/ The AND can be omitted completly in this case, as only one bit is left after shifting\n+    @Test\n+    @IR(failOn = { IRNode.AND }, counts = {IRNode.URSHIFT_I, \"1\"})\n+    public boolean test31ShiftBitTest(int a) {\n+        return ((a >> 31) & 0b1) == 0;\n+    }\n+\n+    \/\/ Tests with Unsigned shifts\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testUnsignedBitTest(int a) {\n+        return ((a >>> 12) & 0b1) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testUnsignedMaskTest(int a) {\n+        return ((a >>> 12) & 0b101) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testUnsignedLargeShiftBitTest(int a) {\n+        return ((a >>> 300) & 0b1) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testUnsignedLargeShiftMaskTest(int a) {\n+        return ((a >>> 300) & 0b101) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testUnsigned30ShiftBitTest(int a) {\n+        return ((a >>> 30) & 0b1) == 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.RSHIFT, IRNode.URSHIFT }, counts = { IRNode.AND_I, \"1\" })\n+    public boolean testUnsigned30ShiftMaskTest(int a) {\n+        return ((a >>> 30) & 0b101) == 0;\n+    }\n+\n+    \/\/ The AND can be omitted completly in these cases\n+    @Test\n+    @IR(failOn = { IRNode.AND }, counts = { IRNode.URSHIFT_I, \"1\" })\n+    public boolean testUnsigned31ShiftMaskTest(int a) {\n+        return ((a >>> 31) & 0b101) == 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.AND }, counts = {IRNode.URSHIFT_I, \"1\"})\n+    public boolean testUnsigned31ShiftBitTest(int a) {\n+        return ((a >>> 31) & 0b1) == 0;\n+    }\n+\n+    @Run(test = { \"testBitTest\", \"testMaskTest\", \"testLargeShiftBitTest\", \"testLargeShiftMaskTest\", \"test30ShiftBitTest\", \"test30ShiftMaskTest\", \"test31ShiftBitTest\", \"test31ShiftMaskTest\",\n+            \"testUnsignedBitTest\", \"testUnsignedMaskTest\", \"testUnsignedLargeShiftBitTest\", \"testUnsignedLargeShiftMaskTest\", \"testUnsigned30ShiftBitTest\", \"testUnsigned30ShiftMaskTest\", \"testUnsigned31ShiftBitTest\", \"testUnsigned31ShiftMaskTest\"})\n+    public void runTests() {\n+        testConstantShiftAndEqZero(-1);\n+        testConstantShiftAndEqZero(0);\n+        testConstantShiftAndEqZero(1);\n+        testConstantShiftAndEqZero(10);\n+        testConstantShiftAndEqZero(20);\n+        testConstantShiftAndEqZero(0b101 >> 12);\n+        testConstantShiftAndEqZero(Short.MAX_VALUE);\n+        testConstantShiftAndEqZero(Integer.MAX_VALUE);\n+        testConstantShiftAndEqZero(Integer.MIN_VALUE);\n+        testConstantShiftAndEqZero(RANDOM.nextInt());\n+    }\n+\n+    @DontCompile\n+    public void testConstantShiftAndEqZero(int a) {\n+        Asserts.assertEQ(((a >> 12) & 0b1) == 0, testBitTest(a));\n+        Asserts.assertEQ(((a >> 12) & 0b101) == 0, testMaskTest(a));\n+        Asserts.assertEQ(((a >> 300) & 0b1) == 0, testLargeShiftBitTest(a));\n+        Asserts.assertEQ(((a >> 300) & 0b101) == 0, testLargeShiftMaskTest(a));\n+        Asserts.assertEQ(((a >> 30) & 0b1) == 0, test30ShiftBitTest(a));\n+        Asserts.assertEQ(((a >> 30) & 0b101) == 0, test30ShiftMaskTest(a));\n+        Asserts.assertEQ(((a >> 31) & 0b1) == 0, test31ShiftBitTest(a));\n+        Asserts.assertEQ(((a >> 31) & 0b101) == 0, test31ShiftMaskTest(a));\n+        Asserts.assertEQ(((a >>> 12) & 0b1) == 0, testUnsignedBitTest(a));\n+        Asserts.assertEQ(((a >>> 12) & 0b101) == 0, testUnsignedMaskTest(a));\n+        Asserts.assertEQ(((a >>> 300) & 0b1) == 0, testUnsignedLargeShiftBitTest(a));\n+        Asserts.assertEQ(((a >>> 300) & 0b101) == 0, testUnsignedLargeShiftMaskTest(a));\n+        Asserts.assertEQ(((a >>> 30) & 0b1) == 0, testUnsigned30ShiftBitTest(a));\n+        Asserts.assertEQ(((a >>> 30) & 0b101) == 0, testUnsigned30ShiftMaskTest(a));\n+        Asserts.assertEQ(((a >>> 31) & 0b1) == 0, testUnsigned31ShiftBitTest(a));\n+        Asserts.assertEQ(((a >>> 31) & 0b101) == 0, testUnsigned31ShiftMaskTest(a));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/ConstantShiftAndEqZeroTests.java","additions":180,"deletions":0,"binary":false,"changes":180,"status":"added"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.vm.compiler;\n+\n+import org.openjdk.jmh.annotations.*;\n+import org.openjdk.jmh.infra.Blackhole;\n+\n+import java.util.Random;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Fork(value = 3)\n+@State(Scope.Thread)\n+public class ShiftAndCmpZeroIdeal {\n+    int[] values;\n+\n+    @Setup\n+    public void setup() {\n+        values = new int[128];\n+        Random random = new Random(42);\n+        for (int i = 0; i < values.length; i++) {\n+            values[i] = random.nextInt();\n+        }\n+    }\n+\n+    @Benchmark\n+    public void testConstantShiftMask(Blackhole blackhole) {\n+        for (int value : values) {\n+            int shifted = value >> 8;\n+            int masked = shifted & 0xFF;\n+            blackhole.consume(masked == 0);\n+        }\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/ShiftAndCmpZeroIdeal.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"}]}