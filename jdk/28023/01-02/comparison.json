{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,7 @@\n+import java.lang.reflect.Proxy;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -26,3 +33,3 @@\n- * @bug 8333854\n- * @summary Test invoking a method in a proxy interface with package-private\n- *          classes or interfaces in its method type\n+ * @bug 8333854 8370839\n+ * @summary Behavior of methods whose signature has package-private\n+ *          class or interfaces but the proxy interface is public\n@@ -31,0 +38,2 @@\n+public class NonPublicMethodTypeTest {\n+    enum Internal { INSTANCE }\n@@ -32,5 +41,3 @@\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.reflect.Proxy;\n-\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+    public interface InternalParameter {\n+        void call(Internal parameter);\n+    }\n@@ -38,3 +45,13 @@\n-public final class NonPublicMethodTypeTest {\n-    interface NonPublicWorker {\n-        void work();\n+    @Test\n+    void testNonPublicParameter() throws Throwable {\n+        \/\/ Creation should be successful\n+        InternalParameter instance = (InternalParameter) Proxy.newProxyInstance(\n+                InternalParameter.class.getClassLoader(),\n+                new Class[] { InternalParameter.class },\n+                (_, _, _) -> null);\n+        assertNotSame(Internal.class.getPackage(),\n+                instance.getClass().getPackage(),\n+                \"Proxy class should not be able to access method parameter \" +\n+                        \"Internal class's package\");\n+        instance.call(null);\n+        instance.call(Internal.INSTANCE);\n@@ -43,2 +60,2 @@\n-    public interface PublicWorkable {\n-        void accept(NonPublicWorker worker);\n+    public interface InternalReturn {\n+        Internal call();\n@@ -48,7 +65,9 @@\n-    public void test() {\n-        PublicWorkable proxy = (PublicWorkable) Proxy.newProxyInstance(\n-               NonPublicMethodTypeTest.class.getClassLoader(),\n-               new Class[] {PublicWorkable.class},\n-               (_, _, _) -> null);\n-        assertNotSame(NonPublicWorker.class.getPackage(),\n-                proxy.getClass().getPackage(),\n+    void testNonPublicReturn() throws Throwable {\n+        AtomicReference<Internal> returnValue = new AtomicReference<>();\n+        \/\/ Creation should be successful\n+        InternalReturn instance = (InternalReturn) Proxy.newProxyInstance(\n+                InternalReturn.class.getClassLoader(),\n+                new Class[] { InternalReturn.class },\n+                (_, _, _) -> returnValue.get());\n+        assertNotSame(Internal.class.getPackage(),\n+                instance.getClass().getPackage(),\n@@ -56,2 +75,16 @@\n-                        \"NonPublic type's package\");\n-        proxy.accept(() -> {}); \/\/ Call should not fail\n+                        \"Internal class's package\");\n+\n+        \/\/ The generated call() implementation is as follows:\n+        \/\/ aload0, getfield Proxy.h, aload 0, getstatic (Method), aconst_null,\n+        \/\/ invokevirtual InvocationHandler::invoke(Object, Method, Object[])Object,\n+        \/\/ checkcast Internal.class, areturn\n+        \/\/ In this bytecode, checkcast Internal.class will fail with a\n+        \/\/ IllegalAccessError as a result of resolution of Internal.class\n+        \/\/ if and only if the incoming reference is non-null.\n+\n+        \/\/ checkcast does not perform access check for null\n+        returnValue.set(null);\n+        instance.call();\n+        \/\/ checkcast fails - proxy class cannot access the return type\n+        returnValue.set(Internal.INSTANCE);\n+        assertThrows(IllegalAccessError.class, instance::call);\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":56,"deletions":23,"binary":false,"changes":79,"status":"modified"},{"patch":"@@ -1,75 +0,0 @@\n-\/*\n- * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-import java.lang.reflect.Proxy;\n-import java.util.concurrent.atomic.AtomicReference;\n-\n-import org.junit.jupiter.api.Test;\n-\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-\/*\n- * @test\n- * @bug 8370839\n- * @summary Behavior of methods whose signature has package-private\n- *          class or interfaces but the proxy interface is public\n- * @run junit NonPublicSignaturesTest\n- *\/\n-public class NonPublicSignaturesTest {\n-    enum Internal { INSTANCE }\n-\n-    public interface InternalParameter {\n-        void call(Internal parameter);\n-    }\n-\n-    @Test\n-    void testNonPublicParameter() throws Throwable {\n-        \/\/ Creation should be successful\n-        InternalParameter instance = (InternalParameter) Proxy.newProxyInstance(\n-                InternalParameter.class.getClassLoader(),\n-                new Class[] { InternalParameter.class },\n-                (_, _, _) -> null);\n-        instance.call(null);\n-        instance.call(Internal.INSTANCE);\n-    }\n-\n-    public interface InternalReturn {\n-        Internal call();\n-    }\n-\n-    @Test\n-    void testNonPublicReturn() throws Throwable {\n-        AtomicReference<Internal> returnValue = new AtomicReference<>();\n-        \/\/ Creation should be successful\n-        InternalReturn instance = (InternalReturn) Proxy.newProxyInstance(\n-                InternalReturn.class.getClassLoader(),\n-                new Class[] { InternalReturn.class },\n-                (_, _, _) -> returnValue.get());\n-        \/\/ checkcast does not perform access check for null\n-        returnValue.set(null);\n-        instance.call();\n-        \/\/ checkcast fails - proxy class cannot access the return type\n-        returnValue.set(Internal.INSTANCE);\n-        assertThrows(IllegalAccessError.class, instance::call);\n-    }\n-}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicSignaturesTest.java","additions":0,"deletions":75,"binary":false,"changes":75,"status":"deleted"}]}