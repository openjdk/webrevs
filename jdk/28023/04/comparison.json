{"files":[{"patch":"@@ -0,0 +1,86 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.UndeclaredThrowableException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.function.Consumer;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8370839\n+ * @summary Behavior of bridge methods in interfaces\n+ * @run junit BridgeMethodsTest\n+ *\/\n+public class BridgeMethodsTest {\n+\n+    interface StringCallable extends Callable<String> {\n+        @Override\n+        String call(); \/\/ throws no exception\n+    }\n+\n+    @Test\n+    void testExceptionTypes() throws Throwable {\n+        class MyException extends Exception {}\n+        \/\/ This proxy has two distinct methods, even though the\n+        \/\/ Java language would treat the first one as overridden:\n+        \/\/ Object call() throws Exception;  - from Callable\n+        \/\/ String call();                   - from StringCallable\n+        var instance = Proxy.newProxyInstance(StringCallable.class.getClassLoader(),\n+                new Class[] { StringCallable.class }, (_, _, _) -> { throw new MyException(); });\n+        \/\/ The exception can't be thrown through StringCallable.call which has no throws\n+        var undeclared = assertThrows(UndeclaredThrowableException.class, () -> ((StringCallable) instance).call());\n+        assertInstanceOf(MyException.class, undeclared.getCause());\n+        \/\/ But it can be thrown through Callable.call which permits Exception\n+        assertThrows(MyException.class, () -> ((Callable<?>) instance).call());\n+    }\n+\n+    interface SpecificConsumer extends Consumer<String> {\n+        @Override\n+        void accept(String s);\n+    }\n+\n+    @Test\n+    @SuppressWarnings(\"unchecked\")\n+    void testMethodObjects() throws Throwable {\n+        List<Method> methods = new ArrayList<>();\n+        \/\/ This proxy has two distinct methods, even though the\n+        \/\/ Java language would treat the first one as overridden:\n+        \/\/ void accept(Object);    - from Consumer\n+        \/\/ void accept(String);    - from SpecificConsumer\n+        var instance = Proxy.newProxyInstance(SpecificConsumer.class.getClassLoader(),\n+                new Class[] { SpecificConsumer.class }, (_, m, _) -> methods.add(m));\n+        ((Consumer<Object>) instance).accept(null);\n+        ((SpecificConsumer) instance).accept(null);\n+        assertEquals(2, methods.size());\n+        \/\/ invocation handler gets different method due to covariant parameter types\n+        assertNotEquals(methods.getFirst(), methods.getLast());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/BridgeMethodsTest.java","additions":86,"deletions":0,"binary":false,"changes":86,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -24,0 +24,7 @@\n+import java.lang.reflect.Proxy;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n@@ -26,3 +33,3 @@\n- * @bug 8333854\n- * @summary Test invoking a method in a proxy interface with package-private\n- *          classes or interfaces in its method type\n+ * @bug 8333854 8370839\n+ * @summary Behavior of methods whose signature has package-private\n+ *          class or interfaces but the proxy interface is public\n@@ -31,0 +38,10 @@\n+public class NonPublicMethodTypeTest {\n+    \/\/ Java language and JVM allow using fields and methods with inaccessible\n+    \/\/ classes or interfaces in its signature, as long as the field or method\n+    \/\/ is accessible and its declaring class or interface is accessible.\n+    \/\/ Such inaccessible classes and interfaces are treated as if an arbitrary\n+    \/\/ subtype of their accessible types, or an arbitrary supertype of their\n+    \/\/ accessible subtypes.\n+    \/\/ java.lang.invoke is stricter - MethodType constant pool entry resolution\n+    \/\/ for such signatures fail, so they can't be used for MethodHandle or indy.\n+    enum Internal { INSTANCE }\n@@ -32,5 +49,3 @@\n-import org.junit.jupiter.api.Test;\n-\n-import java.lang.reflect.Proxy;\n-\n-import static org.junit.jupiter.api.Assertions.assertNotSame;\n+    public interface InternalParameter {\n+        void call(Internal parameter);\n+    }\n@@ -38,3 +53,15 @@\n-public final class NonPublicMethodTypeTest {\n-    interface NonPublicWorker {\n-        void work();\n+    @Test\n+    void testNonPublicParameter() throws Throwable {\n+        \/\/ Creation should be successful\n+        \/\/ 8333854 - BSM usage fails for looking up such methods\n+        InternalParameter instance = (InternalParameter) Proxy.newProxyInstance(\n+                InternalParameter.class.getClassLoader(),\n+                new Class[] { InternalParameter.class },\n+                (_, _, _) -> null);\n+        assertNotSame(Internal.class.getPackage(),\n+                instance.getClass().getPackage(),\n+                \"Proxy class should not be able to access method parameter \" +\n+                        \"Internal class's package\");\n+        \/\/ Calls should be always successful\n+        instance.call(null);\n+        instance.call(Internal.INSTANCE);\n@@ -43,2 +70,2 @@\n-    public interface PublicWorkable {\n-        void accept(NonPublicWorker worker);\n+    public interface InternalReturn {\n+        Internal call();\n@@ -48,7 +75,12 @@\n-    public void test() {\n-        PublicWorkable proxy = (PublicWorkable) Proxy.newProxyInstance(\n-               NonPublicMethodTypeTest.class.getClassLoader(),\n-               new Class[] {PublicWorkable.class},\n-               (_, _, _) -> null);\n-        assertNotSame(NonPublicWorker.class.getPackage(),\n-                proxy.getClass().getPackage(),\n+    void testNonPublicReturn() throws Throwable {\n+        AtomicReference<Internal> returnValue = new AtomicReference<>();\n+        \/\/ Creation should be successful\n+        \/\/ A lot of annotation interfaces are implemented by such proxy classes,\n+        \/\/ due to presence of package-private annotation interface or enum-typed\n+        \/\/ elements in public annotation interfaces.\n+        InternalReturn instance = (InternalReturn) Proxy.newProxyInstance(\n+                InternalReturn.class.getClassLoader(),\n+                new Class[] { InternalReturn.class },\n+                (_, _, _) -> returnValue.get());\n+        assertNotSame(Internal.class.getPackage(),\n+                instance.getClass().getPackage(),\n@@ -56,2 +88,17 @@\n-                        \"NonPublic type's package\");\n-        proxy.accept(() -> {}); \/\/ Call should not fail\n+                        \"Internal class's package\");\n+\n+        \/\/ The generated call() implementation is as follows:\n+        \/\/ aload0, getfield Proxy.h, aload 0, getstatic (Method), aconst_null,\n+        \/\/ invokevirtual InvocationHandler::invoke(Object, Method, Object[])Object,\n+        \/\/ checkcast Internal.class, areturn\n+        \/\/ In this bytecode, checkcast Internal.class will fail with a\n+        \/\/ IllegalAccessError as a result of resolution of Internal.class\n+        \/\/ if and only if the incoming reference is non-null.\n+\n+        \/\/ checkcast does not perform access check for null\n+        returnValue.set(null);\n+        instance.call();\n+        \/\/ checkcast fails - proxy class cannot access the return type\n+        \/\/ See JDK-8349716\n+        returnValue.set(Internal.INSTANCE);\n+        assertThrows(IllegalAccessError.class, instance::call);\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":70,"deletions":23,"binary":false,"changes":93,"status":"modified"},{"patch":"@@ -0,0 +1,190 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.invoke.MethodHandle;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.lang.reflect.Proxy;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import org.junit.jupiter.api.Test;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+\/*\n+ * @test\n+ * @bug 8370839\n+ * @summary Behavior of protected methods in java.lang.Object\n+ * @modules java.base\/java.lang:+open\n+ * @run junit ProtectedObjectMethodsTest\n+ *\/\n+public class ProtectedObjectMethodsTest {\n+\n+    static final MethodHandle OBJECT_CLONE;\n+    static final MethodHandle OBJECT_FINALIZE;\n+\n+    static {\n+        try {\n+            var lookup = MethodHandles.privateLookupIn(Object.class, MethodHandles.lookup());\n+            OBJECT_CLONE = lookup.findVirtual(Object.class, \"clone\", MethodType.methodType(Object.class));\n+            OBJECT_FINALIZE = lookup.findVirtual(Object.class, \"finalize\", MethodType.methodType(void.class));\n+        } catch (ReflectiveOperationException ex) {\n+            throw new ExceptionInInitializerError(ex);\n+        }\n+    }\n+\n+    interface FakeClone {\n+        \/\/ This method is not related to Object::clone in the JVM, but most\n+        \/\/ implementations in the Java Language override Object::clone as\n+        \/\/ covariant overrides\n+        FakeClone clone();\n+    }\n+\n+    interface TrueClone {\n+        \/\/ This method is identical to Object::clone in the JVM, that calls\n+        \/\/ to Object::clone can always call an implementation of this method\n+        \/\/ if it exists\n+        Object clone();\n+    }\n+\n+    interface PrimitiveClone {\n+        \/\/ This method is not related to Object::clone in the JVM, but it can't\n+        \/\/ be implemented in the Java Language unless using a lambda expression,\n+        \/\/ due to the Java language covariant override restrictions.\n+        int clone();\n+    }\n+\n+    \/\/ Does not duplicate with Object::clone so it is not proxied\n+    @Test\n+    void testDistinctClone() throws Throwable {\n+        {\n+            \/\/ This proxy declares FakeClone clone(); which cannot be\n+            \/\/ invoked through Object::clone.\n+            var fake = (FakeClone) Proxy.newProxyInstance(FakeClone.class.getClassLoader(), new Class[] { FakeClone.class }, (p, _, _) -> p);\n+            assertSame(fake, fake.clone());\n+            \/\/ Verify the default Object::clone behavior (this is not Cloneable)\n+            assertThrows(CloneNotSupportedException.class, () -> {\n+                var _ = (Object) OBJECT_CLONE.invoke((Object) fake);\n+            });\n+        }\n+\n+        {\n+            \/\/ This proxy declares FakeClone clone(); which cannot be\n+            \/\/ invoked through Object::clone.\n+            var fake = (FakeClone) Proxy.newProxyInstance(FakeClone.class.getClassLoader(), new Class[] { FakeClone.class, Cloneable.class }, (p, _, _) -> p);\n+            assertSame(fake, fake.clone());\n+            \/\/ Verify the default Object::clone behavior (this is Cloneable)\n+            var fakeClone = (Object) OBJECT_CLONE.invoke((Object) fake);\n+            assertNotSame(fake, fakeClone);\n+            assertSame(fake.getClass(), fakeClone.getClass());\n+            assertSame(fakeClone, ((FakeClone) fakeClone).clone());\n+        }\n+\n+        {\n+            \/\/ This proxy declares int clone(); which cannot be\n+            \/\/ invoked through Object::clone.\n+            var instance = (PrimitiveClone) Proxy.newProxyInstance(PrimitiveClone.class.getClassLoader(), new Class[] { PrimitiveClone.class }, (_, _, _) -> 42);\n+            assertEquals(42, instance.clone());\n+            \/\/ Verify the default Object::clone behavior (this is not Cloneable)\n+            assertThrows(CloneNotSupportedException.class, () -> {\n+                var _ = (Object) OBJECT_CLONE.invoke((Object) instance);\n+            });\n+        }\n+\n+        {\n+            \/\/ This proxy declares int clone(); which cannot be\n+            \/\/ invoked through Object::clone\n+            var instance = (PrimitiveClone) Proxy.newProxyInstance(PrimitiveClone.class.getClassLoader(), new Class[] { PrimitiveClone.class, Cloneable.class }, (_, _, _) -> 76);\n+            assertEquals(76, instance.clone());\n+            \/\/ Verify the default Object::clone behavior (this is Cloneable)\n+            var clone = (Object) OBJECT_CLONE.invoke((Object) instance);\n+            assertNotSame(instance, clone);\n+            assertSame(instance.getClass(), clone.getClass());\n+            assertEquals(76, ((PrimitiveClone) clone).clone());\n+        }\n+    }\n+\n+    \/\/ Duplicates with Object::clone so it is proxied\n+    @Test\n+    void testDuplicateClone() throws Throwable {\n+        {\n+            \/\/ This proxy declares Object clone();, which\n+            \/\/ accidentally overrides Object::clone\n+            var instance = (TrueClone) Proxy.newProxyInstance(TrueClone.class.getClassLoader(), new Class[] { TrueClone.class }, (p, _, _) -> p);\n+            assertSame(instance, instance.clone());\n+            \/\/ Verify Object::clone is overridden\n+            assertSame(instance, (Object) OBJECT_CLONE.invoke((Object) instance));\n+        }\n+\n+        {\n+            \/\/ This proxy declares Object clone(); and FakeClone clone();.\n+            \/\/ They are considered duplicate methods and dispatched equivalently.\n+            \/\/ Object clone() accidentally overrides Object::clone, so now\n+            \/\/ FakeClone clone() can be called through Object::clone\n+            var instance = Proxy.newProxyInstance(TrueClone.class.getClassLoader(), new Class[] { TrueClone.class, FakeClone.class }, (p, _, _) -> p);\n+            assertSame(instance, ((FakeClone) instance).clone());\n+            assertSame(instance, ((TrueClone) instance).clone());\n+            \/\/ Verify Object::clone is overridden\n+            assertSame(instance, (Object) OBJECT_CLONE.invoke((Object) instance));\n+        }\n+    }\n+\n+    interface FalseFinalize {\n+        \/\/ This method is not related to Object::finalize in the JVM, but it can't\n+        \/\/ be implemented in the Java Language unless using a lambda expression,\n+        \/\/ due to the Java language covariant override restrictions.\n+        int finalize();\n+    }\n+\n+    interface TrueFinalize {\n+        \/\/ This method is identical to Object::finalize in the JVM, that calls\n+        \/\/ to Object::finalize can always call an implementation of this method\n+        \/\/ if it exists\n+        void finalize();\n+    }\n+\n+    @Test\n+    void testDistinctFinalize() throws Throwable {\n+        AtomicInteger invokeCount = new AtomicInteger();\n+        \/\/ This proxy declares int finalize(), which cannot be\n+        \/\/ invoked through Object::finalize.\n+        var instance = Proxy.newProxyInstance(FalseFinalize.class.getClassLoader(), new Class[] { FalseFinalize.class }, (_, _, _) -> invokeCount.incrementAndGet());\n+        \/\/ Verify the default Object::finalize behavior\n+        OBJECT_FINALIZE.invoke(instance);\n+        assertEquals(0, invokeCount.get());\n+        assertEquals(1, ((FalseFinalize) instance).finalize());\n+    }\n+\n+    @Test\n+    void testDuplicateFinalize() throws Throwable {\n+        AtomicInteger invokeCount = new AtomicInteger();\n+        \/\/ This proxy declares void finalize(), which can be\n+        \/\/ invoked through Object::finalize.\n+        var instance = Proxy.newProxyInstance(TrueFinalize.class.getClassLoader(), new Class[] { TrueFinalize.class }, (_, _, _) -> invokeCount.incrementAndGet());\n+        \/\/ Verify the overridden Object::finalize behavior\n+        OBJECT_FINALIZE.invoke(instance);\n+        assertEquals(1, invokeCount.get());\n+        ((TrueFinalize) instance).finalize();\n+        assertEquals(2, invokeCount.get());\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProtectedObjectMethodsTest.java","additions":190,"deletions":0,"binary":false,"changes":190,"status":"added"}]}