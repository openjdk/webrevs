{"files":[{"patch":"@@ -52,0 +52,4 @@\n+        \/\/ This proxy has two distinct methods, even though the\n+        \/\/ Java language would treat the first one as overridden:\n+        \/\/ Object call() throws Exception;  - from Callable\n+        \/\/ String call();                   - from StringCallable\n@@ -70,0 +74,4 @@\n+        \/\/ This proxy has two distinct methods, even though the\n+        \/\/ Java language would treat the first one as overridden:\n+        \/\/ void accept(Object);    - from Consumer\n+        \/\/ void accept(String);    - from SpecificConsumer\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/BridgeMethodsTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,0 +39,8 @@\n+    \/\/ Java language and JVM allow using fields and methods with inaccessible\n+    \/\/ classes or interfaces in its signature, as long as the field or method\n+    \/\/ is accessible and its declaring class or interface is accessible.\n+    \/\/ Such inaccessible classes and interfaces are treated as if an arbitrary\n+    \/\/ subtype of their accessible types, or an arbitrary supertype of their\n+    \/\/ accessible subtypes.\n+    \/\/ java.lang.invoke is stricter - MethodType constant pool entry resolution\n+    \/\/ for such signatures fail, so they can't be used for MethodHandle or indy.\n@@ -48,0 +56,1 @@\n+        \/\/ 8333854 - BSM usage fails for looking up such methods\n@@ -56,0 +65,1 @@\n+        \/\/ Calls should be always successful\n@@ -68,0 +78,3 @@\n+        \/\/ A lot of annotation interfaces are implemented by such proxy classes,\n+        \/\/ due to presence of package-private annotation interface or enum-typed\n+        \/\/ elements in public annotation interfaces.\n@@ -89,0 +102,1 @@\n+        \/\/ See JDK-8349716\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/NonPublicMethodTypeTest.java","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -57,0 +57,3 @@\n+        \/\/ This method is not related to Object::clone in the JVM, but most\n+        \/\/ implementations in the Java Language override Object::clone as\n+        \/\/ covariant overrides\n@@ -61,0 +64,3 @@\n+        \/\/ This method is identical to Object::clone in the JVM, that calls\n+        \/\/ to Object::clone can always call an implementation of this method\n+        \/\/ if it exists\n@@ -65,0 +71,3 @@\n+        \/\/ This method is not related to Object::clone in the JVM, but it can't\n+        \/\/ be implemented in the Java Language unless using a lambda expression,\n+        \/\/ due to the Java language covariant override restrictions.\n@@ -72,0 +81,2 @@\n+            \/\/ This proxy declares FakeClone clone(); which cannot be\n+            \/\/ invoked through Object::clone.\n@@ -74,0 +85,1 @@\n+            \/\/ Verify the default Object::clone behavior (this is not Cloneable)\n@@ -80,0 +92,2 @@\n+            \/\/ This proxy declares FakeClone clone(); which cannot be\n+            \/\/ invoked through Object::clone.\n@@ -82,0 +96,1 @@\n+            \/\/ Verify the default Object::clone behavior (this is Cloneable)\n@@ -89,0 +104,2 @@\n+            \/\/ This proxy declares int clone(); which cannot be\n+            \/\/ invoked through Object::clone.\n@@ -91,0 +108,1 @@\n+            \/\/ Verify the default Object::clone behavior (this is not Cloneable)\n@@ -97,0 +115,2 @@\n+            \/\/ This proxy declares int clone(); which cannot be\n+            \/\/ invoked through Object::clone\n@@ -99,0 +119,1 @@\n+            \/\/ Verify the default Object::clone behavior (this is Cloneable)\n@@ -110,1 +131,2 @@\n-            \/\/ TrueClone::clone accidentally overrides Object::clone\n+            \/\/ This proxy declares Object clone();, which\n+            \/\/ accidentally overrides Object::clone\n@@ -113,0 +135,1 @@\n+            \/\/ Verify Object::clone is overridden\n@@ -117,1 +140,4 @@\n-            \/\/ Use the TrueClone to bridge Object::clone and FakeClone::clone\n+            \/\/ This proxy declares Object clone(); and FakeClone clone();.\n+            \/\/ They are considered duplicate methods and dispatched equivalently.\n+            \/\/ Object clone() accidentally overrides Object::clone, so now\n+            \/\/ FakeClone clone() can be called through Object::clone\n@@ -121,0 +147,1 @@\n+            \/\/ Verify Object::clone is overridden\n@@ -126,0 +153,3 @@\n+        \/\/ This method is not related to Object::finalize in the JVM, but it can't\n+        \/\/ be implemented in the Java Language unless using a lambda expression,\n+        \/\/ due to the Java language covariant override restrictions.\n@@ -130,0 +160,3 @@\n+        \/\/ This method is identical to Object::finalize in the JVM, that calls\n+        \/\/ to Object::finalize can always call an implementation of this method\n+        \/\/ if it exists\n@@ -136,0 +169,2 @@\n+        \/\/ This proxy declares int finalize(), which cannot be\n+        \/\/ invoked through Object::finalize.\n@@ -137,0 +172,1 @@\n+        \/\/ Verify the default Object::finalize behavior\n@@ -145,0 +181,2 @@\n+        \/\/ This proxy declares void finalize(), which can be\n+        \/\/ invoked through Object::finalize.\n@@ -146,0 +184,1 @@\n+        \/\/ Verify the overridden Object::finalize behavior\n","filename":"test\/jdk\/java\/lang\/reflect\/Proxy\/ProtectedObjectMethodsTest.java","additions":41,"deletions":2,"binary":false,"changes":43,"status":"modified"}]}