{"files":[{"patch":"@@ -27,1 +27,0 @@\n-#include \"code\/nmethod.hpp\"\n@@ -233,0 +232,11 @@\n+class ShenandoahFlushSATB : public ThreadClosure {\n+private:\n+  SATBMarkQueueSet& _satb_qset;\n+\n+public:\n+  explicit ShenandoahFlushSATB(SATBMarkQueueSet& satb_qset) : _satb_qset(satb_qset) {}\n+\n+  inline void do_thread(Thread* thread) override;\n+};\n+\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.hpp","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -256,0 +256,4 @@\n+inline void ShenandoahFlushSATB::do_thread(Thread* thread) {\n+  \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n+  _satb_qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahClosures.inline.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -282,15 +282,0 @@\n-  if (!heap->is_concurrent_old_mark_in_progress()) {\n-    heap->concurrent_final_roots();\n-  } else {\n-    \/\/ Since the cycle was shortened for having enough immediate garbage, this will be\n-    \/\/ the last phase before concurrent marking of old resumes. We must be sure\n-    \/\/ that old mark threads don't see any pointers to garbage in the SATB queues. Even\n-    \/\/ though nothing was evacuated, overwriting unreachable weak roots with null may still\n-    \/\/ put pointers to regions that become trash in the SATB queues. The following will\n-    \/\/ piggyback flushing the thread local SATB queues on the same handshake that propagates\n-    \/\/ the gc state change.\n-    ShenandoahSATBMarkQueueSet& satb_queues = ShenandoahBarrierSet::satb_mark_queue_set();\n-    ShenandoahFlushSATBHandshakeClosure complete_thread_local_satb_buffers(satb_queues);\n-    heap->concurrent_final_roots(&complete_thread_local_satb_buffers);\n-    heap->old_generation()->concurrent_transfer_pointers_from_satb();\n-  }\n@@ -687,1 +672,0 @@\n-\n@@ -690,6 +674,0 @@\n-    } else if (heap->is_concurrent_old_mark_in_progress()) {\n-      \/\/ Purge the SATB buffers, transferring any valid, old pointers to the\n-      \/\/ old generation mark queue. Any pointers in a young region will be\n-      \/\/ abandoned.\n-      ShenandoahGCPhase phase(ShenandoahPhaseTimings::init_transfer_satb);\n-      heap->old_generation()->transfer_pointers_from_satb();\n@@ -697,0 +675,1 @@\n+\n@@ -1134,1 +1113,1 @@\n-  void do_thread(Thread* thread);\n+  void do_thread(Thread* thread) override;\n@@ -1149,0 +1128,34 @@\n+class ShenandoahUpdateThreadRootsAndFlushOldSatbBuffers final : public HandshakeClosure {\n+  \/\/ When Shenandoah is marking the old generation, it is possible for the SATB barrier\n+  \/\/ to pick up overwritten pointers that point into a cset region. If these pointers\n+  \/\/ are accessed by mark threads, they will crash. Once update refs has completed, it is\n+  \/\/ no longer possible for a mutator thread to overwrite a pointer into a cset region.\n+  \/\/\n+  \/\/ Therefore, at the end of update refs, we use this closure to update the thread roots\n+  \/\/ and 'complete' all the thread local SATB buffers. Completing these will filter out\n+  \/\/ anything that has already been marked or anything that points to a region which is\n+  \/\/ not old. We do not need to worry about ABA situations where a region may become old\n+  \/\/ after the pointer is enqueued but before it is filtered. There are only two ways a\n+  \/\/ region may become old:\n+  \/\/  1. The region is promoted in place. This is safe because such regions will never\n+  \/\/     be in the collection set. If this happens, the pointer will be preserved, essentially\n+  \/\/     becoming part of the old snapshot.\n+  \/\/  2. The region is allocated during evacuation of old. This is also not a concern because\n+  \/\/     we haven't yet finished marking old so no mixed evacuations will happen.\n+  ShenandoahUpdateThreadHandshakeClosure _update_roots;\n+  ShenandoahFlushSATB _flush_all_satb;\n+\n+public:\n+  ShenandoahUpdateThreadRootsAndFlushOldSatbBuffers() :\n+    HandshakeClosure(\"Shenandoah Update Thread Roots and Flush SATB\"),\n+    _flush_all_satb(ShenandoahBarrierSet::satb_mark_queue_set()) {\n+    assert(ShenandoahBarrierSet::satb_mark_queue_set().get_filter_out_young(),\n+           \"Should be filtering pointers outside of old during old marking\");\n+  }\n+\n+  void do_thread(Thread* thread) override {\n+    _update_roots.do_thread(thread);\n+    _flush_all_satb.do_thread(thread);\n+  }\n+};\n+\n@@ -1150,2 +1163,8 @@\n-  ShenandoahUpdateThreadHandshakeClosure cl;\n-  Handshake::execute(&cl);\n+  ShenandoahHeap* const heap = ShenandoahHeap::heap();\n+  if (heap->is_concurrent_old_mark_in_progress()) {\n+    ShenandoahUpdateThreadRootsAndFlushOldSatbBuffers cl;\n+    Handshake::execute(&cl);\n+  } else {\n+    ShenandoahUpdateThreadHandshakeClosure cl;\n+    Handshake::execute(&cl);\n+  }\n@@ -1180,17 +1199,0 @@\n-    \/\/ When the SATB barrier is left on to support concurrent old gen mark, it may pick up writes to\n-    \/\/ objects in the collection set. After those objects are evacuated, the pointers in the\n-    \/\/ SATB are no longer safe. Once we have finished update references, we are guaranteed that\n-    \/\/ no more writes to the collection set are possible.\n-    \/\/\n-    \/\/ This will transfer any old pointers in _active_ regions from the SATB to the old gen\n-    \/\/ mark queues. All other pointers will be discarded. This would also discard any pointers\n-    \/\/ in old regions that were included in a mixed evacuation. We aren't using the SATB filter\n-    \/\/ methods here because we cannot control when they execute. If the SATB filter runs _after_\n-    \/\/ a region has been recycled, we will not be able to detect the bad pointer.\n-    \/\/\n-    \/\/ We are not concerned about skipping this step in abbreviated cycles because regions\n-    \/\/ with no live objects cannot have been written to and so cannot have entries in the SATB\n-    \/\/ buffers.\n-    ShenandoahGCPhase phase(ShenandoahPhaseTimings::final_update_refs_transfer_satb);\n-    heap->old_generation()->transfer_pointers_from_satb();\n-\n@@ -1231,3 +1233,1 @@\n-  if (!heap->mode()->is_generational()) {\n-    heap->concurrent_final_roots();\n-  } else {\n+  if (heap->mode()->is_generational()) {\n@@ -1238,0 +1238,2 @@\n+\n+  heap->concurrent_final_roots();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":47,"deletions":45,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -69,14 +69,0 @@\n-class ShenandoahSATBAndRemarkThreadsClosure : public ThreadClosure {\n-private:\n-  SATBMarkQueueSet& _satb_qset;\n-\n-public:\n-  explicit ShenandoahSATBAndRemarkThreadsClosure(SATBMarkQueueSet& satb_qset) :\n-    _satb_qset(satb_qset) {}\n-\n-  void do_thread(Thread* thread) override {\n-    \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n-    _satb_qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n-  }\n-};\n-\n@@ -112,1 +98,1 @@\n-      ShenandoahSATBAndRemarkThreadsClosure tc(satb_mq_set);\n+      ShenandoahFlushSATB tc(satb_mq_set);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":1,"deletions":15,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -163,9 +163,0 @@\n-        if (heap->is_concurrent_mark_in_progress()) {\n-          \/\/ If either old or young marking is in progress, the SATB barrier will be enabled.\n-          \/\/ The SATB buffer may hold a mix of old and young pointers. The old pointers need to be\n-          \/\/ transferred to the old generation mark queues and the young pointers are NOT part\n-          \/\/ of this snapshot, so they must be dropped here. It is safe to drop them here because\n-          \/\/ we will rescan the roots on this safepoint.\n-          heap->old_generation()->transfer_pointers_from_satb();\n-        }\n-\n@@ -190,2 +181,3 @@\n-      if (_degen_point == ShenandoahDegenPoint::_degenerated_mark &&\n-          heap->is_concurrent_mark_in_progress()) {\n+      if (_degen_point == ShenandoahDegenPoint::_degenerated_mark && heap->is_concurrent_mark_in_progress()) {\n+        assert(!ShenandoahBarrierSet::satb_mark_queue_set().get_filter_out_young(),\n+               \"Should not be filtering out young pointers when concurrent mark degenerates\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":3,"deletions":11,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2083,0 +2083,4 @@\n+    \/\/ If we are only marking old, we do not need to process young pointers\n+    ShenandoahBarrierSet::satb_mark_queue_set().set_filter_out_young(\n+      is_concurrent_old_mark_in_progress() && !is_concurrent_young_mark_in_progress()\n+    );\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,46 +46,0 @@\n-class ShenandoahFlushAllSATB : public ThreadClosure {\n-private:\n-  SATBMarkQueueSet& _satb_qset;\n-\n-public:\n-  explicit ShenandoahFlushAllSATB(SATBMarkQueueSet& satb_qset) :\n-    _satb_qset(satb_qset) {}\n-\n-  void do_thread(Thread* thread) override {\n-    \/\/ Transfer any partial buffer to the qset for completed buffer processing.\n-    _satb_qset.flush_queue(ShenandoahThreadLocalData::satb_mark_queue(thread));\n-  }\n-};\n-\n-class ShenandoahProcessOldSATB : public SATBBufferClosure {\n-private:\n-  ShenandoahObjToScanQueue*       _queue;\n-  ShenandoahHeap*                 _heap;\n-  ShenandoahMarkingContext* const _mark_context;\n-  size_t                          _trashed_oops;\n-\n-public:\n-  explicit ShenandoahProcessOldSATB(ShenandoahObjToScanQueue* q) :\n-    _queue(q),\n-    _heap(ShenandoahHeap::heap()),\n-    _mark_context(_heap->marking_context()),\n-    _trashed_oops(0) {}\n-\n-  void do_buffer(void** buffer, size_t size) override {\n-    assert(size == 0 || !_heap->has_forwarded_objects() || _heap->is_concurrent_old_mark_in_progress(), \"Forwarded objects are not expected here\");\n-    for (size_t i = 0; i < size; ++i) {\n-      oop *p = (oop *) &buffer[i];\n-      ShenandoahHeapRegion* region = _heap->heap_region_containing(*p);\n-      if (region->is_old() && region->is_active()) {\n-          ShenandoahMark::mark_through_ref<oop, OLD>(p, _queue, nullptr, _mark_context, false);\n-      } else {\n-        _trashed_oops++;\n-      }\n-    }\n-  }\n-\n-  size_t trashed_oops() const {\n-    return _trashed_oops;\n-  }\n-};\n-\n@@ -93,6 +47,0 @@\n-private:\n-  ShenandoahObjToScanQueueSet* _mark_queues;\n-  \/\/ Keep track of the number of oops that are not transferred to mark queues.\n-  \/\/ This is volatile because workers update it, but the vm thread reads it.\n-  volatile size_t             _trashed_oops;\n-\n@@ -100,4 +48,1 @@\n-  explicit ShenandoahPurgeSATBTask(ShenandoahObjToScanQueueSet* queues) :\n-    WorkerTask(\"Purge SATB\"),\n-    _mark_queues(queues),\n-    _trashed_oops(0) {\n+  explicit ShenandoahPurgeSATBTask() : WorkerTask(\"Purge SATB\") {\n@@ -107,6 +52,0 @@\n-  ~ShenandoahPurgeSATBTask() {\n-    if (_trashed_oops > 0) {\n-      log_debug(gc)(\"Purged %zu oops from old generation SATB buffers\", _trashed_oops);\n-    }\n-  }\n-\n@@ -116,1 +55,1 @@\n-    ShenandoahFlushAllSATB flusher(satb_queues);\n+    ShenandoahFlushSATB flusher(satb_queues);\n@@ -118,35 +57,0 @@\n-\n-    ShenandoahObjToScanQueue* mark_queue = _mark_queues->queue(worker_id);\n-    ShenandoahProcessOldSATB processor(mark_queue);\n-    while (satb_queues.apply_closure_to_completed_buffer(&processor)) {}\n-\n-    AtomicAccess::add(&_trashed_oops, processor.trashed_oops());\n-  }\n-};\n-\n-class ShenandoahTransferOldSATBTask : public WorkerTask {\n-  ShenandoahSATBMarkQueueSet&  _satb_queues;\n-  ShenandoahObjToScanQueueSet* _mark_queues;\n-  \/\/ Keep track of the number of oops that are not transferred to mark queues.\n-  \/\/ This is volatile because workers update it, but the control thread reads it.\n-  volatile size_t              _trashed_oops;\n-\n-public:\n-  explicit ShenandoahTransferOldSATBTask(ShenandoahSATBMarkQueueSet& satb_queues, ShenandoahObjToScanQueueSet* mark_queues) :\n-    WorkerTask(\"Transfer SATB\"),\n-    _satb_queues(satb_queues),\n-    _mark_queues(mark_queues),\n-    _trashed_oops(0) {}\n-\n-  ~ShenandoahTransferOldSATBTask() {\n-    if (_trashed_oops > 0) {\n-      log_debug(gc)(\"Purged %zu oops from old generation SATB buffers\", _trashed_oops);\n-    }\n-  }\n-\n-  void work(uint worker_id) override {\n-    ShenandoahObjToScanQueue* mark_queue = _mark_queues->queue(worker_id);\n-    ShenandoahProcessOldSATB processor(mark_queue);\n-    while (_satb_queues.apply_closure_to_completed_buffer(&processor)) {}\n-\n-    AtomicAccess::add(&_trashed_oops, processor.trashed_oops());\n@@ -455,15 +359,0 @@\n-void ShenandoahOldGeneration::concurrent_transfer_pointers_from_satb() const {\n-  const ShenandoahHeap* heap = ShenandoahHeap::heap();\n-  assert(heap->is_concurrent_old_mark_in_progress(), \"Only necessary during old marking.\");\n-  log_debug(gc)(\"Transfer SATB buffers\");\n-\n-  \/\/ Step 1. All threads need to 'complete' partially filled, thread local SATB buffers. This\n-  \/\/ is accomplished in ShenandoahConcurrentGC::complete_abbreviated_cycle using a Handshake\n-  \/\/ operation.\n-  \/\/ Step 2. Use worker threads to transfer oops from old, active regions in the completed\n-  \/\/ SATB buffers to old generation mark queues.\n-  ShenandoahSATBMarkQueueSet& satb_queues = ShenandoahBarrierSet::satb_mark_queue_set();\n-  ShenandoahTransferOldSATBTask transfer_task(satb_queues, task_queues());\n-  heap->workers()->run_task(&transfer_task);\n-}\n-\n@@ -474,1 +363,1 @@\n-  ShenandoahPurgeSATBTask purge_satb_task(task_queues());\n+  ShenandoahPurgeSATBTask purge_satb_task;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.cpp","additions":3,"deletions":114,"binary":false,"changes":117,"status":"modified"},{"patch":"@@ -224,2 +224,4 @@\n-  \/\/ avoid this problem, we \"purge\" the SATB buffers during the final update\n-  \/\/ references phase if (and only if) an old generation mark is in progress.\n+  \/\/ avoid this problem, we \"purge\" the SATB buffers during a handshake just\n+  \/\/ before the final update references safepoint references phase if (and only if)\n+  \/\/ an old generation mark is in progress.\n+  \/\/\n@@ -232,3 +234,3 @@\n-  \/\/ Alternatively, we could inspect the state of the heap and the age of the\n-  \/\/ object at the barrier, but we reject this approach because it is likely\n-  \/\/ the performance impact would be too severe.\n+  \/\/ This method is here for degenerated cycles. A concurrent cycle may be\n+  \/\/ cancelled before we have a chance to execute the handshake to flush the\n+  \/\/ SATB.\n@@ -236,1 +238,0 @@\n-  void concurrent_transfer_pointers_from_satb() const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-  SATBMarkQueueSet(allocator)\n+  SATBMarkQueueSet(allocator), _filter_out_young(false)\n@@ -42,1 +42,1 @@\n-  ShenandoahSATBMarkQueueFilterFn(ShenandoahHeap* heap) : _heap(heap) {}\n+  explicit ShenandoahSATBMarkQueueFilterFn(ShenandoahHeap* heap) : _heap(heap) {}\n@@ -44,2 +44,1 @@\n-  \/\/ Return true if entry should be filtered out (removed), false if\n-  \/\/ it should be retained.\n+  \/\/ Return true if entry should be filtered out (removed), false if it should be retained.\n@@ -51,0 +50,14 @@\n+class ShenandoahSATBOldMarkQueueFilterFn {\n+  ShenandoahHeap* const _heap;\n+\n+public:\n+  explicit ShenandoahSATBOldMarkQueueFilterFn(ShenandoahHeap* heap) : _heap(heap) {}\n+\n+  \/\/ Return true if entry should be filtered out (removed), false if it should be retained.\n+  bool operator()(const void* entry) const {\n+    assert(_heap->is_concurrent_old_mark_in_progress(), \"Should only use this when old marking is in progress\");\n+    assert(!_heap->is_concurrent_young_mark_in_progress(), \"Should only use this when young marking is not in progress\");\n+    return !_heap->requires_marking(entry) || !_heap->is_in_old(entry);\n+  }\n+};\n+\n@@ -53,1 +66,5 @@\n-  apply_filter(ShenandoahSATBMarkQueueFilterFn(heap), queue);\n+  if (_filter_out_young) {\n+    apply_filter(ShenandoahSATBOldMarkQueueFilterFn(heap), queue);\n+  } else {\n+    apply_filter(ShenandoahSATBMarkQueueFilterFn(heap), queue);\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.cpp","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-#include \"runtime\/javaThread.hpp\"\n-#include \"runtime\/mutex.hpp\"\n@@ -34,0 +32,3 @@\n+private:\n+  bool _filter_out_young;\n+\n@@ -35,1 +36,7 @@\n-  ShenandoahSATBMarkQueueSet(BufferNode::Allocator* allocator);\n+  explicit ShenandoahSATBMarkQueueSet(BufferNode::Allocator* allocator);\n+\n+  SATBMarkQueue& satb_queue_for_thread(Thread* const t) const override;\n+  void filter(SATBMarkQueue& queue) override;\n+  void set_filter_out_young(bool filter_out_young) {\n+    _filter_out_young = filter_out_young;\n+  }\n@@ -37,2 +44,3 @@\n-  virtual SATBMarkQueue& satb_queue_for_thread(Thread* const t) const;\n-  virtual void filter(SATBMarkQueue& queue);\n+  bool get_filter_out_young() const {\n+    return _filter_out_young;\n+  }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahSATBMarkQueueSet.hpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"}]}