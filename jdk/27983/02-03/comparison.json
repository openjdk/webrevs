{"files":[{"patch":"@@ -231,10 +231,4 @@\n-  \/\/ We leave the SATB barrier on for the entirety of the old generation\n-  \/\/ marking phase. In some cases, this can cause a write to a perfectly\n-  \/\/ reachable oop to enqueue a pointer that later becomes garbage (because\n-  \/\/ it points at an object that is later chosen for the collection set). There are\n-  \/\/ also cases where the referent of a weak reference ends up in the SATB\n-  \/\/ and is later collected. In these cases the oop in the SATB buffer becomes\n-  \/\/ invalid and the _next_ cycle will crash during its marking phase. To\n-  \/\/ avoid this problem, we \"purge\" the SATB buffers during a handshake just\n-  \/\/ before the final update references safepoint references phase if (and only if)\n-  \/\/ an old generation mark is in progress.\n+  \/\/ The SATB barrier will be \"enabled\" until old marking completes. This means it is\n+  \/\/ possible for an entire young collection cycle to execute while the SATB barrier is enabled.\n+  \/\/ Consider a situation like this, where we have a pointer 'B' at an object 'A' which is in\n+  \/\/ the young collection set:\n@@ -242,5 +236,7 @@\n-  \/\/ At this stage we can safely determine if any of the oops in the SATB\n-  \/\/ buffer belong to trashed regions (before they are recycled). As it\n-  \/\/ happens, flushing a SATB queue also filters out oops which have already\n-  \/\/ been marked - which is the case for anything that is being evacuated\n-  \/\/ from the collection set.\n+  \/\/      +--Young, CSet------+     +--Young, Regular----+\n+  \/\/      |                   |     |                    |\n+  \/\/      |                   |     |                    |\n+  \/\/      |       A <--------------------+ B             |\n+  \/\/      |                   |     |                    |\n+  \/\/      |                   |     |                    |\n+  \/\/      +-------------------+     +--------------------+\n@@ -248,3 +244,7 @@\n-  \/\/ This method is here for degenerated cycles. A concurrent cycle may be\n-  \/\/ cancelled before we have a chance to execute the handshake to flush the\n-  \/\/ SATB.\n+  \/\/ If a mutator thread overwrites pointer B, the SATB barrier will dutifully enqueue\n+  \/\/ object A. However, this object will be trashed when the young cycle completes. We must,\n+  \/\/ therefore, filter this object from the SATB buffer before any old mark threads see it.\n+  \/\/ We do this with a handshake before final-update-refs (see shenandoahConcurrentGC.cpp).\n+  \/\/\n+  \/\/ This method is here only for degenerated cycles. A concurrent cycle may be cancelled before\n+  \/\/ we have a chance to execute the handshake to flush the SATB in final-update-refs.\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahOldGeneration.hpp","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"}]}