{"files":[{"patch":"@@ -913,0 +913,1 @@\n+      nm->print_code_snippet(st, addr);\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -4311,0 +4311,40 @@\n+void nmethod::print_code_snippet(outputStream* st, address addr) const {\n+  if (entry_point() <= addr && addr < code_end()) {\n+    \/\/ Pointing into the nmethod's code. Try to disassemble some instructions around addr.\n+    \/\/ Determine conservative start and end points.\n+    address start;\n+    if (frame_complete_offset() != CodeOffsets::frame_never_safe &&\n+        addr >= code_begin() + frame_complete_offset()) {\n+      start = code_begin() + frame_complete_offset();\n+    } else {\n+      start = (addr < verified_entry_point()) ? entry_point() : verified_entry_point();\n+    }\n+    address start_for_hex_dump = start; \/\/ We can choose a different starting point for hex dump, below.\n+    address end = code_end();\n+\n+    \/\/ Try using relocations to find closer instruction start and end points.\n+    \/\/ (Some platforms have variable length instructions and can only\n+    \/\/ disassemble correctly at instruction start addresses.)\n+    RelocIterator iter((nmethod*)this, start);\n+    while (iter.next() && iter.addr() < addr) { \/\/ find relocation before addr\n+      \/\/ Note: There's a relocation which doesn't point to an instruction start:\n+      \/\/ ZBarrierRelocationFormatStoreGoodAfterMov with ZGC on x86_64\n+      \/\/ We could detect and skip it, but hex dump is still usable when\n+      \/\/ disassembler produces garbage in such a very rare case.\n+      start = iter.addr();\n+      \/\/ We want at least 64 Bytes ahead in hex dump.\n+      if (iter.addr() <= (addr - 64)) start_for_hex_dump = iter.addr();\n+    }\n+    if (iter.has_current()) {\n+      if (iter.addr() == addr) iter.next(); \/\/ find relocation after addr\n+      if (iter.has_current()) end = iter.addr();\n+    }\n+\n+    \/\/ Always print hex. Disassembler may still have problems when hitting an incorrect instruction start.\n+    os::print_hex_dump(st, start_for_hex_dump, end, 1, \/* print_ascii=*\/false);\n+    if (!Disassembler::is_abstract()) {\n+      Disassembler::decode(start, end, st);\n+    }\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/code\/nmethod.cpp","additions":40,"deletions":0,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -1011,0 +1011,1 @@\n+  void print_code_snippet(outputStream* st, address addr) const;\n","filename":"src\/hotspot\/share\/code\/nmethod.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"}]}