{"files":[{"patch":"@@ -913,0 +913,22 @@\n+      if (nm->entry_point() <= addr && addr < nm->code_end()) {\n+        \/\/ Pointing into an nmethod. Try to disassemble some instructions around addr.\n+        address start = (addr < nm->verified_entry_point()) ? nm->entry_point() : nm->verified_entry_point();\n+        address end = nm->code_end();\n+        \/\/ Try using relocations to find known instruction start and end points.\n+        \/\/ (Some platforms have variable length instructions and can only\n+        \/\/ disassemble correctly at instruction start addresses.)\n+        RelocIterator iter(nm, start);\n+        while (iter.next() && iter.addr() < addr) { \/\/ find relocation before addr\n+          start = iter.addr();\n+        }\n+        if (iter.has_current()) {\n+          if (iter.addr() == addr) iter.next(); \/\/ find relocation after addr\n+          if (iter.has_current()) end = iter.addr();\n+        }\n+\n+        \/\/ Always print hex. Disassembler may still have problems if start is not a correct instruction start.\n+        os::print_hex_dump(st, start, end, 1, \/* print_ascii=*\/false);\n+        if (!Disassembler::is_abstract()) {\n+          Disassembler::decode(start, end, st);\n+        }\n+      }\n","filename":"src\/hotspot\/share\/code\/codeBlob.cpp","additions":22,"deletions":0,"binary":false,"changes":22,"status":"modified"}]}