{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,1 +106,1 @@\n-     * Returns a boolean indicating if the test VM runs with flags that allow C2 compilations.\n+     * Returns a boolean indicating if the Test VM runs with flags that allow C2 compilations.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/AbstractInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-     * for the compilation if the test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler}, or\n+     * for the compilation if the Test VM is run with {@code -Xcomp}, {@code -XX:-UseCompiler}, or\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/CompLevel.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n- * annotation can specify additional preconditions on the allowed test VM flags that must hold when an IR rule is applied.\n+ * annotation can specify additional preconditions on the allowed Test VM flags that must hold when an IR rule is applied.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IR.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -118,1 +118,1 @@\n-One might also want to restrict the application of certain `@IR` rules depending on the used flags in the test VM. These could be flags defined by the user or by JTreg. In the latter case, the flags must be whitelisted in `JTREG_WHITELIST_FLAGS` in [TestFramework](.\/TestFramework.java) (i.e. have no unexpected impact on the IR except if the flag simulates a specific machine setup like `UseAVX={1,2,3}` etc.) to enable an IR verification by the framework. The `@IR` rules thus have an option to restrict their application:\n+One might also want to restrict the application of certain `@IR` rules depending on the used flags in the Test VM. These could be flags defined by the user or by JTreg. In the latter case, the flags must be whitelisted in `JTREG_WHITELIST_FLAGS` in [TestFramework](.\/TestFramework.java) (i.e. have no unexpected impact on the IR except if the flag simulates a specific machine setup like `UseAVX={1,2,3}` etc.) to enable an IR verification by the framework. The `@IR` rules thus have an option to restrict their application:\n@@ -147,1 +147,1 @@\n-The recommended way to use the framework is by defining a single `@run driver` statement in the JTreg header which, however, does not allow the specification of additional test VM flags. Instead, the user has the possibility to provide VM flags by calling `TestFramework.runWithFlags()` or by creating a `TestFramework` builder object on which `addFlags()` can be called.\n+The recommended way to use the framework is by defining a single `@run driver` statement in the JTreg header which, however, does not allow the specification of additional Test VM flags. Instead, the user has the possibility to provide VM flags by calling `TestFramework.runWithFlags()` or by creating a `TestFramework` builder object on which `addFlags()` can be called.\n@@ -177,1 +177,1 @@\n-- `-DReportStdout=true`: Print the standard output of the test VM.\n+- `-DReportStdout=true`: Print the standard output of the Test VM.\n@@ -179,1 +179,1 @@\n-- `-DReproduce=true`: Flag to use when directly running a test VM to bypass dependencies to the driver VM state (for example, when reproducing an issue).\n+- `-DReproduce=true`: Flag to use when directly running a Test VM to bypass dependencies to the Driver VM state (for example, when reproducing an issue).\n@@ -182,1 +182,1 @@\n-- `-DVerifyVM=true`: The framework runs the test VM with additional verification flags (slows the execution down).\n+- `-DVerifyVM=true`: The framework runs the Test VM with additional verification flags (slows the execution down).\n@@ -186,1 +186,1 @@\n-- `-DDumpReplay=true`: Add the `DumpReplay` directive to the test VM.\n+- `-DDumpReplay=true`: Add the `DumpReplay` directive to the Test VM.\n@@ -196,1 +196,1 @@\n-The framework will spawn a new \"test VM\" to execute the user defined tests. The test VM collects all tests of the test class specified by the user code in `main()` and ensures that there is no violation of the required format by the framework. In a next step, the framework does the following for each test in general:\n+The framework will spawn a new \"Test VM\" to execute the user defined tests. The Test VM collects all tests of the test class specified by the user code in `main()` and ensures that there is no violation of the required format by the framework. In a next step, the framework does the following for each test in general:\n@@ -201,1 +201,1 @@\n-Once the test VM terminates, IR verification (if possible) is performed on the output of the test VM. If any test throws an exception during its execution or if IR matching fails, the failures are collected and reported in a pretty format. Check the standard error and output for more information and how to reproduce these failures.\n+Once the Test VM terminates, IR verification (if possible) is performed on the output of the Test VM. If any test throws an exception during its execution or if IR matching fails, the failures are collected and reported in a pretty format. Check the standard error and output for more information and how to reproduce these failures.\n@@ -215,4 +215,4 @@\n-- `compiler.lib.ir_framework.driver`: These classes are used while running the driver VM (same VM as the one running the user code's `main()` method of a JTreg test).\n-- `compiler.lib.ir_framework.flag`: These classes are used while running the flag VM to determine additional flags for the test VM which are required for IR verification.\n-- `compiler.lib.ir_framework.test`: These classes are used while running the test VM (i.e. the actual execution of the user tests as described in section 3).\n-- `compiler.lib.ir_framework.shared`: These classes can be called from either the driver, flag, or test VM.\n+- `compiler.lib.ir_framework.driver`: These classes are used while running the Driver VM (same VM as the one running the user code's `main()` method of a JTreg test).\n+- `compiler.lib.ir_framework.flag`: These classes are used while running the Flag VM to determine additional flags for the Test VM which are required for IR verification.\n+- `compiler.lib.ir_framework.test`: These classes are used while running the Test VM (i.e. the actual execution of the user tests as described in section 3).\n+- `compiler.lib.ir_framework.shared`: These classes can be called from either the driver, flag, or Test VM.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,1 @@\n-     * Get the test VM output (stdout + stderr) of this scenario from the last execution of the framework.\n+     * Get the Test VM output (stdout + stderr) of this scenario from the last execution of the framework.\n@@ -126,1 +126,1 @@\n-     * @return the test VM output.\n+     * @return the Test VM output.\n@@ -133,1 +133,1 @@\n-     * Set the test VM output, called by the framework.\n+     * Set the Test VM output, called by the framework.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/Scenario.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n- * The framework is called from the <i>driver VM<\/i> in which the JTreg test is initially run by specifying {@code\n+ * The framework is called from the <i>Driver VM<\/i> in which the JTreg test is initially run by specifying {@code\n@@ -90,1 +90,1 @@\n- * The framework creates a new <i>flag VM<\/i> with all these flags added again in order to figure out which flags are\n+ * The framework creates a new <i>Flag VM<\/i> with all these flags added again in order to figure out which flags are\n@@ -94,1 +94,1 @@\n- * After the flag VM terminates, it starts a new <i>test VM<\/i> which performs the execution of the specified\n+ * After the Flag VM terminates, it starts a new <i>Test VM<\/i> which performs the execution of the specified\n@@ -97,1 +97,1 @@\n- * In a last step, once the test VM has terminated without exceptions, IR matching is performed if there are any IR\n+ * In a last step, once the Test VM has terminated without exceptions, IR matching is performed if there are any IR\n@@ -100,1 +100,1 @@\n- * the hotspot_pid file of the test VM. Failing IR rules are reported by throwing a {@link IRViolationException}.\n+ * the hotspot_pid file of the Test VM. Failing IR rules are reported by throwing a {@link IRViolationException}.\n@@ -169,1 +169,1 @@\n-                                                - To also get the standard output of the test VM run with\n+                                                - To also get the standard output of the Test VM run with\n@@ -239,1 +239,1 @@\n-     * Tests the class from which this method was invoked from. The test VM is called with the specified {@code flags}.\n+     * Tests the class from which this method was invoked from. The Test VM is called with the specified {@code flags}.\n@@ -242,1 +242,1 @@\n-     *            Use {@code -DPreferCommandLineFlags=true} if you want to prefer the JTreg VM and  Javaoptions flags over\n+     *            Use {@code -DPreferCommandLineFlags=true} if you want to prefer the JTreg VM and Javaoptions flags over\n@@ -251,1 +251,1 @@\n-     * @param flags VM flags to be used for the test VM.\n+     * @param flags VM flags to be used for the Test VM.\n@@ -261,1 +261,1 @@\n-     * Add VM flags to be used for the test VM. These flags override any VM or Javaoptions set by JTreg by default.<p>\n+     * Add VM flags to be used for the Test VM. These flags override any VM or Javaoptions set by JTreg by default.<p>\n@@ -267,1 +267,1 @@\n-     * @param flags VM options to be applied to the test VM.\n+     * @param flags VM options to be applied to the Test VM.\n@@ -309,1 +309,1 @@\n-     * Add scenarios to be used for the test VM. A test VM is called for each scenario in {@code scenarios} by using the\n+     * Add scenarios to be used for the Test VM. A Test VM is called for each scenario in {@code scenarios} by using the\n@@ -317,1 +317,1 @@\n-     * @param scenarios scenarios which specify specific flags for the test VM.\n+     * @param scenarios scenarios which specify specific flags for the Test VM.\n@@ -506,1 +506,1 @@\n-     * Get the VM output of the test VM. Use {@code -DVerbose=true} to enable more debug information. If scenarios\n+     * Get the VM output of the Test VM. Use {@code -DVerbose=true} to enable more debug information. If scenarios\n@@ -509,1 +509,1 @@\n-     * @return the last test VM output.\n+     * @return the last Test VM output.\n@@ -799,3 +799,3 @@\n-     * Execute a separate \"flag\" VM with White Box access to determine all test VM flags. The flag VM sends an encoding of\n-     * all required flags for the test VM to the driver VM over a socket. Once the flag VM exits, this driver VM parses the\n-     * test VM flags, which also determine if IR matching should be done, and then starts the test VM to execute all tests.\n+     * Execute a separate Flag VM with White Box access to determine all Test VM flags. The Flag VM sends an encoding of\n+     * all required flags for the Test VM to the Driver VM over a socket. Once the Flag VM exits, this Driver VM parses the\n+     * Test VM flags, which also determine if IR matching should be done, and then starts the Test VM to execute all tests.\n@@ -826,1 +826,1 @@\n-                \/\/ Only need to use flag VM if an IR verification is possibly done.\n+                \/\/ Only need to use Flag VM if an IR verification is possibly done.\n@@ -831,1 +831,1 @@\n-                    \/\/ Add more flags for the test VM which are required to do IR verification.\n+                    \/\/ Add more flags for the Test VM which are required to do IR verification.\n@@ -885,1 +885,1 @@\n-                                                                     testVMProcess.getIrEncoding());\n+                                                                     testVMProcess.getApplicableIRRules());\n@@ -895,1 +895,1 @@\n-                               \"Javaopts flag like -Xint, or running the test VM with other VM flags added by user code \" +\n+                               \"Javaopts flag like -Xint, or running the Test VM with other VM flags added by user code \" +\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":23,"deletions":23,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,3 @@\n- * This class prepares, creates, and runs the \"flag\" VM with verification of proper termination. The flag VM determines\n- * the flags required for the \"test\" VM. The flag VM writes these flags to a dedicated file which is then parsed by this\n- * class after the termination of the flag VM.\n+ * This class prepares, creates, and runs the Flag VM with verification of proper termination. The Flag VM determines\n+ * the flags required for the Test VM. The Flag VM writes these flags to a dedicated file which is then parsed by this\n+ * class after the termination of the Flag VM.\n@@ -76,1 +76,1 @@\n-        TestFramework.check(matcher.find(), \"Invalid flag encoding emitted by flag VM\");\n+        TestFramework.check(matcher.find(), \"Invalid flag encoding emitted by Flag VM\");\n@@ -94,2 +94,2 @@\n-     * The flag VM needs White Box access to prepare all test VM flags. The flag VM will write the test VM flags to\n-     * a dedicated file which is afterwards parsed by the driver VM and added as flags to the test VM.\n+     * The Flag VM needs White Box access to prepare all Test VM flags. The Flag VM will write the Test VM flags to\n+     * a dedicated file which is afterwards parsed by the Driver VM and added as flags to the Test VM.\n@@ -106,1 +106,1 @@\n-        \/\/ TestFramework and scenario flags might have an influence on the later used test VM flags. Add them as well.\n+        \/\/ TestFramework and scenario flags might have an influence on the later used Test VM flags. Add them as well.\n@@ -114,1 +114,1 @@\n-            \/\/ Run \"flag\" VM with White Box access to determine the test VM flags and if IR verification should be done.\n+            \/\/ Run Flag VM with White Box access to determine the Test VM flags and if IR verification should be done.\n@@ -117,1 +117,1 @@\n-            throw new TestRunException(\"Failed to execute TestFramework flag VM\", e);\n+            throw new TestRunException(\"Failed to execute TestFramework Flag VM\", e);\n@@ -128,1 +128,1 @@\n-            System.out.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.out.println(\"--- OUTPUT TestFramework Flag VM ---\");\n@@ -133,1 +133,1 @@\n-            System.err.println(\"--- OUTPUT TestFramework flag VM ---\");\n+            System.err.println(\"--- OUTPUT TestFramework Flag VM ---\");\n@@ -135,1 +135,1 @@\n-            throw new RuntimeException(\"TestFramework flag VM exited with \" + exitCode);\n+            throw new RuntimeException(\"TestFramework Flag VM exited with \" + exitCode);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/FlagVMProcess.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,1 +29,1 @@\n- * Exception that is thrown if the test VM has thrown any kind of exception (except for {@link TestFormatException}).\n+ * Exception that is thrown if the Test VM has thrown any kind of exception (except for {@link TestFormatException}).\n@@ -40,1 +40,1 @@\n-     * Get some more detailed information about the exception thrown in the test VM and how to reproduce it.\n+     * Get some more detailed information about the exception thrown in the Test VM and how to reproduce it.\n@@ -42,1 +42,1 @@\n-     * @return a formatted string containing information about the exception of the test VM and how to reproduce it.\n+     * @return a formatted string containing information about the exception of the Test VM and how to reproduce it.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMException.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,3 +44,3 @@\n- * This class prepares, creates, and runs the \"test\" VM with verification of proper termination. The class also stores\n- * information about the test VM which is later queried for IR matching. The communication between this driver VM\n- * and the test VM is done over a dedicated socket.\n+ * This class prepares, creates, and runs the Test VM with verification of proper termination. The class also stores\n+ * information about the Test VM which is later queried for IR matching. The communication between this Driver VM\n+ * and the Test VM is done over a dedicated socket.\n@@ -65,1 +65,1 @@\n-    private String irEncoding;\n+    private String applicableIRRules;\n@@ -84,2 +84,2 @@\n-    public String getIrEncoding() {\n-        return irEncoding;\n+    public String getApplicableIRRules() {\n+        return applicableIRRules;\n@@ -101,1 +101,1 @@\n-        \/\/ Need White Box access in test VM.\n+        \/\/ Need White Box access in Test VM.\n@@ -115,1 +115,2 @@\n-        \/\/ Add server property flag that enables test VM to print encoding for IR verification last and debug messages.\n+        \/\/ Add server property flag that enables the Test VM to print the Applicable IR Rules for IR verification and\n+        \/\/ debug messages.\n@@ -145,1 +146,1 @@\n-     * Default flags that are added used for the test VM.\n+     * Default flags that are added used for the Test VM.\n@@ -172,1 +173,1 @@\n-        process.command().add(1, \"-DReproduce=true\"); \/\/ Add after \"\/path\/to\/bin\/java\" in order to rerun the test VM directly\n+        process.command().add(1, \"-DReproduce=true\"); \/\/ Add after \"\/path\/to\/bin\/java\" in order to rerun the Test VM directly\n@@ -181,1 +182,1 @@\n-     * represent the IR encoding used for IR matching later.\n+     * represent the Applicable IR Rules used for IR matching later.\n@@ -218,1 +219,1 @@\n-            irEncoding = nonStdOutBuilder.toString();\n+            applicableIRRules = nonStdOutBuilder.toString();\n@@ -220,1 +221,1 @@\n-            irEncoding = output;\n+            applicableIRRules = output;\n@@ -227,1 +228,1 @@\n-            System.out.println(\"--- OUTPUT TestFramework test VM ---\");\n+            System.out.println(\"--- OUTPUT TestFramework Test VM ---\");\n@@ -237,1 +238,1 @@\n-     * Exit code was non-zero of test VM. Check the stderr to determine what kind of exception that should be thrown to\n+     * Exit code was non-zero of Test VM. Check the stderr to determine what kind of exception that should be thrown to\n@@ -269,1 +270,1 @@\n-        return \"TestFramework test VM exited with code \" + exitCode + System.lineSeparator() + stdOut\n+        return \"TestFramework Test VM exited with code \" + exitCode + System.lineSeparator() + stdOut\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":18,"deletions":17,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -0,0 +1,159 @@\n+\/*\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.lib.ir_framework.driver.irmatching.parser;\n+\n+import compiler.lib.ir_framework.IR;\n+import compiler.lib.ir_framework.TestFramework;\n+import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.HotSpotPidFileParser;\n+import compiler.lib.ir_framework.shared.TestFormat;\n+import compiler.lib.ir_framework.shared.TestFrameworkException;\n+import compiler.lib.ir_framework.test.ApplicableIRRulesPrinter;\n+\n+import java.lang.reflect.Method;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+\/**\n+ * Class to parse the Applicable IR Rules emitted by the Test VM and creating {@link TestMethod} objects for each entry.\n+ *\n+ * @see TestMethod\n+ *\/\n+public class ApplicableIRRulesParser {\n+\n+    private static final boolean PRINT_APPLICABLE_IR_RULES = Boolean.parseBoolean(System.getProperty(\"PrintApplicableIRRules\", \"false\"));\n+    private static final Pattern APPLICABLE_IR_RULES_PATTERN =\n+            Pattern.compile(\"(?<=\" + ApplicableIRRulesPrinter.START + \"\\r?\\n).*\\\\R([\\\\s\\\\S]*)(?=\" + ApplicableIRRulesPrinter.END + \")\");\n+\n+    private final Map<String, TestMethod> testMethods;\n+    private final Class<?> testClass;\n+\n+    public ApplicableIRRulesParser(Class<?> testClass) {\n+        this.testClass = testClass;\n+        this.testMethods = new HashMap<>();\n+    }\n+\n+    \/**\n+     * Parse the Applicable IR rules passed as parameter and return a \"test name\" -> TestMethod map that contains an\n+     * entry for each method that needs to be IR matched on.\n+     *\/\n+    public TestMethods parse(String applicableIRRules) {\n+        if (TestFramework.VERBOSE || PRINT_APPLICABLE_IR_RULES) {\n+            System.out.println(\"Read Applicable IR Rules from Test VM:\");\n+            System.out.println(applicableIRRules);\n+        }\n+        createTestMethodMap(applicableIRRules, testClass);\n+        \/\/ We could have found format errors in @IR annotations. Report them now with an exception.\n+        TestFormat.throwIfAnyFailures();\n+        return new TestMethods(testMethods);\n+    }\n+\n+    \/**\n+     * Sets up a map testname -> TestMethod map. The TestMethod object will later be filled with the ideal and opto\n+     * assembly output in {@link HotSpotPidFileParser}.\n+     *\/\n+    private void createTestMethodMap(String applicableIRRules, Class<?> testClass) {\n+        Map<String, int[]> irRulesMap = parseApplicableIRRules(applicableIRRules);\n+        createTestMethodsWithApplicableIRRules(testClass, irRulesMap);\n+    }\n+\n+    \/**\n+     * Read the Applicable IR Rules emitted by the Test VM to decide if an @IR rule must be checked for a method.\n+     *\/\n+    private Map<String, int[]> parseApplicableIRRules(String applicableIRRules) {\n+        Map<String, int[]> irRulesMap = new HashMap<>();\n+        String[] applicableIRRulesLines = getApplicableIRRulesLines(applicableIRRules);\n+        for (String s : applicableIRRulesLines) {\n+            String line = s.trim();\n+            String[] splitLine = line.split(\",\");\n+            if (splitLine.length < 2) {\n+                throw new TestFrameworkException(\"Invalid Applicable IR Rules format. No comma found: \" + splitLine[0]);\n+            }\n+            String testName = splitLine[0];\n+            int[] irRulesIdx = getRuleIndexes(splitLine);\n+            irRulesMap.put(testName, irRulesIdx);\n+        }\n+        return irRulesMap;\n+    }\n+\n+    \/**\n+     * Parse the Applicable IR Rules lines without header, explanation line and footer and return them in an array.\n+     *\/\n+    private String[] getApplicableIRRulesLines(String applicableIRRules) {\n+        Matcher matcher = APPLICABLE_IR_RULES_PATTERN.matcher(applicableIRRules);\n+        TestFramework.check(matcher.find(), \"Did not find Applicable IR Rules in:\" +\n+                System.lineSeparator() + applicableIRRules);\n+        String lines = matcher.group(1).trim();\n+        if (lines.isEmpty()) {\n+            \/\/ Nothing to IR match.\n+            return new String[0];\n+        }\n+        return lines.split(\"\\\\R\");\n+    }\n+\n+    \/**\n+     * Parse rule indexes from a single line of the Applicable IR Rules in the format: <method,idx1,idx2,...>\n+     *\/\n+    private int[] getRuleIndexes(String[] splitLine) {\n+        int[] irRulesIdx = new int[splitLine.length - 1];\n+        for (int i = 1; i < splitLine.length; i++) {\n+            try {\n+                irRulesIdx[i - 1] = Integer.parseInt(splitLine[i]);\n+            } catch (NumberFormatException e) {\n+                throw new TestFrameworkException(\"Invalid Applicable IR Rules format. No number found: \" + splitLine[i]);\n+            }\n+        }\n+        return irRulesIdx;\n+    }\n+\n+    private void createTestMethodsWithApplicableIRRules(Class<?> testClass, Map<String, int[]> irRulesMap) {\n+        for (Method m : testClass.getDeclaredMethods()) {\n+            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n+            if (irAnnos.length > 0) {\n+                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n+                int[] irRuleIds = irRulesMap.get(m.getName());\n+                validateIRRuleIds(m, irAnnos, irRuleIds);\n+                if (hasAnyApplicableIRRules(irRuleIds)) {\n+                    testMethods.put(m.getName(), new TestMethod(m, irAnnos, irRuleIds));\n+                }\n+            }\n+        }\n+    }\n+\n+    private void validateIRRuleIds(Method m, IR[] irAnnos, int[] ids) {\n+        TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n+        TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n+        TestFramework.check((ids[0] >= 1 || ids[0] == ApplicableIRRulesPrinter.NO_RULE_APPLIED)\n+                            && ids[ids.length - 1] <= irAnnos.length,\n+                            \"Invalid IR rule index found in validIrRulesMap for \" + m);\n+    }\n+\n+    \/**\n+     * Does the list of IR rules contain any applicable IR rules for the given conditions?\n+     *\/\n+    private boolean hasAnyApplicableIRRules(int[] irRuleIds) {\n+        return irRuleIds[0] != ApplicableIRRulesPrinter.NO_RULE_APPLIED;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/ApplicableIRRulesParser.java","additions":159,"deletions":0,"binary":false,"changes":159,"status":"added"},{"patch":"@@ -1,158 +0,0 @@\n-\/*\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-package compiler.lib.ir_framework.driver.irmatching.parser;\n-\n-import compiler.lib.ir_framework.IR;\n-import compiler.lib.ir_framework.TestFramework;\n-import compiler.lib.ir_framework.driver.irmatching.parser.hotspot.HotSpotPidFileParser;\n-import compiler.lib.ir_framework.shared.TestFormat;\n-import compiler.lib.ir_framework.shared.TestFrameworkException;\n-import compiler.lib.ir_framework.test.IREncodingPrinter;\n-\n-import java.lang.reflect.Method;\n-import java.util.HashMap;\n-import java.util.Map;\n-import java.util.regex.Matcher;\n-import java.util.regex.Pattern;\n-\n-\/**\n- * Class to parse the IR encoding emitted by the test VM and creating {@link TestMethod} objects for each entry.\n- *\n- * @see TestMethod\n- *\/\n-public class IREncodingParser {\n-\n-    private static final boolean PRINT_IR_ENCODING = Boolean.parseBoolean(System.getProperty(\"PrintIREncoding\", \"false\"));\n-    private static final Pattern IR_ENCODING_PATTERN =\n-            Pattern.compile(\"(?<=\" + IREncodingPrinter.START + \"\\r?\\n).*\\\\R([\\\\s\\\\S]*)(?=\" + IREncodingPrinter.END + \")\");\n-\n-    private final Map<String, TestMethod> testMethods;\n-    private final Class<?> testClass;\n-\n-    public IREncodingParser(Class<?> testClass) {\n-        this.testClass = testClass;\n-        this.testMethods = new HashMap<>();\n-    }\n-\n-    \/**\n-     * Parse the IR encoding passed as parameter and return a \"test name\" -> TestMethod map that contains an entry\n-     * for each method that needs to be IR matched on.\n-     *\/\n-    public TestMethods parse(String irEncoding) {\n-        if (TestFramework.VERBOSE || PRINT_IR_ENCODING) {\n-            System.out.println(\"Read IR encoding from test VM:\");\n-            System.out.println(irEncoding);\n-        }\n-        createTestMethodMap(irEncoding, testClass);\n-        \/\/ We could have found format errors in @IR annotations. Report them now with an exception.\n-        TestFormat.throwIfAnyFailures();\n-        return new TestMethods(testMethods);\n-    }\n-\n-    \/**\n-     * Sets up a map testname -> TestMethod map. The TestMethod object will later be filled with the ideal and opto\n-     * assembly output in {@link HotSpotPidFileParser}.\n-     *\/\n-    private void createTestMethodMap(String irEncoding, Class<?> testClass) {\n-        Map<String, int[]> irRulesMap = parseIREncoding(irEncoding);\n-        createTestMethodsWithEncoding(testClass, irRulesMap);\n-    }\n-\n-    \/**\n-     * Read the IR encoding emitted by the test VM to decide if an @IR rule must be checked for a method.\n-     *\/\n-    private Map<String, int[]> parseIREncoding(String irEncoding) {\n-        Map<String, int[]> irRulesMap = new HashMap<>();\n-        String[] irEncodingLines = getIREncodingLines(irEncoding);\n-        for (String s : irEncodingLines) {\n-            String line = s.trim();\n-            String[] splitLine = line.split(\",\");\n-            if (splitLine.length < 2) {\n-                throw new TestFrameworkException(\"Invalid IR match rule encoding. No comma found: \" + splitLine[0]);\n-            }\n-            String testName = splitLine[0];\n-            int[] irRulesIdx = getRuleIndexes(splitLine);\n-            irRulesMap.put(testName, irRulesIdx);\n-        }\n-        return irRulesMap;\n-    }\n-\n-    \/**\n-     * Parse the IR encoding lines without header, explanation line and footer and return them in an array.\n-     *\/\n-    private String[] getIREncodingLines(String irEncoding) {\n-        Matcher matcher = IR_ENCODING_PATTERN.matcher(irEncoding);\n-        TestFramework.check(matcher.find(), \"Did not find IR encoding in:\" + System.lineSeparator() + irEncoding);\n-        String lines = matcher.group(1).trim();\n-        if (lines.isEmpty()) {\n-            \/\/ Nothing to IR match.\n-            return new String[0];\n-        }\n-        return lines.split(\"\\\\R\");\n-    }\n-\n-    \/**\n-     * Parse rule indexes from IR encoding line of the format: <method,idx1,idx2,...>\n-     *\/\n-    private int[] getRuleIndexes(String[] splitLine) {\n-        int[] irRulesIdx = new int[splitLine.length - 1];\n-        for (int i = 1; i < splitLine.length; i++) {\n-            try {\n-                irRulesIdx[i - 1] = Integer.parseInt(splitLine[i]);\n-            } catch (NumberFormatException e) {\n-                throw new TestFrameworkException(\"Invalid IR match rule encoding. No number found: \" + splitLine[i]);\n-            }\n-        }\n-        return irRulesIdx;\n-    }\n-\n-    private void createTestMethodsWithEncoding(Class<?> testClass, Map<String, int[]> irRulesMap) {\n-        for (Method m : testClass.getDeclaredMethods()) {\n-            IR[] irAnnos = m.getAnnotationsByType(IR.class);\n-            if (irAnnos.length > 0) {\n-                \/\/ Validation of legal @IR attributes and placement of the annotation was already done in Test VM.\n-                int[] irRuleIds = irRulesMap.get(m.getName());\n-                validateIRRuleIds(m, irAnnos, irRuleIds);\n-                if (hasAnyApplicableIRRules(irRuleIds)) {\n-                    testMethods.put(m.getName(), new TestMethod(m, irAnnos, irRuleIds));\n-                }\n-            }\n-        }\n-    }\n-\n-    private void validateIRRuleIds(Method m, IR[] irAnnos, int[] ids) {\n-        TestFramework.check(ids != null, \"Should find method name in validIrRulesMap for \" + m);\n-        TestFramework.check(ids.length > 0, \"Did not find any rule indices for \" + m);\n-        TestFramework.check((ids[0] >= 1 || ids[0] == IREncodingPrinter.NO_RULE_APPLIED)\n-                            && ids[ids.length - 1] <= irAnnos.length,\n-                            \"Invalid IR rule index found in validIrRulesMap for \" + m);\n-    }\n-\n-    \/**\n-     * Does the list of IR rules contain any applicable IR rules for the given conditions?\n-     *\/\n-    private boolean hasAnyApplicableIRRules(int[] irRuleIds) {\n-        return irRuleIds[0] != IREncodingPrinter.NO_RULE_APPLIED;\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IREncodingParser.java","additions":0,"deletions":158,"binary":false,"changes":158,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,0 @@\n-import compiler.lib.ir_framework.TestFramework;\n@@ -56,1 +55,1 @@\n-     * Create IR methods for all test methods identified by {@link IREncodingParser} by combining them with the parsed\n+     * Create IR methods for all test methods identified by {@link ApplicableIRRulesParser} by combining them with the parsed\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/IRMethodBuilder.java","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-     * Parse the IR encoding and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n+     * Parse the Applicable IR Rules and hotspot_pid* file to create a collection of {@link IRMethod} objects.\n@@ -56,4 +56,4 @@\n-    public Matchable parse(String hotspotPidFileName, String irEncoding) {\n-        IREncodingParser irEncodingParser = new IREncodingParser(testClass);\n-        TestMethods testMethods = irEncodingParser.parse(irEncoding);\n-        VMInfo vmInfo = VMInfoParser.parseVMInfo(irEncoding);\n+    public Matchable parse(String hotspotPidFileName, String applicableIRRules) {\n+        ApplicableIRRulesParser applicableIRRulesParser = new ApplicableIRRulesParser(testClass);\n+        TestMethods testMethods = applicableIRRulesParser.parse(applicableIRRules);\n+        VMInfo vmInfo = VMInfoParser.parseVMInfo(applicableIRRules);\n@@ -69,1 +69,1 @@\n-     * Create test class with IR methods for all test methods identified by {@link IREncodingParser} by combining them\n+     * Create test class with IR methods for all test methods identified by {@link ApplicableIRRulesParser} by combining them\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestClassParser.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n- * This class represents a test method parsed by {@link IREncodingParser}. In combination with the associated\n+ * This class represents a test method parsed by {@link ApplicableIRRulesParser}. In combination with the associated\n@@ -36,1 +36,1 @@\n- * @see IREncodingParser\n+ * @see ApplicableIRRulesParser\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestMethod.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n- * This class stores all test methods that need to be IR matched as identified by {@link IREncodingParser}.\n+ * This class stores all test methods that need to be IR matched as identified by {@link ApplicableIRRulesParser}.\n@@ -34,1 +34,1 @@\n- * @see IREncodingParser\n+ * @see ApplicableIRRulesParser\n@@ -40,1 +40,1 @@\n-     * \"Method name\" -> TestMethod map created by {@link IREncodingParser} which contains an entry for each method that\n+     * \"Method name\" -> TestMethod map created by {@link ApplicableIRRulesParser} which contains an entry for each method that\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/TestMethods.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * @see IREncodingParser\n+ * @see ApplicableIRRulesParser\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/VMInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Class to parse the VMInfo emitted by the test VM and creating {@link VMInfo} objects for each entry.\n+ * Class to parse the VMInfo emitted by the Test VM and creating {@link VMInfo} objects for each entry.\n@@ -46,1 +46,1 @@\n-     * Extract VMInfo from the irEncoding.\n+     * Extract VMInfo from the applicableIRRules.\n@@ -48,1 +48,1 @@\n-    public static VMInfo parseVMInfo(String irEncoding) {\n+    public static VMInfo parseVMInfo(String applicableIRRules) {\n@@ -50,1 +50,1 @@\n-        String[] lines = getVMInfoLines(irEncoding);\n+        String[] lines = getVMInfoLines(applicableIRRules);\n@@ -65,1 +65,1 @@\n-     * Extract the VMInfo from the irEncoding string, strip away the header and return the individual key-value lines.\n+     * Extract the VMInfo from the applicableIRRules string, strip away the header and return the individual key-value lines.\n@@ -67,3 +67,3 @@\n-    private static String[] getVMInfoLines(String irEncoding) {\n-        Matcher matcher = VM_INFO_PATTERN.matcher(irEncoding);\n-        TestFramework.check(matcher.find(), \"Did not find VMInfo in:\" + System.lineSeparator() + irEncoding);\n+    private static String[] getVMInfoLines(String applicableIRRules) {\n+        Matcher matcher = VM_INFO_PATTERN.matcher(applicableIRRules);\n+        TestFramework.check(matcher.find(), \"Did not find VMInfo in:\" + System.lineSeparator() + applicableIRRules);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/VMInfoParser.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.parser.IREncodingParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.ApplicableIRRulesParser;\n@@ -37,1 +37,1 @@\n- * IR matched (i.e. identified by {@link IREncodingParser}.\n+ * IR matched (i.e. identified by {@link ApplicableIRRulesParser}.\n@@ -39,1 +39,1 @@\n- * @see IREncodingParser\n+ * @see ApplicableIRRulesParser\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/CompileQueueMessages.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-import compiler.lib.ir_framework.driver.irmatching.parser.IREncodingParser;\n+import compiler.lib.ir_framework.driver.irmatching.parser.ApplicableIRRulesParser;\n@@ -37,1 +37,1 @@\n- * of all methods identified by {@link IREncodingParser}.\n+ * of all methods identified by {@link ApplicableIRRulesParser}.\n@@ -40,1 +40,1 @@\n- * @see IREncodingParser\n+ * @see ApplicableIRRulesParser\n@@ -50,2 +50,2 @@\n-     * Parse the hotspot_pid*.log file from the test VM. Read the ideal compile phase and PrintOptoAssembly outputs for\n-     * all methods defined by the IR encoding.\n+     * Parse the hotspot_pid*.log file from the Test VM. Read the ideal compile phase and PrintOptoAssembly outputs for\n+     * all methods defined by the Applicable IR Rules.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/irmatching\/parser\/hotspot\/HotSpotPidFileParser.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-            \/\/ Create default map and let the IR matcher report the format failures later in the driver VM.\n+            \/\/ Create default map and let the IR matcher report the format failures later in the Driver VM.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/CompilePhaseCollector.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,2 @@\n- * This class' main method is called from {@link TestFramework} and represents the so-called \"flag VM\". It uses the\n- * Whitebox API to determine the necessary additional flags to run the test VM (e.g. to do IR matching). It returns\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"Flag VM\". It uses the\n+ * Whitebox API to determine the necessary additional flags to run the Test VM (e.g. to do IR matching). It returns\n@@ -82,1 +82,1 @@\n-     * Main entry point of the flag VM.\n+     * Main entry point of the Flag VM.\n@@ -87,1 +87,1 @@\n-            System.out.println(\"FlagVM main() called. Prepare test VM flags to run class \" + testClassName);\n+            System.out.println(\"FlagVM main() called. Prepare Test VM flags to run class \" + testClassName);\n@@ -99,2 +99,2 @@\n-     * Emit test VM flags to the dedicated test VM flags file to parse them from the TestFramework \"driver\" VM again\n-     * which adds them to the test VM.\n+     * Emit Test VM flags to the dedicated Test VM flags file to parse them from the TestFramework Driver VM again\n+     * which adds them to the Test VM.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/flag\/FlagVM.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,2 @@\n- * Exception that is thrown by the test VM if no tests are run as a result of specifying {@code -DTest} and\/or\n- * {@code -DExclude} defining an empty set with the used test VM flags.\n+ * Exception that is thrown by the Test VM if no tests are run as a result of specifying {@code -DTest} and\/or\n+ * {@code -DExclude} defining an empty set with the used Test VM flags.\n@@ -32,1 +32,1 @@\n-     * Default constructor used by test VM\n+     * Default constructor used by Test VM\n@@ -37,1 +37,1 @@\n-     * Constructor used to eventually throw the exception in the driver VM.\n+     * Constructor used to eventually throw the exception in the Driver VM.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/NoTestsRunException.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Dedicated socket to send data from the flag and test VM back to the driver VM.\n+ * Dedicated socket to send data from the flag and Test VM back to the Driver VM.\n@@ -49,1 +49,1 @@\n-    \/\/ Static fields used for test VM only.\n+    \/\/ Static fields used for Test VM only.\n@@ -88,1 +88,1 @@\n-     * Waits for a client (created by flag or test VM) to connect. Return the messages received from the client.\n+     * Waits for a client (created by flag or Test VM) to connect. Return the messages received from the client.\n@@ -120,1 +120,1 @@\n-     * Only called by test VM to write to server socket.\n+     * Only called by Test VM to write to server socket.\n@@ -127,1 +127,1 @@\n-     * Only called by test VM to write to server socket.\n+     * Only called by Test VM to write to server socket.\n@@ -129,1 +129,1 @@\n-     * The test VM is spawned by the main jtreg VM. The stdout of the test VM is hidden\n+     * The Test VM is spawned by the main jtreg VM. The stdout of the Test VM is hidden\n@@ -131,1 +131,1 @@\n-     * VM and the test VM to communicate. By sending the prints through the TestFrameworkSocket with the\n+     * VM and the Test VM to communicate. By sending the prints through the TestFrameworkSocket with the\n@@ -140,2 +140,2 @@\n-        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or test VM \"\n-                                               + \"or method not called from flag or test VM\");\n+        TestFramework.check(SERVER_PORT != -1, \"Server port was not set correctly for flag and\/or Test VM \"\n+                                               + \"or method not called from flag or Test VM\");\n@@ -143,1 +143,1 @@\n-            \/\/ Keep the client socket open until the test VM terminates (calls closeClientSocket before exiting main()).\n+            \/\/ Keep the client socket open until the Test VM terminates (calls closeClientSocket before exiting main()).\n@@ -153,2 +153,2 @@\n-            \/\/ When the test VM is directly run, we should ignore all messages that would normally be sent to the\n-            \/\/ driver VM.\n+            \/\/ When the Test VM is directly run, we should ignore all messages that would normally be sent to the\n+            \/\/ Driver VM.\n@@ -157,1 +157,1 @@\n-                              Did you directly run the test VM (TestVM class)\n+                              Did you directly run the Test VM (TestVM class)\n@@ -172,1 +172,1 @@\n-     * the main() method of the flag and the test VM.\n+     * the main() method of the flag and the Test VM.\n@@ -186,1 +186,1 @@\n-     * Get the socket output of the flag VM.\n+     * Get the socket output of the Flag VM.\n@@ -200,1 +200,1 @@\n-     * Return whether test VM sent messages to be put on stdout (starting with {@link ::STDOUT_PREFIX}).\n+     * Return whether Test VM sent messages to be put on stdout (starting with {@link ::STDOUT_PREFIX}).\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/shared\/TestFrameworkSocket.java","additions":17,"deletions":17,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,3 +42,4 @@\n- * Prints an encoding to the dedicated test framework socket whether @IR rules of @Test methods should be applied or not.\n- * This is done during the execution of the test VM by checking the active VM flags. This encoding is eventually parsed\n- * and checked by the IRMatcher class in the driver VM after the termination of the test VM. IR rule indices start at 1.\n+ * Prints all applicable IR rules to the dedicated test framework socket whether @IR rules of @Test methods should be\n+ * applied or not. This is done during the execution of the Test VM by checking the active VM flags. This\n+ * Applicable IR Rules message is eventually parsed and checked by the IRMatcher class in the Driver VM after the\n+ * termination of the Test VM. IR rule indices start at 1.\n@@ -46,2 +47,2 @@\n-public class IREncodingPrinter {\n-    public static final String START = \"##### IRMatchRulesEncoding - used by TestFramework #####\";\n+public class ApplicableIRRulesPrinter {\n+    public static final String START = \"##### ApplicableIRRules - used by TestFramework #####\";\n@@ -63,1 +64,1 @@\n-    private static final List<String> irTestingPlatforms = new ArrayList<String>(Arrays.asList(\n+    private static final List<String> irTestingPlatforms = new ArrayList<>(Arrays.asList(\n@@ -88,1 +89,1 @@\n-    private static final List<String> verifiedCPUFeatures = new ArrayList<String>( Arrays.asList(\n+    private static final List<String> verifiedCPUFeatures = new ArrayList<>( Arrays.asList(\n@@ -129,1 +130,1 @@\n-    public IREncodingPrinter() {\n+    public ApplicableIRRulesPrinter() {\n@@ -139,1 +140,1 @@\n-    public void emitRuleEncoding(Method m, boolean skipped) {\n+    public void emitApplicableIRRules(Method m, boolean skipped) {\n@@ -173,1 +174,1 @@\n-                                  \"[IREncodingPrinter]\", true);\n+                                  \"[ApplicableIRRules]\", true);\n@@ -524,1 +525,1 @@\n-        TestFrameworkSocket.write(output.toString(), \"IR rule application encoding\");\n+        TestFrameworkSocket.write(output.toString(), \"ApplicableIRRules\");\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/ApplicableIRRulesPrinter.java","additions":13,"deletions":12,"binary":false,"changes":25,"previous_filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/IREncodingPrinter.java","status":"renamed"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * This class' main method is called from {@link TestFramework} and represents the so-called \"test VM\". The class is\n+ * This class' main method is called from {@link TestFramework} and represents the so-called \"Test VM\". The class is\n@@ -61,1 +61,1 @@\n-                                - Are you rerunning the test VM (TestVM class)\n+                                - Are you rerunning the Test VM (TestVM class)\n@@ -103,1 +103,1 @@\n-    \/\/ Use separate flag as VERIFY_IR could have been set by user but due to other flags it was disabled by flag VM.\n+    \/\/ Use separate flag as VERIFY_IR could have been set by user but due to other flags it was disabled by Flag VM.\n@@ -117,1 +117,1 @@\n-    private final IREncodingPrinter irMatchRulePrinter;\n+    private final ApplicableIRRulesPrinter irMatchRulePrinter;\n@@ -128,1 +128,1 @@\n-            irMatchRulePrinter = new IREncodingPrinter();\n+            irMatchRulePrinter = new ApplicableIRRulesPrinter();\n@@ -158,1 +158,1 @@\n-     * Main entry point of the test VM.\n+     * Main entry point of the Test VM.\n@@ -296,1 +296,1 @@\n-                        irMatchRulePrinter.emitRuleEncoding(m, baseTest.isSkipped());\n+                        irMatchRulePrinter.emitApplicableIRRules(m, baseTest.isSkipped());\n@@ -690,1 +690,1 @@\n-            irMatchRulePrinter.emitRuleEncoding(testMethod, checkedTest.isSkipped());\n+            irMatchRulePrinter.emitApplicableIRRules(testMethod, checkedTest.isSkipped());\n@@ -758,1 +758,1 @@\n-            tests.forEach(test -> irMatchRulePrinter.emitRuleEncoding(test.getTestMethod(), customRunTest.isSkipped()));\n+            tests.forEach(test -> irMatchRulePrinter.emitApplicableIRRules(test.getTestMethod(), customRunTest.isSkipped()));\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/TestVM.java","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n- * Prints some test VM info to the socket.\n+ * Prints some Test VM info to the socket.\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/test\/VMInfoPrinter.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @summary Test IR matcher with different default IR node regexes. Use -DPrintIREncoding.\n+ * @summary Test IR matcher with different default IR node regexes. Use -DPrintApplicableIRRules.\n@@ -47,1 +47,1 @@\n- *                               -XX:+WhiteBoxAPI -DPrintIREncoding=true  ir_framework.tests.TestIRMatching\n+ *                               -XX:+WhiteBoxAPI -DPrintApplicableIRRules=true  ir_framework.tests.TestIRMatching\n@@ -443,1 +443,2 @@\n-            addException(new RuntimeException(\"Could not find encoding: \\\"\" + builder + System.lineSeparator()));\n+            addException(new RuntimeException(\"Could not find line in Applicable IR Rules: \\\"\" + builder +\n+                                                      System.lineSeparator()));\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestIRMatching.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2026, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,1 +73,1 @@\n-                                                             testVMProcess.getIrEncoding());\n+                                                             testVMProcess.getApplicableIRRules());\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"}]}