{"files":[{"patch":"@@ -2007,4 +2007,5 @@\n-        \"The target VM may not support, or may only provide limited support, for \"\n-        \"this command when the thread is a virtual thread. It may, for example, \"\n-        \"only support this command when the virtual thread is suspended at a \"\n-        \"breakpoint or singlestep event.\"\n+        \"This command may be used to send an asynchronous \"\n+        \"exception to a virtual thread when it is suspended at an event. \"\n+        \"An implementation may support sending an asynchronous exception \"\n+        \"to a suspended virtual thread in other cases.\"\n+\n@@ -2021,2 +2022,4 @@\n-            (Error NOT_IMPLEMENTED \"The thread is a virtual thread and the target \"\n-                                  \"VM does not support the command on virtual threads.\")\n+            (Error THREAD_NOT_SUSPENDED \"The thread is a virtual thread and was not suspended.\")\n+            (Error OPAQUE_FRAME   \"The thread is a suspended virtual thread and the implementation \"\n+                                  \"was unable to throw an asynchronous exception \"\n+                                  \"from the current frame.\")\n@@ -3169,1 +3172,1 @@\n-                                          \"to perform an operation on the frame.\")\n+                                          \"to perform an operation on the thread's current frame.\")\n","filename":"src\/java.se\/share\/data\/jdwp\/jdwp.spec","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -119,4 +119,5 @@\n-     * The target VM may not support, or may only provide limited support,\n-     * for stopping a virtual thread with an asynchronous exception. It may,\n-     * for example, only support this operation when the virtual thread is\n-     * suspended at a breakpoint or singlestep event.\n+     * This method may be used to send an asynchronous\n+     * exception to a virtual thread when it is suspended at an event.\n+     * An implementation may support sending an asynchronous exception\n+     * to a suspended virtual thread in other cases.\n+\n@@ -127,4 +128,5 @@\n-     * @throws IllegalThreadStateException if the thread has terminated\n-     * @throws UnsupportedOperationException if the thread is a virtual\n-     * thread and the target VM does not support this operation on\n-     * virtual threads\n+     * @throws IllegalThreadStateException if the thread has terminated,\n+     * or if the thread is a virtual thread and was not suspended\n+     * @throws OpaqueFrameException if the thread is a suspended\n+     * virtual thread and the implementation was unable to throw an\n+     * asynchronous exception from the current frame\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/jdi\/ThreadReference.java","additions":10,"deletions":8,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -722,3 +722,7 @@\n-                MessageOutput.println(\"Illegal thread state\");\n-            } catch (UnsupportedOperationException uoe) {\n-                MessageOutput.println(\"Operation is not supported on the target VM\");\n+                if (!thread.isSuspended() && thread.isVirtual()) {\n+                    MessageOutput.println(\"Illegal thread state (virtual thread not suspended)\");\n+                } else {\n+                    MessageOutput.println(\"Illegal thread state\");\n+                }\n+            } catch (OpaqueFrameException ope) {\n+                MessageOutput.println(\"Operation is not supported on the current frame\");\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/Commands.java","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -145,0 +145,1 @@\n+        {\"Illegal thread state (virtual thread not suspended)\", \"Illegal thread state (virtual thread not suspended)\"},\n@@ -247,1 +248,1 @@\n-        {\"Operation is not supported on the target VM\", \"Operation is not supported on the target VM\"},\n+        {\"Operation is not supported on the current frame\", \"Operation is not supported on the current frame\"},\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/example\/debug\/tty\/TTYResources.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -276,1 +276,12 @@\n-            throw exc.toJDIException();\n+            switch (exc.errorCode()) {\n+            case JDWP.Error.OPAQUE_FRAME:\n+                assert isVirtual(); \/\/ can only happen with virtual threads\n+                throw new OpaqueFrameException();\n+            case JDWP.Error.THREAD_NOT_SUSPENDED:\n+                assert isVirtual(); \/\/ can only happen with virtual threads\n+                throw new IllegalThreadStateException(\"virtual thread not suspended\");\n+            case JDWP.Error.INVALID_THREAD:\n+                throw new IllegalThreadStateException(\"thread has terminated\");\n+            default:\n+                throw exc.toJDIException();\n+            }\n","filename":"src\/jdk.jdi\/share\/classes\/com\/sun\/tools\/jdi\/ThreadReferenceImpl.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,5 +38,2 @@\n- * The test checks that the JDI method:<br>\n- * <code>com.sun.jdi.ThreadReference.stop()<\/code><br>\n- * properly throws <i>InvalidTypeException<\/i> - if specified\n- * throwable is not an instance of java.lang.Throwable in the\n- * target VM.<p>\n+ * The test checks that the JDI method:<br><code>com.sun.jdi.ThreadReference.stop()<\/code><br>\n+ * behaves properly in various situations. It consists of 5 subtests.\n@@ -44,4 +41,12 @@\n- * Debugger part of the test tries to stop debuggee thread\n- * through the JDI method using as a parameter an object\n- * reference of the main debuggee class <i>stop002t<\/i> itself\n- * which is not <code>Throwable<\/code>.\n+ * TEST #1: Tests that stop() properly throws <i>InvalidTypeException<\/i> if\n+ * specified throwable is not an instance of java.lang.Throwable in the target VM.<p>\n+ *\n+ * TEST #2: Verify that stop() works when suspended at a breakpoint.\n+ *\n+ * TEST #3: Verify that stop() works when not suspended in a loop. For virtual threads\n+ * we expect an IncompatibleThreadStateException.\n+ *\n+ * TEST #4: Verify that stop() works when suspended in a loop.\n+ *\n+ * TEST #5: Verify that stop() works when suspended in Thread.sleep(). For virtual\n+ * threads we expect an OpaqueFrameException.\n@@ -57,3 +62,6 @@\n-    static final String DEBUGGEE_LOCALVAR = \"stop002tNonThrowable\";\n-    \/\/ debuggee field used to indicate that testing is over\n-    static final String DEBUGGEE_FIELD = \"stopLooping\";\n+    static final String DEBUGGEE_NON_THROWABLE_VAR= \"stop002tNonThrowable\";\n+    \/\/ debuggee local var used to find needed throwable object\n+    static final String DEBUGGEE_THROWABLE_VAR = \"stop002tThrowable\";\n+    \/\/ debuggee fields used to indicate to exit infinite loops\n+    static final String DEBUGGEE_STOP_LOOP1_FIELD = \"stopLooping1\";\n+    static final String DEBUGGEE_STOP_LOOP2_FIELD = \"stopLooping2\";\n@@ -62,1 +70,1 @@\n-    static final int DEBUGGEE_STOPATLINE = 69;\n+    static final int DEBUGGEE_STOPATLINE = 88;\n@@ -70,0 +78,2 @@\n+    static final boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n+\n@@ -76,0 +86,1 @@\n+    private ReferenceType mainClass;\n@@ -104,3 +115,2 @@\n-        ThreadReference thrRef = null;\n-        if ((thrRef =\n-                debuggee.threadByName(DEBUGGEE_THRNAME)) == null) {\n+        ThreadReference thrRef = debuggee.threadByName(DEBUGGEE_THRNAME);\n+        if (thrRef == null) {\n@@ -113,1 +123,2 @@\n-        Field doExit = null;\n+        Field stopLoop1 = null;\n+        Field stopLoop2 = null;\n@@ -115,0 +126,1 @@\n+        ObjectReference throwableRef = null;\n@@ -117,1 +129,1 @@\n-            ReferenceType rType = debuggee.classByName(DEBUGGEE_CLASS);\n+            mainClass = debuggee.classByName(DEBUGGEE_CLASS);\n@@ -119,2 +131,3 @@\n-            suspendAtBP(rType, DEBUGGEE_STOPATLINE);\n-            objRef = findObjRef(thrRef, DEBUGGEE_LOCALVAR);\n+            suspendAtBP(mainClass, DEBUGGEE_STOPATLINE);\n+            objRef = findObjRef(thrRef, DEBUGGEE_NON_THROWABLE_VAR);\n+            throwableRef = findObjRef(thrRef, DEBUGGEE_THROWABLE_VAR);\n@@ -122,3 +135,6 @@\n-            \/\/ this field is used to indicate that debuggee has to\n-            \/\/ stop looping\n-            doExit = rType.fieldByName(DEBUGGEE_FIELD);\n+            \/\/ These fields are used to indicate that debuggee has to stop looping\n+            stopLoop1 = mainClass.fieldByName(DEBUGGEE_STOP_LOOP1_FIELD);\n+            stopLoop2 = mainClass.fieldByName(DEBUGGEE_STOP_LOOP2_FIELD);\n+            if (stopLoop1 == null || stopLoop2 == null) {\n+                throw new RuntimeException(\"Failed to find a \\\"stop loop\\\" field\");\n+            }\n@@ -126,3 +142,3 @@\n-            log.display(\"Resuming debuggee VM ...\");\n-            vm.resume();\n-            log.display(\"Resumption of debuggee VM done\");\n+            log.display(\"non-throwable object: \\\"\" + objRef + \"\\\"\");\n+            log.display(\"throwable object:     \\\"\" + throwableRef + \"\\\"\");\n+            log.display(\"debuggee thread:      \\\"\" + thrRef + \"\\\"\");\n@@ -130,3 +146,16 @@\n-            log.display(\"\\nTrying to stop debuggee thread \\\"\" + thrRef\n-                + \"\\\"\\n\\tusing non-throwable object reference \\\"\"\n-                + objRef + \"\\\" as a parameter ...\");\n+            \/*\n+             * Test #1: verify using a non-throwable object with stop() fails appropriately.\n+             *\/\n+            log.display(\"\\nTEST #1: Trying to stop debuggee thread using non-throwable object.\");\n+            try {\n+                thrRef.stop(objRef); \/\/ objRef is an instance of the debuggee class, not a Throwable\n+                log.complain(\"TEST #1 FAILED: expected InvalidTypeException was not thrown\");\n+                tot_res = Consts.TEST_FAILED;\n+            } catch (InvalidTypeException ee) {\n+                log.display(\"TEST #1 PASSED: caught expected \" + ee);\n+            } catch (Exception ue) {\n+                ue.printStackTrace();\n+                log.complain(\"TEST #1 FAILED: caught unexpected \" + ue + \"instead of InvalidTypeException\");\n+                tot_res = Consts.TEST_FAILED;\n+            }\n+            log.display(\"TEST #1: all done.\");\n@@ -134,1 +163,4 @@\n-\/\/ Check the tested assersion\n+            \/*\n+             * Test #2: verify that stop() works when suspended at a breakpoint.\n+             *\/\n+            log.display(\"\\nTEST #2: Trying to stop debuggee thread while suspended at a breakpoint.\");\n@@ -136,5 +168,5 @@\n-                thrRef.stop(objRef);\n-                log.complain(\"TEST FAILED: expected IllegalArgumentException was not thrown\"\n-                    + \"\\n\\twhen attempted to stop debuggee thread \\\"\" + thrRef\n-                    + \"\\\"\\n\\tusing non-throwable object reference \\\"\"\n-                    + objRef + \"\\\" as a parameter\");\n+                thrRef.stop(throwableRef);\n+                log.display(\"TEST #2 PASSED: stop() call succeeded.\");\n+            } catch (Exception ue) {\n+                ue.printStackTrace();\n+                log.complain(\"TEST #2 FAILED: caught unexpected \" + ue);\n@@ -142,3 +174,48 @@\n-            } catch(InvalidTypeException ee) {\n-                log.display(\"CHECK PASSED: caught expected \" + ee);\n-            } catch(Exception ue) {\n+            }\n+            log.display(\"TEST #2: Resuming debuggee VM to allow async exception to be handled\");\n+            vm.resume();\n+            log.display(\"TEST #2: all done.\");\n+\n+            \/*\n+             * Test #3: verify that stop() works when not suspended in a loop. Expect\n+             * IllegalThreadStateException for virtual threads.\n+             *\/\n+            log.display(\"\\nTEST #3: Trying to stop debuggee thread while not suspended in a loop.\");\n+            waitForTestReady(3);\n+            try {\n+                thrRef.stop(throwableRef);\n+                if (vthreadMode) {\n+                    log.complain(\"TEST #3 FAILED: expected IllegalThreadStateException\"\n+                                 + \" was not thrown for virtual thread\");\n+                    tot_res = Consts.TEST_FAILED;\n+                } else {\n+                    log.display(\"TEST #3 PASSED: stop() call succeeded.\");\n+                }\n+            } catch (Exception ue) {\n+                if (vthreadMode && ue instanceof IllegalThreadStateException) {\n+                    log.display(\"TEST #3 PASSED: stop() call threw IllegalThreadStateException\"\n+                                + \" for virtual thread\");\n+                } else {\n+                    ue.printStackTrace();\n+                    log.complain(\"TEST #3 FAILED: caught unexpected \" + ue);\n+                    tot_res = Consts.TEST_FAILED;\n+                }\n+            } finally {\n+                \/\/ Force the debuggee out of the loop. Not really needed if the stop() call\n+                \/\/ successfully threw the async exception, but it's easier to just always do this.\n+                log.display(\"TEST #3: clearing loop flag.\");\n+                objRef.setValue(stopLoop1, vm.mirrorOf(true));\n+            }\n+            log.display(\"TEST #3: all done.\");\n+\n+            \/*\n+             * Test #4: verify that stop() works when suspended in a loop\n+             *\/\n+            log.display(\"\\nTEST #4: Trying to stop debuggee thread while suspended in a loop.\");\n+            waitForTestReady(4);\n+            try {\n+                thrRef.suspend();\n+                log.display(\"TEST #4: thread is suspended.\");\n+                thrRef.stop(throwableRef);\n+                log.display(\"TEST #4 PASSED: stop() call succeeded.\");\n+            } catch (Throwable ue) {\n@@ -146,5 +223,1 @@\n-                log.complain(\"TEST FAILED: ThreadReference.stop(): caught unexpected \"\n-                    + ue + \"\\n\\tinstead of InvalidTypeException\"\n-                    + \"\\n\\twhen attempted to stop debuggee thread \\\"\" + thrRef\n-                    + \"\\\"\\n\\tusing non-throwable object reference \\\"\"\n-                    + objRef + \"\\\" as a parameter\");\n+                log.complain(\"TEST #4 FAILED: caught unexpected \" + ue);\n@@ -152,0 +225,7 @@\n+            } finally {\n+                log.display(\"TEST #4: resuming thread.\");\n+                thrRef.resume();\n+                \/\/ Force the debuggee out of the loop. Not really needed if the stop() call\n+                \/\/ successfully threw the async exception, but it's easier to just always do this.\n+                log.display(\"TEST #4: clearing loop flag.\");\n+                objRef.setValue(stopLoop2, vm.mirrorOf(true));\n@@ -153,0 +233,1 @@\n+            log.display(\"TEST #4: all done.\");\n@@ -154,0 +235,41 @@\n+            \/*\n+             * Test #5: verify that stop() works when suspended in Thread.sleep(). Expect\n+             * OpaqueFrameException for virtual threads.\n+             *\/\n+            log.display(\"\\nTEST #5: Trying to stop debuggee thread while suspended in Thread.sleep().\");\n+            waitForTestReady(5);\n+            \/\/ Allow debuggee to reach Thread.sleep() first.\n+            log.display(\"TEST #5: waiting for debuggee to sleep...\");\n+            while (true) {\n+                int status = thrRef.status();\n+                if (status == ThreadReference.THREAD_STATUS_SLEEPING ||\n+                    status == ThreadReference.THREAD_STATUS_WAIT)\n+                {\n+                    break;\n+                }\n+                Thread.sleep(50);\n+            }\n+            log.display(\"TEST #5: debuggee is sleeping.\");\n+            try {\n+                thrRef.suspend();\n+                log.display(\"TEST #5: thread is suspended.\");\n+                thrRef.stop(throwableRef);\n+                if (vthreadMode) {\n+                    log.complain(\"TEST #5 FAILED: expected OpaqueFrameException was not thrown\");\n+                    tot_res = Consts.TEST_FAILED;\n+                } else {\n+                    log.display(\"TEST #5 PASSED: stop() call for suspended thread succeeded\");\n+                }\n+            } catch (Throwable ue) {\n+                if (vthreadMode && ue instanceof OpaqueFrameException) {\n+                    log.display(\"TEST #5 PASSED: stop() call threw OpaqueFrameException for virtual thread\");\n+                } else {\n+                    ue.printStackTrace();\n+                    log.complain(\"TEST #5 FAILED: caught unexpected \" + ue);\n+                    tot_res = Consts.TEST_FAILED;\n+                }\n+            } finally {\n+                log.display(\"TEST #5: resuming thread.\");\n+                thrRef.resume();\n+            }\n+            log.display(\"TEST #5: all done.\");\n@@ -159,3 +281,2 @@\n-\/\/ Finish the test\n-            \/\/ force an method to exit\n-            if (objRef != null && doExit != null) {\n+            \/\/ Force the debuggee out of both loops\n+            if (objRef != null && stopLoop1 != null && stopLoop2 != null) {\n@@ -163,2 +284,3 @@\n-                    objRef.setValue(doExit, vm.mirrorOf(true));\n-                } catch(Exception sve) {\n+                    objRef.setValue(stopLoop1, vm.mirrorOf(true));\n+                    objRef.setValue(stopLoop2, vm.mirrorOf(true));\n+                } catch (Exception sve) {\n@@ -166,0 +288,1 @@\n+                    tot_res = Consts.TEST_FAILED;\n@@ -173,0 +296,9 @@\n+    private void waitForTestReady(int testNum) {\n+        log.display(\"TEST #\" + testNum + \": waiting for test ready...\");\n+        IntegerValue ival;\n+        do {\n+            ival = (IntegerValue)mainClass.getValue(mainClass.fieldByName(\"testNumReady\"));\n+        } while (ival.value() != testNum);\n+        log.display(\"TEST #\" + testNum + \": test ready.\");\n+    }\n+\n@@ -187,1 +319,1 @@\n-                } catch(AbsentInformationException e) {\n+                } catch (AbsentInformationException e) {\n@@ -189,1 +321,1 @@\n-                } catch(NativeMethodException ne) {\n+                } catch (NativeMethodException ne) {\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/stop\/stop002.java","additions":183,"deletions":51,"binary":false,"changes":234,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,4 @@\n-    volatile boolean stopLooping = false;\n+    volatile boolean stopLooping1 = false;\n+    volatile boolean stopLooping2 = false;\n+    volatile static int testNumReady = 0;\n+    static final boolean vthreadMode = \"Virtual\".equals(System.getProperty(\"main.wrapper\"));\n@@ -60,0 +63,4 @@\n+        \/\/ throwable object which will be used by debugger\n+        \/\/ as valid parameter of JDI method ThreadReference.stop()\n+        Throwable stop002tThrowable = new MyThrowable(\"Async exception\");\n+\n@@ -64,1 +71,1 @@\n-            log.complain(\"Debuggee: exiting due to the command \"\n+            log.complain(\"Debuggee: premature debuggee exit due to the command \"\n@@ -66,1 +73,1 @@\n-            return Consts.TEST_PASSED;\n+            return Consts.TEST_FAILED;\n@@ -69,1 +76,6 @@\n-        int stopMeHere = 0; \/\/ stop002.DEBUGGEE_STOPATLINE\n+        \/*\n+         * TEST #1: Tests that stop() properly throws InvalidTypeException if\n+         * the specified throwable is not an instance of java.lang.Throwable\n+         * in the debuggee. It does not involve the debuggee at all, so there\n+         * is no code here for it.\n+         *\/\n@@ -71,3 +83,18 @@\n-        log.display(\"Debuggee: going to loop ...\");\n-        while(!stopLooping) { \/\/ looping\n-            stopMeHere++; stopMeHere--;\n+        \/*\n+         * TEST #2: async exception while suspended at a breakpoint.\n+         *\/\n+        int stopMeHere = 0;\n+        try {\n+            stopMeHere = 1; \/\/ stop002.DEBUGGEE_STOPATLINE\n+            log.complain(\"TEST #2: Failed to throw expected exception\");\n+            return Consts.TEST_FAILED;\n+        } catch (Throwable t) {\n+            \/\/ Call Thread.interrupted(). Workaround for JDK-8306324\n+            log.display(\"TEST #2: interrupted = \" + Thread.interrupted());\n+            if (t instanceof MyThrowable) {\n+                log.display(\"TEST #2: Caught expected exception while at breakpoint: \" + t);\n+            } else {\n+                log.complain(\"TEST #2: Unexpected exception caught: \" + t);\n+                t.printStackTrace();\n+                return Consts.TEST_FAILED;\n+            }\n@@ -75,1 +102,1 @@\n-        log.display(\"Debuggee: looping done\");\n+        log.display(\"TEST #2: all done\");\n@@ -77,0 +104,91 @@\n+        \/*\n+         * TEST #3: async exception while not suspended in a loop.\n+         *\/\n+        log.display(\"TEST #3: going to loop ...\");\n+        try {\n+            while (!stopLooping1) { \/\/ looping\n+                testNumReady = 3; \/\/ signal debugger side of test that we are ready\n+                stopMeHere++; stopMeHere--;\n+            }\n+            if (vthreadMode) {\n+                log.display(\"TEST #3: Correctly did not throw async exception for virtual thread\");\n+            } else {\n+                log.complain(\"TEST #3: Failed to throw expected exception\");\n+                return Consts.TEST_FAILED;\n+            }\n+        } catch (Throwable t) {\n+            \/\/ Call Thread.interrupted(). Workaround for JDK-8306324\n+            log.display(\"TEST #3: interrupted = \" + Thread.interrupted());\n+            \/\/ We don't expect the exception to be thrown when in vthread mode.\n+            if (!vthreadMode && t instanceof MyThrowable) {\n+                log.display(\"TEST #3: Caught expected exception while in loop: \" + t);\n+            } else {\n+                log.complain(\"TEST #3: Unexpected exception caught: \" + t);\n+                t.printStackTrace();\n+                return Consts.TEST_FAILED;\n+            }\n+        }\n+        log.display(\"TEST #3: all done\");\n+\n+        \/*\n+         * TEST #4: async exception while suspended in a loop.\n+         *\/\n+        log.display(\"TEST #4: going to loop ...\");\n+        try {\n+            while (!stopLooping2) { \/\/ looping\n+                testNumReady = 4; \/\/ signal debugger side of test that we are ready\n+                stopMeHere++; stopMeHere--;\n+            }\n+            log.complain(\"TEST #4: Failed to throw expected exception\");\n+            return Consts.TEST_FAILED;\n+        } catch (Throwable t) {\n+            \/\/ Call Thread.interrupted(). Workaround for JDK-8306324\n+            log.display(\"TEST #4: interrupted = \" + Thread.interrupted());\n+            if (t instanceof MyThrowable) {\n+                log.display(\"TEST #4: Caught expected exception while in loop: \" + t);\n+            } else {\n+                log.complain(\"TEST #4: Unexpected exception caught: \" + t);\n+                t.printStackTrace();\n+                return Consts.TEST_FAILED;\n+            }\n+        }\n+        log.display(\"TEST #4: all done\");\n+\n+        \/*\n+         * TEST #5: async exception while suspended doing Thread.sleep().\n+         *\/\n+        try {\n+            try {\n+                \/\/ Signal debugger side of test that we are \"almost\" ready. The\n+                \/\/ debugger will still need to check that we are in the sleep state.\n+                testNumReady = 5;\n+                log.display(\"TEST #5: going to sleep ...\");\n+                Thread.sleep(10000);\n+            } catch (InterruptedException e) {\n+                log.complain(\"TEST #5: Unexpected InterruptedException\");\n+                e.printStackTrace();\n+                return Consts.TEST_FAILED;\n+            }\n+            if (vthreadMode) {\n+                log.display(\"TEST #5: Correctly did not throw exception while in sleep\");\n+            } else {\n+                log.complain(\"TEST #5: Failed to throw expected exception\");\n+                return Consts.TEST_FAILED;\n+            }\n+        } catch (Throwable t) {\n+            \/\/ Call Thread.interrupted(). Workaround for JDK-8306324\n+            log.display(\"TEST #5: interrupted = \" + Thread.interrupted());\n+            \/\/ We don't expect the exception to be thrown when in vthread mode.\n+            if (!vthreadMode && t instanceof MyThrowable) {\n+                log.display(\"TEST #5: Caught expected exception while in loop: \" + t);\n+            } else {\n+                log.complain(\"TEST #5: Unexpected exception caught: \" + t);\n+                t.printStackTrace();\n+                return Consts.TEST_FAILED;\n+            }\n+        }\n+        log.display(\"TEST #5: all done\");\n+\n+        \/*\n+         * Test shutdown.\n+         *\/\n@@ -86,0 +204,7 @@\n+\n+class MyThrowable extends Throwable\n+{\n+    MyThrowable(String message) {\n+        super(message);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdi\/ThreadReference\/stop\/stop002t.java","additions":134,"deletions":9,"binary":false,"changes":143,"status":"modified"}]}