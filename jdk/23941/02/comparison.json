{"files":[{"patch":"@@ -4504,1 +4504,1 @@\n-void PhaseIdealLoop::eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates) {\n+void PhaseIdealLoop::eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates) const {\n@@ -4509,2 +4509,1 @@\n-      ConINode* one = intcon(1);\n-      _igvn.replace_node(opaque_node, one);\n+      opaque_node->mark_useless(_igvn);\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1456,1 +1456,1 @@\n-  void eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates);\n+  void eliminate_useless_template_assertion_predicates(Unique_Node_List& useful_predicates) const;\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -110,7 +110,4 @@\n-  if (phase->C->post_loop_opts_phase()) {\n-    \/\/ Template Assertion Predicates only serve as templates to create Initialized Assertion Predicates when splitting\n-    \/\/ a loop during loop opts. They are not used anymore once loop opts are over and can then be removed. They feed\n-    \/\/ into the bool input of an If node and can thus be replaced by true to let the Template Assertion Predicate be\n-    \/\/ folded away (the success path is always the true path by design).\n-    return phase->intcon(1);\n-  } else {\n+  if (!phase->C->post_loop_opts_phase()) {\n+    \/\/ Record Template Assertion Predicates for post loop opts IGVN. We can remove them when there is no more loop\n+    \/\/ splitting possible. This also means that we do not create any new Initialized Assertion Predicates created from\n+    \/\/ these templates.\n@@ -123,0 +120,8 @@\n+  if (_useless || phase->C->post_loop_opts_phase()) {\n+    \/\/ Template Assertion Predicates only serve as templates to create Initialized Assertion Predicates when splitting\n+    \/\/ a loop during loop opts. They are not used anymore once loop opts are over and can then be removed. They feed\n+    \/\/ into the bool input of an If node and can thus be replaced by the success path to let the Template Assertion\n+    \/\/ Predicate be folded away (the success path is always the true path by design). We can also fold the Template\n+    \/\/ Assertion Predicate away when it's found to be useless and not used anymore.\n+    return TypeInt::ONE;\n+  }\n@@ -126,0 +131,13 @@\n+void OpaqueTemplateAssertionPredicateNode::mark_useless(PhaseIterGVN& igvn) {\n+  _useless = true;\n+  igvn._worklist.push(this);\n+}\n+\n+#ifndef PRODUCT\n+void OpaqueTemplateAssertionPredicateNode::dump_spec(outputStream* st) const {\n+  if (_useless) {\n+    st->print(\"#useless \");\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n+\n@@ -127,0 +145,3 @@\n+  if (_useless) {\n+    return TypeInt::ONE;\n+  }\n@@ -130,1 +151,12 @@\n-\/\/=============================================================================\n+void OpaqueInitializedAssertionPredicateNode::mark_useless(PhaseIterGVN& igvn) {\n+  _useless = true;\n+  igvn._worklist.push(this);\n+}\n+\n+#ifndef PRODUCT\n+void OpaqueInitializedAssertionPredicateNode::dump_spec(outputStream* st) const {\n+  if (_useless) {\n+    st->print(\"#useless \");\n+  }\n+}\n+#endif \/\/ NOT PRODUCT\n","filename":"src\/hotspot\/share\/opto\/opaquenode.cpp","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n@@ -155,0 +155,11 @@\n+  \/\/ When splitting a loop or when the associated loop dies, the Template Assertion Predicate with this\n+  \/\/ OpaqueTemplateAssertionPredicateNode also needs to be removed. We set this flag and then clean this node up in the\n+  \/\/ next IGVN phase by checking this flag in Value().\n+  bool _useless;\n+\n+  \/\/ OpaqueTemplateAssertionPredicateNodes are unique to a Template Assertion Predicate expression and should never\n+  \/\/ common up. We still make sure of that by returning NO_HASH here.\n+  virtual uint hash() const {\n+    return NO_HASH;\n+  }\n+\n@@ -156,1 +167,2 @@\n-  OpaqueTemplateAssertionPredicateNode(BoolNode* bol) : Node(nullptr, bol) {\n+  OpaqueTemplateAssertionPredicateNode(BoolNode* bol) : Node(nullptr, bol),\n+      _useless(false) {\n@@ -161,0 +173,1 @@\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -164,0 +177,7 @@\n+\n+  bool is_useless() const {\n+    return _useless;\n+  }\n+\n+  void mark_useless(PhaseIterGVN& igvn);\n+  NOT_PRODUCT(void dump_spec(outputStream* st) const);\n@@ -167,1 +187,1 @@\n-\/\/ to true. During  macro expansion, we replace the OpaqueInitializedAssertionPredicateNodes with true in product builds\n+\/\/ to true. During macro expansion, we replace the OpaqueInitializedAssertionPredicateNodes with true in product builds\n@@ -172,0 +192,10 @@\n+  \/\/ When updating a loop in Loop Unrolling, we forcefully kill old Initialized Assertion Predicates. We set this flag\n+  \/\/ and then clean this node up in the next IGVN phase by checking this flag in Value().\n+  bool _useless;\n+\n+  \/\/ OpaqueInitializedAssertionPredicateNode are unique to an Initialized Assertion Predicate expression and should never\n+  \/\/ common up. Thus, we return NO_HASH here.\n+  virtual uint hash() const {\n+    return NO_HASH;\n+  }\n+\n@@ -173,1 +203,2 @@\n-  OpaqueInitializedAssertionPredicateNode(BoolNode* bol, Compile* C) : Node(nullptr, bol) {\n+  OpaqueInitializedAssertionPredicateNode(BoolNode* bol, Compile* C) : Node(nullptr, bol),\n+      _useless(false) {\n@@ -180,0 +211,1 @@\n+  virtual uint size_of() const { return sizeof(*this); }\n@@ -182,0 +214,7 @@\n+\n+  bool is_useless() const {\n+    return _useless;\n+  }\n+\n+  void mark_useless(PhaseIterGVN& igvn);\n+  NOT_PRODUCT(void dump_spec(outputStream* st) const);\n","filename":"src\/hotspot\/share\/opto\/opaquenode.hpp","additions":43,"deletions":4,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -223,4 +223,4 @@\n-\/\/ Kills the Template Assertion Predicate by setting the condition to true. Will be folded away in the next IGVN round.\n-void TemplateAssertionPredicate::kill(PhaseIdealLoop* phase) const {\n-  ConINode* true_con = phase->intcon(1);\n-  phase->igvn().replace_input_of(_if_node, 1, true_con);\n+\/\/ Kills this Template Assertion Predicate by marking the associated OpaqueTemplateAssertionPredicate node useless.\n+\/\/ It will then be folded away in the next IGVN round.\n+void TemplateAssertionPredicate::kill(PhaseIterGVN& igvn) const {\n+  opaque_node()->mark_useless(igvn);\n@@ -306,3 +306,4 @@\n-void InitializedAssertionPredicate::kill(PhaseIdealLoop* phase) const {\n-  Node* true_con = phase->intcon(1);\n-  phase->igvn().replace_input_of(_if_node, 1, true_con);\n+\/\/ Kills this Initialized Assertion Predicate by marking the associated OpaqueInitializedAssertionPredicate node useless.\n+\/\/ It will then be folded away in the next IGVN round.\n+void InitializedAssertionPredicate::kill(PhaseIterGVN& igvn) const {\n+  opaque_node()->mark_useless(igvn);\n@@ -1087,1 +1088,1 @@\n-  template_assertion_predicate.kill(_phase);\n+  template_assertion_predicate.kill(_phase->igvn());\n@@ -1104,0 +1105,10 @@\n+\/\/ Kill the old Initialized Assertion Predicates with old strides before unrolling. The new Initialized Assertion\n+\/\/ Predicates are inserted after the Template Assertion Predicate which ensures that we are not accidentally visiting\n+\/\/ and killing a newly created Initialized Assertion Predicate here.\n+void UpdateStrideForAssertionPredicates::visit(const InitializedAssertionPredicate& initialized_assertion_predicate) {\n+  if (initialized_assertion_predicate.is_last_value()) {\n+    \/\/ Only Last Value Initialized Assertion Predicates need to be killed and updated.\n+    initialized_assertion_predicate.kill(_phase->igvn());\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/predicates.cpp","additions":19,"deletions":8,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -406,0 +406,4 @@\n+  bool is_useless() const {\n+    return opaque_node()->is_useless();\n+  }\n+\n@@ -413,2 +417,2 @@\n-  void kill(PhaseIdealLoop* phase) const;\n-  static bool is_predicate(const Node* node);\n+  void kill(PhaseIterGVN& igvn) const;\n+  static bool is_predicate(const Node* maybe_success_proj);\n@@ -459,2 +463,6 @@\n-  void kill(PhaseIdealLoop* phase) const;\n-  static bool is_predicate(const Node* node);\n+  bool is_useless() const {\n+    return opaque_node()->is_useless();\n+  }\n+\n+  void kill(PhaseIterGVN& igvn) const;\n+  static bool is_predicate(const Node* maybe_success_proj);\n@@ -655,1 +663,1 @@\n-  Node* const _start_node;\n+  Node* _current_node;\n@@ -660,1 +668,1 @@\n-      : _start_node(start_node),\n+      : _current_node(start_node),\n@@ -665,1 +673,1 @@\n-  Node* skip_all() const {\n+  Node* skip_all() {\n@@ -672,2 +680,1 @@\n-  Node* for_each(PredicateVisitor& predicate_visitor) const {\n-    Node* current = _start_node;\n+  Node* for_each(PredicateVisitor& predicate_visitor) {\n@@ -675,15 +682,10 @@\n-      if (TemplateAssertionPredicate::is_predicate(current)) {\n-        TemplateAssertionPredicate template_assertion_predicate(current->as_IfTrue());\n-        predicate_visitor.visit(template_assertion_predicate);\n-        current = template_assertion_predicate.entry();\n-      } else if (RuntimePredicate::is_predicate(current, _deopt_reason)) {\n-        RuntimePredicate runtime_predicate(current->as_IfProj());\n-        predicate_visitor.visit(runtime_predicate);\n-        current = runtime_predicate.entry();\n-      } else if (InitializedAssertionPredicate::is_predicate(current)) {\n-        InitializedAssertionPredicate initialized_assertion_predicate(current->as_IfTrue());\n-        predicate_visitor.visit(initialized_assertion_predicate);\n-        current = initialized_assertion_predicate.entry();\n-      } else {\n-        \/\/ Either a Parse Predicate or not a Regular Predicate. In both cases, the node does not belong to this block.\n-        break;\n+      if (process_template_assertion_predicate(predicate_visitor)) {\n+        continue;\n+      }\n+\n+      if (process_runtime_predicate(predicate_visitor)) {\n+        continue;\n+      }\n+\n+      if (process_initialized_assertion_predicate(predicate_visitor)) {\n+        continue;\n@@ -691,0 +693,2 @@\n+      \/\/ Either a Parse Predicate or not a Regular Predicate. In both cases, the node does not belong to this block.\n+      break;\n@@ -692,1 +696,39 @@\n-    return current;\n+    return _current_node;\n+  }\n+\n+  bool process_template_assertion_predicate(PredicateVisitor& predicate_visitor) {\n+    if (!TemplateAssertionPredicate::is_predicate(_current_node)) {\n+      return false;\n+    }\n+\n+    TemplateAssertionPredicate template_assertion_predicate(_current_node->as_IfTrue());\n+    if (!template_assertion_predicate.is_useless()) {\n+      \/\/ Only visit if not useless. Otherwise, just skip over it to possibly process other predicates above.\n+      predicate_visitor.visit(template_assertion_predicate);\n+    }\n+    _current_node = template_assertion_predicate.entry();\n+    return true;\n+  }\n+\n+  bool process_runtime_predicate(PredicateVisitor& predicate_visitor) {\n+    if (!RuntimePredicate::is_predicate(_current_node, _deopt_reason)) {\n+      return false;\n+    }\n+    RuntimePredicate runtime_predicate(_current_node->as_IfProj());\n+    predicate_visitor.visit(runtime_predicate);\n+    _current_node = runtime_predicate.entry();\n+    return true;\n+  }\n+\n+  bool process_initialized_assertion_predicate(PredicateVisitor& predicate_visitor) {\n+    if (!InitializedAssertionPredicate::is_predicate(_current_node)) {\n+      return false;\n+    }\n+\n+    InitializedAssertionPredicate initialized_assertion_predicate(_current_node->as_IfTrue());\n+    if (!initialized_assertion_predicate.is_useless()) {\n+      \/\/ Only visit if not useless. Otherwise, just skip over it to possibly process other predicates above.\n+      predicate_visitor.visit(initialized_assertion_predicate);\n+    }\n+    _current_node = initialized_assertion_predicate.entry();\n+    return true;\n@@ -700,1 +742,1 @@\n-  const RegularPredicateBlockIterator _regular_predicate_block_iterator;\n+  RegularPredicateBlockIterator _regular_predicate_block_iterator;\n@@ -710,1 +752,1 @@\n-  Node* for_each(PredicateVisitor& predicate_visitor) const {\n+  Node* for_each(PredicateVisitor& predicate_visitor) {\n@@ -734,5 +776,5 @@\n-    Node* current = _start_node;\n-    PredicateBlockIterator loop_limit_check_predicate_iterator(current, Deoptimization::Reason_loop_limit_check);\n-    current = loop_limit_check_predicate_iterator.for_each(predicate_visitor);\n-    PredicateBlockIterator auto_vectorization_check_iterator(current, Deoptimization::Reason_auto_vectorization_check);\n-    current = auto_vectorization_check_iterator.for_each(predicate_visitor);\n+    Node* current_node = _start_node;\n+    PredicateBlockIterator loop_limit_check_predicate_iterator(current_node, Deoptimization::Reason_loop_limit_check);\n+    current_node = loop_limit_check_predicate_iterator.for_each(predicate_visitor);\n+    PredicateBlockIterator auto_vectorization_check_iterator(current_node, Deoptimization::Reason_auto_vectorization_check);\n+    current_node = auto_vectorization_check_iterator.for_each(predicate_visitor);\n@@ -741,2 +783,2 @@\n-        PredicateBlockIterator profiled_loop_predicate_iterator(current, Deoptimization::Reason_profile_predicate);\n-        current = profiled_loop_predicate_iterator.for_each(predicate_visitor);\n+        PredicateBlockIterator profiled_loop_predicate_iterator(current_node, Deoptimization::Reason_profile_predicate);\n+        current_node = profiled_loop_predicate_iterator.for_each(predicate_visitor);\n@@ -744,2 +786,2 @@\n-      PredicateBlockIterator loop_predicate_iterator(current, Deoptimization::Reason_predicate);\n-      current = loop_predicate_iterator.for_each(predicate_visitor);\n+      PredicateBlockIterator loop_predicate_iterator(current_node, Deoptimization::Reason_predicate);\n+      current_node = loop_predicate_iterator.for_each(predicate_visitor);\n@@ -747,1 +789,1 @@\n-    return current;\n+    return current_node;\n@@ -1196,10 +1238,1 @@\n-\n-  \/\/ Kill the old Initialized Assertion Predicates with old strides before unrolling. The new Initialized Assertion\n-  \/\/ Predicates are inserted after the Template Assertion Predicate which ensures that we are not accidentally visiting\n-  \/\/ and killing a newly created Initialized Assertion Predicate here.\n-  void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override {\n-    if (initialized_assertion_predicate.is_last_value()) {\n-      \/\/ Only Last Value Initialized Assertion Predicates need to be killed and updated.\n-      initialized_assertion_predicate.kill(_phase);\n-    }\n-  }\n+  void visit(const InitializedAssertionPredicate& initialized_assertion_predicate) override;\n","filename":"src\/hotspot\/share\/opto\/predicates.hpp","additions":80,"deletions":47,"binary":false,"changes":127,"status":"modified"}]}