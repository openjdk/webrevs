{"files":[{"patch":"@@ -128,1 +128,1 @@\n-bool ZRemembered::scan_page(ZPage* page) const {\n+bool ZRemembered::scan_page_and_clear_remset(ZPage* page) const {\n@@ -154,0 +154,14 @@\n+  if (ZVerifyRemembered) {\n+    \/\/ Make sure self healing of pointers is ordered before clearing of\n+    \/\/ the previous bits so that ZVerify::after_scan can detect missing\n+    \/\/ remset entries accurately.\n+    OrderAccess::storestore();\n+  }\n+\n+  \/\/ If we have consumed the remset entries above we also clear them.\n+  \/\/ The exception is if the page is completely empty\/garbage, where we don't\n+  \/\/ want to race with an old collection modifying the remset as well.\n+  if (!can_trust_live_bits || page->is_marked()) {\n+    page->clear_remset_previous();\n+  }\n+\n@@ -503,10 +517,1 @@\n-          bool found_roots = _remembered->scan_page(page);\n-\n-          \/\/ ... and as a side-effect clear the previous entries\n-          if (ZVerifyRemembered) {\n-            \/\/ Make sure self healing of pointers is ordered before clearing of\n-            \/\/ the previous bits so that ZVerify::after_scan can detect missing\n-            \/\/ remset entries accurately.\n-            OrderAccess::storestore();\n-          }\n-          page->clear_remset_previous();\n+          bool found_roots = _remembered->scan_page_and_clear_remset(page);\n","filename":"src\/hotspot\/share\/gc\/z\/zRemembered.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  bool scan_page(ZPage* page) const;\n+  bool scan_page_and_clear_remset(ZPage* page) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRemembered.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}