{"files":[{"patch":"@@ -256,0 +256,16 @@\n+bool AddNode::is_not(PhaseGVN* phase, Node* n, BasicType bt) {\n+  return n->Opcode() == Op_Xor(bt) && phase->type(n->in(2)) == TypeInteger::minus_1(bt);\n+}\n+\n+AddNode* AddNode::make_not(PhaseGVN* phase, Node*n, BasicType bt) {\n+  switch (bt) {\n+    case T_INT:\n+      return new XorINode(n, phase->intcon(-1));\n+    case T_LONG:\n+      return new XorLNode(n, phase->longcon(-1L));\n+    default:\n+      fatal(\"Not implemented for %s\", type2name(bt));\n+  }\n+  return nullptr;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/addnode.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -81,0 +81,7 @@\n+\n+  \/\/ Utility function to check if the given node is a NOT operation,\n+  \/\/ i.e., n == m ^ (-1).\n+  static bool is_not(PhaseGVN* phase, Node* n, BasicType bt);\n+\n+  \/\/ Utility function to make a NOT operation, i.e., returning n ^ (-1).\n+  static AddNode* make_not(PhaseGVN* phase, Node* n, BasicType bt);\n","filename":"src\/hotspot\/share\/opto\/addnode.hpp","additions":7,"deletions":0,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -614,4 +614,1 @@\n-  if (in(1)->Opcode() == Op_XorI &&\n-      phase->type(in(1)->in(2)) == TypeInt::MINUS_1 &&\n-      in(2)->Opcode() == Op_XorI &&\n-      phase->type(in(2)->in(2)) == TypeInt::MINUS_1) {\n+  if (AddNode::is_not(phase, in(1), T_INT) && AddNode::is_not(phase, in(2), T_INT)) {\n@@ -619,2 +616,2 @@\n-    Node *t = phase->transform(or_a_b);\n-    return new XorINode(t, in(1)->in(2));\n+    Node *tn = phase->transform(or_a_b);\n+    return AddNode::make_not(phase, tn, T_INT);\n@@ -764,5 +761,4 @@\n-  if (in(1)->Opcode() == Op_XorL\n-      && phase->type(in(1)->in(2)) == TypeLong::MINUS_1\n-      && in(2)->Opcode() == Op_XorL\n-      && in(1)->in(2) == in(2)->in(2)) {\n-    return new XorLNode(phase->transform(new OrLNode(in(1)->in(1), in(2)->in(1))), in(1)->in(2));\n+  if (AddNode::is_not(phase, in(1), T_LONG) && AddNode::is_not(phase, in(2), T_LONG)) {\n+    Node *or_a_b = new OrLNode(in(1)->in(1), in(2)->in(1));\n+    Node *tn = phase->transform(or_a_b);\n+    return AddNode::make_not(phase, tn, T_LONG);\n","filename":"src\/hotspot\/share\/opto\/mulnode.cpp","additions":7,"deletions":11,"binary":false,"changes":18,"status":"modified"}]}