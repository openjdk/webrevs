{"files":[{"patch":"@@ -1486,12 +1486,3 @@\n-      if (u->is_Phi() && u->as_Phi()->type() == Type::MEMORY &&\n-          u->adr_type() == TypePtr::BOTTOM && u->in(0) == phi_reg &&\n-          u->req() == phi_len) {\n-        for (uint j = 1; j < phi_len; j++) {\n-          if (in(j) != u->in(j)) {\n-            u = nullptr;\n-            break;\n-          }\n-        }\n-        if (u != nullptr) {\n-          return u;\n-        }\n+      assert(!u->is_Phi() || u->in(0) == phi_reg, \"broken Phi\/Region subgraph\");\n+      if (u->is_Phi() && u->req() == phi_len && can_be_replaced_by(u->as_Phi())) {\n+        return u;\n@@ -2693,0 +2684,19 @@\n+  \/\/ PhiNode::Identity replaces a non-bottom memory phi with a bottom memory phi with the same inputs, if it exists.\n+  \/\/ If the bottom memory phi's inputs are changed (so it can now replace the non-bottom memory phi) or if it's created\n+  \/\/ only after the non-bottom memory phi is processed by igvn, PhiNode::Identity doesn't run and the transformation\n+  \/\/ doesn't happen.\n+  \/\/ Look for non-bottom Phis that should be transformed and enqueue them for igvn so that PhiNode::Identity executes for\n+  \/\/ them.\n+  if (can_reshape && type() == Type::MEMORY && adr_type() == TypePtr::BOTTOM) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    uint phi_len = req();\n+    Node* phi_reg = region();\n+    for (DUIterator_Fast imax, i = phi_reg->fast_outs(imax); i < imax; i++) {\n+      Node* u = phi_reg->fast_out(i);\n+      assert(!u->is_Phi() || (u->in(0) == phi_reg && u->req() == phi_len), \"broken Phi\/Region subgraph\");\n+      if (u->is_Phi() && u->as_Phi()->can_be_replaced_by(this)) {\n+        igvn->_worklist.push(u);\n+      }\n+    }\n+  }\n+\n@@ -2742,0 +2752,5 @@\n+bool PhiNode::can_be_replaced_by(const PhiNode* other) const {\n+  return type() == Type::MEMORY && other->type() == Type::MEMORY && adr_type() != TypePtr::BOTTOM &&\n+    other->adr_type() == TypePtr::BOTTOM && has_same_inputs_as(other);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":27,"deletions":12,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+  bool can_be_replaced_by(const PhiNode* other) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2878,10 +2878,3 @@\n-            use->req() == req()) {\n-          uint j;\n-          for (j = 0; j < use->req(); j++) {\n-            if (use->in(j) != in(j)) {\n-              break;\n-            }\n-          }\n-          if (j == use->req()) {\n-            return use;\n-          }\n+            use->req() == req() &&\n+            has_same_inputs_as(use)) {\n+          return use;\n@@ -2895,0 +2888,10 @@\n+bool Node::has_same_inputs_as(const Node* other) const {\n+  assert(req() == other->req(), \"should have same number of inputs\");\n+  for (uint j = 0; j < other->req(); j++) {\n+    if (in(j) != other->in(j)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -1182,0 +1182,1 @@\n+  bool has_same_inputs_as(const Node* other) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8370200\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+\n+package compiler.c2;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.Test;\n+\n+public class TestReplaceNarrowPhiWithBottomPhi {\n+    private int field1;\n+    private volatile int field2;\n+\n+    static public void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.PHI, \"2\" })\n+    public void test1() {\n+        int j;\n+        for (j = 0; j < 10; j++) {\n+\n+        }\n+        inlined1(j);\n+\n+        \/\/ Initially, there are 2 memory Phis: one for bottom, one for field1. After loop opts, both\n+        \/\/ Phis have the same inputs and the narrower Phi should be replaced by the bottom Phi.\n+        for (int i = 1; i < 100; i *= 2) {\n+            field2 = 42;\n+        }\n+    }\n+\n+    private void inlined1(int j) {\n+        if (j == 42) {\n+            field1 = 42;\n+        }\n+    }\n+\n+    @Run(test = \"test1\")\n+    private void test1Runner() {\n+        test1();\n+        inlined1(42);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestReplaceNarrowPhiWithBottomPhi.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8370200\n+ * @summary Crash: assert(outer->outcnt() >= phis + 2 - be_loads && outer->outcnt() <= phis + 2 + stores + 1) failed: only phis\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:StressSeed=36200582 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*TestMismatchedMemoryPhis*::mainTest -XX:-TieredCompilation\n+ *                   -Xcomp -XX:+StressIGVN -XX:+StressLoopPeeling -XX:PerMethodTrapLimit=0 ${test.main.class}\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:+UnlockDiagnosticVMOptions -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*TestMismatchedMemoryPhis*::mainTest -XX:-TieredCompilation\n+ *                   -Xcomp -XX:+StressIGVN -XX:+StressLoopPeeling -XX:PerMethodTrapLimit=0 ${test.main.class}\n+ * @run main ${test.main.class}\n+ *\/\n+\n+package compiler.loopstripmining;\n+\n+public class TestMismatchedMemoryPhis {\n+    long l;\n+    volatile int iArrFld[];\n+\n+    void mainTest() {\n+        int i, i1, i15 = 4, i16 = 4;\n+        for (i = 1; i < 7; ++i) {\n+            l = i;\n+        }\n+        int j = 1;\n+        while (++j < 4) {\n+            try {\n+                i1 = i15 % i16;\n+                i16 = i15;\n+                i1 = 0 % iArrFld[j];\n+            } catch (ArithmeticException a_e) {\n+            }\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        try {\n+            new TestMismatchedMemoryPhis().mainTest();\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestMismatchedMemoryPhis.java","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"}]}