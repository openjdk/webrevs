{"files":[{"patch":"@@ -1485,12 +1485,3 @@\n-      if (u->is_Phi() && u->as_Phi()->type() == Type::MEMORY &&\n-          u->adr_type() == TypePtr::BOTTOM && u->in(0) == phi_reg &&\n-          u->req() == phi_len) {\n-        for (uint j = 1; j < phi_len; j++) {\n-          if (in(j) != u->in(j)) {\n-            u = nullptr;\n-            break;\n-          }\n-        }\n-        if (u != nullptr) {\n-          return u;\n-        }\n+      assert(!u->is_Phi() || u->in(0) == phi_reg, \"broken Phi\/Region subgraph\");\n+      if (u->is_Phi() && u->req() == phi_len && can_be_replaced_by(u->as_Phi())) {\n+        return u;\n@@ -2692,0 +2683,20 @@\n+  \/\/ PhiNode::Identity replaces a non bottom memory phi with a bottom memory phi with same inputs if it exists\n+  \/\/ This performs the mirror transformation: it looks for non bottom memory phis with same inputs as this bottom memory\n+  \/\/ phi and replaces them by this phi.\n+  \/\/ The reason for having the same transformation in 2 places is so all candidates are transformed. For instance, if\n+  \/\/ the bottom memory phi's inputs are changed (so it can now replace the non bottom memory phi) only after the non\n+  \/\/ bottom memory phi is processed by igvn, having the transformation in PhiNode::Identity is not sufficient\n+  if (can_reshape && type() == Type::MEMORY && adr_type() == TypePtr::BOTTOM) {\n+    PhaseIterGVN* igvn = phase->is_IterGVN();\n+    uint phi_len = req();\n+    Node* phi_reg = region();\n+    for (DUIterator_Fast imax, i = phi_reg->fast_outs(imax); i < imax; i++) {\n+      Node* u = phi_reg->fast_out(i);\n+      assert(!u->is_Phi() || (u->in(0) == phi_reg && u->req() == phi_len), \"broken Phi\/Region subgraph\");\n+      if (u->is_Phi() && u->as_Phi()->can_be_replaced_by(this)) {\n+        igvn->replace_node(u, this);\n+        --i; --imax;\n+      }\n+    }\n+  }\n+\n@@ -2741,0 +2752,5 @@\n+bool PhiNode::can_be_replaced_by(const PhiNode* other) const {\n+  return type() == Type::MEMORY && other->type() == Type::MEMORY && adr_type() != TypePtr::BOTTOM &&\n+    other->adr_type() == TypePtr::BOTTOM && has_same_inputs_as(other);\n+}\n+\n","filename":"src\/hotspot\/share\/opto\/cfgnode.cpp","additions":28,"deletions":12,"binary":false,"changes":40,"status":"modified"},{"patch":"@@ -274,0 +274,1 @@\n+  bool can_be_replaced_by(const PhiNode* other) const;\n","filename":"src\/hotspot\/share\/opto\/cfgnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2878,10 +2878,3 @@\n-            use->req() == req()) {\n-          uint j;\n-          for (j = 0; j < use->req(); j++) {\n-            if (use->in(j) != in(j)) {\n-              break;\n-            }\n-          }\n-          if (j == use->req()) {\n-            return use;\n-          }\n+            use->req() == req() &&\n+            has_same_inputs_as(use)) {\n+          return use;\n@@ -2895,0 +2888,11 @@\n+bool Node::has_same_inputs_as(const Node* other) const {\n+  assert(req() == other->req(), \"should have same number of inputs\");\n+  for (uint j = 0; j < other->req(); j++) {\n+    if (in(j) != other->in(j)) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -1182,0 +1182,1 @@\n+  bool has_same_inputs_as(const Node* other) const;\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,64 @@\n+\/*\n+ * Copyright (c) 2025 IBM Corporation. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8370200\n+ * @summary Crash: assert(outer->outcnt() >= phis + 2 - be_loads && outer->outcnt() <= phis + 2 + stores + 1) failed: only phis\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:StressSeed=36200582 -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*TestMismatchedMemoryPhis*::mainTest -XX:-TieredCompilation\n+ *                   -Xcomp -XX:+StressIGVN -XX:+StressLoopPeeling -XX:PerMethodTrapLimit=0 TestMismatchedMemoryPhis\n+ * @run main\/othervm -XX:+IgnoreUnrecognizedVMOptions -XX:CompileCommand=quiet\n+ *                   -XX:CompileCommand=compileonly,*TestMismatchedMemoryPhis*::mainTest -XX:-TieredCompilation\n+ *                   -Xcomp -XX:+StressIGVN -XX:+StressLoopPeeling -XX:PerMethodTrapLimit=0 TestMismatchedMemoryPhis\n+ * @run main TestMismatchedMemoryPhis\n+ *\/\n+\n+public class TestMismatchedMemoryPhis {\n+    long l;\n+    volatile int iArrFld[];\n+\n+    void mainTest() {\n+        int i, i1, i15 = 4, i16 = 4;\n+        for (i = 1; i < 7; ++i) {\n+           l = i;\n+        }\n+        int j = 1;\n+        while (++j < 4) {\n+            try {\n+                i1 = i15 % i16;\n+                i16 = i15;\n+                i1 = 0 % iArrFld[j];\n+            } catch (ArithmeticException a_e) {\n+            }\n+        }\n+    }\n+\n+    static public void main(String[] args) {\n+        try {\n+            new TestMismatchedMemoryPhis().mainTest();\n+        } catch (NullPointerException npe) {\n+            \/\/ Expected\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopstripmining\/TestMismatchedMemoryPhis.java","additions":64,"deletions":0,"binary":false,"changes":64,"status":"added"}]}