{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n-    Signature.RefTypeSig superclassSignature();\n+    Signature.ClassTypeSig superclassSignature();\n@@ -48,1 +48,1 @@\n-    List<Signature.RefTypeSig> superinterfaceSignatures();\n+    List<Signature.ClassTypeSig> superinterfaceSignatures();\n@@ -58,2 +58,2 @@\n-    public static ClassSignature of(Signature.RefTypeSig superclassSignature,\n-                                    Signature.RefTypeSig... superinterfaceSignatures) {\n+    public static ClassSignature of(Signature.ClassTypeSig superclassSignature,\n+                                    Signature.ClassTypeSig... superinterfaceSignatures) {\n@@ -70,2 +70,2 @@\n-                                    Signature.RefTypeSig superclassSignature,\n-                                    Signature.RefTypeSig... superinterfaceSignatures) {\n+                                    Signature.ClassTypeSig superclassSignature,\n+                                    Signature.ClassTypeSig... superinterfaceSignatures) {\n@@ -84,1 +84,1 @@\n-        return new SignaturesImpl().parseClassSignature(requireNonNull(classSignature));\n+        return new SignaturesImpl(classSignature).parseClassSignature();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -112,1 +112,1 @@\n-        return new SignaturesImpl().parseMethodSignature(requireNonNull(methodSignature));\n+        return new SignaturesImpl(methodSignature).parseMethodSignature();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        return new SignaturesImpl().parseSignature(requireNonNull(javaTypeSignature));\n+        return new SignaturesImpl(javaTypeSignature).parseSignature();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -294,1 +294,1 @@\n-                        .map(this::mapSignature).toArray(Signature.RefTypeSig[]::new));\n+                        .map(this::mapSignature).toArray(Signature.ClassTypeSig[]::new));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.util.Objects;\n@@ -38,1 +39,3 @@\n-    public SignaturesImpl() {\n+    public SignaturesImpl(String signature) {\n+        this.sig = Objects.requireNonNull(signature);\n+        this.sigp = 0;\n@@ -41,1 +44,1 @@\n-    private String sig;\n+    private final String sig;\n@@ -44,3 +47,1 @@\n-    public ClassSignature parseClassSignature(String signature) {\n-        this.sig = signature;\n-        sigp = 0;\n+    public ClassSignature parseClassSignature() {\n@@ -49,2 +50,2 @@\n-            RefTypeSig superclass = referenceTypeSig();\n-            ArrayList<RefTypeSig> superinterfaces = null;\n+            ClassTypeSig superclass = classTypeSig();\n+            ArrayList<ClassTypeSig> superinterfaces = null;\n@@ -54,1 +55,1 @@\n-                superinterfaces.add(referenceTypeSig());\n+                superinterfaces.add(classTypeSig());\n@@ -62,3 +63,1 @@\n-    public MethodSignature parseMethodSignature(String signature) {\n-        this.sig = signature;\n-        sigp = 0;\n+    public MethodSignature parseMethodSignature() {\n@@ -67,2 +66,1 @@\n-            if (sig.charAt(sigp) != '(') throw error(\"Expected ( at possition %d of signature\".formatted(sigp));\n-            sigp++;\n+            require('(');\n@@ -70,1 +68,1 @@\n-            while (sig.charAt(sigp) != ')') {\n+            while (!match(')')) {\n@@ -72,1 +70,1 @@\n-                     paramTypes = new ArrayList<>();\n+                    paramTypes = new ArrayList<>();\n@@ -75,1 +73,0 @@\n-            sigp++;\n@@ -79,2 +76,1 @@\n-                if (sig.charAt(sigp) != '^') throw error(\"Expected ^ at possition %d of signature\".formatted(sigp));\n-                sigp++;\n+                require('^');\n@@ -95,3 +91,1 @@\n-    public Signature parseSignature(String signature) {\n-        this.sig = signature;\n-        sigp = 0;\n+    public Signature parseSignature() {\n@@ -100,1 +94,1 @@\n-            if (sigp == signature.length())\n+            if (sigp == sig.length())\n@@ -109,2 +103,1 @@\n-        if (sig.charAt(sigp) == '<') {\n-            sigp++;\n+        if (match('<')) {\n@@ -112,3 +105,3 @@\n-            while (sig.charAt(sigp) != '>') {\n-                int sep = sig.indexOf(\":\", sigp);\n-                String name = sig.substring(sigp, sep);\n+            \/\/ cannot have empty <>\n+            do {\n+                String name = sig.substring(sigp, requireIdentifier());\n@@ -117,1 +110,1 @@\n-                sigp = sep + 1;\n+                require(':');\n@@ -120,2 +113,1 @@\n-                while (sig.charAt(sigp) == ':') {\n-                    sigp++;\n+                while (match(':')) {\n@@ -127,2 +119,1 @@\n-            }\n-            sigp++;\n+            } while (!match('>'));\n@@ -144,32 +135,14 @@\n-        char c = sig.charAt(sigp++);\n-        switch (c) {\n-            case 'L':\n-                StringBuilder sb = new StringBuilder();\n-                ArrayList<TypeArg> argTypes = null;\n-                Signature.ClassTypeSig t = null;\n-                char sigch ;\n-                do {\n-                    switch  (sigch = sig.charAt(sigp++)) {\n-                        case '<' -> {\n-                            argTypes = new ArrayList<>();\n-                            while (sig.charAt(sigp) != '>')\n-                                argTypes.add(typeArg());\n-                            sigp++;\n-                        }\n-                        case '.',';' -> {\n-                            t = new ClassTypeSigImpl(Optional.ofNullable(t), sb.toString(), null2Empty(argTypes));\n-                            sb.setLength(0);\n-                            argTypes = null;\n-                        }\n-                        default -> sb.append(sigch);\n-                    }\n-                } while (sigch != ';');\n-                return t;\n-            case 'T':\n-                int sep = sig.indexOf(';', sigp);\n-                var ty = Signature.TypeVarSig.of(sig.substring(sigp, sep));\n-                sigp = sep + 1;\n-                return ty;\n-            case '[': return ArrayTypeSig.of(typeSig());\n-        }\n-        throw error(\"Unexpected character %c at possition %d of signature\".formatted(c, sigp - 1));\n+        return switch (sig.charAt(sigp)) {\n+            case 'L' -> classTypeSig();\n+            case 'T' -> {\n+                sigp++;\n+                var ty = Signature.TypeVarSig.of(sig.substring(sigp, requireIdentifier()));\n+                require(';');\n+                yield ty;\n+            }\n+            case '[' -> {\n+                sigp++;\n+                yield ArrayTypeSig.of(typeSig());\n+            }\n+            default -> throw unexpectedError(\"a type signature\");\n+        };\n@@ -190,0 +163,74 @@\n+    private ClassTypeSig classTypeSig() {\n+        require('L');\n+        Signature.ClassTypeSig t = null;\n+\n+        do {\n+            int start = sigp;\n+            requireIdentifier();\n+            if (t == null) {\n+                while (match('\/')) {\n+                    requireIdentifier();\n+                }\n+            }\n+            String className = sig.substring(start, sigp);\n+\n+            ArrayList<TypeArg> argTypes;\n+            if (match('<')) {\n+                \/\/ cannot have empty <>\n+                argTypes = new ArrayList<>();\n+                do {\n+                    argTypes.add(typeArg());\n+                } while (!match('>'));\n+            } else {\n+                argTypes = null;\n+            }\n+\n+            if (match(';')) {\n+                return new ClassTypeSigImpl(Optional.ofNullable(t), className, null2Empty(argTypes));\n+            } else if (match('.')) {\n+                t = new ClassTypeSigImpl(Optional.ofNullable(t), className, null2Empty(argTypes));\n+            } else {\n+                throw unexpectedError(\". or ;\");\n+            }\n+        } while (true);\n+    }\n+\n+    \/**\n+     * Tries to match a character, and moves pointer if it matches.\n+     *\/\n+    private boolean match(char c) {\n+        if (sigp < sig.length() && sig.charAt(sigp) == c) {\n+            sigp++;\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    \/**\n+     * Requires a character and moves past it, failing otherwise.\n+     *\/\n+    private void require(char c) {\n+        if (!match(c))\n+            throw unexpectedError(String.valueOf(c));\n+    }\n+\n+    \/**\n+     * Requires an identifier, moving pointer to next illegal character and returning\n+     * its position. Fails if the identifier is empty.\n+     *\/\n+    private int requireIdentifier() {\n+        int start = sigp;\n+        while (sigp < sig.length()) {\n+            switch (sig.charAt(sigp)) {\n+                case '.', ';', '[', '\/', '<', '>', ':' -> {\n+                    break;\n+                }\n+            }\n+            sigp++;\n+        }\n+        if (start == sigp) {\n+            throw unexpectedError(\"an identifier\");\n+        }\n+        return sigp;\n+    }\n+\n@@ -274,2 +321,2 @@\n-    public static record ClassSignatureImpl(List<TypeParam> typeParameters, RefTypeSig superclassSignature,\n-            List<RefTypeSig> superinterfaceSignatures) implements ClassSignature {\n+    public static record ClassSignatureImpl(List<TypeParam> typeParameters, ClassTypeSig superclassSignature,\n+            List<ClassTypeSig> superinterfaceSignatures) implements ClassSignature {\n@@ -311,0 +358,6 @@\n+    private IllegalArgumentException unexpectedError(String expected) {\n+        return error(sigp < sig.length() ? \"Unexpected character %c at position %d, expected %s\"\n+                .formatted(sig.charAt(sigp), sigp, expected)\n+                : \"Unexpected end of signature at position %d, expected %s\".formatted(sigp, expected));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SignaturesImpl.java","additions":119,"deletions":66,"binary":false,"changes":185,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8321540\n+ * @bug 8321540 8319463\n@@ -186,1 +186,1 @@\n-        var innerSig = (ClassTypeSig) ((ClassTypeSig) sig.superclassSignature()) \/\/ ArrayList\n+        var innerSig = (ClassTypeSig) sig.superclassSignature() \/\/ ArrayList\n@@ -216,0 +216,17 @@\n+        Ljava\/util\/Opt<Ljava\/lang\/Integer;>ional;\n+        Lcom\/example\/Outer<Ljava\/lang\/String;>.package\/Inner<[I>;\n+        LSample>;\n+        LSample:Other;\n+        LOuter<[JTT;>.[Inner;\n+        TA:J;\n+        LEmpty<>;\n+        L\n+        Lcom\n+        Lcom\/example\/\n+        Lcom\/example\/Outer<\n+        Lcom\/example\/Outer<Ljava\/\n+        Lcom\/example\/Outer<Ljava\/lang\/String\n+        Lcom\/example\/Outer<Ljava\/lang\/String;\n+        Lcom\/example\/Outer<Ljava\/lang\/String;>\n+        Lcom\/example\/Outer<Ljava\/lang\/String;>.\n+        Lcom\/example\/Outer<Ljava\/lang\/String;>.Inner<[I>\n@@ -219,0 +236,11 @@\n+    @Test\n+    void testGoodTypeSignatures() {\n+        \"\"\"\n+        Ljava\/util\/Optional<Ljava\/lang\/Integer;>;\n+        Lcom\/example\/Outer<Ljava\/lang\/Integer;>.Inner<[I>;\n+        LSample;\n+        LOuter<[JTT;>.Inner;\n+        LOuter.Inner;\n+        \"\"\".lines().forEach(Signature::parseFrom);\n+    }\n+\n@@ -237,0 +265,8 @@\n+        <K:Ljava\/lang\/Object;>Ljava\/lang\/Object;TK;\n+        Ljava\/lang\/Object;[Ljava\/lang\/Object;\n+        [Ljava\/util\/Optional<[I>;\n+        [I\n+        <K:Ljava\/lang\/Object;>TK;\n+        <K;Q:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+        <:Ljava\/lang\/Object;>Ljava\/lang\/Object;\n+        <>Ljava\/lang\/Object;\n@@ -262,0 +298,1 @@\n+        (TT;I)VI\n","filename":"test\/jdk\/jdk\/classfile\/SignaturesTest.java","additions":39,"deletions":2,"binary":false,"changes":41,"status":"modified"}]}