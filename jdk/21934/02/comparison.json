{"files":[{"patch":"@@ -160,1 +160,2 @@\n- *         try (var scope = new StructuredTaskScope<String>()) {\n+ *         \/\/ @link substring=\"open\" target=\"StructuredTaskScope#open()\" :\n+ *         try (var scope = StructuredTaskScope.open()) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ScopedValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,215 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.NoSuchElementException;\n+import java.util.Objects;\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import jdk.internal.invoke.MhUtil;\n+\n+\/**\n+ * Built-in StructuredTaskScope.Joiner implementations.\n+ *\/\n+class Joiners {\n+    private Joiners() { }\n+\n+    \/**\n+     * A joiner that returns a stream of all subtasks when all subtasks complete\n+     * successfully. Cancels the scope if any subtask fails.\n+     *\/\n+    static final class AllSuccessful<T> implements Joiner<T, Stream<Subtask<T>>> {\n+        private static final VarHandle FIRST_EXCEPTION =\n+                MhUtil.findVarHandle(MethodHandles.lookup(), \"firstException\", Throwable.class);\n+\n+        \/\/ list of forked subtasks, only accessed by owner thread\n+        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+\n+        private volatile Throwable firstException;\n+\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            if (subtask.state() != Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            var s = (Subtask<T>) subtask;\n+            subtasks.add(s);\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            Subtask.State state = subtask.state();\n+            if (state == Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n+            }\n+            return (state == Subtask.State.FAILED)\n+                    && (firstException == null)\n+                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n+        }\n+\n+        @Override\n+        public Stream<Subtask<T>> result() throws Throwable {\n+            Throwable ex = firstException;\n+            if (ex != null) {\n+                throw ex;\n+            } else {\n+                return subtasks.stream();\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A joiner that returns the result of the first subtask to complete successfully.\n+     * Cancels the scope if any subtasks succeeds.\n+     *\/\n+    static final class AnySuccessful<T> implements Joiner<T, T> {\n+        private static final VarHandle SUBTASK =\n+                MhUtil.findVarHandle(MethodHandles.lookup(), \"subtask\", Subtask.class);\n+\n+        \/\/ UNAVAILABLE < FAILED < SUCCESS\n+        private static final Comparator<Subtask.State> SUBTASK_STATE_COMPARATOR =\n+                Comparator.comparingInt(AnySuccessful::stateToInt);\n+\n+        private volatile Subtask<T> subtask;\n+\n+        \/**\n+         * Maps a Subtask.State to an int that can be compared.\n+         *\/\n+        private static int stateToInt(Subtask.State s) {\n+            return switch (s) {\n+                case UNAVAILABLE -> 0;\n+                case FAILED      -> 1;\n+                case SUCCESS     -> 2;\n+            };\n+        }\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            Subtask.State state = subtask.state();\n+            if (state == Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n+            }\n+            Subtask<T> s;\n+            while (((s = this.subtask) == null)\n+                    || SUBTASK_STATE_COMPARATOR.compare(s.state(), state) < 0) {\n+                if (SUBTASK.compareAndSet(this, s, subtask)) {\n+                    return (state == Subtask.State.SUCCESS);\n+                }\n+            }\n+            return false;\n+        }\n+\n+        @Override\n+        public T result() throws Throwable {\n+            Subtask<T> subtask = this.subtask;\n+            if (subtask == null) {\n+                throw new NoSuchElementException(\"No subtasks completed\");\n+            }\n+            return switch (subtask.state()) {\n+                case SUCCESS -> subtask.get();\n+                case FAILED -> throw subtask.exception();\n+                default -> throw new InternalError();\n+            };\n+        }\n+    }\n+\n+    \/**\n+     * A joiner that that waits for all successful subtasks. Cancels the scope if any\n+     * subtask fails.\n+     *\/\n+    static final class AwaitSuccessful<T> implements Joiner<T, Void> {\n+        private static final VarHandle FIRST_EXCEPTION =\n+                MhUtil.findVarHandle(MethodHandles.lookup(), \"firstException\", Throwable.class);\n+        private volatile Throwable firstException;\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            Subtask.State state = subtask.state();\n+            if (state == Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n+            }\n+            return (state == Subtask.State.FAILED)\n+                    && (firstException == null)\n+                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n+        }\n+\n+        @Override\n+        public Void result() throws Throwable {\n+            Throwable ex = firstException;\n+            if (ex != null) {\n+                throw ex;\n+            } else {\n+                return null;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * A joiner that returns a stream of all subtasks.\n+     *\/\n+    static class AllSubtasks<T> implements Joiner<T, Stream<Subtask<T>>> {\n+        private final Predicate<Subtask<? extends T>> isDone;\n+\n+        \/\/ list of forked subtasks, only accessed by owner thread\n+        private final List<Subtask<T>> subtasks = new ArrayList<>();\n+\n+        AllSubtasks(Predicate<Subtask<? extends T>> isDone) {\n+            this.isDone = Objects.requireNonNull(isDone);\n+        }\n+\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            if (subtask.state() != Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n+            }\n+            @SuppressWarnings(\"unchecked\")\n+            var s = (Subtask<T>) subtask;\n+            subtasks.add(s);\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            if (subtask.state() == Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n+            }\n+            return isDone.test(subtask);\n+        }\n+\n+        @Override\n+        public Stream<Subtask<T>> result() {\n+            return subtasks.stream();\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Joiners.java","additions":215,"deletions":0,"binary":false,"changes":215,"status":"added"},{"patch":"@@ -27,2 +27,0 @@\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.VarHandle;\n@@ -30,4 +28,0 @@\n-import java.time.Instant;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.concurrent.locks.ReentrantLock;\n@@ -35,0 +29,1 @@\n+import java.util.function.Predicate;\n@@ -36,0 +31,1 @@\n+import java.util.stream.Stream;\n@@ -37,2 +33,0 @@\n-import jdk.internal.misc.ThreadFlock;\n-import jdk.internal.invoke.MhUtil;\n@@ -41,5 +35,6 @@\n- * A basic API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports\n- * cases where a task splits into several concurrent subtasks, and where the subtasks must\n- * complete before the main task continues. A {@code StructuredTaskScope} can be used to\n- * ensure that the lifetime of a concurrent operation is confined by a <em>syntax block<\/em>,\n- * just like that of a sequential operation in structured programming.\n+ * An API for <em>structured concurrency<\/em>. {@code StructuredTaskScope} supports cases\n+ * where execution of a <em>task<\/em> (a unit of work) splits into several concurrent\n+ * subtasks, and where the subtasks must complete before the task continues. A {@code\n+ * StructuredTaskScope} can be used to ensure that the lifetime of a concurrent operation\n+ * is confined by a <em>syntax block<\/em>, similar to that of a sequential operation in\n+ * structured programming.\n@@ -47,1 +42,15 @@\n- * <h2>Basic operation<\/h2>\n+ * <p> {@code StructuredTaskScope} defines the static method {@link #open() open} to open\n+ * a new {@code StructuredTaskScope} and the {@link #close() close} method to close it.\n+ * The API is designed to be used with the {@code try}-with-resources statement where\n+ * the {@code StructuredTaskScope} is opened as a resource and then closed automatically.\n+ * The code inside the block uses the {@link #fork(Callable) fork} method to fork subtasks.\n+ * After forking, it uses the {@link #join() join} method to wait for all subtasks to\n+ * finish (or some other outcome) as a single operation. Forking a subtask starts a new\n+ * {@link Thread} to run the subtask. The thread executing the task does not continue\n+ * beyond the {@code close} method until all threads started to execute subtasks have finished.\n+ * To ensure correct usage, the {@code fork}, {@code join} and {@code close} methods may\n+ * only be invoked by the <em>owner thread<\/em> (the thread that opened the {@code\n+ * StructuredTaskScope}), the {@code fork} method may not be called after {@code join},\n+ * the {@code join} method may only be invoked once, and the {@code close} method throws\n+ * an exception after closing if the owner did not invoke the {@code join} method after\n+ * forking subtasks.\n@@ -49,10 +58,6 @@\n- * A {@code StructuredTaskScope} is created with one of its public constructors. It defines\n- * the {@link #fork(Callable) fork} method to start a thread to execute a subtask, the {@link\n- * #join() join} method to wait for all subtasks to finish, and the {@link #close() close}\n- * method to close the task scope. The API is intended to be used with the {@code\n- * try-with-resources} statement. The intention is that code in the try <em>block<\/em>\n- * uses the {@code fork} method to fork threads to execute the subtasks, wait for the\n- * subtasks to finish with the {@code join} method, and then <em>process the results<\/em>.\n- * A call to the {@code fork} method returns a {@link Subtask Subtask} to representing\n- * the <em>forked subtask<\/em>. Once {@code join} is called, the {@code Subtask} can be\n- * used to get the result completed successfully, or the exception if the subtask failed.\n+ * <p> As a first example, consider a task that splits into two subtasks to concurrently\n+ * fetch resources from two URL locations \"left\" and \"right\". Both subtasks may complete\n+ * successfully, one subtask may succeed and the other may fail, or both subtasks may\n+ * fail. The task in this example is interested in the successful result from both\n+ * subtasks. It waits in the {@link #join() join} method for both subtasks to complete\n+ * successfully or for either subtask to fail.\n@@ -60,2 +65,2 @@\n- *     Callable<String> task1 = ...\n- *     Callable<Integer> task2 = ...\n+ *    \/\/ @link substring=\"open\" target=\"#open()\" :\n+ *    try (var scope = StructuredTaskScope.open()) {\n@@ -63,1 +68,3 @@\n- *     try (var scope = new StructuredTaskScope<Object>()) {\n+ *        \/\/ @link substring=\"fork\" target=\"#fork(Callable)\" :\n+ *        Subtask<String> subtask1 = scope.fork(() -> query(left));\n+ *        Subtask<Integer> subtask2 = scope.fork(() -> query(right));\n@@ -65,2 +72,2 @@\n- *         Subtask<String> subtask1 = scope.fork(task1);   \/\/ @highlight substring=\"fork\"\n- *         Subtask<Integer> subtask2 = scope.fork(task2);  \/\/ @highlight substring=\"fork\"\n+ *        \/\/ throws if either subtask fails\n+ *        scope.join();  \/\/ @link substring=\"join\" target=\"#join()\"\n@@ -68,1 +75,3 @@\n- *         scope.join();                                   \/\/ @highlight substring=\"join\"\n+ *        \/\/ both subtasks completed successfully\n+ *        \/\/ @link substring=\"get\" target=\"Subtask#get()\" :\n+ *        return new MyResult(subtask1.get(), subtask2.get());\n@@ -70,3 +79,2 @@\n- *         ... process results\/exceptions ...\n- *\n- *     } \/\/ close                                          \/\/ @highlight substring=\"close\"\n+ *    \/\/ @link substring=\"close\" target=\"#close()\" :\n+ *    } \/\/ close\n@@ -74,6 +82,0 @@\n- * <p> The following example forks a collection of homogeneous subtasks, waits for all of\n- * them to complete with the {@code join} method, and uses the {@link Subtask.State\n- * Subtask.State} to partition the subtasks into a set of the subtasks that completed\n- * successfully and another for the subtasks that failed.\n- * {@snippet lang=java :\n- *     List<Callable<String>> callables = ...\n@@ -81,1 +83,6 @@\n- *     try (var scope = new StructuredTaskScope<String>()) {\n+ * <p> If both subtasks complete successfully then the {@code join} method completes\n+ * normally and the task uses the {@link Subtask#get() Subtask.get()} method to get\n+ * the result of each subtask. If one of the subtasks fails then the other subtask is\n+ * cancelled (this will {@linkplain Thread#interrupt() interrupt} the thread executing the\n+ * other subtask) and the {@code join} method throws {@link FailedException} with the\n+ * exception from the failed subtask as the {@linkplain Throwable#getCause() cause}.\n@@ -83,1 +90,6 @@\n- *         List<Subtask<String>> subtasks = callables.stream().map(scope::fork).toList();\n+ * <p> To allow for cancellation, subtasks must be coded so that they finish as soon as\n+ * possible when interrupted. Subtasks that do not respond to interrupt, e.g. block on\n+ * methods that are not interruptible, may delay the closing of a scope indefinitely. The\n+ * {@link #close() close} method always waits for threads executing subtasks to finish,\n+ * even if the scope is cancelled, so execution cannot continue beyond the {@code close}\n+ * method until the interrupted threads finish.\n@@ -85,1 +97,4 @@\n- *         scope.join();\n+ * <p> In the example, the subtasks produce results of different types ({@code String} and\n+ * {@code Integer}). In other cases the subtasks may all produce results of the same type.\n+ * If the example had used {@code StructuredTaskScope.<String>open()} then it could\n+ * only be used to fork subtasks that return a {@code String} result.\n@@ -87,3 +102,1 @@\n- *         Map<Boolean, Set<Subtask<String>>> map = subtasks.stream()\n- *                 .collect(Collectors.partitioningBy(h -> h.state() == Subtask.State.SUCCESS,\n- *                                                    Collectors.toSet()));\n+ * <h2>Joiners<\/h2>\n@@ -91,2 +104,30 @@\n- *     } \/\/ close\n- * }\n+ * <p> In the example above, the task fails if any subtask fails. If all subtasks\n+ * succeed then the {@code join} method completes normally. Other policy and outcome is\n+ * supported by creating a {@code StructuredTaskScope} with a {@link Joiner} that\n+ * implements the desired policy. A {@code Joiner} handles subtask completion and produces\n+ * the outcome for the {@link #join() join} method. In the example above, {@code join}\n+ * returns {@code null}. Depending on the {@code Joiner}, {@code join} may return a\n+ * result, a stream of elements, or some other object. The {@code Joiner} interface defines\n+ * factory methods to create {@code Joiner}s for some common cases.\n+ *\n+ * <p> A {@code Joiner} may <a id=\"Cancallation\">cancel<\/a> the scope (sometimes called\n+ * \"short-circuiting\") when some condition is reached that does not require the result of\n+ * subtasks that are still executing. Cancelling the scope prevents new threads from being\n+ * started to execute further subtasks, {@linkplain Thread#interrupt() interrupts} the\n+ * threads executing subtasks that have not completed, and causes the {@code join} method\n+ * to wakeup with the outcome (result or exception). In the above example, the outcome is\n+ * that {@code join} completes with a result of {@code null} when all subtasks succeed.\n+ * The scope is cancelled if any of the subtasks fail and {@code join} throws {@code\n+ * FailedException} with the exception from the failed subtask as the cause. Other {@code\n+ * Joiner} implementations may cancel the scope for other reasons.\n+ *\n+ * <p> Now consider another example that splits into two subtasks. In this example,\n+ * each subtask produces a {@code String} result and the task is only interested in\n+ * the result from the first subtask to complete successfully. The example uses {@link\n+ * Joiner#anySuccessfulResultOrThrow() Joiner.anySuccessfulResultOrThrow()} to\n+ * create a {@code Joiner} that makes available the result of the first subtask to\n+ * complete successfully. The type parameter in the example is \"{@code String}\" so that\n+ * only subtasks that return a {@code String} can be forked.\n+ * {@snippet lang=java :\n+ *    \/\/ @link substring=\"open\" target=\"#open(Joiner)\" :\n+ *    try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow())) {\n@@ -94,4 +135,2 @@\n- * <p> To ensure correct usage, the {@code join} and {@code close} methods may only be\n- * invoked by the <em>owner<\/em> (the thread that opened\/created the task scope), and the\n- * {@code close} method throws an exception after closing if the owner did not invoke the\n- * {@code join} method after forking.\n+ *        scope.fork(callable1);\n+ *        scope.fork(callable2);\n@@ -99,5 +138,2 @@\n- * <p> {@code StructuredTaskScope} defines the {@link #shutdown() shutdown} method to shut\n- * down a task scope without closing it. The {@code shutdown()} method <em>cancels<\/em> all\n- * unfinished subtasks by {@linkplain Thread#interrupt() interrupting} the threads. It\n- * prevents new threads from starting in the task scope. If the owner is waiting in the\n- * {@code join} method then it will wakeup.\n+ *        \/\/ throws if both subtasks fail\n+ *        String firstResult = scope.join();\n@@ -105,2 +141,18 @@\n- * <p> Shutdown is used for <em>short-circuiting<\/em> and allow subclasses to implement\n- * <em>policy<\/em> that does not require all subtasks to finish.\n+ *    }\n+ * }\n+ *\n+ * <p> In the example, the task forks the two subtasks, then waits in the {@code\n+ * join} method for either subtask to complete successfully or for both subtasks to fail.\n+ * If one of the subtasks completes successfully then the {@code Joiner} causes the other\n+ * subtask to be cancelled (this will interrupt the thread executing the subtask), and\n+ * the {@code join} method returns the result from the successful subtask. Cancelling the\n+ * other subtask avoids the task waiting for a result that it doesn't care about. If\n+ * both subtasks fail then the {@code join} method throws {@code FailedException} with the\n+ * exception from one of the subtasks as the {@linkplain Throwable#getCause() cause}.\n+ *\n+ * <p> Whether code uses the {@code Subtask} returned from {@code fork} will depend on\n+ * the {@code Joiner} and usage. Some {@code Joiner} implementations are suited to subtasks\n+ * that return results of the same type and where the {@code join} method returns a result\n+ * for the task to use. Code that forks subtasks that return results of different\n+ * types, and uses a {@code Joiner} such as {@code Joiner.awaitAllSuccessfulOrThrow()} that\n+ * does not return a result, will use {@link Subtask#get() Subtask.get()} after joining.\n@@ -108,1 +160,1 @@\n- * <h2>Subclasses with policies for common cases<\/h2>\n+ * <h2>Exception handling<\/h2>\n@@ -110,16 +162,9 @@\n- * Two subclasses of {@code StructuredTaskScope} are defined to implement policy for\n- * common cases:\n- * <ol>\n- *   <li> {@link ShutdownOnSuccess ShutdownOnSuccess} captures the result of the first\n- *   subtask to complete successfully. Once captured, it shuts down the task scope to\n- *   interrupt unfinished threads and wakeup the owner. This class is intended for cases\n- *   where the result of any subtask will do (\"invoke any\") and where there is no need to\n- *   wait for results of other unfinished subtasks. It defines methods to get the first\n- *   result or throw an exception if all subtasks fail.\n- *   <li> {@link ShutdownOnFailure ShutdownOnFailure} captures the exception of the first\n- *   subtask to fail. Once captured, it shuts down the task scope to interrupt unfinished\n- *   threads and wakeup the owner. This class is intended for cases where the results of all\n- *   subtasks are required (\"invoke all\"); if any subtask fails then the results of other\n- *   unfinished subtasks are no longer needed. If defines methods to throw an exception if\n- *   any of the subtasks fail.\n- * <\/ol>\n+ * <p> A {@code StructuredTaskScope} is opened with a {@link Joiner Joiner} that\n+ * handles subtask completion and produces the outcome for the {@link #join() join} method.\n+ * In some cases, the outcome will be a result, in other cases it will be an exception.\n+ * If the outcome is an exception then the {@code join} method throws {@link\n+ * FailedException} with the exception as the {@linkplain Throwable#getCause()\n+ * cause}. For many {@code Joiner} implementations, the exception will be an exception\n+ * thrown by a subtask that failed. In the case of {@link Joiner#allSuccessfulOrThrow()\n+ * allSuccessfulOrThrow} and {@link Joiner#awaitAllSuccessfulOrThrow() awaitAllSuccessfulOrThrow}\n+ * for example, the exception is from the first subtask to fail.\n@@ -127,9 +172,4 @@\n- * <p> The following are two examples that use the two classes. In both cases, a pair of\n- * subtasks are forked to fetch resources from two URL locations \"left\" and \"right\". The\n- * first example creates a ShutdownOnSuccess object to capture the result of the first\n- * subtask to complete successfully, cancelling the other by way of shutting down the task\n- * scope. The main task waits in {@code join} until either subtask completes with a result\n- * or both subtasks fail. It invokes {@link ShutdownOnSuccess#result(Function)\n- * result(Function)} method to get the captured result. If both subtasks fail then this\n- * method throws a {@code WebApplicationException} with the exception from one of the\n- * subtasks as the cause.\n+ * <p> Many of the details for how exceptions are handled will depend on usage. In some\n+ * cases it may be useful to add a {@code catch} block to the {@code try}-with-resources\n+ * statement to catch {@code FailedException}. The exception handling may use {@code\n+ * instanceof} with pattern matching to handle specific causes.\n@@ -137,1 +177,1 @@\n- *     try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {\n+ *    try (var scope = StructuredTaskScope.open()) {\n@@ -139,2 +179,1 @@\n- *         scope.fork(() -> fetch(left));\n- *         scope.fork(() -> fetch(right));\n+ *        ..\n@@ -142,1 +181,1 @@\n- *         scope.join();\n+ *    } catch (StructuredTaskScope.FailedException e) {\n@@ -144,2 +183,5 @@\n- *         \/\/ @link regex=\"result(?=\\()\" target=\"ShutdownOnSuccess#result\" :\n- *         String result = scope.result(e -> new WebApplicationException(e));\n+ *        Throwable cause = e.getCause();\n+ *        switch (cause) {\n+ *            case IOException ioe -> ..\n+ *            default -> ..\n+ *        }\n@@ -147,2 +189,1 @@\n- *         ...\n- *     }\n+ *    }\n@@ -150,12 +191,3 @@\n- * The second example creates a ShutdownOnFailure object to capture the exception of the\n- * first subtask to fail, cancelling the other by way of shutting down the task scope. The\n- * main task waits in {@link #joinUntil(Instant)} until both subtasks complete with a\n- * result, either fails, or a deadline is reached. It invokes {@link\n- * ShutdownOnFailure#throwIfFailed(Function) throwIfFailed(Function)} to throw an exception\n- * if either subtask fails. This method is a no-op if both subtasks complete successfully.\n- * The example uses {@link Supplier#get()} to get the result of each subtask. Using\n- * {@code Supplier} instead of {@code Subtask} is preferred for common cases where the\n- * object returned by fork is only used to get the result of a subtask that completed\n- * successfully.\n- * {@snippet lang=java :\n- *    Instant deadline = ...\n+ * In other cases it may not be useful to catch {@code FailedException} but instead leave\n+ * it to propagate to the configured {@linkplain Thread.UncaughtExceptionHandler uncaught\n+ * exception handler} for logging purposes.\n@@ -163,1 +195,3 @@\n- *    try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {\n+ * <p> For cases where a specific exception triggers the use of a default result then it\n+ * may be more appropriate to handle this in the subtask itself rather than the subtask\n+ * failing and the scope owner handling the exception.\n@@ -165,2 +199,1 @@\n- *         Supplier<String> supplier1 = scope.fork(() -> query(left));\n- *         Supplier<String> supplier2 = scope.fork(() -> query(right));\n+ * <h2>Configuration<\/h2>\n@@ -168,1 +201,3 @@\n- *         scope.joinUntil(deadline);\n+ * A {@code StructuredTaskScope} is opened with {@linkplain Config configuration} that\n+ * consists of a {@link ThreadFactory} to create threads, an optional name for monitoring\n+ * and management purposes, and an optional timeout.\n@@ -170,2 +205,5 @@\n- *         \/\/ @link substring=\"throwIfFailed\" target=\"ShutdownOnFailure#throwIfFailed\" :\n- *         scope.throwIfFailed(e -> new WebApplicationException(e));\n+ * <p> The {@link #open()} and {@link #open(Joiner)} methods create a {@code StructuredTaskScope}\n+ * with the <a id=\"DefaultConfiguration\"> <em>default configuration<\/em><\/a>. The default\n+ * configuration has a {@code ThreadFactory} that creates unnamed\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n+ * is unnamed for monitoring and management purposes, and has no timeout.\n@@ -173,4 +211,7 @@\n- *         \/\/ both subtasks completed successfully\n- *         String result = Stream.of(supplier1, supplier2)\n- *                 .map(Supplier::get)\n- *                 .collect(Collectors.joining(\", \", \"{ \", \" }\"));\n+ * <p> The 2-arg {@link #open(Joiner, Function) open} method can be used to create a\n+ * {@code StructuredTaskScope} that uses a different {@code ThreadFactory}, has a name for\n+ * the purposes of monitoring and management, or has a timeout that cancels the scope if\n+ * the timeout expires before or while waiting for subtasks to complete. The {@code open}\n+ * method is called with a {@linkplain Function function} that is applied to the default\n+ * configuration and returns a {@link Config Config} for the {@code StructuredTaskScope}\n+ * under construction.\n@@ -178,3 +219,9 @@\n- *         ...\n- *     }\n- * }\n+ * <p> The following example opens a new {@code StructuredTaskScope} with a {@code\n+ * ThreadFactory} that creates virtual threads {@linkplain Thread#setName(String) named}\n+ * \"duke-0\", \"duke-1\" ...\n+ * {@snippet lang = java:\n+ *    \/\/ @link substring=\"name\" target=\"Thread.Builder#name(String, long)\" :\n+ *    ThreadFactory factory = Thread.ofVirtual().name(\"duke-\", 0).factory();\n+ *\n+ *    \/\/ @link substring=\"withThreadFactory\" target=\"Config#withThreadFactory(ThreadFactory)\" :\n+ *    try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n@@ -182,1 +229,2 @@\n- * <h2>Extending StructuredTaskScope<\/h2>\n+ *        scope.fork( .. );   \/\/ runs in a virtual thread with name \"duke-0\"\n+ *        scope.fork( .. );   \/\/ runs in a virtual thread with name \"duke-1\"\n@@ -184,7 +232,1 @@\n- * {@code StructuredTaskScope} can be extended, and the {@link #handleComplete(Subtask)\n- * handleComplete} method overridden, to implement policies other than those implemented\n- * by {@code ShutdownOnSuccess} and {@code ShutdownOnFailure}. A subclass may, for example,\n- * collect the results of subtasks that complete successfully and ignore subtasks that\n- * fail. It may collect exceptions when subtasks fail. It may invoke the {@link #shutdown()\n- * shutdown} method to shut down and cause {@link #join() join} to wakeup when some\n- * condition arises.\n+ *        scope.join();\n@@ -192,5 +234,2 @@\n- * <p> A subclass will typically define methods to make available results, state, or other\n- * outcome to code that executes after the {@code join} method. A subclass that collects\n- * results and ignores subtasks that fail may define a method that returns the results.\n- * A subclass that implements a policy to shut down when a subtask fails may define a\n- * method to get the exception of the first subtask to fail.\n+ *     }\n+ *}\n@@ -198,3 +237,5 @@\n- * <p> The following is an example of a simple {@code StructuredTaskScope} implementation\n- * that collects homogenous subtasks that complete successfully. It defines the method\n- * \"{@code completedSuccessfully()}\" that the main task can invoke after it joins.\n+ * <p> A second example sets a timeout, represented by a {@link Duration}. The timeout\n+ * starts when the new scope is opened. If the timeout expires before the {@code join}\n+ * method has completed then the scope is <a href=\"#Cancallation\">cancelled<\/a>. This\n+ * interrupts the threads executing the two subtasks and causes the {@link #join() join}\n+ * method to throw {@link TimeoutException}.\n@@ -202,2 +243,1 @@\n- *     class CollectingScope<T> extends StructuredTaskScope<T> {\n- *         private final Queue<Subtask<? extends T>> subtasks = new LinkedTransferQueue<>();\n+ *    Duration timeout = Duration.ofSeconds(10);\n@@ -205,6 +245,4 @@\n- *         @Override\n- *         protected void handleComplete(Subtask<? extends T> subtask) {\n- *             if (subtask.state() == Subtask.State.SUCCESS) {\n- *                 subtasks.add(subtask);\n- *             }\n- *         }\n+ *    \/\/ @link substring=\"allSuccessfulOrThrow\" target=\"Joiner#allSuccessfulOrThrow()\" :\n+ *    try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+ *    \/\/ @link substring=\"withTimeout\" target=\"Config#withTimeout(Duration)\" :\n+ *                                              cf -> cf.withTimeout(timeout))) {\n@@ -212,5 +250,2 @@\n- *         @Override\n- *         public CollectingScope<T> join() throws InterruptedException {\n- *             super.join();\n- *             return this;\n- *         }\n+ *        scope.fork(callable1);\n+ *        scope.fork(callable2);\n@@ -218,6 +253,5 @@\n- *         public Stream<Subtask<? extends T>> completedSuccessfully() {\n- *             \/\/ @link substring=\"ensureOwnerAndJoined\" target=\"ensureOwnerAndJoined\" :\n- *             super.ensureOwnerAndJoined();\n- *             return subtasks.stream();\n- *         }\n- *     }\n+ *        List<String> result = scope.join()\n+ *                                   .map(Subtask::get)\n+ *                                   .toList();\n+ *\n+ *   }\n@@ -225,3 +259,0 @@\n- * <p> The implementations of the {@code completedSuccessfully()} method in the example\n- * invokes {@link #ensureOwnerAndJoined()} to ensure that the method can only be invoked\n- * by the owner thread and only after it has joined.\n@@ -229,1 +260,6 @@\n- * <h2><a id=\"TreeStructure\">Tree structure<\/a><\/h2>\n+ * <h2>Inheritance of scoped value bindings<\/h2>\n+ *\n+ * {@link ScopedValue} supports the execution of a method with a {@code ScopedValue} bound\n+ * to a value for the bounded period of execution of the method by the <em>current thread<\/em>.\n+ * It allows a value to be safely and efficiently shared to methods without using method\n+ * parameters.\n@@ -231,11 +267,11 @@\n- * Task scopes form a tree where parent-child relations are established implicitly when\n- * opening a new task scope:\n- * <ul>\n- *   <li> A parent-child relation is established when a thread started in a task scope\n- *   opens its own task scope. A thread started in task scope \"A\" that opens task scope\n- *   \"B\" establishes a parent-child relation where task scope \"A\" is the parent of task\n- *   scope \"B\".\n- *   <li> A parent-child relation is established with nesting. If a thread opens task\n- *   scope \"B\", then opens task scope \"C\" (before it closes \"B\"), then the enclosing task\n- *   scope \"B\" is the parent of the nested task scope \"C\".\n- * <\/ul>\n+ * <p> When used in conjunction with a {@code StructuredTaskScope}, a {@code ScopedValue}\n+ * can also safely and efficiently share a value to methods executed by subtasks forked\n+ * in the scope. When a {@code ScopedValue} object is bound to a value in the thread\n+ * executing the task then that binding is inherited by the threads created to\n+ * execute the subtasks. The thread executing the task does not continue beyond the\n+ * {@link #close() close} method until all threads executing the subtasks have finished.\n+ * This ensures that the {@code ScopedValue} is not reverted to being {@linkplain\n+ * ScopedValue#isBound() unbound} (or its previous value) while subtasks are executing.\n+ * In addition to providing a safe and efficient means to inherit a value into subtasks,\n+ * the inheritance allows sequential code using {@code ScopedValue} be refactored to use\n+ * structured concurrency.\n@@ -243,2 +279,7 @@\n- * The <i>descendants<\/i> of a task scope are the child task scopes that it is a parent\n- * of, plus the descendants of the child task scopes, recursively.\n+ * <p> To ensure correctness, opening a new {@code StructuredTaskScope} captures the\n+ * current thread's scoped value bindings. These are the scoped values bindings that are\n+ * inherited by the threads created to execute subtasks in the scope. Forking a\n+ * subtask checks that the bindings in effect at the time that the subtask is forked\n+ * match the bindings when the {@code StructuredTaskScope} was created. This check ensures\n+ * that a subtask does not inherit a binding that is reverted in the task before the\n+ * subtask has completed.\n@@ -246,6 +287,2 @@\n- * <p> The tree structure supports:\n- * <ul>\n- *   <li> Inheritance of {@linkplain ScopedValue scoped values} across threads.\n- *   <li> Confinement checks. The phrase \"threads contained in the task scope\" in method\n- *   descriptions means threads started in the task scope or descendant scopes.\n- * <\/ul>\n+ * <p> A {@code ScopedValue} that is shared across threads requires that the value be an\n+ * immutable object or for all access to the value to be appropriately synchronized.\n@@ -253,6 +290,7 @@\n- * <p> The following example demonstrates the inheritance of a scoped value. A scoped\n- * value {@code USERNAME} is bound to the value \"{@code duke}\". A {@code StructuredTaskScope}\n- * is created and its {@code fork} method invoked to start a thread to execute {@code\n- * childTask}. The thread inherits the scoped value <em>bindings<\/em> captured when\n- * creating the task scope. The code in {@code childTask} uses the value of the scoped\n- * value and so reads the value \"{@code duke}\".\n+ * <p> The following example demonstrates the inheritance of scoped value bindings. The\n+ * scoped value USERNAME is bound to the value \"duke\" for the bounded period of a lambda\n+ * expression by the thread executing it. The code in the block opens a {@code\n+ * StructuredTaskScope} and forks two subtasks, it then waits in the {@code join} method\n+ * and aggregates the results from both subtasks. If code executed by the threads\n+ * running subtask1 and subtask2 uses {@link ScopedValue#get()}, to get the value of\n+ * USERNAME, then value \"duke\" will be returned.\n@@ -260,0 +298,1 @@\n+ *     \/\/ @link substring=\"newInstance\" target=\"ScopedValue#newInstance()\" :\n@@ -262,3 +301,2 @@\n- *     \/\/ @link substring=\"run\" target=\"ScopedValue.Carrier#run(Runnable)\" :\n- *     ScopedValue.where(USERNAME, \"duke\").run(() -> {\n- *         try (var scope = new StructuredTaskScope<String>()) {\n+ *     \/\/ @link substring=\"callWhere\" target=\"ScopedValue#where\" :\n+ *     MyResult result = ScopedValue.where(USERNAME, \"duke\").call(() -> {\n@@ -266,4 +304,1 @@\n- *             scope.fork(() -> childTask());           \/\/ @highlight substring=\"fork\"\n- *             ...\n- *          }\n- *     });\n+ *         try (var scope = StructuredTaskScope.open()) {\n@@ -271,1 +306,2 @@\n- *     ...\n+ *             Subtask<String> subtask1 = scope.fork( .. );    \/\/ inherits binding\n+ *             Subtask<Integer> subtask2 = scope.fork( .. );   \/\/ inherits binding\n@@ -273,5 +309,5 @@\n- *     String childTask() {\n- *         \/\/ @link substring=\"get\" target=\"ScopedValue#get()\" :\n- *         String name = USERNAME.get();   \/\/ \"duke\"\n- *         ...\n- *     }\n+ *             scope.join();\n+ *             return new MyResult(subtask1.get(), subtask2.get());\n+ *         }\n+ *\n+ *     });\n@@ -280,2 +316,5 @@\n- * <p> {@code StructuredTaskScope} does not define APIs that exposes the tree structure\n- * at this time.\n+ * <p> A scoped value inherited into a subtask may be\n+ * <a href=\"{@docRoot}\/java.base\/java\/lang\/ScopedValues.html#rebind\">rebound<\/a> to a new\n+ * value in the subtask for the bounded execution of some method executed in the subtask.\n+ * When the method completes, the value of the {@code ScopedValue} reverts to its previous\n+ * value, the value inherited from the thread executing the task.\n@@ -283,2 +322,8 @@\n- * <p> Unless otherwise specified, passing a {@code null} argument to a constructor\n- * or method in this class will cause a {@link NullPointerException} to be thrown.\n+ * <p> A subtask may execute code that itself opens a new {@code StructuredTaskScope}.\n+ * A task executing in thread T1 opens a {@code StructuredTaskScope} and forks a\n+ * subtask that runs in thread T2. The scoped value bindings captured when T1 opens the\n+ * scope are inherited into T2. The subtask (in thread T2) executes code that opens a\n+ * new {@code StructuredTaskScope} and forks a subtask that runs in thread T3. The scoped\n+ * value bindings captured when T2 opens the scope are inherited into T3. These\n+ * include (or may be the same) as the bindings that were inherited from T1. In effect,\n+ * scoped values are inherited into a tree of subtasks, not just one level of subtask.\n@@ -288,1 +333,1 @@\n- * <p> Actions in the owner thread of, or a thread contained in, the task scope prior to\n+ * <p> Actions in the owner thread of a {@code StructuredTaskScope} prior to\n@@ -291,3 +336,2 @@\n- * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn <i>happen-before<\/i>\n- * the subtask result is {@linkplain Subtask#get() retrieved} or <i>happen-before<\/i> any\n- * actions taken in a thread after {@linkplain #join() joining} of the task scope.\n+ * <i>happen-before<\/i><\/a> any actions taken by that subtask, which in turn\n+ * <i>happen-before<\/i> the subtask result is {@linkplain Subtask#get() retrieved}.\n@@ -295,1 +339,1 @@\n- * @jls 17.4.5 Happens-before Order\n+ * <h2>General exceptions<\/h2>\n@@ -297,1 +341,7 @@\n- * @param <T> the result type of tasks executed in the task scope\n+ * <p> Unless otherwise specified, passing a {@code null} argument to a method in this\n+ * class will cause a {@link NullPointerException} to be thrown.\n+ *\n+ * @param <T> the result type of subtasks executed in the scope\n+ * @param <R> the result type of the scope\n+ *\n+ * @jls 17.4.5 Happens-before Order\n@@ -301,19 +351,3 @@\n-public class StructuredTaskScope<T> implements AutoCloseable {\n-    private final ThreadFactory factory;\n-    private final ThreadFlock flock;\n-    private final ReentrantLock shutdownLock = new ReentrantLock();\n-\n-    \/\/ states: OPEN -> SHUTDOWN -> CLOSED\n-    private static final int OPEN     = 0;   \/\/ initial state\n-    private static final int SHUTDOWN = 1;\n-    private static final int CLOSED   = 2;\n-\n-    \/\/ state: set to SHUTDOWN by any thread, set to CLOSED by owner, read by any thread\n-    private volatile int state;\n-\n-    \/\/ Counters to support checking that the task scope owner joins before processing\n-    \/\/ results and attempts join before closing the task scope. These counters are\n-    \/\/ accessed only by the owner thread.\n-    private int forkRound;         \/\/ incremented when the first subtask is forked after join\n-    private int lastJoinAttempted; \/\/ set to the current fork round when join is attempted\n-    private int lastJoinCompleted; \/\/ set to the current fork round when join completes\n+public sealed interface StructuredTaskScope<T, R>\n+        extends AutoCloseable\n+        permits StructuredTaskScopeImpl {\n@@ -322,1 +356,7 @@\n-     * Represents a subtask forked with {@link #fork(Callable)}.\n+     * Represents a subtask forked with {@link #fork(Callable)} or {@link #fork(Runnable)}.\n+     *\n+     * <p> Code that forks subtasks can use the {@link #get() get()} method after {@linkplain\n+     * #join() joining} to obtain the result of a subtask that completed successfully. It\n+     * can use the {@link #exception()} method to obtain the exception thrown by a subtask\n+     * that failed.\n+     *\n@@ -327,9 +367,1 @@\n-    public sealed interface Subtask<T> extends Supplier<T> permits SubtaskImpl {\n-        \/**\n-         * {@return the value returning task provided to the {@code fork} method}\n-         *\n-         * @apiNote Task objects with unique identity may be used for correlation by\n-         * implementations of {@link #handleComplete(Subtask) handleComplete}.\n-         *\/\n-        Callable<? extends T> task();\n-\n+    sealed interface Subtask<T> extends Supplier<T> permits StructuredTaskScopeImpl.SubtaskImpl {\n@@ -345,3 +377,3 @@\n-             * the subtask was forked but has not completed, it completed after the task\n-             * scope was {@linkplain #shutdown() shut down}, or it was forked after the\n-             * task scope was shut down.\n+             * the subtask was forked but has not completed, it completed after the scope\n+             * was cancelled, or it was forked after the scoped was cancelled (in which\n+             * case a thread was not created to execute the subtask).\n@@ -351,3 +383,2 @@\n-             * The subtask completed successfully with a result. The {@link Subtask#get()\n-             * Subtask.get()} method can be used to obtain the result. This is a terminal\n-             * state.\n+             * The subtask completed successfully. The {@link Subtask#get() Subtask.get()}\n+             * method can be used to get the result. This is a terminal state.\n@@ -358,1 +389,1 @@\n-             * Subtask.exception()} method can be used to obtain the exception. This is a\n+             * Subtask.exception()} method can be used to get the exception. This is a\n@@ -365,1 +396,1 @@\n-         * {@return the state of the subtask}\n+         * {@return the subtask state}\n@@ -370,1 +401,4 @@\n-         * Returns the result of the subtask.\n+         * Returns the result of this subtask if it completed successfully. If the subtask\n+         * was forked with {@link #fork(Callable) fork(Callable)} then the result from the\n+         * {@link Callable#call() call} method is returned. If the subtask was forked with\n+         * {@link #fork(Runnable) fork(Runnable)} then {@code null} is returned.\n@@ -372,3 +406,6 @@\n-         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n-         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n-         * joinUntil}) before it can obtain the result of the subtask.\n+         * <p> Code executing in the scope owner thread can use this method to get the\n+         * result of a successful subtask only after it has {@linkplain #join() joined}.\n+         *\n+         * <p> Code executing in the {@code Joiner} {@link Joiner#onComplete(Subtask)\n+         * onComplete} method should test that the {@linkplain #state() subtask state} is\n+         * {@link State#SUCCESS SUCCESS} before using this method to get the result.\n@@ -378,2 +415,2 @@\n-         * successfully, or the current thread is the task scope owner and did not join\n-         * after forking\n+         * successfully, or the current thread is the scope owner invoking this\n+         * method before {@linkplain #join() joining}\n@@ -385,1 +422,8 @@\n-         * {@return the exception thrown by the subtask}\n+         * {@return the exception or error thrown by this subtask if it failed}\n+         * If the subtask was forked with {@link #fork(Callable) fork(Callable)} then the\n+         * exception or error thrown by the {@link Callable#call() call} method is returned.\n+         * If the subtask was forked with {@link #fork(Runnable) fork(Runnable)} then the\n+         * exception or error thrown by the {@link Runnable#run() run} method is returned.\n+         *\n+         * <p> Code executing in the scope owner thread can use this method to get the\n+         * exception thrown by a failed subtask only after it has {@linkplain #join() joined}.\n@@ -387,3 +431,3 @@\n-         * <p> To ensure correct usage, if the scope owner {@linkplain #fork(Callable) forks}\n-         * a subtask, then it must join (with {@link #join() join} or {@link #joinUntil(Instant)\n-         * joinUntil}) before it can obtain the exception thrown by the subtask.\n+         * <p> Code executing in a {@code Joiner} {@link Joiner#onComplete(Subtask)\n+         * onComplete} method should test that the {@linkplain #state() subtask state} is\n+         * {@link State#FAILED FAILED} before using this method to get the exception.\n@@ -392,2 +436,2 @@\n-         * a result, or the current thread is the task scope owner and did not join after\n-         * forking\n+         * a result, or the current thread is the scope owner invoking this method\n+         * before {@linkplain #join() joining}\n@@ -400,148 +444,3 @@\n-     * Creates a structured task scope with the given name and thread factory. The task\n-     * scope is optionally named for the purposes of monitoring and management. The thread\n-     * factory is used to {@link ThreadFactory#newThread(Runnable) create} threads when\n-     * subtasks are {@linkplain #fork(Callable) forked}. The task scope is owned by the\n-     * current thread.\n-     *\n-     * <p> Construction captures the current thread's {@linkplain ScopedValue scoped value}\n-     * bindings for inheritance by threads started in the task scope. The\n-     * <a href=\"#TreeStructure\">Tree Structure<\/a> section in the class description details\n-     * how parent-child relations are established implicitly for the purpose of inheritance\n-     * of scoped value bindings.\n-     *\n-     * @param name the name of the task scope, can be null\n-     * @param factory the thread factory\n-     *\/\n-    @SuppressWarnings(\"this-escape\")\n-    public StructuredTaskScope(String name, ThreadFactory factory) {\n-        this.factory = Objects.requireNonNull(factory, \"'factory' is null\");\n-        if (name == null)\n-            name = Objects.toIdentityString(this);\n-        this.flock = ThreadFlock.open(name);\n-    }\n-\n-    \/**\n-     * Creates an unnamed structured task scope that creates virtual threads. The task\n-     * scope is owned by the current thread.\n-     *\n-     * @implSpec This constructor is equivalent to invoking the 2-arg constructor with a\n-     * name of {@code null} and a thread factory that creates virtual threads.\n-     *\/\n-    public StructuredTaskScope() {\n-        this(null, Thread.ofVirtual().factory());\n-    }\n-\n-    private IllegalStateException newIllegalStateExceptionScopeClosed() {\n-        return new IllegalStateException(\"Task scope is closed\");\n-    }\n-\n-    private IllegalStateException newIllegalStateExceptionNoJoin() {\n-        return new IllegalStateException(\"Owner did not join after forking subtasks\");\n-    }\n-\n-    \/**\n-     * Throws IllegalStateException if the scope is closed, returning the state if not\n-     * closed.\n-     *\/\n-    private int ensureOpen() {\n-        int s = state;\n-        if (s == CLOSED)\n-            throw newIllegalStateExceptionScopeClosed();\n-        return s;\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner.\n-     *\/\n-    private void ensureOwner() {\n-        if (Thread.currentThread() != flock.owner())\n-            throw new WrongThreadException(\"Current thread not owner\");\n-    }\n-\n-    \/**\n-     * Throws WrongThreadException if the current thread is not the owner\n-     * or a thread contained in the tree.\n-     *\/\n-    private void ensureOwnerOrContainsThread() {\n-        Thread currentThread = Thread.currentThread();\n-        if (currentThread != flock.owner() && !flock.containsThread(currentThread))\n-            throw new WrongThreadException(\"Current thread not owner or thread in the tree\");\n-    }\n-\n-    \/**\n-     * Throws IllegalStateException if the current thread is the owner, and the owner did\n-     * not join after forking a subtask in the given fork round.\n-     *\/\n-    private void ensureJoinedIfOwner(int round) {\n-        if (Thread.currentThread() == flock.owner() && (round > lastJoinCompleted)) {\n-            throw newIllegalStateExceptionNoJoin();\n-        }\n-    }\n-\n-    \/**\n-     * Ensures that the current thread is the owner of this task scope and that it joined\n-     * (with {@link #join()} or {@link #joinUntil(Instant)}) after {@linkplain #fork(Callable)\n-     * forking} subtasks.\n-     *\n-     * @apiNote This method can be used by subclasses that define methods to make available\n-     * results, state, or other outcome to code intended to execute after the join method.\n-     *\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws IllegalStateException if the task scope is open and task scope owner did\n-     * not join after forking\n-     *\/\n-    protected final void ensureOwnerAndJoined() {\n-        ensureOwner();\n-        if (forkRound > lastJoinCompleted) {\n-            throw newIllegalStateExceptionNoJoin();\n-        }\n-    }\n-\n-    \/**\n-     * Invoked by a subtask when it completes successfully or fails in this task scope.\n-     * This method is not invoked if a subtask completes after the task scope is\n-     * {@linkplain #shutdown() shut down}.\n-     *\n-     * @implSpec The default implementation throws {@code NullPointerException} if the\n-     * subtask is {@code null}. It throws {@link IllegalArgumentException} if the subtask\n-     * has not completed.\n-     *\n-     * @apiNote The {@code handleComplete} method should be thread safe. It may be\n-     * invoked by several threads concurrently.\n-     *\n-     * @param subtask the subtask\n-     *\n-     * @throws IllegalArgumentException if called with a subtask that has not completed\n-     *\/\n-    protected void handleComplete(Subtask<? extends T> subtask) {\n-        if (subtask.state() == Subtask.State.UNAVAILABLE)\n-            throw new IllegalArgumentException();\n-    }\n-\n-    \/**\n-     * Starts a new thread in this task scope to execute a value-returning task, thus\n-     * creating a <em>subtask<\/em> of this task scope.\n-     *\n-     * <p> The value-returning task is provided to this method as a {@link Callable}, the\n-     * thread executes the task's {@link Callable#call() call} method. The thread is\n-     * created with the task scope's {@link ThreadFactory}. It inherits the current thread's\n-     * {@linkplain ScopedValue scoped value} bindings. The bindings must match the bindings\n-     * captured when the task scope was created.\n-     *\n-     * <p> This method returns a {@link Subtask Subtask} to represent the <em>forked\n-     * subtask<\/em>. The {@code Subtask} object can be used to obtain the result when\n-     * the subtask completes successfully, or the exception when the subtask fails. To\n-     * ensure correct usage, the {@link Subtask#get() get()} and {@link Subtask#exception()\n-     * exception()} methods may only be called by the task scope owner after it has waited\n-     * for all threads to finish with the {@link #join() join} or {@link #joinUntil(Instant)}\n-     * methods. When the subtask completes, the thread invokes the {@link\n-     * #handleComplete(Subtask) handleComplete} method to consume the completed subtask.\n-     * If the task scope is {@linkplain #shutdown() shut down} before the subtask completes\n-     * then the {@code handleComplete} method will not be invoked.\n-     *\n-     * <p> If this task scope is {@linkplain #shutdown() shutdown} (or in the process of\n-     * shutting down) then the subtask will not run and the {@code handleComplete} method\n-     * will not be invoked.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope.\n+     * An object used with a {@link StructuredTaskScope} to handle subtask completion and\n+     * produce the result for the scope owner waiting in the {@link #join() join} method\n+     * for subtasks to complete.\n@@ -549,186 +448,1 @@\n-     * @implSpec This method may be overridden for customization purposes, wrapping tasks\n-     * for example. If overridden, the subclass must invoke {@code super.fork} to start a\n-     * new thread in this task scope.\n-     *\n-     * @param task the value-returning task for the thread to execute\n-     * @param <U> the result type\n-     * @return the subtask\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner or a\n-     * thread contained in the task scope\n-     * @throws StructureViolationException if the current scoped value bindings are not\n-     * the same as when the task scope was created\n-     * @throws RejectedExecutionException if the thread factory rejected creating a\n-     * thread to run the subtask\n-     *\/\n-    public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n-        Objects.requireNonNull(task, \"'task' is null\");\n-        int s = ensureOpen();   \/\/ throws ISE if closed\n-\n-        \/\/ when forked by the owner, the subtask is forked in the current or next round\n-        int round = -1;\n-        if (Thread.currentThread() == flock.owner()) {\n-            round = forkRound;\n-            if (forkRound == lastJoinCompleted) {\n-                \/\/ new round if first fork after join\n-                round++;\n-            }\n-        }\n-\n-        SubtaskImpl<U> subtask = new SubtaskImpl<>(this, task, round);\n-        if (s < SHUTDOWN) {\n-            \/\/ create thread to run task\n-            Thread thread = factory.newThread(subtask);\n-            if (thread == null) {\n-                throw new RejectedExecutionException(\"Rejected by thread factory\");\n-            }\n-\n-            \/\/ attempt to start the thread\n-            try {\n-                flock.start(thread);\n-            } catch (IllegalStateException e) {\n-                \/\/ shutdown by another thread, or underlying flock is shutdown due\n-                \/\/ to unstructured use\n-            }\n-        }\n-\n-        \/\/ force owner to join if this is the first fork in the round\n-        if (Thread.currentThread() == flock.owner() && round > forkRound) {\n-            forkRound = round;\n-        }\n-\n-        \/\/ return forked subtask or a subtask that did not run\n-        return subtask;\n-    }\n-\n-    \/**\n-     * Wait for all threads to finish or the task scope to shut down.\n-     *\/\n-    private void implJoin(Duration timeout)\n-        throws InterruptedException, TimeoutException\n-    {\n-        ensureOwner();\n-        lastJoinAttempted = forkRound;\n-        int s = ensureOpen();  \/\/ throws ISE if closed\n-        if (s == OPEN) {\n-            \/\/ wait for all threads, wakeup, interrupt, or timeout\n-            if (timeout != null) {\n-                flock.awaitAll(timeout);\n-            } else {\n-                flock.awaitAll();\n-            }\n-        }\n-        lastJoinCompleted = forkRound;\n-    }\n-\n-    \/**\n-     * Wait for all subtasks started in this task scope to finish or the task scope to\n-     * shut down.\n-     *\n-     * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-     * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-     * when all threads finish, the task scope is {@linkplain #shutdown() shut down}, or\n-     * the current thread is {@linkplain Thread#interrupt() interrupted}.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @implSpec This method may be overridden for customization purposes or to return a\n-     * more specific return type. If overridden, the subclass must invoke {@code\n-     * super.join} to ensure that the method waits for threads in this task scope to\n-     * finish.\n-     *\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws InterruptedException if interrupted while waiting\n-     *\/\n-    public StructuredTaskScope<T> join() throws InterruptedException {\n-        try {\n-            implJoin(null);\n-        } catch (TimeoutException e) {\n-            throw new InternalError();\n-        }\n-        return this;\n-    }\n-\n-    \/**\n-     * Wait for all subtasks started in this task scope to finish or the task scope to\n-     * shut down, up to the given deadline.\n-     *\n-     * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-     * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-     * when all threads finish, the task scope is {@linkplain #shutdown() shut down}, the\n-     * deadline is reached, or the current thread is {@linkplain Thread#interrupt()\n-     * interrupted}.\n-     *\n-     * <p> This method may only be invoked by the task scope owner.\n-     *\n-     * @implSpec This method may be overridden for customization purposes or to return a\n-     * more specific return type. If overridden, the subclass must invoke {@code\n-     * super.joinUntil} to ensure that the method waits for threads in this task scope to\n-     * finish.\n-     *\n-     * @param deadline the deadline\n-     * @return this task scope\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws InterruptedException if interrupted while waiting\n-     * @throws TimeoutException if the deadline is reached while waiting\n-     *\/\n-    public StructuredTaskScope<T> joinUntil(Instant deadline)\n-        throws InterruptedException, TimeoutException\n-    {\n-        Duration timeout = Duration.between(Instant.now(), deadline);\n-        implJoin(timeout);\n-        return this;\n-    }\n-\n-    \/**\n-     * Interrupt all unfinished threads.\n-     *\/\n-    private void interruptAll() {\n-        flock.threads()\n-            .filter(t -> t != Thread.currentThread())\n-            .forEach(t -> {\n-                try {\n-                    t.interrupt();\n-                } catch (Throwable ignore) { }\n-            });\n-    }\n-\n-    \/**\n-     * Shutdown the task scope if not already shutdown. Return true if this method\n-     * shutdowns the task scope, false if already shutdown.\n-     *\/\n-    private boolean implShutdown() {\n-        shutdownLock.lock();\n-        try {\n-            if (state < SHUTDOWN) {\n-                \/\/ prevent new threads from starting\n-                flock.shutdown();\n-\n-                \/\/ set status before interrupting tasks\n-                state = SHUTDOWN;\n-\n-                \/\/ interrupt all unfinished threads\n-                interruptAll();\n-\n-                return true;\n-            } else {\n-                \/\/ already shutdown\n-                return false;\n-            }\n-        } finally {\n-            shutdownLock.unlock();\n-        }\n-    }\n-\n-    \/**\n-     * Shut down this task scope without closing it. Shutting down a task scope prevents\n-     * new threads from starting, interrupts all unfinished threads, and causes the\n-     * {@link #join() join} method to wakeup. Shutdown is useful for cases where the\n-     * results of unfinished subtasks are no longer needed. It will typically be called\n-     * by the {@link #handleComplete(Subtask)} implementation of a subclass that\n-     * implements a policy to discard unfinished tasks once some outcome is reached.\n-     *\n-     * <p> More specifically, this method:\n+     * <p> Joiner defines static methods to create {@code Joiner} objects for common cases:\n@@ -736,5 +450,12 @@\n-     * <li> {@linkplain Thread#interrupt() Interrupts} all unfinished threads in the\n-     * task scope (except the current thread).\n-     * <li> Wakes up the task scope owner if it is waiting in {@link #join()} or {@link\n-     * #joinUntil(Instant)}. If the task scope owner is not waiting then its next call to\n-     * {@code join} or {@code joinUntil} will return immediately.\n+     *   <li> {@link #allSuccessfulOrThrow() allSuccessfulOrThrow()} creates a {@code Joiner}\n+     *   that yields a stream of the completed subtasks for {@code join} to return when\n+     *   all subtasks complete successfully. It cancels the scope and causes {@code join}\n+     *   to throw if any subtask fails.\n+     *   <li> {@link #anySuccessfulResultOrThrow() anySuccessfulResultOrThrow()} creates a\n+     *   {@code Joiner} that yields the result of the first subtask to succeed for {@code\n+     *   join} to return. It causes {@code join} to throw if all subtasks fail.\n+     *   <li> {@link #awaitAllSuccessfulOrThrow() awaitAllSuccessfulOrThrow()} creates a\n+     *   {@code Joiner} that waits for all successful subtasks. It cancels the scope and\n+     *   causes {@code join} to throw if any subtask fails.\n+     *   <li> {@link #awaitAll() awaitAll()} creates a {@code Joiner} that waits for all\n+     *   subtasks. It does not cancel the scope or cause {@code join} to throw.\n@@ -743,18 +464,6 @@\n-     * <p> The {@linkplain Subtask.State state} of unfinished subtasks that complete at\n-     * around the time that the task scope is shutdown is not defined. A subtask that\n-     * completes successfully with a result, or fails with an exception, at around\n-     * the time that the task scope is shutdown may or may not <i>transition<\/i> to a\n-     * terminal state.\n-     *\n-     * <p> This method may only be invoked by the task scope owner or threads contained\n-     * in the task scope.\n-     *\n-     * @implSpec This method may be overridden for customization purposes. If overridden,\n-     * the subclass must invoke {@code super.shutdown} to ensure that the method shuts\n-     * down the task scope.\n-     *\n-     * @apiNote\n-     * There may be threads that have not finished because they are executing code that\n-     * did not respond (or respond promptly) to thread interrupt. This method does not wait\n-     * for these threads. When the owner invokes the {@link #close() close} method\n-     * to close the task scope then it will wait for the remaining threads to finish.\n+     * <p> In addition to the methods to create {@code Joiner} objects for common cases,\n+     * the {@link #allUntil(Predicate) allUntil(Predicate)} method is defined to create a\n+     * {@code Joiner} that yields a stream of all subtasks. It is created with a {@link\n+     * Predicate Predicate} that determines if the scope should continue or be cancelled.\n+     * This {@code Joiner} can be built upon to create custom policies that cancel the\n+     * scope based on some condition.\n@@ -762,22 +471,8 @@\n-     * @throws IllegalStateException if this task scope is closed\n-     * @throws WrongThreadException if the current thread is not the task scope owner or\n-     * a thread contained in the task scope\n-     * @see #isShutdown()\n-     *\/\n-    public void shutdown() {\n-        ensureOwnerOrContainsThread();\n-        int s = ensureOpen();  \/\/ throws ISE if closed\n-        if (s < SHUTDOWN && implShutdown())\n-            flock.wakeup();\n-    }\n-\n-    \/**\n-     * {@return true if this task scope is shutdown, otherwise false}\n-     * @see #shutdown()\n-     *\/\n-    public final boolean isShutdown() {\n-        return state >= SHUTDOWN;\n-    }\n-\n-    \/**\n-     * Closes this task scope.\n+     * <p> More advanced policies can be developed by implementing the {@code Joiner}\n+     * interface. The {@link #onFork(Subtask)} method is invoked when subtasks are forked.\n+     * The {@link #onComplete(Subtask)} method is invoked when subtasks complete with a\n+     * result or exception. These methods return a {@code boolean} to indicate if scope\n+     * should be cancelled. These methods can be used to collect subtasks, results, or\n+     * exceptions, and control when to cancel the scope. The {@link #result()} method\n+     * must be implemented to produce the result (or exception) for the {@code join}\n+     * method.\n@@ -785,4 +480,2 @@\n-     * <p> This method first shuts down the task scope (as if by invoking the {@link\n-     * #shutdown() shutdown} method). It then waits for the threads executing any\n-     * unfinished tasks to finish. If interrupted, this method will continue to wait for\n-     * the threads to finish before completing with the interrupt status set.\n+     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n+     * in this class will cause a {@link NullPointerException} to be thrown.\n@@ -790,2 +483,3 @@\n-     * <p> This method may only be invoked by the task scope owner. If the task scope\n-     * is already closed then the task scope owner invoking this method has no effect.\n+     * @implSpec Implementations of this interface must be thread safe. The {@link\n+     * #onComplete(Subtask)} method defined by this interface may be invoked by several\n+     * threads concurrently.\n@@ -793,14 +487,3 @@\n-     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n-     * manner<\/em>. If this method is called to close a task scope before nested task\n-     * scopes are closed then it closes the underlying construct of each nested task scope\n-     * (in the reverse order that they were created in), closes this task scope, and then\n-     * throws {@link StructureViolationException}.\n-     * Similarly, if this method is called to close a task scope while executing with\n-     * {@linkplain ScopedValue scoped value} bindings, and the task scope was created\n-     * before the scoped values were bound, then {@code StructureViolationException} is\n-     * thrown after closing the task scope.\n-     * If a thread terminates without first closing task scopes that it owns then\n-     * termination will cause the underlying construct of each of its open tasks scopes to\n-     * be closed. Closing is performed in the reverse order that the task scopes were\n-     * created in. Thread termination may therefore be delayed when the task scope owner\n-     * has to wait for threads forked in these task scopes to finish.\n+     * @apiNote It is very important that a new {@code Joiner} object is created for each\n+     * {@code StructuredTaskScope}. {@code Joiner} objects should never be shared with\n+     * different scopes or re-used after a task is closed.\n@@ -808,2 +491,6 @@\n-     * @implSpec This method may be overridden for customization purposes. If overridden,\n-     * the subclass must invoke {@code super.close} to close the task scope.\n+     * <p> Designing a {@code Joiner} should take into account the code at the use-site\n+     * where the results from the {@link StructuredTaskScope#join() join} method are\n+     * processed. It should be clear what the {@code Joiner} does vs. the application\n+     * code at the use-site. In general, the {@code Joiner} implementation is not the\n+     * place to code \"business logic\". A {@code Joiner} should be designed to be as\n+     * general purpose as possible.\n@@ -811,40 +498,4 @@\n-     * @throws IllegalStateException thrown after closing the task scope if the task scope\n-     * owner did not attempt to join after forking\n-     * @throws WrongThreadException if the current thread is not the task scope owner\n-     * @throws StructureViolationException if a structure violation was detected\n-     *\/\n-    @Override\n-    public void close() {\n-        ensureOwner();\n-        int s = state;\n-        if (s == CLOSED)\n-            return;\n-\n-        try {\n-            if (s < SHUTDOWN)\n-                implShutdown();\n-            flock.close();\n-        } finally {\n-            state = CLOSED;\n-        }\n-\n-        \/\/ throw ISE if the owner didn't attempt to join after forking\n-        if (forkRound > lastJoinAttempted) {\n-            lastJoinCompleted = forkRound;\n-            throw newIllegalStateExceptionNoJoin();\n-        }\n-    }\n-\n-    @Override\n-    public String toString() {\n-        String name = flock.name();\n-        return switch (state) {\n-            case OPEN     -> name;\n-            case SHUTDOWN -> name + \"\/shutdown\";\n-            case CLOSED   -> name + \"\/closed\";\n-            default -> throw new InternalError();\n-        };\n-    }\n-\n-    \/**\n-     * Subtask implementation, runs the task specified to the fork method.\n+     * @param <T> the result type of subtasks executed in the scope\n+     * @param <R> the result type of the scope\n+     * @since 24\n+     * @see #open(Joiner)\n@@ -852,73 +503,23 @@\n-    private static final class SubtaskImpl<T> implements Subtask<T>, Runnable {\n-        private static final AltResult RESULT_NULL = new AltResult(Subtask.State.SUCCESS);\n-\n-        private record AltResult(Subtask.State state, Throwable exception) {\n-            AltResult(Subtask.State state) {\n-                this(state, null);\n-            }\n-        }\n-\n-        private final StructuredTaskScope<? super T> scope;\n-        private final Callable<? extends T> task;\n-        private final int round;\n-        private volatile Object result;\n-\n-        SubtaskImpl(StructuredTaskScope<? super T> scope,\n-                    Callable<? extends T> task,\n-                    int round) {\n-            this.scope = scope;\n-            this.task = task;\n-            this.round = round;\n-        }\n-\n-        @Override\n-        public void run() {\n-            T result = null;\n-            Throwable ex = null;\n-            try {\n-                result = task.call();\n-            } catch (Throwable e) {\n-                ex = e;\n-            }\n-\n-            \/\/ nothing to do if task scope is shutdown\n-            if (scope.isShutdown())\n-                return;\n-\n-            \/\/ capture result or exception, invoke handleComplete\n-            if (ex == null) {\n-                this.result = (result != null) ? result : RESULT_NULL;\n-            } else {\n-                this.result = new AltResult(State.FAILED, ex);\n-            }\n-            scope.handleComplete(this);\n-        }\n-\n-        @Override\n-        public Callable<? extends T> task() {\n-            return task;\n-        }\n-\n-        @Override\n-        public Subtask.State state() {\n-            Object result = this.result;\n-            if (result == null) {\n-                return State.UNAVAILABLE;\n-            } else if (result instanceof AltResult alt) {\n-                \/\/ null or failed\n-                return alt.state();\n-            } else {\n-                return State.SUCCESS;\n-            }\n-        }\n-\n-        @Override\n-        public T get() {\n-            scope.ensureJoinedIfOwner(round);\n-            Object result = this.result;\n-            if (result instanceof AltResult) {\n-                if (result == RESULT_NULL) return null;\n-            } else if (result != null) {\n-                @SuppressWarnings(\"unchecked\")\n-                T r = (T) result;\n-                return r;\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    @FunctionalInterface\n+    interface Joiner<T, R> {\n+        \/**\n+         * Invoked by {@link #fork(Callable) fork(Callable)} and {@link #fork(Runnable)\n+         * fork(Runnable)} when forking a subtask. The method is invoked from the task\n+         * owner thread. The method is invoked before a thread is created to run the\n+         * subtask.\n+         *\n+         * @implSpec The default implementation throws {@code NullPointerException} if the\n+         * subtask is {@code null}. It throws {@code IllegalArgumentException} if the\n+         * subtask is not in the {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state, it\n+         * otherwise returns {@code false}.\n+         *\n+         * @apiNote This method is invoked by the {@code fork} methods. It should not be\n+         * invoked directly.\n+         *\n+         * @param subtask the subtask\n+         * @return {@code true} to cancel the scope, otherwise {@code false}\n+         *\/\n+        default boolean onFork(Subtask<? extends T> subtask) {\n+            if (subtask.state() != Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n@@ -926,2 +527,1 @@\n-            throw new IllegalStateException(\n-                    \"Result is unavailable or subtask did not complete successfully\");\n+            return false;\n@@ -930,6 +530,19 @@\n-        @Override\n-        public Throwable exception() {\n-            scope.ensureJoinedIfOwner(round);\n-            Object result = this.result;\n-            if (result instanceof AltResult alt && alt.state() == State.FAILED) {\n-                return alt.exception();\n+        \/**\n+         * Invoked by the thread started to execute a subtask after the subtask completes\n+         * successfully or fails with an exception. This method is not invoked if a\n+         * subtask completes after the scope is cancelled.\n+         *\n+         * @implSpec The default implementation throws {@code NullPointerException} if the\n+         * subtask is {@code null}. It throws {@code IllegalArgumentException} if the\n+         * subtask is not in the {@link Subtask.State#SUCCESS SUCCESS} or {@link\n+         * Subtask.State#FAILED FAILED} state, it otherwise returns {@code false}.\n+         *\n+         * @apiNote This method is invoked by subtasks when they complete. It should not\n+         * be invoked directly.\n+         *\n+         * @param subtask the subtask\n+         * @return {@code true} to cancel the scope, otherwise {@code false}\n+         *\/\n+        default boolean onComplete(Subtask<? extends T> subtask) {\n+            if (subtask.state() == Subtask.State.UNAVAILABLE) {\n+                throw new IllegalArgumentException();\n@@ -937,45 +550,1 @@\n-            throw new IllegalStateException(\n-                    \"Exception is unavailable or subtask did not complete with exception\");\n-        }\n-\n-        @Override\n-        public String toString() {\n-            String stateAsString = switch (state()) {\n-                case UNAVAILABLE -> \"[Unavailable]\";\n-                case SUCCESS     -> \"[Completed successfully]\";\n-                case FAILED      -> {\n-                    Throwable ex = ((AltResult) result).exception();\n-                    yield \"[Failed: \" + ex + \"]\";\n-                }\n-            };\n-            return Objects.toIdentityString(this) + stateAsString;\n-        }\n-    }\n-\n-    \/**\n-     * A {@code StructuredTaskScope} that captures the result of the first subtask to\n-     * complete {@linkplain Subtask.State#SUCCESS successfully}. Once captured, it\n-     * {@linkplain #shutdown() shuts down} the task scope to interrupt unfinished threads\n-     * and wakeup the task scope owner. The policy implemented by this class is intended\n-     * for cases where the result of any subtask will do (\"invoke any\") and where the\n-     * results of other unfinished subtasks are no longer needed.\n-     *\n-     * <p> Unless otherwise specified, passing a {@code null} argument to a method\n-     * in this class will cause a {@link NullPointerException} to be thrown.\n-     *\n-     * @apiNote This class implements a policy to shut down the task scope when a subtask\n-     * completes successfully. There shouldn't be any need to directly shut down the task\n-     * scope with the {@link #shutdown() shutdown} method.\n-     *\n-     * @param <T> the result type\n-     * @since 21\n-     *\/\n-    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n-    public static final class ShutdownOnSuccess<T> extends StructuredTaskScope<T> {\n-        private static final Object RESULT_NULL = new Object();\n-        private static final VarHandle FIRST_RESULT;\n-        private static final VarHandle FIRST_EXCEPTION;\n-        static {\n-            MethodHandles.Lookup l = MethodHandles.lookup();\n-            FIRST_RESULT = MhUtil.findVarHandle(l, \"firstResult\", Object.class);\n-            FIRST_EXCEPTION = MhUtil.findVarHandle(l, \"firstException\", Throwable.class);\n+            return false;\n@@ -983,2 +552,0 @@\n-        private volatile Object firstResult;\n-        private volatile Throwable firstException;\n@@ -987,5 +554,5 @@\n-         * Constructs a new {@code ShutdownOnSuccess} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n-         * is owned by the current thread.\n+         * Invoked by the {@link #join() join()} method to produce the result (or exception)\n+         * after waiting for all subtasks to complete or the scope cancelled. The result\n+         * from this method is returned by the {@code join} method. If this method throws,\n+         * then {@code join} throws {@link FailedException} with the exception thrown by\n+         * this method as the cause.\n@@ -993,5 +560,5 @@\n-         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n-         * value} bindings for inheritance by threads started in the task scope. The\n-         * {@linkplain StructuredTaskScope##TreeStructure Tree Structure} section\n-         * in the class description details how parent-child relations are established\n-         * implicitly for the purpose of inheritance of scoped value bindings.\n+         * <p> In normal usage, this method will be called at most once by the {@code join}\n+         * method to produce the result (or exception). The behavior of this method when\n+         * invoked directly, and invoked more than once, is not specified. Where possible,\n+         * an implementation should return an equal result (or throw the same exception)\n+         * on second or subsequent calls to produce the outcome.\n@@ -999,2 +566,5 @@\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n+         * @apiNote This method is invoked by the {@code join} method. It should not be\n+         * invoked directly.\n+         *\n+         * @return the result\n+         * @throws Throwable the exception\n@@ -1002,3 +572,1 @@\n-        public ShutdownOnSuccess(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n+        R result() throws Throwable;\n@@ -1007,1 +575,9 @@\n-         * Constructs a new unnamed {@code ShutdownOnSuccess} that creates virtual threads.\n+         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * subtasks complete successfully}\n+         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * the scope and causes {@code join} to throw if any subtask fails.\n+         *\n+         * <p> If all subtasks complete successfully, the joiner's {@link Joiner#result()}\n+         * method returns a stream of all subtasks in the order that they were forked.\n+         * If any subtask failed then the {@code result} method throws the exception from\n+         * the first subtask to fail.\n@@ -1009,2 +585,6 @@\n-         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n-         * a name of {@code null} and a thread factory that creates virtual threads.\n+         * @apiNote Joiners returned by this method are suited to cases where all subtasks\n+         * return a result of the same type. Joiners returned by {@link\n+         * #awaitAllSuccessfulOrThrow()} are suited to cases where the subtasks return\n+         * results of different types.\n+         *\n+         * @param <T> the result type of subtasks\n@@ -1012,22 +592,2 @@\n-        public ShutdownOnSuccess() {\n-            this(null, Thread.ofVirtual().factory());\n-        }\n-\n-        @Override\n-        protected void handleComplete(Subtask<? extends T> subtask) {\n-            if (firstResult != null) {\n-                \/\/ already captured a result\n-                return;\n-            }\n-\n-            if (subtask.state() == Subtask.State.SUCCESS) {\n-                \/\/ task succeeded\n-                T result = subtask.get();\n-                Object r = (result != null) ? result : RESULT_NULL;\n-                if (FIRST_RESULT.compareAndSet(this, null, r)) {\n-                    super.shutdown();\n-                }\n-            } else if (firstException == null) {\n-                \/\/ capture the exception thrown by the first subtask that failed\n-                FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception());\n-            }\n+        static <T> Joiner<T, Stream<Subtask<T>>> allSuccessfulOrThrow() {\n+            return new Joiners.AllSuccessful<>();\n@@ -1037,9 +597,3 @@\n-         * Wait for a subtask started in this task scope to complete {@linkplain\n-         * Subtask.State#SUCCESS successfully} or all subtasks to complete.\n-         *\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask completes successfully, or the current\n-         * thread is {@linkplain Thread#interrupt() interrupted}. It also stops waiting\n-         * if the {@link #shutdown() shutdown} method is invoked directly to shut down\n-         * this task scope.\n+         * {@return a new Joiner object that yields the result of any subtask that\n+         * completed successfully}\n+         * The {@code Joiner} causes {@code join} to throw if all subtasks fail.\n@@ -1047,1 +601,4 @@\n-         * <p> This method may only be invoked by the task scope owner.\n+         * <p> The joiner's {@link Joiner#result()} method returns the result of a subtask\n+         * that completed successfully. If all subtasks fail then the {@code result} method\n+         * throws the exception from one of the failed subtasks. The {@code result} method\n+         * throws {@code NoSuchElementException} if no subtasks were forked.\n@@ -1049,2 +606,1 @@\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n+         * @param <T> the result type of subtasks\n@@ -1052,4 +608,2 @@\n-        @Override\n-        public ShutdownOnSuccess<T> join() throws InterruptedException {\n-            super.join();\n-            return this;\n+        static <T> Joiner<T, T> anySuccessfulResultOrThrow() {\n+            return new Joiners.AnySuccessful<>();\n@@ -1059,3 +613,3 @@\n-         * Wait for a subtask started in this task scope to complete {@linkplain\n-         * Subtask.State#SUCCESS successfully} or all subtasks to complete, up to the\n-         * given deadline.\n+         * {@return a new Joiner object that waits for subtasks to complete successfully}\n+         * The {@code Joiner} <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a>\n+         * the scope and causes {@code join} to throw if any subtask fails.\n@@ -1063,6 +617,3 @@\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask completes successfully, the deadline is\n-         * reached, or the current thread is {@linkplain Thread#interrupt() interrupted}.\n-         * It also stops waiting if the {@link #shutdown() shutdown} method is invoked\n-         * directly to shut down this task scope.\n+         * <p> The joiner's {@link Joiner#result() result} method returns {@code null}\n+         * if all subtasks complete successfully, or throws the exception from the first\n+         * subtask to fail.\n@@ -1070,1 +621,3 @@\n-         * <p> This method may only be invoked by the task scope owner.\n+         * @apiNote Joiners returned by this method are suited to cases where subtasks\n+         * return results of different types. Joiners returned by {@link #allSuccessfulOrThrow()}\n+         * are suited to cases where the subtasks return a result of the same type.\n@@ -1072,2 +625,1 @@\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n+         * @param <T> the result type of subtasks\n@@ -1075,6 +627,2 @@\n-        @Override\n-        public ShutdownOnSuccess<T> joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n+        static <T> Joiner<T, Void> awaitAllSuccessfulOrThrow() {\n+            return new Joiners.AwaitSuccessful<>();\n@@ -1084,2 +632,4 @@\n-         * {@return the result of the first subtask that completed {@linkplain\n-         * Subtask.State#SUCCESS successfully}}\n+         * {@return a new Joiner object that waits for all subtasks to complete}\n+         * The {@code Joiner} does not cancel the scope if a subtask fails.\n+         *\n+         * <p> The joiner's {@link Joiner#result() result} method returns {@code null}.\n@@ -1087,3 +637,4 @@\n-         * <p> When no subtask completed successfully, but a subtask {@linkplain\n-         * Subtask.State#FAILED failed} then {@code ExecutionException} is thrown with\n-         * the subtask's exception as the {@linkplain Throwable#getCause() cause}.\n+         * @apiNote This Joiner is useful for cases where subtasks make use of\n+         * <em>side-effects<\/em> rather than return results or fail with exceptions.\n+         * The {@link #fork(Runnable) fork(Runnable)} method can be used to fork subtasks\n+         * that do not return a result.\n@@ -1091,5 +642,16 @@\n-         * @throws ExecutionException if no subtasks completed successfully but at least\n-         * one subtask failed\n-         * @throws IllegalStateException if no subtasks completed or the task scope owner\n-         * did not join after forking\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * <p> This Joiner can also be used for <em>fan-in<\/em> scenarios where subtasks\n+         * are forked to handle incoming connections and the number of subtasks is unbounded.\n+         * In this example, the thread executing the {@code acceptLoop} method will only\n+         * stop when interrupted or the listener socket is closed asynchronously.\n+         * {@snippet lang=java :\n+         *   void acceptLoop(ServerSocket listener) throws IOException, InterruptedException {\n+         *       try (var scope = StructuredTaskScope.open(Joiner.<Socket>awaitAll())) {\n+         *           while (true) {\n+         *               Socket socket = listener.accept();\n+         *               scope.fork(() -> handle(socket));\n+         *           }\n+         *       }\n+         *   }\n+         * }\n+         *\n+         * @param <T> the result type of subtasks\n@@ -1097,2 +659,8 @@\n-        public T result() throws ExecutionException {\n-            return result(ExecutionException::new);\n+        static <T> Joiner<T, Void> awaitAll() {\n+            \/\/ ensure that new Joiner object is returned\n+            return new Joiner<T, Void>() {\n+                @Override\n+                public Void result() {\n+                    return null;\n+                }\n+            };\n@@ -1102,3 +670,31 @@\n-         * Returns the result of the first subtask that completed {@linkplain\n-         * Subtask.State#SUCCESS successfully}, otherwise throws an exception produced\n-         * by the given exception supplying function.\n+         * {@return a new Joiner object that yields a stream of all subtasks when all\n+         * subtasks complete or a predicate returns {@code true} to cancel the scope}\n+         *\n+         * <p> The joiner's {@link Joiner#onComplete(Subtask)} method invokes the\n+         * predicate's {@link Predicate#test(Object) test} method with the subtask that\n+         * completed successfully or failed with an exception. If the {@code test} method\n+         * returns {@code true} then <a href=\"StructuredTaskScope.html#Cancallation\">\n+         * the scope is cancelled<\/a>. The {@code test} method must be thread safe as it\n+         * may be invoked concurrently from several threads. If the {@code test} method\n+         * completes with an exception or error, then the thread that executed the subtask\n+         * invokes the {@linkplain Thread.UncaughtExceptionHandler uncaught exception handler}\n+         * with the exception or error before the thread terminates.\n+         *\n+         * <p> The joiner's {@link #result()} method returns the stream of all subtasks,\n+         * in fork order. The stream may contain subtasks that have completed\n+         * (in {@link Subtask.State#SUCCESS SUCCESS} or {@link Subtask.State#FAILED FAILED}\n+         * state) or subtasks in the {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state\n+         * if the scope was cancelled before all subtasks were forked or completed.\n+         *\n+         * <p> The following example uses this method to create a {@code Joiner} that\n+         * <a href=\"StructuredTaskScope.html#Cancallation\">cancels<\/a> the scope when\n+         * two or more subtasks fail.\n+         * {@snippet lang=java :\n+         *    class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+         *         private final AtomicInteger failedCount = new AtomicInteger();\n+         *         @Override\n+         *         public boolean test(Subtask<? extends T> subtask) {\n+         *             return subtask.state() == Subtask.State.FAILED\n+         *                     && failedCount.incrementAndGet() >= 2;\n+         *         }\n+         *     }\n@@ -1106,3 +702,2 @@\n-         * <p> When no subtask completed successfully, but a subtask {@linkplain\n-         * Subtask.State#FAILED failed}, then the exception supplying function is invoked\n-         * with subtask's exception.\n+         *     var joiner = Joiner.all(new CancelAfterTwoFailures<String>());\n+         * }\n@@ -1110,3 +705,11 @@\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         * @return the result of the first subtask that completed with a result\n+         * <p> The following example uses {@code allUntil} to wait for all subtasks to\n+         * complete without any cancellation. This is similar to {@link #awaitAll()}\n+         * except that it yields a stream of the completed subtasks.\n+         * {@snippet lang=java :\n+         *    <T> List<Subtask<T>> invokeAll(Collection<Callable<T>> tasks) throws InterruptedException {\n+         *        try (var scope = StructuredTaskScope.open(Joiner.<T>allUntil(_ -> false))) {\n+         *            tasks.forEach(scope::fork);\n+         *            return scope.join().toList();\n+         *        }\n+         *    }\n+         * }\n@@ -1114,4 +717,2 @@\n-         * @throws X if no subtasks completed successfully but at least one subtask failed\n-         * @throws IllegalStateException if no subtasks completed or the task scope owner\n-         * did not join after forking\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n+         * @param isDone the predicate to evaluate completed subtasks\n+         * @param <T> the result type of subtasks\n@@ -1119,21 +720,2 @@\n-        public <X extends Throwable> T result(Function<Throwable, ? extends X> esf) throws X {\n-            Objects.requireNonNull(esf);\n-            ensureOwnerAndJoined();\n-\n-            Object result = firstResult;\n-            if (result == RESULT_NULL) {\n-                return null;\n-            } else if (result != null) {\n-                @SuppressWarnings(\"unchecked\")\n-                T r = (T) result;\n-                return r;\n-            }\n-\n-            Throwable exception = firstException;\n-            if (exception != null) {\n-                X ex = esf.apply(exception);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-\n-            throw new IllegalStateException(\"No completed subtasks\");\n+        static <T> Joiner<T, Stream<Subtask<T>>> allUntil(Predicate<Subtask<? extends T>> isDone) {\n+            return new Joiners.AllSubtasks<>(isDone);\n@@ -1144,6 +726,18 @@\n-     * A {@code StructuredTaskScope} that captures the exception of the first subtask to\n-     * {@linkplain Subtask.State#FAILED fail}. Once captured, it {@linkplain #shutdown()\n-     * shuts down} the task scope to interrupt unfinished threads and wakeup the task\n-     * scope owner. The policy implemented by this class is intended for cases where the\n-     * results for all subtasks are required (\"invoke all\"); if any subtask fails then the\n-     * results of other unfinished subtasks are no longer needed.\n+     * Represents the configuration for a {@code StructuredTaskScope}.\n+     *\n+     * <p> The configuration for a {@code StructuredTaskScope} consists of a {@link\n+     * ThreadFactory} to create threads, an optional name for the purposes of monitoring\n+     * and management, and an optional timeout.\n+     *\n+     * <p> Creating a {@code StructuredTaskScope} with {@link #open()} or {@link #open(Joiner)}\n+     * uses the <a href=\"StructuredTaskScope.html#DefaultConfiguration\">default\n+     * configuration<\/a>. The default configuration consists of a thread factory that\n+     * creates unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">\n+     * virtual threads<\/a>, no name for monitoring and management purposes, and no timeout.\n+     *\n+     * <p> Creating a {@code StructuredTaskScope} with its 2-arg {@link #open(Joiner, Function)\n+     * open} method allows a different configuration to be used. The function specified\n+     * to the {@code open} method is applied to the default configuration and returns the\n+     * configuration for the {@code StructuredTaskScope} under construction. The function\n+     * can use the {@code with-} prefixed methods defined here to specify the components\n+     * of the configuration to use.\n@@ -1154,5 +748,1 @@\n-     * @apiNote This class implements a policy to shut down the task scope when a subtask\n-     * fails. There shouldn't be any need to directly shut down the task scope with the\n-     * {@link #shutdown() shutdown} method.\n-     *\n-     * @since 21\n+     * @since 24\n@@ -1161,5 +751,1 @@\n-    public static final class ShutdownOnFailure extends StructuredTaskScope<Object> {\n-        private static final VarHandle FIRST_EXCEPTION =\n-                MhUtil.findVarHandle(MethodHandles.lookup(), \"firstException\", Throwable.class);\n-        private volatile Throwable firstException;\n-\n+    sealed interface Config permits StructuredTaskScopeImpl.ConfigImpl {\n@@ -1167,5 +753,4 @@\n-         * Constructs a new {@code ShutdownOnFailure} with the given name and thread factory.\n-         * The task scope is optionally named for the purposes of monitoring and management.\n-         * The thread factory is used to {@link ThreadFactory#newThread(Runnable) create}\n-         * threads when subtasks are {@linkplain #fork(Callable) forked}. The task scope\n-         * is owned by the current thread.\n+         * {@return a new {@code Config} object with the given thread factory}\n+         * The other components are the same as this object. The thread factory is used by\n+         * a scope to create threads when {@linkplain #fork(Callable) forking} subtasks.\n+         * @param threadFactory the thread factory\n@@ -1173,5 +758,4 @@\n-         * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n-         * value} bindings for inheritance by threads started in the task scope. The\n-         * {@linkplain StructuredTaskScope##TreeStructure Tree Structure} section in the class description\n-         * details how parent-child relations are established implicitly for the purpose\n-         * of inheritance of scoped value bindings.\n+         * @apiNote The thread factory will typically create\n+         * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n+         * maybe with names for monitoring purposes, an {@linkplain Thread.UncaughtExceptionHandler\n+         * uncaught exception handler}, or other properties configured.\n@@ -1179,2 +763,1 @@\n-         * @param name the name of the task scope, can be null\n-         * @param factory the thread factory\n+         * @see #fork(Callable)\n@@ -1182,3 +765,1 @@\n-        public ShutdownOnFailure(String name, ThreadFactory factory) {\n-            super(name, factory);\n-        }\n+        Config withThreadFactory(ThreadFactory threadFactory);\n@@ -1187,4 +768,4 @@\n-         * Constructs a new unnamed {@code ShutdownOnFailure} that creates virtual threads.\n-         *\n-         * @implSpec This constructor is equivalent to invoking the 2-arg constructor with\n-         * a name of {@code null} and a thread factory that creates virtual threads.\n+         * {@return a new {@code Config} object with the given name}\n+         * The other components are the same as this object. A scope is optionally\n+         * named for the purposes of monitoring and management.\n+         * @param name the name\n@@ -1192,12 +773,1 @@\n-        public ShutdownOnFailure() {\n-            this(null, Thread.ofVirtual().factory());\n-        }\n-\n-        @Override\n-        protected void handleComplete(Subtask<?> subtask) {\n-            if (subtask.state() == Subtask.State.FAILED\n-                    && firstException == null\n-                    && FIRST_EXCEPTION.compareAndSet(this, null, subtask.exception())) {\n-                super.shutdown();\n-            }\n-        }\n+        Config withName(String name);\n@@ -1206,2 +776,3 @@\n-         * Wait for all subtasks started in this task scope to complete or for a subtask\n-         * to {@linkplain Subtask.State#FAILED fail}.\n+         * {@return a new {@code Config} object with the given timeout}\n+         * The other components are the same as this object.\n+         * @param timeout the timeout\n@@ -1209,5 +780,3 @@\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask fails, or the current thread is {@linkplain\n-         * Thread#interrupt() interrupted}. It also stops waiting if the {@link #shutdown()\n-         * shutdown} method is invoked directly to shut down this task scope.\n+         * @apiNote Applications using deadlines, expressed as an {@link java.time.Instant},\n+         * can use {@link Duration#between Duration.between(Instant.now(), deadline)} to\n+         * compute the timeout for this method.\n@@ -1215,4 +784,1 @@\n-         * <p> This method may only be invoked by the task scope owner.\n-         *\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n+         * @see #join()\n@@ -1220,5 +786,2 @@\n-        @Override\n-        public ShutdownOnFailure join() throws InterruptedException {\n-            super.join();\n-            return this;\n-        }\n+        Config withTimeout(Duration timeout);\n+    }\n@@ -1226,23 +789,10 @@\n-        \/**\n-         * Wait for all subtasks started in this task scope to complete or for a subtask\n-         * to {@linkplain Subtask.State#FAILED fail}, up to the given deadline.\n-         *\n-         * <p> This method waits for all subtasks by waiting for all threads {@linkplain\n-         * #fork(Callable) started} in this task scope to finish execution. It stops waiting\n-         * when all threads finish, a subtask fails, the deadline is reached, or the current\n-         * thread is {@linkplain Thread#interrupt() interrupted}. It also stops waiting\n-         * if the {@link #shutdown() shutdown} method is invoked directly to shut down\n-         * this task scope.\n-         *\n-         * <p> This method may only be invoked by the task scope owner.\n-         *\n-         * @throws IllegalStateException {@inheritDoc}\n-         * @throws WrongThreadException {@inheritDoc}\n-         *\/\n-        @Override\n-        public ShutdownOnFailure joinUntil(Instant deadline)\n-            throws InterruptedException, TimeoutException\n-        {\n-            super.joinUntil(deadline);\n-            return this;\n-        }\n+    \/**\n+     * Exception thrown by {@link #join()} when the outcome is an exception rather than a\n+     * result.\n+     *\n+     * @since 24\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    final class FailedException extends RuntimeException {\n+        @java.io.Serial\n+        static final long serialVersionUID = -1533055100078459923L;\n@@ -1251,5 +801,1 @@\n-         * Returns the exception of the first subtask that {@linkplain Subtask.State#FAILED\n-         * failed}. If no subtasks failed then an empty {@code Optional} is returned.\n-         *\n-         * @return the exception for the first subtask to fail or an empty optional if no\n-         * subtasks failed\n+         * Constructs a {@code FailedException} with the specified cause.\n@@ -1257,2 +803,1 @@\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n-         * @throws IllegalStateException if the task scope owner did not join after forking\n+         * @param  cause the cause, can be {@code null}\n@@ -1260,3 +805,2 @@\n-        public Optional<Throwable> exception() {\n-            ensureOwnerAndJoined();\n-            return Optional.ofNullable(firstException);\n+        public FailedException(Throwable cause) {\n+            super(cause);\n@@ -1264,0 +808,1 @@\n+    }\n@@ -1265,13 +810,11 @@\n-        \/**\n-         * Throws if a subtask {@linkplain Subtask.State#FAILED failed}.\n-         * If any subtask failed with an exception then {@code ExecutionException} is\n-         * thrown with the exception of the first subtask to fail as the {@linkplain\n-         * Throwable#getCause() cause}. This method does nothing if no subtasks failed.\n-         *\n-         * @throws ExecutionException if a subtask failed\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n-         * @throws IllegalStateException if the task scope owner did not join after forking\n-         *\/\n-        public void throwIfFailed() throws ExecutionException {\n-            throwIfFailed(ExecutionException::new);\n-        }\n+    \/**\n+     * Exception thrown by {@link #join()} if the scope was created with a timeout and\n+     * the timeout expired before or while waiting in {@code join}.\n+     *\n+     * @since 24\n+     * @see Config#withTimeout(Duration)\n+     *\/\n+    @PreviewFeature(feature = PreviewFeature.Feature.STRUCTURED_CONCURRENCY)\n+    final class TimeoutException extends RuntimeException {\n+        @java.io.Serial\n+        static final long serialVersionUID = 705788143955048766L;\n@@ -1280,12 +823,1 @@\n-         * Throws the exception produced by the given exception supplying function if a\n-         * subtask {@linkplain Subtask.State#FAILED failed}. If any subtask failed with\n-         * an exception then the function is invoked with the exception of the first\n-         * subtask to fail. The exception returned by the function is thrown. This method\n-         * does nothing if no subtasks failed.\n-         *\n-         * @param esf the exception supplying function\n-         * @param <X> type of the exception to be thrown\n-         *\n-         * @throws X produced by the exception supplying function\n-         * @throws WrongThreadException if the current thread is not the task scope owner\n-         * @throws IllegalStateException if the task scope owner did not join after forking\n+         * Constructs a {@code TimeoutException} with no detail message.\n@@ -1293,11 +825,63 @@\n-        public <X extends Throwable>\n-        void throwIfFailed(Function<Throwable, ? extends X> esf) throws X {\n-            ensureOwnerAndJoined();\n-            Objects.requireNonNull(esf);\n-            Throwable exception = firstException;\n-            if (exception != null) {\n-                X ex = esf.apply(exception);\n-                Objects.requireNonNull(ex, \"esf returned null\");\n-                throw ex;\n-            }\n-        }\n+        public TimeoutException() { }\n+    }\n+\n+    \/**\n+     * Opens a new {@code StructuredTaskScope} to use the given {@code Joiner} object and\n+     * with configuration that is the result of applying the given function to the\n+     * <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     *\n+     * <p> The {@code configFunction} is called with the default configuration and returns\n+     * the configuration for the new scope. The function may, for example, set the\n+     * {@linkplain Config#withThreadFactory(ThreadFactory) ThreadFactory} or set a\n+     * {@linkplain Config#withTimeout(Duration) timeout}. If the function completes with\n+     * an exception or error then it is propagated by this method. If the function returns\n+     * {@code null} then {@code NullPointerException} is thrown.\n+     *\n+     * <p> If a {@code ThreadFactory} is set then its {@link ThreadFactory#newThread(Runnable)\n+     * newThread} method will be called to create threads when {@linkplain #fork(Callable)\n+     * forking} subtasks in this scope. If a {@code ThreadFactory} is not set then\n+     * forking subtasks will create an unnamed virtual thread for each subtask.\n+     *\n+     * <p> If a {@linkplain Config#withTimeout(Duration) timeout} is set then it starts\n+     * when the scope is opened. If the timeout expires before the scope has\n+     * {@linkplain #join() joined} then the scope is <a href=\"#Cancallation\">cancelled<\/a>\n+     * and the {@code join} method throws {@link TimeoutException}.\n+     *\n+     * <p> The new scope is owned by the current thread. Only code executing in this\n+     * thread can {@linkplain #fork(Callable) fork}, {@linkplain #join() join}, or\n+     * {@linkplain #close close} the scope.\n+     *\n+     * <p> Construction captures the current thread's {@linkplain ScopedValue scoped\n+     * value} bindings for inheritance by threads started in the scope.\n+     *\n+     * @param joiner the joiner\n+     * @param configFunction a function to produce the configuration\n+     * @return a new scope\n+     * @param <T> the result type of subtasks executed in the scope\n+     * @param <R> the result type of the scope\n+     * @since 24\n+     *\/\n+    static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T, ? extends R> joiner,\n+                                                 Function<Config, Config> configFunction) {\n+        return StructuredTaskScopeImpl.open(joiner, configFunction);\n+    }\n+\n+    \/**\n+     * Opens a new {@code StructuredTaskScope}to use the given {@code Joiner} object. The\n+     * scope is created with the <a href=\"#DefaultConfiguration\">default configuration<\/a>.\n+     * The default configuration has a {@code ThreadFactory} that creates unnamed\n+     * <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual threads<\/a>,\n+     * is unnamed for monitoring and management purposes, and has no timeout.\n+     *\n+     * @implSpec\n+     * This factory method is equivalent to invoking the 2-arg open method with the given\n+     * joiner and the {@linkplain Function#identity() identity function}.\n+     *\n+     * @param joiner the joiner\n+     * @return a new scope\n+     * @param <T> the result type of subtasks executed in the scope\n+     * @param <R> the result type of the scope\n+     * @since 24\n+     *\/\n+    static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T, ? extends R> joiner) {\n+        return open(joiner, Function.identity());\n@@ -1305,1 +889,183 @@\n-}\n+\n+    \/**\n+     * Opens a new {@code StructuredTaskScope} that can be used to fork subtasks that return\n+     * results of any type. The scope's {@link #join()} method waits for all subtasks to\n+     * succeed or any subtask to fail.\n+     *\n+     * <p> The {@code join} method returns {@code null} if all subtasks complete successfully.\n+     * It throws {@link FailedException} if any subtask fails, with the exception from\n+     * the first subtask to fail as the cause.\n+     *\n+     * <p> The scope is created with the <a href=\"#DefaultConfiguration\">default\n+     * configuration<\/a>. The default configuration has a {@code ThreadFactory} that creates\n+     * unnamed <a href=\"{@docRoot}\/java.base\/java\/lang\/Thread.html#virtual-threads\">virtual\n+     * threads<\/a>, is unnamed for monitoring and management purposes, and has no timeout.\n+     *\n+     * @implSpec\n+     * This factory method is equivalent to invoking the 2-arg open method with a joiner\n+     * created with {@link Joiner#awaitAllSuccessfulOrThrow() awaitAllSuccessfulOrThrow()}\n+     * and the {@linkplain Function#identity() identity function}.\n+     *\n+     * @param <T> the result type of subtasks\n+     * @return a new scope\n+     * @since 24\n+     *\/\n+    static <T> StructuredTaskScope<T, Void> open() {\n+        return open(Joiner.awaitAllSuccessfulOrThrow(), Function.identity());\n+    }\n+\n+    \/**\n+     * Fork a subtask by starting a new thread in this scope to execute a value-returning\n+     * method. The new thread executes the subtask concurrently with the current thread.\n+     * The parameter to this method is a {@link Callable}, the new thread executes its\n+     * {@link Callable#call() call()} method.\n+     *\n+     * <p> This method first creates a {@link Subtask Subtask} object to represent the\n+     * <em>forked subtask<\/em>. It invokes the joiner's {@link Joiner#onFork(Subtask) onFork}\n+     * method with the subtask in the {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state.\n+     * If the {@code onFork} completes with an exception or error then it is propagated by\n+     * the {@code fork} method without creating a thread. If the scope is already\n+     * <a href=\"#Cancallation\">cancelled<\/a>, or {@code onFork} returns {@code true} to\n+     * cancel the scope, then this method returns the {@code Subtask}, in the\n+     * {@link Subtask.State#UNAVAILABLE UNAVAILABLE} state, without creating a thread to\n+     * execute the subtask.\n+     *\n+     * <p> If the scope is not cancelled, and the {@code onFork} method returns {@code false},\n+     * then a thread is created with the {@link ThreadFactory} configured when the scope\n+     * was opened, and the thread is started. Forking a subtask inherits the current thread's\n+     * {@linkplain ScopedValue scoped value} bindings. The bindings must match the bindings\n+     * captured when the scope was opened. If the subtask completes (successfully or with\n+     * an exception) before the scope is cancelled, then the thread invokes the joiner's\n+     * {@link Joiner#onComplete(Subtask) onComplete} method with the subtask in the\n+     * {@link Subtask.State#SUCCESS SUCCESS} or {@link Subtask.State#FAILED FAILED} state.\n+     * If the {@code onComplete} method completes with an exception or error, then the\n+     * {@linkplain Thread.UncaughtExceptionHandler uncaught exception handler} is invoked\n+     * with the exception or error before the thread terminates.\n+     *\n+     * <p> This method returns the {@link Subtask Subtask} object. In some usages, this\n+     * object may be used to get its result. In other cases it may be used for correlation\n+     * or just discarded. To ensure correct usage, the {@link Subtask#get() Subtask.get()}\n+     * method may only be called by the scope owner to get the result after it has\n+     * waited for subtasks to complete with the {@link #join() join} method and the subtask\n+     * completed successfully. Similarly, the {@link Subtask#exception() Subtask.exception()}\n+     * method may only be called by the scope owner after it has joined and the subtask\n+     * failed. If the scope was cancelled before the subtask was forked, or before it\n+     * completes, then neither method can be used to obtain the outcome.\n+     *\n+     * <p> This method may only be invoked by the scope owner.\n+     *\n+     * @param task the value-returning task for the thread to execute\n+     * @param <U> the result type\n+     * @return the subtask\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws IllegalStateException if the owner has already {@linkplain #join() joined}\n+     * or the scope is closed\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the scope was created\n+     * @throws RejectedExecutionException if the thread factory rejected creating a\n+     * thread to run the subtask\n+     *\/\n+    <U extends T> Subtask<U> fork(Callable<? extends U> task);\n+\n+    \/**\n+     * Fork a subtask by starting a new thread in this scope to execute a method that\n+     * does not return a result.\n+     *\n+     * <p> This method works exactly the same as {@link #fork(Callable)} except that the\n+     * parameter to this method is a {@link Runnable}, the new thread executes its\n+     * {@link Runnable#run() run} method, and {@link Subtask#get() Subtask.get()} returns\n+     * {@code null} if the subtask completes successfully.\n+     *\n+     * @param task the task for the thread to execute\n+     * @param <U> the result type\n+     * @return the subtask\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws IllegalStateException if the owner has already {@linkplain #join() joined}\n+     * or the scope is closed\n+     * @throws StructureViolationException if the current scoped value bindings are not\n+     * the same as when the scope was created\n+     * @throws RejectedExecutionException if the thread factory rejected creating a\n+     * thread to run the subtask\n+     * @since 24\n+     *\/\n+    <U extends T> Subtask<U> fork(Runnable task);\n+\n+    \/**\n+     * Returns the result, or throws, after waiting for all subtasks to complete or\n+     * the scope to be <a href=\"#Cancallation\">cancelled<\/a>.\n+     *\n+     * <p> This method waits for all subtasks started in this scope to complete or the\n+     * scope to be cancelled. If a {@linkplain Config#withTimeout(Duration) timeout} is\n+     * configured and the timeout expires before or while waiting, then the scope is\n+     * cancelled and {@link TimeoutException TimeoutException} is thrown. Once finished\n+     * waiting, the {@code Joiner}'s {@link Joiner#result() result()} method is invoked\n+     * to get the result or throw an exception. If the {@code result()} method throws\n+     * then this method throws {@code FailedException} with the exception as the cause.\n+     *\n+     * <p> This method may only be invoked by the scope owner, and only once.\n+     *\n+     * @return the result\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws IllegalStateException if already joined or this scope is closed\n+     * @throws FailedException if the <i>outcome<\/i> is an exception, thrown with the\n+     * exception from {@link Joiner#result() Joiner.result()} as the cause\n+     * @throws TimeoutException if a timeout is set and the timeout expires before or\n+     * while waiting\n+     * @throws InterruptedException if interrupted while waiting\n+     * @since 24\n+     *\/\n+    R join() throws InterruptedException;\n+\n+    \/**\n+     * {@return {@code true} if this scope is <a href=\"#Cancallation\">cancelled<\/a> or in\n+     * the process of being cancelled, otherwise {@code false}}\n+     *\n+     * <p> Cancelling the scope prevents new threads from starting in the scope and\n+     * {@linkplain Thread#interrupt() interrupts} threads executing unfinished subtasks.\n+     * It may take some time before the interrupted threads finish execution; this\n+     * method may return {@code true} before all threads have been interrupted or before\n+     * all threads have finished.\n+     *\n+     * @apiNote A task with a lengthy \"forking phase\" (the code that executes before\n+     * it invokes {@link #join() join}) may use this method to avoid doing work in cases\n+     * where scope is cancelled by the completion of a previously forked subtask or timeout.\n+     *\n+     * @since 24\n+     *\/\n+    boolean isCancelled();\n+\n+    \/**\n+     * Closes this scope.\n+     *\n+     * <p> This method first <a href=\"#Cancallation\">cancels<\/a> the scope, if not\n+     * already cancelled. This interrupts the threads executing unfinished subtasks. This\n+     * method then waits for all threads to finish. If interrupted while waiting then it\n+     * will continue to wait until the threads finish, before completing with the interrupt\n+     * status set.\n+     *\n+     * <p> This method may only be invoked by the scope owner. If the scope\n+     * is already closed then the scope owner invoking this method has no effect.\n+     *\n+     * <p> A {@code StructuredTaskScope} is intended to be used in a <em>structured\n+     * manner<\/em>. If this method is called to close a scope before nested task\n+     * scopes are closed then it closes the underlying construct of each nested scope\n+     * (in the reverse order that they were created in), closes this scope, and then\n+     * throws {@link StructureViolationException}.\n+     * Similarly, if this method is called to close a scope while executing with\n+     * {@linkplain ScopedValue scoped value} bindings, and the scope was created\n+     * before the scoped values were bound, then {@code StructureViolationException} is\n+     * thrown after closing the scope.\n+     * If a thread terminates without first closing scopes that it owns then\n+     * termination will cause the underlying construct of each of its open tasks scopes to\n+     * be closed. Closing is performed in the reverse order that the scopes were\n+     * created in. Thread termination may therefore be delayed when the scope owner\n+     * has to wait for threads forked in these scopes to finish.\n+     *\n+     * @throws IllegalStateException thrown after closing the scope if the scope\n+     * owner did not attempt to join after forking\n+     * @throws WrongThreadException if the current thread is not the scope owner\n+     * @throws StructureViolationException if a structure violation was detected\n+     *\/\n+    @Override\n+    void close();\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScope.java","additions":841,"deletions":1075,"binary":false,"changes":1916,"status":"modified"},{"patch":"@@ -0,0 +1,444 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package java.util.concurrent;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.VarHandle;\n+import java.security.AccessController;\n+import java.security.PrivilegedAction;\n+import java.time.Duration;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import jdk.internal.misc.InnocuousThread;\n+import jdk.internal.misc.ThreadFlock;\n+import jdk.internal.invoke.MhUtil;\n+\n+\/**\n+ * StructuredTaskScope implementation.\n+ *\/\n+final class StructuredTaskScopeImpl<T, R> implements StructuredTaskScope<T, R> {\n+    private static final VarHandle CANCELLED =\n+            MhUtil.findVarHandle(MethodHandles.lookup(), \"cancelled\", boolean.class);\n+\n+    private final Joiner<? super T, ? extends R> joiner;\n+    private final ThreadFactory threadFactory;\n+    private final ThreadFlock flock;\n+\n+    \/\/ state, only accessed by owner thread\n+    private static final int ST_NEW            = 0;\n+    private static final int ST_FORKED         = 1;   \/\/ subtasks forked, need to join\n+    private static final int ST_JOIN_STARTED   = 2;   \/\/ join started, can no longer fork\n+    private static final int ST_JOIN_COMPLETED = 3;   \/\/ join completed\n+    private static final int ST_CLOSED         = 4;   \/\/ closed\n+    private int state;\n+\n+    \/\/ timer task, only accessed by owner thread\n+    private Future<?> timerTask;\n+\n+    \/\/ set or read by any thread\n+    private volatile boolean cancelled;\n+\n+    \/\/ set by the timer thread, read by the owner thread\n+    private volatile boolean timeoutExpired;\n+\n+    @SuppressWarnings(\"this-escape\")\n+    private StructuredTaskScopeImpl(Joiner<? super T, ? extends R> joiner,\n+                                    ThreadFactory threadFactory,\n+                                    String name) {\n+        this.joiner = joiner;\n+        this.threadFactory = threadFactory;\n+        this.flock = ThreadFlock.open((name != null) ? name : Objects.toIdentityString(this));\n+    }\n+\n+    \/**\n+     * Returns a new {@code StructuredTaskScope} to use the given {@code Joiner} object\n+     * and with configuration that is the result of applying the given function to the\n+     * default configuration.\n+     *\/\n+    static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T, ? extends R> joiner,\n+                                                 Function<Config, Config> configFunction) {\n+        Objects.requireNonNull(joiner);\n+\n+        var config = (ConfigImpl) configFunction.apply(ConfigImpl.defaultConfig());\n+        var scope = new StructuredTaskScopeImpl<T, R>(joiner, config.threadFactory(), config.name());\n+\n+        \/\/ schedule timeout\n+        Duration timeout = config.timeout();\n+        if (timeout != null) {\n+            boolean scheduled = false;\n+            try {\n+                scope.scheduleTimeout(timeout);\n+                scheduled = true;\n+            } finally {\n+                if (!scheduled) {\n+                    scope.close();  \/\/ pop if scheduling timeout failed\n+                }\n+            }\n+        }\n+\n+        return scope;\n+    }\n+\n+    \/**\n+     * Throws WrongThreadException if the current thread is not the owner thread.\n+     *\/\n+    private void ensureOwner() {\n+        if (Thread.currentThread() != flock.owner()) {\n+            throw new WrongThreadException(\"Current thread not owner\");\n+        }\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if already joined or scope is closed.\n+     *\/\n+    private void ensureNotJoined() {\n+        assert Thread.currentThread() == flock.owner();\n+        if (state > ST_FORKED) {\n+            throw new IllegalStateException(\"Already joined or scope is closed\");\n+        }\n+    }\n+\n+    \/**\n+     * Throws IllegalStateException if invoked by the owner thread and the owner thread\n+     * has not joined.\n+     *\/\n+    private void ensureJoinedIfOwner() {\n+        if (Thread.currentThread() == flock.owner() && state <= ST_JOIN_STARTED) {\n+            throw new IllegalStateException(\"join not called\");\n+        }\n+    }\n+\n+    \/**\n+     * Interrupts all threads in this scope, except the current thread.\n+     *\/\n+    private void interruptAll() {\n+        flock.threads()\n+                .filter(t -> t != Thread.currentThread())\n+                .forEach(t -> {\n+                    try {\n+                        t.interrupt();\n+                    } catch (Throwable ignore) { }\n+                });\n+    }\n+\n+    \/**\n+     * Cancel the scope if not already cancelled.\n+     *\/\n+    private void cancel() {\n+        if (!cancelled && CANCELLED.compareAndSet(this, false, true)) {\n+            \/\/ prevent new threads from starting\n+            flock.shutdown();\n+\n+            \/\/ interrupt all unfinished threads\n+            interruptAll();\n+\n+            \/\/ wakeup join\n+            flock.wakeup();\n+        }\n+    }\n+\n+    \/**\n+     * Schedules a task to cancel the scope on timeout.\n+     *\/\n+    private void scheduleTimeout(Duration timeout) {\n+        assert Thread.currentThread() == flock.owner() && timerTask == null;\n+        timerTask = TimerSupport.schedule(timeout, () -> {\n+            if (!cancelled) {\n+                timeoutExpired = true;\n+                cancel();\n+            }\n+        });\n+    }\n+\n+    \/**\n+     * Cancels the timer task if set.\n+     *\/\n+    private void cancelTimeout() {\n+        assert Thread.currentThread() == flock.owner();\n+        if (timerTask != null) {\n+            timerTask.cancel(false);\n+        }\n+    }\n+\n+    \/**\n+     * Invoked by the thread for a subtask when the subtask completes before scope is cancelled.\n+     *\/\n+    private void onComplete(SubtaskImpl<? extends T> subtask) {\n+        assert subtask.state() != Subtask.State.UNAVAILABLE;\n+        if (joiner.onComplete(subtask)) {\n+            cancel();\n+        }\n+    }\n+\n+    @Override\n+    public <U extends T> Subtask<U> fork(Callable<? extends U> task) {\n+        Objects.requireNonNull(task);\n+        ensureOwner();\n+        ensureNotJoined();\n+\n+        var subtask = new SubtaskImpl<U>(this, task);\n+\n+        \/\/ notify joiner, even if cancelled\n+        if (joiner.onFork(subtask)) {\n+            cancel();\n+        }\n+\n+        if (!cancelled) {\n+            \/\/ create thread to run task\n+            Thread thread = threadFactory.newThread(subtask);\n+            if (thread == null) {\n+                throw new RejectedExecutionException(\"Rejected by thread factory\");\n+            }\n+\n+            \/\/ attempt to start the thread\n+            try {\n+                flock.start(thread);\n+            } catch (IllegalStateException e) {\n+                \/\/ shutdown by another thread, or underlying flock is shutdown due\n+                \/\/ to unstructured use\n+            }\n+        }\n+\n+        \/\/ force owner to join\n+        state = ST_FORKED;\n+        return subtask;\n+    }\n+\n+    @Override\n+    public <U extends T> Subtask<U> fork(Runnable task) {\n+        Objects.requireNonNull(task);\n+        return fork(() -> { task.run(); return null; });\n+    }\n+\n+    @Override\n+    public R join() throws InterruptedException {\n+        ensureOwner();\n+        ensureNotJoined();\n+\n+        \/\/ join started\n+        state = ST_JOIN_STARTED;\n+\n+        \/\/ wait for all subtasks, the scope to be cancelled, or interrupt\n+        flock.awaitAll();\n+\n+        \/\/ throw if timeout expired\n+        if (timeoutExpired) {\n+            throw new TimeoutException();\n+        }\n+        cancelTimeout();\n+\n+        \/\/ all subtasks completed or cancelled\n+        state = ST_JOIN_COMPLETED;\n+\n+        \/\/ invoke joiner to get result\n+        try {\n+            return joiner.result();\n+        } catch (Throwable e) {\n+            throw new FailedException(e);\n+        }\n+    }\n+\n+    @Override\n+    public boolean isCancelled() {\n+        return cancelled;\n+    }\n+\n+    @Override\n+    public void close() {\n+        ensureOwner();\n+        int s = state;\n+        if (s == ST_CLOSED) {\n+            return;\n+        }\n+\n+        \/\/ cancel the scope if join did not complete\n+        if (s < ST_JOIN_COMPLETED) {\n+            cancel();\n+            cancelTimeout();\n+        }\n+\n+        \/\/ wait for stragglers\n+        try {\n+            flock.close();\n+        } finally {\n+            state = ST_CLOSED;\n+        }\n+\n+        \/\/ throw ISE if the owner didn't join after forking\n+        if (s == ST_FORKED) {\n+            throw new IllegalStateException(\"Owner did not join after forking\");\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return flock.name();\n+    }\n+\n+    \/**\n+     * Subtask implementation, runs the task specified to the fork method.\n+     *\/\n+    static final class SubtaskImpl<T> implements Subtask<T>, Runnable {\n+        private static final AltResult RESULT_NULL = new AltResult(Subtask.State.SUCCESS);\n+\n+        private record AltResult(Subtask.State state, Throwable exception) {\n+            AltResult(Subtask.State state) {\n+                this(state, null);\n+            }\n+        }\n+\n+        private final StructuredTaskScopeImpl<? super T, ?> scope;\n+        private final Callable<? extends T> task;\n+        private volatile Object result;\n+\n+        SubtaskImpl(StructuredTaskScopeImpl<? super T, ?> scope, Callable<? extends T> task) {\n+            this.scope = scope;\n+            this.task = task;\n+        }\n+\n+        @Override\n+        public void run() {\n+            T result = null;\n+            Throwable ex = null;\n+            try {\n+                result = task.call();\n+            } catch (Throwable e) {\n+                ex = e;\n+            }\n+\n+            \/\/ nothing to do if scope is cancelled\n+            if (scope.isCancelled())\n+                return;\n+\n+            \/\/ set result\/exception and invoke onComplete\n+            if (ex == null) {\n+                this.result = (result != null) ? result : RESULT_NULL;\n+            } else {\n+                this.result = new AltResult(State.FAILED, ex);\n+            }\n+            scope.onComplete(this);\n+        }\n+\n+        @Override\n+        public Subtask.State state() {\n+            Object result = this.result;\n+            if (result == null) {\n+                return State.UNAVAILABLE;\n+            } else if (result instanceof AltResult alt) {\n+                \/\/ null or failed\n+                return alt.state();\n+            } else {\n+                return State.SUCCESS;\n+            }\n+        }\n+\n+        @Override\n+        public T get() {\n+            scope.ensureJoinedIfOwner();\n+            Object result = this.result;\n+            if (result instanceof AltResult) {\n+                if (result == RESULT_NULL) return null;\n+            } else if (result != null) {\n+                @SuppressWarnings(\"unchecked\")\n+                T r = (T) result;\n+                return r;\n+            }\n+            throw new IllegalStateException(\n+                    \"Result is unavailable or subtask did not complete successfully\");\n+        }\n+\n+        @Override\n+        public Throwable exception() {\n+            scope.ensureJoinedIfOwner();\n+            Object result = this.result;\n+            if (result instanceof AltResult alt && alt.state() == State.FAILED) {\n+                return alt.exception();\n+            }\n+            throw new IllegalStateException(\n+                    \"Exception is unavailable or subtask did not complete with exception\");\n+        }\n+\n+        @Override\n+        public String toString() {\n+            String stateAsString = switch (state()) {\n+                case UNAVAILABLE -> \"[Unavailable]\";\n+                case SUCCESS     -> \"[Completed successfully]\";\n+                case FAILED      -> {\n+                    Throwable ex = ((AltResult) result).exception();\n+                    yield \"[Failed: \" + ex + \"]\";\n+                }\n+            };\n+            return Objects.toIdentityString(this) + stateAsString;\n+        }\n+    }\n+\n+    \/**\n+     * Config implementation.\n+     *\/\n+    record ConfigImpl(ThreadFactory threadFactory,\n+                      String name,\n+                      Duration timeout) implements Config {\n+        static Config defaultConfig() {\n+            return new ConfigImpl(Thread.ofVirtual().factory(), null, null);\n+        }\n+\n+        @Override\n+        public Config withThreadFactory(ThreadFactory threadFactory) {\n+            return new ConfigImpl(Objects.requireNonNull(threadFactory), name, timeout);\n+        }\n+\n+        @Override\n+        public Config withName(String name) {\n+            return new ConfigImpl(threadFactory, Objects.requireNonNull(name), timeout);\n+        }\n+\n+        @Override\n+        public Config withTimeout(Duration timeout) {\n+            return new ConfigImpl(threadFactory, name, Objects.requireNonNull(timeout));\n+        }\n+    }\n+\n+    \/**\n+     * Used to schedule a task to cancel the scope when a timeout expires.\n+     *\/\n+    private static class TimerSupport {\n+        private static final ScheduledExecutorService DELAYED_TASK_SCHEDULER;\n+        static {\n+            ScheduledThreadPoolExecutor stpe = (ScheduledThreadPoolExecutor)\n+                    Executors.newScheduledThreadPool(1, task -> {\n+                        Thread t = InnocuousThread.newThread(\"StructuredTaskScope-Timer\", task);\n+                        t.setDaemon(true);\n+                        return t;\n+                    });\n+            stpe.setRemoveOnCancelPolicy(true);\n+            DELAYED_TASK_SCHEDULER = stpe;\n+        }\n+\n+        static Future<?> schedule(Duration timeout, Runnable task) {\n+            long nanos = TimeUnit.NANOSECONDS.convert(timeout);\n+            return DELAYED_TASK_SCHEDULER.schedule(task, nanos, TimeUnit.NANOSECONDS);\n+        }\n+    }\n+}\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/StructuredTaskScopeImpl.java","additions":444,"deletions":0,"binary":false,"changes":444,"status":"added"},{"patch":"@@ -75,1 +75,1 @@\n-        @JEP(number=499, title=\"Structured Concurrency\", status=\"Fourth Preview\")\n+        @JEP(number=999, title=\"Structured Concurrency\", status=\"Fifth Preview\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/javac\/PreviewFeature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -275,6 +275,0 @@\n-     *\n-     * <p> This method may only be invoked by the flock owner or threads {@linkplain\n-     * #containsThread(Thread) contained} in the flock.\n-     *\n-     * @throws WrongThreadException if the current thread is not the owner or a thread\n-     * contained in the flock\n@@ -283,1 +277,0 @@\n-        ensureOwnerOrContainsThread();\n@@ -373,3 +366,0 @@\n-     *\n-     * @throws WrongThreadException if the current thread is not the owner or a thread\n-     * contained in the flock\n@@ -378,1 +368,0 @@\n-        ensureOwnerOrContainsThread();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/misc\/ThreadFlock.java","additions":0,"deletions":11,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -172,1 +173,1 @@\n-        try (var scope = new StructuredTaskScope<>(\"\", threadFactory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withThreadFactory(threadFactory))) {\n@@ -189,1 +190,1 @@\n-                try (var scope = new StructuredTaskScope<>()) {\n+                try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n","filename":"test\/jdk\/java\/lang\/ScopedValue\/StressStackOverflow.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,103 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Stress test of StructuredTaskScope cancellation with running and starting threads\n+ * @enablePreview\n+ * @run junit StressCancellation\n+ *\/\n+\n+import java.time.Duration;\n+import java.util.concurrent.StructuredTaskScope;\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n+import java.util.concurrent.StructuredTaskScope.Subtask;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+class StressCancellation {\n+\n+    static Stream<Arguments> testCases() {\n+        Stream<ThreadFactory> factories = Stream.of(\n+                Thread.ofPlatform().factory(),\n+                Thread.ofVirtual().factory()\n+        );\n+        \/\/ 0..15 forks before shutdown, 0..15 forks after shutdown\n+        return factories.flatMap(f -> IntStream.range(0, 256)\n+                .mapToObj(x -> Arguments.of(f, x & 0x0F, (x & 0xF0) >> 4)));\n+    }\n+\n+    \/**\n+     * Test StructuredTaskScope cancellation with running threads and concurrently with\n+     * threads that are starting. The cancellation should interrupt all running threads,\n+     * join should wakeup, and close would complete quickly.\n+     *\n+     * @param factory the ThreadFactory to use\n+     * @param beforeCancel the number of subtasks to fork before cancel\n+     * @param afterCancel the number of subtasks to fork after cancel\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"testCases\")\n+    void test(ThreadFactory factory, int beforeCancel, int afterCancel) throws Exception {\n+        var joiner = new Joiner<Boolean, Void>() {\n+            @Override\n+            public boolean onComplete(Subtask<? extends Boolean> subtask) {\n+                boolean cancel = subtask.get();\n+                return cancel;\n+            }\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+\n+        try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n+            \/\/ fork subtasks\n+            for (int i = 0; i < beforeCancel; i++) {\n+                scope.fork(() -> {\n+                    Thread.sleep(Duration.ofDays(1));\n+                    return false;\n+                });\n+            }\n+\n+            \/\/ fork subtask to cancel\n+            scope.fork(() -> true);\n+\n+            \/\/ fork after forking subtask to cancel\n+            for (int i = 0; i < afterCancel; i++) {\n+                scope.fork(() -> {\n+                    Thread.sleep(Duration.ofDays(1));\n+                    return false;\n+                });\n+            }\n+\n+            scope.join();\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StressCancellation.java","additions":103,"deletions":0,"binary":false,"changes":103,"status":"added"},{"patch":"@@ -1,95 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8311867\n- * @summary Stress test of StructuredTaskScope.shutdown with running and starting threads\n- * @enablePreview\n- * @run junit StressShutdown\n- *\/\n-\n-import java.time.Duration;\n-import java.util.concurrent.Callable;\n-import java.util.concurrent.StructuredTaskScope;\n-import java.util.concurrent.ThreadFactory;\n-import java.util.stream.IntStream;\n-import java.util.stream.Stream;\n-\n-import org.junit.jupiter.params.ParameterizedTest;\n-import org.junit.jupiter.params.provider.Arguments;\n-import org.junit.jupiter.params.provider.MethodSource;\n-import static org.junit.jupiter.api.Assertions.*;\n-\n-class StressShutdown {\n-\n-    static final Callable<Void> SLEEP_FOR_A_DAY = () -> {\n-        Thread.sleep(Duration.ofDays(1));\n-        return null;\n-    };\n-\n-    static Stream<Arguments> testCases() {\n-        Stream<ThreadFactory> factories = Stream.of(\n-                Thread.ofPlatform().factory(),\n-                Thread.ofVirtual().factory()\n-        );\n-        \/\/ 0..15 forks before shutdown, 0..15 forks after shutdown\n-        return factories.flatMap(f -> IntStream.range(0, 256)\n-                .mapToObj(x -> Arguments.of(f, x & 0x0F, (x & 0xF0) >> 4)));\n-    }\n-\n-    \/**\n-     * Test StructuredTaskScope.shutdown with running threads and concurrently with\n-     * threads that are starting. The shutdown should interrupt all threads so that\n-     * join wakes up.\n-     *\n-     * @param factory the ThreadFactory to use\n-     * @param beforeShutdown the number of subtasks to fork before shutdown\n-     * @param afterShutdown the number of subtasks to fork after shutdown\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"testCases\")\n-    void testShutdown(ThreadFactory factory, int beforeShutdown, int afterShutdown)\n-        throws InterruptedException\n-    {\n-        try (var scope = new StructuredTaskScope<>(null, factory)) {\n-            \/\/ fork subtasks\n-            for (int i = 0; i < beforeShutdown; i++) {\n-                scope.fork(SLEEP_FOR_A_DAY);\n-            }\n-\n-            \/\/ fork subtask to shutdown\n-            scope.fork(() -> {\n-                scope.shutdown();\n-                return null;\n-            });\n-\n-            \/\/ fork after forking subtask to shutdown\n-            for (int i = 0; i < afterShutdown; i++) {\n-                scope.fork(SLEEP_FOR_A_DAY);\n-            }\n-\n-            scope.join();\n-        }\n-    }\n-}\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StressShutdown.java","additions":0,"deletions":95,"binary":false,"changes":95,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,2 +39,0 @@\n-import java.io.IOException;\n-import java.time.Instant;\n@@ -45,0 +43,1 @@\n+import java.util.NoSuchElementException;\n@@ -49,1 +48,0 @@\n-import java.util.concurrent.ExecutionException;\n@@ -51,0 +49,1 @@\n+import java.util.concurrent.LinkedTransferQueue;\n@@ -52,1 +51,0 @@\n-import java.util.concurrent.TimeoutException;\n@@ -57,0 +55,4 @@\n+import java.util.concurrent.StructuredTaskScope.TimeoutException;\n+import java.util.concurrent.StructuredTaskScope.Config;\n+import java.util.concurrent.StructuredTaskScope.FailedException;\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -58,2 +60,0 @@\n-import java.util.concurrent.StructuredTaskScope.ShutdownOnSuccess;\n-import java.util.concurrent.StructuredTaskScope.ShutdownOnFailure;\n@@ -64,1 +64,2 @@\n-import java.util.function.Supplier;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n@@ -104,1 +105,1 @@\n-     * Test that fork creates a new thread for each task.\n+     * Test that fork creates virtual threads when no ThreadFactory is configured.\n@@ -106,6 +107,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkCreatesThread(ThreadFactory factory) throws Exception {\n-        Set<Long> tids = ConcurrentHashMap.newKeySet();\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            for (int i = 0; i < 100; i++) {\n+    @Test\n+    void testForkCreatesVirtualThread() throws Exception {\n+        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            for (int i = 0; i < 50; i++) {\n+                \/\/ runnable\n@@ -113,2 +114,1 @@\n-                    tids.add(Thread.currentThread().threadId());\n-                    return null;\n+                    threads.add(Thread.currentThread());\n@@ -116,5 +116,0 @@\n-            }\n-            scope.join();\n-        }\n-        assertEquals(100, tids.size());\n-    }\n@@ -122,8 +117,1 @@\n-    \/**\n-     * Test that fork creates a new virtual thread for each task.\n-     *\/\n-    @Test\n-    void testForkCreateVirtualThread() throws Exception {\n-        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            for (int i = 0; i < 100; i++) {\n+                \/\/ callable\n@@ -142,1 +130,1 @@\n-     * Test that fork creates a new thread with the given thread factory.\n+     * Test that fork create threads with the configured ThreadFactory.\n@@ -146,9 +134,34 @@\n-    void testForkUsesFactory(ThreadFactory factory) throws Exception {\n-        var count = new AtomicInteger();\n-        ThreadFactory countingFactory = task -> {\n-            count.incrementAndGet();\n-            return factory.newThread(task);\n-        };\n-        try (var scope = new StructuredTaskScope<Object>(null, countingFactory)) {\n-            for (int i = 0; i < 100; i++) {\n-                scope.fork(() -> null);\n+    void testForkUsesThreadFactory(ThreadFactory factory) throws Exception {\n+        \/\/ TheadFactory that keeps reference to all threads it creates\n+        class RecordingThreadFactory implements ThreadFactory {\n+            final ThreadFactory delegate;\n+            final Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+            RecordingThreadFactory(ThreadFactory delegate) {\n+                this.delegate = delegate;\n+            }\n+            @Override\n+            public Thread newThread(Runnable task) {\n+                Thread thread = delegate.newThread(task);\n+                threads.add(thread);\n+                return thread;\n+            }\n+            Set<Thread> threads() {\n+                return threads;\n+            }\n+        }\n+        var recordingThreadFactory = new RecordingThreadFactory(factory);\n+        Set<Thread> threads = ConcurrentHashMap.newKeySet();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(recordingThreadFactory))) {\n+\n+            for (int i = 0; i < 50; i++) {\n+                \/\/ runnable\n+                scope.fork(() -> {\n+                    threads.add(Thread.currentThread());\n+                });\n+\n+                \/\/ callable\n+                scope.fork(() -> {\n+                    threads.add(Thread.currentThread());\n+                    return null;\n+                });\n@@ -158,1 +171,2 @@\n-        assertEquals(100, count.get());\n+        assertEquals(100, threads.size());\n+        assertEquals(recordingThreadFactory.threads(), threads);\n@@ -162,1 +176,1 @@\n-     * Test fork is confined to threads in the scope \"tree\".\n+     * Test fork method is owner confined.\n@@ -167,22 +181,2 @@\n-        try (var scope1 = new StructuredTaskScope<Boolean>();\n-             var scope2 = new StructuredTaskScope<Boolean>()) {\n-\n-            \/\/ thread in scope1 cannot fork thread in scope2\n-            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope2.fork(() -> null);\n-                });\n-                return true;\n-            });\n-\n-            \/\/ thread in scope2 can fork thread in scope1\n-            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n-                scope1.fork(() -> null);\n-                return true;\n-            });\n-\n-            scope2.join();\n-            scope1.join();\n-\n-            assertTrue(subtask1.get());\n-            assertTrue(subtask2.get());\n+        try (var scope = StructuredTaskScope.open(Joiner.<Boolean>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -194,4 +188,1 @@\n-                        scope1.fork(() -> null);\n-                    });\n-                    assertThrows(WrongThreadException.class, () -> {\n-                        scope2.fork(() -> null);\n+                        scope.fork(() -> null);\n@@ -203,0 +194,10 @@\n+\n+            \/\/ subtask cannot fork\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> {\n+                    scope.fork(() -> null);\n+                });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n@@ -207,1 +208,1 @@\n-     * Test fork after join completes.\n+     * Test fork after join, no subtasks forked before join.\n@@ -211,12 +212,3 @@\n-    void testForkAfterJoin(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            \/\/ round 1\n-            var subtask1 = scope.fork(() -> \"foo\");\n-            assertThrows(IllegalStateException.class, subtask1::get);\n-            scope.join();\n-            assertEquals(\"foo\", subtask1.get());\n-\n-            \/\/ round 2\n-            var subtask2 = scope.fork(() -> \"bar\");\n-            assertEquals(\"foo\", subtask1.get());\n-            assertThrows(IllegalStateException.class, subtask2::get);\n+    void testForkAfterJoin1(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -224,2 +216,3 @@\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n+        }\n+    }\n@@ -227,5 +220,9 @@\n-            \/\/ round 3\n-            var subtask3 = scope.fork(() -> \"baz\");\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n-            assertThrows(IllegalStateException.class, subtask3::get);\n+    \/**\n+     * Test fork after join, subtasks forked before join.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testForkAfterJoin2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n@@ -233,3 +230,1 @@\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n-            assertEquals(\"baz\", subtask3.get());\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n@@ -245,1 +240,2 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -256,10 +252,2 @@\n-            \/\/ allow subtask1 to finish\n-            latch.countDown();\n-\n-            \/\/ continue to fork\n-            var subtask2 = scope.fork(() -> \"bar\");\n-            assertThrows(IllegalStateException.class, subtask1::get);\n-            assertThrows(IllegalStateException.class, subtask2::get);\n-            scope.join();\n-            assertEquals(\"foo\", subtask1.get());\n-            assertEquals(\"bar\", subtask2.get());\n+            \/\/ fork should throw\n+            assertThrows(IllegalStateException.class, () -> scope.fork(() -> \"bar\"));\n@@ -270,1 +258,2 @@\n-     * Test fork after scope is shutdown.\n+     * Test fork after task scope is cancelled. This test uses a custom Joiner to\n+     * cancel execution.\n@@ -274,8 +263,25 @@\n-    void testForkAfterShutdown(ThreadFactory factory) throws Exception {\n-        var executed = new AtomicBoolean();\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            scope.shutdown();\n-            Subtask<String> subtask = scope.fork(() -> {\n-                executed.set(true);\n-                return null;\n-            });\n+    void testForkAfterCancel2(ThreadFactory factory) throws Exception {\n+        var countingThreadFactory = new CountingThreadFactory(factory);\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n+\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(countingThreadFactory))) {\n+\n+            \/\/ fork subtask, the scope should be cancelled when the subtask completes\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n+            }\n+\n+            assertEquals(1, countingThreadFactory.threadCount());\n+            assertEquals(1, testJoiner.onForkCount());\n+            assertEquals(1, testJoiner.onCompleteCount());\n+\n+            \/\/ fork second subtask, it should not run\n+            var subtask2 = scope.fork(() -> \"bar\");\n+\n+            \/\/ onFork should be invoked, newThread and onComplete should not be invoked\n+            assertEquals(1, countingThreadFactory.threadCount());\n+            assertEquals(2, testJoiner.onForkCount());\n+            assertEquals(1, testJoiner.onCompleteCount());\n+\n@@ -283,3 +289,6 @@\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            assertThrows(IllegalStateException.class, subtask::get);\n-            assertThrows(IllegalStateException.class, subtask::exception);\n+\n+            assertEquals(1, countingThreadFactory.threadCount());\n+            assertEquals(2, testJoiner.onForkCount());\n+            assertEquals(1, testJoiner.onCompleteCount());\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n@@ -287,1 +296,0 @@\n-        assertFalse(executed.get());\n@@ -291,1 +299,1 @@\n-     * Test fork after scope is closed.\n+     * Test fork after task scope is closed.\n@@ -293,4 +301,3 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testForkAfterClose(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+    @Test\n+    void testForkAfterClose() {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -303,1 +310,1 @@\n-     * Test fork when the thread factory rejects creating a thread.\n+     * Test fork with a ThreadFactory that rejects creating a thread.\n@@ -306,1 +313,1 @@\n-    void testForkRejectedExecutionException() throws Exception {\n+    void testForkRejectedExecutionException() {\n@@ -308,1 +315,2 @@\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -310,1 +318,0 @@\n-            scope.join();\n@@ -319,1 +326,1 @@\n-        try (var scope = new StructuredTaskScope()) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -325,1 +332,1 @@\n-     * Test join with unfinished subtasks.\n+     * Test join with a remaining subtask.\n@@ -329,2 +336,3 @@\n-    void testJoinWithSubtasks(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n+    void testJoinWithRemainingSubtasks(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -332,1 +340,1 @@\n-                Thread.sleep(Duration.ofMillis(50));\n+                Thread.sleep(Duration.ofMillis(100));\n@@ -341,1 +349,1 @@\n-     * Test join is owner confined.\n+     * Test join after join completed with a result.\n@@ -343,4 +351,7 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinConfined(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Boolean>()) {\n+    @Test\n+    void testJoinAfterJoin1() throws Exception {\n+        var results = new LinkedTransferQueue<>(List.of(\"foo\", \"bar\", \"baz\"));\n+        Joiner<Object, String> joiner = results::take;\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            scope.fork(() -> \"foo\");\n+            assertEquals(\"foo\", scope.join());\n@@ -348,5 +359,6 @@\n-            \/\/ thread in scope cannot join\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, () -> { scope.join(); });\n-                return true;\n-            });\n+            \/\/ join already called\n+            for (int i = 0 ; i < 3; i++) {\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+        }\n+    }\n@@ -354,1 +366,9 @@\n-            scope.join();\n+    \/**\n+     * Test join after join completed with an exception.\n+     *\/\n+    @Test\n+    void testJoinAfterJoin2() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+            scope.fork(() -> { throw new FooException(); });\n+            Throwable ex = assertThrows(FailedException.class, scope::join);\n+            assertTrue(ex.getCause() instanceof FooException);\n@@ -356,1 +376,35 @@\n-            assertTrue(subtask.get());\n+            \/\/ join already called\n+            for (int i = 0 ; i < 3; i++) {\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test join after join completed with a timeout.\n+     *\/\n+    @Test\n+    void testJoinAfterJoin3() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+                cf -> cf.withTimeout(Duration.ofMillis(100)))) {\n+            \/\/ wait for scope to be cancelled by timeout\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n+            }\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            \/\/ join already called\n+            for (int i = 0 ; i < 3; i++) {\n+                assertThrows(IllegalStateException.class, scope::join);\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Test join method is owner confined.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testJoinConfined(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<Boolean>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -366,0 +420,8 @@\n+\n+            \/\/ subtask cannot join\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, () -> { scope.join(); });\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n@@ -375,2 +437,2 @@\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -379,1 +441,1 @@\n-                latch.await();\n+                Thread.sleep(60_000);\n@@ -389,4 +451,1 @@\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n+                assertFalse(Thread.interrupted());   \/\/ interrupt status should be cleared\n@@ -394,4 +453,0 @@\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", subtask.get());\n@@ -407,1 +462,3 @@\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+\n@@ -410,1 +467,1 @@\n-                latch.await();\n+                Thread.sleep(60_000);\n@@ -414,2 +471,2 @@\n-            \/\/ join should throw\n-            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.join\");\n+            \/\/ interrupt main thread when it blocks in join\n+            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScopeImpl.join\");\n@@ -421,3 +478,0 @@\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n@@ -425,4 +479,0 @@\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", subtask.get());\n@@ -433,1 +483,1 @@\n-     * Test join when scope is shutdown.\n+     * Test join when scope is cancelled.\n@@ -437,16 +487,3 @@\n-    void testJoinWithShutdown1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            var interrupted = new CountDownLatch(1);\n-            var finish = new CountDownLatch(1);\n-\n-            Subtask<String> subtask = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (InterruptedException e) {\n-                    interrupted.countDown();\n-                }\n-                finish.await();\n-                return \"foo\";\n-            });\n-\n-            scope.shutdown();      \/\/ should interrupt task\n+    void testJoinWhenCancelled(ThreadFactory factory) throws Exception {\n+        var countingThreadFactory = new CountingThreadFactory(factory);\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n@@ -454,8 +491,2 @@\n-            interrupted.await();\n-\n-            scope.join();\n-\n-            \/\/ signal task to finish\n-            finish.countDown();\n-        }\n-    }\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                    cf -> cf.withThreadFactory(countingThreadFactory))) {\n@@ -463,13 +494,4 @@\n-    \/**\n-     * Test shutdown when owner is blocked in join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testJoinWithShutdown2(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n-            }\n-            @Override\n-            protected void handleComplete(Subtask<? extends T> subtask) {\n-                shutdown();\n+            \/\/ fork subtask, the scope should be cancelled when the subtask completes\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n@@ -477,1 +499,0 @@\n-        }\n@@ -479,6 +500,2 @@\n-        try (var scope = new MyScope<String>(factory)) {\n-            Subtask<String> subtask1 = scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(50));\n-                return \"foo\";\n-            });\n-            Subtask<String> subtask2 = scope.fork(() -> {\n+            \/\/ fork second subtask, it should not run\n+            var subtask2 = scope.fork(() -> {\n@@ -489,1 +506,0 @@\n-            \/\/ join should wakeup when shutdown is called\n@@ -492,2 +508,0 @@\n-            \/\/ task1 should have completed successfully\n-            assertEquals(Subtask.State.SUCCESS, subtask1.state());\n@@ -495,3 +509,0 @@\n-            assertThrows(IllegalStateException.class, subtask1::exception);\n-\n-            \/\/ task2 result\/exception not available\n@@ -499,2 +510,0 @@\n-            assertThrows(IllegalStateException.class, subtask2::get);\n-            assertThrows(IllegalStateException.class, subtask2::exception);\n@@ -509,2 +518,1 @@\n-        try (var scope = new StructuredTaskScope()) {\n-            scope.join();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -513,1 +521,0 @@\n-            assertThrows(IllegalStateException.class, () -> scope.joinUntil(Instant.now()));\n@@ -518,1 +525,1 @@\n-     * Test joinUntil, subtasks finish before deadline expires.\n+     * Test join with timeout, subtasks finish before timeout expires.\n@@ -522,2 +529,5 @@\n-    void testJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+    void testJoinWithTimeout1(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofDays(1)))) {\n+\n@@ -525,3 +535,1 @@\n-                try {\n-                    Thread.sleep(Duration.ofSeconds(2));\n-                } catch (InterruptedException e) { }\n+                Thread.sleep(Duration.ofSeconds(1));\n@@ -531,3 +539,3 @@\n-            long startMillis = millisTime();\n-            scope.joinUntil(Instant.now().plusSeconds(30));\n-            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+            scope.join();\n+\n+            assertFalse(scope.isCancelled());\n@@ -539,1 +547,1 @@\n-     * Test joinUntil, deadline expires before subtasks finish.\n+     * Test join with timeout, timeout expires before subtasks finish.\n@@ -543,2 +551,6 @@\n-    void testJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+    void testJoinWithTimeout2(ThreadFactory factory) throws Exception {\n+        long startMillis = millisTime();\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofSeconds(2)))) {\n+\n@@ -550,6 +562,4 @@\n-            long startMillis = millisTime();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(2));\n-            } catch (TimeoutException e) {\n-                expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n-            }\n+            assertThrows(TimeoutException.class, scope::join);\n+            expectDuration(startMillis, \/*min*\/1900, \/*max*\/20_000);\n+\n+            assertTrue(scope.isCancelled());\n@@ -561,1 +571,1 @@\n-     * Test joinUntil many times.\n+     * Test join with timeout that has already expired.\n@@ -565,3 +575,6 @@\n-    void testJoinUntil3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            Subtask<String> subtask = scope.fork(() -> {\n+    void testJoinWithTimeout3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofSeconds(-1)))) {\n+\n+            Subtask<Void> subtask = scope.fork(() -> {\n@@ -572,8 +585,4 @@\n-            for (int i = 0; i < 3; i++) {\n-                try {\n-                    scope.joinUntil(Instant.now().plusMillis(50));\n-                    fail(\"joinUntil did not throw\");\n-                } catch (TimeoutException expected) {\n-                    assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-                }\n-            }\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            assertTrue(scope.isCancelled());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n@@ -584,1 +593,2 @@\n-     * Test joinUntil with a deadline that has already expired.\n+     * Test that cancelling execution interrupts unfinished threads. This test uses\n+     * a custom Joiner to cancel execution.\n@@ -588,5 +598,16 @@\n-    void testJoinUntil4(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            Subtask<Void> subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n+    void testCancelInterruptsThreads2(ThreadFactory factory) throws Exception {\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n+\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(factory))) {\n+\n+            \/\/ fork subtask1 that runs for a long time\n+            var started = new CountDownLatch(1);\n+            var interrupted = new CountDownLatch(1);\n+            var subtask1 = scope.fork(() -> {\n+                started.countDown();\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n@@ -594,0 +615,1 @@\n+            started.await();\n@@ -595,6 +617,4 @@\n-            \/\/ now\n-            try {\n-                scope.joinUntil(Instant.now());\n-                fail(\"joinUntil did not throw\");\n-            } catch (TimeoutException expected) {\n-                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            \/\/ fork subtask2, the scope should be cancelled when the subtask completes\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n@@ -603,7 +623,6 @@\n-            \/\/ in the past\n-            try {\n-                scope.joinUntil(Instant.now().minusSeconds(1));\n-                fail(\"joinUntil did not throw\");\n-            } catch (TimeoutException expected) {\n-                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            }\n+            \/\/ subtask1 should be interrupted\n+            interrupted.await();\n+\n+            scope.join();\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask1.state());\n+            assertEquals(\"bar\", subtask2.get());\n@@ -614,1 +633,1 @@\n-     * Test joinUntil with interrupt status set.\n+     * Test that timeout interrupts unfinished threads.\n@@ -618,3 +637,4 @@\n-    void testInterruptJoinUntil1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            var latch = new CountDownLatch(1);\n+    void testTimeoutInterruptsThreads(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory)\n+                        .withTimeout(Duration.ofSeconds(2)))) {\n@@ -622,3 +642,10 @@\n-            Subtask<String> subtask = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n+            var started = new AtomicBoolean();\n+            var interrupted = new CountDownLatch(1);\n+            Subtask<Void> subtask = scope.fork(() -> {\n+                started.set(true);\n+                try {\n+                    Thread.sleep(Duration.ofDays(1));\n+                } catch (InterruptedException e) {\n+                    interrupted.countDown();\n+                }\n+                return null;\n@@ -627,10 +654,2 @@\n-            \/\/ joinUntil should throw\n-            Thread.currentThread().interrupt();\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(30));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(50);\n@@ -639,3 +658,8 @@\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", subtask.get());\n+            \/\/ if subtask started then it should be interrupted\n+            if (started.get()) {\n+                interrupted.await();\n+            }\n+\n+            assertThrows(TimeoutException.class, scope::join);\n+\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n@@ -646,187 +670,1 @@\n-     * Test interrupt of thread blocked in joinUntil.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testInterruptJoinUntil2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-\n-            Subtask<String> subtask = scope.fork(() -> {\n-                latch.await();\n-                return \"foo\";\n-            });\n-\n-            \/\/ joinUntil should throw\n-            scheduleInterruptAt(\"java.util.concurrent.StructuredTaskScope.joinUntil\");\n-            try {\n-                scope.joinUntil(Instant.now().plusSeconds(30));\n-                fail(\"joinUntil did not throw\");\n-            } catch (InterruptedException expected) {\n-                assertFalse(Thread.interrupted());   \/\/ interrupt status should be clear\n-            } finally {\n-                \/\/ let task continue\n-                latch.countDown();\n-            }\n-\n-            \/\/ join should complete\n-            scope.join();\n-            assertEquals(\"foo\", subtask.get());\n-        }\n-    }\n-\n-    \/**\n-     * Test that shutdown interrupts unfinished subtasks.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownInterruptsThreads1(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var interrupted = new AtomicBoolean();\n-            var latch = new CountDownLatch(1);\n-            var subtask = scope.fork(() -> {\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (InterruptedException e) {\n-                    interrupted.set(true);\n-                } finally {\n-                    latch.countDown();\n-                }\n-                return null;\n-            });\n-\n-            scope.shutdown();\n-\n-            \/\/ wait for task to complete\n-            latch.await();\n-            assertTrue(interrupted.get());\n-\n-            scope.join();\n-\n-            \/\/ subtask result\/exception not available\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            assertThrows(IllegalStateException.class, subtask::get);\n-            assertThrows(IllegalStateException.class, subtask::exception);\n-        }\n-    }\n-\n-    \/**\n-     * Test that shutdown does not interrupt current thread.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownInterruptsThreads2(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var interrupted = new AtomicBoolean();\n-            var latch = new CountDownLatch(1);\n-            var subtask = scope.fork(() -> {\n-                try {\n-                    scope.shutdown();\n-                    interrupted.set(Thread.currentThread().isInterrupted());\n-                } finally {\n-                    latch.countDown();\n-                }\n-                return null;\n-            });\n-\n-            \/\/ wait for task to complete\n-            latch.await();\n-            assertFalse(interrupted.get());\n-\n-            scope.join();\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown wakes join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownWakesJoin(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var latch = new CountDownLatch(1);\n-            scope.fork(() -> {\n-                Thread.sleep(Duration.ofMillis(100));  \/\/ give time for join to block\n-                scope.shutdown();\n-                latch.await();\n-                return null;\n-            });\n-\n-            scope.join();\n-\n-            \/\/ join woke up, allow task to complete\n-            latch.countDown();\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown after scope is closed.\n-     *\/\n-    @Test\n-    void testShutdownAfterClose() throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            scope.join();\n-            scope.close();\n-            assertThrows(IllegalStateException.class, scope::shutdown);\n-        }\n-    }\n-\n-    \/**\n-     * Test shutdown is confined to threads in the scope \"tree\".\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownConfined(ThreadFactory factory) throws Exception {\n-        try (var scope1 = new StructuredTaskScope<Boolean>();\n-             var scope2 = new StructuredTaskScope<Boolean>()) {\n-\n-            \/\/ thread in scope1 cannot shutdown scope2\n-            Subtask<Boolean> subtask1 = scope1.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope2::shutdown);\n-                return true;\n-            });\n-\n-            \/\/ wait for task in scope1 to complete to avoid racing with task in scope2\n-            while (subtask1.state() == Subtask.State.UNAVAILABLE) {\n-                Thread.sleep(10);\n-            }\n-\n-            \/\/ thread in scope2 shutdown scope1\n-            Subtask<Boolean> subtask2 = scope2.fork(() -> {\n-                scope1.shutdown();\n-                return true;\n-            });\n-\n-            scope2.join();\n-            scope1.join();\n-\n-            assertTrue(subtask1.get());\n-            assertTrue(subtask1.get());\n-\n-            \/\/ random thread cannot shutdown\n-            try (var pool = Executors.newSingleThreadExecutor()) {\n-                Future<Void> future = pool.submit(() -> {\n-                    assertThrows(WrongThreadException.class, scope1::shutdown);\n-                    assertThrows(WrongThreadException.class, scope2::shutdown);\n-                    return null;\n-                });\n-                future.get();\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Test isShutdown.\n-     *\/\n-    @Test\n-    void testIsShutdown() {\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            assertFalse(scope.isShutdown());   \/\/ before shutdown\n-            scope.shutdown();\n-            assertTrue(scope.isShutdown());    \/\/ after shutdown\n-            scope.close();\n-            assertTrue(scope.isShutdown());    \/\/ after cose\n-        }\n-    }\n-\n-    \/**\n-     * Test close without join, no subtasks forked.\n+     * Test close without join, no subtasks forked.\n@@ -836,1 +674,1 @@\n-        try (var scope = new StructuredTaskScope<Object>()) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -842,1 +680,1 @@\n-     * Test close without join, unfinished subtasks.\n+     * Test close without join, subtasks forked.\n@@ -847,1 +685,2 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -852,8 +691,0 @@\n-            assertThrows(IllegalStateException.class, scope::close);\n-\n-            \/\/ subtask result\/exception not available\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            assertThrows(IllegalStateException.class, subtask::get);\n-            assertThrows(IllegalStateException.class, subtask::exception);\n-        }\n-    }\n@@ -861,14 +692,1 @@\n-    \/**\n-     * Test close without join, unfinished subtasks forked after join.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseWithoutJoin3(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope(null, factory)) {\n-            scope.fork(() -> \"foo\");\n-            scope.join();\n-\n-            Subtask<String> subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n+            \/\/ first call to close should throw\n@@ -877,0 +695,5 @@\n+            \/\/ subsequent calls to close should not throw\n+            for (int i = 0; i < 3; i++) {\n+                scope.close();\n+            }\n+\n@@ -890,1 +713,2 @@\n-        try (var scope = new StructuredTaskScope<Object>()) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -900,14 +724,0 @@\n-        }\n-    }\n-\n-    \/**\n-     * Test close after joinUntil throws. Close should not throw as join attempted.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testCloseAfterJoinUntilThrows(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            var subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            });\n@@ -915,4 +725,1 @@\n-            \/\/ joinUntil throws\n-            assertThrows(TimeoutException.class, () -> scope.joinUntil(Instant.now()));\n-            assertThrows(IllegalStateException.class, subtask::get);\n-        }\n+        }  \/\/ close should not throw\n@@ -922,1 +729,1 @@\n-     * Test close is owner confined.\n+     * Test close method is owner confined.\n@@ -927,10 +734,2 @@\n-        try (var scope = new StructuredTaskScope<Boolean>()) {\n-\n-            \/\/ attempt to close from thread in scope\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope::close);\n-                return true;\n-            });\n-\n-            scope.join();\n-            assertTrue(subtask.get());\n+        try (var scope = StructuredTaskScope.open(Joiner.<Boolean>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -946,0 +745,8 @@\n+\n+            \/\/ subtask cannot close\n+            Subtask<Boolean> subtask = scope.fork(() -> {\n+                assertThrows(WrongThreadException.class, scope::close);\n+                return true;\n+            });\n+            scope.join();\n+            assertTrue(subtask.get());\n@@ -955,1 +762,6 @@\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(factory))) {\n+\n+            \/\/ fork first subtask, a straggler as it continues after being interrupted\n+            var started = new CountDownLatch(1);\n@@ -958,0 +770,1 @@\n+                started.countDown();\n@@ -961,1 +774,1 @@\n-                    \/\/ interrupted by shutdown, expected\n+                    \/\/ interrupted by cancel, expected\n@@ -967,0 +780,7 @@\n+            started.await();\n+\n+            \/\/ fork second subtask, the scope should be cancelled when this subtask completes\n+            scope.fork(() -> \"bar\");\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n+            }\n@@ -968,1 +788,0 @@\n-            scope.shutdown();\n@@ -988,2 +807,4 @@\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            var done = new AtomicBoolean();\n+        var testJoiner = new CancelAfterOneJoiner<String>();\n+        try (var scope = StructuredTaskScope.open(testJoiner,\n+                cf -> cf.withThreadFactory(factory))) {\n+\n@@ -991,0 +812,4 @@\n+\n+            \/\/ fork first subtask, a straggler as it continues after being interrupted\n+            var started = new CountDownLatch(1);\n+            var done = new AtomicBoolean();\n@@ -992,0 +817,1 @@\n+                started.countDown();\n@@ -995,1 +821,1 @@\n-                    \/\/ interrupted by shutdown, expected\n+                    \/\/ interrupted by cancel, expected\n@@ -999,1 +825,1 @@\n-                interruptThreadAt(mainThread, \"java.util.concurrent.StructuredTaskScope.close\");\n+                interruptThreadAt(mainThread, \"java.util.concurrent.StructuredTaskScopeImpl.close\");\n@@ -1005,0 +831,7 @@\n+            started.await();\n+\n+            \/\/ fork second subtask, the scope should be cancelled when this subtask completes\n+            scope.fork(() -> \"bar\");\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n+            }\n@@ -1006,1 +839,0 @@\n-            scope.shutdown();   \/\/ interrupts task\n@@ -1008,0 +840,2 @@\n+\n+            \/\/ main thread will be interrupted while blocked in close\n@@ -1011,1 +845,1 @@\n-                assertTrue(Thread.interrupted()); \/\/ clear interrupt status\n+                assertTrue(Thread.interrupted());   \/\/ clear interrupt status\n@@ -1022,2 +856,2 @@\n-        try (var scope1 = new StructuredTaskScope<Object>()) {\n-            try (var scope2 = new StructuredTaskScope<Object>()) {\n+        try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll())) {\n@@ -1025,2 +859,1 @@\n-                \/\/ join + close enclosing scope\n-                scope1.join();\n+                \/\/ close enclosing scope\n@@ -1032,1 +865,1 @@\n-                \/\/ underlying flock should be closed, fork should return a cancelled task\n+                \/\/ underlying flock should be closed\n@@ -1034,4 +867,1 @@\n-                Subtask<Void> subtask = scope2.fork(() -> {\n-                    executed.set(true);\n-                    return null;\n-                });\n+                Subtask<?> subtask = scope2.fork(() -> executed.set(true));\n@@ -1041,0 +871,1 @@\n+                assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n@@ -1046,1 +877,1 @@\n-     * A StructuredTaskScope that collects the subtasks notified to the handleComplete method.\n+     * Test that isCancelled returns true after close.\n@@ -1048,42 +879,6 @@\n-    private static class CollectAll<T> extends StructuredTaskScope<T> {\n-        private final Set<Subtask<? extends T>> subtasks = ConcurrentHashMap.newKeySet();\n-\n-        CollectAll(ThreadFactory factory) {\n-            super(null, factory);\n-        }\n-\n-        @Override\n-        protected void handleComplete(Subtask<? extends T> subtask) {\n-            subtasks.add(subtask);\n-        }\n-\n-        Set<Subtask<? extends T>> subtasks() {\n-            return subtasks;\n-        }\n-\n-        Subtask<? extends T> find(Callable<T> task) {\n-            return subtasks.stream()\n-                    .filter(h -> task.equals(h.task()))\n-                    .findAny()\n-                    .orElseThrow();\n-        }\n-    }\n-\n-    \/**\n-     * Test that handleComplete method is invoked for tasks that complete before shutdown.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleCompleteBeforeShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll<String>(factory)) {\n-            Callable<String> task1 = () -> \"foo\";\n-            Callable<String> task2 = () -> { throw new FooException(); };\n-            scope.fork(task1);\n-            scope.fork(task2);\n-            scope.join();\n-\n-            var subtask1 = scope.find(task1);\n-            assertEquals(\"foo\", subtask1.get());\n-\n-            var subtask2 = scope.find(task2);\n-            assertTrue(subtask2.exception() instanceof FooException);\n+    @Test\n+    void testIsCancelledAfterClose() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            assertFalse(scope.isCancelled());\n+            scope.close();\n+            assertTrue(scope.isCancelled());\n@@ -1094,2 +889,1 @@\n-     * Test that handleComplete method is not invoked for tasks that finish after shutdown\n-     * or are forked after shutdown.\n+     * Test Joiner.onFork throwing exception.\n@@ -1097,31 +891,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testHandleCompleteAfterShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new CollectAll<String>(factory)) {\n-            Callable<String> task1 = () -> {\n-                try {\n-                    Thread.sleep(Duration.ofDays(1));\n-                } catch (InterruptedException ignore) { }\n-                return \"foo\";\n-            };\n-            Callable<String> task2 = () -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"bar\";\n-            };\n-            Callable<String> task3 = () -> \"baz\";\n-\n-            \/\/ forked before shutdown, will complete after shutdown\n-            var subtask1 = scope.fork(task1);\n-            var subtask2 = scope.fork(task2);\n-\n-            scope.shutdown();\n-\n-            \/\/ forked after shutdown\n-            var subtask3 = scope.fork(task3);\n-\n-            scope.join();\n-\n-            \/\/ handleComplete should not be called\n-            for (int i = 0; i < 3; i++) {\n-                assertEquals(0, scope.subtasks().size());\n-                Thread.sleep(20);\n+    @Test\n+    void testOnForkThrows() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onFork(Subtask<? extends String> subtask) {\n+                throw new FooException();\n@@ -1129,4 +898,7 @@\n-\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask1.state());\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask3.state());\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            assertThrows(FooException.class, () -> scope.fork(() -> \"foo\"));\n@@ -1137,2 +909,1 @@\n-     * Test that the default handleComplete throws IllegalArgumentException if called\n-     * with a running task.\n+     * Test Joiner.onFork returning true to cancel execution.\n@@ -1141,4 +912,5 @@\n-    void testHandleCompleteThrows() throws Exception {\n-        class TestScope<T> extends StructuredTaskScope<T> {\n-            protected void handleComplete(Subtask<? extends T> subtask) {\n-                super.handleComplete(subtask);\n+    void testOnForkCancelsExecution() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onFork(Subtask<? extends String> subtask) {\n+                return true;\n@@ -1146,16 +918,9 @@\n-        }\n-\n-        try (var scope = new TestScope<String>()) {\n-            var subtask = scope.fork(() -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return \"foo\";\n-            });\n-\n-            \/\/ running task\n-            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n-            assertThrows(IllegalArgumentException.class, () -> scope.handleComplete(subtask));\n-            scope.shutdown();\n-\n-            \/\/ null task\n-            assertThrows(NullPointerException.class, () -> scope.handleComplete(null));\n-\n+            @Override\n+            public Void result() {\n+                return null;\n+            }\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            assertFalse(scope.isCancelled());\n+            scope.fork(() -> \"foo\");\n+            assertTrue(scope.isCancelled());\n@@ -1167,1 +932,1 @@\n-     * Test ensureOwnerAndJoined.\n+     * Test Joiner.onComplete throwing exception causes UHE to be invoked.\n@@ -1169,9 +934,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testEnsureOwnerAndJoined(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n-            }\n-            void invokeEnsureOwnerAndJoined() {\n-                super.ensureOwnerAndJoined();\n+    @Test\n+    void testOnCompleteThrows() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onComplete(Subtask<? extends String> subtask) {\n+                throw new FooException();\n@@ -1179,32 +941,3 @@\n-        }\n-\n-        try (var scope = new MyScope<Boolean>(factory)) {\n-            \/\/ owner thread, before join\n-            scope.fork(() -> true);\n-            assertThrows(IllegalStateException.class, () -> {\n-                scope.invokeEnsureOwnerAndJoined();\n-            });\n-\n-            \/\/ owner thread, after join\n-            scope.join();\n-            scope.invokeEnsureOwnerAndJoined();\n-\n-            \/\/ thread in scope cannot invoke ensureOwnerAndJoined\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope.invokeEnsureOwnerAndJoined();\n-                });\n-                return true;\n-            });\n-            scope.join();\n-            assertTrue(subtask.get());\n-\n-            \/\/ random thread cannot invoke ensureOwnerAndJoined\n-            try (var pool = Executors.newSingleThreadExecutor()) {\n-                Future<Void> future = pool.submit(() -> {\n-                    assertThrows(WrongThreadException.class, () -> {\n-                        scope.invokeEnsureOwnerAndJoined();\n-                    });\n-                    return null;\n-                });\n-                future.get();\n+            @Override\n+            public Void result() {\n+                return null;\n@@ -1212,0 +945,10 @@\n+        };\n+        var excRef = new AtomicReference<Throwable>();\n+        Thread.UncaughtExceptionHandler uhe = (t, e) -> excRef.set(e);\n+        ThreadFactory factory = Thread.ofVirtual()\n+                .uncaughtExceptionHandler(uhe)\n+                .factory();\n+        try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n+            scope.join();\n+            assertInstanceOf(FooException.class, excRef.get());\n@@ -1216,1 +959,1 @@\n-     * Test ensureOwnerAndJoined after the task scope has been closed.\n+     * Test Joiner.onComplete returning true to cancel execution.\n@@ -1218,6 +961,6 @@\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testEnsureOwnerAndJoinedAfterClose(ThreadFactory factory) throws Exception {\n-        class MyScope<T> extends StructuredTaskScope<T> {\n-            MyScope(ThreadFactory factory) {\n-                super(null, factory);\n+    @Test\n+    void testOnCompleteCancelsExecution() throws Exception {\n+        var joiner = new Joiner<String, Void>() {\n+            @Override\n+            public boolean onComplete(Subtask<? extends String> subtask) {\n+                return true;\n@@ -1225,2 +968,3 @@\n-            public void invokeEnsureOwnerAndJoined() {\n-                super.ensureOwnerAndJoined();\n+            @Override\n+            public Void result() {\n+                return null;\n@@ -1228,4 +972,3 @@\n-        }\n-\n-        \/\/ ensureOwnerAndJoined after close, join invoked\n-        try (var scope = new MyScope<String>(factory)) {\n+        };\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            assertFalse(scope.isCancelled());\n@@ -1233,0 +976,3 @@\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(10);\n+            }\n@@ -1234,9 +980,0 @@\n-            scope.close();\n-            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n-        }\n-\n-        \/\/ ensureOwnerAndJoined after close, join not invoked\n-        try (var scope = new MyScope<String>(factory)) {\n-            scope.fork(() -> \"foo\");\n-            assertThrows(IllegalStateException.class, scope::close);\n-            scope.invokeEnsureOwnerAndJoined();  \/\/ should not throw\n@@ -1246,1 +983,0 @@\n-\n@@ -1252,4 +988,2 @@\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope = new StructuredTaskScope<Object>(\"duke\", factory)) {\n-            \/\/ open\n-            assertTrue(scope.toString().contains(\"duke\"));\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withName(\"duke\"))) {\n@@ -1257,2 +991,1 @@\n-            \/\/ shutdown\n-            scope.shutdown();\n+            \/\/ open\n@@ -1262,1 +995,0 @@\n-            scope.join();\n@@ -1274,3 +1006,4 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            Callable<String> task = () -> \"foo\";\n-            Subtask<String> subtask = scope.fork(task);\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+\n+            Subtask<String> subtask = scope.fork(() -> \"foo\");\n@@ -1278,2 +1011,1 @@\n-            \/\/ before join, owner thread\n-            assertEquals(task, subtask.task());\n+            \/\/ before join\n@@ -1286,1 +1018,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1299,3 +1030,4 @@\n-        try (var scope = new StructuredTaskScope<String>(null, factory)) {\n-            Callable<String> task = () -> { throw new FooException(); };\n-            Subtask<String> subtask = scope.fork(task);\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+\n+            Subtask<String> subtask = scope.fork(() -> { throw new FooException(); });\n@@ -1303,2 +1035,1 @@\n-            \/\/ before join, owner thread\n-            assertEquals(task, subtask.task());\n+            \/\/ before join\n@@ -1311,1 +1042,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1324,2 +1054,3 @@\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            Callable<Void> task = () -> {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            Subtask<Void> subtask = scope.fork(() -> {\n@@ -1328,2 +1059,1 @@\n-            };\n-            Subtask<Void> subtask = scope.fork(task);\n+            });\n@@ -1332,1 +1062,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1342,1 +1071,0 @@\n-            assertEquals(task, subtask.task());\n@@ -1350,1 +1078,1 @@\n-     * Test Subtask when forked after shutdown.\n+     * Test Subtask forked after execution cancelled.\n@@ -1354,6 +1082,6 @@\n-    void testSubtaskWhenShutdown(ThreadFactory factory) throws Exception {\n-        try (var scope = new StructuredTaskScope<Object>(null, factory)) {\n-            Callable<Void> task = () -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            };\n+    void testSubtaskWhenCancelled(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(new CancelAfterOneJoiner<String>())) {\n+            scope.fork(() -> \"foo\");\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n+            }\n@@ -1361,1 +1089,6 @@\n-            scope.shutdown();\n+            var subtask = scope.fork(() -> \"foo\");\n+\n+            \/\/ before join\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalStateException.class, subtask::get);\n+            assertThrows(IllegalStateException.class, subtask::exception);\n@@ -1363,2 +1096,0 @@\n-            \/\/ fork after shutdown\n-            Subtask<Void> subtask = scope.fork(task);\n@@ -1366,1 +1097,2 @@\n-            assertEquals(task, subtask.task());\n+\n+            \/\/ after join\n@@ -1378,7 +1110,6 @@\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            \/\/ success\n-            var subtask1 = scope.fork(() -> \"foo\");\n-            scope.join();\n-            assertTrue(subtask1.toString().contains(\"Completed successfully\"));\n-\n-            \/\/ failed\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            var latch = new CountDownLatch(1);\n+            var subtask1 = scope.fork(() -> {\n+                latch.await();\n+                return \"foo\";\n+            });\n@@ -1386,0 +1117,5 @@\n+\n+            \/\/ subtask1 result is unavailable\n+            assertTrue(subtask1.toString().contains(\"Unavailable\"));\n+            latch.countDown();\n+\n@@ -1387,1 +1123,0 @@\n-            assertTrue(subtask2.toString().contains(\"Failed\"));\n@@ -1389,7 +1124,4 @@\n-            \/\/ not completed\n-            Callable<Void> sleepForDay = () -> {\n-                Thread.sleep(Duration.ofDays(1));\n-                return null;\n-            };\n-            var subtask3 = scope.fork(sleepForDay);\n-            assertTrue(subtask3.toString().contains(\"Unavailable\"));\n+            assertTrue(subtask1.toString().contains(\"Completed successfully\"));\n+            assertTrue(subtask2.toString().contains(\"Failed\"));\n+        }\n+    }\n@@ -1397,1 +1129,10 @@\n-            scope.shutdown();\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with no subtasks.\n+     *\/\n+    @Test\n+    void testAllSuccessfulOrThrow1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.allSuccessfulOrThrow())) {\n+            var subtasks = scope.join().toList();\n+            assertTrue(subtasks.isEmpty());\n+        }\n+    }\n@@ -1399,3 +1140,16 @@\n-            \/\/ forked after shutdown\n-            var subtask4 = scope.fork(sleepForDay);\n-            assertTrue(subtask4.toString().contains(\"Unavailable\"));\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with subtasks that complete successfully.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAllSuccessfulOrThrow2(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            var subtasks = scope.join().toList();\n+            assertEquals(List.of(subtask1, subtask2), subtasks);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+        }\n+    }\n@@ -1403,1 +1157,16 @@\n-            scope.join();\n+    \/**\n+     * Test Joiner.allSuccessfulOrThrow() with a subtask that complete successfully and\n+     * a subtask that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAllSuccessfulOrThrow3(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new FooException(); });\n+            try {\n+                scope.join();\n+            } catch (FailedException e) {\n+                assertTrue(e.getCause() instanceof FooException);\n+            }\n@@ -1408,1 +1177,1 @@\n-     * Test ShutdownOnSuccess with no completed tasks.\n+     * Test Joiner.anySuccessfulResultOrThrow() with no subtasks.\n@@ -1411,4 +1180,7 @@\n-    void testShutdownOnSuccess1() throws Exception {\n-        try (var scope = new ShutdownOnSuccess<Object>()) {\n-            assertThrows(IllegalStateException.class, () -> scope.result());\n-            assertThrows(IllegalStateException.class, () -> scope.result(e -> null));\n+    void testAnySuccessfulResultOrThrow1() throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {\n+            try {\n+                scope.join();\n+            } catch (FailedException e) {\n+                assertTrue(e.getCause() instanceof NoSuchElementException);\n+            }\n@@ -1419,1 +1191,1 @@\n-     * Test ShutdownOnSuccess with tasks that complete successfully.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully.\n@@ -1423,2 +1195,3 @@\n-    void testShutdownOnSuccess2(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+    void testAnySuccessfulResultOrThrow2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1426,5 +1199,2 @@\n-            scope.join();  \/\/ ensures foo completes first\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n+            String result = scope.join();\n+            assertEquals(\"foo\", result);\n@@ -1435,1 +1205,2 @@\n-     * Test ShutdownOnSuccess with a task that completes successfully with a null result.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that completes successfully\n+     * with a null result.\n@@ -1439,2 +1210,3 @@\n-    void testShutdownOnSuccess3(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n+    void testAnySuccessfulResultOrThrow3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1442,3 +1214,2 @@\n-            scope.join();\n-            assertNull(scope.result());\n-            assertNull(scope.result(e -> null));\n+            String result = scope.join();\n+            assertNull(result);\n@@ -1449,1 +1220,2 @@\n-     * Test ShutdownOnSuccess with tasks that complete succcessfully and tasks that fail.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that complete succcessfully\n+     * and a subtask that fails.\n@@ -1453,2 +1225,3 @@\n-    void testShutdownOnSuccess4(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<String>(null, factory)) {\n+    void testAnySuccessfulResultOrThrow4(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1456,4 +1229,3 @@\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-            assertEquals(\"foo\", scope.result());\n-            assertEquals(\"foo\", scope.result(e -> null));\n+            scope.fork(() -> { throw new FooException(); });\n+            String first = scope.join();\n+            assertEquals(\"foo\", first);\n@@ -1464,1 +1236,1 @@\n-     * Test ShutdownOnSuccess with a task that fails.\n+     * Test Joiner.anySuccessfulResultOrThrow() with a subtask that fails.\n@@ -1468,8 +1240,17 @@\n-    void testShutdownOnSuccess5(ThreadFactory factory) throws Exception {\n-        try (var scope = new ShutdownOnSuccess<Object>(null, factory)) {\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n-            Throwable ex = assertThrows(ExecutionException.class, () -> scope.result());\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n-            ex = assertThrows(FooException.class, () -> scope.result(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n+    void testAnySuccessfulResultOrThrow5(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> { throw new FooException(); });\n+            Throwable ex = assertThrows(FailedException.class, scope::join);\n+            assertTrue(ex.getCause() instanceof FooException);\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with no subtasks.\n+     *\/\n+    @Test\n+    void testAwaitSuccessfulOrThrow1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAllSuccessfulOrThrow())) {\n+            var result = scope.join();\n+            assertNull(result);\n@@ -1480,1 +1261,1 @@\n-     * Test ShutdownOnSuccess methods are confined to the owner.\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with subtasks that complete successfully.\n@@ -1484,9 +1265,9 @@\n-    void testShutdownOnSuccessConfined(ThreadFactory factory) throws Exception {\n-        \/\/ owner before join\n-        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n-            scope.fork(() -> { throw new FooException(); });\n-            assertThrows(IllegalStateException.class, scope::result);\n-            assertThrows(IllegalStateException.class, () -> {\n-                scope.result(e -> new RuntimeException(e));\n-            });\n-            scope.join();\n+    void testAwaitSuccessfulOrThrow2(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAllSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            var result = scope.join();\n+            assertNull(result);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n@@ -1494,0 +1275,1 @@\n+    }\n@@ -1495,11 +1277,16 @@\n-        \/\/ non-owner\n-        try (var scope = new ShutdownOnSuccess<Boolean>(null, factory)) {\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope::result);\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope.result(e -> new RuntimeException(e));\n-                });\n-                return true;\n-            });\n-            scope.join();\n-            assertTrue(subtask.get());\n+    \/**\n+     * Test Joiner.awaitAllSuccessfulOrThrow() with a subtask that complete successfully and\n+     * a subtask that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitSuccessfulOrThrow3(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAllSuccessfulOrThrow(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            scope.fork(() -> \"foo\");\n+            scope.fork(() -> { throw new FooException(); });\n+            try {\n+                scope.join();\n+            } catch (FailedException e) {\n+                assertTrue(e.getCause() instanceof FooException);\n+            }\n@@ -1510,1 +1297,1 @@\n-     * Test ShutdownOnFailure with no completed tasks.\n+     * Test Joiner.awaitAll() with no subtasks.\n@@ -1513,5 +1300,4 @@\n-    void testShutdownOnFailure1() throws Throwable {\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n+    void testAwaitAll1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            var result = scope.join();\n+            assertNull(result);\n@@ -1522,1 +1308,1 @@\n-     * Test ShutdownOnFailure with tasks that complete successfully.\n+     * Test Joiner.awaitAll() with subtasks that complete successfully.\n@@ -1526,5 +1312,29 @@\n-    void testShutdownOnFailure2(ThreadFactory factory) throws Throwable {\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> \"bar\");\n-            scope.join();\n+    void testAwaitAll2(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            var result = scope.join();\n+            assertNull(result);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(\"bar\", subtask2.get());\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiner.awaitAll() with a subtask that complete successfully and a subtask\n+     * that fails.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAwaitAll3(ThreadFactory factory) throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>awaitAll(),\n+                cf -> cf.withThreadFactory(factory))) {\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> { throw new FooException(); });\n+            var result = scope.join();\n+            assertNull(result);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertTrue(subtask2.exception() instanceof FooException);\n+        }\n+    }\n@@ -1532,4 +1342,8 @@\n-            \/\/ no exception\n-            assertTrue(scope.exception().isEmpty());\n-            scope.throwIfFailed();\n-            scope.throwIfFailed(e -> new FooException(e));\n+    \/**\n+     * Test Joiner.allUntil(Predicate) with no subtasks.\n+     *\/\n+    @Test\n+    void testAllUntil1() throws Throwable {\n+        try (var scope = StructuredTaskScope.open(Joiner.allUntil(s -> false))) {\n+            var subtasks = scope.join();\n+            assertEquals(0, subtasks.count());\n@@ -1540,1 +1354,1 @@\n-     * Test ShutdownOnFailure with tasks that complete succcessfully and tasks that fail.\n+     * Test Joiner.allUntil(Predicate) with no cancellation.\n@@ -1544,2 +1358,3 @@\n-    void testShutdownOnFailure3(ThreadFactory factory) throws Throwable {\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n+    void testAllUntil2(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> false),\n+                cf -> cf.withThreadFactory(factory))) {\n@@ -1547,4 +1362,12 @@\n-            \/\/ one task completes successfully, the other fails\n-            scope.fork(() -> \"foo\");\n-            scope.fork(() -> { throw new ArithmeticException(); });\n-            scope.join();\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> { throw new FooException(); });\n+\n+            var subtasks = scope.join().toList();\n+            assertEquals(2, subtasks.size());\n+\n+            assertTrue(subtasks.get(0) == subtask1);\n+            assertTrue(subtasks.get(1) == subtask2);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertTrue(subtask2.exception() instanceof FooException);\n+        }\n+    }\n@@ -1552,2 +1375,14 @@\n-            Throwable ex = scope.exception().orElse(null);\n-            assertTrue(ex instanceof ArithmeticException);\n+    \/**\n+     * Test Joiner.allUntil(Predicate) with cancellation after one subtask completes.\n+     *\/\n+    @ParameterizedTest\n+    @MethodSource(\"factories\")\n+    void testAllUntil3(ThreadFactory factory) throws Exception {\n+        try (var scope = StructuredTaskScope.open(Joiner.<String>allUntil(s -> true),\n+                cf -> cf.withThreadFactory(factory))) {\n+\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            var subtask2 = scope.fork(() -> {\n+                Thread.sleep(Duration.ofDays(1));\n+                return \"bar\";\n+            });\n@@ -1555,2 +1390,1 @@\n-            ex = assertThrows(ExecutionException.class, () -> scope.throwIfFailed());\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n+            var subtasks = scope.join().toList();\n@@ -1558,3 +1392,5 @@\n-            ex = assertThrows(FooException.class,\n-                              () -> scope.throwIfFailed(e -> new FooException(e)));\n-            assertTrue(ex.getCause() instanceof ArithmeticException);\n+            assertEquals(2, subtasks.size());\n+            assertTrue(subtasks.get(0) == subtask1);\n+            assertTrue(subtasks.get(1) == subtask2);\n+            assertEquals(\"foo\", subtask1.get());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n@@ -1565,1 +1401,1 @@\n-     * Test ShutdownOnFailure methods are confined to the owner.\n+     * Test Joiner.allUntil(Predicate) with cancellation after serveral subtasks complete.\n@@ -1569,3 +1405,46 @@\n-    void testShutdownOnFailureConfined(ThreadFactory factory) throws Exception {\n-        \/\/ owner before join\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n+    void testAllUntil4(ThreadFactory factory) throws Exception {\n+\n+        \/\/ cancel execution after two or more failures\n+        class CancelAfterTwoFailures<T> implements Predicate<Subtask<? extends T>> {\n+            final AtomicInteger failedCount = new AtomicInteger();\n+            @Override\n+            public boolean test(Subtask<? extends T> subtask) {\n+                return subtask.state() == Subtask.State.FAILED\n+                        && failedCount.incrementAndGet() >= 2;\n+            }\n+        }\n+        var joiner = Joiner.allUntil(new CancelAfterTwoFailures<String>());\n+\n+        try (var scope = StructuredTaskScope.open(joiner)) {\n+            int forkCount = 0;\n+\n+            \/\/ fork subtasks until execution cancelled\n+            while (!scope.isCancelled()) {\n+                scope.fork(() -> \"foo\");\n+                scope.fork(() -> { throw new FooException(); });\n+                forkCount += 2;\n+                Thread.sleep(Duration.ofMillis(10));\n+            }\n+\n+            var subtasks = scope.join().toList();\n+            assertEquals(forkCount, subtasks.size());\n+\n+            long failedCount = subtasks.stream()\n+                    .filter(s -> s.state() == Subtask.State.FAILED)\n+                    .count();\n+            assertTrue(failedCount >= 2);\n+        }\n+    }\n+\n+    \/**\n+     * Test Test Joiner.allUntil(Predicate) where the Predicate's test method throws.\n+     *\/\n+    @Test\n+    void testAllUntil5() throws Exception {\n+        var joiner = Joiner.allUntil(_ -> { throw new FooException(); });\n+        var excRef = new AtomicReference<Throwable>();\n+        Thread.UncaughtExceptionHandler uhe = (t, e) -> excRef.set(e);\n+        ThreadFactory factory = Thread.ofVirtual()\n+                .uncaughtExceptionHandler(uhe)\n+                .factory();\n+        try (var scope = StructuredTaskScope.open(joiner, cf -> cf.withThreadFactory(factory))) {\n@@ -1573,5 +1452,0 @@\n-            assertThrows(IllegalStateException.class, scope::exception);\n-            assertThrows(IllegalStateException.class, scope::throwIfFailed);\n-            assertThrows(IllegalStateException.class, () -> {\n-                scope.throwIfFailed(e -> new RuntimeException(e));\n-            });\n@@ -1579,0 +1453,1 @@\n+            assertInstanceOf(FooException.class, excRef.get());\n@@ -1580,0 +1455,1 @@\n+    }\n@@ -1581,9 +1457,39 @@\n-        \/\/ non-owner\n-        try (var scope = new ShutdownOnFailure(null, factory)) {\n-            Subtask<Boolean> subtask = scope.fork(() -> {\n-                assertThrows(WrongThreadException.class, scope::exception);\n-                assertThrows(WrongThreadException.class, scope::throwIfFailed);\n-                assertThrows(WrongThreadException.class, () -> {\n-                    scope.throwIfFailed(e -> new RuntimeException(e));\n-                });\n-                return true;\n+    \/**\n+     * Test Joiner default methods.\n+     *\/\n+    @Test\n+    void testJoinerDefaultMethods() throws Exception {\n+        try (var scope = StructuredTaskScope.open(new CancelAfterOneJoiner<String>())) {\n+\n+            \/\/ need subtasks to test default methods\n+            var subtask1 = scope.fork(() -> \"foo\");\n+            while (!scope.isCancelled()) {\n+                Thread.sleep(20);\n+            }\n+            var subtask2 = scope.fork(() -> \"bar\");\n+            scope.join();\n+\n+            assertEquals(Subtask.State.SUCCESS, subtask1.state());\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask2.state());\n+\n+            \/\/ Joiner that does not override default methods\n+            Joiner<Object, Void> joiner = () -> null;\n+            assertThrows(NullPointerException.class, () -> joiner.onFork(null));\n+            assertThrows(NullPointerException.class, () -> joiner.onComplete(null));\n+            assertThrows(IllegalArgumentException.class, () -> joiner.onFork(subtask1));\n+            assertFalse(joiner.onFork(subtask2));\n+            assertFalse(joiner.onComplete(subtask1));\n+            assertThrows(IllegalArgumentException.class, () -> joiner.onComplete(subtask2));\n+        }\n+    }\n+\n+    \/**\n+     * Test Joiners onFork\/onComplete methods with a subtask in an unexpected state.\n+     *\/\n+    @Test\n+    void testJoinersWithUnavailableResukt() throws Exception {\n+        try (var scope = StructuredTaskScope.open()) {\n+            var done = new CountDownLatch(1);\n+            var subtask = scope.fork(() -> {\n+                done.await();\n+                return null;\n@@ -1591,0 +1497,15 @@\n+\n+            \/\/ onComplete with uncompleted task should throw IAE\n+            assertEquals(Subtask.State.UNAVAILABLE, subtask.state());\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allSuccessfulOrThrow().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.anySuccessfulResultOrThrow().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAllSuccessfulOrThrow().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAll().onComplete(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allUntil(_ -> false).onComplete(subtask));\n+\n+            done.countDown();\n@@ -1592,1 +1513,59 @@\n-            assertTrue(subtask.get());\n+\n+            \/\/ onFork with completed task should throw IAE\n+            assertEquals(Subtask.State.SUCCESS, subtask.state());\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allSuccessfulOrThrow().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.anySuccessfulResultOrThrow().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAllSuccessfulOrThrow().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.awaitAll().onFork(subtask));\n+            assertThrows(IllegalArgumentException.class,\n+                    () -> Joiner.allUntil(_ -> false).onFork(subtask));\n+        }\n+\n+    }\n+\n+    \/**\n+     * Test the Config function apply method throwing an exception.\n+     *\/\n+    @Test\n+    void testConfigFunctionThrows() throws Exception {\n+        assertThrows(FooException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(),\n+                                               cf -> { throw new FooException(); }));\n+    }\n+\n+    \/**\n+     * Test Config equals\/hashCode\/toString\n+     *\/\n+    @Test\n+    void testConfigMethods() throws Exception {\n+        Function<Config, Config> testConfig = cf -> {\n+            var name = \"duke\";\n+            var threadFactory = Thread.ofPlatform().factory();\n+            var timeout = Duration.ofSeconds(10);\n+\n+            assertEquals(cf, cf);\n+            assertEquals(cf.withName(name), cf.withName(name));\n+            assertEquals(cf.withThreadFactory(threadFactory), cf.withThreadFactory(threadFactory));\n+            assertEquals(cf.withTimeout(timeout), cf.withTimeout(timeout));\n+\n+            assertNotEquals(cf, cf.withName(name));\n+            assertNotEquals(cf, cf.withThreadFactory(threadFactory));\n+            assertNotEquals(cf, cf.withTimeout(timeout));\n+\n+            assertEquals(cf.withName(name).hashCode(), cf.withName(name).hashCode());\n+            assertEquals(cf.withThreadFactory(threadFactory).hashCode(),\n+                    cf.withThreadFactory(threadFactory).hashCode());\n+            assertEquals(cf.withTimeout(timeout).hashCode(), cf.withTimeout(timeout).hashCode());\n+\n+            assertTrue(cf.withName(name).toString().contains(name));\n+            assertTrue(cf.withThreadFactory(threadFactory).toString().contains(threadFactory.toString()));\n+            assertTrue(cf.withTimeout(timeout).toString().contains(timeout.toString()));\n+\n+            return cf;\n+        };\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), testConfig)) {\n+            \/\/ do nothing\n@@ -1601,4 +1580,60 @@\n-        assertThrows(NullPointerException.class, () -> new StructuredTaskScope(\"\", null));\n-        try (var scope = new StructuredTaskScope<Object>()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(null));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(null, cf -> cf));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), null));\n+\n+        assertThrows(NullPointerException.class, () -> Joiner.allUntil(null));\n+\n+        \/\/ fork\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            assertThrows(NullPointerException.class, () -> scope.fork((Callable<Object>) null));\n+            assertThrows(NullPointerException.class, () -> scope.fork((Runnable) null));\n+        }\n+\n+        \/\/ Config and withXXX methods\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> null));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(null)));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withThreadFactory(null)));\n+        assertThrows(NullPointerException.class,\n+                () -> StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withTimeout(null)));\n+\n+        \/\/ Joiner.onFork\/onComplete\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAllSuccessfulOrThrow().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAllSuccessfulOrThrow().onComplete(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAll().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.awaitAll().onComplete(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.allSuccessfulOrThrow().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.allSuccessfulOrThrow().onComplete(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.anySuccessfulResultOrThrow().onFork(null));\n+        assertThrows(NullPointerException.class,\n+                () -> Joiner.anySuccessfulResultOrThrow().onComplete(null));\n+    }\n+\n+    \/**\n+     * ThreadFactory that counts usage.\n+     *\/\n+    private static class CountingThreadFactory implements ThreadFactory {\n+        final ThreadFactory delegate;\n+        final AtomicInteger threadCount = new AtomicInteger();\n+        CountingThreadFactory(ThreadFactory delegate) {\n+            this.delegate = delegate;\n+        }\n+        @Override\n+        public Thread newThread(Runnable task) {\n+            threadCount.incrementAndGet();\n+            return delegate.newThread(task);\n+        }\n+        int threadCount() {\n+            return threadCount.get();\n@@ -1606,0 +1641,1 @@\n+    }\n@@ -1607,5 +1643,11 @@\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnSuccess<Object>(\"\", null));\n-        try (var scope = new ShutdownOnSuccess<Object>()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.result(null));\n+    \/**\n+     * A joiner that counts that counts the number of subtasks that are forked and the\n+     * number of subtasks that complete.\n+     *\/\n+    private static class CountingJoiner<T> implements Joiner<T, Void> {\n+        final AtomicInteger onForkCount = new AtomicInteger();\n+        final AtomicInteger onCompleteCount = new AtomicInteger();\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            onForkCount.incrementAndGet();\n+            return false;\n@@ -1613,0 +1655,16 @@\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            onCompleteCount.incrementAndGet();\n+            return false;\n+        }\n+        @Override\n+        public Void result() {\n+            return null;\n+        }\n+        int onForkCount() {\n+            return onForkCount.get();\n+        }\n+        int onCompleteCount() {\n+            return onCompleteCount.get();\n+        }\n+    }\n@@ -1614,5 +1672,26 @@\n-        assertThrows(NullPointerException.class, () -> new ShutdownOnFailure(\"\", null));\n-        try (var scope = new ShutdownOnFailure()) {\n-            assertThrows(NullPointerException.class, () -> scope.fork(null));\n-            assertThrows(NullPointerException.class, () -> scope.joinUntil(null));\n-            assertThrows(NullPointerException.class, () -> scope.throwIfFailed(null));\n+    \/**\n+     * A joiner that cancels execution when a subtask completes. It also keeps a count\n+     * of the number of subtasks that are forked and the number of subtasks that complete.\n+     *\/\n+    private static class CancelAfterOneJoiner<T> implements Joiner<T, Void> {\n+        final AtomicInteger onForkCount = new AtomicInteger();\n+        final AtomicInteger onCompleteCount = new AtomicInteger();\n+        @Override\n+        public boolean onFork(Subtask<? extends T> subtask) {\n+            onForkCount.incrementAndGet();\n+            return false;\n+        }\n+        @Override\n+        public boolean onComplete(Subtask<? extends T> subtask) {\n+            onCompleteCount.incrementAndGet();\n+            return true;\n+        }\n+        @Override\n+        public Void result() {\n+            return null;\n+        }\n+        int onForkCount() {\n+            return onForkCount.get();\n+        }\n+        int onCompleteCount() {\n+            return onCompleteCount.get();\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredTaskScopeTest.java","additions":969,"deletions":890,"binary":false,"changes":1859,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -56,2 +57,1 @@\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope = new StructuredTaskScope<>(\"scope\", factory)) {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(\"scope\"))) {\n@@ -86,1 +86,2 @@\n-                scope.shutdown();\n+                LockSupport.unpark(thread1);\n+                LockSupport.unpark(thread2);\n@@ -98,2 +99,1 @@\n-        ThreadFactory factory = Thread.ofVirtual().factory();\n-        try (var scope1 = new StructuredTaskScope<>(\"scope-A\", factory)) {\n+        try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(\"scope-A\"))) {\n@@ -102,1 +102,1 @@\n-            try (var scope2 = new StructuredTaskScope<>(\"scope-B\", factory)) {\n+            try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll(), cf -> cf.withName(\"scope-B\"))) {\n@@ -130,1 +130,1 @@\n-                    scope2.shutdown();\n+                    LockSupport.unpark(thread2);\n@@ -134,1 +134,1 @@\n-                scope1.shutdown();\n+                LockSupport.unpark(thread1);\n@@ -163,1 +163,1 @@\n-    private static Thread fork(StructuredTaskScope<Object> scope) throws Exception {\n+    private static Thread fork(StructuredTaskScope<Object, Void> scope) throws Exception {\n@@ -181,1 +181,1 @@\n-    private static Thread fork(StructuredTaskScope<Object> scope,\n+    private static Thread fork(StructuredTaskScope<Object, Void> scope,\n@@ -185,2 +185,2 @@\n-            ThreadFactory factory = Thread.ofVirtual().factory();\n-            try (var childScope = new StructuredTaskScope<Object>(childScopeName, factory)) {\n+            try (var childScope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                    cf -> cf.withName(childScopeName))) {\n@@ -190,1 +190,0 @@\n-            return null;\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/StructuredThreadDumpTest.java","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.concurrent.StructuredTaskScope.Joiner;\n@@ -58,1 +59,2 @@\n-            try (var scope = new StructuredTaskScope<String>(null, factory)) {\n+            try (var scope = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                      cf -> cf.withThreadFactory(factory))) {\n@@ -77,1 +79,2 @@\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+            try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                       cf -> cf.withThreadFactory(factory))) {\n@@ -79,1 +82,2 @@\n-                    try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                    try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                               cf -> cf.withThreadFactory(factory))) {\n@@ -102,1 +106,2 @@\n-            try (var scope1 = new StructuredTaskScope<String>(null, factory)) {\n+            try (var scope1 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                       cf -> cf.withThreadFactory(factory))) {\n@@ -108,1 +113,2 @@\n-                        try (var scope2 = new StructuredTaskScope<String>(null, factory)) {\n+                        try (var scope2 = StructuredTaskScope.open(Joiner.awaitAll(),\n+                                                                   cf -> cf.withThreadFactory(factory))) {\n@@ -134,1 +140,1 @@\n-            StructuredTaskScope<Object> scope;\n+            StructuredTaskScope<Object, Void> scope;\n@@ -140,1 +146,1 @@\n-                    box.scope = new StructuredTaskScope<Object>();\n+                    box.scope = StructuredTaskScope.open(Joiner.awaitAll());\n@@ -146,1 +152,1 @@\n-            StructuredTaskScope<Object> scope = box.scope;\n+            StructuredTaskScope<Object, Void> scope = box.scope;\n@@ -156,1 +162,1 @@\n-            StructuredTaskScope<Object> scope = box.scope;\n+            StructuredTaskScope<Object, Void> scope = box.scope;\n@@ -169,2 +175,2 @@\n-        try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name, \"x\").run(() -> {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            ScopedValue.where(name, \"x\").run(() -> {\n@@ -182,2 +188,2 @@\n-        try (var scope = new StructuredTaskScope<String>()) {\n-                ScopedValue.where(name, \"x\").run(() -> {\n+        try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+            ScopedValue.where(name, \"x\").run(() -> {\n@@ -200,2 +206,2 @@\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                    ScopedValue.where(name1, \"y\").run(() -> {\n+            try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+                ScopedValue.where(name1, \"y\").run(() -> {\n@@ -210,2 +216,2 @@\n-            try (var scope = new StructuredTaskScope<String>()) {\n-                    ScopedValue.where(name2, \"y\").run(() -> {\n+            try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {\n+                ScopedValue.where(name2, \"y\").run(() -> {\n","filename":"test\/jdk\/java\/util\/concurrent\/StructuredTaskScope\/WithScopedValue.java","additions":24,"deletions":18,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -68,1 +68,2 @@\n-            try (var scope = new StructuredTaskScope<>()) {\n+            var joiner = StructuredTaskScope.Joiner.awaitAll();\n+            try (var scope = StructuredTaskScope.open(joiner)) {\n","filename":"test\/jdk\/javax\/security\/auth\/Subject\/CallAsWithScopedValue.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -753,45 +753,0 @@\n-    \/**\n-     * Test wakeup is flock confined.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testWakeupConfined(ThreadFactory factory) throws Exception {\n-        try (var flock = ThreadFlock.open(null)) {\n-            \/\/ thread in flock\n-            testWakeupConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                return flock.start(thread);\n-            });\n-\n-            \/\/ thread not in flock\n-            testWakeupConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                thread.start();\n-                return thread;\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test that a thread created with the given factory cannot wakeup the\n-     * given flock.\n-     *\/\n-    private void testWakeupConfined(ThreadFlock flock,\n-                                    Function<Runnable, Thread> factory) throws Exception {\n-        var exception = new AtomicReference<Exception>();\n-        Thread thread = factory.apply(() -> {\n-            try {\n-                flock.wakeup();\n-            } catch (Exception e) {\n-                exception.set(e);\n-            }\n-        });\n-        thread.join();\n-        Throwable cause = exception.get();\n-        if (flock.containsThread(thread)) {\n-            assertNull(cause);\n-        } else {\n-            assertTrue(cause instanceof WrongThreadException);\n-        }\n-    }\n-\n@@ -936,53 +891,0 @@\n-    \/**\n-     * Test shutdown is confined to threads in the flock.\n-     *\/\n-    @ParameterizedTest\n-    @MethodSource(\"factories\")\n-    void testShutdownConfined(ThreadFactory factory) throws Exception {\n-        try (var flock = ThreadFlock.open(null)) {\n-            \/\/ thread in flock\n-            testShutdownConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                return flock.start(thread);\n-            });\n-\n-            \/\/ thread in flock\n-            try (var flock2 = ThreadFlock.open(null)) {\n-                testShutdownConfined(flock, task -> {\n-                    Thread thread = factory.newThread(task);\n-                    return flock2.start(thread);\n-                });\n-            }\n-\n-            \/\/ thread not contained in flock\n-            testShutdownConfined(flock, task -> {\n-                Thread thread = factory.newThread(task);\n-                thread.start();\n-                return thread;\n-            });\n-        }\n-    }\n-\n-    \/**\n-     * Test that a thread created with the given factory cannot shut down the\n-     * given flock.\n-     *\/\n-    private void testShutdownConfined(ThreadFlock flock,\n-                                      Function<Runnable, Thread> factory) throws Exception {\n-        var exception = new AtomicReference<Exception>();\n-        Thread thread = factory.apply(() -> {\n-            try {\n-                flock.shutdown();\n-            } catch (Exception e) {\n-                exception.set(e);\n-            }\n-        });\n-        thread.join();\n-        Throwable cause = exception.get();\n-        if (flock.containsThread(thread)) {\n-            assertNull(cause);\n-        } else {\n-            assertTrue(cause instanceof WrongThreadException);\n-        }\n-    }\n-\n","filename":"test\/jdk\/jdk\/internal\/misc\/ThreadFlock\/ThreadFlockTest.java","additions":0,"deletions":98,"binary":false,"changes":98,"status":"modified"}]}