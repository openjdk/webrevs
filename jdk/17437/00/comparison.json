{"files":[{"patch":"@@ -27,1 +27,1 @@\n-#include \"asm\/assembler.hpp\"\n+#include \"asm\/macroAssembler.hpp\"\n@@ -70,1 +70,1 @@\n-    assert(immediate > 0 && Assembler::operand_valid_for_logical_immediate(\/*is32*\/false, immediate),\n+    assert(immediate > 0 && MacroAssembler::eor_compatible_klass_encoding(immediate) >= 32,\n@@ -133,0 +133,10 @@\n+\n+  DEBUG_ONLY(assert_is_valid_encoding(addr, len, _base, _shift);)\n+}\n+\n+bool CompressedKlassPointers::pd_is_valid_encoding(address addr, size_t len, address base, int shift) {\n+  size_t range = (addr == nullptr) \/* Not specified *\/ ? len : (addr + len - base);\n+  return (base == nullptr \/* Zero-based encoding *\/ ||\n+          (1ULL << MacroAssembler::eor_compatible_klass_encoding((uint64_t)base) >= range) ||\n+          MacroAssembler::movk_compatible_klass_encoding((uint64_t)base)) &&\n+         (shift == -1 \/* Not specified *\/ || shift == 0);\n","filename":"src\/hotspot\/cpu\/aarch64\/compressedKlass_aarch64.cpp","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -4647,0 +4647,9 @@\n+int MacroAssembler::eor_compatible_klass_encoding(uint64_t base) {\n+  return Assembler::operand_valid_for_logical_immediate(\/*is32*\/false, base) ?\n+         count_trailing_zeros(base) : 0; \/\/ Return the bits of the \"encodable area\" given a base\n+}\n+\n+bool MacroAssembler::movk_compatible_klass_encoding(uint64_t shifted_base) {\n+  return (shifted_base & 0xffff0000ffffffff) == 0;\n+}\n+\n@@ -4664,5 +4673,2 @@\n-  if (operand_valid_for_logical_immediate(\n-        \/*is32*\/false, (uint64_t)CompressedKlassPointers::base())) {\n-    const uint64_t range_mask =\n-      (1ULL << log2i(CompressedKlassPointers::range())) - 1;\n-    if (((uint64_t)CompressedKlassPointers::base() & range_mask) == 0) {\n+  if (int bits = eor_compatible_klass_encoding((uint64_t)CompressedKlassPointers::base())) {\n+    if (CompressedKlassPointers::range() <= (1ULL << bits)) {\n@@ -4675,1 +4681,1 @@\n-  guarantee((shifted_base & 0xffff0000ffffffff) == 0,\n+  guarantee(movk_compatible_klass_encoding(shifted_base),\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -917,0 +917,3 @@\n+  static int eor_compatible_klass_encoding(uint64_t base);\n+  static bool movk_compatible_klass_encoding(uint64_t shifted_base);\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -589,0 +589,2 @@\n+#if !defined(AARCH64)\n+  \/\/ On aarch64, this likely wouldn't satisfy the encoding constraints.\n@@ -594,0 +596,1 @@\n+#endif \/\/ !AARCH64\n@@ -735,1 +738,3 @@\n-      if (!is_aligned(base, Metaspace::reserve_alignment())) {\n+      if (!is_aligned(base, Metaspace::reserve_alignment()) ||\n+          !(CompressedKlassPointers::pd_is_valid_encoding(\n+                nullptr \/* Not specified *\/, size, base, -1 \/* Not specified *\/))) {\n@@ -738,1 +743,1 @@\n-                    \"(must be aligned to \" SIZE_FORMAT_X \").\",\n+                    \"(must be aligned to \" SIZE_FORMAT_X \" and satisify platform constraints).\",\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -45,0 +45,1 @@\n+  assert(pd_is_valid_encoding(addr, len, base, shift), \"Must satisfy\");\n@@ -118,0 +119,4 @@\n+\n+bool CompressedKlassPointers::pd_is_valid_encoding(address addr, size_t len, address base, int shift) {\n+  return true;\n+}\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,2 @@\n+  static bool pd_is_valid_encoding(address addr, size_t len, address base, int shift);\n+\n","filename":"src\/hotspot\/share\/oops\/compressedKlass.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"}]}