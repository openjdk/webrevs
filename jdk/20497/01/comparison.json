{"files":[{"patch":"@@ -44,1 +44,1 @@\n-        value=\"$(grep -h ${{ inputs.var }}= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n+        value=\"$(grep -h '^${{ inputs.var }}'= make\/conf\/github-actions.conf | cut -d '=' -f 2-)\"\n","filename":".github\/actions\/config\/action.yml","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,0 +48,1 @@\n+        static_libs_bundle=\"$(ls build\/*\/bundles\/jdk-*_bin-static-libs${{ inputs.debug-suffix }}.tar.gz 2> \/dev\/null || true)\"\n@@ -63,0 +64,3 @@\n+        if [[ \"$static_libs_bundle\" != \"\" ]]; then\n+          mv \"$static_libs_bundle\" \"bundles\/static-libs-${{ inputs.platform }}${{ inputs.debug-suffix }}.tar.gz\"\n+        fi\n@@ -64,1 +68,1 @@\n-        if [[ \"$jdk_bundle_zip$jdk_bundle_tar_gz$symbols_bundle$tests_bundle\" != \"\" ]]; then\n+        if [[ \"$jdk_bundle_zip$jdk_bundle_tar_gz$symbols_bundle$tests_bundle$static_libs_bundle\" != \"\" ]]; then\n","filename":".github\/actions\/upload-bundles\/action.yml","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+name: 'Build (alpine-linux)'\n+\n+on:\n+  workflow_call:\n+    inputs:\n+      platform:\n+        required: true\n+        type: string\n+      extra-conf-options:\n+        required: false\n+        type: string\n+      make-target:\n+        required: false\n+        type: string\n+        default: 'product-bundles test-bundles'\n+      debug-levels:\n+        required: false\n+        type: string\n+        default: '[ \"debug\", \"release\" ]'\n+      apk-extra-packages:\n+        required: false\n+        type: string\n+      configure-arguments:\n+        required: false\n+        type: string\n+      make-arguments:\n+        required: false\n+        type: string\n+\n+jobs:\n+  build-linux:\n+    name: build\n+    runs-on: ubuntu-22.04\n+    container:\n+      image: alpine:3.20\n+\n+    strategy:\n+      fail-fast: false\n+      matrix:\n+        debug-level: ${{ fromJSON(inputs.debug-levels) }}\n+        include:\n+          - debug-level: debug\n+            flags: --with-debug-level=fastdebug\n+            suffix: -debug+\n+\n+    steps:\n+      - name: 'Checkout the JDK source'\n+        uses: actions\/checkout@v4\n+\n+      - name: 'Install toolchain and dependencies'\n+        run: |\n+          apk update\n+          apk add alpine-sdk alsa-lib-dev autoconf bash cups-dev cups-libs fontconfig-dev freetype-dev grep libx11-dev libxext-dev libxrandr-dev libxrender-dev libxt-dev libxtst-dev linux-headers wget zip ${{ inputs.apk-extra-packages }}\n+\n+      - name: 'Get the BootJDK'\n+        id: bootjdk\n+        uses: .\/.github\/actions\/get-bootjdk\n+        with:\n+          platform: alpine-linux-x64\n+\n+      - name: 'Configure'\n+        run: >\n+          bash configure\n+          --with-conf-name=${{ inputs.platform }}\n+          ${{ matrix.flags }}\n+          --with-version-opt=${GITHUB_ACTOR}-${GITHUB_SHA}\n+          --with-boot-jdk=${{ steps.bootjdk.outputs.path }}\n+          --with-zlib=system\n+          --with-jmod-compress=zip-1\n+          ${{ inputs.extra-conf-options }} ${{ inputs.configure-arguments }} || (\n+          echo \"Dumping config.log:\" &&\n+          cat config.log &&\n+          exit 1)\n+\n+      - name: 'Build'\n+        id: build\n+        uses: .\/.github\/actions\/do-build\n+        with:\n+          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n+\n+      - name: 'Upload bundles'\n+        uses: .\/.github\/actions\/upload-bundles\n+        with:\n+          platform: ${{ inputs.platform }}\n+          debug-suffix: '${{ matrix.suffix }}'\n","filename":".github\/workflows\/build-alpine-linux.yml","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -136,0 +136,4 @@\n+        env:\n+          # Only build static-libs-bundles for release builds.\n+          # For debug builds, building static-libs often exceeds disk space.\n+          STATIC_LIBS: ${{ matrix.debug-level == 'release' && 'static-libs-bundles' }}\n@@ -137,1 +141,1 @@\n-          make-target: '${{ inputs.make-target }} ${{ inputs.make-arguments }}'\n+          make-target: '${{ inputs.make-target }} ${STATIC_LIBS} ${{ inputs.make-arguments }}'\n","filename":".github\/workflows\/build-linux.yml","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-        default: 'linux-x64, linux-x86, linux-x64-variants, linux-cross-compile, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n+        default: 'linux-x64, linux-x86-hs, linux-x64-variants, linux-cross-compile, alpine-linux-x64, macos-x64, macos-aarch64, windows-x64, windows-aarch64, docs'\n@@ -60,0 +60,3 @@\n+    env:\n+      # List of platforms to exclude by default\n+      EXCLUDED_PLATFORMS: 'alpine-linux-x64'\n@@ -62,1 +65,1 @@\n-      linux-x86: ${{ steps.include.outputs.linux-x86 }}\n+      linux-x86-hs: ${{ steps.include.outputs.linux-x86-hs }}\n@@ -65,0 +68,1 @@\n+      alpine-linux-x64: ${{ steps.include.outputs.alpine-linux-x64 }}\n@@ -81,0 +85,4 @@\n+\n+          # Convert EXCLUDED_PLATFORMS from a comma-separated string to an array\n+          IFS=',' read -r -a excluded_array <<< \"$EXCLUDED_PLATFORMS\"\n+\n@@ -97,1 +105,7 @@\n-              # For an empty input, assume all platforms should run\n+              # For an empty input, assume all platforms should run, except those in the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -108,0 +122,8 @@\n+\n+              # If not explicitly included, check against the EXCLUDED_PLATFORMS list\n+              for excluded in \"${excluded_array[@]}\"; do\n+                if [[ \"$1\" == \"$excluded\" ]]; then\n+                  echo 'false'\n+                  return\n+                fi\n+              done\n@@ -114,1 +136,1 @@\n-          echo \"linux-x86=$(check_platform linux-x86 linux x86)\" >> $GITHUB_OUTPUT\n+          echo \"linux-x86-hs=$(check_platform linux-x86-hs linux x86)\" >> $GITHUB_OUTPUT\n@@ -117,0 +139,1 @@\n+          echo \"alpine-linux-x64=$(check_platform alpine-linux-x64 alpine-linux x64)\" >> $GITHUB_OUTPUT\n@@ -138,2 +161,2 @@\n-  build-linux-x86:\n-    name: linux-x86\n+  build-linux-x86-hs:\n+    name: linux-x86-hs\n@@ -144,0 +167,1 @@\n+      make-target: 'hotspot'\n@@ -153,1 +177,1 @@\n-    if: needs.select.outputs.linux-x86 == 'true'\n+    if: needs.select.outputs.linux-x86-hs == 'true'\n@@ -223,0 +247,10 @@\n+  build-alpine-linux-x64:\n+    name: alpine-linux-x64\n+    needs: select\n+    uses: .\/.github\/workflows\/build-alpine-linux.yml\n+    with:\n+      platform: alpine-linux-x64\n+      configure-arguments: ${{ github.event.inputs.configure-arguments }}\n+      make-arguments: ${{ github.event.inputs.make-arguments }}\n+    if: needs.select.outputs.alpine-linux-x64 == 'true'\n+\n@@ -303,10 +337,0 @@\n-  test-linux-x86:\n-    name: linux-x86\n-    needs:\n-      - build-linux-x86\n-    uses: .\/.github\/workflows\/test.yml\n-    with:\n-      platform: linux-x86\n-      bootjdk-platform: linux-x64\n-      runs-on: ubuntu-22.04\n-\n@@ -350,1 +374,1 @@\n-      - build-linux-x86\n+      - build-linux-x86-hs\n@@ -356,0 +380,1 @@\n+      - build-alpine-linux-x64\n@@ -361,1 +386,0 @@\n-      - test-linux-x86\n@@ -374,1 +398,1 @@\n-              '${{ github.api_url }}\/repos\/${{ github.repository }}\/actions\/runs\/${{ github.run_id }}\/artifacts')\"\n+              '${{ github.api_url }}\/repos\/${{ github.repository }}\/actions\/runs\/${{ github.run_id }}\/artifacts?per_page=100')\"\n","filename":".github\/workflows\/main.yml","additions":44,"deletions":20,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -287,1 +287,1 @@\n-    ################################################################################\n+    ############################################################################\n@@ -316,1 +316,1 @@\n-    ################################################################################\n+    ############################################################################\n","filename":"make\/Bundles.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-     $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n+    $(BUILDTOOLS_OUTPUTDIR)\/gensrc\/java.compiler.interim\/javax\/tools\/ToolProvider.java\n","filename":"make\/CompileInterimLangtools.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,6 +78,6 @@\n-       $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n-         $(subst \/share\/classes,, \\\n-            $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n-         ) \\\n-       ), \\\n-       .properties \\\n+        $(patsubst $(TOPDIR)\/src\/%, $(JDK_OUTPUTDIR)\/modules\/%, \\\n+            $(subst \/share\/classes,, \\\n+                $(subst _zh_TW,_zh_HK, $(filter %_zh_TW.properties, $1)) \\\n+            ) \\\n+        ), \\\n+        .properties \\\n","filename":"make\/CompileJavaModules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -55,2 +55,1 @@\n-        build\/tools\/depend \\\n-        , \\\n+        build\/tools\/depend, \\\n@@ -69,1 +68,1 @@\n-$(eval $(call SetupCopyFiles,COPY_NIMBUS_TEMPLATES, \\\n+$(eval $(call SetupCopyFiles, COPY_NIMBUS_TEMPLATES, \\\n@@ -72,1 +71,2 @@\n-    FILES := $(wildcard $(TOPDIR)\/src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/*.template)))\n+    FILES := $(wildcard $(TOPDIR)\/src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/*.template), \\\n+))\n@@ -76,1 +76,1 @@\n-$(eval $(call SetupCopyFiles,COPY_CLDRCONVERTER_PROPERTIES, \\\n+$(eval $(call SetupCopyFiles, COPY_CLDRCONVERTER_PROPERTIES, \\\n@@ -79,1 +79,2 @@\n-    FILES := $(wildcard $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/*.properties)))\n+    FILES := $(wildcard $(TOPDIR)\/make\/jdk\/src\/classes\/build\/tools\/cldrconverter\/*.properties), \\\n+))\n","filename":"make\/CompileToolsJdk.gmk","additions":7,"deletions":6,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-##########################################################################################\n+################################################################################\n@@ -44,1 +44,1 @@\n-$(eval $(call SetupCopyFiles,COPY_INTERIM_TZDB, \\\n+$(eval $(call SetupCopyFiles, COPY_INTERIM_TZDB, \\\n@@ -48,1 +48,2 @@\n-    MACRO := tzdb_copyfiles))\n+    MACRO := tzdb_copyfiles, \\\n+))\n@@ -50,1 +51,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/CopyInterimTZDB.gmk","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -232,0 +232,12 @@\n+\n+  JMOD_TARGET_OS := $(OPENJDK_BUILD_OS)\n+  ifeq ($(JMOD_TARGET_OS), macosx)\n+    JMOD_TARGET_OS := macos\n+  endif\n+\n+  JMOD_TARGET_CPU := $(OPENJDK_BUILD_CPU)\n+  ifeq ($(JMOD_TARGET_CPU), x86_64)\n+    JMOD_TARGET_CPU := amd64\n+  endif\n+\n+  JMOD_TARGET_PLATFORM := $(JMOD_TARGET_OS)-$(JMOD_TARGET_CPU)\n@@ -234,0 +246,1 @@\n+  JMOD_TARGET_PLATFORM := $(OPENJDK_MODULE_TARGET_PLATFORM)\n@@ -245,1 +258,1 @@\n-        --target-platform '$(OPENJDK_MODULE_TARGET_PLATFORM)' \\\n+        --target-platform '$(JMOD_TARGET_PLATFORM)' \\\n","filename":"make\/CreateJmods.gmk","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -250,1 +250,1 @@\n-  ifneq ($$($1_GROUPS),)\n+  ifneq ($$($1_GROUPS), )\n","filename":"make\/Docs.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -31,1 +31,1 @@\n-_:=\n+_ :=\n@@ -111,1 +111,1 @@\n-\t$(if $(all_confs), $(info Available configurations in $(build_dir):) $(foreach var,$(all_confs),$(info * $(var))),\\\n+\t$(if $(all_confs), $(info Available configurations in $(build_dir):) $(foreach var,$(all_confs),$(info * $(var))), \\\n","filename":"make\/Global.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -137,2 +137,2 @@\n-  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2),-XX:-UseCompressedOops,)\n-  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2),-NOCOOPS,)\n+  $1_$2_DUMP_EXTRA_ARG := $(if $(filter _nocoops, $2), -XX:-UseCompressedOops, )\n+  $1_$2_DUMP_TYPE      := $(if $(filter _nocoops, $2), -NOCOOPS, )\n@@ -141,1 +141,1 @@\n-  $1_$2_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)),-XX:+UseG1GC)\n+  $1_$2_CDS_DUMP_FLAGS := $(CDS_DUMP_FLAGS) $(if $(filter g1gc, $(JVM_FEATURES_$1)), -XX:+UseG1GC)\n@@ -238,1 +238,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_GCOV_GCNO, \\\n+  $(eval $(call SetupCopyFiles, COPY_GCOV_GCNO, \\\n","filename":"make\/Images.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-ifeq ($(HAS_SPEC),)\n+ifeq ($(HAS_SPEC), )\n@@ -171,1 +171,1 @@\n-        ifneq ($(findstring $(LOG_LEVEL),info debug trace),)\n+        ifneq ($(findstring $(LOG_LEVEL), info debug trace), )\n","filename":"make\/Init.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-ifeq ($(HAS_SPEC),)\n+ifeq ($(HAS_SPEC), )\n@@ -77,1 +77,1 @@\n-    build_dir=$(CUSTOM_ROOT)\/build\n+    build_dir = $(CUSTOM_ROOT)\/build\n@@ -79,1 +79,1 @@\n-    build_dir=$(topdir)\/build\n+    build_dir = $(topdir)\/build\n@@ -81,1 +81,1 @@\n-  all_spec_files=$(wildcard $(build_dir)\/*\/spec.gmk)\n+  all_spec_files = $(wildcard $(build_dir)\/*\/spec.gmk)\n@@ -83,1 +83,1 @@\n-  all_confs=$(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n+  all_confs = $(patsubst %\/spec.gmk, %, $(patsubst $(build_dir)\/%, %, $(all_spec_files)))\n@@ -131,1 +131,1 @@\n-    else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)),)\n+    else ifneq ($$(filter-out auto fail ignore, $$(CONF_CHECK)), )\n@@ -150,1 +150,1 @@\n-      ifeq ($$(wildcard $$(SPEC)),)\n+      ifeq ($$(wildcard $$(SPEC)), )\n@@ -154,1 +154,1 @@\n-      ifeq ($$(filter \/%, $$(SPEC)),)\n+      ifeq ($$(filter \/%, $$(SPEC)), )\n@@ -165,1 +165,1 @@\n-      ifeq ($$(all_spec_files),)\n+      ifeq ($$(all_spec_files), )\n@@ -183,1 +183,1 @@\n-        ifeq ($$(matching_conf),)\n+        ifeq ($$(matching_conf), )\n@@ -200,1 +200,1 @@\n-        ifeq ($$(CONF),)\n+        ifeq ($$(CONF), )\n@@ -205,1 +205,1 @@\n-          ifeq ($$(patsubst !%,,$$(CONF)),)\n+          ifeq ($$(patsubst !%,,$$(CONF)), )\n@@ -208,1 +208,1 @@\n-               $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n+                $$(if $$(findstring $$(subst !,,$$(CONF)), $$(var)), ,$$(var))))\n@@ -218,1 +218,1 @@\n-            ifeq ($$(MAKE_RESTARTS),)\n+            ifeq ($$(MAKE_RESTARTS), )\n@@ -223,1 +223,1 @@\n-        ifeq ($$(matching_confs),)\n+        ifeq ($$(matching_confs), )\n@@ -231,1 +231,1 @@\n-          ifeq ($$(MAKE_RESTARTS),)\n+          ifeq ($$(MAKE_RESTARTS), )\n@@ -233,1 +233,1 @@\n-              ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)\n+              ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n@@ -275,1 +275,1 @@\n-    ifeq ($$(MAKE_RESTARTS),)\n+    ifeq ($$(MAKE_RESTARTS), )\n@@ -319,1 +319,1 @@\n-    topdir=$(CUSTOM_ROOT)\n+    topdir = $(CUSTOM_ROOT)\n@@ -321,1 +321,1 @@\n-    topdir=$(TOPDIR)\n+    topdir = $(TOPDIR)\n@@ -352,1 +352,1 @@\n-            $$(eval COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n+            $$(eval COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(part)))) \\\n@@ -355,1 +355,1 @@\n-            $$(eval COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(part))))) \\\n@@ -358,1 +358,1 @@\n-            $$(eval COMPARE_BUILD_MAKE=$$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_MAKE = $$(strip $$(subst +, , $$(patsubst MAKE=%, %, $$(part))))) \\\n@@ -361,1 +361,1 @@\n-            $$(eval COMPARE_BUILD_COMP_OPTS=$$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_COMP_OPTS = $$(strip $$(subst +, , $$(patsubst COMP_OPTS=%, %, $$(part))))) \\\n@@ -364,1 +364,1 @@\n-            $$(eval COMPARE_BUILD_COMP_DIR=$$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_COMP_DIR = $$(strip $$(subst +, , $$(patsubst COMP_DIR=%, %, $$(part))))) \\\n@@ -367,1 +367,1 @@\n-            $$(eval COMPARE_BUILD_FAIL=$$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_FAIL = $$(strip $$(subst +, , $$(patsubst FAIL=%, %, $$(part))))) \\\n@@ -370,1 +370,1 @@\n-            $$(eval COMPARE_BUILD_NODRYRUN=$$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n+            $$(eval COMPARE_BUILD_NODRYRUN = $$(strip $$(subst +, , $$(patsubst NODRYRUN=%, %, $$(part))))) \\\n@@ -376,1 +376,1 @@\n-          COMPARE_BUILD_PATCH=$$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n+          COMPARE_BUILD_PATCH = $$(strip $$(patsubst PATCH=%, %, $$(COMPARE_BUILD)))\n@@ -378,1 +378,1 @@\n-          COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n+          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(patsubst CONF=%, %, $$(COMPARE_BUILD))))\n@@ -381,1 +381,1 @@\n-          COMPARE_BUILD_CONF=$$(strip $$(subst +, , $$(COMPARE_BUILD)))\n+          COMPARE_BUILD_CONF = $$(strip $$(subst +, , $$(COMPARE_BUILD)))\n@@ -384,1 +384,1 @@\n-          COMPARE_BUILD_PATCH=$$(strip $$(COMPARE_BUILD))\n+          COMPARE_BUILD_PATCH = $$(strip $$(COMPARE_BUILD))\n@@ -534,1 +534,1 @@\n-\t  sleep 5\\\n+\t  sleep 5 \\\n@@ -547,1 +547,1 @@\n-  BUILDTIMESDIR=$(OUTPUTDIR)\/make-support\/build-times\n+  BUILDTIMESDIR = $(OUTPUTDIR)\/make-support\/build-times\n@@ -608,1 +608,1 @@\n-  ifneq ($$(findstring $1, $$(LOG)),)\n+  ifneq ($$(findstring $1, $$(LOG)), )\n@@ -623,1 +623,1 @@\n-  ifneq ($$(findstring $1=, $$(LOG)),)\n+  ifneq ($$(findstring $1=, $$(LOG)), )\n@@ -676,1 +676,1 @@\n-  ifeq ($$(LOG_LEVEL),)\n+  ifeq ($$(LOG_LEVEL), )\n","filename":"make\/InitSupport.gmk","additions":36,"deletions":36,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+\n+include Execute.gmk\n@@ -34,2 +36,1 @@\n-# Use this file inside the image as target for make rule\n-JIMAGE_TARGET_FILE := bin\/java$(EXECUTABLE_SUFFIX)\n+INTERIM_JLINK_SUPPORT_DIR := $(SUPPORT_OUTPUTDIR)\/interim-image-jlink\n@@ -45,11 +46,12 @@\n-$(INTERIM_IMAGE_DIR)\/$(JIMAGE_TARGET_FILE): $(JMODS) \\\n-    $(call DependOnVariable, INTERIM_MODULES_LIST)\n-\t$(call LogWarn, Creating interim jimage)\n-\t$(RM) -r $(INTERIM_IMAGE_DIR)\n-\t$(JLINK_TOOL) \\\n-\t    --output $(INTERIM_IMAGE_DIR) \\\n-\t    --disable-plugin generate-jli-classes \\\n-\t    --add-modules $(INTERIM_MODULES_LIST)\n-\t$(TOUCH) $@\n-\n-TARGETS += $(INTERIM_IMAGE_DIR)\/$(JIMAGE_TARGET_FILE)\n+$(eval $(call SetupExecute, jlink_interim_image, \\\n+    WARN := Creating interim jimage, \\\n+    DEPS :=  $(JMODS) $(call DependOnVariable, INTERIM_MODULES_LIST), \\\n+    OUTPUT_DIR := $(INTERIM_IMAGE_DIR), \\\n+    SUPPORT_DIR := $(INTERIM_JLINK_SUPPORT_DIR), \\\n+    PRE_COMMAND := $(RM) -r $(INTERIM_IMAGE_DIR), \\\n+    COMMAND := $(JLINK_TOOL) --output $(INTERIM_IMAGE_DIR) \\\n+        --disable-plugin generate-jli-classes \\\n+        --add-modules $(INTERIM_MODULES_LIST), \\\n+))\n+\n+TARGETS += $(jlink_interim_image)\n","filename":"make\/InterimImage.gmk","additions":16,"deletions":14,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -70,1 +70,2 @@\n-    FILES := META-INF\/services\/java.nio.file.spi.FileSystemProvider))\n+    FILES := META-INF\/services\/java.nio.file.spi.FileSystemProvider, \\\n+))\n","filename":"make\/JrtfsJar.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-ifeq ($(wildcard $(SPEC)),)\n+ifeq ($(wildcard $(SPEC)), )\n@@ -281,0 +281,12 @@\n+$(eval $(call SetupTarget, hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := build, \\\n+    DEPS := hotspot compile-commands-hotspot jdk-image, \\\n+))\n+\n+$(eval $(call SetupTarget, open-hotspot-xcode-project, \\\n+    MAKEFILE := ide\/xcode\/hotspot\/CreateXcodeProject, \\\n+    TARGET := open, \\\n+    DEPS := hotspot-xcode-project, \\\n+))\n+\n@@ -1405,1 +1417,1 @@\n-\t$(if $(filter $(CONF_NAME),$(notdir $(OUTPUTDIR))), \\\n+\t$(if $(filter $(CONF_NAME), $(notdir $(OUTPUTDIR))), \\\n","filename":"make\/Main.gmk","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    ifeq ($(NO_RECIPES),)\n+    ifeq ($(NO_RECIPES), )\n@@ -200,2 +200,2 @@\n-  $(foreach i,2 3 4 5 6 7 8, $(if $(strip $($i)),$(strip $1)_$(strip $($i)))$(NEWLINE))\n-  $(if $(9),$(error Internal makefile error: Too many arguments to \\\n+  $(foreach i, 2 3 4 5 6 7 8, $(if $(strip $($i)),$(strip $1)_$(strip $($i)))$(NEWLINE))\n+  $(if $(9), $(error Internal makefile error: Too many arguments to \\\n","filename":"make\/MainSupport.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -107,1 +107,2 @@\n-      -timeoutHandlerTimeout:$(JTREG_FAILURE_HANDLER_TIMEOUT)\n+      -timeoutHandlerTimeout:$(JTREG_FAILURE_HANDLER_TIMEOUT) \\\n+      #\n@@ -503,1 +504,1 @@\n-    $1_GTEST_REPEAT :=--gtest_repeat=$$(GTEST_REPEAT)\n+    $1_GTEST_REPEAT := --gtest_repeat=$$(GTEST_REPEAT)\n@@ -751,2 +752,0 @@\n-  JTREG_TIMEOUT_FACTOR ?= 4\n-\n@@ -840,0 +839,18 @@\n+  JTREG_ALL_OPTIONS := $$(JTREG_JAVA_OPTIONS) $$(JTREG_VM_OPTIONS)\n+\n+  JTREG_AUTO_PROBLEM_LISTS :=\n+  JTREG_AUTO_TIMEOUT_FACTOR := 4\n+\n+  ifneq ($$(findstring -Xcomp, $$(JTREG_ALL_OPTIONS)), )\n+    JTREG_AUTO_PROBLEM_LISTS += ProblemList-Xcomp.txt\n+    JTREG_AUTO_TIMEOUT_FACTOR := 10\n+  endif\n+\n+  ifneq ($$(findstring -XX:+UseZGC, $$(JTREG_ALL_OPTIONS)), )\n+    ifneq ($$(findstring -XX:-ZGenerational, $$(JTREG_ALL_OPTIONS)), )\n+      JTREG_AUTO_PROBLEM_LISTS += ProblemList-zgc.txt\n+    else\n+      JTREG_AUTO_PROBLEM_LISTS += ProblemList-generational-zgc.txt\n+    endif\n+  endif\n+\n@@ -871,0 +888,12 @@\n+  # SetupRunJtregTestCustom might also adjust JTREG_AUTO_ variables\n+  # so set the final results after setting values from custom setup\n+  ifneq ($$(JTREG_AUTO_PROBLEM_LISTS), )\n+    # Accept both absolute paths as well as relative to the current test root.\n+    $1_JTREG_BASIC_OPTIONS += $$(addprefix $$(JTREG_PROBLEM_LIST_PREFIX), $$(wildcard \\\n+        $$(JTREG_AUTO_PROBLEM_LISTS) \\\n+        $$(addprefix $$($1_TEST_ROOT)\/, $$(JTREG_AUTO_PROBLEM_LISTS)) \\\n+    ))\n+  endif\n+\n+  JTREG_TIMEOUT_FACTOR ?= $$(JTREG_AUTO_TIMEOUT_FACTOR)\n+\n","filename":"make\/RunTests.gmk","additions":34,"deletions":5,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-ifeq ($(filter \/%, $(lastword $(MAKEFILE_LIST))),)\n+ifeq ($(filter \/%, $(lastword $(MAKEFILE_LIST))), )\n@@ -70,1 +70,1 @@\n-      $1:=$2\n+      $1 := $2\n@@ -166,1 +166,1 @@\n-  OPENJDK_TARGET_OS_TYPE:=unix\n+  OPENJDK_TARGET_OS_TYPE := unix\n","filename":"make\/RunTestsPrebuilt.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,3 +73,3 @@\n-X:=\n-SPACE:=$(X) $(X)\n-COMMA:=,\n+X :=\n+SPACE := $(X) $(X)\n+COMMA := ,\n","filename":"make\/RunTestsPrebuiltSpec.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    $(if $(wildcard $(TOPDIR)\/$(repo)\/$(SCM_DIR)),, \\\n+    $(if $(wildcard $(TOPDIR)\/$(repo)\/$(SCM_DIR)), , \\\n@@ -75,1 +75,1 @@\n-  ################################################################################\n+  ##############################################################################\n","filename":"make\/SourceRevision.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  IMAGE_DEST_DIR=$(STATIC_LIBS_IMAGE_DIR)\/lib\n+  IMAGE_DEST_DIR = $(STATIC_LIBS_IMAGE_DIR)\/lib\n@@ -46,1 +46,1 @@\n-  IMAGE_DEST_DIR=$(STATIC_LIBS_GRAAL_IMAGE_DIR)\/lib\n+  IMAGE_DEST_DIR = $(STATIC_LIBS_GRAAL_IMAGE_DIR)\/lib\n","filename":"make\/StaticLibsImage.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-############################################################################\n+################################################################################\n","filename":"make\/TestImage.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ToolsHotspot.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -131,1 +131,1 @@\n-##########################################################################################\n+################################################################################\n@@ -138,1 +138,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ToolsJdk.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-##########################################################################################\n+################################################################################\n@@ -36,1 +36,1 @@\n-$(eval $(call SetupZipArchive,BUILD_SEC_BIN_ZIP, \\\n+$(eval $(call SetupZipArchive, BUILD_SEC_BIN_ZIP, \\\n@@ -63,1 +63,2 @@\n-    ZIP := $(IMAGES_OUTPUTDIR)\/sec-bin.zip))\n+    ZIP := $(IMAGES_OUTPUTDIR)\/sec-bin.zip, \\\n+))\n@@ -67,1 +68,1 @@\n-##########################################################################################\n+################################################################################\n@@ -73,1 +74,1 @@\n-  $(eval $(call SetupZipArchive,BUILD_SEC_WINDOWS_BIN_ZIP, \\\n+  $(eval $(call SetupZipArchive, BUILD_SEC_WINDOWS_BIN_ZIP, \\\n@@ -76,1 +77,2 @@\n-      ZIP := $(IMAGES_OUTPUTDIR)\/sec-windows-bin.zip))\n+      ZIP := $(IMAGES_OUTPUTDIR)\/sec-windows-bin.zip, \\\n+  ))\n@@ -87,1 +89,1 @@\n-  $(eval $(call SetupZipArchive,BUILD_JGSS_BIN_ZIP, \\\n+  $(eval $(call SetupZipArchive, BUILD_JGSS_BIN_ZIP, \\\n@@ -93,1 +95,2 @@\n-      ZIP := $(IMAGES_OUTPUTDIR)\/$(JGSS_ZIP_NAME)))\n+      ZIP := $(IMAGES_OUTPUTDIR)\/$(JGSS_ZIP_NAME), \\\n+  ))\n@@ -98,1 +101,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/ZipSecurity.gmk","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-SPEC:=@OUTPUTDIR@\/spec.gmk\n+SPEC := @OUTPUTDIR@\/spec.gmk\n","filename":"make\/autoconf\/Makefile.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-###############################################################################\n+################################################################################\n@@ -49,1 +49,1 @@\n-###############################################################################\n+################################################################################\n@@ -61,1 +61,1 @@\n-###############################################################################\n+################################################################################\n@@ -105,1 +105,1 @@\n-###############################################################################\n+################################################################################\n@@ -144,1 +144,1 @@\n-###############################################################################\n+################################################################################\n@@ -154,1 +154,1 @@\n-###############################################################################\n+################################################################################\n@@ -164,1 +164,1 @@\n-###############################################################################\n+################################################################################\n@@ -249,1 +249,1 @@\n-###############################################################################\n+################################################################################\n@@ -383,1 +383,1 @@\n-###############################################################################\n+################################################################################\n@@ -480,1 +480,1 @@\n-###############################################################################\n+################################################################################\n@@ -517,1 +517,1 @@\n-###############################################################################\n+################################################################################\n@@ -532,1 +532,1 @@\n-###############################################################################\n+################################################################################\n@@ -575,1 +575,1 @@\n-###############################################################################\n+################################################################################\n@@ -594,1 +594,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/basic.m4","additions":14,"deletions":14,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -31,1 +31,1 @@\n-###############################################################################\n+################################################################################\n@@ -62,1 +62,1 @@\n-###############################################################################\n+################################################################################\n@@ -119,1 +119,1 @@\n-###############################################################################\n+################################################################################\n@@ -132,1 +132,1 @@\n-   else\n+  else\n@@ -179,1 +179,1 @@\n-###############################################################################\n+################################################################################\n@@ -204,1 +204,1 @@\n-###############################################################################\n+################################################################################\n@@ -252,1 +252,1 @@\n-###############################################################################\n+################################################################################\n@@ -281,1 +281,1 @@\n-###############################################################################\n+################################################################################\n@@ -319,1 +319,1 @@\n-###############################################################################\n+################################################################################\n@@ -343,1 +343,1 @@\n-###############################################################################\n+################################################################################\n@@ -415,1 +415,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/basic_tools.m4","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-########################################################################\n+################################################################################\n@@ -52,1 +52,1 @@\n-########################################################################\n+################################################################################\n@@ -325,1 +325,1 @@\n-###############################################################################\n+################################################################################\n@@ -605,5 +605,6 @@\n-       if test \"x$with_build_jdk\" != x; then\n-         BUILD_JDK=$with_build_jdk\n-         BUILD_JDK_FOUND=maybe\n-         AC_MSG_NOTICE([Found potential Build JDK using configure arguments])\n-       fi])\n+      if test \"x$with_build_jdk\" != x; then\n+        BUILD_JDK=$with_build_jdk\n+        BUILD_JDK_FOUND=maybe\n+        AC_MSG_NOTICE([Found potential Build JDK using configure arguments])\n+      fi\n+    ])\n","filename":"make\/autoconf\/boot-jdk.m4","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -37,2 +37,2 @@\n-OLD_OUTPUTDIR:=@OUTPUTDIR@\n-OUTPUTDIR:=$(OLD_OUTPUTDIR)\/bootcycle-build\n+OLD_OUTPUTDIR := @OUTPUTDIR@\n+OUTPUTDIR := $(OLD_OUTPUTDIR)\/bootcycle-build\n@@ -40,1 +40,1 @@\n-JAVAC_SERVER_DIR:=$(patsubst $(OLD_OUTPUTDIR)%,$(OUTPUTDIR)%,$(JAVAC_SERVER_DIR))\n+JAVAC_SERVER_DIR := $(patsubst $(OLD_OUTPUTDIR)%,$(OUTPUTDIR)%,$(JAVAC_SERVER_DIR))\n@@ -51,1 +51,0 @@\n-\n","filename":"make\/autoconf\/bootcycle-spec.gmk.template","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/autoconf\/compare.sh.template","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -30,1 +30,1 @@\n-###############################################################################\n+################################################################################\n@@ -66,1 +66,1 @@\n-###############################################################################\n+################################################################################\n@@ -73,1 +73,1 @@\n-###############################################################################\n+################################################################################\n@@ -131,1 +131,1 @@\n-###############################################################################\n+################################################################################\n@@ -135,1 +135,1 @@\n-###############################################################################\n+################################################################################\n@@ -142,1 +142,1 @@\n-###############################################################################\n+################################################################################\n@@ -146,1 +146,1 @@\n-###############################################################################\n+################################################################################\n@@ -152,1 +152,1 @@\n-###############################################################################\n+################################################################################\n@@ -156,1 +156,1 @@\n-###############################################################################\n+################################################################################\n@@ -161,1 +161,1 @@\n-###############################################################################\n+################################################################################\n@@ -165,1 +165,1 @@\n-###############################################################################\n+################################################################################\n@@ -170,1 +170,1 @@\n-###############################################################################\n+################################################################################\n@@ -175,1 +175,1 @@\n-###############################################################################\n+################################################################################\n@@ -230,1 +230,1 @@\n-###############################################################################\n+################################################################################\n@@ -234,1 +234,1 @@\n-###############################################################################\n+################################################################################\n@@ -239,1 +239,1 @@\n-###############################################################################\n+################################################################################\n@@ -243,1 +243,1 @@\n-###############################################################################\n+################################################################################\n@@ -250,1 +250,1 @@\n-###############################################################################\n+################################################################################\n@@ -254,1 +254,1 @@\n-###############################################################################\n+################################################################################\n@@ -266,1 +266,1 @@\n-###############################################################################\n+################################################################################\n@@ -271,1 +271,1 @@\n-###############################################################################\n+################################################################################\n@@ -291,1 +291,1 @@\n-###############################################################################\n+################################################################################\n@@ -295,1 +295,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/configure.ac","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -238,3 +238,3 @@\n-      WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wsign-compare \\\n-          -Wunused-function -Wundef -Wunused-value -Wreturn-type \\\n-          -Wtrampolines\"\n+      WARNINGS_ENABLE_ADDITIONAL=\"-Wpointer-arith -Wreturn-type -Wsign-compare \\\n+          -Wtrampolines -Wundef -Wunused-const-variable=1 -Wunused-function \\\n+          -Wunused-result -Wunused-value\"\n@@ -245,1 +245,3 @@\n-      DISABLED_WARNINGS=\"unused-parameter unused\"\n+      # These warnings will never be turned on, since they generate too many\n+      # false positives.\n+      DISABLED_WARNINGS=\"unused-parameter\"\n@@ -262,1 +264,3 @@\n-      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter unused\"\n+      # These warnings will never be turned on, since they generate too many\n+      # false positives.\n+      DISABLED_WARNINGS=\"unknown-warning-option unused-parameter\"\n@@ -479,1 +483,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -513,1 +517,1 @@\n-  ###############################################################################\n+  ##############################################################################\n","filename":"make\/autoconf\/flags-cflags.m4","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -74,0 +74,1 @@\n+      # Clang needs the lld linker to work correctly\n@@ -75,0 +76,1 @@\n+      UTIL_REQUIRE_PROGS(LLD, lld)\n@@ -169,3 +171,3 @@\n-       test \"x${OPENJDK_$1_CPU}\" = xmipsel ||\n-       test \"x${OPENJDK_$1_CPU}\" = xmips64 ||\n-       test \"x${OPENJDK_$1_CPU}\" = xmips64el; then\n+        test \"x${OPENJDK_$1_CPU}\" = xmipsel ||\n+        test \"x${OPENJDK_$1_CPU}\" = xmips64 ||\n+        test \"x${OPENJDK_$1_CPU}\" = xmips64el; then\n","filename":"make\/autoconf\/flags-ldflags.m4","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-###############################################################################\n+################################################################################\n@@ -41,1 +41,1 @@\n-###############################################################################\n+################################################################################\n@@ -105,1 +105,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/hotspot.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -84,1 +84,1 @@\n-###############################################################################\n+################################################################################\n@@ -238,2 +238,2 @@\n-         test \"x$OPENJDK_TARGET_OS\" != \"xbsd\" &&\n-         test \"x$OPENJDK_TARGET_OS\" != \"xaix\"; then\n+        test \"x$OPENJDK_TARGET_OS\" != \"xbsd\" &&\n+        test \"x$OPENJDK_TARGET_OS\" != \"xaix\"; then\n@@ -249,1 +249,1 @@\n-###############################################################################\n+################################################################################\n@@ -413,1 +413,1 @@\n-###############################################################################\n+################################################################################\n@@ -424,2 +424,2 @@\n-           test \"x$TOOLCHAIN_TYPE\" = \"xclang\" ||\n-           test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\" ||\n+            test \"x$TOOLCHAIN_TYPE\" = \"xmicrosoft\"; then\n@@ -434,1 +434,1 @@\n-           test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n+            test \"x$TOOLCHAIN_TYPE\" = \"xclang\"; then\n@@ -470,1 +470,1 @@\n-###############################################################################\n+################################################################################\n@@ -503,1 +503,1 @@\n-###############################################################################\n+################################################################################\n@@ -710,3 +710,2 @@\n-       [Set to disable to prevent any absolute paths from the build to end up in\n-        any of the build output. @<:@disabled in release builds, otherwise enabled@:>@])\n-      ])\n+      [Set to disable to prevent any absolute paths from the build to end up in\n+      any of the build output. @<:@disabled in release builds, otherwise enabled@:>@])])\n","filename":"make\/autoconf\/jdk-options.m4","additions":13,"deletions":14,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -96,1 +96,1 @@\n-       properties of MS Windows binaries.],\n+        properties of MS Windows binaries.],\n@@ -108,1 +108,1 @@\n-       and 'java.vm.vendor' system properties.],\n+        and 'java.vm.vendor' system properties.],\n","filename":"make\/autoconf\/jdk-version.m4","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -39,1 +39,1 @@\n-###############################################################################\n+################################################################################\n@@ -81,1 +81,1 @@\n-###############################################################################\n+################################################################################\n@@ -202,1 +202,1 @@\n-###############################################################################\n+################################################################################\n@@ -228,1 +228,1 @@\n-###############################################################################\n+################################################################################\n@@ -244,1 +244,1 @@\n-###############################################################################\n+################################################################################\n@@ -273,1 +273,1 @@\n-###############################################################################\n+################################################################################\n@@ -293,1 +293,1 @@\n-###############################################################################\n+################################################################################\n@@ -312,1 +312,1 @@\n-###############################################################################\n+################################################################################\n@@ -368,1 +368,1 @@\n-###############################################################################\n+################################################################################\n@@ -386,1 +386,1 @@\n-###############################################################################\n+################################################################################\n@@ -434,1 +434,1 @@\n-###############################################################################\n+################################################################################\n@@ -482,1 +482,1 @@\n-###############################################################################\n+################################################################################\n@@ -492,1 +492,1 @@\n-###############################################################################\n+################################################################################\n@@ -530,1 +530,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/jvm-features.m4","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -122,1 +122,1 @@\n-     [use libpng from build system or OpenJDK source (system, bundled) @<:@bundled@:>@])])\n+      [use libpng from build system or OpenJDK source (system, bundled) @<:@bundled@:>@])])\n","filename":"make\/autoconf\/lib-bundled.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -76,5 +76,5 @@\n-       The selected option applies to both build time and run time.\n-       The default behaviour can be platform dependent.\n-       If using 'system' and either the include files or libraries cannot be\n-       located automatically, then additionally specify both using\n-       --with-freetype-include and --with-freetype-lib.])])\n+      The selected option applies to both build time and run time.\n+      The default behaviour can be platform dependent.\n+      If using 'system' and either the include files or libraries cannot be\n+      located automatically, then additionally specify both using\n+      --with-freetype-include and --with-freetype-lib.])])\n@@ -98,2 +98,4 @@\n-  if (test \"x$with_freetype_include\" = \"x\" && test \"x$with_freetype_lib\" != \"x\") || \\\n-     (test \"x$with_freetype_include\" != \"x\" && test \"x$with_freetype_lib\" = \"x\"); then\n+  if (test \"x$with_freetype_include\" = \"x\" && \\\n+      test \"x$with_freetype_lib\" != \"x\") || \\\n+      (test \"x$with_freetype_include\" != \"x\" && \\\n+      test \"x$with_freetype_lib\" = \"x\"); then\n@@ -129,2 +131,2 @@\n-     (test \"x$OPENJDK_TARGET_OS\" = \"xwindows\" || \\\n-     test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\"); then\n+      (test \"x$OPENJDK_TARGET_OS\" = \"xwindows\" || \\\n+      test \"x$OPENJDK_TARGET_OS\" = \"xmacosx\"); then\n","filename":"make\/autoconf\/lib-freetype.m4","additions":11,"deletions":9,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -166,2 +166,2 @@\n-     test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n-     test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n+      test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+      test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a; then\n@@ -270,2 +270,4 @@\n-       test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n-       (test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a || test -e $BINUTILS_INSTALL_DIR\/lib64\/libiberty.a || test -e $BINUTILS_INSTALL_DIR\/lib32\/libiberty.a); then\n+        test -e $BINUTILS_INSTALL_DIR\/lib\/libopcodes.a && \\\n+        (test -e $BINUTILS_INSTALL_DIR\/lib\/libiberty.a || \\\n+        test -e $BINUTILS_INSTALL_DIR\/lib64\/libiberty.a || \\\n+        test -e $BINUTILS_INSTALL_DIR\/lib32\/libiberty.a); then\n","filename":"make\/autoconf\/lib-hsdis.m4","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-###############################################################################\n+################################################################################\n@@ -77,1 +77,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/lib-tests.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -102,6 +102,6 @@\n-         test \"x$OPENJDK_$1_CPU\" = xm68k ||\n-         test \"x$OPENJDK_$1_CPU\" = xmips ||\n-         test \"x$OPENJDK_$1_CPU\" = xmipsel ||\n-         test \"x$OPENJDK_$1_CPU\" = xppc ||\n-         test \"x$OPENJDK_$1_CPU\" = xsh ||\n-         test \"x$OPENJDK_$1_CPU\" = xriscv32); then\n+        test \"x$OPENJDK_$1_CPU\" = xm68k ||\n+        test \"x$OPENJDK_$1_CPU\" = xmips ||\n+        test \"x$OPENJDK_$1_CPU\" = xmipsel ||\n+        test \"x$OPENJDK_$1_CPU\" = xppc ||\n+        test \"x$OPENJDK_$1_CPU\" = xsh ||\n+        test \"x$OPENJDK_$1_CPU\" = xriscv32); then\n","filename":"make\/autoconf\/libraries.m4","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -393,1 +393,1 @@\n-       [build 32-bit or 64-bit binaries (for platforms that support it), e.g. --with-target-bits=32 @<:@guessed@:>@])])\n+      [build 32-bit or 64-bit binaries (for platforms that support it), e.g. --with-target-bits=32 @<:@guessed@:>@])])\n@@ -668,1 +668,1 @@\n-       [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n+      [Suppress the error when configuring for a deprecated port @<:@no@:>@])])\n@@ -681,1 +681,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -696,1 +696,1 @@\n-  ###############################################################################\n+  ##############################################################################\n@@ -742,1 +742,1 @@\n-  ###############################################################################\n+  ##############################################################################\n","filename":"make\/autoconf\/platform.m4","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -275,1 +275,1 @@\n-ifneq ($(COMPANY_NAME),)\n+ifneq ($(COMPANY_NAME), )\n@@ -291,1 +291,1 @@\n-ifneq ($(VENDOR_URL),)\n+ifneq ($(VENDOR_URL), )\n@@ -294,1 +294,1 @@\n-ifneq ($(VENDOR_URL_BUG),)\n+ifneq ($(VENDOR_URL_BUG), )\n@@ -297,1 +297,1 @@\n-ifneq ($(VENDOR_URL_VM_BUG),)\n+ifneq ($(VENDOR_URL_VM_BUG), )\n@@ -807,2 +807,0 @@\n-####################################################\n-#\n@@ -810,2 +808,0 @@\n-#\n-\n@@ -824,2 +820,0 @@\n-####################################################\n-#\n@@ -827,2 +821,0 @@\n-#\n-\n","filename":"make\/autoconf\/spec.gmk.template","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-########################################################################\n+################################################################################\n@@ -33,1 +33,1 @@\n-########################################################################\n+################################################################################\n@@ -681,0 +681,3 @@\n+        AC_MSG_NOTICE([A full XCode is required to build the JDK (not only command line tools)])\n+        AC_MSG_NOTICE([If you have XCode installed, you might need to reset the Xcode active developer directory])\n+        AC_MSG_NOTICE([using 'sudo xcode-select -r'])\n","filename":"make\/autoconf\/toolchain.m4","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -164,1 +164,1 @@\n-       pass to vcvarsall.bat (Windows only)])])\n+      pass to vcvarsall.bat (Windows only)])])\n","filename":"make\/autoconf\/toolchain_microsoft.m4","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,1 +28,1 @@\n-###############################################################################\n+################################################################################\n@@ -103,1 +103,1 @@\n-###############################################################################\n+################################################################################\n@@ -124,1 +124,1 @@\n-###############################################################################\n+################################################################################\n@@ -140,1 +140,1 @@\n-###############################################################################\n+################################################################################\n@@ -156,1 +156,1 @@\n-###############################################################################\n+################################################################################\n@@ -168,1 +168,1 @@\n-###############################################################################\n+################################################################################\n@@ -180,1 +180,1 @@\n-###############################################################################\n+################################################################################\n@@ -207,1 +207,1 @@\n-###############################################################################\n+################################################################################\n@@ -234,1 +234,1 @@\n-###############################################################################\n+################################################################################\n@@ -262,1 +262,1 @@\n-###############################################################################\n+################################################################################\n@@ -276,1 +276,1 @@\n-###############################################################################\n+################################################################################\n@@ -297,1 +297,1 @@\n-###############################################################################\n+################################################################################\n@@ -307,1 +307,1 @@\n-###############################################################################\n+################################################################################\n@@ -317,1 +317,1 @@\n-###############################################################################\n+################################################################################\n@@ -332,1 +332,1 @@\n-###############################################################################\n+################################################################################\n@@ -474,1 +474,1 @@\n-###############################################################################\n+################################################################################\n@@ -578,1 +578,1 @@\n-###############################################################################\n+################################################################################\n@@ -813,1 +813,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/util.m4","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-###############################################################################\n+################################################################################\n@@ -39,1 +39,1 @@\n-###############################################################################\n+################################################################################\n@@ -52,1 +52,1 @@\n-###############################################################################\n+################################################################################\n@@ -121,1 +121,1 @@\n-##############################################################################\n+################################################################################\n@@ -139,1 +139,1 @@\n-###############################################################################\n+################################################################################\n@@ -173,1 +173,1 @@\n-###############################################################################\n+################################################################################\n@@ -292,1 +292,1 @@\n-###############################################################################\n+################################################################################\n@@ -372,1 +372,1 @@\n-###############################################################################\n+################################################################################\n@@ -439,1 +439,1 @@\n-###############################################################################\n+################################################################################\n@@ -455,1 +455,1 @@\n-###############################################################################\n+################################################################################\n@@ -465,1 +465,1 @@\n-###############################################################################\n+################################################################################\n@@ -476,1 +476,1 @@\n-###############################################################################\n+################################################################################\n@@ -488,1 +488,1 @@\n-###############################################################################\n+################################################################################\n@@ -500,1 +500,1 @@\n-###############################################################################\n+################################################################################\n@@ -513,1 +513,1 @@\n-###############################################################################\n+################################################################################\n","filename":"make\/autoconf\/util_paths.m4","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n","filename":"make\/common\/CopyFiles.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n","filename":"make\/common\/Execute.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -139,0 +139,1 @@\n+          $(CHMOD) u+w '$(call DecodeSpace, $@)'; \\\n@@ -191,0 +192,5 @@\n+define copy-and-chmod-executable\n+\t$(install-file)\n+\t$(CHMOD) a+rx $@\n+endef\n+\n@@ -284,1 +290,1 @@\n-    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%,\\\n+    $(eval CacheFindFiles_NEW_DIRS := $$(filter-out $$(addsuffix \/%, \\\n","filename":"make\/common\/FileUtils.gmk","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-   ) \\\n+  ) \\\n","filename":"make\/common\/FindTests.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -35,1 +35,1 @@\n-FALSE_FIND_PATTERN:=-name FILE_NAME_THAT_DOESNT_EXIST\n+FALSE_FIND_PATTERN := -name FILE_NAME_THAT_DOESNT_EXIST\n@@ -43,1 +43,1 @@\n-#   DEPENDENCIES:=List of dependencies for the jar target. If left empty,\n+#   DEPENDENCIES List of dependencies for the jar target. If left empty,\n@@ -47,12 +47,12 @@\n-#   SRCS:=List of directories in where to find files to add to archive\n-#   BIN:=Directory where to store build control files\n-#   SUFFIXES:=File suffixes to include in jar\n-#   INCLUDES:=List of directories\/packages in SRCS that should be included\n-#   EXCLUDES:=List of directories\/packages in SRCS that should be excluded\n-#   EXCLUDE_FILES:=List of files in SRCS that should be excluded\n-#   EXTRA_FILES:=List of files in SRCS that should be included regardless of suffix match.\n-#   JAR:=Jar file to create\n-#   MANIFEST:=Optional manifest file template.\n-#   JARMAIN:=Optional main class to add to manifest\n-#   JARINDEX:=true means generate the index in the jar file.\n-#   SKIP_METAINF:=Set to prevent contents of an META-INF directory to be automatically\n+#   SRCS List of directories in where to find files to add to archive\n+#   BIN Directory where to store build control files\n+#   SUFFIXES File suffixes to include in jar\n+#   INCLUDES List of directories\/packages in SRCS that should be included\n+#   EXCLUDES List of directories\/packages in SRCS that should be excluded\n+#   EXCLUDE_FILES List of files in SRCS that should be excluded\n+#   EXTRA_FILES List of files in SRCS that should be included regardless of suffix match.\n+#   JAR Jar file to create\n+#   MANIFEST Optional manifest file template.\n+#   JARMAIN Optional main class to add to manifest\n+#   JARINDEX true means generate the index in the jar file.\n+#   SKIP_METAINF Set to prevent contents of an META-INF directory to be automatically\n@@ -60,1 +60,1 @@\n-#   EXTRA_MANIFEST_ATTR:=Extra attribute to add to manifest.\n+#   EXTRA_MANIFEST_ATTR Extra attribute to add to manifest.\n@@ -62,1 +62,1 @@\n-#   JAR_CMD:=Optionally override the jar command to use when creating the archive.\n+#   JAR_CMD Optionally override the jar command to use when creating the archive.\n@@ -66,2 +66,2 @@\n-  $1_JARMAIN:=$(strip $$($1_JARMAIN))\n-  $1_JARNAME:=$$(notdir $$($1_JAR))\n+  $1_JARMAIN := $(strip $$($1_JARMAIN))\n+  $1_JARNAME := $$(notdir $$($1_JAR))\n@@ -70,3 +70,3 @@\n-  $1_MANIFEST_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_manifest\n-  $1_DELETESS_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_deletess\n-  $1_DELETES_FILE:=$$($1_BIN)\/_the.$$($1_JARNAME)_deletes\n+  $1_MANIFEST_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_manifest\n+  $1_DELETESS_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_deletess\n+  $1_DELETES_FILE := $$($1_BIN)\/_the.$$($1_JARNAME)_deletes\n@@ -75,1 +75,1 @@\n-  ifeq (,$$($1_SUFFIXES))\n+  ifeq ($$($1_SUFFIXES), )\n@@ -77,1 +77,1 @@\n-    $1_SUFFIXES:=.class\n+    $1_SUFFIXES := .class\n@@ -80,1 +80,1 @@\n-  $1_FIND_PATTERNS:=$(FALSE_FIND_PATTERN) $$(patsubst %,$(SPACE)-o$(SPACE)-name$(SPACE)$(DQUOTE)*%$(DQUOTE),$$($1_SUFFIXES))\n+  $1_FIND_PATTERNS := $(FALSE_FIND_PATTERN) $$(patsubst %,$(SPACE)-o$(SPACE)-name$(SPACE)$(DQUOTE)*%$(DQUOTE),$$($1_SUFFIXES))\n@@ -84,2 +84,2 @@\n-  ifneq (,$$($1_INCLUDES))\n-    $1_GREP_INCLUDE_PATTERNS:=$$(call EscapeDollar, \\\n+  ifneq ($$($1_INCLUDES), )\n+    $1_GREP_INCLUDE_PATTERNS := $$(call EscapeDollar, \\\n@@ -88,2 +88,2 @@\n-    ifeq ($$(word 20,$$($1_GREP_INCLUDE_PATTERNS)),)\n-      $1_GREP_INCLUDES:=| ( $(GREP) $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_INCLUDE_PATTERNS)) \\\n+    ifeq ($$(word 20, $$($1_GREP_INCLUDE_PATTERNS)), )\n+      $1_GREP_INCLUDES := | ( $(GREP) $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_INCLUDE_PATTERNS)) \\\n@@ -93,1 +93,1 @@\n-          $$(eval $$(call ListPathsSafely,$1_GREP_INCLUDE_PATTERNS, \\\n+          $$(eval $$(call ListPathsSafely, $1_GREP_INCLUDE_PATTERNS, \\\n@@ -95,1 +95,1 @@\n-      $1_GREP_INCLUDES:=| ( $(GREP) -f $$($1_BIN)\/_the.$$($1_JARNAME)_include \\\n+      $1_GREP_INCLUDES := | ( $(GREP) -f $$($1_BIN)\/_the.$$($1_JARNAME)_include \\\n@@ -99,3 +99,3 @@\n-  ifneq (,$$($1_EXCLUDES)$$($1_EXCLUDE_FILES))\n-    $1_GREP_EXCLUDE_PATTERNS:=$$(call EscapeDollar, \\\n-        $$(foreach src,$$($1_SRCS),$$(addprefix $$(src)\/, \\\n+  ifneq ($$($1_EXCLUDES)$$($1_EXCLUDE_FILES), )\n+    $1_GREP_EXCLUDE_PATTERNS := $$(call EscapeDollar, \\\n+        $$(foreach src, $$($1_SRCS), $$(addprefix $$(src)\/, \\\n@@ -104,2 +104,2 @@\n-    ifeq ($$(word 20,$$($1_GREP_EXCLUDE_PATTERNS)),)\n-      $1_GREP_EXCLUDES:=| ( $(GREP) -v $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_EXCLUDE_PATTERNS)) \\\n+    ifeq ($$(word 20, $$($1_GREP_EXCLUDE_PATTERNS)), )\n+      $1_GREP_EXCLUDES := | ( $(GREP) -v $$(patsubst %,$(SPACE)-e$(SPACE)$(DQUOTE)%$(DQUOTE),$$($1_GREP_EXCLUDE_PATTERNS)) \\\n@@ -109,1 +109,1 @@\n-          $$(eval $$(call ListPathsSafely,$1_GREP_EXCLUDE_PATTERNS, \\\n+          $$(eval $$(call ListPathsSafely, $1_GREP_EXCLUDE_PATTERNS, \\\n@@ -111,1 +111,1 @@\n-      $1_GREP_EXCLUDES:=| ( $(GREP) -v -f $$($1_BIN)\/_the.$$($1_JARNAME)_exclude \\\n+      $1_GREP_EXCLUDES := | ( $(GREP) -v -f $$($1_BIN)\/_the.$$($1_JARNAME)_exclude \\\n@@ -117,1 +117,1 @@\n-  ifneq (,$$($1_JARINDEX))\n+  ifneq ($$($1_JARINDEX), )\n@@ -130,4 +130,4 @@\n-    $1_DEPENDENCIES:=$$(filter $$(addprefix %,$$($1_SUFFIXES)), \\\n-        $$(call FindFiles,$$($1_SRCS)))\n-    ifneq (,$$($1_GREP_INCLUDE_PATTERNS))\n-      $1_DEPENDENCIES:=$$(filter $$(addsuffix %,$$($1_GREP_INCLUDE_PATTERNS)),$$($1_DEPENDENCIES))\n+    $1_DEPENDENCIES := $$(filter $$(addprefix %, $$($1_SUFFIXES)), \\\n+        $$(call FindFiles, $$($1_SRCS)))\n+    ifneq ($$($1_GREP_INCLUDE_PATTERNS), )\n+      $1_DEPENDENCIES := $$(filter $$(addsuffix %, $$($1_GREP_INCLUDE_PATTERNS)), $$($1_DEPENDENCIES))\n@@ -135,2 +135,2 @@\n-    ifneq (,$$($1_GREP_EXCLUDE_PATTERNS))\n-      $1_DEPENDENCIES:=$$(filter-out $$(addsuffix %,$$($1_GREP_EXCLUDE_PATTERNS)),$$($1_DEPENDENCIES))\n+    ifneq ($$($1_GREP_EXCLUDE_PATTERNS), )\n+      $1_DEPENDENCIES := $$(filter-out $$(addsuffix %, $$($1_GREP_EXCLUDE_PATTERNS)), $$($1_DEPENDENCIES))\n@@ -139,1 +139,1 @@\n-    $1_DEPENDENCIES+=$$(wildcard $$(foreach src, $$($1_SRCS), \\\n+    $1_DEPENDENCIES += $$(wildcard $$(foreach src, $$($1_SRCS), \\\n@@ -141,2 +141,2 @@\n-    ifeq (,$$($1_SKIP_METAINF))\n-      $1_DEPENDENCIES+=$$(call FindFiles,$$(wildcard $$(addsuffix \/META-INF,$$($1_SRCS))))\n+    ifeq ($$($1_SKIP_METAINF), )\n+      $1_DEPENDENCIES += $$(call FindFiles, $$(wildcard $$(addsuffix \/META-INF, $$($1_SRCS))))\n@@ -159,2 +159,2 @@\n-  $1_CAPTURE_EXTRA_FILES=\\\n-      $$(eval $1_EXTRA_FILES_RESOLVED:=$$(call DoubleDollar, \\\n+  $1_CAPTURE_EXTRA_FILES = \\\n+      $$(eval $1_EXTRA_FILES_RESOLVED := $$(call DoubleDollar, \\\n@@ -164,1 +164,1 @@\n-        $$(eval $$(call ListPathsSafely,$1_EXTRA_FILES_RESOLVED, \\\n+        $$(eval $$(call ListPathsSafely, $1_EXTRA_FILES_RESOLVED, \\\n@@ -166,1 +166,1 @@\n-        $(SED) $$(foreach src,$$($1_SRCS), -e 's|$$(src)\/|-C $$(src) |g') \\\n+        $(SED) $$(foreach src, $$($1_SRCS), -e 's|$$(src)\/|-C $$(src) |g') \\\n@@ -173,1 +173,1 @@\n-  $1_CAPTURE_CONTENTS=\\\n+  $1_CAPTURE_CONTENTS = \\\n@@ -175,1 +175,1 @@\n-      $$(foreach src,$$($1_SRCS), \\\n+      $$(foreach src, $$($1_SRCS), \\\n@@ -183,2 +183,2 @@\n-  ifeq (,$$($1_SKIP_METAINF))\n-    $1_CAPTURE_METAINF =$$(foreach src,$$($1_SRCS), \\\n+  ifeq ($$($1_SKIP_METAINF), )\n+    $1_CAPTURE_METAINF = $$(foreach src, $$($1_SRCS), \\\n@@ -191,1 +191,1 @@\n-  $1_CAPTURE_DELETES=$$(foreach src,$$($1_SRCS),($(FIND) $$(src) -name _the.package.deleted -newer $$@ \\\n+  $1_CAPTURE_DELETES = $$(foreach src, $$($1_SRCS), ($(FIND) $$(src) -name _the.package.deleted -newer $$@ \\\n@@ -195,1 +195,1 @@\n-  $1_UPDATE_CONTENTS=\\\n+  $1_UPDATE_CONTENTS = \\\n@@ -203,1 +203,1 @@\n-  $1_SCAPTURE_CONTENTS=\\\n+  $1_SCAPTURE_CONTENTS = \\\n@@ -205,1 +205,1 @@\n-      $$(foreach src,$$($1_SRCS), \\\n+      $$(foreach src, $$($1_SRCS), \\\n@@ -212,2 +212,2 @@\n-  ifeq (,$$($1_SKIP_METAINF))\n-    $1_SCAPTURE_METAINF=$$(foreach src,$$($1_SRCS), \\\n+  ifeq ($$($1_SKIP_METAINF), )\n+    $1_SCAPTURE_METAINF = $$(foreach src, $$($1_SRCS), \\\n@@ -218,1 +218,1 @@\n-  $1_SUPDATE_CONTENTS=\\\n+  $1_SUPDATE_CONTENTS = \\\n@@ -223,1 +223,1 @@\n-  $1_NAME:=$$(subst $$(OUTPUTDIR)\/,,$$($1_JAR))\n+  $1_NAME := $$(subst $$(OUTPUTDIR)\/,,$$($1_JAR))\n@@ -231,1 +231,1 @@\n-  ifneq (,$$($1_CHECK_COMPRESS_JAR))\n+  ifneq ($$($1_CHECK_COMPRESS_JAR), )\n","filename":"make\/common\/JarArchive.gmk","additions":65,"deletions":65,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -60,1 +60,1 @@\n-  $2_TARGET:=$2\n+  $2_TARGET := $2\n@@ -62,1 +62,1 @@\n-  $$(foreach i,$$($1_SRC),$$(eval $$(call remove_string,$$i,$2_TARGET)))\n+  $$(foreach i, $$($1_SRC), $$(eval $$(call remove_string,$$i,$2_TARGET)))\n@@ -101,1 +101,1 @@\n-  $2_TARGET:=$2\n+  $2_TARGET := $2\n@@ -103,1 +103,1 @@\n-  $$(foreach i,$$($1_SRC),$$(eval $$(call remove_string,$$i,$2_TARGET)))\n+  $$(foreach i, $$($1_SRC), $$(eval $$(call remove_string,$$i,$2_TARGET)))\n@@ -141,3 +141,3 @@\n-#   SMALL_JAVA:=set to false to run javac as a \"big\" java app\n-#   COMPILER:=bootjdk or interim, the latter is default\n-#   TARGET_RELEASE:=javac flags to set the targeted jdk release (-source\/-target or --release)\n+#   SMALL_JAVA set to false to run javac as a \"big\" java app\n+#   COMPILER bootjdk or interim, the latter is default\n+#   TARGET_RELEASE javac flags to set the targeted jdk release (-source\/-target or --release)\n@@ -145,4 +145,4 @@\n-#   JAVAC_FLAGS:=javac flags to append to the default ones.\n-#   JAVA_FLAGS:=flags to be appended to the java launching the compiler\n-#   DISABLED_WARNINGS:=list of Xlint warnings that should be disabled\n-#   SRC:=one or more directories to search for sources. The order of the source roots\n+#   JAVAC_FLAGS javac flags to append to the default ones.\n+#   JAVA_FLAGS flags to be appended to the java launching the compiler\n+#   DISABLED_WARNINGS list of Xlint warnings that should be disabled\n+#   SRC one or more directories to search for sources. The order of the source roots\n@@ -150,12 +150,12 @@\n-#   BIN:=store classes here\n-#   MODULE:=Name of module being compiled. If set, classes are put in BIN\/MODULE.\n-#   CLASSPATH:=a list of additional entries to set as classpath to javac\n-#   INCLUDES:=myapp.foo means will only compile java files in myapp.foo or any of its sub-packages.\n-#   EXCLUDES:=myapp.foo means will do not compile java files in myapp.foo or any of its sub-packages.\n-#   COPY:=.prp means copy all prp files to the corresponding package in BIN.\n-#   COPY_FILES:=myapp\/foo\/setting.txt means copy this file over to the package myapp\/foo\n-#   CLEAN:=.properties means copy and clean all properties file to the corresponding package in BIN.\n-#   CLEAN_FILES:=myapp\/foo\/setting.txt means clean this file over to the package myapp\/foo\n-#   SRCZIP:=Create a src.zip based on the found sources and copied files.\n-#   INCLUDE_FILES:=\"com\/sun\/SolarisFoobar.java\" means only compile this file!\n-#   EXCLUDE_FILES:=\"com\/sun\/SolarisFoobar.java\" means do not compile this particular file!\n+#   BIN store classes here\n+#   MODULE Name of module being compiled. If set, classes are put in BIN\/MODULE.\n+#   CLASSPATH a list of additional entries to set as classpath to javac\n+#   INCLUDES myapp.foo means will only compile java files in myapp.foo or any of its sub-packages.\n+#   EXCLUDES myapp.foo means will do not compile java files in myapp.foo or any of its sub-packages.\n+#   COPY .prp means copy all prp files to the corresponding package in BIN.\n+#   COPY_FILES myapp\/foo\/setting.txt means copy this file over to the package myapp\/foo\n+#   CLEAN .properties means copy and clean all properties file to the corresponding package in BIN.\n+#   CLEAN_FILES myapp\/foo\/setting.txt means clean this file over to the package myapp\/foo\n+#   SRCZIP Create a src.zip based on the found sources and copied files.\n+#   INCLUDE_FILES \"com\/sun\/SolarisFoobar.java\" means only compile this file!\n+#   EXCLUDE_FILES \"com\/sun\/SolarisFoobar.java\" means do not compile this particular file!\n@@ -163,1 +163,1 @@\n-#   EXTRA_FILES:=List of extra source files to include in compilation. Can be used to\n+#   EXTRA_FILES List of extra source files to include in compilation. Can be used to\n@@ -165,4 +165,4 @@\n-#   HEADERS:=path to directory where all generated c-headers are written.\n-#   DEPENDS:=Extra dependency\n-#   KEEP_DUPS:=Do not remove duplicate file names from different source roots.\n-#   FAIL_NO_SRC:=Set to false to not fail the build if no source files are found,\n+#   HEADERS path to directory where all generated c-headers are written.\n+#   DEPENDS Extra dependency\n+#   KEEP_DUPS Do not remove duplicate file names from different source roots.\n+#   FAIL_NO_SRC Set to false to not fail the build if no source files are found,\n@@ -170,1 +170,1 @@\n-#   CREATE_API_DIGEST:=Set to true to use a javac plugin to generate a public API\n+#   CREATE_API_DIGEST Set to true to use a javac plugin to generate a public API\n@@ -173,1 +173,1 @@\n-#   KEEP_ALL_TRANSLATIONS:=Set to true to skip translation filtering\n+#   KEEP_ALL_TRANSLATIONS Set to true to skip translation filtering\n@@ -178,1 +178,1 @@\n-  ifeq ($$($1_BIN),)\n+  ifeq ($$($1_BIN), )\n@@ -258,1 +258,1 @@\n-       $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n+        $1_JAVAC_CMD := $$(JAVA_SMALL) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n@@ -260,1 +260,1 @@\n-       $1_JAVAC_CMD := $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n+        $1_JAVAC_CMD := $$(JAVA) $$($1_JAVA_FLAGS) $$($1_JAVAC)\n@@ -285,2 +285,20 @@\n-  ifneq ($$($1_CLASSPATH), )\n-    $1_FLAGS += -cp $$(call PathList, $$($1_CLASSPATH))\n+  $1_AUGMENTED_CLASSPATH := $$($1_CLASSPATH)\n+  $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n+  $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n+\n+  ifeq ($$($1_CREATE_API_DIGEST), true)\n+    $1_API_DIGEST_FLAGS := \\\n+        -Xplugin:\"depend $$($1_API_TARGET)\" \\\n+        \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n+        \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n+        #\n+\n+    $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n+    # including the compilation output on the classpath, so that incremental\n+    # compilations in unnamed module can refer to other classes from the same\n+    # source root, which are not being recompiled in this compilation:\n+    $1_AUGMENTED_CLASSPATH += $$(BUILDTOOLS_OUTPUTDIR)\/depend $$($1_BIN)\n+  endif\n+\n+  ifneq ($$($1_AUGMENTED_CLASSPATH), )\n+    $1_FLAGS += -cp $$(call PathList, $$($1_AUGMENTED_CLASSPATH))\n@@ -298,1 +316,1 @@\n-  $$(call MakeDir,$$($1_BIN))\n+  $$(call MakeDir, $$($1_BIN))\n@@ -354,1 +372,1 @@\n-    $1_ALL_COPIES := $$(filter $$(addsuffix \/META-INF%,$$($1_SRC)),$$($1_ALL_SRCS))\n+    $1_ALL_COPIES := $$(filter $$(addsuffix \/META-INF%, $$($1_SRC)), $$($1_ALL_SRCS))\n@@ -356,1 +374,1 @@\n-    ifneq (,$$($1_COPY)$$($1_COPY_FILES))\n+    ifneq ($$($1_COPY)$$($1_COPY_FILES), )\n@@ -358,1 +376,1 @@\n-      $1_ALL_COPIES += $$(filter $$(addprefix %,$$($1_COPY)),$$($1_ALL_SRCS))\n+      $1_ALL_COPIES += $$(filter $$(addprefix %, $$($1_COPY)), $$($1_ALL_SRCS))\n@@ -363,2 +381,2 @@\n-    ifneq (,$$($1_INCLUDE_PATTERN))\n-      $1_ALL_COPIES := $$(filter $$($1_INCLUDE_PATTERN),$$($1_ALL_COPIES))\n+    ifneq ($$($1_INCLUDE_PATTERN), )\n+      $1_ALL_COPIES := $$(filter $$($1_INCLUDE_PATTERN), $$($1_ALL_COPIES))\n@@ -366,2 +384,2 @@\n-    ifneq (,$$($1_EXCLUDE_PATTERN))\n-      $1_ALL_COPIES := $$(filter-out $$($1_EXCLUDE_PATTERN),$$($1_ALL_COPIES))\n+    ifneq ($$($1_EXCLUDE_PATTERN), )\n+      $1_ALL_COPIES := $$(filter-out $$($1_EXCLUDE_PATTERN), $$($1_ALL_COPIES))\n@@ -373,1 +391,1 @@\n-    ifneq (,$$($1_ALL_COPIES))\n+    ifneq ($$($1_ALL_COPIES), )\n@@ -375,2 +393,2 @@\n-      $1_ALL_COPY_TARGETS:=\n-          $$(foreach i,$$($1_ALL_COPIES),$$(eval $$(call add_file_to_copy,$1,$$i)))\n+      $1_ALL_COPY_TARGETS :=\n+          $$(foreach i, $$($1_ALL_COPIES), $$(eval $$(call add_file_to_copy,$1,$$i)))\n@@ -381,1 +399,1 @@\n-    ifneq (,$$($1_CLEAN)$$($1_CLEAN_FILES))\n+    ifneq ($$($1_CLEAN)$$($1_CLEAN_FILES), )\n@@ -383,1 +401,1 @@\n-      $1_ALL_CLEANS := $$(filter $$(addprefix %,$$($1_CLEAN)),$$($1_ALL_SRCS))\n+      $1_ALL_CLEANS := $$(filter $$(addprefix %, $$($1_CLEAN)), $$($1_ALL_SRCS))\n@@ -387,2 +405,2 @@\n-      ifneq (,$$($1_INCLUDE_PATTERN))\n-        $1_ALL_CLEANS := $$(filter $$($1_INCLUDE_PATTERN),$$($1_ALL_CLEANS))\n+      ifneq ($$($1_INCLUDE_PATTERN), )\n+        $1_ALL_CLEANS := $$(filter $$($1_INCLUDE_PATTERN), $$($1_ALL_CLEANS))\n@@ -390,2 +408,2 @@\n-      ifneq (,$$($1_EXCLUDE_PATTERN))\n-        $1_ALL_CLEANS := $$(filter-out $$($1_EXCLUDE_PATTERN),$$($1_ALL_CLEANS))\n+      ifneq ($$($1_EXCLUDE_PATTERN), )\n+        $1_ALL_CLEANS := $$(filter-out $$($1_EXCLUDE_PATTERN), $$($1_ALL_CLEANS))\n@@ -397,1 +415,1 @@\n-      ifneq (,$$($1_ALL_CLEANS))\n+      ifneq ($$($1_ALL_CLEANS), )\n@@ -399,2 +417,2 @@\n-        $1_ALL_COPY_CLEAN_TARGETS:=\n-            $$(foreach i,$$($1_ALL_CLEANS),$$(eval $$(call add_file_to_clean,$1,$$i)))\n+        $1_ALL_COPY_CLEAN_TARGETS :=\n+            $$(foreach i, $$($1_ALL_CLEANS), $$(eval $$(call add_file_to_clean,$1,$$i)))\n@@ -407,1 +425,1 @@\n-    $1_REWRITE_INTO_CLASSES:=$$(foreach i,$$($1_SRC),-e 's|$$i\/||g') -e 's|\/|.|g' -e 's|.java$$$$||g'\n+    $1_REWRITE_INTO_CLASSES := $$(foreach i, $$($1_SRC), -e 's|$$i\/||g') -e 's|\/|.|g' -e 's|.java$$$$||g'\n@@ -414,3 +432,0 @@\n-    $1_API_TARGET := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_pubapi\n-    $1_API_INTERNAL := $$($1_BIN)$$($1_MODULE_SUBDIR)\/_the.$1_internalapi\n-\n@@ -419,1 +434,1 @@\n-    ifneq (,$$($1_HEADERS))\n+    ifneq ($$($1_HEADERS), )\n@@ -445,11 +460,0 @@\n-    ifeq ($$($1_CREATE_API_DIGEST), true)\n-      $1_API_DIGEST_FLAGS := \\\n-          -classpath $$(BUILDTOOLS_OUTPUTDIR)\/depend \\\n-          -Xplugin:\"depend $$($1_API_TARGET)\" \\\n-          \"-XDinternalAPIPath=$$($1_API_INTERNAL)\" \\\n-          \"-XDLOG_LEVEL=$(LOG_LEVEL)\" \\\n-          #\n-\n-      $1_EXTRA_DEPS := $$(BUILDTOOLS_OUTPUTDIR)\/depend\/_the.COMPILE_DEPEND_batch\n-    endif\n-\n@@ -502,1 +506,1 @@\n-    ifneq (,$$($1_JAR))\n+    ifneq ($$($1_JAR), )\n@@ -506,2 +510,2 @@\n-      ifeq (,$$($1_SUFFIXES))\n-        $1_SUFFIXES:=.class $$($1_CLEAN) $$($1_COPY)\n+      ifeq ($$($1_SUFFIXES), )\n+        $1_SUFFIXES := .class $$($1_CLEAN) $$($1_COPY)\n@@ -511,12 +515,12 @@\n-          DEPENDENCIES:=$$($1), \\\n-          SRCS:=$$($1_BIN)$$($1_MODULE_SUBDIR), \\\n-          SUFFIXES:=$$($1_SUFFIXES), \\\n-          EXCLUDE:=$$($1_EXCLUDES), \\\n-          INCLUDES:=$$($1_INCLUDES), \\\n-          EXTRA_FILES:=$$($1_ALL_COPY_TARGETS) $$($1_ALL_COPY_CLEAN_TARGETS), \\\n-          JAR:=$$($1_JAR), \\\n-          JARMAIN:=$$($1_JARMAIN), \\\n-          MANIFEST:=$$($1_MANIFEST), \\\n-          EXTRA_MANIFEST_ATTR:=$$($1_EXTRA_MANIFEST_ATTR), \\\n-          JARINDEX:=$$($1_JARINDEX), \\\n-          HEADERS:=$$($1_HEADERS), \\\n+          DEPENDENCIES := $$($1), \\\n+          SRCS := $$($1_BIN)$$($1_MODULE_SUBDIR), \\\n+          SUFFIXES := $$($1_SUFFIXES), \\\n+          EXCLUDE := $$($1_EXCLUDES), \\\n+          INCLUDES := $$($1_INCLUDES), \\\n+          EXTRA_FILES := $$($1_ALL_COPY_TARGETS) $$($1_ALL_COPY_CLEAN_TARGETS), \\\n+          JAR := $$($1_JAR), \\\n+          JARMAIN := $$($1_JARMAIN), \\\n+          MANIFEST := $$($1_MANIFEST), \\\n+          EXTRA_MANIFEST_ATTR := $$($1_EXTRA_MANIFEST_ATTR), \\\n+          JARINDEX := $$($1_JARINDEX), \\\n+          HEADERS := $$($1_HEADERS), \\\n@@ -530,1 +534,1 @@\n-    ifneq (,$$($1_SRCZIP))\n+    ifneq ($$($1_SRCZIP), )\n@@ -532,5 +536,5 @@\n-          SRC:=$$($1_SRC), \\\n-          ZIP:=$$($1_SRCZIP), \\\n-          INCLUDES:=$$($1_INCLUDES), \\\n-          EXCLUDES:=$$($1_EXCLUDES), \\\n-          EXCLUDE_FILES:=$$($1_EXCLUDE_FILES)))\n+          SRC := $$($1_SRC), \\\n+          ZIP := $$($1_SRCZIP), \\\n+          INCLUDES := $$($1_INCLUDES), \\\n+          EXCLUDES := $$($1_EXCLUDES), \\\n+          EXCLUDE_FILES := $$($1_EXCLUDE_FILES)))\n","filename":"make\/common\/JavaCompilation.gmk","additions":97,"deletions":93,"binary":false,"changes":190,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-  ifeq ($$(filter lib%, $$($1_$2_NAME)),)\n+  ifeq ($$(filter lib%, $$($1_$2_NAME)), )\n@@ -190,1 +190,1 @@\n-  ifeq ($$($1_$2_MODULE),)\n+  ifeq ($$($1_$2_MODULE), )\n@@ -199,1 +199,1 @@\n-     $1_$2_STATIC_LIBRARY := true\n+    $1_$2_STATIC_LIBRARY := true\n@@ -202,1 +202,1 @@\n-     $1_$2_STATIC_LIBRARY := true\n+    $1_$2_STATIC_LIBRARY := true\n","filename":"make\/common\/JdkNativeCompilation.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-################################################################\n+################################################################################\n@@ -31,1 +31,1 @@\n-################################################################\n+################################################################################\n@@ -36,1 +36,1 @@\n-ifeq ($(wildcard $(SPEC)),)\n+ifeq ($(wildcard $(SPEC)), )\n@@ -52,8 +52,8 @@\n-X:=\n-SPACE:=$(X) $(X)\n-COMMA:=,\n-DOLLAR:=$$\n-HASH:=\\#\n-LEFT_PAREN:=(\n-RIGHT_PAREN:=)\n-SQUOTE:='\n+X :=\n+SPACE := $(X) $(X)\n+COMMA := ,\n+DOLLAR := $$\n+HASH := \\#\n+LEFT_PAREN := (\n+RIGHT_PAREN := )\n+SQUOTE := '\n@@ -61,1 +61,1 @@\n-DQUOTE:=\"\n+DQUOTE := \"\n@@ -102,1 +102,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n@@ -120,1 +120,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), info debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), info debug trace), )\n@@ -127,1 +127,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n@@ -134,1 +134,1 @@\n-  ifneq ($$(findstring $$(LOG_LEVEL), trace),)\n+  ifneq ($$(findstring $$(LOG_LEVEL), trace), )\n@@ -167,1 +167,1 @@\n-  $(if $($(MAX_PARAMS)),$(error Internal makefile error: \\\n+  $(if $($(MAX_PARAMS)), $(error Internal makefile error: \\\n@@ -170,1 +170,1 @@\n-  $(foreach i,$(PARAM_SEQUENCE), $(if $(strip $($i)),\\\n+  $(foreach i, $(PARAM_SEQUENCE), $(if $(strip $($i)), \\\n@@ -174,1 +174,1 @@\n-    $(info $0 $(strip $1) $(foreach i,$(PARAM_SEQUENCE), \\\n+    $(info $0 $(strip $1) $(foreach i, $(PARAM_SEQUENCE), \\\n@@ -249,2 +249,2 @@\n-    $(call WriteFile, $1_old:=$(call DoubleDollar,$(call EscapeHash,$($1))), \\\n-         $($1_filename)) \\\n+    $(call WriteFile, $1_old := $(call DoubleDollar,$(call EscapeHash,$($1))), \\\n+        $($1_filename)) \\\n@@ -263,1 +263,1 @@\n-          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),,\\\n+          $(if $(call equals, $(strip $($1)), $(strip $($1_old))),, \\\n","filename":"make\/common\/MakeBase.gmk","additions":22,"deletions":22,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -70,1 +70,1 @@\n-  decompress_paths=$(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n+  decompress_paths = $(SED) -f $(TOPDIR)\/make\/common\/support\/ListPathsSafely-uncompress.sed \\\n@@ -76,1 +76,1 @@\n-      $(if $(word $3,$($(strip $1))), \\\n+      $(if $(word $3, $($(strip $1))), \\\n@@ -78,1 +78,1 @@\n-              $(call compress_paths, $(wordlist $3,$4,$($(strip $1))))))\\n\" \\\n+              $(call compress_paths, $(wordlist $3, $4, $($(strip $1))))))\\n\" \\\n@@ -85,1 +85,1 @@\n-    ifneq (,$$(word 30001,$$($$(strip $1))))\n+    ifneq ($$(word 30001, $$($$(strip $1))), )\n","filename":"make\/common\/MakeIO.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -180,2 +180,2 @@\n-\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t    ( $(PRINTF) \"DEPS_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -194,2 +194,2 @@\n-\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) :=\" && \\\n-\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) '\\\n+\t      $(PRINTF) \"TRANSITIVE_MODULES_$(call GetModuleNameFromModuleInfo, $m) := \" && \\\n+\t      $(AWK) -v MODULE=$(call GetModuleNameFromModuleInfo, $m) ' \\\n@@ -224,1 +224,1 @@\n-                 $(call FindDepsForModule, $n))))\n+                $(call FindDepsForModule, $n))))\n@@ -243,1 +243,1 @@\n-                 $(call FindIndirectExportsForModule, $n))))\n+                $(call FindIndirectExportsForModule, $n))))\n","filename":"make\/common\/Modules.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -185,1 +185,1 @@\n-      $$(eval $$(call CreateCompiledNativeFile,$1_$$(notdir $$(file)),\\\n+      $$(eval $$(call CreateCompiledNativeFile,$1_$$(notdir $$(file)), \\\n@@ -225,1 +225,1 @@\n-    $1 := $$($1_ALL_OBJS_JSON)\n+    $1 := $$($1_ALL_OBJS_JSON) $$($1_LDFLAGS_FILE)\n@@ -295,0 +295,1 @@\n+  $1_UNIQUE_NAME = $$($1_TYPE)_$$(subst \/,_,$$(patsubst $$(OUTPUTDIR)\/%\/,%,$$(dir $$($1_OBJECT_DIR))))_$$($1_NOSUFFIX)\n","filename":"make\/common\/NativeCompilation.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -95,1 +95,1 @@\n-        ifneq ($$(findstring $$(LOG_LEVEL), debug trace),)\n+        ifneq ($$(findstring $$(LOG_LEVEL), debug trace), )\n","filename":"make\/common\/ProcessMarkdown.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -98,1 +98,1 @@\n-  $$(foreach file, $$($1_FILTERED_FILE_LIST),\\\n+  $$(foreach file, $$($1_FILTERED_FILE_LIST), \\\n@@ -115,3 +115,6 @@\n-        DISABLED_WARNINGS_gcc := format undef unused-function unused-value, \\\n-        DISABLED_WARNINGS_clang := undef format-nonliteral \\\n-            missing-field-initializers sometimes-uninitialized, \\\n+        DISABLED_WARNINGS_gcc := format undef unused-but-set-variable \\\n+            unused-const-variable unused-function unused-value \\\n+            unused-variable, \\\n+        DISABLED_WARNINGS_clang := format-nonliteral \\\n+            missing-field-initializers sometimes-uninitialized undef \\\n+            unused-but-set-variable unused-function unused-variable, \\\n@@ -122,1 +125,1 @@\n-        OPTIMIZATION := $$(if $$($1_OPTIMIZATION_$$(name)),$$($1_OPTIMIZATION_$$(name)),LOW), \\\n+        OPTIMIZATION := $$(if $$($1_OPTIMIZATION_$$(name)), $$($1_OPTIMIZATION_$$(name)), LOW), \\\n@@ -124,1 +127,1 @@\n-        STRIP_SYMBOLS := $$(if $$($1_STRIP_SYMBOLS_$$(name)),$$($1_STRIP_SYMBOLS_$$(name)),false), \\\n+        STRIP_SYMBOLS := $$(if $$($1_STRIP_SYMBOLS_$$(name)), $$($1_STRIP_SYMBOLS_$$(name)), false), \\\n","filename":"make\/common\/TestFilesCompilation.gmk","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -83,2 +83,2 @@\n-  ifneq ($$($1_SOURCE_FILES),)\n-    ifneq ($$($1_SOURCE_DIRS),)\n+  ifneq ($$($1_SOURCE_FILES), )\n+    ifneq ($$($1_SOURCE_DIRS), )\n@@ -87,1 +87,1 @@\n-    ifneq ($$($1_EXCLUDE_FILES)$$($1_INCLUDE_FILES),)\n+    ifneq ($$($1_EXCLUDE_FILES)$$($1_INCLUDE_FILES), )\n@@ -91,1 +91,1 @@\n-    ifeq ($$($1_SOURCE_DIRS),)\n+    ifeq ($$($1_SOURCE_DIRS), )\n@@ -97,1 +97,1 @@\n-    ifneq ($$($1_SOURCE_BASE_DIR),)\n+    ifneq ($$($1_SOURCE_BASE_DIR), )\n@@ -104,5 +104,5 @@\n-    $1_EXCLUDE_FILES:=$$(foreach i,$$($1_SOURCE_DIRS),$$(addprefix $$i\/,$$($1_EXCLUDE_FILES)))\n-    $1_INCLUDE_FILES:=$$(foreach i,$$($1_SOURCE_DIRS),$$(addprefix $$i\/,$$($1_INCLUDE_FILES)))\n-    $1_SOURCE_FILES := $$(filter-out $$($1_EXCLUDE_FILES),$$($1_SOURCE_FILES))\n-    ifneq (,$$(strip $$($1_INCLUDE_FILES)))\n-      $1_SOURCE_FILES := $$(filter $$($1_INCLUDE_FILES),$$($1_SOURCE_FILES))\n+    $1_EXCLUDE_FILES := $$(foreach i, $$($1_SOURCE_DIRS), $$(addprefix $$i\/, $$($1_EXCLUDE_FILES)))\n+    $1_INCLUDE_FILES := $$(foreach i, $$($1_SOURCE_DIRS), $$(addprefix $$i\/, $$($1_INCLUDE_FILES)))\n+    $1_SOURCE_FILES := $$(filter-out $$($1_EXCLUDE_FILES), $$($1_SOURCE_FILES))\n+    ifneq ($$(strip $$($1_INCLUDE_FILES)), )\n+      $1_SOURCE_FILES := $$(filter $$($1_INCLUDE_FILES), $$($1_SOURCE_FILES))\n@@ -110,1 +110,1 @@\n-    ifeq (,$$($1_SOURCE_FILES))\n+    ifeq ($$($1_SOURCE_FILES), )\n@@ -115,1 +115,1 @@\n-  ifneq ($$($1_REPLACEMENTS),)\n+  ifneq ($$($1_REPLACEMENTS), )\n@@ -117,1 +117,1 @@\n-    ifneq ($$(findstring \/,$$($1_REPLACEMENTS)),)\n+    ifneq ($$(findstring \/, $$($1_REPLACEMENTS)), )\n@@ -119,1 +119,1 @@\n-      ifneq ($$(findstring @,$$($1_REPLACEMENTS)),)\n+      ifneq ($$(findstring @, $$($1_REPLACEMENTS)), )\n@@ -121,1 +121,1 @@\n-        ifneq ($$(findstring |,$$($1_REPLACEMENTS)),)\n+        ifneq ($$(findstring |, $$($1_REPLACEMENTS)), )\n@@ -123,1 +123,1 @@\n-          ifneq ($$(findstring !,$$($1_REPLACEMENTS)),)\n+          ifneq ($$(findstring !, $$($1_REPLACEMENTS)), )\n@@ -164,1 +164,1 @@\n-  ifneq ($$($1_INCLUDES),)\n+  ifneq ($$($1_INCLUDES), )\n@@ -193,1 +193,1 @@\n-  ifneq ($$($1_OUTPUT_FILE),)\n+  ifneq ($$($1_OUTPUT_FILE), )\n@@ -202,1 +202,1 @@\n-    ifeq ($$($1_OUTPUT_DIR),)\n+    ifeq ($$($1_OUTPUT_DIR), )\n@@ -207,1 +207,1 @@\n-    ifeq ($$($1_SOURCE_BASE_DIR),)\n+    ifeq ($$($1_SOURCE_BASE_DIR), )\n","filename":"make\/common\/TextFileProcessing.gmk","additions":21,"deletions":21,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -39,1 +39,1 @@\n-      $(and $(findstring $(strip $1),$(strip $2)),\\\n+      $(and $(findstring $(strip $1),$(strip $2)), \\\n@@ -67,1 +67,1 @@\n-        $(eval SEQUENCE_COUNT :=) \\\n+        $(eval SEQUENCE_COUNT := ) \\\n@@ -228,1 +228,1 @@\n-        $(foreach v,$(strip $2),\\\n+        $(foreach v,$(strip $2), \\\n@@ -245,1 +245,1 @@\n-    $(strip $(if $1,$(patsubst $(firstword $1)%,%,\\\n+    $(strip $(if $1,$(patsubst $(firstword $1)%,%, \\\n@@ -273,1 +273,1 @@\n-         +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n+        +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n@@ -277,1 +277,1 @@\n-         +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n+        +\"$(ISO_8601_FORMAT_STRING)\" 2> \/dev\/null)\n","filename":"make\/common\/Utils.gmk","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-ifeq (,$(_MAKEBASE_GMK))\n+ifeq ($(_MAKEBASE_GMK), )\n@@ -68,3 +68,3 @@\n-  ifneq ($$($1_INCLUDES)$$($1_INCLUDE_FILES),)\n-    $1_FIND_LIST := $$(wildcard $$(foreach s,$$($1_SRC_SLASH), \\\n-        $$(addprefix $$s,$$($1_INCLUDES) $$($1_INCLUDE_FILES))))\n+  ifneq ($$($1_INCLUDES)$$($1_INCLUDE_FILES), )\n+    $1_FIND_LIST := $$(wildcard $$(foreach s, $$($1_SRC_SLASH), \\\n+        $$(addprefix $$s, $$($1_INCLUDES) $$($1_INCLUDE_FILES))))\n@@ -79,1 +79,1 @@\n-    $1_ALL_SRCS := $$(call not-containing,_the.,$$(call ShellFindFiles,$$($1_FIND_LIST), , -L))\n+    $1_ALL_SRCS := $$(call not-containing, _the., $$(call ShellFindFiles, $$($1_FIND_LIST), , -L))\n@@ -81,1 +81,1 @@\n-    $1_ALL_SRCS := $$(call not-containing,_the.,$$(call FindFiles,$$($1_FIND_LIST)))\n+    $1_ALL_SRCS := $$(call not-containing, _the., $$(call FindFiles, $$($1_FIND_LIST)))\n@@ -85,1 +85,1 @@\n-  ifneq ($$($1_SUFFIXES),)\n+  ifneq ($$($1_SUFFIXES), )\n@@ -89,4 +89,4 @@\n-  ifneq ($$($1_INCLUDES),)\n-    ifneq ($$($1_SUFFIXES),)\n-      $1_ZIP_INCLUDES := $$(foreach s,$$($1_SUFFIXES), \\\n-          $$(addprefix -i$(SPACE)$(DQUOTE),$$(addsuffix \/*$$s$(DQUOTE),$$($1_INCLUDES))))\n+  ifneq ($$($1_INCLUDES), )\n+    ifneq ($$($1_SUFFIXES), )\n+      $1_ZIP_INCLUDES := $$(foreach s, $$($1_SUFFIXES), \\\n+          $$(addprefix -i$(SPACE)$(DQUOTE), $$(addsuffix \/*$$s$(DQUOTE), $$($1_INCLUDES))))\n@@ -94,1 +94,1 @@\n-      $1_ZIP_INCLUDES := $$(addprefix -i$(SPACE)$(DQUOTE),$$(addsuffix \/*$(DQUOTE),$$($1_INCLUDES)))\n+      $1_ZIP_INCLUDES := $$(addprefix -i$(SPACE)$(DQUOTE), $$(addsuffix \/*$(DQUOTE), $$($1_INCLUDES)))\n@@ -97,3 +97,3 @@\n-    ifneq ($$($1_SUFFIXES),)\n-      $1_ZIP_INCLUDES := $$(foreach s,$$($1_SUFFIXES), \\\n-          $$(addprefix -i$(SPACE)$(DQUOTE),*$$s$(DQUOTE)))\n+    ifneq ($$($1_SUFFIXES), )\n+      $1_ZIP_INCLUDES := $$(foreach s, $$($1_SUFFIXES), \\\n+          $$(addprefix -i$(SPACE)$(DQUOTE), *$$s$(DQUOTE)))\n@@ -102,2 +102,2 @@\n-  ifneq ($$($1_INCLUDE_FILES),)\n-    $1_ZIP_INCLUDES += $$(addprefix -i$(SPACE),$$($1_INCLUDE_FILES))\n+  ifneq ($$($1_INCLUDE_FILES), )\n+    $1_ZIP_INCLUDES += $$(addprefix -i$(SPACE), $$($1_INCLUDE_FILES))\n@@ -105,4 +105,4 @@\n-  ifneq ($$($1_EXCLUDES),)\n-    $1_ZIP_EXCLUDES := $$(addprefix -x$(SPACE)$(DQUOTE),$$(addsuffix \/*$(DQUOTE),$$($1_EXCLUDES)))\n-    $1_SRC_EXCLUDES := $$(foreach s,$$($1_SRC_SLASH),$$(addprefix $$s,$$(addsuffix \/%,$$($1_EXCLUDES))))\n-    $1_ALL_SRCS := $$(filter-out $$($1_SRC_EXCLUDES),$$($1_ALL_SRCS))\n+  ifneq ($$($1_EXCLUDES), )\n+    $1_ZIP_EXCLUDES := $$(addprefix -x$(SPACE)$(DQUOTE), $$(addsuffix \/*$(DQUOTE), $$($1_EXCLUDES)))\n+    $1_SRC_EXCLUDES := $$(foreach s, $$($1_SRC_SLASH), $$(addprefix $$s, $$(addsuffix \/%, $$($1_EXCLUDES))))\n+    $1_ALL_SRCS := $$(filter-out $$($1_SRC_EXCLUDES), $$($1_ALL_SRCS))\n@@ -110,1 +110,1 @@\n-  ifneq ($$($1_EXCLUDE_FILES),)\n+  ifneq ($$($1_EXCLUDE_FILES), )\n@@ -137,1 +137,1 @@\n-  $1_NAME:=$$(subst $$(OUTPUTDIR)\/,,$$($1_ZIP))\n+  $1_NAME := $$(subst $$(OUTPUTDIR)\/,,$$($1_ZIP))\n@@ -170,1 +170,1 @@\n-\t$$(foreach s,$$($1_SRC_SLASH), $$(call ExecuteWithLog, \\\n+\t$$(foreach s, $$($1_SRC_SLASH), $$(call ExecuteWithLog, \\\n","filename":"make\/common\/ZipArchive.gmk","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -138,1 +138,2 @@\n-      DISABLED_WARNINGS_gcc := unused-function, \\\n+      DISABLED_WARNINGS_gcc := unused-function unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-function, \\\n","filename":"make\/common\/modules\/LauncherCommon.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  $(call WriteFile,{ \\\n+  $(call WriteFile, { \\\n@@ -47,1 +47,1 @@\n-      \"command\": \"$(strip $(subst $(DQUOTE),\\$(DQUOTE),$(subst \\,\\\\,\\\n+      \"command\": \"$(strip $(subst $(DQUOTE),\\$(DQUOTE),$(subst \\,\\\\, \\\n@@ -347,1 +347,1 @@\n-\t\t$(ECHO) >> $$($1_RES_DEPS_FILE) ;\\\n+\t\t$(ECHO) >> $$($1_RES_DEPS_FILE) ; \\\n","filename":"make\/common\/native\/CompileFile.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -97,1 +97,1 @@\n-       endif # !STATIC_LIBRARY\n+      endif # !STATIC_LIBRARY\n","filename":"make\/common\/native\/DebugSymbols.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -112,0 +112,5 @@\n+          # 'ld -r' might invalidate the .llvm_addrsig section, and this will cause subsequent\n+          # calls to lld (with '-Wl,--icf=safe') to fail when linking with this library, so\n+          # remove that section.\n+\t  $$(call ExecuteWithLog, $$($1_OBJECT_DIR)\/$$($1_SAFE_NAME)_objcopy_remove_llvm_addrsig_section, \\\n+\t      $$($1_OBJCOPY) --remove-section=.llvm_addrsig $$($1_TARGET_RELOCATABLE))\n@@ -196,0 +201,12 @@\n+\n+  # This is for IDE integration purposes only, and is not normally generated\n+  $1_LDFLAGS_FILE := $$(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/$$($1_UNIQUE_NAME)-ldflags.txt\n+\n+  $1_ALL_LD_ARGS := $$($1_LDFLAGS) $$($1_EXTRA_LDFLAGS) $$($1_SYSROOT_LDFLAGS) \\\n+      $$($1_LIBS) $$($1_EXTRA_LIBS)\n+\n+  $$($1_LDFLAGS_FILE): $$($1_VARDEPS_FILE)\n+\t$$(call LogInfo, Creating compile commands linker flags output for $$($1_BASENAME))\n+\t$$(call MakeDir, $$(dir $$@))\n+\t$$(ECHO) $$($1_ALL_LD_ARGS) > $$@\n+\n","filename":"make\/common\/native\/Link.gmk","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -35,0 +35,4 @@\n+ALPINE_LINUX_X64_BOOT_JDK_EXT=tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_URL=https:\/\/github.com\/adoptium\/temurin22-binaries\/releases\/download\/jdk-22.0.2%2B9\/OpenJDK22U-jdk_x64_alpine-linux_hotspot_22.0.2_9.tar.gz\n+ALPINE_LINUX_X64_BOOT_JDK_SHA256=49f73414824b1a7c268a611225fa4d7ce5e25600201e0f1cd59f94d1040b5264\n+\n","filename":"make\/conf\/github-actions.conf","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,1 +97,0 @@\n-    java.datatransfer \\\n@@ -100,1 +99,0 @@\n-    java.logging \\\n@@ -102,3 +100,0 @@\n-    java.management.rmi \\\n-    java.naming \\\n-    java.net.http \\\n@@ -107,2 +102,0 @@\n-    java.scripting \\\n-    java.se \\\n@@ -110,1 +103,0 @@\n-    java.security.sasl \\\n@@ -112,5 +104,0 @@\n-    java.sql \\\n-    java.sql.rowset \\\n-    java.transaction.xa \\\n-    java.xml \\\n-    java.xml.crypto \\\n@@ -118,1 +105,1 @@\n-    jdk.charsets \\\n+    jdk.attach \\\n@@ -120,3 +107,2 @@\n-    jdk.dynalink \\\n-    jdk.httpserver \\\n-    jdk.incubator.vector \\\n+    jdk.crypto.mscapi \\\n+    jdk.hotspot.agent \\\n@@ -125,0 +111,1 @@\n+    jdk.jdi \\\n@@ -126,2 +113,1 @@\n-    jdk.jsobject \\\n-    jdk.localedata \\\n+    jdk.jpackage \\\n@@ -130,3 +116,0 @@\n-    jdk.management.jfr \\\n-    jdk.naming.dns \\\n-    jdk.naming.rmi \\\n@@ -134,1 +117,0 @@\n-    jdk.nio.mapmode \\\n@@ -137,4 +119,0 @@\n-    jdk.security.jgss \\\n-    jdk.unsupported \\\n-    jdk.xml.dom \\\n-    jdk.zipfs \\\n","filename":"make\/conf\/module-loader-map.conf","additions":5,"deletions":27,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -84,1 +84,1 @@\n-ifeq (,$(SKIP_ME))\n+ifeq ($(SKIP_ME), )\n","filename":"make\/devkit\/Makefile","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n-##########################################################################################\n+################################################################################\n@@ -95,1 +95,1 @@\n-##########################################################################################\n+################################################################################\n@@ -226,1 +226,1 @@\n-##########################################################################################\n+################################################################################\n@@ -261,1 +261,1 @@\n-##########################################################################################\n+################################################################################\n@@ -288,1 +288,1 @@\n-##########################################################################################\n+################################################################################\n@@ -327,1 +327,1 @@\n-##########################################################################################\n+################################################################################\n@@ -347,1 +347,1 @@\n-##########################################################################################\n+################################################################################\n@@ -360,1 +360,1 @@\n-##########################################################################################\n+################################################################################\n@@ -365,1 +365,1 @@\n-##########################################################################################\n+################################################################################\n@@ -393,1 +393,1 @@\n-##########################################################################################\n+################################################################################\n@@ -427,1 +427,1 @@\n-##########################################################################################\n+################################################################################\n@@ -594,1 +594,1 @@\n-##########################################################################################\n+################################################################################\n@@ -609,1 +609,1 @@\n-##########################################################################################\n+################################################################################\n@@ -624,1 +624,1 @@\n-  ##########################################################################################\n+  ##############################################################################\n@@ -644,1 +644,1 @@\n-##########################################################################################\n+################################################################################\n@@ -659,1 +659,1 @@\n-##########################################################################################\n+################################################################################\n@@ -673,1 +673,1 @@\n-##########################################################################################\n+################################################################################\n@@ -689,1 +689,1 @@\n-##########################################################################################\n+################################################################################\n@@ -709,1 +709,1 @@\n-##########################################################################################\n+################################################################################\n","filename":"make\/devkit\/Tools.gmk","additions":19,"deletions":19,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -40,1 +40,2 @@\n-      FILES := $(filter %.lib, $(LIB_TARGETS))))\n+      FILES := $(filter %.lib, $(LIB_TARGETS)), \\\n+  ))\n","filename":"make\/hotspot\/CopyToExplodedJdk.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -207,5 +207,5 @@\n-         if (CUR_FN != FILENAME) { CUR_FN=FILENAME; NR_BASE=NR-1; need_lineno=1 } \\\n-         if (need_lineno && $$0 !~ \/\\\/\\\/\/) \\\n-           { print \"\\n\\n\\#line \" (NR-NR_BASE) \" \\\"\" FILENAME \"\\\"\"; need_lineno=0 }; \\\n-         print \\\n-       }'\n+        if (CUR_FN != FILENAME) { CUR_FN=FILENAME; NR_BASE=NR-1; need_lineno=1 } \\\n+        if (need_lineno && $$0 !~ \/\\\/\\\/\/) \\\n+          { print \"\\n\\n\\#line \" (NR-NR_BASE) \" \\\"\" FILENAME \"\\\"\"; need_lineno=0 }; \\\n+        print \\\n+      }'\n","filename":"make\/hotspot\/gensrc\/GensrcAdlc.gmk","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -60,2 +60,3 @@\n-    DISABLED_WARNINGS_gcc := undef unused-result format-nonliteral maybe-uninitialized, \\\n-    DISABLED_WARNINGS_clang := undef unused-result format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc := format-nonliteral maybe-uninitialized undef \\\n+        unused-result zero-as-null-pointer-constant, \\\n+    DISABLED_WARNINGS_clang := format-nonliteral undef unused-result, \\\n@@ -97,1 +98,1 @@\n-        $(addprefix -I,$(GTEST_TEST_SRC)), \\\n+        $(addprefix -I, $(GTEST_TEST_SRC)), \\\n@@ -102,0 +103,1 @@\n+    DISABLED_WARNINGS_gcc_test_metaspace_misc.cpp := unused-const-variable, \\\n","filename":"make\/hotspot\/lib\/CompileGtest.gmk","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -95,1 +95,2 @@\n-    shift-negative-value unknown-pragmas\n+    shift-negative-value unknown-pragmas unused-but-set-variable \\\n+    unused-local-typedefs unused-variable\n@@ -97,2 +98,3 @@\n-DISABLED_WARNINGS_clang := sometimes-uninitialized \\\n-    missing-braces delete-non-abstract-non-virtual-dtor unknown-pragmas\n+DISABLED_WARNINGS_clang := delete-non-abstract-non-virtual-dtor missing-braces \\\n+    sometimes-uninitialized unknown-pragmas unused-but-set-variable \\\n+    unused-function unused-local-typedef unused-private-field unused-variable\n@@ -180,0 +182,2 @@\n+    DISABLED_WARNINGS_gcc_bytecodeInterpreter.cpp := unused-label, \\\n+    DISABLED_WARNINGS_gcc_c1_Runtime1_aarch64.cpp := unused-const-variable, \\\n@@ -182,0 +186,1 @@\n+    DISABLED_WARNINGS_gcc_g1FreeIdSet.cpp := unused-const-variable, \\\n@@ -184,0 +189,4 @@\n+    DISABLED_WARNINGS_gcc_javaClasses.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrChunkWriter.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrMemorySizer.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_jfrTraceIdKlassQueue.cpp := unused-const-variable, \\\n@@ -185,0 +194,1 @@\n+    DISABLED_WARNINGS_gcc_jvmFlag.cpp := unused-const-variable, \\\n@@ -186,0 +196,1 @@\n+    DISABLED_WARNINGS_gcc_macroAssembler_ppc_sha.cpp := unused-const-variable, \\\n@@ -188,0 +199,1 @@\n+    DISABLED_WARNINGS_gcc_stubGenerator_s390.cpp := unused-const-variable, \\\n@@ -189,0 +201,2 @@\n+    DISABLED_WARNINGS_gcc_templateInterpreterGenerator_x86.cpp := unused-const-variable, \\\n+    DISABLED_WARNINGS_gcc_xGlobals_ppc.cpp := unused-const-variable, \\\n@@ -271,1 +285,1 @@\n-          FILES :=$(BUILD_LIBJVM_IMPORT_LIBRARY), \\\n+          FILES := $(BUILD_LIBJVM_IMPORT_LIBRARY), \\\n","filename":"make\/hotspot\/lib\/CompileJvm.gmk","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -50,3 +50,4 @@\n-  JVM_EXCLUDE_FILES += templateInterpreter.cpp templateInterpreterGenerator.cpp \\\n-                       bcEscapeAnalyzer.cpp ciTypeFlow.cpp\n-  JVM_CFLAGS_FEATURES += -DZERO -DZERO_LIBARCH='\"$(OPENJDK_TARGET_CPU_LEGACY_LIB)\"' $(LIBFFI_CFLAGS)\n+  JVM_EXCLUDE_FILES += templateInterpreter.cpp \\\n+      templateInterpreterGenerator.cpp bcEscapeAnalyzer.cpp ciTypeFlow.cpp\n+  JVM_CFLAGS_FEATURES += -DZERO \\\n+      -DZERO_LIBARCH='\"$(OPENJDK_TARGET_CPU_LEGACY_LIB)\"' $(LIBFFI_CFLAGS)\n@@ -72,1 +73,2 @@\n-    # Override the default -g with a more liberal strip policy for the minimal JVM\n+    # Override the default -g with a more liberal strip policy for the\n+    # minimal JVM\n@@ -83,5 +85,8 @@\n-  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp jvmtiExtensions.cpp \\\n-      jvmtiImpl.cpp jvmtiManageCapabilities.cpp jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp \\\n-      jvmtiCodeBlobEvents.cpp jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp jvmtiEnvThreadState.cpp \\\n-      jvmtiTagMap.cpp jvmtiEventController.cpp evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n-      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n+  JVM_EXCLUDE_FILES += jvmtiGetLoadedClasses.cpp jvmtiThreadState.cpp \\\n+      jvmtiExtensions.cpp jvmtiImpl.cpp jvmtiManageCapabilities.cpp \\\n+      jvmtiRawMonitor.cpp jvmtiUtil.cpp jvmtiTrace.cpp jvmtiCodeBlobEvents.cpp \\\n+      jvmtiEnv.cpp jvmtiRedefineClasses.cpp jvmtiEnvBase.cpp \\\n+      jvmtiEnvThreadState.cpp jvmtiTagMap.cpp jvmtiEventController.cpp \\\n+      evmCompat.cpp jvmtiEnter.xsl jvmtiExport.cpp \\\n+      jvmtiClassFileReconstituter.cpp jvmtiTagMapTable.cpp jvmtiAgent.cpp \\\n+      jvmtiAgentList.cpp jfrJvmtiAgent.cpp\n@@ -169,2 +174,4 @@\n-    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing -fno-fat-lto-objects\n-    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto -fuse-linker-plugin -fno-strict-aliasing\n+    JVM_CFLAGS_FEATURES += -flto=auto -fuse-linker-plugin -fno-strict-aliasing \\\n+        -fno-fat-lto-objects\n+    JVM_LDFLAGS_FEATURES += $(CXX_O_FLAG_HIGHEST_JVM) -flto=auto \\\n+        -fuse-linker-plugin -fno-strict-aliasing\n","filename":"make\/hotspot\/lib\/JvmFeatures.gmk","additions":18,"deletions":11,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -127,1 +127,1 @@\n-  ifneq ($(DEBUG_LEVEL),slowdebug)\n+  ifneq ($(DEBUG_LEVEL), slowdebug)\n","filename":"make\/hotspot\/lib\/JvmOverrideFiles.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-    $(if $(strip $1),$(wildcard $(SUPPORT_OUTPUTDIR)\/headers\/$(strip $1)))\n+    $(if $(strip $1), $(wildcard $(SUPPORT_OUTPUTDIR)\/headers\/$(strip $1)))\n@@ -115,1 +115,1 @@\n-    $1_CLASSPATH += $$(foreach src,$(JAVA_DIRS), \\\n+    $1_CLASSPATH += $$(foreach src, $(JAVA_DIRS), \\\n@@ -160,1 +160,1 @@\n-      $1_NATIVE_SRCS += $$(foreach src,$(NATIVE_DIRS), \\\n+      $1_NATIVE_SRCS += $$(foreach src, $(NATIVE_DIRS), \\\n@@ -191,1 +191,1 @@\n-    $1_MATCHING_MAKE_TARGETS += $$(foreach name,$$($1_PLAIN_MAKE_TARGETS), \\\n+    $1_MATCHING_MAKE_TARGETS += $$(foreach name, $$($1_PLAIN_MAKE_TARGETS), \\\n@@ -295,1 +295,1 @@\n-    $1_LINKED_RESOURCES += $$(foreach src,$(JAVA_DIRS), \\\n+    $1_LINKED_RESOURCES += $$(foreach src, $(JAVA_DIRS), \\\n@@ -320,1 +320,1 @@\n-    $1_LINKED_RESOURCES += $$(foreach src,$(NATIVE_DIRS), \\\n+    $1_LINKED_RESOURCES += $$(foreach src, $(NATIVE_DIRS), \\\n","filename":"make\/ide\/eclipse\/CreateWorkspace.gmk","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -31,2 +31,2 @@\n-ifeq ($(SPEC),)\n-  ifneq ($(words $(SPECS)),1)\n+ifeq ($(SPEC), )\n+  ifneq ($(words $(SPECS)), 1)\n@@ -42,1 +42,1 @@\n-  ifeq ($(MODULES),)\n+  ifeq ($(MODULES), )\n@@ -50,1 +50,1 @@\n-\t$(ECHO) \"MODULE_ROOTS=\\\"$(foreach mod, $(SEL_MODULES), $(call FindModuleSrcDirs,$(mod)))\\\"\" >> $(OUT)\n+\t$(ECHO) \"MODULE_ROOTS=\\\"$(foreach mod, $(SEL_MODULES), $(call FindModuleSrcDirs, $(mod)))\\\"\" >> $(OUT)\n","filename":"make\/ide\/idea\/jdk\/idea.gmk","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -83,1 +83,1 @@\n-  ################################################################################\n+  ##############################################################################\n@@ -86,1 +86,1 @@\n-  TOOLS_OUTPUTDIR := $(HOTSPOT_OUTPUTDIR)\/support\/ide_classes\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/visualstudio\n","filename":"make\/ide\/visualstudio\/hotspot\/CreateVSProject.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -50,1 +50,1 @@\n-ifneq (,$(wildcard $(call GetIndexerFragment,notes)))\n+ifneq ($(wildcard $(call GetIndexerFragment,notes)), )\n@@ -69,1 +69,1 @@\n-ifneq ($(WORKSPACE_ROOT),$(TOPDIR))\n+ifneq ($(WORKSPACE_ROOT), $(TOPDIR))\n","filename":"make\/ide\/vscode\/hotspot\/CreateVSCodeProject.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,112 @@\n+#\n+# Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.  Oracle designates this\n+# particular file as subject to the \"Classpath\" exception as provided\n+# by Oracle in the LICENSE file that accompanied this code.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+# This must be the first rule\n+default: all\n+\n+include $(SPEC)\n+include MakeBase.gmk\n+include CopyFiles.gmk\n+include Execute.gmk\n+include JavaCompilation.gmk\n+\n+ifeq ($(call isTargetOs, macosx), true)\n+  ##############################################################################\n+  # Build the XcodeProjectMaker java tool.\n+\n+  PROJECT_MAKER_DIR := $(TOPDIR)\/make\/ide\/xcode\/hotspot\n+  TOOLS_OUTPUTDIR := $(MAKESUPPORT_OUTPUTDIR)\/ide\/xcode\n+  IDE_OUTPUTDIR := $(OUTPUTDIR)\/xcode\n+  PROJECT_FILE_NAME := hotspot.xcodeproj\n+\n+  COMPILE_COMMAND_FILE := $(OUTPUTDIR)\/compile_commands.json\n+  LINKER_FLAGS_FILE := $(MAKESUPPORT_OUTPUTDIR)\/compile-commands\/jvm-ldflags.txt\n+\n+  $(eval $(call SetupJavaCompilation, BUILD_PROJECT_CREATOR, \\\n+      TARGET_RELEASE := $(TARGET_RELEASE_BOOTJDK), \\\n+      SRC := $(PROJECT_MAKER_DIR)\/src\/classes, \\\n+      BIN := $(TOOLS_OUTPUTDIR), \\\n+      DISABLED_WARNINGS := rawtypes unchecked serial, \\\n+  ))\n+\n+  TARGETS += $(BUILD_PROJECT_CREATOR)\n+\n+  # Run the XcodeProjectMaker tool\n+  PROJECT_CREATOR_TOOL := $(JAVA_SMALL) -cp $(TOOLS_OUTPUTDIR) XcodeProjectMaker\n+\n+  ifneq ($(findstring $(LOG_LEVEL), debug trace), )\n+    XCODE_PROJ_DEBUG_OPTION := -d\n+  endif\n+\n+  XCODE_PROJ_VARDEPS := $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+      $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) $(LINKER_FLAGS_FILE)\n+  XCODE_PROJ_VARDEPS_FILE := $(call DependOnVariable, XCODE_PROJ_VARDEPS, \\\n+    $(TOOLS_OUTPUTDIR)\/xcodeproj.vardeps)\n+\n+  $(eval $(call SetupExecute, build_xcode_project, \\\n+      WARN := Generating Xcode project file, \\\n+      DEPS := $(BUILD_PROJECT_CREATOR) $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_VARDEPS_FILE), \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := $(PROJECT_CREATOR_TOOL) $(WORKSPACE_ROOT) $(IDE_OUTPUTDIR) \\\n+          $(PROJECT_MAKER_DIR)\/data $(COMPILE_COMMAND_FILE) \\\n+          $(LINKER_FLAGS_FILE) $(XCODE_PROJ_DEBUG_OPTION), \\\n+  ))\n+\n+  TARGETS += $(build_xcode_project)\n+\n+  $(eval $(call SetupCopyFiles, copy_xcode_project, \\\n+      DEST := $(IDE_OUTPUTDIR), \\\n+      FILES := $(PROJECT_MAKER_DIR)\/data\/script_before.sh $(PROJECT_MAKER_DIR)\/data\/script_after.sh , \\\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n+\n+  TARGETS += $(copy_xcode_project)\n+\n+  $(eval $(call SetupExecute, open_xcode_project, \\\n+      INFO := Opening Xcode project file, \\\n+      DEPS := $(build_xcodeproject_TARGET) FORCE, \\\n+      OUTPUT_DIR := $(TOOLS_OUTPUTDIR), \\\n+      COMMAND := open $(IDE_OUTPUTDIR)\/$(PROJECT_FILE_NAME), \\\n+  ))\n+\n+  TARGETS += $(open_xcode_project)\n+\n+  # Always call open without considering dependencies being up to date\n+  FORCE:\n+\n+  build: $(build_xcode_project) $(copy_xcode_project)\n+\n+  open: $(open_xcode_project)\n+\n+  all: $(TARGETS)\n+else\n+  build:\n+  open:\n+  all:\n+\t$(info Xcode projects are only supported on macOS)\n+endif\n+\n+.PHONY: default all build open\n","filename":"make\/ide\/xcode\/hotspot\/CreateXcodeProject.gmk","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,41 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Bucket\n+   type = \"4\"\n+   version = \"2.0\">\n+   <Breakpoints>\n+      <BreakpointProxy\n+         BreakpointExtensionID = \"Xcode.Breakpoint.SymbolicBreakpoint\">\n+         <BreakpointContent\n+            shouldBeEnabled = \"Yes\"\n+            ignoreCount = \"0\"\n+            continueAfterRunningActions = \"Yes\"\n+            symbolName = \"load_jimage_library\"\n+            moduleName = \"libjvm.dylib\">\n+            <Actions>\n+               <BreakpointActionProxy\n+                  ActionExtensionID = \"Xcode.BreakpointAction.DebuggerCommand\">\n+                  <ActionContent\n+                     consoleCommand = \"process handle -n true -p true -s false SIGSEGV SIGBUS SIGUSR2\">\n+                  <\/ActionContent>\n+               <\/BreakpointActionProxy>\n+            <\/Actions>\n+            <Locations>\n+               <Location\n+                  shouldBeEnabled = \"Yes\"\n+                  ignoreCount = \"0\"\n+                  continueAfterRunningActions = \"No\"\n+                  symbolName = \"ClassLoader::load_jimage_library()\"\n+                  moduleName = \"libjvm.dylib\"\n+                  usesParentBreakpointCondition = \"Yes\"\n+                  timestampString = \"0\"\n+                  startingColumnNumber = \"0\"\n+                  endingColumnNumber = \"0\"\n+                  startingLineNumber = \"0\"\n+                  endingLineNumber = \"0\"\n+                  offsetFromSymbolStart = \"0\">\n+               <\/Location>\n+            <\/Locations>\n+         <\/BreakpointContent>\n+      <\/BreakpointProxy>\n+   <\/Breakpoints>\n+<\/Bucket>\n","filename":"make\/ide\/xcode\/hotspot\/data\/Breakpoints_v2.xcbkptlist.template","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \"YES\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"YES\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-version\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/jvm.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,207 @@\n+\/\/ !$*UTF8*$!\n+{\n+\tarchiveVersion = 1;\n+\tclasses = {\n+\t};\n+\tobjectVersion = 48;\n+\tobjects = {\n+\n+\/* Begin PBXBuildFile section *\/\n+TEMPLATE_PBXBUILDFILE\n+\/* End PBXBuildFile section *\/\n+\n+\/* Begin PBXFileReference section *\/\n+\t\tD60000000000000000000003 \/* script_before.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_before.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000002 \/* script_after.sh *\/ = {isa = PBXFileReference; lastKnownFileType = text.script.sh; path = script_after.sh; sourceTree = \"<group>\"; };\n+\t\tD60000000000000000000006 \/* libjvm.dylib *\/ = {isa = PBXFileReference; explicitFileType = \"compiled.mach-o.dylib\"; includeInIndex = 0; path = libjvm.dylib; sourceTree = BUILT_PRODUCTS_DIR; };\n+TEMPLATE_PBXFILEREFERENCE\n+\/* End PBXFileReference section *\/\n+\n+\/* Begin PBXGroup section *\/\n+\t\tD60000000000000000000004 \/* scripts *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000003 \/* script_before.sh *\/,\n+\t\t\t\tD60000000000000000000002 \/* script_after.sh *\/,\n+\t\t\t);\n+\t\t\tname = scripts;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000005 \/* Products *\/ = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000006 \/* libjvm.dylib *\/,\n+\t\t\t);\n+\t\t\tname = Products;\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+\t\tD60000000000000000000001 = {\n+\t\t\tisa = PBXGroup;\n+\t\t\tchildren = (\n+\t\t\t\tD60000000000000000000004 \/* scripts *\/,\n+TEMPLATE_GROUP_GENSRC \/* gensrc *\/,\n+TEMPLATE_GROUP_SRC \/* src *\/,\n+TEMPLATE_GROUP_TEST \/* test *\/,\n+\t\t\t\tD60000000000000000000005 \/* Products *\/,\n+\t\t\t);\n+\t\t\tsourceTree = \"<group>\";\n+\t\t};\n+TEMPLATE_GROUPS\n+\/* End PBXGroup section *\/\n+\n+\/* Begin PBXNativeTarget section *\/\n+\t\tD60000000000000000000000 \/* jvm *\/ = {\n+\t\t\tisa = PBXNativeTarget;\n+\t\t\tbuildConfigurationList = D6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/;\n+\t\t\tbuildPhases = (\n+\t\t\t\tD60000000000000000000007 \/* Run script_before *\/,\n+\t\t\t\tD60000000000000000000008 \/* Sources *\/,\n+\t\t\t\tD6000000000000000000000A \/* Run script_after *\/,\n+\t\t\t);\n+\t\t\tbuildRules = (\n+\t\t\t);\n+\t\t\tdependencies = (\n+\t\t\t);\n+\t\t\tname = jvm;\n+\t\t\tproductName = jvm;\n+\t\t\tproductReference = D60000000000000000000006 \/* libjvm.dylib *\/;\n+\t\t\tproductType = \"com.apple.product-type.library.dynamic\";\n+\t\t};\n+\/* End PBXNativeTarget section *\/\n+\n+\/* Begin PBXProject section *\/\n+\t\tD60000000000000000000010 \/* Project object *\/ = {\n+\t\t\tisa = PBXProject;\n+\t\t\tattributes = {\n+\t\t\t\tLastUpgradeCheck = 0900;\n+\t\t\t\tORGANIZATIONNAME = Oracle;\n+\t\t\t\tTargetAttributes = {\n+\t\t\t\t\tD60000000000000000000000 = {\n+\t\t\t\t\t\tCreatedOnToolsVersion = 9.0;\n+\t\t\t\t\t\tProvisioningStyle = Automatic;\n+\t\t\t\t\t};\n+\t\t\t\t};\n+\t\t\t};\n+\t\t\tbuildConfigurationList = D6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/;\n+\t\t\tcompatibilityVersion = \"Xcode 8.0\";\n+\t\t\tdevelopmentRegion = en;\n+\t\t\thasScannedForEncodings = 0;\n+\t\t\tknownRegions = (\n+\t\t\t\ten,\n+\t\t\t);\n+\t\t\tmainGroup = D60000000000000000000001;\n+\t\t\tproductRefGroup = D60000000000000000000005 \/* Products *\/;\n+\t\t\tprojectDirPath = \"\";\n+\t\t\tprojectRoot = \"\";\n+\t\t\ttargets = (\n+\t\t\t\tD60000000000000000000000 \/* jvm *\/,\n+\t\t\t);\n+\t\t};\n+\/* End PBXProject section *\/\n+\n+\/* Begin PBXShellScriptBuildPhase section *\/\n+\t\tD60000000000000000000007 \/* Run script_before *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_before\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_before.sh;\\n\";\n+\t\t};\n+\t\tD6000000000000000000000A \/* Run script_after *\/ = {\n+\t\t\tisa = PBXShellScriptBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+\t\t\t);\n+\t\t\tinputPaths = (\n+\t\t\t);\n+\t\t\tname = \"Run script_after\";\n+\t\t\toutputPaths = (\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t\tshellPath = \/bin\/sh;\n+\t\t\tshellScript = \"cd $PROJECT_DIR;\\ntime .\/script_after.sh;\\n\";\n+\t\t};\n+\/* End PBXShellScriptBuildPhase section *\/\n+\n+\/* Begin PBXSourcesBuildPhase section *\/\n+\t\tD60000000000000000000008 \/* Sources *\/ = {\n+\t\t\tisa = PBXSourcesBuildPhase;\n+\t\t\tbuildActionMask = 2147483647;\n+\t\t\tfiles = (\n+TEMPLATE_PBXSOURCESSBUILDPHASE\n+\t\t\t);\n+\t\t\trunOnlyForDeploymentPostprocessing = 0;\n+\t\t};\n+\/* End PBXSourcesBuildPhase section *\/\n+\n+\/* Begin XCBuildConfiguration section *\/\n+\t\tD6000000000000000000000B \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tALWAYS_SEARCH_USER_PATHS = YES;\n+\t\t\t\tCLANG_CXX_LANGUAGE_STANDARD = \"gnu++14\";\n+\t\t\t\tCODE_SIGN_IDENTITY = \"-\";\n+\t\t\t\tCONFIGURATION_BUILD_DIR = build\/jdk\/lib\/server;\n+\t\t\t\tCONFIGURATION_TEMP_DIR = build;\n+\t\t\t\tCOPY_PHASE_STRIP = NO;\n+\t\t\t\tDEBUG_INFORMATION_FORMAT = \"dwarf-with-dsym\";\n+\t\t\t\tMTL_ENABLE_DEBUG_INFO = NO;\n+\t\t\t\tOBJROOT = build;\n+\t\t\t\tONLY_ACTIVE_ARCH = YES;\n+\t\t\t\tSDKROOT = macosx;\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\t\tD6000000000000000000000D \/* Release *\/ = {\n+\t\t\tisa = XCBuildConfiguration;\n+\t\t\tbuildSettings = {\n+\t\t\t\tCONFIGURATION_BUILD_DIR = \"$(BUILD_DIR)\";\n+\t\t\t\tEXECUTABLE_PREFIX = lib;\n+\t\t\t\tFRAMEWORK_SEARCH_PATHS = (\n+TEMPLATE_FRAMEWORK_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t\tOTHER_CFLAGS = (\n+TEMPLATE_OTHER_CFLAGS\n+\t\t\t\t);\n+\t\t\t\tOTHER_LDFLAGS = (\n+TEMPLATE_OTHER_LDFLAGS\n+\t\t\t\t);\n+\t\t\t\tPRODUCT_NAME = \"$(TARGET_NAME)\";\n+\t\t\t\tSKIP_INSTALL = YES;\n+\t\t\t\tSYMROOT = build\/jdk\/lib\/server;\n+\t\t\t\tUSER_HEADER_SEARCH_PATHS = (\n+TEMPLATE_USER_HEADER_SEARCH_PATHS\n+\t\t\t\t);\n+\t\t\t};\n+\t\t\tname = Release;\n+\t\t};\n+\/* End XCBuildConfiguration section *\/\n+\n+\/* Begin XCConfigurationList section *\/\n+\t\tD6000000000000000000000E \/* Build configuration list for PBXProject \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000B \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\t\tD6000000000000000000000F \/* Build configuration list for PBXNativeTarget \"jvm\" *\/ = {\n+\t\t\tisa = XCConfigurationList;\n+\t\t\tbuildConfigurations = (\n+\t\t\t\tD6000000000000000000000D \/* Release *\/,\n+\t\t\t);\n+\t\t\tdefaultConfigurationIsVisible = 0;\n+\t\t\tdefaultConfigurationName = Release;\n+\t\t};\n+\/* End XCConfigurationList section *\/\n+\t};\n+\trootObject = D60000000000000000000010 \/* Project object *\/;\n+}\n","filename":"make\/ide\/xcode\/hotspot\/data\/project.pbxproj.template","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,112 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<Scheme\n+   LastUpgradeVersion = \"0900\"\n+   version = \"1.3\">\n+   <BuildAction\n+      parallelizeBuildables = \"YES\"\n+      buildImplicitDependencies = \"YES\">\n+      <BuildActionEntries>\n+         <BuildActionEntry\n+            buildForTesting = \"YES\"\n+            buildForRunning = \" NO\"\n+            buildForProfiling = \"NO\"\n+            buildForArchiving = \"NO\"\n+            buildForAnalyzing = \"NO\">\n+            <BuildableReference\n+               BuildableIdentifier = \"primary\"\n+               BlueprintIdentifier = \"D60000000000000000000000\"\n+               BuildableName = \"libjvm.dylib\"\n+               BlueprintName = \"jvm\"\n+               ReferencedContainer = \"container:hotspot.xcodeproj\">\n+            <\/BuildableReference>\n+         <\/BuildActionEntry>\n+      <\/BuildActionEntries>\n+   <\/BuildAction>\n+   <TestAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\">\n+      <Testables>\n+      <\/Testables>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/TestAction>\n+   <LaunchAction\n+      buildConfiguration = \"Release\"\n+      selectedDebuggerIdentifier = \"Xcode.DebuggerFoundation.Debugger.LLDB\"\n+      selectedLauncherIdentifier = \"Xcode.DebuggerFoundation.Launcher.LLDB\"\n+      language = \"\"\n+      launchStyle = \"0\"\n+      useCustomWorkingDirectory = \"NO\"\n+      ignoresPersistentStateOnLaunch = \"NO\"\n+      debugDocumentVersioning = \"YES\"\n+      debugServiceExtension = \"internal\"\n+      allowLocationSimulation = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+      <CommandLineArguments>\n+         <CommandLineArgument\n+            argument = \"-jar TEMPLATE_JDK_PATH\/build\/jdk\/demo\/jfc\/J2Ddemo\/J2Ddemo.jar\"\n+            isEnabled = \"YES\">\n+         <\/CommandLineArgument>\n+      <\/CommandLineArguments>\n+      <EnvironmentVariables>\n+         <EnvironmentVariable\n+            key = \"DYLD_PRINT_ENV\"\n+            value = \"1\"\n+            isEnabled = \"YES\">\n+         <\/EnvironmentVariable>\n+      <\/EnvironmentVariables>\n+      <AdditionalOptions>\n+      <\/AdditionalOptions>\n+   <\/LaunchAction>\n+   <ProfileAction\n+      buildConfiguration = \"Release\"\n+      shouldUseLaunchSchemeArgsEnv = \"YES\"\n+      savedToolIdentifier = \"\"\n+      useCustomWorkingDirectory = \"NO\"\n+      debugDocumentVersioning = \"YES\">\n+      <PathRunnable\n+         runnableDebuggingMode = \"0\"\n+         FilePath = \"TEMPLATE_JDK_PATH\/build\/jdk\/bin\/java\">\n+      <\/PathRunnable>\n+      <MacroExpansion>\n+         <BuildableReference\n+            BuildableIdentifier = \"primary\"\n+            BlueprintIdentifier = \"D60000000000000000000000\"\n+            BuildableName = \"libjvm.dylib\"\n+            BlueprintName = \"jvm\"\n+            ReferencedContainer = \"container:hotspot.xcodeproj\">\n+         <\/BuildableReference>\n+      <\/MacroExpansion>\n+   <\/ProfileAction>\n+   <AnalyzeAction\n+      buildConfiguration = \"Release\">\n+   <\/AnalyzeAction>\n+   <ArchiveAction\n+      buildConfiguration = \"Release\"\n+      revealArchiveInOrganizer = \"YES\">\n+   <\/ArchiveAction>\n+<\/Scheme>\n","filename":"make\/ide\/xcode\/hotspot\/data\/runJ2Demo.xcscheme.template","additions":112,"deletions":0,"binary":false,"changes":112,"status":"added"},{"patch":"@@ -0,0 +1,34 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_after.sh\"\n+\n+readonly JDK_LIB_PATH=\"build\/jdk\/lib\/server\/libjvm.dylib\";\n+\n+if [ ! -f ${JDK_LIB_PATH} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${JDK_LIB_PATH}, the build failed!?\";\n+    exit 1;\n+}\n+fi\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_after.sh","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,67 @@\n+#!\/bin\/bash\n+#\n+# Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+#\n+# This code is free software; you can redistribute it and\/or modify it\n+# under the terms of the GNU General Public License version 2 only, as\n+# published by the Free Software Foundation.\n+#\n+# This code is distributed in the hope that it will be useful, but WITHOUT\n+# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# version 2 for more details (a copy is included in the LICENSE file that\n+# accompanied this code).\n+#\n+# You should have received a copy of the GNU General Public License version\n+# 2 along with this work; if not, write to the Free Software Foundation,\n+# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+#\n+# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+# or visit www.oracle.com if you need additional information or have any\n+# questions.\n+#\n+\n+echo \"running script_before.sh\"\n+\n+readonly JDK_BUILD_PATH=\"..\";\n+readonly JAVAC_LOCATE_PATTERN=\"images\/jdk\/bin\/javac\";\n+readonly HOTSPOT_TOUCH_FILE=\"..\/..\/..\/src\/hotspot\/os\/posix\/jvm_posix.cpp\";\n+\n+echo \">>>>>>> Making a copy of JDK ...\";\n+\n+javac_file_array=( $(find ${JDK_BUILD_PATH} | grep ${JAVAC_LOCATE_PATTERN}) );\n+javac_file=${javac_file_array[0]};\n+if [ -z ${javac_file} ] ; then\n+{\n+  echo \">>>>>>>   ERROR: could not locate ${JAVAC_LOCATE_PATTERN} (did you remember to do \\\"make images\\\"?)\";\n+  exit 1;\n+}\n+fi\n+\n+jdk_build_path=$(dirname $(dirname ${javac_file}));\n+if [ ! -f \"build\/${JAVAC_LOCATE_PATTERN}\" ] ; then\n+{\n+  echo \">>>>>>>   Copying jdk over...\";\n+  rsync -a \"${jdk_build_path}\" \"build\/\";\n+}\n+fi\n+\n+# the following files will be supplied by the Xcode build\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib\";\n+rm -rf \"build\/jdk\/lib\/server\/libjvm.dylib.dSYM\";\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Touching ${HOTSPOT_TOUCH_FILE} to force HotspotVM rebuilt\";\n+if [ ! -f ${HOTSPOT_TOUCH_FILE} ] ; then\n+{\n+    echo \">>>>>>>   Cannot find ${HOTSPOT_TOUCH_FILE}\";\n+    exit 1;\n+}\n+fi\n+touch ${HOTSPOT_TOUCH_FILE};\n+\n+echo \">>>>>>> DONE\";\n+\n+echo \">>>>>>> Xcode should be building the HotspotVM now...\";\n","filename":"make\/ide\/xcode\/hotspot\/data\/script_before.sh","additions":67,"deletions":0,"binary":false,"changes":67,"status":"added"},{"patch":"@@ -0,0 +1,291 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public class DiskFile extends LinkedHashMap<Path, DiskFile> implements Comparable<DiskFile> {\n+    \/\/ xcode id ex: D50000000000000000000000\n+    private static long xcodeIdCount = 0xF0000001;\n+    private final Path path;\n+    private final boolean directory;\n+    private final String xcodeId;\n+    private final String xcodeId2;\n+    private Iterable<String> compilerFlags;\n+\n+    public DiskFile(String path, boolean directory) {\n+        this(stringToPath(path), directory);\n+    }\n+\n+    private DiskFile(Path path, boolean directory) {\n+        this.path = path;\n+        this.directory = directory;\n+        this.compilerFlags = null;\n+        this.xcodeId = getNextXcodeId();\n+        this.xcodeId2 = getNextXcodeId();\n+    }\n+\n+    private static Path stringToPath(String string) {\n+        if (string != null) {\n+            return new File(string).toPath();\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private static Path clipPath(Path path, String clip) {\n+        return clipPath(path.toString(), clip);\n+    }\n+\n+    private static Path clipPath(String path, String clip) {\n+        String subpath = path;\n+        if (path.contains(clip)) {\n+            subpath = clip;\n+        }\n+        int index = path.indexOf(subpath);\n+        return stringToPath(path.substring(index));\n+    }\n+\n+    private String getNextXcodeId() {\n+        String id = \"D5FFFFFF\" + Long.toHexString(xcodeIdCount).toUpperCase(Locale.ROOT);\n+        xcodeIdCount++;\n+\n+        return id;\n+    }\n+\n+    private String getPath() {\n+        return this.path.toString();\n+    }\n+\n+    public boolean isDirectory() {\n+        return this.directory;\n+    }\n+\n+    public void markAsCompiled(List<String> compilerFlags) {\n+        this.compilerFlags = compilerFlags;\n+    }\n+\n+    private boolean isCompiled() {\n+        return (this.compilerFlags != null);\n+    }\n+\n+    public String getXcodeId() {\n+        return this.xcodeId;\n+    }\n+\n+    public String generatePbxSourcesBuildPhase() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String fileName = getFileName();\n+            string += String.format(\"        %s \/* %s in Sources *\/,\\n\", this.xcodeId2, fileName);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxSourcesBuildPhase();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    \/\/ D5FFFFFFFFFFFFFFF0006506 \/* vm_version.cpp in Sources *\/ = {isa = PBXBuildFile; fileRef = D5FFFFFFFFFFFFFFF0006505 \/* vm_version.cpp *\/; settings = {COMPILER_FLAGS = HEREHERE; }; };\n+    public String generatePbxBuildFile() {\n+        String string = \"\";\n+        if (isCompiled()) {\n+            String flagsString = \"\";\n+            for (String flag : this.compilerFlags) {\n+                flagsString += flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \" \";\n+            }\n+            String fileName = getFileName();\n+            string += String.format(\"    %s \/* %s in Sources *\/ = {isa = PBXBuildFile; fileRef = %s \/* %s *\/; settings = {COMPILER_FLAGS = \\\"%s\\\"; }; };\\n\", this.xcodeId2, fileName, this.xcodeId, fileName, flagsString);\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxBuildFile();\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxFileReference(String relativePathToRoot) {\n+        String string = \"\";\n+        if (!isDirectory()) {\n+            String fileName = getFileName();\n+            String suffix = getFileNameSuffix();\n+            string += String.format(\"    %s \/* %s *\/ = {isa = PBXFileReference; fileEncoding = 4; lastKnownFileType = %s%s; name = %s; path = \\\"%s%s\\\"; sourceTree = \\\"<group>\\\"; };\\n\", this.xcodeId, fileName, fileName, suffix, fileName, relativePathToRoot, getPath());\n+        } else if (isDirectory()) {\n+            for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+                DiskFile file = entry.getValue();\n+                string += file.generatePbxFileReference(relativePathToRoot);\n+            }\n+        }\n+        return string;\n+    }\n+\n+    public String generatePbxGroup() {\n+        String string = String.format(\"    %s \/* %s *\/ = {\\n      isa = PBXGroup;\\n      children = (\\n\", this.xcodeId, getFileName());\n+\n+        Set<DiskFile> sortedSet = new TreeSet<>(values());\n+\n+        for (DiskFile file : sortedSet) {\n+            string += String.format(\"        %s \/* %s *\/,\\n\", file.getXcodeId(), file.getFileName());\n+        }\n+        string += String.format(\"      );\\n      name = %s;\\n      sourceTree = \\\"<group>\\\";\\n    };\\n\", getFileName());\n+\n+        for (DiskFile file : sortedSet) {\n+            if (file.isDirectory()) {\n+                string += file.generatePbxGroup();\n+            }\n+        }\n+\n+        return string;\n+    }\n+\n+    private ArrayList<DiskFile> getFiles(ArrayList<DiskFile> array) {\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.isDirectory()) {\n+                array.add(file);\n+                array = file.getFiles(array);\n+            } else {\n+                array.add(file);\n+            }\n+        }\n+        return array;\n+    }\n+\n+    public ArrayList<DiskFile> getFiles() {\n+        return getFiles(new ArrayList<>());\n+    }\n+\n+    public String getFilePath() {\n+        return this.path.toString();\n+    }\n+\n+    private String getFileName() {\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            return fileName.toString();\n+        } else {\n+            return this.path.toString();\n+        }\n+    }\n+\n+    private String getFileNameNoSuffix() {\n+        String string;\n+        Path fileName = this.path.getFileName();\n+        if (fileName != null) {\n+            string = fileName.toString();\n+            int index = string.indexOf('.');\n+            if (index >= 0) {\n+                string = string.substring(0, index);\n+            }\n+        } else {\n+            string = this.path.toString();\n+        }\n+        return string;\n+    }\n+\n+    private String getFileNameSuffix() {\n+        String fileName = getFileName();\n+        int index = fileName.indexOf('.');\n+        if (index >= 0) {\n+            return fileName.substring(index);\n+        } else {\n+            return \"\";\n+        }\n+    }\n+\n+    public DiskFile getChild(String fileName) {\n+        DiskFile child = null;\n+        for (Map.Entry<Path, DiskFile> entry : entrySet()) {\n+            DiskFile file = entry.getValue();\n+            if (file.getFileName().equals(fileName)) {\n+                child = entry.getValue();\n+                break;\n+            } else if (file.isDirectory()) {\n+                child = file.getChild(fileName);\n+                if (child != null) {\n+                    break;\n+                }\n+            }\n+        }\n+        return child;\n+    }\n+\n+    private DiskFile getParent(Path path) {\n+        Path pathParent = path.getParent();\n+        DiskFile parent = get(pathParent);\n+        if (parent == null) {\n+            if (this.path.equals(pathParent)) {\n+                parent = this;\n+            } else {\n+                parent = getParent(pathParent).get(pathParent);\n+            }\n+            parent.putIfAbsent(path, new DiskFile(path, true));\n+        }\n+        return parent;\n+    }\n+\n+    public void addFile(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.put(path, new DiskFile(path, false));\n+    }\n+\n+    public void addDirectory(Path path, String clip) {\n+        path = clipPath(path, clip);\n+        DiskFile parent = getParent(path);\n+        parent.putIfAbsent(path, new DiskFile(path, true));\n+    }\n+\n+    @Override\n+    public int compareTo(DiskFile file) {\n+        \/\/ \".hpp\", then \".inline.hpp\", then \".cpp\"\n+        int equal = getFileNameNoSuffix().compareTo(file.getFileNameNoSuffix());\n+        if (equal == 0) {\n+            String suffix1 = getFileNameSuffix();\n+            String suffix2 = file.getFileNameSuffix();\n+            if (!suffix1.equals(\".inline.hpp\") && !suffix2.equals(\".inline.hpp\")) {\n+                \/\/ .hpp before .cpp\n+                equal = -(getFileNameSuffix().compareTo(file.getFileNameSuffix()));\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".hpp\")) {\n+                return 1;\n+            } else if (suffix1.equals(\".inline.hpp\") && suffix2.equals(\".cpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".hpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return -1;\n+            } else if (suffix1.equals(\".cpp\") && suffix2.equals(\".inline.hpp\")) {\n+                return 1;\n+            }\n+        }\n+        return equal;\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/DiskFile.java","additions":291,"deletions":0,"binary":false,"changes":291,"status":"added"},{"patch":"@@ -0,0 +1,754 @@\n+\/*\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.FileSystemLoopException;\n+import java.nio.file.FileVisitResult;\n+import java.nio.file.FileVisitor;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.attribute.BasicFileAttributes;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+public final class XcodeProjectMaker {\n+    private static final String JDK_SCRIPT_TOKEN_1 = \"configure\";\n+    private static final String JDK_SCRIPT_TOKEN_2 = \".jcheck\";\n+    private static final String COMPILER_LINE_HEADER = \"-I\";\n+    private static final String COMPILER_IFRAMEWORK = \"-iframework\";\n+    private static final String COMPILER_FFRAMEWORK = \"-F\";\n+    private static final String SRC_HOTSPOT_PATH = \"\/src\/hotspot\";\n+    private static final String TEST_HOTSPOT_PATH = \"\/test\/hotspot\/gtest\";\n+    private static final String ALIAS_JAVA_OLD = \"java_old.sh\";\n+    private static final String ALIAS_JAVA_NEW = \"java_new.sh\";\n+    private static final String JDK_BIN_JAVA = \"\/jdk\/bin\/java\";\n+    private static final String FILE_TOKEN = \"\\\"file\\\": \";\n+    private static final String COMMAND_TOKEN = \"\\\"command\\\": \";\n+    private static final String QUOTE_START_TOKEN = \"'\\\\\\\"\";\n+    private static final String QUOTE_END_TOKEN = \"\\\\\\\"'\";\n+    private static final String VERSION = \"2.0.0\";\n+    private static final String EXCLUDE_PARSE_TOKEN_1 = \"gtest\";\n+    private static final String TEMPLATE_FRAMEWORK_SEARCH_PATHS = \"TEMPLATE_FRAMEWORK_SEARCH_PATHS\";\n+    private static final String TEMPLATE_OTHER_CFLAGS = \"TEMPLATE_OTHER_CFLAGS\";\n+    private static final String TEMPLATE_OTHER_LDFLAGS = \"TEMPLATE_OTHER_LDFLAGS\";\n+    private static final String TEMPLATE_USER_HEADER_SEARCH_PATHS = \"TEMPLATE_USER_HEADER_SEARCH_PATHS\";\n+    private static final String TEMPLATE_GROUP_GENSRC = \"TEMPLATE_GROUP_GENSRC\";\n+    private static final String TEMPLATE_GROUP_SRC = \"TEMPLATE_GROUP_SRC\";\n+    private static final String TEMPLATE_GROUP_TEST = \"TEMPLATE_GROUP_TEST\";\n+    private static final String TEMPLATE_GROUPS = \"TEMPLATE_GROUPS\";\n+    private static final String TEMPLATE_PBXBUILDFILE = \"TEMPLATE_PBXBUILDFILE\";\n+    private static final String TEMPLATE_PBXFILEREFERENCE = \"TEMPLATE_PBXFILEREFERENCE\";\n+    private static final String TEMPLATE_PBXSOURCESSBUILDPHASE = \"TEMPLATE_PBXSOURCESSBUILDPHASE\";\n+    private static final String TEMPLATE_JDK_PATH = \"TEMPLATE_JDK_PATH\";\n+    private static final String HOTSPOT_PBXPROJ = \"hotspot.xcodeproj\";\n+    private static final String PBXPROJ = \"project.pbxproj\";\n+    private static final String XCSAHAREDDATA = \"xcshareddata\";\n+    private static final String XCSCHEMES = \"xcschemes\";\n+    private static final String JVM_XCSCHEME = \"jvm.xcscheme\";\n+    private static final String J2D_XCSCHEME = \"runJ2Demo.xcscheme\";\n+    private static final String XCDEBUGGER = \"xcdebugger\";\n+    private static final String XCBKPTLIST = \"Breakpoints_v2.xcbkptlist\";\n+    private static final String TEMPLATE_PBXPROJ = PBXPROJ + \".template\";\n+    private static final String TEMPLATE_JVM_XCSCHEME = JVM_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_J2D_XCSCHEME = J2D_XCSCHEME + \".template\";\n+    private static final String TEMPLATE_XCBKPTLIST = XCBKPTLIST + \".template\";\n+    private static final String[] EXCLUDE_FILES_PREFIX = {\".\"};\n+    private static final String[] EXCLUDE_FILES_POSTFIX = {\".log\", \".cmdline\"};\n+    private static final String[] COMPILER_FLAGS_INCLUDE = {\"-m\", \"-f\", \"-D\", \"-W\"};\n+    private static final String[] COMPILER_FLAGS_IS = {\"-g\", \"-Os\", \"-0\"};\n+    private static final String[] COMPILER_FLAGS_EXCLUDE = {\"-DTHIS_FILE\", \"-DGTEST_OS_MAC\", \"-mmacosx-version-min\", \"-Werror\"}; \/\/ \"-Werror\" causes Xcode to stop compiling\n+    private static final int EXIT4 = -4;\n+    private static final int EXIT5 = -5;\n+    private static final int EXIT6 = -6;\n+    private static final int EXIT7 = -7;\n+\n+    private final HashMap<String, ArrayList<String>> compiledFiles = new HashMap<>();\n+    private final TreeSet<String> compilerFlags = new TreeSet<>();\n+    private List<String> linkerFlags = List.of();\n+    private final TreeSet<String> headerPaths = new TreeSet<>();\n+    private final boolean debugLog;\n+    private String projectMakerDataPath = null;\n+    private String generatedHotspotPath = null;\n+    private String iframework = null;\n+    private String fframework = null;\n+    private DiskFile rootGensrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootSrc = new DiskFile(\"\/\", true);\n+    private DiskFile rootTest = new DiskFile(\"\/\", true);\n+\n+    public XcodeProjectMaker(boolean debugLog) {\n+        this.debugLog = debugLog;\n+    }\n+\n+    public static void main(String[] args) {\n+        String workspaceRoot = args[0];\n+        String outputDir = args[1];\n+        String pathToProjectMakerData = args[2];\n+        String pathToCompileCommands = args[3];\n+        String pathToLinkerOptionsFile = args[4];\n+        String linkerOptionsString = readFile(pathToLinkerOptionsFile);\n+        boolean debugLog = args.length > 5 && args[5].equals(\"-d\");\n+\n+        File xcodeFolder = new File(outputDir);\n+        xcodeFolder.mkdirs();\n+        String workspaceRootPathFromOutputDir = findRelativePathToWorkspaceRoot(outputDir);\n+\n+        if (debugLog) {\n+            System.out.println();\n+            System.out.println(\"Version \" + VERSION);\n+            System.out.println();\n+            System.out.println(\"       Path to workspace root is \\\"\" + workspaceRoot + \"\\\"\");\n+            System.out.println(\"Path to compile commands file is \\\"\" + pathToCompileCommands + \"\\\"\");\n+            System.out.println(\" Xcode project will be placed in \\\"\" + outputDir + \"\\\"\");\n+            System.out.println();\n+        }\n+\n+        XcodeProjectMaker maker = new XcodeProjectMaker(debugLog);\n+        maker.parseHotspotCompileCommands(pathToCompileCommands);\n+        maker.linkerFlags = List.of(linkerOptionsString.split(\" \"));\n+        maker.projectMakerDataPath = pathToProjectMakerData;\n+\n+        maker.printLogDetails();\n+\n+        maker.prepareFiles(workspaceRoot);\n+        maker.makeXcodeProj(outputDir, workspaceRootPathFromOutputDir);\n+\n+        String pathToBuild = getFileParent(outputDir);\n+        maker.makeAliases(outputDir, pathToBuild);\n+\n+        System.out.println();\n+        System.out.println(\"The Xcode project for hotspot was succesfully created\");\n+        System.out.println(\"It can be found in '\" + outputDir + \"\/\" + HOTSPOT_PBXPROJ + \"'\");\n+        System.out.println();\n+    }\n+\n+    \/\/ find a path to what looks like jdk\n+    private static String findRelativePathToWorkspaceRoot(String root) {\n+        String pathToWorkspaceRoot = null;\n+        String path = root;\n+        boolean found1 = false;\n+        boolean found2 = false;\n+\n+        while (!found1 && !found2) {\n+            File folder = new File(path);\n+            File[] files = folder.listFiles();\n+            for (File file : files) {\n+                String fileName = file.toPath().getFileName().toString();\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_1)) {\n+                    found1 = true;\n+                }\n+                if (fileName.equals(JDK_SCRIPT_TOKEN_2)) {\n+                    found2 = true;\n+                }\n+                if (found1 && found2) {\n+                    break;\n+                }\n+            }\n+\n+            if (!found1 && !found2) {\n+                path = Paths.get(path).getParent().toString();\n+                if (pathToWorkspaceRoot == null) {\n+                    pathToWorkspaceRoot = \"..\";\n+                } else {\n+                    pathToWorkspaceRoot += \"\/..\";\n+                }\n+            }\n+        }\n+        return pathToWorkspaceRoot;\n+    }\n+\n+    private static String readFile(File file) {\n+        return readFile(file.toPath());\n+    }\n+\n+    private static String readFile(String path) {\n+        return readFile(Paths.get(path));\n+    }\n+\n+    private static String readFile(Path path) {\n+        try {\n+            return Files.readString(path);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            return null;\n+        }\n+    }\n+\n+    private static void writeFile(File file, String string) {\n+        writeFile(file.toPath(), string);\n+    }\n+\n+    private static void writeFile(Path path, String string) {\n+        try {\n+            Files.writeString(path, string);\n+        } catch (IOException e) {\n+            e.printStackTrace();\n+            System.exit(EXIT4);\n+        }\n+    }\n+\n+    private static boolean excludeFile(Path path) {\n+        return excludeFile(path.toString());\n+    }\n+\n+    private static boolean excludeFile(String string) {\n+        return excludeFile(string, null);\n+    }\n+\n+    private static boolean excludeFile(String string, String exclude) {\n+        if (exclude != null) {\n+            if (contains(string, exclude)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPrefix : EXCLUDE_FILES_PREFIX) {\n+            if (string.startsWith(excludeFilesPrefix)) {\n+                return true;\n+            }\n+        }\n+        for (String excludeFilesPostfix : EXCLUDE_FILES_POSTFIX) {\n+            if (string.endsWith(excludeFilesPostfix)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static boolean isExcludeCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String exclude : COMPILER_FLAGS_EXCLUDE) {\n+            if (string.contains(exclude)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        return flag;\n+    }\n+\n+    private static boolean isCompilerFlag(String string) {\n+        boolean flag = false;\n+        for (String include : COMPILER_FLAGS_INCLUDE) {\n+            if (string.startsWith(include)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        for (String is : COMPILER_FLAGS_IS) {\n+            if (string.equals(is)) {\n+                flag = true;\n+                break;\n+            }\n+        }\n+        if (isExcludeCompilerFlag(string)) {\n+            flag = false;\n+        }\n+        return flag;\n+    }\n+\n+    private static String strip(String string) {\n+        return string.substring(2, string.length() - 1);\n+    }\n+\n+    private static String strip(String string, String token) {\n+        int start = string.indexOf(token);\n+        int end = start + token.length();\n+        return strip(string.substring(end));\n+    }\n+\n+    private static boolean contains(String string, String token) {\n+        return ((string.length() >= token.length()) && (string.contains(token)));\n+    }\n+\n+    private static String getFileParent(String path) {\n+        return Paths.get(path).getParent().toString();\n+    }\n+\n+    private static String extractPath(String string, String from, String to) {\n+        String result = null;\n+        String[] tokens = string.split(\"\/\");\n+        int i = 0;\n+        for (; i < tokens.length; i++) {\n+            if (tokens[i].equals(from)) {\n+                result = \"\";\n+                break;\n+            }\n+        }\n+        for (; i < tokens.length; i++) {\n+            result += \"\/\" + tokens[i];\n+            if (tokens[i].equals(to)) {\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    private void extractCommonCompilerFlags() {\n+        \/\/ heuristic, find average count of number of flags used by each compiled file\n+        int countFiles = 0;\n+        int countFlags = 0;\n+\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            countFiles++;\n+            List<String> flags = entry.getValue();\n+            countFlags += flags.size();\n+        }\n+\n+        \/\/ when finding common flags, only consider files with this many flags\n+        int flagCutoff = (countFlags \/ countFiles) \/ 2;\n+\n+        \/\/ collect all flags\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                this.compilerFlags.addAll(flags);\n+            }\n+        }\n+\n+        \/\/ find flags to remove\n+        Set<String> removeFlags = new TreeSet<>();\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    if (!flags.contains(common)) {\n+                        removeFlags.add(common);\n+                    }\n+                }\n+            }\n+        }\n+\n+        \/\/ leave only common flags\n+        for (String flag : removeFlags) {\n+            this.compilerFlags.remove(flag);\n+        }\n+\n+        \/\/ remove common flags from each compiler file, leaving only the unique ones\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            List<String> flags = entry.getValue();\n+            if (flags.size() > flagCutoff) {\n+                for (String common : this.compilerFlags) {\n+                    flags.remove(common);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void extractCompilerFlags(String line) {\n+        boolean verboseCompilerTokens = false;\n+        String file = null;\n+        ArrayList<String> flags = null;\n+\n+        String[] commands = line.split(\",\");\n+        for (String command : commands) {\n+            if (contains(command, FILE_TOKEN)) {\n+                file = strip(command, FILE_TOKEN);\n+                \/\/verbose_compiler_tokens = Contains(file, \"vm_version.cpp\");\n+            } else if (contains(command, COMMAND_TOKEN)) {\n+                String tokens = strip(command, COMMAND_TOKEN);\n+                String[] arguments = tokens.split(\" \");\n+                if (arguments.length >= 3) {\n+                    flags = new ArrayList<>();\n+                    for (int a = 2; a < arguments.length; a++) {\n+                        String argument = arguments[a];\n+                        if (isCompilerFlag(argument)) {\n+                            \/\/ catch argument like -DVMTYPE=\\\"Minimal\\\"\n+                            if (contains(argument, \"\\\\\\\\\\\\\\\"\") && argument.endsWith(\"\\\\\\\\\\\\\\\"\")) {\n+                                \/\/ TODO: more robust fix needed here\n+                                argument = argument.replace(\"\\\\\", \"\");\n+                                argument = argument.replaceFirst(\"\\\"\", \"~.~\"); \/\/ temp token ~.~\n+                                argument = argument.replace(\"\\\"\", \"\\\\\\\"'\");\n+                                argument = argument.replace(\"~.~\", \"'\\\\\\\"\");\n+                            }\n+\n+                            \/\/ argument like -DHOTSPOT_VM_DISTRO='\\\"Java HotSpot(TM)\\\"'\n+                            \/\/ gets split up, so reconstruct as single string\n+                            if (contains(argument, QUOTE_START_TOKEN) && !argument.endsWith(QUOTE_END_TOKEN)) {\n+                                String fullArgument = argument;\n+                                do {\n+                                    ++a;\n+                                    argument = arguments[a];\n+                                    fullArgument = fullArgument + \" \" + argument;\n+                                } while (!argument.endsWith(QUOTE_END_TOKEN));\n+                                argument = fullArgument;\n+                            }\n+                            flags.add(argument);\n+                            if (verboseCompilerTokens) {\n+                                System.out.println(\"    FOUND COMPILER FLAG: \" + argument);\n+                            }\n+                        } else if (argument.startsWith(COMPILER_LINE_HEADER)) {\n+                            this.headerPaths.add(argument.substring(2));\n+                        } else if (argument.equals(COMPILER_IFRAMEWORK)) {\n+                            if (iframework == null) {\n+                                ++a;\n+                                this.iframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        } else if (argument.equals(COMPILER_FFRAMEWORK)) {\n+                            if (fframework == null) {\n+                                ++a;\n+                                this.fframework = arguments[a]; \/\/ gets the value, so skip it for the next loop\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if ((file != null) && (flags != null)) {\n+            this.compiledFiles.put(file, flags);\n+        } else {\n+            System.err.println(\" WARNING: extractCompilerFlags returns file:\" + file + \", flags:\" + flags);\n+        }\n+\n+        if (verboseCompilerTokens) {\n+            System.exit(0);\n+        }\n+    }\n+\n+    public void parseHotspotCompileCommands(String path) {\n+        String content = readFile(path);\n+        String[] parts = content.split(\"\\\\{\"); \/\/ }\n+\n+        int found = 0;\n+        for (String line : parts) {\n+            if (!contains(line, EXCLUDE_PARSE_TOKEN_1) && !line.startsWith(\"[\")) {\n+                extractCompilerFlags(line);\n+                found++;\n+            }\n+        }\n+        if (debugLog) {\n+            System.out.println(\"Found total of \" + found + \" files that make up the libjvm.dylib\");\n+        }\n+        extractCommonCompilerFlags();\n+\n+        \/\/ figure out \"gensrc\" folder\n+        \/\/ from: \"\/Users\/gerard\/Desktop\/jdk_test\/jdk10\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\/adfiles\/ad_x86_clone.cpp\"\n+        \/\/ to:   \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\"\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            if (file.contains(\"gensrc\")) {\n+                this.generatedHotspotPath = extractPath(file, \"build\", \"gensrc\");\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x64\/hotspot\/variant-server\/gensrc\";\n+                \/\/generatedHotspotPath = \"\/build\/macosx-x86_64-normal-server-fastdebug\/hotspot\/variant-server\/gensrc\";\n+            }\n+        }\n+    }\n+\n+    \/\/ https:\/\/docs.oracle.com\/javase\/tutorial\/displayCode.html?code=https:\/\/docs.oracle.com\/javase\/tutorial\/essential\/io\/examples\/Copy.java\n+    private DiskFile getHotspotFiles(DiskFile root, String workspaceRoot, String hotspotPath) {\n+        File file = new File(workspaceRoot + \"\/\" + hotspotPath);\n+        if (!file.exists()) {\n+            return null;\n+        }\n+\n+        try {\n+            final Path rootDir = Paths.get(workspaceRoot + hotspotPath);\n+            Files.walkFileTree(rootDir, new HotspotFileVisitor(root, hotspotPath));\n+        } catch (IOException ex) {\n+            System.err.println(\"ex: \" + ex);\n+        }\n+\n+        return root;\n+    }\n+\n+    public void prepareFiles(String workspaceRoot) {\n+        this.rootGensrc = getHotspotFiles(this.rootGensrc, workspaceRoot, this.generatedHotspotPath);\n+        this.rootSrc = getHotspotFiles(this.rootSrc, workspaceRoot, SRC_HOTSPOT_PATH);\n+        this.rootTest = getHotspotFiles(this.rootTest, workspaceRoot, TEST_HOTSPOT_PATH);\n+\n+        \/\/ make a copy of files from the log\n+        Set<String> logFiles = new TreeSet<>(this.compiledFiles.keySet());\n+\n+        int totalMarkedFiles = 0;\n+        DiskFile[] roots = { this.rootGensrc, this.rootSrc };\n+        for (DiskFile root : roots) {\n+            List<DiskFile> diskFiles = root.getFiles();\n+            for (DiskFile diskFile : diskFiles) {\n+                if (!diskFile.isDirectory()) {\n+                    String logFileProcessed = null;\n+                    String diskFilePath = diskFile.getFilePath();\n+                    for (String logFilePath : logFiles) {\n+                        if (contains(logFilePath, diskFilePath)) {\n+                            totalMarkedFiles++;\n+\n+                            logFileProcessed = logFilePath;\n+\n+                            \/\/ mark the file as needing compilation\n+                            diskFile.markAsCompiled(this.compiledFiles.get(logFilePath));\n+\n+                            \/\/ break early if found\n+                            break;\n+                        }\n+                    }\n+                    if (logFileProcessed != null) {\n+                        \/\/ remove the file, so we don't have to search through it again\n+                        logFiles.remove(logFileProcessed);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (this.compiledFiles.size() != totalMarkedFiles) {\n+            System.err.println(\"\\nError: was expecting to compile \" + this.compiledFiles.size() + \" files, but marked \" + totalMarkedFiles);\n+            for (String file : logFiles) {\n+                System.err.println(\"file: \" + file);\n+            }\n+            System.exit(EXIT5);\n+        }\n+\n+        if (!logFiles.isEmpty()) {\n+            System.err.println(\"\\nError: unprocessed files left over:\");\n+            for (String logFile : logFiles) {\n+                System.err.println(\"  \" + logFile);\n+            }\n+            System.exit(EXIT6);\n+        }\n+    }\n+\n+    public void printLogDetails() {\n+        if (!debugLog) return;\n+\n+        System.out.println(\"\\nFound \" + this.compilerFlags.size() + \" common compiler flags:\");\n+        for (String flag : this.compilerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nList of compiled files (each one uses common compiler flags plus extra ones as specified):\");\n+        int count = 1;\n+        for (Map.Entry<String, ArrayList<String>> entry : this.compiledFiles.entrySet()) {\n+            String file = entry.getKey();\n+            System.out.format(\"%4d: %s\\n\", (count), file);\n+            count++;\n+            List<String> flags = entry.getValue();\n+            for (String flag : flags) {\n+                System.out.println(\"        \" + flag);\n+            }\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.linkerFlags.size() + \" linker flags:\");\n+        for (String flag : this.linkerFlags) {\n+            System.out.println(\" \" + flag);\n+        }\n+\n+        System.out.println(\"\\nFound \" + this.headerPaths.size() + \" header paths:\");\n+        for (String header : this.headerPaths) {\n+            System.out.println(\" \" + header);\n+        }\n+\n+        System.out.println(\"\\nFrameworks:\");\n+        System.out.println(\" -iframework \" + iframework);\n+        System.out.println(\" -f \" + fframework);\n+    }\n+\n+    private String makeProjectPbxproj(String workspaceRootPathFromOutputDir, String string) {\n+        String cFlags = \"\";\n+        for (String flag : this.compilerFlags) {\n+            cFlags += \"          \\\"\" + flag.replace(\"\\\"\", \"\\\\\\\\\\\"\") + \"\\\",\\n\";\n+        }\n+        cFlags = cFlags.substring(0, cFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_CFLAGS, cFlags);\n+\n+        String ldFlags = \"\";\n+        for (String flag : this.linkerFlags) {\n+            ldFlags += \"          \\\"\" + flag + \"\\\",\\n\";\n+        }\n+        ldFlags = ldFlags.substring(0, ldFlags.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_OTHER_LDFLAGS, ldFlags);\n+\n+        String headerPaths = \"\";\n+        for (String header : this.headerPaths) {\n+            headerPaths += \"          \\\"\" + header + \"\\\",\\n\";\n+        }\n+        headerPaths = headerPaths.substring(0, headerPaths.length() - 2);\n+        string = string.replaceFirst(TEMPLATE_USER_HEADER_SEARCH_PATHS, headerPaths);\n+\n+        String frameworkPaths = \"\";\n+        if (fframework != null) {\n+            frameworkPaths += \"          \\\"\" + fframework + \"\\\"\\n\";\n+        }\n+        string = string.replaceFirst(TEMPLATE_FRAMEWORK_SEARCH_PATHS, frameworkPaths);\n+\n+        DiskFile gensrcFile = this.rootGensrc.getChild(\"gensrc\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_GENSRC, \"        \" + gensrcFile.getXcodeId());\n+\n+        DiskFile srcFile = this.rootSrc.getChild(\"src\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_SRC, \"        \" + srcFile.getXcodeId());\n+\n+        DiskFile testFile = this.rootTest.getChild(\"test\");\n+        string = string.replaceFirst(TEMPLATE_GROUP_TEST, \"        \" + testFile.getXcodeId());\n+\n+        String gensrcGroups = gensrcFile.generatePbxGroup();\n+        String srcGroups = srcFile.generatePbxGroup();\n+        String testGroups = testFile.generatePbxGroup();\n+        string = string.replaceFirst(TEMPLATE_GROUPS, gensrcGroups + srcGroups + testGroups);\n+\n+        String gensrcFiles = gensrcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String srcFiles = srcFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        String testFiles = testFile.generatePbxFileReference(workspaceRootPathFromOutputDir);\n+        string = string.replaceFirst(TEMPLATE_PBXFILEREFERENCE, gensrcFiles + srcFiles + testFiles);\n+\n+        String gensrcCompiled = gensrcFile.generatePbxBuildFile();\n+        String compiled = srcFile.generatePbxBuildFile();\n+        string = string.replaceFirst(TEMPLATE_PBXBUILDFILE, gensrcCompiled + compiled);\n+\n+        String gensrcBuilt = gensrcFile.generatePbxSourcesBuildPhase();\n+        String built = srcFile.generatePbxSourcesBuildPhase();\n+        string = string.replaceFirst(TEMPLATE_PBXSOURCESSBUILDPHASE, gensrcBuilt + built);\n+\n+        return string;\n+    }\n+\n+    private String makeTemplateXcscheme(String outputDir, String string) {\n+        string = string.replaceAll(TEMPLATE_JDK_PATH, outputDir);\n+\n+        return string;\n+    }\n+\n+    public void makeXcodeProj(String outputDir, String workspaceRootPathFromOutputDir) {\n+    \/*\n+     jvm.xcodeproj                     <-- folder\n+       project.pbxproj                 <-- file\n+       xcshareddata                    <-- folder\n+         xcschemes                     <-- folder\n+           jvm.xcscheme                <-- file\n+         xcdebugger                    <-- folder\n+           Breakpoints_v2.xcbkptlist   <-- file\n+     *\/\n+        File xcodeDir = new File(outputDir);\n+        File jvmXcodeprojDir = new File(xcodeDir, HOTSPOT_PBXPROJ);\n+        File projectPbxprojFile = new File(jvmXcodeprojDir, PBXPROJ);\n+        File xcshareddataDir = new File(jvmXcodeprojDir, XCSAHAREDDATA);\n+        File xcschemesDir = new File(xcshareddataDir, XCSCHEMES);\n+        File jvmXcschemeFile = new File(xcschemesDir, JVM_XCSCHEME);\n+        File j2DemoXcschemeFile = new File(xcschemesDir, J2D_XCSCHEME);\n+        File xcdebuggerDir = new File(xcshareddataDir, XCDEBUGGER);\n+        File jBreakpointsV2XcbkptlistFile = new File(xcdebuggerDir, XCBKPTLIST);\n+\n+        if (xcodeDir.exists()) {\n+            xcodeDir.delete();\n+        }\n+\n+        jvmXcodeprojDir.mkdirs();\n+        xcshareddataDir.mkdirs();\n+        xcschemesDir.mkdirs();\n+        xcdebuggerDir.mkdirs();\n+\n+        File dataDir = new File(projectMakerDataPath);\n+        File templateProjectPbxprojFile = new File(dataDir, TEMPLATE_PBXPROJ);\n+        File templateJvmXcschemeFile = new File(dataDir, TEMPLATE_JVM_XCSCHEME);\n+        File templateJ2DemoXcschemeFile = new File(dataDir, TEMPLATE_J2D_XCSCHEME);\n+        File templateJBreakpointsV2XcbkptlistFile = new File(dataDir, TEMPLATE_XCBKPTLIST);\n+\n+        String projectPbxprojString = readFile(templateProjectPbxprojFile);\n+        String jvmXcschemeString = readFile(templateJvmXcschemeFile);\n+        String j2DemoXcschemeString = readFile(templateJ2DemoXcschemeFile);\n+        String jBreakpointsV2XcbkptlistString = readFile(templateJBreakpointsV2XcbkptlistFile);\n+\n+        writeFile(projectPbxprojFile, makeProjectPbxproj(workspaceRootPathFromOutputDir, projectPbxprojString));\n+        writeFile(jvmXcschemeFile, makeTemplateXcscheme(outputDir, jvmXcschemeString));\n+        writeFile(j2DemoXcschemeFile, makeTemplateXcscheme(outputDir, j2DemoXcschemeString));\n+        writeFile(jBreakpointsV2XcbkptlistFile, jBreakpointsV2XcbkptlistString);\n+    }\n+\n+    public void makeAliases(String outputDir, String pathToBuild) {\n+        File xcodeDir = new File(outputDir);\n+        File jdkOldSh = new File(xcodeDir, ALIAS_JAVA_OLD);\n+        File jdkNewSh = new File(xcodeDir, ALIAS_JAVA_NEW);\n+\n+        writeFile(jdkOldSh, \"#!\/bin\/bash\\n\" + pathToBuild + JDK_BIN_JAVA + \" $@\");\n+        writeFile(jdkNewSh, \"#!\/bin\/bash\\n\" + outputDir + \"\/build\" + JDK_BIN_JAVA + \" $@\");\n+\n+        try {\n+            Set<PosixFilePermission> permissions = new HashSet<>();\n+            permissions.add(PosixFilePermission.OWNER_READ);\n+            permissions.add(PosixFilePermission.OWNER_WRITE);\n+            permissions.add(PosixFilePermission.OWNER_EXECUTE);\n+            permissions.add(PosixFilePermission.GROUP_READ);\n+            permissions.add(PosixFilePermission.OTHERS_READ);\n+            Files.setPosixFilePermissions(jdkOldSh.toPath(), permissions);\n+            Files.setPosixFilePermissions(jdkNewSh.toPath(), permissions);\n+        } catch (IOException ex) {\n+            System.err.println(\"Warning: unable to change file permissions\");\n+            System.err.println(ex);\n+        }\n+    }\n+\n+    private static class HotspotFileVisitor implements FileVisitor<Path> {\n+        private final DiskFile root;\n+        private final String hotspotPath;\n+\n+        public HotspotFileVisitor(DiskFile root, String hotspotPath) {\n+            this.root = root;\n+            this.hotspotPath = hotspotPath;\n+        }\n+\n+        @Override\n+        public FileVisitResult preVisitDirectory(Path path, BasicFileAttributes attrs) {\n+            if (excludeFile(path)) {\n+                return FileVisitResult.SKIP_SUBTREE;\n+            } else {\n+                \/\/ consider folders based on their names\n+                Path file = path.getFileName();\n+                if (!excludeFile(file)) {\n+                    root.addDirectory(path, hotspotPath);\n+                    return FileVisitResult.CONTINUE;\n+                } else {\n+                    \/\/ skip folders with names beginning with \".\", etc\n+                    return FileVisitResult.SKIP_SUBTREE;\n+                }\n+            }\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFile(Path path, BasicFileAttributes attrs) {\n+            Path file = path.getFileName();\n+            if (!excludeFile(file)) {\n+                \/\/System.err.println(path.toString());\n+                root.addFile(path, hotspotPath);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult postVisitDirectory(Path path, IOException exc) {\n+            return FileVisitResult.CONTINUE;\n+        }\n+\n+        @Override\n+        public FileVisitResult visitFileFailed(Path path, IOException exc) {\n+            if (exc instanceof FileSystemLoopException) {\n+                System.err.println(\"cycle detected: \" + path);\n+            } else {\n+                System.err.format(\"Unable to process: %s: %s\\n\", path, exc);\n+            }\n+            return FileVisitResult.CONTINUE;\n+        }\n+    }\n+}\n","filename":"make\/ide\/xcode\/hotspot\/src\/classes\/XcodeProjectMaker.java","additions":754,"deletions":0,"binary":false,"changes":754,"status":"added"},{"patch":"@@ -109,1 +109,2 @@\n-    private static final Pattern TAG_PATTERN = Pattern.compile(\"(?s)(.+ )?(?<chapter>[1-9][0-9]*)(?<section>[0-9.]*)( .*)?$\");\n+    \/\/ Note: Matches special cases like @jvms 6.5.checkcast\n+    private static final Pattern TAG_PATTERN = Pattern.compile(\"(?s)(.+ )?(?<chapter>[1-9][0-9]*)(?<section>[0-9a-z_.]*)( .*)?$\");\n","filename":"make\/jdk\/src\/classes\/build\/tools\/taglet\/JSpec.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-# Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,5 +54,0 @@\n-  define copy-and-chmod\n-\t$(install-file)\n-\t$(CHMOD) a+rx $@\n-  endef\n-\n@@ -61,1 +56,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCR, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCR, \\\n@@ -64,1 +59,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -66,1 +62,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_VCRUNTIME_1, \\\n+  $(eval $(call SetupCopyFiles, COPY_VCRUNTIME_1, \\\n@@ -69,1 +65,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -71,1 +68,1 @@\n-  $(eval $(call SetupCopyFiles,COPY_MSVCP, \\\n+  $(eval $(call SetupCopyFiles, COPY_MSVCP, \\\n@@ -74,1 +71,2 @@\n-      MACRO := copy-and-chmod))\n+      MACRO := copy-and-chmod-executable, \\\n+  ))\n@@ -83,1 +81,1 @@\n-        MACRO := copy-and-chmod, \\\n+        MACRO := copy-and-chmod-executable, \\\n@@ -136,1 +134,1 @@\n-\t$(foreach f,$(POLICY_SRC_LIST),$(CAT) $(f) >> $@.tmp;)\n+\t$(foreach f, $(POLICY_SRC_LIST), $(CAT) $(f) >> $@.tmp;)\n@@ -161,1 +159,1 @@\n-\t$(foreach f,$(DEF_POLICY_SRC_LIST),$(CAT) $(f) >> $@.tmp;)\n+\t$(foreach f, $(DEF_POLICY_SRC_LIST), $(CAT) $(f) >> $@.tmp;)\n","filename":"make\/modules\/java.base\/Copy.gmk","additions":13,"deletions":15,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-    DISABLED_WARNINGS_gcc_net_util_md.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_gcc_net_util_md.c := format-nonliteral unused-variable, \\\n@@ -49,1 +49,3 @@\n-    DISABLED_WARNINGS_clang_net_util_md.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_net_util_md.c := format-nonliteral \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_NetworkInterface.c := unused-function, \\\n@@ -59,1 +61,1 @@\n-    LIBS_aix := $(LIBDL),\\\n+    LIBS_aix := $(LIBDL), \\\n@@ -80,0 +82,2 @@\n+    DISABLED_WARNINGS_clang_Net.c := unused-function unused-variable, \\\n+    DISABLED_WARNINGS_clang_UnixNativeDispatcher.c := unused-variable, \\\n@@ -99,1 +103,2 @@\n-      DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations, \\\n+      DISABLED_WARNINGS_clang_KeystoreImpl.m := deprecated-declarations \\\n+          unused-but-set-variable unused-variable, \\\n@@ -119,0 +124,2 @@\n+      DISABLED_WARNINGS_gcc_jsig.c := unused-but-set-variable, \\\n+      DISABLED_WARNINGS_clang_jsig.c := unused-but-set-variable, \\\n@@ -172,0 +179,1 @@\n+      DISABLED_WARNINGS_gcc := implicit-function-declaration unused-variable, \\\n@@ -189,0 +197,1 @@\n+      DISABLED_WARNINGS_gcc := unused-variable, \\\n","filename":"make\/modules\/java.base\/Lib.gmk","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -282,7 +282,7 @@\n-$(eval $(call SetupGenBuffer,ByteBuffer,  $(X_BUF), type:=byte, BIN:=1))\n-$(eval $(call SetupGenBuffer,CharBuffer,  $(X_BUF), type:=char))\n-$(eval $(call SetupGenBuffer,ShortBuffer, $(X_BUF), type:=short))\n-$(eval $(call SetupGenBuffer,IntBuffer,   $(X_BUF), type:=int))\n-$(eval $(call SetupGenBuffer,LongBuffer,  $(X_BUF), type:=long))\n-$(eval $(call SetupGenBuffer,FloatBuffer, $(X_BUF), type:=float))\n-$(eval $(call SetupGenBuffer,DoubleBuffer,$(X_BUF), type:=double))\n+$(eval $(call SetupGenBuffer,ByteBuffer,  $(X_BUF), type := byte, BIN := 1))\n+$(eval $(call SetupGenBuffer,CharBuffer,  $(X_BUF), type := char))\n+$(eval $(call SetupGenBuffer,ShortBuffer, $(X_BUF), type := short))\n+$(eval $(call SetupGenBuffer,IntBuffer,   $(X_BUF), type := int))\n+$(eval $(call SetupGenBuffer,LongBuffer,  $(X_BUF), type := long))\n+$(eval $(call SetupGenBuffer,FloatBuffer, $(X_BUF), type := float))\n+$(eval $(call SetupGenBuffer,DoubleBuffer,$(X_BUF), type := double))\n@@ -294,14 +294,14 @@\n-$(eval $(call SetupGenBuffer,HeapByteBuffer,   $(HEAP_X_BUF), type:=byte))\n-$(eval $(call SetupGenBuffer,HeapByteBufferR,  $(HEAP_X_BUF), type:=byte, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapCharBuffer,   $(HEAP_X_BUF), type:=char))\n-$(eval $(call SetupGenBuffer,HeapCharBufferR,  $(HEAP_X_BUF), type:=char, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapShortBuffer,  $(HEAP_X_BUF), type:=short))\n-$(eval $(call SetupGenBuffer,HeapShortBufferR, $(HEAP_X_BUF), type:=short, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapIntBuffer,    $(HEAP_X_BUF), type:=int))\n-$(eval $(call SetupGenBuffer,HeapIntBufferR,   $(HEAP_X_BUF), type:=int, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapLongBuffer,   $(HEAP_X_BUF), type:=long))\n-$(eval $(call SetupGenBuffer,HeapLongBufferR,  $(HEAP_X_BUF), type:=long, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapFloatBuffer,  $(HEAP_X_BUF), type:=float))\n-$(eval $(call SetupGenBuffer,HeapFloatBufferR, $(HEAP_X_BUF), type:=float, RW:=R))\n-$(eval $(call SetupGenBuffer,HeapDoubleBuffer, $(HEAP_X_BUF), type:=double))\n-$(eval $(call SetupGenBuffer,HeapDoubleBufferR,$(HEAP_X_BUF), type:=double, RW:=R))\n+$(eval $(call SetupGenBuffer,HeapByteBuffer,   $(HEAP_X_BUF), type := byte))\n+$(eval $(call SetupGenBuffer,HeapByteBufferR,  $(HEAP_X_BUF), type := byte, RW := R))\n+$(eval $(call SetupGenBuffer,HeapCharBuffer,   $(HEAP_X_BUF), type := char))\n+$(eval $(call SetupGenBuffer,HeapCharBufferR,  $(HEAP_X_BUF), type := char, RW := R))\n+$(eval $(call SetupGenBuffer,HeapShortBuffer,  $(HEAP_X_BUF), type := short))\n+$(eval $(call SetupGenBuffer,HeapShortBufferR, $(HEAP_X_BUF), type := short, RW := R))\n+$(eval $(call SetupGenBuffer,HeapIntBuffer,    $(HEAP_X_BUF), type := int))\n+$(eval $(call SetupGenBuffer,HeapIntBufferR,   $(HEAP_X_BUF), type := int, RW := R))\n+$(eval $(call SetupGenBuffer,HeapLongBuffer,   $(HEAP_X_BUF), type := long))\n+$(eval $(call SetupGenBuffer,HeapLongBufferR,  $(HEAP_X_BUF), type := long, RW := R))\n+$(eval $(call SetupGenBuffer,HeapFloatBuffer,  $(HEAP_X_BUF), type := float))\n+$(eval $(call SetupGenBuffer,HeapFloatBufferR, $(HEAP_X_BUF), type := float, RW := R))\n+$(eval $(call SetupGenBuffer,HeapDoubleBuffer, $(HEAP_X_BUF), type := double))\n+$(eval $(call SetupGenBuffer,HeapDoubleBufferR,$(HEAP_X_BUF), type := double, RW := R))\n@@ -313,2 +313,2 @@\n-$(eval $(call SetupGenBuffer,DirectByteBuffer, $(DIRECT_X_BUF), type:=byte, BIN:=1))\n-$(eval $(call SetupGenBuffer,DirectByteBufferR,$(DIRECT_X_BUF), type:=byte, BIN:=1, RW:=R))\n+$(eval $(call SetupGenBuffer,DirectByteBuffer, $(DIRECT_X_BUF), type := byte, BIN := 1))\n+$(eval $(call SetupGenBuffer,DirectByteBufferR,$(DIRECT_X_BUF), type := byte, BIN := 1, RW := R))\n@@ -318,12 +318,12 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferU,   $(DIRECT_X_BUF), type:=char, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRU,  $(DIRECT_X_BUF), type:=char, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferU,  $(DIRECT_X_BUF), type:=short, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRU, $(DIRECT_X_BUF), type:=short, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferU,    $(DIRECT_X_BUF), type:=int, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRU,   $(DIRECT_X_BUF), type:=int, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferU,   $(DIRECT_X_BUF), type:=long, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRU,  $(DIRECT_X_BUF), type:=long, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferU,  $(DIRECT_X_BUF), type:=float, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRU, $(DIRECT_X_BUF), type:=float, RW:=R, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferU, $(DIRECT_X_BUF), type:=double, BO:=U))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRU,$(DIRECT_X_BUF), type:=double, RW:=R, BO:=U))\n+$(eval $(call SetupGenBuffer,DirectCharBufferU,   $(DIRECT_X_BUF), type := char, BO := U))\n+$(eval $(call SetupGenBuffer,DirectCharBufferRU,  $(DIRECT_X_BUF), type := char, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectShortBufferU,  $(DIRECT_X_BUF), type := short, BO := U))\n+$(eval $(call SetupGenBuffer,DirectShortBufferRU, $(DIRECT_X_BUF), type := short, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectIntBufferU,    $(DIRECT_X_BUF), type := int, BO := U))\n+$(eval $(call SetupGenBuffer,DirectIntBufferRU,   $(DIRECT_X_BUF), type := int, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectLongBufferU,   $(DIRECT_X_BUF), type := long, BO := U))\n+$(eval $(call SetupGenBuffer,DirectLongBufferRU,  $(DIRECT_X_BUF), type := long, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferU,  $(DIRECT_X_BUF), type := float, BO := U))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferRU, $(DIRECT_X_BUF), type := float, RW := R, BO := U))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferU, $(DIRECT_X_BUF), type := double, BO := U))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferRU,$(DIRECT_X_BUF), type := double, RW := R, BO := U))\n@@ -333,12 +333,12 @@\n-$(eval $(call SetupGenBuffer,DirectCharBufferS,   $(DIRECT_X_BUF), type:=char, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectCharBufferRS,  $(DIRECT_X_BUF), type:=char, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferS,  $(DIRECT_X_BUF), type:=short, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectShortBufferRS, $(DIRECT_X_BUF), type:=short, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferS,    $(DIRECT_X_BUF), type:=int, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectIntBufferRS,   $(DIRECT_X_BUF), type:=int, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferS,   $(DIRECT_X_BUF), type:=long, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectLongBufferRS,  $(DIRECT_X_BUF), type:=long, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferS,  $(DIRECT_X_BUF), type:=float, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectFloatBufferRS, $(DIRECT_X_BUF), type:=float, RW:=R, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferS, $(DIRECT_X_BUF), type:=double, BO:=S))\n-$(eval $(call SetupGenBuffer,DirectDoubleBufferRS,$(DIRECT_X_BUF), type:=double, RW:=R, BO:=S))\n+$(eval $(call SetupGenBuffer,DirectCharBufferS,   $(DIRECT_X_BUF), type := char, BO := S))\n+$(eval $(call SetupGenBuffer,DirectCharBufferRS,  $(DIRECT_X_BUF), type := char, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectShortBufferS,  $(DIRECT_X_BUF), type := short, BO := S))\n+$(eval $(call SetupGenBuffer,DirectShortBufferRS, $(DIRECT_X_BUF), type := short, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectIntBufferS,    $(DIRECT_X_BUF), type := int, BO := S))\n+$(eval $(call SetupGenBuffer,DirectIntBufferRS,   $(DIRECT_X_BUF), type := int, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectLongBufferS,   $(DIRECT_X_BUF), type := long, BO := S))\n+$(eval $(call SetupGenBuffer,DirectLongBufferRS,  $(DIRECT_X_BUF), type := long, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferS,  $(DIRECT_X_BUF), type := float, BO := S))\n+$(eval $(call SetupGenBuffer,DirectFloatBufferRS, $(DIRECT_X_BUF), type := float, RW := R, BO := S))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferS, $(DIRECT_X_BUF), type := double, BO := S))\n+$(eval $(call SetupGenBuffer,DirectDoubleBufferRS,$(DIRECT_X_BUF), type := double, RW := R, BO := S))\n@@ -350,12 +350,12 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferB,   $(BYTE_X_BUF), type:=char, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRB,  $(BYTE_X_BUF), type:=char, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferB,  $(BYTE_X_BUF), type:=short, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRB, $(BYTE_X_BUF), type:=short, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferB,    $(BYTE_X_BUF), type:=int, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRB,   $(BYTE_X_BUF), type:=int, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferB,   $(BYTE_X_BUF), type:=long, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRB,  $(BYTE_X_BUF), type:=long, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferB,  $(BYTE_X_BUF), type:=float, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRB, $(BYTE_X_BUF), type:=float, RW:=R, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferB, $(BYTE_X_BUF), type:=double, BO:=B))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRB,$(BYTE_X_BUF), type:=double, RW:=R, BO:=B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferB,   $(BYTE_X_BUF), type := char, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRB,  $(BYTE_X_BUF), type := char, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferB,  $(BYTE_X_BUF), type := short, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRB, $(BYTE_X_BUF), type := short, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferB,    $(BYTE_X_BUF), type := int, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRB,   $(BYTE_X_BUF), type := int, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferB,   $(BYTE_X_BUF), type := long, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRB,  $(BYTE_X_BUF), type := long, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferB,  $(BYTE_X_BUF), type := float, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRB, $(BYTE_X_BUF), type := float, RW := R, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferB, $(BYTE_X_BUF), type := double, BO := B))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRB,$(BYTE_X_BUF), type := double, RW := R, BO := B))\n@@ -365,12 +365,12 @@\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferL,   $(BYTE_X_BUF), type:=char, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRL,  $(BYTE_X_BUF), type:=char, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferL,  $(BYTE_X_BUF), type:=short, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRL, $(BYTE_X_BUF), type:=short, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferL,    $(BYTE_X_BUF), type:=int, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRL,   $(BYTE_X_BUF), type:=int, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferL,   $(BYTE_X_BUF), type:=long, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRL,  $(BYTE_X_BUF), type:=long, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferL,  $(BYTE_X_BUF), type:=float, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRL, $(BYTE_X_BUF), type:=float, RW:=R, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferL, $(BYTE_X_BUF), type:=double, BO:=L))\n-$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRL,$(BYTE_X_BUF), type:=double, RW:=R, BO:=L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferL,   $(BYTE_X_BUF), type := char, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsCharBufferRL,  $(BYTE_X_BUF), type := char, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferL,  $(BYTE_X_BUF), type := short, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsShortBufferRL, $(BYTE_X_BUF), type := short, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferL,    $(BYTE_X_BUF), type := int, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsIntBufferRL,   $(BYTE_X_BUF), type := int, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferL,   $(BYTE_X_BUF), type := long, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsLongBufferRL,  $(BYTE_X_BUF), type := long, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferL,  $(BYTE_X_BUF), type := float, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsFloatBufferRL, $(BYTE_X_BUF), type := float, RW := R, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferL, $(BYTE_X_BUF), type := double, BO := L))\n+$(eval $(call SetupGenBuffer,ByteBufferAsDoubleBufferRL,$(BYTE_X_BUF), type := double, RW := R, BO := L))\n","filename":"make\/modules\/java.base\/gensrc\/GensrcBuffer.gmk","additions":71,"deletions":71,"binary":false,"changes":142,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n-GENSRC_EXCEPTIONS += $(foreach D,$(GENSRC_EXCEPTIONS_SRC_DIRS),$(GENSRC_EXCEPTIONS_DST)\/_the.$(D).marker)\n+GENSRC_EXCEPTIONS += $(foreach D, $(GENSRC_EXCEPTIONS_SRC_DIRS), $(GENSRC_EXCEPTIONS_DST)\/_the.$(D).marker)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcExceptions.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -90,1 +90,1 @@\n-  ifeq ($(OPENJDK_TARGET_CPU),aarch64)\n+  ifeq ($(OPENJDK_TARGET_CPU), aarch64)\n","filename":"make\/modules\/java.base\/gensrc\/GensrcMisc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-############################################################################\n+################################################################################\n","filename":"make\/modules\/java.base\/gensrc\/GensrcModuleLoaderMap.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+    DISABLED_WARNINGS_gcc_check_code.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_check_code.c := unused-variable, \\\n@@ -61,0 +63,1 @@\n+    DISABLED_WARNINGS_clang_TimeZone_md.c := unused-variable, \\\n@@ -63,1 +66,1 @@\n-    LIBS_aix := $(LIBDL) $(LIBM),\\\n+    LIBS_aix := $(LIBDL) $(LIBM), \\\n@@ -95,0 +98,1 @@\n+    DISABLED_WARNINGS_clang_zip_util.c := unused-function, \\\n@@ -111,0 +115,6 @@\n+    DISABLED_WARNINGS_gcc_imageDecompressor.cpp := unused-variable, \\\n+    DISABLED_WARNINGS_gcc_imageFile.cpp := unused-const-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_imageDecompressor.cpp := unused-variable, \\\n+    DISABLED_WARNINGS_clang_imageFile.cpp := unused-private-field \\\n+        unused-variable, \\\n@@ -170,2 +180,4 @@\n-    DISABLED_WARNINGS_gcc := unused-function, \\\n-    DISABLED_WARNINGS_clang := format-nonliteral deprecated-non-prototype, \\\n+    DISABLED_WARNINGS_gcc := unused-function unused-variable, \\\n+    DISABLED_WARNINGS_clang := deprecated-non-prototype format-nonliteral \\\n+        unused-function, \\\n+    DISABLED_WARNINGS_clang_java_md_macosx.m := unused-variable, \\\n","filename":"make\/modules\/java.base\/lib\/CoreLibraries.gmk","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -67,2 +67,5 @@\n-      DISABLED_WARNINGS_gcc := undef, \\\n-      DISABLED_WARNINGS_clang := undef, \\\n+      DISABLED_WARNINGS_gcc := undef unused-variable, \\\n+      DISABLED_WARNINGS_clang := undef unused-variable, \\\n+      DISABLED_WARNINGS_clang_PLATFORM_API_MacOSX_MidiUtils.c := \\\n+          unused-but-set-variable, \\\n+      DISABLED_WARNINGS_clang_DirectAudioDevice.c := unused-function, \\\n","filename":"make\/modules\/java.desktop\/Lib.gmk","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -109,0 +109,1 @@\n+    DISABLED_WARNINGS_gcc := unused-but-set-variable unused-variable, \\\n@@ -115,0 +116,1 @@\n+    DISABLED_WARNINGS_clang := unused-but-set-variable unused-variable, \\\n@@ -128,1 +130,1 @@\n-    LIBS_aix := $(LIBDL),\\\n+    LIBS_aix := $(LIBDL), \\\n@@ -181,0 +183,2 @@\n+      DISABLED_WARNINGS_gcc := unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-variable, \\\n@@ -183,0 +187,2 @@\n+      DISABLED_WARNINGS_clang_X11Renderer.c := unused-function, \\\n+      DISABLED_WARNINGS_clang_X11SurfaceData.c := unused-function, \\\n@@ -237,1 +243,2 @@\n-      DISABLED_WARNINGS_gcc := int-to-pointer-cast, \\\n+      DISABLED_WARNINGS_gcc := int-to-pointer-cast unused-variable, \\\n+      DISABLED_WARNINGS_clang := unused-variable, \\\n@@ -240,1 +247,0 @@\n-      DISABLED_WARNINGS_gcc_gtk2_interface.c := parentheses type-limits, \\\n@@ -248,0 +254,1 @@\n+      DISABLED_WARNINGS_gcc_X11Color.c := unused-but-set-variable, \\\n@@ -249,1 +256,2 @@\n-          pointer-to-int-cast, \\\n+          pointer-to-int-cast unused-but-set-variable, \\\n+      DISABLED_WARNINGS_gcc_X11TextRenderer_md.c := unused-but-set-variable, \\\n@@ -255,2 +263,2 @@\n-      DISABLED_WARNINGS_clang_gtk2_interface.c := parentheses, \\\n-      DISABLED_WARNINGS_clang_gtk3_interface.c := parentheses, \\\n+      DISABLED_WARNINGS_clang_gtk3_interface.c := unused-function parentheses, \\\n+      DISABLED_WARNINGS_clang_GLXSurfaceData.c := unused-function, \\\n@@ -261,0 +269,1 @@\n+      DISABLED_WARNINGS_clang_XWindow.c := unused-function, \\\n@@ -265,3 +274,1 @@\n-      DISABLED_WARNINGS_clang_aix_gtk2_interface.c := parentheses \\\n-          logical-op-parentheses, \\\n-      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := parentheses \\\n+      DISABLED_WARNINGS_clang_aix_gtk3_interface.c := unused-function parentheses \\\n@@ -271,1 +278,1 @@\n-      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_aix_awt_InputMethod.c := unused-function sign-compare, \\\n@@ -315,3 +322,4 @@\n-      DISABLED_WARNINGS_clang := incomplete-implementation \\\n-          deprecated-declarations objc-method-access \\\n-          incompatible-pointer-types extra-tokens sign-compare undef, \\\n+      DISABLED_WARNINGS_clang := deprecated-declarations extra-tokens \\\n+          incompatible-pointer-types incomplete-implementation \\\n+          objc-method-access sign-compare undef unused-function \\\n+          unused-variable, \\\n","filename":"make\/modules\/java.desktop\/lib\/AwtLibraries.gmk","additions":21,"deletions":13,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+    DISABLED_WARNINGS_clang_mlib_ImageCreate.c := unused-function, \\\n@@ -87,2 +88,2 @@\n-    DISABLED_WARNINGS_gcc := format-nonliteral type-limits \\\n-        stringop-truncation, \\\n+    DISABLED_WARNINGS_gcc := format-nonliteral stringop-truncation type-limits \\\n+        unused-variable, \\\n@@ -103,1 +104,2 @@\n-      jpegdecoder.c\n+      jpegdecoder.c \\\n+      #\n@@ -121,1 +123,2 @@\n-    DISABLED_WARNINGS_gcc_imageioJPEG.c := clobbered array-bounds, \\\n+    DISABLED_WARNINGS_gcc_imageioJPEG.c := array-bounds clobbered \\\n+        unused-but-set-variable, \\\n@@ -124,0 +127,1 @@\n+    DISABLED_WARNINGS_clang_imageioJPEG.c := unused-but-set-variable, \\\n@@ -227,1 +231,2 @@\n-      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits unused-result, \\\n+      DISABLED_WARNINGS_gcc_splashscreen_sys.c := type-limits \\\n+          unused-but-set-variable unused-result unused-variable, \\\n@@ -231,1 +236,2 @@\n-      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare, \\\n+      DISABLED_WARNINGS_clang_splashscreen_impl.c := sign-compare \\\n+          unused-but-set-variable unused-function, \\\n@@ -234,1 +240,2 @@\n-      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations, \\\n+      DISABLED_WARNINGS_clang_splashscreen_sys.m := deprecated-declarations \\\n+          unused-variable unused-but-set-variable, \\\n@@ -282,3 +289,3 @@\n-   LIBFONTMANAGER_EXTRA_SRC =\n-   LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n-   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n+  LIBFONTMANAGER_EXTRA_SRC =\n+  LIBFONTMANAGER_LIBS += $(HARFBUZZ_LIBS)\n+  LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n@@ -286,1 +293,1 @@\n-   LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n+  LIBFONTMANAGER_EXTRA_SRC = libharfbuzz\n@@ -288,2 +295,2 @@\n-   ifeq ($(call isTargetOs, windows), false)\n-     HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n+  ifeq ($(call isTargetOs, windows), false)\n+    HARFBUZZ_CFLAGS += -DGETPAGESIZE -DHAVE_MPROTECT -DHAVE_PTHREAD \\\n@@ -292,9 +299,9 @@\n-   endif\n-   ifeq ($(call isTargetOs, linux macosx), true)\n-     HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n-   endif\n-\n-   # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n-   # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n-   # time.\n-   LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n+  endif\n+  ifeq ($(call isTargetOs, linux macosx), true)\n+    HARFBUZZ_CFLAGS += -DHAVE_INTEL_ATOMIC_PRIMITIVES -DHB_NO_VISIBILITY\n+  endif\n+\n+  # hb-ft.cc is not presently needed, and requires freetype 2.4.2 or later.\n+  # hb-subset and hb-style APIs are not needed, excluded to cut on compilation\n+  # time.\n+  LIBFONTMANAGER_EXCLUDE_FILES += gsubgpos-context.cc hb-ft.cc hb-style.cc \\\n@@ -305,21 +312,22 @@\n-   # list of disabled warnings and the compilers for which it was specifically\n-   # added.\n-   # array-bounds         -> GCC 12 on Alpine Linux\n-   # parentheses          -> GCC 6\n-   # range-loop-analysis  -> clang on Xcode12\n-\n-   HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n-       strict-aliasing unused-result array-bounds parentheses\n-   # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n-   # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n-   # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n-   # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n-   #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n-   HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n-       expansion-to-defined dangling-reference maybe-uninitialized \\\n-       calloc-transposed-args\n-   HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n-      range-loop-analysis\n-   HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n-\n-   LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n+  # list of disabled warnings and the compilers for which it was specifically\n+  # added.\n+  # array-bounds         -> GCC 12 on Alpine Linux\n+  # parentheses          -> GCC 6\n+  # range-loop-analysis  -> clang on Xcode12\n+\n+  HARFBUZZ_DISABLED_WARNINGS_gcc := missing-field-initializers \\\n+      strict-aliasing unused-result array-bounds parentheses \\\n+       unused-variable\n+  # noexcept-type required for GCC 7 builds. Not required for GCC 8+.\n+  # expansion-to-defined required for GCC 9 builds. Not required for GCC 10+.\n+  # maybe-uninitialized required for GCC 8 builds. Not required for GCC 9+.\n+  # calloc-transposed-args required for GCC 14 builds. (fixed upstream in\n+  #  Harfbuzz 032c931e1c0cfb20f18e5acb8ba005775242bd92)\n+  HARFBUZZ_DISABLED_WARNINGS_CXX_gcc := class-memaccess noexcept-type \\\n+      expansion-to-defined dangling-reference maybe-uninitialized \\\n+      calloc-transposed-args\n+  HARFBUZZ_DISABLED_WARNINGS_clang := missing-field-initializers \\\n+      range-loop-analysis unused-variable\n+  HARFBUZZ_DISABLED_WARNINGS_microsoft := 4267 4244\n+\n+  LIBFONTMANAGER_CFLAGS += $(HARFBUZZ_CFLAGS)\n@@ -387,1 +395,1 @@\n-    LDFLAGS_FILTER_OUT :=-Wl$(COMMA)-z$(COMMA)defs, \\\n+    LDFLAGS_FILTER_OUT := -Wl$(COMMA)-z$(COMMA)defs, \\\n","filename":"make\/modules\/java.desktop\/lib\/ClientLibraries.gmk","additions":52,"deletions":44,"binary":false,"changes":96,"status":"modified"},{"patch":"@@ -40,0 +40,2 @@\n+    DISABLED_WARNINGS_gcc_VMManagementImpl.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_VMManagementImpl.c := unused-variable, \\\n@@ -41,1 +43,1 @@\n-    LIBS_aix := -lperfstat,\\\n+    LIBS_aix := -lperfstat, \\\n","filename":"make\/modules\/java.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -36,2 +36,2 @@\n-    DISABLED_WARNINGS_gcc := undef, \\\n-    DISABLED_WARNINGS_clang := undef, \\\n+    DISABLED_WARNINGS_gcc := undef unused-but-set-variable, \\\n+    DISABLED_WARNINGS_clang := undef unused-but-set-variable, \\\n","filename":"make\/modules\/java.security.jgss\/Lib.gmk","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -96,1 +96,1 @@\n-   ))\n+    ))\n","filename":"make\/modules\/jdk.accessibility\/Launcher.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -36,0 +36,2 @@\n+    DISABLED_WARNINGS_gcc_p11_md.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_p11_md.c := unused-variable, \\\n","filename":"make\/modules\/jdk.crypto.cryptoki\/Lib.gmk","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+    DISABLED_WARNINGS_gcc_LinuxDebuggerLocal.cpp := unused-variable, \\\n@@ -63,1 +64,1 @@\n-    DISABLED_WARNINGS_clang_ps_core.c := pointer-arith, \\\n+    DISABLED_WARNINGS_gcc_symtab.c := unused-but-set-variable, \\\n@@ -66,0 +67,2 @@\n+    DISABLED_WARNINGS_clang_MacosxDebuggerLocal.m := unused-variable, \\\n+    DISABLED_WARNINGS_clang_ps_core.c := pointer-arith, \\\n","filename":"make\/modules\/jdk.hotspot.agent\/Lib.gmk","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -29,1 +29,1 @@\n-$(eval $(call SetupVersionProperties, JAVADOC_VERSION,\\\n+$(eval $(call SetupVersionProperties, JAVADOC_VERSION, \\\n","filename":"make\/modules\/jdk.javadoc\/Gensrc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-$(eval $(call SetupVersionProperties, JDEPS_VERSION,\\\n+$(eval $(call SetupVersionProperties, JDEPS_VERSION, \\\n","filename":"make\/modules\/jdk.jdeps\/Gensrc.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+    DISABLED_WARNINGS_gcc_eventFilter.c := unused-variable, \\\n@@ -56,0 +57,3 @@\n+    DISABLED_WARNINGS_gcc_threadControl.c := unused-but-set-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_gcc_utf_util.c := unused-but-set-variable, \\\n@@ -57,0 +61,1 @@\n+    DISABLED_WARNINGS_clang_eventFilter.c := unused-variable, \\\n@@ -60,0 +65,4 @@\n+    DISABLED_WARNINGS_clang_SDE.c := unused-function, \\\n+    DISABLED_WARNINGS_clang_threadControl.c := unused-but-set-variable \\\n+        unused-variable, \\\n+    DISABLED_WARNINGS_clang_utf_util.c := unused-but-set-variable, \\\n@@ -63,2 +72,2 @@\n-        java.base:libjava \\\n-        java.base:libjvm, \\\n+        java.base:libjava, \\\n+    JDK_LIBS := java.base:libjvm, \\\n","filename":"make\/modules\/jdk.jdwp.agent\/Lib.gmk","additions":11,"deletions":2,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n-$(eval $(call SetupBuildLauncher, jimage,\\\n+$(eval $(call SetupBuildLauncher, jimage, \\\n@@ -41,1 +41,1 @@\n-$(eval $(call SetupBuildLauncher, jlink,\\\n+$(eval $(call SetupBuildLauncher, jlink, \\\n@@ -51,1 +51,1 @@\n-$(eval $(call SetupBuildLauncher, jmod,\\\n+$(eval $(call SetupBuildLauncher, jmod, \\\n","filename":"make\/modules\/jdk.jlink\/Launcher.gmk","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -56,1 +56,0 @@\n-    DISABLED_WARNINGS_clang_LinuxPackage.c := format-nonliteral, \\\n@@ -58,0 +57,2 @@\n+    DISABLED_WARNINGS_clang_LinuxPackage.c := format-nonliteral, \\\n+    DISABLED_WARNINGS_clang_Log.cpp := unused-const-variable, \\\n@@ -92,0 +93,1 @@\n+      DISABLED_WARNINGS_gcc_Log.cpp := unused-const-variable, \\\n","filename":"make\/modules\/jdk.jpackage\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -47,0 +47,2 @@\n+    DISABLED_WARNINGS_gcc_DiagnosticCommandImpl.c := unused-variable, \\\n+    DISABLED_WARNINGS_clang_DiagnosticCommandImpl.c := unused-variable, \\\n@@ -50,1 +52,1 @@\n-    LIBS_aix := -lperfstat,\\\n+    LIBS_aix := -lperfstat, \\\n","filename":"make\/modules\/jdk.management\/Lib.gmk","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -97,0 +97,1 @@\n+    CREATE_API_DIGEST := true, \\\n@@ -151,1 +152,1 @@\n-    EXCLUDE_FILES:= _the.BUILD_JDK_MICROBENCHMARK_batch \\\n+    EXCLUDE_FILES := _the.BUILD_JDK_MICROBENCHMARK_batch \\\n","filename":"make\/test\/BuildMicrobenchmark.gmk","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -67,1 +67,1 @@\n-    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview dangling-doc-comments, \\\n+    DISABLED_WARNINGS := try deprecation rawtypes unchecked serial cast removal preview restricted dangling-doc-comments, \\\n","filename":"make\/test\/BuildTestLib.gmk","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -62,1 +62,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -66,1 +67,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -69,1 +71,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/native \\\n+    #\n@@ -73,1 +76,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jdi \\\n+    #\n@@ -77,1 +81,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -82,1 +87,2 @@\n-    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti\n+    -I$(TOPDIR)\/test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jvmti \\\n+    #\n@@ -86,1 +92,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/locks \\\n+    #\n@@ -93,1 +100,2 @@\n-    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share\n+    -I$(VM_TESTBASE_DIR)\/vm\/mlvm\/share \\\n+    #\n@@ -97,1 +105,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -102,1 +111,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -107,1 +117,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -111,1 +122,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -114,1 +126,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/stress\/jni \\\n+    #\n@@ -120,1 +133,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/agent_common \\\n+    #\n@@ -127,1 +141,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jvmti\/aod \\\n+    #\n@@ -132,1 +147,2 @@\n-    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni\n+    -I$(VM_TESTBASE_DIR)\/nsk\/share\/jni \\\n+    #\n@@ -143,1 +159,1 @@\n-JVMTI_COMMON_INCLUDES=-I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n+JVMTI_COMMON_INCLUDES = -I$(TOPDIR)\/test\/lib\/jdk\/test\/lib\/jvmti\n@@ -765,1 +781,1 @@\n-BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 :=$(NSK_JVMTI_AGENT_INCLUDES)\n+BUILD_HOTSPOT_JTREG_LIBRARIES_CFLAGS_libgetclmdf006 := $(NSK_JVMTI_AGENT_INCLUDES)\n@@ -1562,1 +1578,1 @@\n-$(eval $(call SetupCopyFiles,COPY_HOTSPOT_JTREG_NATIVE, \\\n+$(eval $(call SetupCopyFiles, COPY_HOTSPOT_JTREG_NATIVE, \\\n","filename":"make\/test\/JtregNativeHotspot.gmk","additions":35,"deletions":19,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS)\/native\/libjli\n+    -I$(TOPDIR)\/src\/java.base\/$(OPENJDK_TARGET_OS)\/native\/libjli \\\n+    #\n@@ -157,1 +158,1 @@\n-$(eval $(call SetupCopyFiles,COPY_JDK_JTREG_NATIVE, \\\n+$(eval $(call SetupCopyFiles, COPY_JDK_JTREG_NATIVE, \\\n","filename":"make\/test\/JtregNativeJdk.gmk","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"filename":"src\/demo\/share\/jfc\/SwingSet2\/resources\/images\/About.jpg","binary":true,"status":"modified"},{"patch":"@@ -2337,1 +2337,1 @@\n-  int size = MIN2((UseSVE > 0) ? 256 : 16, (int)MaxVectorSize);\n+  int size = MIN2((UseSVE > 0) ? (int)FloatRegister::sve_vl_max : (int)FloatRegister::neon_vl, (int)MaxVectorSize);\n@@ -2376,1 +2376,1 @@\n-  if (UseSVE > 0 && 16 < len && len <= 256) {\n+  if (UseSVE > 0 && FloatRegister::neon_vl < len && len <= FloatRegister::sve_vl_max) {\n@@ -2723,1 +2723,1 @@\n-      \/* Fix up any out-of-range offsets. *\/\n+      \/\/ Fix up any out-of-range offsets.\n@@ -2764,1 +2764,5 @@\n-      (masm->*insn)(reg, T, Address(base, disp));\n+      \/\/ Fix up any out-of-range offsets.\n+      assert_different_registers(rscratch1, base);\n+      Address addr = Address(base, disp);\n+      addr = __ legitimize_address(addr, (1 << T), rscratch1);\n+      (masm->*insn)(reg, T, addr);\n@@ -2819,1 +2823,1 @@\n-  enc_class aarch64_enc_ldrsbw(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsbw(iRegI dst, memory mem) %{\n@@ -2827,1 +2831,1 @@\n-  enc_class aarch64_enc_ldrsb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrsb(iRegI dst, memory mem) %{\n@@ -2835,1 +2839,1 @@\n-  enc_class aarch64_enc_ldrb(iRegI dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegI dst, memory mem) %{\n@@ -2843,1 +2847,1 @@\n-  enc_class aarch64_enc_ldrb(iRegL dst, memory1 mem) %{\n+  enc_class aarch64_enc_ldrb(iRegL dst, memory mem) %{\n@@ -2851,1 +2855,1 @@\n-  enc_class aarch64_enc_ldrshw(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrshw(iRegI dst, memory mem) %{\n@@ -2859,1 +2863,1 @@\n-  enc_class aarch64_enc_ldrsh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrsh(iRegI dst, memory mem) %{\n@@ -2867,1 +2871,1 @@\n-  enc_class aarch64_enc_ldrh(iRegI dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegI dst, memory mem) %{\n@@ -2875,1 +2879,1 @@\n-  enc_class aarch64_enc_ldrh(iRegL dst, memory2 mem) %{\n+  enc_class aarch64_enc_ldrh(iRegL dst, memory mem) %{\n@@ -2883,1 +2887,1 @@\n-  enc_class aarch64_enc_ldrw(iRegI dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegI dst, memory mem) %{\n@@ -2891,1 +2895,1 @@\n-  enc_class aarch64_enc_ldrw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrw(iRegL dst, memory mem) %{\n@@ -2899,1 +2903,1 @@\n-  enc_class aarch64_enc_ldrsw(iRegL dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrsw(iRegL dst, memory mem) %{\n@@ -2907,1 +2911,1 @@\n-  enc_class aarch64_enc_ldr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldr(iRegL dst, memory mem) %{\n@@ -2915,1 +2919,1 @@\n-  enc_class aarch64_enc_ldrs(vRegF dst, memory4 mem) %{\n+  enc_class aarch64_enc_ldrs(vRegF dst, memory mem) %{\n@@ -2923,1 +2927,1 @@\n-  enc_class aarch64_enc_ldrd(vRegD dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldrd(vRegD dst, memory mem) %{\n@@ -2931,1 +2935,1 @@\n-  enc_class aarch64_enc_strb(iRegI src, memory1 mem) %{\n+  enc_class aarch64_enc_strb(iRegI src, memory mem) %{\n@@ -2939,1 +2943,1 @@\n-  enc_class aarch64_enc_strb0(memory1 mem) %{\n+  enc_class aarch64_enc_strb0(memory mem) %{\n@@ -2946,1 +2950,1 @@\n-  enc_class aarch64_enc_strh(iRegI src, memory2 mem) %{\n+  enc_class aarch64_enc_strh(iRegI src, memory mem) %{\n@@ -2954,1 +2958,1 @@\n-  enc_class aarch64_enc_strh0(memory2 mem) %{\n+  enc_class aarch64_enc_strh0(memory mem) %{\n@@ -2961,1 +2965,1 @@\n-  enc_class aarch64_enc_strw(iRegI src, memory4 mem) %{\n+  enc_class aarch64_enc_strw(iRegI src, memory mem) %{\n@@ -2969,1 +2973,1 @@\n-  enc_class aarch64_enc_strw0(memory4 mem) %{\n+  enc_class aarch64_enc_strw0(memory mem) %{\n@@ -2976,1 +2980,1 @@\n-  enc_class aarch64_enc_str(iRegL src, memory8 mem) %{\n+  enc_class aarch64_enc_str(iRegL src, memory mem) %{\n@@ -2991,1 +2995,1 @@\n-  enc_class aarch64_enc_str0(memory8 mem) %{\n+  enc_class aarch64_enc_str0(memory mem) %{\n@@ -2998,1 +3002,1 @@\n-  enc_class aarch64_enc_strs(vRegF src, memory4 mem) %{\n+  enc_class aarch64_enc_strs(vRegF src, memory mem) %{\n@@ -3006,1 +3010,1 @@\n-  enc_class aarch64_enc_strd(vRegD src, memory8 mem) %{\n+  enc_class aarch64_enc_strd(vRegD src, memory mem) %{\n@@ -3014,1 +3018,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n@@ -3216,1 +3220,1 @@\n-  enc_class aarch64_enc_ldaxr(iRegL dst, memory8 mem) %{\n+  enc_class aarch64_enc_ldaxr(iRegL dst, memory mem) %{\n@@ -3244,1 +3248,1 @@\n-  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory8 mem) %{\n+  enc_class aarch64_enc_stlxr(iRegLNoSp src, memory mem) %{\n@@ -4172,1 +4176,1 @@\n-\/\/ Offset for scaled or unscaled immediate loads and stores\n+\/\/ Offset for immediate loads and stores\n@@ -4175,51 +4179,1 @@\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 0));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 1));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 2));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 3));\n-  match(ConI);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immIOffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_int(), 4));\n+  predicate(n->get_int() >= -256 && n->get_int() <= 65520);\n@@ -4243,50 +4197,0 @@\n-operand immLoffset1()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 0));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset2()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 1));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset4()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 2));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset8()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 3));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n-operand immLoffset16()\n-%{\n-  predicate(Address::offset_ok_for_immed(n->get_long(), 4));\n-  match(ConL);\n-\n-  op_cost(0);\n-  format %{ %}\n-  interface(CONST_INTER);\n-%}\n-\n@@ -5205,1 +5109,1 @@\n-operand indOffI1(iRegP reg, immIOffset1 off)\n+operand indOffI(iRegP reg, immIOffset off)\n@@ -5219,113 +5123,1 @@\n-operand indOffI2(iRegP reg, immIOffset2 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI4(iRegP reg, immIOffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI8(iRegP reg, immIOffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffI16(iRegP reg, immIOffset16 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL1(iRegP reg, immLoffset1 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL2(iRegP reg, immLoffset2 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL4(iRegP reg, immLoffset4 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL8(iRegP reg, immLoffset8 off)\n-%{\n-  constraint(ALLOC_IN_RC(ptr_reg));\n-  match(AddP reg off);\n-  op_cost(0);\n-  format %{ \"[$reg, $off]\" %}\n-  interface(MEMORY_INTER) %{\n-    base($reg);\n-    index(0xffffffff);\n-    scale(0x0);\n-    disp($off);\n-  %}\n-%}\n-\n-operand indOffL16(iRegP reg, immLoffset16 off)\n+operand indOffL(iRegP reg, immLOffset off)\n@@ -5707,4 +5499,1 @@\n-opclass vmem2(indirect, indIndex, indOffI2, indOffL2);\n-opclass vmem4(indirect, indIndex, indOffI4, indOffL4);\n-opclass vmem8(indirect, indIndex, indOffI8, indOffL8);\n-opclass vmem16(indirect, indIndex, indOffI16, indOffL16);\n+opclass vmem(indirect, indIndex, indOffI, indOffL, indOffIN, indOffLN);\n@@ -5722,17 +5511,3 @@\n-opclass memory1(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI1, indOffL1,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory2(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI2, indOffL2,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indirectX2P, indOffX2P);\n-\n-opclass memory4(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI4, indOffL4,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-opclass memory8(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI8, indOffL8,\n-                indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n-\/\/ All of the memory operands. For the pipeline description.\n-opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex,\n-               indOffI1, indOffL1, indOffI2, indOffL2, indOffI4, indOffL4, indOffI8, indOffL8,\n-               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN, indOffLN, indirectX2P, indOffX2P);\n-\n+opclass memory(indirect, indIndexScaled, indIndexScaledI2L, indIndexI2L, indIndex, indOffI, indOffL,\n+               indirectN, indIndexScaledN, indIndexScaledI2LN, indIndexI2LN, indIndexN, indOffIN,\n+               indOffLN, indirectX2P, indOffX2P);\n@@ -6440,1 +6215,1 @@\n-instruct loadB(iRegINoSp dst, memory1 mem)\n+instruct loadB(iRegINoSp dst, memory mem)\n@@ -6454,1 +6229,1 @@\n-instruct loadB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadB2L(iRegLNoSp dst, memory mem)\n@@ -6468,1 +6243,1 @@\n-instruct loadUB(iRegINoSp dst, memory1 mem)\n+instruct loadUB(iRegINoSp dst, memory mem)\n@@ -6482,1 +6257,1 @@\n-instruct loadUB2L(iRegLNoSp dst, memory1 mem)\n+instruct loadUB2L(iRegLNoSp dst, memory mem)\n@@ -6496,1 +6271,1 @@\n-instruct loadS(iRegINoSp dst, memory2 mem)\n+instruct loadS(iRegINoSp dst, memory mem)\n@@ -6510,1 +6285,1 @@\n-instruct loadS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadS2L(iRegLNoSp dst, memory mem)\n@@ -6524,1 +6299,1 @@\n-instruct loadUS(iRegINoSp dst, memory2 mem)\n+instruct loadUS(iRegINoSp dst, memory mem)\n@@ -6538,1 +6313,1 @@\n-instruct loadUS2L(iRegLNoSp dst, memory2 mem)\n+instruct loadUS2L(iRegLNoSp dst, memory mem)\n@@ -6552,1 +6327,1 @@\n-instruct loadI(iRegINoSp dst, memory4 mem)\n+instruct loadI(iRegINoSp dst, memory mem)\n@@ -6566,1 +6341,1 @@\n-instruct loadI2L(iRegLNoSp dst, memory4 mem)\n+instruct loadI2L(iRegLNoSp dst, memory mem)\n@@ -6580,1 +6355,1 @@\n-instruct loadUI2L(iRegLNoSp dst, memory4 mem, immL_32bits mask)\n+instruct loadUI2L(iRegLNoSp dst, memory mem, immL_32bits mask)\n@@ -6594,1 +6369,1 @@\n-instruct loadL(iRegLNoSp dst, memory8 mem)\n+instruct loadL(iRegLNoSp dst, memory mem)\n@@ -6608,1 +6383,1 @@\n-instruct loadRange(iRegINoSp dst, memory4 mem)\n+instruct loadRange(iRegINoSp dst, memory mem)\n@@ -6621,1 +6396,1 @@\n-instruct loadP(iRegPNoSp dst, memory8 mem)\n+instruct loadP(iRegPNoSp dst, memory mem)\n@@ -6635,1 +6410,1 @@\n-instruct loadN(iRegNNoSp dst, memory4 mem)\n+instruct loadN(iRegNNoSp dst, memory mem)\n@@ -6649,1 +6424,1 @@\n-instruct loadKlass(iRegPNoSp dst, memory8 mem)\n+instruct loadKlass(iRegPNoSp dst, memory mem)\n@@ -6663,1 +6438,1 @@\n-instruct loadNKlass(iRegNNoSp dst, memory4 mem)\n+instruct loadNKlass(iRegNNoSp dst, memory mem)\n@@ -6677,1 +6452,1 @@\n-instruct loadF(vRegF dst, memory4 mem)\n+instruct loadF(vRegF dst, memory mem)\n@@ -6691,1 +6466,1 @@\n-instruct loadD(vRegD dst, memory8 mem)\n+instruct loadD(vRegD dst, memory mem)\n@@ -6895,1 +6670,1 @@\n-instruct storeimmCM0(immI0 zero, memory1 mem)\n+instruct storeimmCM0(immI0 zero, memory mem)\n@@ -6910,1 +6685,1 @@\n-instruct storeimmCM0_ordered(immI0 zero, memory1 mem)\n+instruct storeimmCM0_ordered(immI0 zero, memory mem)\n@@ -6925,1 +6700,1 @@\n-instruct storeB(iRegIorL2I src, memory1 mem)\n+instruct storeB(iRegIorL2I src, memory mem)\n@@ -6939,1 +6714,1 @@\n-instruct storeimmB0(immI0 zero, memory1 mem)\n+instruct storeimmB0(immI0 zero, memory mem)\n@@ -6953,1 +6728,1 @@\n-instruct storeC(iRegIorL2I src, memory2 mem)\n+instruct storeC(iRegIorL2I src, memory mem)\n@@ -6966,1 +6741,1 @@\n-instruct storeimmC0(immI0 zero, memory2 mem)\n+instruct storeimmC0(immI0 zero, memory mem)\n@@ -6981,1 +6756,1 @@\n-instruct storeI(iRegIorL2I src, memory4 mem)\n+instruct storeI(iRegIorL2I src, memory mem)\n@@ -6994,1 +6769,1 @@\n-instruct storeimmI0(immI0 zero, memory4 mem)\n+instruct storeimmI0(immI0 zero, memory mem)\n@@ -7008,1 +6783,1 @@\n-instruct storeL(iRegL src, memory8 mem)\n+instruct storeL(iRegL src, memory mem)\n@@ -7022,1 +6797,1 @@\n-instruct storeimmL0(immL0 zero, memory8 mem)\n+instruct storeimmL0(immL0 zero, memory mem)\n@@ -7036,1 +6811,1 @@\n-instruct storeP(iRegP src, memory8 mem)\n+instruct storeP(iRegP src, memory mem)\n@@ -7050,1 +6825,1 @@\n-instruct storeimmP0(immP0 zero, memory8 mem)\n+instruct storeimmP0(immP0 zero, memory mem)\n@@ -7064,1 +6839,1 @@\n-instruct storeN(iRegN src, memory4 mem)\n+instruct storeN(iRegN src, memory mem)\n@@ -7077,1 +6852,1 @@\n-instruct storeImmN0(immN0 zero, memory4 mem)\n+instruct storeImmN0(immN0 zero, memory mem)\n@@ -7091,1 +6866,1 @@\n-instruct storeF(vRegF src, memory4 mem)\n+instruct storeF(vRegF src, memory mem)\n@@ -7108,1 +6883,1 @@\n-instruct storeD(vRegD src, memory8 mem)\n+instruct storeD(vRegD src, memory mem)\n@@ -7122,1 +6897,1 @@\n-instruct storeNKlass(iRegN src, memory4 mem)\n+instruct storeNKlass(iRegN src, memory mem)\n@@ -7141,1 +6916,1 @@\n-instruct prefetchalloc( memory8 mem ) %{\n+instruct prefetchalloc( memory mem ) %{\n@@ -7710,1 +7485,1 @@\n-instruct popCountI_mem(iRegINoSp dst, memory4 mem, vRegF tmp) %{\n+instruct popCountI_mem(iRegINoSp dst, memory mem, vRegF tmp) %{\n@@ -7751,1 +7526,1 @@\n-instruct popCountL_mem(iRegINoSp dst, memory8 mem, vRegD tmp) %{\n+instruct popCountL_mem(iRegINoSp dst, memory mem, vRegD tmp) %{\n@@ -16021,1 +15796,1 @@\n-    __ fast_lock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16037,1 +15812,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -16187,0 +15962,13 @@\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp()\n+%{\n+  match(ForwardException);\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"b forward_exception_stub\" %}\n+  ins_encode %{\n+    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+  %}\n+  ins_pipe(pipe_class_call);\n+%}\n+\n@@ -16887,1 +16675,1 @@\n-instruct compressBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct compressBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -16924,1 +16712,1 @@\n-instruct compressBitsL_memcon(iRegLNoSp dst, memory8 mem, immL mask,\n+instruct compressBitsL_memcon(iRegLNoSp dst, memory mem, immL mask,\n@@ -16961,1 +16749,1 @@\n-instruct expandBitsI_memcon(iRegINoSp dst, memory4 mem, immI mask,\n+instruct expandBitsI_memcon(iRegINoSp dst, memory mem, immI mask,\n@@ -16999,1 +16787,1 @@\n-instruct expandBitsL_memcon(iRegINoSp dst, memory8 mem, immL mask,\n+instruct expandBitsL_memcon(iRegINoSp dst, memory mem, immL mask,\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64.ad","additions":101,"deletions":313,"binary":false,"changes":414,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-    if (UseSVE == 0 && length_in_bytes > 16) {\n+    if (UseSVE == 0 && length_in_bytes > FloatRegister::neon_vl) {\n@@ -348,1 +348,1 @@\n-instruct loadV2(vReg dst, vmem2 mem) %{\n+instruct loadV2(vReg dst, vmem mem) %{\n@@ -357,1 +357,1 @@\n-instruct storeV2(vReg src, vmem2 mem) %{\n+instruct storeV2(vReg src, vmem mem) %{\n@@ -366,1 +366,1 @@\n-instruct loadV4(vReg dst, vmem4 mem) %{\n+instruct loadV4(vReg dst, vmem mem) %{\n@@ -375,1 +375,1 @@\n-instruct storeV4(vReg src, vmem4 mem) %{\n+instruct storeV4(vReg src, vmem mem) %{\n@@ -384,1 +384,1 @@\n-instruct loadV8(vReg dst, vmem8 mem) %{\n+instruct loadV8(vReg dst, vmem mem) %{\n@@ -393,1 +393,1 @@\n-instruct storeV8(vReg src, vmem8 mem) %{\n+instruct storeV8(vReg src, vmem mem) %{\n@@ -402,1 +402,1 @@\n-instruct loadV16(vReg dst, vmem16 mem) %{\n+instruct loadV16(vReg dst, vmem mem) %{\n@@ -411,1 +411,1 @@\n-instruct storeV16(vReg src, vmem16 mem) %{\n+instruct storeV16(vReg src, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector.ad","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-    if (UseSVE == 0 && length_in_bytes > 16) {\n+    if (UseSVE == 0 && length_in_bytes > FloatRegister::neon_vl) {\n@@ -341,1 +341,1 @@\n-instruct $1V$2(vReg $3, vmem$2 mem) %{\n+instruct $1V$2(vReg $3, vmem mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/aarch64_vector_ad.m4","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n-  enc_class aarch64_enc_$2($1 dst, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 dst, memory mem) %{dnl\n@@ -56,1 +56,1 @@\n-  enc_class aarch64_enc_$2($1 src, memory$5 mem) %{dnl\n+  enc_class aarch64_enc_$2($1 src, memory mem) %{dnl\n@@ -61,1 +61,1 @@\n-  enc_class aarch64_enc_$2`'0(memory$4 mem) %{\n+  enc_class aarch64_enc_$2`'0(memory mem) %{\n@@ -85,1 +85,1 @@\n-  enc_class aarch64_enc_strb0_ordered(memory4 mem) %{\n+  enc_class aarch64_enc_strb0_ordered(memory mem) %{\n","filename":"src\/hotspot\/cpu\/aarch64\/ad_encode.m4","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -650,1 +650,1 @@\n-    assert(c->as_jobject() == 0, \"should be\");\n+    assert(c->as_jobject() == nullptr, \"should be\");\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,2 +63,0 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n-\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_LIRAssembler_aarch64.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -78,2 +78,2 @@\n-    ldrw(hdr, Address(hdr, Klass::access_flags_offset()));\n-    tstw(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(hdr, Address(hdr, Klass::misc_flags_offset()));\n+    tst(hdr, KlassFlags::_misc_is_value_based_class);\n@@ -84,1 +84,1 @@\n-    lightweight_lock(obj, hdr, temp, rscratch2, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, rscratch2, slow_case);\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_MacroAssembler_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -786,2 +786,2 @@\n-        __ ldrw(t, Address(t, Klass::access_flags_offset()));\n-        __ tbnz(t, exact_log2(JVM_ACC_HAS_FINALIZER), register_finalizer);\n+        __ ldrb(t, Address(t, Klass::misc_flags_offset()));\n+        __ tbnz(t, exact_log2(KlassFlags::_misc_has_finalizer), register_finalizer);\n@@ -1032,1 +1032,1 @@\n-const char *Runtime1::pd_name_for_address(address entry) { Unimplemented(); return 0; }\n+const char *Runtime1::pd_name_for_address(address entry) { Unimplemented(); }\n","filename":"src\/hotspot\/cpu\/aarch64\/c1_Runtime1_aarch64.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-    ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-    tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n+    tst(tmp, KlassFlags::_misc_is_value_based_class);\n@@ -227,1 +227,1 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register t1,\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box, Register t1,\n@@ -230,1 +230,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -239,0 +239,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -241,2 +246,2 @@\n-    ldrw(t1, Address(t1, Klass::access_flags_offset()));\n-    tstw(t1, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(t1, Address(t1, Klass::misc_flags_offset()));\n+    tst(t1, KlassFlags::_misc_is_value_based_class);\n@@ -247,0 +252,1 @@\n+  const Register t3_t = t3;\n@@ -254,1 +260,0 @@\n-    const Register t3_t = t3;\n@@ -292,3 +297,38 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_tagged_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t3_t, Address(rthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ldr(t1, Address(t3_t));\n+        cmp(obj, t1);\n+        br(Assembler::EQ, monitor_found);\n+        increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ldr(t1, Address(t3_t));\n+      cmp(obj, t1);\n+      br(Assembler::EQ, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      increment(t3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      cbnz(t1, loop);\n+      \/\/ Cache Miss, NE set from cmp above, cbnz does not set flags\n+      b(slow_path);\n+\n+      bind(monitor_found);\n+      ldr(t1_monitor, Address(t3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -297,0 +337,5 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(t1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(t1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n@@ -299,1 +344,1 @@\n-    lea(t2_owner_addr, Address(t1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    lea(t2_owner_addr, owner_address);\n@@ -304,1 +349,1 @@\n-    br(Assembler::EQ, locked);\n+    br(Assembler::EQ, monitor_locked);\n@@ -311,1 +356,6 @@\n-    increment(Address(t1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1);\n+    increment(recursions_address, 1);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      str(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -334,2 +384,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register t1, Register t2,\n-                                                Register t3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box, Register t1,\n+                                                Register t2, Register t3) {\n@@ -337,1 +387,1 @@\n-  assert_different_registers(obj, t1, t2, t3);\n+  assert_different_registers(obj, box, t1, t2, t3);\n@@ -340,1 +390,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -352,0 +402,2 @@\n+    Label push_and_slow_path;\n+\n@@ -358,1 +410,1 @@\n-    br(Assembler::NE, inflated_load_monitor);\n+    br(Assembler::NE, inflated_load_mark);\n@@ -375,1 +427,4 @@\n-    tbnz(t1_mark, exact_log2(markWord::monitor_value), inflated);\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n+    tbnz(t1_mark, exact_log2(markWord::monitor_value), UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -384,0 +439,1 @@\n+    bind(push_and_slow_path);\n@@ -394,1 +450,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -415,3 +471,4 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register t1_monitor = t1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register t1_monitor = t1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(t1_monitor == t1_mark, \"should be the same here\");\n@@ -419,2 +476,8 @@\n-    \/\/ Untag the monitor.\n-    sub(t1_monitor, t1_mark, monitor_tag);\n+      \/\/ Untag the monitor.\n+      add(t1_monitor, t1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ldr(t1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with Flags == NE, no valid pointer below alignof(ObjectMonitor*)\n+      cmp(t1_monitor, checked_cast<uint8_t>(alignof(ObjectMonitor*)));\n+      br(Assembler::LO, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.cpp","additions":88,"deletions":25,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-  void fast_lock_lightweight(Register object, Register t1, Register t2, Register t3);\n-  void fast_unlock_lightweight(Register object, Register t1, Register t2, Register t3);\n+  void fast_lock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n+  void fast_unlock_lightweight(Register object, Register box, Register t1, Register t2, Register t3);\n","filename":"src\/hotspot\/cpu\/aarch64\/c2_MacroAssembler_aarch64.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -296,1 +296,1 @@\n-  assert(_pc == pc_old || pc == pc_old || pc_old == 0, \"\");\n+  assert(_pc == pc_old || pc == pc_old || pc_old == nullptr, \"\");\n@@ -500,1 +500,1 @@\n-  if (fp() == 0 || (intptr_t(fp()) & (wordSize-1)) != 0) {\n+  if (fp() == nullptr || (intptr_t(fp()) & (wordSize-1)) != 0) {\n@@ -503,1 +503,1 @@\n-  if (sp() == 0 || (intptr_t(sp()) & (wordSize-1)) != 0) {\n+  if (sp() == nullptr || (intptr_t(sp()) & (wordSize-1)) != 0) {\n","filename":"src\/hotspot\/cpu\/aarch64\/frame_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-instruct xLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct xLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/x\/x_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -103,1 +103,1 @@\n-instruct zLoadP(iRegPNoSp dst, memory8 mem, rFlagsReg cr)\n+instruct zLoadP(iRegPNoSp dst, memory mem, rFlagsReg cr)\n","filename":"src\/hotspot\/cpu\/aarch64\/gc\/z\/z_aarch64.ad","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-    uint64_t or_bits_top = (0 << nbits) | or_bits_sub;\n+    uint64_t or_bits_top = (UCONST64(0) << nbits) | or_bits_sub;\n","filename":"src\/hotspot\/cpu\/aarch64\/immediate_aarch64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -693,2 +693,2 @@\n-      ldrw(tmp, Address(tmp, Klass::access_flags_offset()));\n-      tstw(tmp, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      ldrb(tmp, Address(tmp, Klass::misc_flags_offset()));\n+      tst(tmp, KlassFlags::_misc_is_value_based_class);\n@@ -699,1 +699,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -755,9 +755,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/aarch64\/interp_masm_aarch64.cpp","additions":6,"deletions":12,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -204,1 +204,1 @@\n-    __ lea(rscratch1, ExternalAddress(slow_case_addr));\n+    __ lea(rscratch1, RuntimeAddress(slow_case_addr));\n","filename":"src\/hotspot\/cpu\/aarch64\/jniFastGetField_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-          assert(target == 0, \"did not expect to relocate target for polling page load\");\n+          assert(target == nullptr, \"did not expect to relocate target for polling page load\");\n@@ -747,1 +747,1 @@\n-    lea(rscratch1, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+    lea(rscratch1, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -1733,2 +1733,2 @@\n-  cmn(r_bitmap, (u1)1);\n-  br(EQ, L_huge);\n+  cmpw(r_array_length, (u1)(Klass::SECONDARY_SUPERS_TABLE_SIZE - 2));\n+  br(GT, L_huge);\n@@ -6416,0 +6416,3 @@\n+  if (!UseSVE || VM_Version::get_max_supported_sve_vector_length() == FloatRegister::sve_vl_min) {\n+    return;\n+  }\n@@ -6417,1 +6420,0 @@\n-  if (!UseSVE) return;\n@@ -6753,1 +6755,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow) {\n@@ -6755,1 +6757,1 @@\n-  assert_different_registers(obj, t1, t2, t3, rscratch1);\n+  assert_different_registers(basic_lock, obj, t1, t2, t3, rscratch1);\n@@ -6766,0 +6768,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    str(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1642,1 +1642,1 @@\n-  void lightweight_lock(Register obj, Register t1, Register t2, Register t3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register t1, Register t2, Register t3, Label& slow);\n","filename":"src\/hotspot\/cpu\/aarch64\/macroAssembler_aarch64.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -454,1 +454,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/aarch64\/methodHandles_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -231,1 +231,1 @@\n-  if ((dest == (address)this) || dest == 0) {\n+  if ((dest == (address)this) || dest == nullptr) {\n@@ -259,1 +259,1 @@\n-  if ((dest == (address)this) || dest == 0) {\n+  if ((dest == (address)this) || dest == nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/nativeInst_aarch64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -169,1 +169,7 @@\n-    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register\n+    extra_save_slots_per_neon_register = slots_per_neon_register - save_slots_per_register,\n+    neon_vl = 16,\n+    \/\/ VLmax: The maximum sve vector length is determined by the hardware\n+    \/\/ sve_vl_min <= VLmax <= sve_vl_max.\n+    sve_vl_min = 16,\n+    \/\/ Maximum supported vector length across all CPUs\n+    sve_vl_max = 256\n","filename":"src\/hotspot\/cpu\/aarch64\/register_aarch64.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -69,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1814,1 +1820,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -1886,10 +1892,2 @@\n-    \/\/ We need an acquire here to ensure that any subsequent load of the\n-    \/\/ global SafepointSynchronize::_state flag is ordered after this load\n-    \/\/ of the thread-local polling word.  We don't want this poll to\n-    \/\/ return false (i.e. not safepointing) and a later poll of the global\n-    \/\/ SafepointSynchronize::_state spuriously to return true.\n-    \/\/\n-    \/\/ This is to avoid a race when we're in a native->Java transition\n-    \/\/ racing the code which wakes up from a safepoint.\n-\n-    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+    \/\/ No need for acquire as Java threads always disarm themselves.\n+    __ safepoint_poll(safepoint_in_progress, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n@@ -2775,0 +2773,190 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n+  enum layout {\n+    rfp_off = 0,\n+    rfp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and LR before call\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ lr and fp are already in place\n+  __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+\n+  __ mov(c_rarg0, rthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ mov(rscratch1, runtime_entry);\n+  __ blr(rscratch1);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n+  \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n+  __ reinitialize_ptrue();\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n+  __ cbnz(rscratch1, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n+  __ mov(c_rarg0, thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(r0, rscratch1, rscratch2);\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+\n+  __ leave();\n+  __ ret(lr);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/aarch64\/sharedRuntime_aarch64.cpp","additions":199,"deletions":11,"binary":false,"changes":210,"status":"modified"},{"patch":"@@ -7048,1 +7048,1 @@\n-    __ lea(rscratch1, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ lea(rscratch1, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -7308,92 +7308,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-    __ mov(c_rarg0, thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(r0, rscratch1, rscratch2);\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      rbp_off,\n-      rbpH_off,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-\n-    __ leave();\n-    __ ret(lr);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rfp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -7415,16 +7323,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n@@ -7434,90 +7326,0 @@\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. aarch64 asserts that frame::arg_reg_save_area_bytes == 0\n-    enum layout {\n-      rfp_off = 0,\n-      rfp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 512;\n-    int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and LR before call\n-\n-    assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-    \/\/ lr and fp are already in place\n-    __ sub(sp, rfp, ((uint64_t)framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, rfp, the_pc, rscratch1);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mov(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mov(c_rarg2, arg2);\n-    }\n-    __ mov(c_rarg0, rthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ mov(rscratch1, runtime_entry);\n-    __ blr(rscratch1);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    \/\/ Reinitialize the ptrue predicate register, in case the external runtime\n-    \/\/ call clobbers ptrue reg, as we may return to SVE compiled code.\n-    __ reinitialize_ptrue();\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ldr(rscratch1, Address(rthread, Thread::pending_exception_offset()));\n-    __ cbnz(rscratch1, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -8366,10 +8168,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -8411,10 +8203,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -8422,1 +8204,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -8429,17 +8210,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n","filename":"src\/hotspot\/cpu\/aarch64\/stubGenerator_aarch64.cpp","additions":1,"deletions":237,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -755,2 +755,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -1416,9 +1416,2 @@\n-    \/\/ We need an acquire here to ensure that any subsequent load of the\n-    \/\/ global SafepointSynchronize::_state flag is ordered after this load\n-    \/\/ of the thread-local polling word.  We don't want this poll to\n-    \/\/ return false (i.e. not safepointing) and a later poll of the global\n-    \/\/ SafepointSynchronize::_state spuriously to return true.\n-    \/\/\n-    \/\/ This is to avoid a race when we're in a native->Java transition\n-    \/\/ racing the code which wakes up from a safepoint.\n-    __ safepoint_poll(L, true \/* at_return *\/, true \/* acquire *\/, false \/* in_nmethod *\/);\n+    \/\/ No need for acquire as Java threads always disarm themselves.\n+    __ safepoint_poll(L, true \/* at_return *\/, false \/* acquire *\/, false \/* in_nmethod *\/);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateInterpreterGenerator_aarch64.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2194,1 +2194,1 @@\n-    __ ldrw(r3, Address(r3, Klass::access_flags_offset()));\n+    __ ldrb(r3, Address(r3, Klass::misc_flags_offset()));\n@@ -2196,1 +2196,1 @@\n-    __ tbz(r3, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);\n+    __ tbz(r3, exact_log2(KlassFlags::_misc_has_finalizer), skip_register_finalizer);\n","filename":"src\/hotspot\/cpu\/aarch64\/templateTable_aarch64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+#include \"register_aarch64.hpp\"\n@@ -47,0 +48,1 @@\n+int VM_Version::_max_supported_sve_vector_length;\n@@ -510,2 +512,3 @@\n-    } else if (MaxVectorSize < 16) {\n-      warning(\"SVE does not support vector length less than 16 bytes. Disabling SVE.\");\n+    } else if (MaxVectorSize < FloatRegister::sve_vl_min) {\n+      warning(\"SVE does not support vector length less than %d bytes. Disabling SVE.\",\n+              FloatRegister::sve_vl_min);\n@@ -513,14 +516,1 @@\n-    } else if ((MaxVectorSize % 16) == 0 && is_power_of_2(MaxVectorSize)) {\n-      int new_vl = set_and_get_current_sve_vector_length(MaxVectorSize);\n-      _initial_sve_vector_length = new_vl;\n-      \/\/ Update MaxVectorSize to the largest supported value.\n-      if (new_vl < 0) {\n-        vm_exit_during_initialization(\n-          err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n-                  (int)MaxVectorSize));\n-      } else if (new_vl != MaxVectorSize) {\n-        warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n-                new_vl, new_vl);\n-      }\n-      MaxVectorSize = new_vl;\n-    } else {\n+    } else if (!((MaxVectorSize % FloatRegister::sve_vl_min) == 0 && is_power_of_2(MaxVectorSize))) {\n@@ -529,0 +519,19 @@\n+\n+    if (UseSVE > 0) {\n+      \/\/ Acquire the largest supported vector length of this machine\n+      _max_supported_sve_vector_length = set_and_get_current_sve_vector_length(FloatRegister::sve_vl_max);\n+\n+      if (MaxVectorSize != _max_supported_sve_vector_length) {\n+        int new_vl = set_and_get_current_sve_vector_length(MaxVectorSize);\n+        if (new_vl < 0) {\n+          vm_exit_during_initialization(\n+            err_msg(\"Current system does not support SVE vector length for MaxVectorSize: %d\",\n+                    (int)MaxVectorSize));\n+        } else if (new_vl != MaxVectorSize) {\n+          warning(\"Current system only supports max SVE vector length %d. Set MaxVectorSize to %d\",\n+                  new_vl, new_vl);\n+        }\n+        MaxVectorSize = new_vl;\n+      }\n+      _initial_sve_vector_length = MaxVectorSize;\n+    }\n@@ -533,1 +542,1 @@\n-    int max_vector_size = 16;\n+    int max_vector_size = FloatRegister::neon_vl;\n@@ -545,1 +554,1 @@\n-      FLAG_SET_DEFAULT(MaxVectorSize, 16);\n+      FLAG_SET_DEFAULT(MaxVectorSize, FloatRegister::neon_vl);\n@@ -549,1 +558,1 @@\n-  int inline_size = (UseSVE > 0 && MaxVectorSize >= 16) ? MaxVectorSize : 0;\n+  int inline_size = (UseSVE > 0 && MaxVectorSize >= FloatRegister::sve_vl_min) ? MaxVectorSize : 0;\n@@ -609,1 +618,1 @@\n-    if (strcasestr(line, virt1) != 0) {\n+    if (strcasestr(line, virt1) != nullptr) {\n@@ -614,1 +623,1 @@\n-    if (virt2 != nullptr && strcasestr(line, virt2) != 0) {\n+    if (virt2 != nullptr && strcasestr(line, virt2) != nullptr) {\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.cpp","additions":30,"deletions":21,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -49,0 +49,1 @@\n+  static int _max_supported_sve_vector_length;\n@@ -167,1 +168,2 @@\n-  static int get_initial_sve_vector_length()  { return _initial_sve_vector_length; };\n+  static int get_initial_sve_vector_length()        { return _initial_sve_vector_length; };\n+  static int get_max_supported_sve_vector_length()  { return _max_supported_sve_vector_length; };\n","filename":"src\/hotspot\/cpu\/aarch64\/vm_version_aarch64.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -8956,0 +8956,14 @@\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp()\n+%{\n+  match(ForwardException);\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"b    forward_exception_stub\" %}\n+  ins_encode %{\n+    \/\/ OK to trash Rtemp, because Rtemp is used by stub\n+    __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n+  %}\n+  ins_pipe(tail_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/arm\/arm.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -198,2 +198,2 @@\n-    ldr_u32(tmp2, Address(tmp2, Klass::access_flags_offset()));\n-    tst(tmp2, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(tmp2, Address(tmp2, Klass::misc_flags_offset()));\n+    tst(tmp2, KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/arm\/c1_MacroAssembler_arm.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -507,1 +507,1 @@\n-        \/\/ Do not call runtime if JVM_ACC_HAS_FINALIZER flag is not set\n+        \/\/ Do not call runtime if has_finalizer flag is not set\n@@ -509,1 +509,1 @@\n-        __ ldr_u32(Rtemp, Address(Rtemp, Klass::access_flags_offset()));\n+        __ ldrb(Rtemp, Address(Rtemp, Klass::misc_flags_offset()));\n@@ -511,1 +511,1 @@\n-        __ tst(Rtemp, JVM_ACC_HAS_FINALIZER);\n+        __ tst(Rtemp, KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/arm\/c1_Runtime1_arm.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,2 +89,2 @@\n-    ldr_u32(Rscratch, Address(Rscratch, Klass::access_flags_offset()));\n-    tst(Rscratch, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    ldrb(Rscratch, Address(Rscratch, Klass::misc_flags_offset()));\n+    tst(Rscratch, KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/arm\/c2_MacroAssembler_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -912,2 +912,2 @@\n-      ldr_u32(R0, Address(R0, Klass::access_flags_offset()));\n-      tst(R0, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      ldrb(R0, Address(R0, Klass::misc_flags_offset()));\n+      tst(R0, KlassFlags::_misc_is_value_based_class);\n@@ -988,9 +988,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Pass oop, not lock, in fast lock case. call_VM wants R1 though.\n-      push(R1);\n-      mov(R1, Robj);\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), R1);\n-      pop(R1);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), Rlock);\n","filename":"src\/hotspot\/cpu\/arm\/interp_masm_arm.cpp","additions":4,"deletions":12,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -42,0 +42,1 @@\n+#include \"runtime\/sharedRuntime.hpp\"\n@@ -143,1 +144,1 @@\n-  __ jump(StubRoutines::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n+  __ jump(SharedRuntime::throw_AbstractMethodError_entry(), relocInfo::runtime_call_type, Rtemp);\n@@ -464,1 +465,1 @@\n-      __ jump(StubRoutines::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n+      __ jump(SharedRuntime::throw_IncompatibleClassChangeError_entry(), relocInfo::runtime_call_type, Rtemp);\n","filename":"src\/hotspot\/cpu\/arm\/methodHandles_arm.cpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1731,0 +1731,140 @@\n+\n+\/\/------------------------------------------------------------------------------------------------------------------------\n+\/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+\/\/ the current activation. Fabricates an exception oop and initiates normal\n+\/\/ exception dispatching in this frame.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  int insts_size = 128;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps;\n+  int frame_size;\n+  int frame_complete;\n+\n+  oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  frame_size = 2;\n+  __ mov(Rexception_pc, LR);\n+  __ raw_push(FP, LR);\n+\n+  frame_complete = __ pc() - start;\n+\n+  \/\/ Any extra arguments are already supposed to be R1 and R2\n+  __ mov(R0, Rthread);\n+\n+  int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n+  assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n+  __ call(runtime_entry);\n+  if (pc_offset == -1) {\n+    pc_offset = __ offset();\n+  }\n+\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n+  oop_maps->add_gc_map(pc_offset, map);\n+  __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n+\n+  __ raw_pop(FP, LR);\n+  __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n+                                                    frame_size, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(R0, Rtemp, R1);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    r1_off,\n+    r2_off,\n+    return_off,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ raw_push(R1, R2, LR);\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(SP, FP, true, Rtemp);\n+  __ mov(c_rarg0, Rthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n+  __ reset_last_Java_frame(Rtemp);\n+\n+  __ raw_pop(R1, R2, LR);\n+  __ ret();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/arm\/sharedRuntime_arm.cpp","additions":140,"deletions":0,"binary":false,"changes":140,"status":"modified"},{"patch":"@@ -2964,46 +2964,0 @@\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  address generate_throw_exception(const char* name, address runtime_entry) {\n-    int insts_size = 128;\n-    int locs_size  = 32;\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps;\n-    int frame_size;\n-    int frame_complete;\n-\n-    oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    frame_size = 2;\n-    __ mov(Rexception_pc, LR);\n-    __ raw_push(FP, LR);\n-\n-    frame_complete = __ pc() - start;\n-\n-    \/\/ Any extra arguments are already supposed to be R1 and R2\n-    __ mov(R0, Rthread);\n-\n-    int pc_offset = __ set_last_Java_frame(SP, FP, false, Rtemp);\n-    assert(((__ pc()) - start) == __ offset(), \"warning: start differs from code_begin\");\n-    __ call(runtime_entry);\n-    if (pc_offset == -1) {\n-      pc_offset = __ offset();\n-    }\n-\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(frame_size*VMRegImpl::slots_per_word, 0);\n-    oop_maps->add_gc_map(pc_offset, map);\n-    __ reset_last_Java_frame(Rtemp); \/\/ Rtemp free since scratched by far call\n-\n-    __ raw_pop(FP, LR);\n-    __ jump(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type, Rtemp);\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete,\n-                                                      frame_size, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n@@ -3028,89 +2982,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    \/\/ R0 is jobject handle result, unpack and process it through a barrier.\n-    __ resolve_global_jobject(R0, Rtemp, R1);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      r1_off,\n-      r2_off,\n-      return_off,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-    __ raw_push(R1, R2, LR);\n-    address the_pc = __ pc();\n-\n-    int frame_complete = the_pc - start;\n-\n-    __ set_last_Java_frame(SP, FP, true, Rtemp);\n-    __ mov(c_rarg0, Rthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), c_rarg0);\n-    __ reset_last_Java_frame(Rtemp);\n-\n-    __ raw_pop(R1, R2, LR);\n-    __ ret();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(frame_complete, map);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps,\n-                                    false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3135,2 +3000,0 @@\n-    StubRoutines::_throw_StackOverflowError_entry  = generate_throw_exception(\"StackOverflowError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-\n@@ -3158,2 +3021,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3162,9 +3023,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3174,6 +3026,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/arm\/stubGenerator_arm.cpp","additions":0,"deletions":154,"binary":false,"changes":154,"status":"modified"},{"patch":"@@ -563,1 +563,1 @@\n-  __ b(StubRoutines::throw_StackOverflowError_entry(), ls);\n+  __ b(SharedRuntime::throw_StackOverflowError_entry(), ls);\n","filename":"src\/hotspot\/cpu\/arm\/templateInterpreterGenerator_arm.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2497,2 +2497,2 @@\n-    __ ldr_u32(Rtemp, Address(Rtemp, Klass::access_flags_offset()));\n-    __ tbz(Rtemp, exact_log2(JVM_ACC_HAS_FINALIZER), skip_register_finalizer);\n+    __ ldrb(Rtemp, Address(Rtemp, Klass::misc_flags_offset()));\n+    __ tbz(Rtemp, exact_log2(KlassFlags::_misc_has_finalizer), skip_register_finalizer);\n","filename":"src\/hotspot\/cpu\/arm\/templateTable_arm.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -295,1 +295,1 @@\n-void Assembler::add(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::add(Register d, Register s, RegisterOrConstant roc) {\n@@ -299,1 +299,3 @@\n-    addi(d, s1, (int)c);\n+    addi(d, s, (int)c);\n+  } else {\n+    add(d, s, roc.as_register());\n@@ -301,1 +303,0 @@\n-  else add(d, roc.as_register(), s1);\n@@ -304,1 +305,1 @@\n-void Assembler::subf(Register d, RegisterOrConstant roc, Register s1) {\n+void Assembler::sub(Register d, Register s, RegisterOrConstant roc) {\n@@ -308,1 +309,13 @@\n-    addi(d, s1, (int)-c);\n+    addi(d, s, (int)-c);\n+  } else {\n+    sub(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::xorr(Register d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_uimm(c, 16), \"too big\");\n+    xori(d, s, (int)c);\n+  } else {\n+    xorr(d, s, roc.as_register());\n@@ -310,1 +323,0 @@\n-  else subf(d, roc.as_register(), s1);\n@@ -313,1 +325,1 @@\n-void Assembler::cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1) {\n+void Assembler::cmpw(ConditionRegister d, Register s, RegisterOrConstant roc) {\n@@ -317,1 +329,13 @@\n-    cmpdi(d, s1, (int)c);\n+    cmpwi(d, s, (int)c);\n+  } else {\n+    cmpw(d, s, roc.as_register());\n+  }\n+}\n+\n+void Assembler::cmpd(ConditionRegister d, Register s, RegisterOrConstant roc) {\n+  if (roc.is_constant()) {\n+    intptr_t c = roc.as_constant();\n+    assert(is_simm(c, 16), \"too big\");\n+    cmpdi(d, s, (int)c);\n+  } else {\n+    cmpd(d, s, roc.as_register());\n@@ -319,1 +343,0 @@\n-  else cmpd(d, roc.as_register(), s1);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.cpp","additions":32,"deletions":9,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2515,3 +2515,7 @@\n-  void add( Register d, RegisterOrConstant roc, Register s1);\n-  void subf(Register d, RegisterOrConstant roc, Register s1);\n-  void cmpd(ConditionRegister d, RegisterOrConstant roc, Register s1);\n+  void add( Register d, Register s, RegisterOrConstant roc);\n+  void add( Register d, RegisterOrConstant roc, Register s) { add(d, s, roc); }\n+  void sub( Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, Register s, RegisterOrConstant roc);\n+  void xorr(Register d, RegisterOrConstant roc, Register s) { xorr(d, s, roc); }\n+  void cmpw(ConditionRegister d, Register s, RegisterOrConstant roc);\n+  void cmpd(ConditionRegister d, Register s, RegisterOrConstant roc);\n","filename":"src\/hotspot\/cpu\/ppc\/assembler_ppc.hpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2623,1 +2623,1 @@\n-                noreg, \/*check without ldarx first*\/true);\n+                noreg, nullptr, \/*check without ldarx first*\/true);\n","filename":"src\/hotspot\/cpu\/ppc\/c1_LIRAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-    lwz(Rscratch, in_bytes(Klass::access_flags_offset()), Rscratch);\n-    testbitdi(CCR0, R0, Rscratch, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbz(Rscratch, in_bytes(Klass::misc_flags_offset()), Rscratch);\n+    testbitdi(CCR0, R0, Rscratch, exact_log2(KlassFlags::_misc_is_value_based_class));\n","filename":"src\/hotspot\/cpu\/ppc\/c1_MacroAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -482,2 +482,2 @@\n-        __ lwz(t, in_bytes(Klass::access_flags_offset()), t);\n-        __ testbitdi(CCR0, R0, t, exact_log2(JVM_ACC_HAS_FINALIZER));\n+        __ lbz(t, in_bytes(Klass::misc_flags_offset()), t);\n+        __ testbitdi(CCR0, R0, t, exact_log2(KlassFlags::_misc_has_finalizer));\n","filename":"src\/hotspot\/cpu\/ppc\/c1_Runtime1_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -672,1 +672,1 @@\n-                false, success_flag, true);\n+                false, success_flag, nullptr, true);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/shenandoah\/shenandoahBarrierSetAssembler_ppc.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -338,1 +338,1 @@\n-      __ add(ref_base, ind_or_offs, ref_base);\n+      __ add(ref_base, ref_base, ind_or_offs);\n@@ -346,1 +346,1 @@\n-      __ subf(ref_base, ind_or_offs, ref_base);\n+      __ sub(ref_base, ref_base, ind_or_offs);\n","filename":"src\/hotspot\/cpu\/ppc\/gc\/z\/zBarrierSetAssembler_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -973,2 +973,2 @@\n-      lwz(tmp, in_bytes(Klass::access_flags_offset()), tmp);\n-      testbitdi(CCR0, R0, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+      lbz(tmp, in_bytes(Klass::misc_flags_offset()), tmp);\n+      testbitdi(CCR0, R0, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -1046,5 +1046,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj), object);\n-    } else {\n-      call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n-    }\n+    call_VM(noreg, CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter), monitor);\n","filename":"src\/hotspot\/cpu\/ppc\/interp_masm_ppc_64.cpp","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1504,1 +1504,1 @@\n-  load_const_optimized(R0, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(R0, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -1623,1 +1623,1 @@\n-                                       Register compare_value, Register exchange_value,\n+                                       RegisterOrConstant compare_value, Register exchange_value,\n@@ -1637,1 +1637,1 @@\n-    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value, exchange_value, addr_base);\n+    assert_different_registers(tmp1, tmp2, dest_current_value, compare_value.register_or_noreg(), exchange_value, addr_base);\n@@ -1698,1 +1698,1 @@\n-                                     Register compare_value, Register exchange_value,\n+                                     RegisterOrConstant compare_value, Register exchange_value,\n@@ -1700,2 +1700,2 @@\n-                                     int semantics, bool cmpxchgx_hint,\n-                                     Register int_flag_success, bool contention_hint, bool weak, int size) {\n+                                     int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                                     Label* failed_ext, bool contention_hint, bool weak, int size) {\n@@ -1703,1 +1703,2 @@\n-  Label failed;\n+  Label failed_int;\n+  Label& failed = (failed_ext != nullptr) ? *failed_ext : failed_int;\n@@ -1709,1 +1710,1 @@\n-  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value &&\n+  bool preset_result_reg = (int_flag_success != dest_current_value && int_flag_success != compare_value.register_or_noreg() &&\n@@ -1713,0 +1714,1 @@\n+  assert(int_flag_success == noreg || failed_ext == nullptr, \"cannot have both\");\n@@ -1738,1 +1740,1 @@\n-  if (!weak || use_result_reg) {\n+  if (!weak || use_result_reg || failed_ext) {\n@@ -1763,1 +1765,1 @@\n-  bind(failed);\n+  bind(failed_int);\n@@ -1790,4 +1792,5 @@\n-void MacroAssembler::cmpxchgd(ConditionRegister flag,\n-                              Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                              Register addr_base, int semantics, bool cmpxchgx_hint,\n-                              Register int_flag_success, Label* failed_ext, bool contention_hint, bool weak) {\n+void MacroAssembler::cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                              RegisterOrConstant compare_value, Register exchange_value,\n+                              Register addr_base,\n+                              int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                              Label* failed_ext, bool contention_hint, bool weak) {\n@@ -1813,1 +1816,1 @@\n-    cmpd(flag, compare_value, dest_current_value);\n+    cmpd(flag, dest_current_value, compare_value);\n@@ -1826,1 +1829,1 @@\n-  cmpd(flag, compare_value, dest_current_value);\n+  cmpd(flag, dest_current_value, compare_value);\n@@ -2173,1 +2176,0 @@\n-\/\/ Return true: we succeeded in generating this code\n@@ -2295,3 +2297,2 @@\n-  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n-  cmpdi(CCR0, r_bitmap, -1);\n-  beq(CCR0, L_huge);\n+  cmpwi(CCR0, r_array_length, (int32_t)Klass::SECONDARY_SUPERS_TABLE_SIZE - 2);\n+  bgt(CCR0, L_huge);\n@@ -2563,2 +2564,2 @@\n-    lwz(temp, in_bytes(Klass::access_flags_offset()), temp);\n-    testbitdi(flag, R0, temp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbz(temp, in_bytes(Klass::misc_flags_offset()), temp);\n+    testbitdi(flag, R0, temp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -2754,2 +2755,2 @@\n-    lwz(tmp1, in_bytes(Klass::access_flags_offset()), tmp1);\n-    testbitdi(flag, R0, tmp1, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbz(tmp1, in_bytes(Klass::misc_flags_offset()), tmp1);\n+    testbitdi(flag, R0, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -2807,26 +2808,33 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-    const Register owner_addr = tmp2;\n-\n-    \/\/ Compute owner address.\n-    addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n-\n-    \/\/ CAS owner (null => current thread).\n-    cmpxchgd(\/*flag=*\/flag,\n-            \/*current_value=*\/t,\n-            \/*compare_value=*\/(intptr_t)0,\n-            \/*exchange_value=*\/R16_thread,\n-            \/*where=*\/owner_addr,\n-            MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n-            MacroAssembler::cmpxchgx_hint_acquire_lock());\n-    beq(flag, locked);\n-\n-    \/\/ Check if recursive.\n-    cmpd(flag, t, R16_thread);\n-    bne(flag, slow_path);\n-\n-    \/\/ Recursive.\n-    ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n-    addi(tmp1, tmp1, 1);\n-    std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+      const Register owner_addr = tmp2;\n+\n+      \/\/ Compute owner address.\n+      addi(owner_addr, tagged_monitor, in_bytes(ObjectMonitor::owner_offset()) - monitor_tag);\n+\n+      \/\/ CAS owner (null => current thread).\n+      cmpxchgd(\/*flag=*\/flag,\n+              \/*current_value=*\/t,\n+              \/*compare_value=*\/(intptr_t)0,\n+              \/*exchange_value=*\/R16_thread,\n+              \/*where=*\/owner_addr,\n+              MacroAssembler::MemBarRel | MacroAssembler::MemBarAcq,\n+              MacroAssembler::cmpxchgx_hint_acquire_lock());\n+      beq(flag, locked);\n+\n+      \/\/ Check if recursive.\n+      cmpd(flag, t, R16_thread);\n+      bne(flag, slow_path);\n+\n+      \/\/ Recursive.\n+      ld(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+      addi(tmp1, tmp1, 1);\n+      std(tmp1, in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), owner_addr);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n@@ -2900,1 +2908,5 @@\n-    bne(CCR0, inflated);\n+    if (!UseObjectMonitorTable) {\n+      bne(CCR0, inflated);\n+    } else {\n+      bne(CCR0, push_and_slow);\n+    }\n@@ -2946,43 +2958,50 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    subi(monitor, mark, monitor_tag);\n-\n-    const Register recursions = tmp2;\n-    Label not_recursive;\n-\n-    \/\/ Check if recursive.\n-    ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    addic_(recursions, recursions, -1);\n-    blt(CCR0, not_recursive);\n-\n-    \/\/ Recursive unlock.\n-    std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n-    crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n-    b(unlocked);\n-\n-    bind(not_recursive);\n-\n-    Label release_;\n-    const Register t2 = tmp2;\n-\n-    \/\/ Check if the entry lists are empty.\n-    ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n-    ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n-    orr(t, t, t2);\n-    cmpdi(flag, t, 0);\n-    beq(flag, release_);\n-\n-    \/\/ The owner may be anonymous and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n-    b(slow_path);\n-\n-    bind(release_);\n-    \/\/ Set owner to null.\n-    release();\n-    \/\/ t contains 0\n-    std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n+      const uintptr_t monitor_tag = markWord::monitor_value;\n+\n+      \/\/ Untag the monitor.\n+      subi(monitor, mark, monitor_tag);\n+\n+      const Register recursions = tmp2;\n+      Label not_recursive;\n+\n+      \/\/ Check if recursive.\n+      ld(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      addic_(recursions, recursions, -1);\n+      blt(CCR0, not_recursive);\n+\n+      \/\/ Recursive unlock.\n+      std(recursions, in_bytes(ObjectMonitor::recursions_offset()), monitor);\n+      crorc(CCR0, Assembler::equal, CCR0, Assembler::equal);\n+      b(unlocked);\n+\n+      bind(not_recursive);\n+\n+      Label release_;\n+      const Register t2 = tmp2;\n+\n+      \/\/ Check if the entry lists are empty.\n+      ld(t, in_bytes(ObjectMonitor::EntryList_offset()), monitor);\n+      ld(t2, in_bytes(ObjectMonitor::cxq_offset()), monitor);\n+      orr(t, t, t2);\n+      cmpdi(flag, t, 0);\n+      beq(flag, release_);\n+\n+      \/\/ The owner may be anonymous and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      std(R16_thread, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+      b(slow_path);\n+\n+      bind(release_);\n+      \/\/ Set owner to null.\n+      release();\n+      \/\/ t contains 0\n+      std(t, in_bytes(ObjectMonitor::owner_offset()), monitor);\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      crxor(flag, Assembler::equal, flag, Assembler::equal);\n+      b(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.cpp","additions":113,"deletions":94,"binary":false,"changes":207,"status":"modified"},{"patch":"@@ -485,1 +485,1 @@\n-                         Register compare_value, Register exchange_value,\n+                         RegisterOrConstant compare_value, Register exchange_value,\n@@ -488,4 +488,5 @@\n-  void cmpxchg_generic(ConditionRegister flag,\n-                       Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                       Register tmp1, Register tmp2,\n-                       int semantics, bool cmpxchgx_hint, Register int_flag_success, bool contention_hint, bool weak, int size);\n+  void cmpxchg_generic(ConditionRegister flag, Register dest_current_value,\n+                       RegisterOrConstant compare_value, Register exchange_value,\n+                       Register addr_base, Register tmp1, Register tmp2,\n+                       int semantics, bool cmpxchgx_hint, Register int_flag_success,\n+                       Label* failed_ext, bool contention_hint, bool weak, int size);\n@@ -531,4 +532,5 @@\n-  void cmpxchgb(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgb(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -536,1 +538,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 1);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 1);\n@@ -540,4 +542,5 @@\n-  void cmpxchgh(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                Register tmp1, Register tmp2, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgh(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base, Register tmp1, Register tmp2,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -545,1 +548,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 2);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 2);\n@@ -547,4 +550,5 @@\n-  void cmpxchgw(ConditionRegister flag,\n-                Register dest_current_value, Register compare_value, Register exchange_value, Register addr_base,\n-                int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, bool contention_hint = false, bool weak = false) {\n+  void cmpxchgw(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false) {\n@@ -552,1 +556,1 @@\n-                    semantics, cmpxchgx_hint, int_flag_success, contention_hint, weak, 4);\n+                    semantics, cmpxchgx_hint, int_flag_success, failed, contention_hint, weak, 4);\n@@ -554,4 +558,5 @@\n-  void cmpxchgd(ConditionRegister flag,\n-                Register dest_current_value, RegisterOrConstant compare_value, Register exchange_value,\n-                Register addr_base, int semantics, bool cmpxchgx_hint = false,\n-                Register int_flag_success = noreg, Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n+  void cmpxchgd(ConditionRegister flag, Register dest_current_value,\n+                RegisterOrConstant compare_value, Register exchange_value,\n+                Register addr_base,\n+                int semantics, bool cmpxchgx_hint = false, Register int_flag_success = noreg,\n+                Label* failed = nullptr, bool contention_hint = false, bool weak = false);\n","filename":"src\/hotspot\/cpu\/ppc\/macroAssembler_ppc.hpp","additions":29,"deletions":24,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -161,2 +161,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -492,1 +492,1 @@\n-      __ load_const_optimized(temp1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(temp1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/ppc\/methodHandles_ppc.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -7393,1 +7393,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7412,1 +7412,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7431,1 +7431,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7450,1 +7450,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7468,1 +7468,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7486,1 +7486,1 @@\n-                $res$$Register, true);\n+                $res$$Register, nullptr, true);\n@@ -7544,1 +7544,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7558,1 +7558,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7572,1 +7572,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7586,1 +7586,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7600,1 +7600,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7614,1 +7614,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7628,1 +7628,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7642,1 +7642,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7656,1 +7656,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7672,1 +7672,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7686,1 +7686,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7702,1 +7702,1 @@\n-                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, \/*weak*\/ true);\n+                MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, nullptr, true, \/*weak*\/ true);\n@@ -7779,1 +7779,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7793,1 +7793,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7807,1 +7807,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7827,1 +7827,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7847,1 +7847,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7861,1 +7861,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7875,1 +7875,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7895,1 +7895,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7915,1 +7915,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7929,1 +7929,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7949,1 +7949,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -7963,1 +7963,1 @@\n-                noreg, true);\n+                noreg, nullptr, true);\n@@ -14537,0 +14537,15 @@\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp()\n+%{\n+  match(ForwardException);\n+  ins_cost(CALL_COST);\n+\n+  format %{ \"Jmp     forward_exception_stub\" %}\n+  ins_encode %{\n+    __ set_inst_mark();\n+    __ b64_patchable(StubRoutines::forward_exception_entry(), relocInfo::runtime_call_type);\n+    __ clear_inst_mark();\n+  %}\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/ppc\/ppc.ad","additions":45,"deletions":30,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -47,0 +47,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -3407,0 +3408,94 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal register window \/ RegisterMap handling).  If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\/\/\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\/\/\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  int frame_size_in_bytes = frame::native_abi_reg_args_size;\n+  OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n+\n+  address start = __ pc();\n+\n+  __ save_LR(R11_scratch1);\n+\n+  \/\/ Push a frame.\n+  __ push_frame_reg_args(0, R11_scratch1);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of\n+  \/\/ stack by this point. Remember the offset of the instruction\n+  \/\/ whose address will be moved to R11_scratch1.\n+  address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n+\n+  __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n+\n+  __ mr(R3_ARG1, R16_thread);\n+#if defined(ABI_ELFv2)\n+  __ call_c(runtime_entry, relocInfo::none);\n+#else\n+  __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n+#endif\n+\n+  \/\/ Set an oopmap for the call site.\n+  oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending\n+  \/\/ exception.\n+  {\n+    Label L;\n+    __ ld(R0,\n+          in_bytes(Thread::pending_exception_offset()),\n+          R16_thread);\n+    __ cmpdi(CCR0, R0, 0);\n+    __ bne(CCR0, L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  \/\/ Pop frame.\n+  __ pop_frame();\n+\n+  __ restore_LR(R11_scratch1);\n+\n+  __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n+  __ mtctr(R11_scratch1);\n+  __ bctr();\n+\n+  \/\/ Create runtime stub with OopMap.\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n+                                  frame_size_in_bytes\/wordSize,\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n@@ -3650,0 +3745,78 @@\n+\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  \/\/ The handle is dereferenced through a load barrier.\n+  __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  CodeBuffer code(\"jfr_return_lease\", 512, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  Register tmp1 = R10_ARG8;\n+  Register tmp2 = R9_ARG7;\n+\n+  int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n+  address start = __ pc();\n+  __ mflr(tmp1);\n+  __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n+  __ push_frame_reg_args(0, tmp1);\n+  int frame_complete = __ pc() - start;\n+  __ set_last_Java_frame(R1_SP, noreg);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n+  address calls_return_pc = __ last_calls_return_pc();\n+  __ reset_last_Java_frame();\n+  __ pop_frame();\n+  __ ld(tmp1, _abi0(lr), R1_SP);\n+  __ mtlr(tmp1);\n+  __ blr();\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(calls_return_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/ppc\/sharedRuntime_ppc.cpp","additions":173,"deletions":0,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -520,103 +520,0 @@\n-#define __ masm->\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal register window \/ RegisterMap handling).  If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-  \/\/\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-  \/\/\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-  address generate_throw_exception(const char* name, address runtime_entry, bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    CodeBuffer code(name, 1024 DEBUG_ONLY(+ 512), 0);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    int frame_size_in_bytes = frame::native_abi_reg_args_size;\n-    OopMap* map = new OopMap(frame_size_in_bytes \/ sizeof(jint), 0);\n-\n-    address start = __ pc();\n-\n-    __ save_LR(R11_scratch1);\n-\n-    \/\/ Push a frame.\n-    __ push_frame_reg_args(0, R11_scratch1);\n-\n-    address frame_complete_pc = __ pc();\n-\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception with restore_saved_exception_pc\");\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of\n-    \/\/ stack by this point. Remember the offset of the instruction\n-    \/\/ whose address will be moved to R11_scratch1.\n-    address gc_map_pc = __ get_PC_trash_LR(R11_scratch1);\n-\n-    __ set_last_Java_frame(\/*sp*\/R1_SP, \/*pc*\/R11_scratch1);\n-\n-    __ mr(R3_ARG1, R16_thread);\n-    if (arg1 != noreg) {\n-      __ mr(R4_ARG2, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mr(R5_ARG3, arg2);\n-    }\n-#if defined(ABI_ELFv2)\n-    __ call_c(runtime_entry, relocInfo::none);\n-#else\n-    __ call_c(CAST_FROM_FN_PTR(FunctionDescriptor*, runtime_entry), relocInfo::none);\n-#endif\n-\n-    \/\/ Set an oopmap for the call site.\n-    oop_maps->add_gc_map((int)(gc_map_pc - start), map);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending\n-    \/\/ exception.\n-    {\n-      Label L;\n-      __ ld(R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                R16_thread);\n-      __ cmpdi(CCR0, R0, 0);\n-      __ bne(CCR0, L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    \/\/ Pop frame.\n-    __ pop_frame();\n-\n-    __ restore_LR(R11_scratch1);\n-\n-    __ load_const(R11_scratch1, StubRoutines::forward_exception_entry());\n-    __ mtctr(R11_scratch1);\n-    __ bctr();\n-\n-    \/\/ Create runtime stub with OopMap.\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    \/*frame_complete=*\/ (int)(frame_complete_pc - start),\n-                                    frame_size_in_bytes\/wordSize,\n-                                    oop_maps,\n-                                    false);\n-    return stub->entry_point();\n-  }\n-#undef __\n@@ -4619,1 +4516,1 @@\n-    __ load_const_optimized(tmp1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+    __ load_const_optimized(tmp1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n@@ -4678,78 +4575,0 @@\n-#if INCLUDE_JFR\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    CodeBuffer code(\"jfr_write_checkpoint\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    \/\/ The handle is dereferenced through a load barrier.\n-    __ resolve_global_jobject(R3_RET, tmp1, tmp2, MacroAssembler::PRESERVATION_NONE);\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  RuntimeStub* generate_jfr_return_lease() {\n-    CodeBuffer code(\"jfr_return_lease\", 512, 64);\n-    MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-    Register tmp1 = R10_ARG8;\n-    Register tmp2 = R9_ARG7;\n-\n-    int framesize = frame::native_abi_reg_args_size \/ VMRegImpl::stack_slot_size;\n-    address start = __ pc();\n-    __ mflr(tmp1);\n-    __ std(tmp1, _abi0(lr), R1_SP);  \/\/ save return pc\n-    __ push_frame_reg_args(0, tmp1);\n-    int frame_complete = __ pc() - start;\n-    __ set_last_Java_frame(R1_SP, noreg);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), R16_thread);\n-    address calls_return_pc = __ last_calls_return_pc();\n-    __ reset_last_Java_frame();\n-    __ pop_frame();\n-    __ ld(tmp1, _abi0(lr), R1_SP);\n-    __ mtlr(tmp1);\n-    __ blr();\n-\n-    OopMapSet* oop_maps = new OopMapSet();\n-    OopMap* map = new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(calls_return_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(code.name(),\n-                                    &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4789,8 +4608,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry   =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -4815,10 +4626,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -4826,1 +4627,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -4831,7 +4631,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    \/\/ Handle IncompatibleClassChangeError in itable stubs.\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/ppc\/stubGenerator_ppc.cpp","additions":1,"deletions":208,"binary":false,"changes":209,"status":"modified"},{"patch":"@@ -786,2 +786,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n-  __ load_const_optimized(Rscratch1, (StubRoutines::throw_StackOverflowError_entry()), R0);\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"generated in wrong order\");\n+  __ load_const_optimized(Rscratch1, (SharedRuntime::throw_StackOverflowError_entry()), R0);\n","filename":"src\/hotspot\/cpu\/ppc\/templateInterpreterGenerator_ppc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2133,2 +2133,2 @@\n-    __ lwz(Rklass_flags, in_bytes(Klass::access_flags_offset()), Rklass);\n-    __ testbitdi(CCR0, R0, Rklass_flags, exact_log2(JVM_ACC_HAS_FINALIZER));\n+    __ lbz(Rklass_flags, in_bytes(Klass::misc_flags_offset()), Rklass);\n+    __ testbitdi(CCR0, R0, Rklass_flags, exact_log2(KlassFlags::_misc_has_finalizer));\n","filename":"src\/hotspot\/cpu\/ppc\/templateTable_ppc_64.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -198,1 +198,1 @@\n-    __ cmpd(CCR0, R19_method, 0);\n+    __ cmpdi(CCR0, R19_method, 0);\n","filename":"src\/hotspot\/cpu\/ppc\/vtableStubs_ppc_64.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1831,0 +1831,15 @@\n+#define INSN(NAME, op, width, umop, mop, mew, nf)                                               \\\n+  void NAME(VectorRegister Vd_or_Vs3, Register Rs1, VectorMask vm = unmasked) { \\\n+    patch_VLdSt(op, Vd_or_Vs3, width, Rs1, umop, vm, mop, mew, nf);                         \\\n+  }\n+\n+  \/\/ Vector Unit-Stride Segment Load Instructions\n+  INSN(vlseg3e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g3);\n+  INSN(vlseg4e8_v, 0b0000111, 0b000, 0b00000, 0b00, 0b0, g4);\n+\n+  \/\/ Vector Unit-Stride Segment Store Instructions\n+  INSN(vsseg3e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g3);\n+  INSN(vsseg4e8_v, 0b0100111, 0b000, 0b00000, 0b00, 0b0, g4);\n+\n+#undef INSN\n+\n","filename":"src\/hotspot\/cpu\/riscv\/assembler_riscv.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -545,1 +545,1 @@\n-      assert(c->as_jobject() == 0, \"should be\");\n+      assert(c->as_jobject() == nullptr, \"should be\");\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -65,2 +65,0 @@\n-  void poll_for_safepoint(relocInfo::relocType rtype, CodeEmitInfo* info = nullptr);\n-\n","filename":"src\/hotspot\/cpu\/riscv\/c1_LIRAssembler_riscv.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -67,2 +67,2 @@\n-    lwu(hdr, Address(hdr, Klass::access_flags_offset()));\n-    test_bit(temp, hdr, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbu(hdr, Address(hdr, Klass::misc_flags_offset()));\n+    test_bit(temp, hdr, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -73,1 +73,1 @@\n-    lightweight_lock(obj, hdr, temp, t1, slow_case);\n+    lightweight_lock(disp_hdr, obj, hdr, temp, t1, slow_case);\n","filename":"src\/hotspot\/cpu\/riscv\/c1_MacroAssembler_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -226,2 +226,0 @@\n-const int float_regs_as_doubles_size_in_slots = pd_nof_fpu_regs_frame_map * 2;\n-\n@@ -802,2 +800,2 @@\n-        __ lwu(t, Address(t, Klass::access_flags_offset()));\n-        __ test_bit(t0, t, exact_log2(JVM_ACC_HAS_FINALIZER));\n+        __ lbu(t, Address(t, Klass::misc_flags_offset()));\n+        __ test_bit(t0, t, exact_log2(KlassFlags::_misc_has_finalizer));\n@@ -1069,1 +1067,1 @@\n-const char *Runtime1::pd_name_for_address(address entry) { Unimplemented(); return 0; }\n+const char *Runtime1::pd_name_for_address(address entry) { Unimplemented(); }\n","filename":"src\/hotspot\/cpu\/riscv\/c1_Runtime1_riscv.cpp","additions":4,"deletions":6,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -71,2 +71,2 @@\n-    lwu(tmp, Address(tmp, Klass::access_flags_offset()));\n-    test_bit(tmp, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n+    test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -256,1 +256,2 @@\n-void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register tmp1, Register tmp2, Register tmp3) {\n+void C2_MacroAssembler::fast_lock_lightweight(Register obj, Register box,\n+                                              Register tmp1, Register tmp2, Register tmp3) {\n@@ -261,1 +262,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -272,0 +273,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+  }\n+\n@@ -274,2 +280,2 @@\n-    lwu(tmp1, Address(tmp1, Klass::access_flags_offset()));\n-    test_bit(tmp1, tmp1, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    lbu(tmp1, Address(tmp1, Klass::misc_flags_offset()));\n+    test_bit(tmp1, tmp1, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -280,0 +286,1 @@\n+  const Register tmp3_t = tmp3;\n@@ -287,1 +294,0 @@\n-    const Register tmp3_t = tmp3;\n@@ -326,3 +332,35 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_tagged_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n+    const Register tmp1_monitor = tmp1;\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+    } else {\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      la(tmp3_t, Address(xthread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        ld(tmp1, Address(tmp3_t));\n+        beq(obj, tmp1, monitor_found);\n+        add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      ld(tmp1, Address(tmp3_t));\n+      beq(obj, tmp1, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      add(tmp3_t, tmp3_t, in_bytes(OMCache::oop_to_oop_difference()));\n+      bnez(tmp1, loop);\n+      \/\/ Cache Miss. Take the slowpath.\n+      j(slow_path);\n+\n+      bind(monitor_found);\n+      ld(tmp1_monitor, Address(tmp3_t, OMCache::oop_to_monitor_difference()));\n+    }\n+\n@@ -332,0 +370,6 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address owner_address(tmp1_monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+    const Address recursions_address(tmp1_monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+\n@@ -333,1 +377,1 @@\n-    la(tmp2_owner_addr, Address(tmp1_tagged_monitor, (in_bytes(ObjectMonitor::owner_offset()) - monitor_tag)));\n+    la(tmp2_owner_addr, owner_address);\n@@ -338,1 +382,1 @@\n-    beqz(tmp3_owner, locked);\n+    beqz(tmp3_owner, monitor_locked);\n@@ -344,1 +388,6 @@\n-    increment(Address(tmp1_tagged_monitor, in_bytes(ObjectMonitor::recursions_offset()) - monitor_tag), 1, tmp2, tmp3);\n+    increment(recursions_address, 1, tmp2, tmp3);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      sd(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+    }\n@@ -368,2 +417,2 @@\n-void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register tmp1, Register tmp2,\n-                                                Register tmp3) {\n+void C2_MacroAssembler::fast_unlock_lightweight(Register obj, Register box,\n+                                                Register tmp1, Register tmp2, Register tmp3) {\n@@ -374,1 +423,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, flag, t0);\n+  assert_different_registers(obj, box, tmp1, tmp2, tmp3, flag, t0);\n@@ -379,1 +428,1 @@\n-  Label inflated, inflated_load_monitor;\n+  Label inflated, inflated_load_mark;\n@@ -390,0 +439,1 @@\n+    Label push_and_slow_path;\n@@ -397,1 +447,1 @@\n-    bne(obj, tmp3_t, inflated_load_monitor);\n+    bne(obj, tmp3_t, inflated_load_mark);\n@@ -414,0 +464,3 @@\n+    \/\/ Because we got here by popping (meaning we pushed in locked)\n+    \/\/ there will be no monitor in the box. So we need to push back the obj\n+    \/\/ so that the runtime can fix any potential anonymous owner.\n@@ -415,1 +468,1 @@\n-    bnez(tmp3_t, inflated);\n+    bnez(tmp3_t, UseObjectMonitorTable ? push_and_slow_path : inflated);\n@@ -424,0 +477,1 @@\n+    bind(push_and_slow_path);\n@@ -434,1 +488,1 @@\n-    bind(inflated_load_monitor);\n+    bind(inflated_load_mark);\n@@ -456,6 +510,12 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tmp1_monitor = tmp1_mark;\n-    const uintptr_t monitor_tag = markWord::monitor_value;\n-\n-    \/\/ Untag the monitor.\n-    sub(tmp1_monitor, tmp1_mark, monitor_tag);\n+    const Register tmp1_monitor = tmp1;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(tmp1_monitor == tmp1_mark, \"should be the same here\");\n+      \/\/ Untag the monitor.\n+      add(tmp1_monitor, tmp1_mark, -(int)markWord::monitor_value);\n+    } else {\n+      ld(tmp1_monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ No valid pointer below alignof(ObjectMonitor*). Take the slow path.\n+      mv(tmp3_t, alignof(ObjectMonitor*));\n+      bltu(tmp1_monitor, tmp3_t, slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.cpp","additions":86,"deletions":26,"binary":false,"changes":112,"status":"modified"},{"patch":"@@ -50,2 +50,2 @@\n-  void fast_lock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n-  void fast_unlock_lightweight(Register object, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_lock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n+  void fast_unlock_lightweight(Register object, Register box, Register tmp1, Register tmp2, Register tmp3);\n","filename":"src\/hotspot\/cpu\/riscv\/c2_MacroAssembler_riscv.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -272,1 +272,1 @@\n-  assert(_pc == pc_old || pc == pc_old || pc_old == 0, \"must be\");\n+  assert(_pc == pc_old || pc == pc_old || pc_old == nullptr, \"must be\");\n","filename":"src\/hotspot\/cpu\/riscv\/frame_riscv.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -268,1 +268,1 @@\n-        \/\/ If we patch code we need both a code patching and a loadload\n+        \/\/ If we patch code we need both a cmodx fence and a loadload\n@@ -276,0 +276,1 @@\n+\n@@ -277,4 +278,11 @@\n-        \/\/ Embed an artificial data dependency to order the guard load\n-        \/\/ before the epoch load.\n-        __ srli(ra, t0, 32);\n-        __ orr(t1, t1, ra);\n+        if (!UseZtso) {\n+          \/\/ Embed a synthetic data dependency between the load of the guard and\n+          \/\/ the load of the epoch. This guarantees that these loads occur in\n+          \/\/ order, while allowing other independent instructions to be reordered.\n+          \/\/ Note: This may be slower than using a membar(load|load) (fence r,r).\n+          \/\/ Because processors will not start the second load until the first comes back.\n+          \/\/ This means you cant overlap the two loads,\n+          \/\/ which is stronger than needed for ordering (stronger than TSO).\n+          __ srli(ra, t0, 32);\n+          __ orr(t1, t1, ra);\n+        }\n","filename":"src\/hotspot\/cpu\/riscv\/gc\/shared\/barrierSetAssembler_riscv.cpp","additions":13,"deletions":5,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -753,2 +753,2 @@\n-      lwu(tmp, Address(tmp, Klass::access_flags_offset()));\n-      test_bit(tmp, tmp, exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+      lbu(tmp, Address(tmp, Klass::misc_flags_offset()));\n+      test_bit(tmp, tmp, exact_log2(KlassFlags::_misc_is_value_based_class));\n@@ -759,1 +759,1 @@\n-      lightweight_lock(obj_reg, tmp, tmp2, tmp3, slow_case);\n+      lightweight_lock(lock_reg, obj_reg, tmp, tmp2, tmp3, slow_case);\n@@ -795,9 +795,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n","filename":"src\/hotspot\/cpu\/riscv\/interp_masm_riscv.cpp","additions":7,"deletions":13,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -176,6 +176,1 @@\n-    ExternalAddress target(slow_case_addr);\n-    __ relocate(target.rspec(), [&] {\n-      int32_t offset;\n-      __ la(t0, target.target(), offset);\n-      __ jalr(t0, offset);\n-    });\n+    __ rt_call(slow_case_addr);\n","filename":"src\/hotspot\/cpu\/riscv\/jniFastGetField_riscv.cpp","additions":2,"deletions":7,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -149,12 +149,0 @@\n-bool MacroAssembler::is_li64_at(address instr) {\n-  return is_lui_at(instr) && \/\/ lui\n-         is_addi_at(instr + instruction_size) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 2, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 3) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 4, 12) &&  \/\/ Slli Rd, Rs, 12\n-         is_addi_at(instr + instruction_size * 5) && \/\/ addi\n-         is_slli_shift_at(instr + instruction_size * 6, 8) &&   \/\/ Slli Rd, Rs, 8\n-         is_addi_at(instr + instruction_size * 7) && \/\/ addi\n-         check_li64_data_dependency(instr);\n-}\n-\n@@ -912,1 +900,0 @@\n-  \/\/ use addiw to distinguish li32 to li64\n@@ -916,27 +903,0 @@\n-void MacroAssembler::li64(Register Rd, int64_t imm) {\n-  \/\/ Load upper 32 bits. upper = imm[63:32], but if imm[31] == 1 or\n-  \/\/ (imm[31:20] == 0x7ff && imm[19] == 1), upper = imm[63:32] + 1.\n-  int64_t lower = imm & 0xffffffff;\n-  lower -= ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)(imm & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper = (tmp_imm - (int32_t)lower) >> 32;\n-\n-  \/\/ Load upper 32 bits\n-  int64_t up = upper, lo = upper;\n-  lo = (lo << 52) >> 52;\n-  up -= lo;\n-  up = (int32_t)up;\n-  lui(Rd, up);\n-  addi(Rd, Rd, lo);\n-\n-  \/\/ Load the rest 32 bits.\n-  slli(Rd, Rd, 12);\n-  addi(Rd, Rd, (int32_t)lower >> 20);\n-  slli(Rd, Rd, 12);\n-  lower = ((int32_t)imm << 12) >> 20;\n-  addi(Rd, Rd, lower);\n-  slli(Rd, Rd, 8);\n-  lower = imm & 0xff;\n-  addi(Rd, Rd, lower);\n-}\n-\n@@ -1744,21 +1704,0 @@\n-static int patch_imm_in_li64(address branch, address target) {\n-  const int LI64_INSTRUCTIONS_NUM = 8;                                          \/\/ lui + addi + slli + addi + slli + addi + slli + addi\n-  int64_t lower = (intptr_t)target & 0xffffffff;\n-  lower = lower - ((lower << 44) >> 44);\n-  int64_t tmp_imm = ((uint64_t)((intptr_t)target & 0xffffffff00000000)) + (uint64_t)lower;\n-  int32_t upper =  (tmp_imm - (int32_t)lower) >> 32;\n-  int64_t tmp_upper = upper, tmp_lower = upper;\n-  tmp_lower = (tmp_lower << 52) >> 52;\n-  tmp_upper -= tmp_lower;\n-  tmp_upper >>= 12;\n-  \/\/ Load upper 32 bits. Upper = target[63:32], but if target[31] = 1 or (target[31:20] == 0x7ff && target[19] == 1),\n-  \/\/ upper = target[63:32] + 1.\n-  Assembler::patch(branch + 0,  31, 12, tmp_upper & 0xfffff);                       \/\/ Lui.\n-  Assembler::patch(branch + 4,  31, 20, tmp_lower & 0xfff);                         \/\/ Addi.\n-  \/\/ Load the rest 32 bits.\n-  Assembler::patch(branch + 12, 31, 20, ((int32_t)lower >> 20) & 0xfff);            \/\/ Addi.\n-  Assembler::patch(branch + 20, 31, 20, (((intptr_t)target << 44) >> 52) & 0xfff);  \/\/ Addi.\n-  Assembler::patch(branch + 28, 31, 20, (intptr_t)target & 0xff);                   \/\/ Addi.\n-  return LI64_INSTRUCTIONS_NUM * MacroAssembler::instruction_size;\n-}\n-\n@@ -1835,10 +1774,0 @@\n-static address get_target_of_li64(address insn_addr) {\n-  assert_cond(insn_addr != nullptr);\n-  intptr_t target_address = (((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr), 31, 12)) & 0xfffff) << 44; \/\/ Lui.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 4), 31, 20)) << 32;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 12), 31, 20)) << 20;                \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 20), 31, 20)) << 8;                 \/\/ Addi.\n-  target_address += ((int64_t)Assembler::sextract(Assembler::ld_instr(insn_addr + 28), 31, 20));                      \/\/ Addi.\n-  return (address)target_address;\n-}\n-\n@@ -1867,2 +1796,0 @@\n-  } else if (MacroAssembler::is_li64_at(instruction_address)) {                 \/\/ li64\n-    return patch_imm_in_li64(instruction_address, target);\n@@ -1899,2 +1826,0 @@\n-  } else if (MacroAssembler::is_li64_at(insn_addr)) {             \/\/ li64\n-    return get_target_of_li64(insn_addr);\n@@ -3608,1 +3533,1 @@\n-         \"destination of far call not found in code cache\");\n+         \"destination of far jump not found in code cache\");\n@@ -3613,0 +3538,2 @@\n+  \/\/ We can use auipc + jr here because we know that the total size of\n+  \/\/ the code cache cannot exceed 2Gb.\n@@ -3614,2 +3541,4 @@\n-    int32_t offset;\n-    la(tmp, entry.target(), offset);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far jump using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n@@ -3630,2 +3559,5 @@\n-    assert(is_valid_32bit_offset(entry.target() - pc()), \"Far call using wrong instructions.\");\n-    call(entry.target(), tmp);\n+    int64_t distance = entry.target() - pc();\n+    int32_t offset = ((int32_t)distance << 20) >> 20;\n+    assert(is_valid_32bit_offset(distance), \"Far call using wrong instructions.\");\n+    auipc(tmp, (int32_t)distance + 0x800);\n+    jalr(tmp, offset);\n@@ -3976,2 +3908,2 @@\n-  addi(t0, r_bitmap, (u1)1);\n-  beqz(t0, L_bitmap_full);\n+  subw(t0, r_array_length, Klass::SECONDARY_SUPERS_TABLE_SIZE - 2);\n+  bgtz(t0, L_bitmap_full);\n@@ -4147,1 +4079,1 @@\n-  la(t0, RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  la(t0, RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -5795,1 +5727,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow) {\n@@ -5797,1 +5729,1 @@\n-  assert_different_registers(obj, tmp1, tmp2, tmp3, t0);\n+  assert_different_registers(basic_lock, obj, tmp1, tmp2, tmp3, t0);\n@@ -5808,0 +5740,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    sd(zr, Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))));\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.cpp","additions":22,"deletions":85,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -816,1 +816,0 @@\n-  void li64(Register Rd, int64_t imm);\n@@ -1605,1 +1604,1 @@\n-  void lightweight_lock(Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register tmp1, Register tmp2, Register tmp3, Label& slow);\n@@ -1709,34 +1708,0 @@\n-  \/\/ the instruction sequence of li64 is as below:\n-  \/\/     lui\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  \/\/     slli\n-  \/\/     addi\n-  static bool check_li64_data_dependency(address instr) {\n-    address lui = instr;\n-    address addi1 = lui + instruction_size;\n-    address slli1 = addi1 + instruction_size;\n-    address addi2 = slli1 + instruction_size;\n-    address slli2 = addi2 + instruction_size;\n-    address addi3 = slli2 + instruction_size;\n-    address slli3 = addi3 + instruction_size;\n-    address addi4 = slli3 + instruction_size;\n-    return extract_rs1(addi1) == extract_rd(lui) &&\n-           extract_rs1(addi1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(addi1) &&\n-           extract_rs1(slli1) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(slli1) &&\n-           extract_rs1(addi2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(addi2) &&\n-           extract_rs1(slli2) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(slli2) &&\n-           extract_rs1(addi3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(addi3) &&\n-           extract_rs1(slli3) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(slli3) &&\n-           extract_rs1(addi4) == extract_rd(addi4);\n-  }\n-\n@@ -1787,1 +1752,0 @@\n-  static bool is_li64_at(address instr);\n","filename":"src\/hotspot\/cpu\/riscv\/macroAssembler_riscv.hpp","additions":1,"deletions":37,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -123,1 +123,1 @@\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -444,1 +444,1 @@\n-      __ far_jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ far_jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/methodHandles_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -688,1 +688,1 @@\n-  if ((dest == (address) this) || dest == 0) {\n+  if ((dest == (address) this) || dest == nullptr) {\n@@ -717,1 +717,1 @@\n-  if ((dest == (address) this) || dest == 0) {\n+  if ((dest == (address) this) || dest == nullptr) {\n","filename":"src\/hotspot\/cpu\/riscv\/nativeInst_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -10556,1 +10556,1 @@\n-instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastLockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10560,1 +10560,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10563,1 +10563,1 @@\n-  format %{ \"fastlock $object,$box\\t! kills $box,$tmp1,$tmp2 #@cmpFastLockLightweight\" %}\n+  format %{ \"fastlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastLockLightweight\" %}\n@@ -10566,1 +10566,1 @@\n-    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_lock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -10572,1 +10572,1 @@\n-instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP_R10 box, iRegPNoSp tmp1, iRegPNoSp tmp2)\n+instruct cmpFastUnlockLightweight(rFlagsReg cr, iRegP object, iRegP box, iRegPNoSp tmp1, iRegPNoSp tmp2, iRegPNoSp tmp3)\n@@ -10576,1 +10576,1 @@\n-  effect(TEMP tmp1, TEMP tmp2, USE_KILL box);\n+  effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);\n@@ -10579,1 +10579,1 @@\n-  format %{ \"fastunlock $object,$box\\t! kills $box,$tmp1,$tmp2, #@cmpFastUnlockLightweight\" %}\n+  format %{ \"fastunlock $object,$box\\t! kills $tmp1,$tmp2,$tmp3 #@cmpFastUnlockLightweight\" %}\n@@ -10582,1 +10582,1 @@\n-    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register);\n+    __ fast_unlock_lightweight($object$$Register, $box$$Register, $tmp1$$Register, $tmp2$$Register, $tmp3$$Register);\n@@ -10620,0 +10620,16 @@\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp()\n+%{\n+  match(ForwardException);\n+\n+  ins_cost(BRANCH_COST);\n+\n+  format %{ \"j forward_exception_stub\\t#@ForwardException\" %}\n+\n+  ins_encode %{\n+    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+  %}\n+\n+  ins_pipe(pipe_class_call);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/riscv\/riscv.ad","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -51,0 +51,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -68,0 +69,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif\n+\n@@ -1698,1 +1705,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, tmp, lock_tmp, slow_path_lock);\n@@ -2631,0 +2638,188 @@\n+\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n+  assert_cond(runtime_entry != nullptr);\n+  enum layout {\n+    fp_off = 0,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  const int insts_size = 1024;\n+  const int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  assert_cond(oop_maps != nullptr && masm != nullptr);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ Save FP and RA before call\n+\n+  assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n+\n+  \/\/ ra and fp are already in place\n+  __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+\n+  \/\/ Call runtime\n+  __ mv(c_rarg0, xthread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ rt_call(runtime_entry);\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+  assert_cond(map != nullptr);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n+  __ bnez(t0, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  assert(stub != nullptr, \"create runtime stub fail!\");\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm, Register thread) {\n+  __ set_last_Java_frame(sp, fp, the_pc, t0);\n+  __ mv(c_rarg0, thread);\n+}\n+\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  __ reset_last_Java_frame(true);\n+}\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(x10, t0, t1);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    fp_off,\n+    fp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm, xthread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret();\n+\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/riscv\/sharedRuntime_riscv.cpp","additions":196,"deletions":1,"binary":false,"changes":197,"status":"modified"},{"patch":"@@ -3777,1 +3777,1 @@\n-    __ la(t0, RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+    __ la(t0, RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -5106,0 +5106,492 @@\n+  \/**\n+   * vector registers:\n+   *   input VectorRegister's:  intputV1-V3, for m2 they could be v2, v4, v6, for m1 they could be v1, v2, v3\n+   *   index VectorRegister's:  idxV1-V4, for m2 they could be v8, v10, v12, v14, for m1 they could be v4, v5, v6, v7\n+   *   output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v8, v9, v10, v11\n+   *\n+   * NOTE: each field will occupy a vector register group\n+   *\/\n+  void base64_vector_encode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3, VectorRegister outputV4,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(3)\n+    __ vlseg3e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 3\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ encoding\n+    \/\/   1. compute index into lookup table: vr(3) => vr(4)\n+    __ vsrl_vi(idxV1, inputV1, 2);\n+\n+    __ vsrl_vi(idxV2, inputV2, 2);\n+    __ vsll_vi(inputV1, inputV1, 6);\n+    __ vor_vv(idxV2, idxV2, inputV1);\n+    __ vsrl_vi(idxV2, idxV2, 2);\n+\n+    __ vsrl_vi(idxV3, inputV3, 4);\n+    __ vsll_vi(inputV2, inputV2, 4);\n+    __ vor_vv(idxV3, inputV2, idxV3);\n+    __ vsrl_vi(idxV3, idxV3, 2);\n+\n+    __ vsll_vi(idxV4, inputV3, 2);\n+    __ vsrl_vi(idxV4, idxV4, 2);\n+\n+    \/\/   2. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(outputV1, codec, idxV1);\n+    __ vluxei8_v(outputV2, codec, idxV2);\n+    __ vluxei8_v(outputV3, codec, idxV3);\n+    __ vluxei8_v(outputV4, codec, idxV4);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(4) => mem(dst)\n+    __ vsseg4e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 4\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   *  void j.u.Base64.Encoder.encodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *\/\n+  address generate_base64_encodeBlock() {\n+    alignas(64) static const char toBase64[64] = {\n+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '+', '\/'\n+    };\n+\n+    alignas(64) static const char toBase64URL[64] = {\n+      'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M',\n+      'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',\n+      'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm',\n+      'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',\n+      '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', '-', '_'\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"encodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+\n+    Register codec  = c_rarg6;\n+    Register length = c_rarg7; \/\/ total length of src data in bytes\n+\n+    Label ProcessData, Exit;\n+\n+    \/\/ length should be multiple of 3\n+    __ sub(length, send, soff);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) toBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) toBase64URL));\n+    __ BIND(ProcessData);\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      Label ProcessM2, ProcessM1, ProcessScalar;\n+\n+      Register size      = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 3);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 4);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+      __ BIND(ProcessM2);\n+      base64_vector_encode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst,\n+                    v2, v4, v6,         \/\/ inputs\n+                    v8, v10, v12, v14,  \/\/ indexes\n+                    v16, v18, v20, v22, \/\/ outputs\n+                    Assembler::m2);\n+\n+      __ sub(length, length, stepSrcM2);\n+      __ bge(length, stepSrcM2, ProcessM2);\n+\n+      __ BIND(ProcessM1);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_encode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst,\n+                    v1, v2, v3,         \/\/ inputs\n+                    v4, v5, v6, v7,     \/\/ indexes\n+                    v8, v9, v10, v11,   \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+\n+      __ BIND(ProcessScalar);\n+    }\n+\n+    \/\/ scalar version\n+    {\n+      Register byte1 = soff, byte0 = send, byte2 = doff;\n+      Register combined24Bits = isURL;\n+\n+      __ beqz(length, Exit);\n+\n+      Label ScalarLoop;\n+      __ BIND(ScalarLoop);\n+      {\n+        \/\/ plain:   [byte0[7:0] : byte1[7:0] : byte2[7:0]] =>\n+        \/\/ encoded: [byte0[7:2] : byte0[1:0]+byte1[7:4] : byte1[3:0]+byte2[7:6] : byte2[5:0]]\n+\n+        \/\/ load 3 bytes src data\n+        __ lbu(byte0, Address(src, 0));\n+        __ lbu(byte1, Address(src, 1));\n+        __ lbu(byte2, Address(src, 2));\n+        __ addi(src, src, 3);\n+\n+        \/\/ construct 24 bits from 3 bytes\n+        __ slliw(byte0, byte0, 16);\n+        __ slliw(byte1, byte1, 8);\n+        __ orr(combined24Bits, byte0, byte1);\n+        __ orr(combined24Bits, combined24Bits, byte2);\n+\n+        \/\/ get codec index and encode(ie. load from codec by index)\n+        __ slliw(byte0, combined24Bits, 8);\n+        __ srliw(byte0, byte0, 26);\n+        __ add(byte0, codec, byte0);\n+        __ lbu(byte0, byte0);\n+\n+        __ slliw(byte1, combined24Bits, 14);\n+        __ srliw(byte1, byte1, 26);\n+        __ add(byte1, codec, byte1);\n+        __ lbu(byte1, byte1);\n+\n+        __ slliw(byte2, combined24Bits, 20);\n+        __ srliw(byte2, byte2, 26);\n+        __ add(byte2, codec, byte2);\n+        __ lbu(byte2, byte2);\n+\n+        __ andi(combined24Bits, combined24Bits, 0x3f);\n+        __ add(combined24Bits, codec, combined24Bits);\n+        __ lbu(combined24Bits, combined24Bits);\n+\n+        \/\/ store 4 bytes encoded data\n+        __ sb(byte0, Address(dst, 0));\n+        __ sb(byte1, Address(dst, 1));\n+        __ sb(byte2, Address(dst, 2));\n+        __ sb(combined24Bits, Address(dst, 3));\n+\n+        __ sub(length, length, 3);\n+        __ addi(dst, dst, 4);\n+        \/\/ loop back\n+        __ bnez(length, ScalarLoop);\n+      }\n+    }\n+\n+    __ BIND(Exit);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n+  \/**\n+   * vector registers:\n+   * input VectorRegister's:  intputV1-V4, for m2 they could be v2, v4, v6, for m1 they could be v2, v4, v6, v8\n+   * index VectorRegister's:  idxV1-V3, for m2 they could be v8, v10, v12, v14, for m1 they could be v10, v12, v14, v16\n+   * output VectorRegister's: outputV1-V4, for m2 they could be v16, v18, v20, v22, for m1 they could be v18, v20, v22\n+   *\n+   * NOTE: each field will occupy a single vector register group\n+   *\/\n+  void base64_vector_decode_round(Register src, Register dst, Register codec,\n+                    Register size, Register stepSrc, Register stepDst, Register failedIdx, Register minusOne,\n+                    VectorRegister inputV1, VectorRegister inputV2, VectorRegister inputV3, VectorRegister inputV4,\n+                    VectorRegister idxV1, VectorRegister idxV2, VectorRegister idxV3, VectorRegister idxV4,\n+                    VectorRegister outputV1, VectorRegister outputV2, VectorRegister outputV3,\n+                    Assembler::LMUL lmul) {\n+    \/\/ set vector register type\/len\n+    __ vsetvli(x0, size, Assembler::e8, lmul, Assembler::ma, Assembler::ta);\n+\n+    \/\/ segmented load src into v registers: mem(src) => vr(4)\n+    __ vlseg4e8_v(inputV1, src);\n+\n+    \/\/ src = src + register_group_len_bytes * 4\n+    __ add(src, src, stepSrc);\n+\n+    \/\/ decoding\n+    \/\/   1. indexed load: vr(4) => vr(4)\n+    __ vluxei8_v(idxV1, codec, inputV1);\n+    __ vluxei8_v(idxV2, codec, inputV2);\n+    __ vluxei8_v(idxV3, codec, inputV3);\n+    __ vluxei8_v(idxV4, codec, inputV4);\n+\n+    \/\/   2. check wrong data\n+    __ vor_vv(outputV1, idxV1, idxV2);\n+    __ vor_vv(outputV2, idxV3, idxV4);\n+    __ vor_vv(outputV1, outputV1, outputV2);\n+    __ vmseq_vi(v0, outputV1, -1);\n+    __ vfirst_m(failedIdx, v0);\n+    Label NoFailure;\n+    __ beq(failedIdx, minusOne, NoFailure);\n+    __ vsetvli(x0, failedIdx, Assembler::e8, lmul, Assembler::mu, Assembler::tu);\n+    __ slli(stepDst, failedIdx, 1);\n+    __ add(stepDst, failedIdx, stepDst);\n+    __ BIND(NoFailure);\n+\n+    \/\/   3. compute the decoded data: vr(4) => vr(3)\n+    __ vsll_vi(idxV1, idxV1, 2);\n+    __ vsrl_vi(outputV1, idxV2, 4);\n+    __ vor_vv(outputV1, outputV1, idxV1);\n+\n+    __ vsll_vi(idxV2, idxV2, 4);\n+    __ vsrl_vi(outputV2, idxV3, 2);\n+    __ vor_vv(outputV2, outputV2, idxV2);\n+\n+    __ vsll_vi(idxV3, idxV3, 6);\n+    __ vor_vv(outputV3, idxV4, idxV3);\n+\n+    \/\/ segmented store encoded data in v registers back to dst: vr(3) => mem(dst)\n+    __ vsseg3e8_v(outputV1, dst);\n+\n+    \/\/ dst = dst + register_group_len_bytes * 3\n+    __ add(dst, dst, stepDst);\n+  }\n+\n+  \/**\n+   * int j.u.Base64.Decoder.decodeBlock(byte[] src, int sp, int sl, byte[] dst, int dp, boolean isURL, boolean isMIME)\n+   *\n+   *  Input arguments:\n+   *  c_rarg0   - src, source array\n+   *  c_rarg1   - sp, src start offset\n+   *  c_rarg2   - sl, src end offset\n+   *  c_rarg3   - dst, dest array\n+   *  c_rarg4   - dp, dst start offset\n+   *  c_rarg5   - isURL, Base64 or URL character set\n+   *  c_rarg6   - isMIME, Decoding MIME block\n+   *\/\n+  address generate_base64_decodeBlock() {\n+\n+    static const uint8_t fromBase64[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u, 255u,  63u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u, 255u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    static const uint8_t fromBase64URL[256] = {\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,  62u, 255u, 255u,\n+        52u,  53u,  54u,  55u,  56u,  57u,  58u,  59u,  60u,  61u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u,   0u,   1u,   2u,   3u,   4u,   5u,   6u,   7u,   8u,   9u,  10u,  11u,  12u,  13u,  14u,\n+        15u,  16u,  17u,  18u,  19u,  20u,  21u,  22u,  23u,  24u,  25u, 255u, 255u, 255u, 255u,  63u,\n+        255u,  26u,  27u,  28u,  29u,  30u,  31u,  32u,  33u,  34u,  35u,  36u,  37u,  38u,  39u,  40u,\n+        41u,  42u,  43u,  44u,  45u,  46u,  47u,  48u,  49u,  50u,  51u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+        255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u, 255u,\n+    };\n+\n+    __ align(CodeEntryAlignment);\n+    StubCodeMark mark(this, \"StubRoutines\", \"decodeBlock\");\n+    address start = __ pc();\n+    __ enter();\n+\n+    Register src    = c_rarg0;\n+    Register soff   = c_rarg1;\n+    Register send   = c_rarg2;\n+    Register dst    = c_rarg3;\n+    Register doff   = c_rarg4;\n+    Register isURL  = c_rarg5;\n+    Register isMIME = c_rarg6;\n+\n+    Register codec     = c_rarg7;\n+    Register dstBackup = x31;\n+    Register length    = x28;     \/\/ t3, total length of src data in bytes\n+\n+    Label ProcessData, Exit;\n+    Label ProcessScalar, ScalarLoop;\n+\n+    \/\/ passed in length (send - soff) is guaranteed to be > 4,\n+    \/\/ and in this intrinsic we only process data of length in multiple of 4,\n+    \/\/ it's not guaranteed to be multiple of 4 by java level, so do it explicitly\n+    __ sub(length, send, soff);\n+    __ andi(length, length, -4);\n+    \/\/ real src\/dst to process data\n+    __ add(src, src, soff);\n+    __ add(dst, dst, doff);\n+    \/\/ backup of dst, used to calculate the return value at exit\n+    __ mv(dstBackup, dst);\n+\n+    \/\/ load the codec base address\n+    __ la(codec, ExternalAddress((address) fromBase64));\n+    __ beqz(isURL, ProcessData);\n+    __ la(codec, ExternalAddress((address) fromBase64URL));\n+    __ BIND(ProcessData);\n+\n+    \/\/ vector version\n+    if (UseRVV) {\n+      \/\/ for MIME case, it has a default length limit of 76 which could be\n+      \/\/ different(smaller) from (send - soff), so in MIME case, we go through\n+      \/\/ the scalar code path directly.\n+      __ bnez(isMIME, ScalarLoop);\n+\n+      Label ProcessM1, ProcessM2;\n+\n+      Register failedIdx = soff;\n+      Register stepSrcM1 = send;\n+      Register stepSrcM2 = doff;\n+      Register stepDst   = isURL;\n+      Register size      = x29;   \/\/ t4\n+      Register minusOne  = x30;   \/\/ t5\n+\n+      __ mv(minusOne, -1);\n+      __ mv(size, MaxVectorSize * 2);\n+      __ mv(stepSrcM1, MaxVectorSize * 4);\n+      __ slli(stepSrcM2, stepSrcM1, 1);\n+      __ mv(stepDst, MaxVectorSize * 2 * 3);\n+\n+      __ blt(length, stepSrcM2, ProcessM1);\n+\n+\n+      \/\/ Assembler::m2\n+      __ BIND(ProcessM2);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM2, stepDst, failedIdx, minusOne,\n+                    v2, v4, v6, v8,      \/\/ inputs\n+                    v10, v12, v14, v16,  \/\/ indexes\n+                    v18, v20, v22,       \/\/ outputs\n+                    Assembler::m2);\n+      __ sub(length, length, stepSrcM2);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ bge(length, stepSrcM2, ProcessM2);\n+\n+\n+      \/\/ Assembler::m1\n+      __ BIND(ProcessM1);\n+      __ blt(length, stepSrcM1, ProcessScalar);\n+\n+      __ srli(size, size, 1);\n+      __ srli(stepDst, stepDst, 1);\n+      base64_vector_decode_round(src, dst, codec,\n+                    size, stepSrcM1, stepDst, failedIdx, minusOne,\n+                    v1, v2, v3, v4,      \/\/ inputs\n+                    v5, v6, v7, v8,      \/\/ indexes\n+                    v9, v10, v11,        \/\/ outputs\n+                    Assembler::m1);\n+      __ sub(length, length, stepSrcM1);\n+\n+      \/\/ error check\n+      __ bne(failedIdx, minusOne, Exit);\n+\n+      __ BIND(ProcessScalar);\n+      __ beqz(length, Exit);\n+    }\n+\n+    \/\/ scalar version\n+    {\n+      Register byte0 = soff, byte1 = send, byte2 = doff, byte3 = isURL;\n+      Register combined32Bits = x29; \/\/ t5\n+\n+      \/\/ encoded:   [byte0[5:0] : byte1[5:0] : byte2[5:0]] : byte3[5:0]] =>\n+      \/\/ plain:     [byte0[5:0]+byte1[5:4] : byte1[3:0]+byte2[5:2] : byte2[1:0]+byte3[5:0]]\n+      __ BIND(ScalarLoop);\n+\n+      \/\/ load 4 bytes encoded src data\n+      __ lbu(byte0, Address(src, 0));\n+      __ lbu(byte1, Address(src, 1));\n+      __ lbu(byte2, Address(src, 2));\n+      __ lbu(byte3, Address(src, 3));\n+      __ addi(src, src, 4);\n+\n+      \/\/ get codec index and decode (ie. load from codec by index)\n+      __ add(byte0, codec, byte0);\n+      __ add(byte1, codec, byte1);\n+      __ lb(byte0, Address(byte0, 0));\n+      __ lb(byte1, Address(byte1, 0));\n+      __ add(byte2, codec, byte2);\n+      __ add(byte3, codec, byte3);\n+      __ lb(byte2, Address(byte2, 0));\n+      __ lb(byte3, Address(byte3, 0));\n+      __ slliw(byte0, byte0, 18);\n+      __ slliw(byte1, byte1, 12);\n+      __ orr(byte0, byte0, byte1);\n+      __ orr(byte0, byte0, byte3);\n+      __ slliw(byte2, byte2, 6);\n+      \/\/ For performance consideration, `combined32Bits` is constructed for 2 purposes at the same time,\n+      \/\/  1. error check below\n+      \/\/  2. decode below\n+      __ orr(combined32Bits, byte0, byte2);\n+\n+      \/\/ error check\n+      __ bltz(combined32Bits, Exit);\n+\n+      \/\/ store 3 bytes decoded data\n+      __ sraiw(byte0, combined32Bits, 16);\n+      __ sraiw(byte1, combined32Bits, 8);\n+      __ sb(byte0, Address(dst, 0));\n+      __ sb(byte1, Address(dst, 1));\n+      __ sb(combined32Bits, Address(dst, 2));\n+\n+      __ sub(length, length, 4);\n+      __ addi(dst, dst, 3);\n+      \/\/ loop back\n+      __ bnez(length, ScalarLoop);\n+    }\n+\n+    __ BIND(Exit);\n+    __ sub(c_rarg0, dst, dstBackup);\n+\n+    __ leave();\n+    __ ret();\n+\n+    return (address) start;\n+  }\n+\n@@ -5618,91 +6110,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* _masm, Register thread) {\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-    __ mv(c_rarg0, thread);\n-  }\n-\n-  static void jfr_epilogue(MacroAssembler* _masm) {\n-    __ reset_last_Java_frame(true);\n-  }\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(x10, t0, t1);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      fp_off,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm, xthread);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret();\n-\n-    OopMap* map = new OopMap(framesize, 1);\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -5723,108 +6124,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Since we need to preserve callee-saved values (currently\n-  \/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-  \/\/ map and therefore have to make these stubs into RuntimeStubs\n-  \/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-  \/\/ be preserved between the fault point and the exception handler\n-  \/\/ then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name,\n-                                   address runtime_entry,\n-                                   Register arg1 = noreg,\n-                                   Register arg2 = noreg) {\n-    \/\/ Information about frame layout at time of blocking runtime call.\n-    \/\/ Note that we only have to preserve callee-saved registers since\n-    \/\/ the compilers are responsible for supplying a continuation point\n-    \/\/ if they expect all registers to be preserved.\n-    \/\/ n.b. riscv asserts that frame::arg_reg_save_area_bytes == 0\n-    assert_cond(runtime_entry != nullptr);\n-    enum layout {\n-      fp_off = 0,\n-      fp_off2,\n-      return_off,\n-      return_off2,\n-      framesize \/\/ inclusive of return address\n-    };\n-\n-    const int insts_size = 1024;\n-    const int locs_size  = 64;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    assert_cond(oop_maps != nullptr && masm != nullptr);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-\n-    __ enter(); \/\/ Save FP and RA before call\n-\n-    assert(is_even(framesize \/ 2), \"sp not 16-byte aligned\");\n-\n-    \/\/ ra and fp are already in place\n-    __ addi(sp, fp, 0 - ((unsigned)framesize << LogBytesPerInt)); \/\/ prolog\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    address the_pc = __ pc();\n-    __ set_last_Java_frame(sp, fp, the_pc, t0);\n-\n-    \/\/ Call runtime\n-    if (arg1 != noreg) {\n-      assert(arg2 != c_rarg1, \"clobbered\");\n-      __ mv(c_rarg1, arg1);\n-    }\n-    if (arg2 != noreg) {\n-      __ mv(c_rarg2, arg2);\n-    }\n-    __ mv(c_rarg0, xthread);\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ rt_call(runtime_entry);\n-\n-    \/\/ Generate oop map\n-    OopMap* map = new OopMap(framesize, 0);\n-    assert_cond(map != nullptr);\n-\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    __ reset_last_Java_frame(true);\n-\n-    __ leave();\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ ld(t0, Address(xthread, Thread::pending_exception_offset()));\n-    __ bnez(t0, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/\/ ASSERT\n-    __ far_jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-    \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name,\n-                                    &code,\n-                                    frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    assert(stub != nullptr, \"create runtime stub fail!\");\n-    return stub->entry_point();\n-  }\n-\n@@ -5855,10 +6148,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -5877,10 +6160,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n-  }\n-\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n@@ -5888,1 +6161,0 @@\n-#endif \/\/ INCLUDE_JFR\n@@ -5896,17 +6168,0 @@\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_AbstractMethodError));\n-\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-      generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_IncompatibleClassChangeError));\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                               CAST_FROM_FN_PTR(address,\n-                                                SharedRuntime::\n-                                                throw_NullPointerException_at_call));\n@@ -5999,0 +6254,5 @@\n+    if (UseBASE64Intrinsics) {\n+      StubRoutines::_base64_encodeBlock = generate_base64_encodeBlock();\n+      StubRoutines::_base64_decodeBlock = generate_base64_decodeBlock();\n+    }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/stubGenerator_riscv.cpp","additions":498,"deletions":238,"binary":false,"changes":736,"status":"modified"},{"patch":"@@ -661,2 +661,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ far_jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ far_jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/riscv\/templateInterpreterGenerator_riscv.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2101,1 +2101,1 @@\n-    __ lwu(x13, Address(x13, Klass::access_flags_offset()));\n+    __ lbu(x13, Address(x13, Klass::misc_flags_offset()));\n@@ -2103,1 +2103,1 @@\n-    __ test_bit(t0, x13, exact_log2(JVM_ACC_HAS_FINALIZER));\n+    __ test_bit(t0, x13, exact_log2(KlassFlags::_misc_has_finalizer));\n","filename":"src\/hotspot\/cpu\/riscv\/templateTable_riscv.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -268,0 +268,5 @@\n+  \/\/ Base64\n+  if (FLAG_IS_DEFAULT(UseBASE64Intrinsics)) {\n+    FLAG_SET_DEFAULT(UseBASE64Intrinsics, true);\n+  }\n+\n","filename":"src\/hotspot\/cpu\/riscv\/vm_version_riscv.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -75,1 +75,1 @@\n-    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n","filename":"src\/hotspot\/cpu\/s390\/c1_MacroAssembler_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -446,1 +446,1 @@\n-        __ testbit(Address(klass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));\n+        __ z_tm(Address(klass, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/s390\/c1_Runtime1_s390.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1010,1 +1010,1 @@\n-    testbit(Address(tmp, Klass::access_flags_offset()), exact_log2(JVM_ACC_IS_VALUE_BASED_CLASS));\n+    z_tm(Address(tmp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -1075,10 +1075,3 @@\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    \/\/ for lightweight locking we need to use monitorenter_obj, see interpreterRuntime.cpp\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-            object);\n-  } else {\n-    call_VM(noreg,\n-            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-            monitor);\n-  }\n+  call_VM(noreg,\n+          CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+          monitor);\n","filename":"src\/hotspot\/cpu\/s390\/interp_masm_s390.cpp","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2754,1 +2754,1 @@\n-  load_const_optimized(Z_R1, StubRoutines::throw_delayed_StackOverflowError_entry());\n+  load_const_optimized(Z_R1, SharedRuntime::throw_delayed_StackOverflowError_entry());\n@@ -3323,2 +3323,2 @@\n-  z_cghi(r_bitmap, Klass::SECONDARY_SUPERS_BITMAP_FULL);\n-  z_bre(L_huge);\n+  z_chi(r_array_length, Klass::SECONDARY_SUPERS_BITMAP_FULL - 2);\n+  z_brh(L_huge);\n@@ -3510,3 +3510,1 @@\n-    z_l(temp, Address(temp, Klass::access_flags_offset()));\n-    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n-    z_nilh(temp, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_tm(Address(temp, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -6157,3 +6155,1 @@\n-    z_l(tmp1, Address(tmp1, Klass::access_flags_offset()));\n-    assert((JVM_ACC_IS_VALUE_BASED_CLASS & 0xFFFF) == 0, \"or change following instruction\");\n-    z_nilh(tmp1, JVM_ACC_IS_VALUE_BASED_CLASS >> 16);\n+    z_tm(Address(tmp1, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -6221,20 +6217,27 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register tagged_monitor = mark;\n-    const Register zero           = tmp2;\n-\n-    \/\/ Try to CAS m->owner from null to current thread.\n-    \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n-    \/\/ Otherwise, register zero is filled with the current owner.\n-    z_lghi(zero, 0);\n-    z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n-    z_bre(locked);\n-\n-    \/\/ Check if recursive.\n-    z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n-    z_brne(slow_path);\n-\n-    \/\/ Recursive\n-    z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n-    z_cgr(zero, zero);\n-    \/\/ z_bru(locked);\n-    \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register tagged_monitor = mark;\n+      const Register zero           = tmp2;\n+\n+      \/\/ Try to CAS m->owner from null to current thread.\n+      \/\/ If m->owner is null, then csg succeeds and sets m->owner=THREAD and CR=EQ.\n+      \/\/ Otherwise, register zero is filled with the current owner.\n+      z_lghi(zero, 0);\n+      z_csg(zero, Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), tagged_monitor);\n+      z_bre(locked);\n+\n+      \/\/ Check if recursive.\n+      z_cgr(Z_thread, zero); \/\/ zero contains the owner from z_csg instruction\n+      z_brne(slow_path);\n+\n+      \/\/ Recursive\n+      z_agsi(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 1ll);\n+      z_cgr(zero, zero);\n+      \/\/ z_bru(locked);\n+      \/\/ Uncomment above line in the future, for now jump address is right next to us.\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n@@ -6282,0 +6285,1 @@\n+    NearLabel push_and_slow_path;\n@@ -6311,1 +6315,5 @@\n-    z_brnaz(inflated);\n+    if (!UseObjectMonitorTable) {\n+      z_brnaz(inflated);\n+    } else {\n+      z_brnaz(push_and_slow_path);\n+    }\n@@ -6330,0 +6338,1 @@\n+    bind(push_and_slow_path);\n@@ -6367,2 +6376,3 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n+    if (!UseObjectMonitorTable) {\n+      \/\/ mark contains the tagged ObjectMonitor*.\n+      const Register monitor = mark;\n@@ -6370,2 +6380,2 @@\n-    NearLabel not_recursive;\n-    const Register recursions = tmp2;\n+      NearLabel not_recursive;\n+      const Register recursions = tmp2;\n@@ -6373,3 +6383,3 @@\n-    \/\/ Check if recursive.\n-    load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n+      \/\/ Check if recursive.\n+      load_and_test_long(recursions, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+      z_bre(not_recursive); \/\/ if 0 then jump, it's not recursive locking\n@@ -6377,4 +6387,4 @@\n-    \/\/ Recursive unlock\n-    z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n-    z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n-    z_bru(unlocked);\n+      \/\/ Recursive unlock\n+      z_agsi(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), -1ll);\n+      z_cgr(monitor, monitor); \/\/ set the CC to EQUAL\n+      z_bru(unlocked);\n@@ -6382,1 +6392,1 @@\n-    bind(not_recursive);\n+      bind(not_recursive);\n@@ -6384,6 +6394,6 @@\n-    NearLabel not_ok;\n-    \/\/ Check if the entry lists are empty.\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    z_brne(not_ok);\n-    load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    z_brne(not_ok);\n+      NearLabel not_ok;\n+      \/\/ Check if the entry lists are empty.\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+      z_brne(not_ok);\n+      load_and_test_long(tmp2, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n+      z_brne(not_ok);\n@@ -6391,2 +6401,2 @@\n-    z_release();\n-    z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_release();\n+      z_stg(tmp2 \/*=0*\/, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n@@ -6394,1 +6404,1 @@\n-    z_bru(unlocked); \/\/ CC = EQ here\n+      z_bru(unlocked); \/\/ CC = EQ here\n@@ -6396,1 +6406,1 @@\n-    bind(not_ok);\n+      bind(not_ok);\n@@ -6398,5 +6408,11 @@\n-    \/\/ The owner may be anonymous, and we removed the last obj entry in\n-    \/\/ the lock-stack. This loses the information about the owner.\n-    \/\/ Write the thread to the owner field so the runtime knows the owner.\n-    z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n-    z_bru(slow_path); \/\/ CC = NE here\n+      \/\/ The owner may be anonymous, and we removed the last obj entry in\n+      \/\/ the lock-stack. This loses the information about the owner.\n+      \/\/ Write the thread to the owner field so the runtime knows the owner.\n+      z_stg(Z_thread, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner), monitor);\n+      z_bru(slow_path); \/\/ CC = NE here\n+    } else {\n+      \/\/ OMCache lookup not supported yet. Take the slowpath.\n+      \/\/ Set flag to NE\n+      z_ltgr(obj, obj);\n+      z_bru(slow_path);\n+    }\n","filename":"src\/hotspot\/cpu\/s390\/macroAssembler_s390.cpp","additions":73,"deletions":57,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -183,2 +183,2 @@\n-  assert(StubRoutines::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n-  __ load_const_optimized(target, StubRoutines::throw_AbstractMethodError_entry());\n+  assert(SharedRuntime::throw_AbstractMethodError_entry() != nullptr, \"not yet generated!\");\n+  __ load_const_optimized(target, SharedRuntime::throw_AbstractMethodError_entry());\n@@ -546,1 +546,1 @@\n-      __ load_const_optimized(Z_R1, StubRoutines::throw_IncompatibleClassChangeError_entry());\n+      __ load_const_optimized(Z_R1, SharedRuntime::throw_IncompatibleClassChangeError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/methodHandles_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -9520,0 +9520,14 @@\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp() %{\n+  match(ForwardException);\n+  ins_cost(CALL_COST);\n+  format %{ \"Jmp    forward_exception_stub\" %}\n+  ins_encode %{\n+    __ set_inst_mark();\n+    __ load_const_optimized(Z_R1_scratch, (address)StubRoutines::forward_exception_entry());\n+    __ z_br(Z_R1_scratch);\n+    __ clear_inst_mark();\n+  %}\n+  ins_pipe(pipe_class_dummy);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/s390\/s390.ad","additions":14,"deletions":0,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -3013,0 +3013,79 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Only callee-saved registers are preserved (through the\n+\/\/ normal RegisterMap handling). If the compiler\n+\/\/ needs all registers to be preserved between the fault point and\n+\/\/ the exception handler then it must assume responsibility for that\n+\/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+\n+\/\/ Note that we generate only this stub into a RuntimeStub, because\n+\/\/ it needs to be properly traversed and ignored during GC, so we\n+\/\/ change the meaning of the \"__\" macro within this method.\n+\n+\/\/ Note: the routine set_pc_not_at_call_for_caller in\n+\/\/ SharedRuntime.cpp requires that this code be generated into a\n+\/\/ RuntimeStub.\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  int insts_size = 256;\n+  int locs_size  = 0;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer      code(name, insts_size, locs_size);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  int framesize_in_bytes;\n+  address start = __ pc();\n+\n+  __ save_return_pc();\n+  framesize_in_bytes = __ push_frame_abi160(0);\n+\n+  address frame_complete_pc = __ pc();\n+\n+  \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n+  __ get_PC(Z_R1);\n+  __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n+\n+  \/\/ Do the call.\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call_VM_leaf(runtime_entry, Z_thread);\n+\n+  __ reset_last_Java_frame();\n+\n+#ifdef ASSERT\n+  \/\/ Make sure that this code is only executed if there is a pending exception.\n+  { Label L;\n+    __ z_lg(Z_R0,\n+            in_bytes(Thread::pending_exception_offset()),\n+            Z_thread);\n+    __ z_ltgr(Z_R0, Z_R0);\n+    __ z_brne(L);\n+    __ stop(\"SharedRuntime::throw_exception: no pending exception\");\n+    __ bind(L);\n+  }\n+#endif\n+\n+  __ pop_frame();\n+  __ restore_return_pc();\n+\n+  __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n+  __ z_br(Z_R1);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name, &code,\n+                                  frame_complete_pc - start,\n+                                  framesize_in_bytes\/wordSize,\n+                                  nullptr \/*oop_maps*\/, false);\n+\n+  return stub;\n+}\n+\n@@ -3266,0 +3345,15 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  if (!Continuations::enabled()) return nullptr;\n+  Unimplemented();\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/s390\/sharedRuntime_s390.cpp","additions":94,"deletions":0,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -575,83 +575,0 @@\n-  \/\/ Continuation point for throwing of implicit exceptions that are\n-  \/\/ not handled in the current activation. Fabricates an exception\n-  \/\/ oop and initiates normal exception dispatching in this\n-  \/\/ frame. Only callee-saved registers are preserved (through the\n-  \/\/ normal RegisterMap handling). If the compiler\n-  \/\/ needs all registers to be preserved between the fault point and\n-  \/\/ the exception handler then it must assume responsibility for that\n-  \/\/ in AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other\n-  \/\/ implicit exceptions (e.g., NullPointerException or\n-  \/\/ AbstractMethodError on entry) are either at call sites or\n-  \/\/ otherwise assume that stack unwinding will be initiated, so\n-  \/\/ caller saved registers were assumed volatile in the compiler.\n-\n-  \/\/ Note that we generate only this stub into a RuntimeStub, because\n-  \/\/ it needs to be properly traversed and ignored during GC, so we\n-  \/\/ change the meaning of the \"__\" macro within this method.\n-\n-  \/\/ Note: the routine set_pc_not_at_call_for_caller in\n-  \/\/ SharedRuntime.cpp requires that this code be generated into a\n-  \/\/ RuntimeStub.\n-#undef __\n-#define __ masm->\n-\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   bool restore_saved_exception_pc,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-    assert_different_registers(arg1, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-    assert_different_registers(arg2, Z_R0_scratch);  \/\/ would be destroyed by push_frame()\n-\n-    int insts_size = 256;\n-    int locs_size  = 0;\n-    CodeBuffer      code(name, insts_size, locs_size);\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    int framesize_in_bytes;\n-    address start = __ pc();\n-\n-    __ save_return_pc();\n-    framesize_in_bytes = __ push_frame_abi160(0);\n-\n-    address frame_complete_pc = __ pc();\n-    if (restore_saved_exception_pc) {\n-      __ unimplemented(\"StubGenerator::throw_exception\", 74);\n-    }\n-\n-    \/\/ Note that we always have a runtime stub frame on the top of stack at this point.\n-    __ get_PC(Z_R1);\n-    __ set_last_Java_frame(\/*sp*\/Z_SP, \/*pc*\/Z_R1);\n-\n-    \/\/ Do the call.\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call_VM_leaf(runtime_entry, Z_thread, arg1, arg2);\n-\n-    __ reset_last_Java_frame();\n-\n-#ifdef ASSERT\n-    \/\/ Make sure that this code is only executed if there is a pending exception.\n-    { Label L;\n-      __ z_lg(Z_R0,\n-                in_bytes(Thread::pending_exception_offset()),\n-                Z_thread);\n-      __ z_ltgr(Z_R0, Z_R0);\n-      __ z_brne(L);\n-      __ stop(\"StubRoutines::throw_exception: no pending exception\");\n-      __ bind(L);\n-    }\n-#endif\n-\n-    __ pop_frame();\n-    __ restore_return_pc();\n-\n-    __ load_const_optimized(Z_R1, StubRoutines::forward_exception_entry());\n-    __ z_br(Z_R1);\n-\n-    RuntimeStub* stub =\n-      RuntimeStub::new_runtime_stub(name, &code,\n-                                    frame_complete_pc - start,\n-                                    framesize_in_bytes\/wordSize,\n-                                    nullptr \/*oop_maps*\/, false);\n-\n-    return stub->entry_point();\n-  }\n-\n@@ -3124,15 +3041,0 @@\n-  #if INCLUDE_JFR\n-  RuntimeStub* generate_jfr_write_checkpoint() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  RuntimeStub* generate_jfr_return_lease() {\n-    if (!Continuations::enabled()) return nullptr;\n-    Unimplemented();\n-    return nullptr;\n-  }\n-\n-  #endif \/\/ INCLUDE_JFR\n-\n@@ -3167,8 +3069,0 @@\n-    \/\/ Build this early so it's available for the interpreter.\n-    StubRoutines::_throw_StackOverflowError_entry          =\n-      generate_throw_exception(\"StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError), false);\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  =\n-      generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                               CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError), false);\n-\n@@ -3199,2 +3093,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -3203,9 +3095,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -3217,5 +3100,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError),  false);\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError),  false);\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call), false);\n-\n","filename":"src\/hotspot\/cpu\/s390\/stubGenerator_s390.cpp","additions":0,"deletions":122,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -853,3 +853,3 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  AddressLiteral stub(StubRoutines::throw_StackOverflowError_entry());\n-  __ load_absolute_address(tmp1, StubRoutines::throw_StackOverflowError_entry());\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  AddressLiteral stub(SharedRuntime::throw_StackOverflowError_entry());\n+  __ load_absolute_address(tmp1, SharedRuntime::throw_StackOverflowError_entry());\n","filename":"src\/hotspot\/cpu\/s390\/templateInterpreterGenerator_s390.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2324,1 +2324,1 @@\n-    __ testbit(Address(Rklass, Klass::access_flags_offset()), exact_log2(JVM_ACC_HAS_FINALIZER));\n+    __ z_tm(Address(Rklass, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/s390\/templateTable_s390.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1783,0 +1783,1 @@\n+  assert(!adr._rspec.reloc()->is_data(), \"should not use ExternalAddress for call\");\n","filename":"src\/hotspot\/cpu\/x86\/assembler_x86.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -61,2 +61,1 @@\n-    movl(hdr, Address(hdr, Klass::access_flags_offset()));\n-    testl(hdr, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(hdr, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -69,0 +68,1 @@\n+    lightweight_lock(disp_hdr, obj, hdr, thread, tmp, slow_case);\n@@ -70,2 +70,4 @@\n-    const Register thread = disp_hdr;\n-    get_thread(thread);\n+    \/\/ Implicit null check.\n+    movptr(hdr, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n@@ -73,1 +75,0 @@\n-    lightweight_lock(obj, hdr, thread, tmp, slow_case);\n@@ -142,4 +143,2 @@\n-    \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-    \/\/ that the reg_rax and thread Register parameters may alias each other.\n-    get_thread(disp_hdr);\n-    lightweight_unlock(obj, disp_hdr, disp_hdr, hdr, slow_case);\n+    \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+    jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/c1_MacroAssembler_x86.cpp","additions":8,"deletions":9,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1169,2 +1169,1 @@\n-        __ movl(t, Address(t, Klass::access_flags_offset()));\n-        __ testl(t, JVM_ACC_HAS_FINALIZER);\n+        __ testb(Address(t, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/x86\/c1_Runtime1_x86.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -99,0 +99,1 @@\n+    __ bind(_slow_path);\n@@ -115,0 +116,4 @@\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address succ_address(monitor, ObjectMonitor::succ_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n@@ -116,1 +121,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -120,1 +125,1 @@\n-    __ movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    __ movptr(owner_address, NULL_WORD);\n@@ -127,1 +132,1 @@\n-    __ cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(succ)), NULL_WORD);\n+    __ cmpptr(succ_address, NULL_WORD);\n@@ -136,1 +141,1 @@\n-    __ lock(); __ cmpxchgptr(_thread, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n+    __ lock(); __ cmpxchgptr(_thread, owner_address);\n","filename":"src\/hotspot\/cpu\/x86\/c2_CodeStubs_x86.cpp","additions":9,"deletions":4,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -280,2 +280,1 @@\n-    movl(tmpReg, Address(tmpReg, Klass::access_flags_offset()));\n-    testl(tmpReg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(tmpReg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -593,0 +592,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), 0);\n+  }\n+\n@@ -595,2 +599,1 @@\n-    movl(rax_reg, Address(rax_reg, Klass::access_flags_offset()));\n-    testl(rax_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+    testb(Address(rax_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -606,1 +609,1 @@\n-    const Register top = box;\n+    const Register top = UseObjectMonitorTable ? rax_reg : box;\n@@ -633,0 +636,4 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Need to reload top, clobbered by CAS.\n+      movl(top, Address(thread, JavaThread::lock_stack_top_offset()));\n+    }\n@@ -643,1 +650,44 @@\n-    const Register tagged_monitor = mark;\n+    const Register monitor = t;\n+\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in the om_cache.\n+      \/\/ Fetch ObjectMonitor* from the cache or take the slow-path.\n+      Label monitor_found;\n+\n+      \/\/ Load cache address\n+      lea(t, Address(thread, JavaThread::om_cache_oops_offset()));\n+\n+      const int num_unrolled = 2;\n+      for (int i = 0; i < num_unrolled; i++) {\n+        cmpptr(obj, Address(t));\n+        jccb(Assembler::equal, monitor_found);\n+        increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      }\n+\n+      Label loop;\n+\n+      \/\/ Search for obj in cache.\n+      bind(loop);\n+\n+      \/\/ Check for match.\n+      cmpptr(obj, Address(t));\n+      jccb(Assembler::equal, monitor_found);\n+\n+      \/\/ Search until null encountered, guaranteed _null_sentinel at end.\n+      cmpptr(Address(t), 1);\n+      jcc(Assembler::below, slow_path); \/\/ 0 check, but with ZF=0 when *t == 0\n+      increment(t, in_bytes(OMCache::oop_to_oop_difference()));\n+      jmpb(loop);\n+\n+      \/\/ Cache hit.\n+      bind(monitor_found);\n+      movptr(monitor, Address(t, OMCache::oop_to_monitor_difference()));\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address(monitor, ObjectMonitor::recursions_offset() - monitor_tag);\n+    const Address owner_address(monitor, ObjectMonitor::owner_offset() - monitor_tag);\n+\n+    Label monitor_locked;\n+    \/\/ Lock the monitor.\n@@ -647,2 +697,2 @@\n-    lock(); cmpxchgptr(thread, Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)));\n-    jccb(Assembler::equal, locked);\n+    lock(); cmpxchgptr(thread, owner_address);\n+    jccb(Assembler::equal, monitor_locked);\n@@ -655,1 +705,7 @@\n-    increment(Address(tagged_monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    increment(recursions_address);\n+\n+    bind(monitor_locked);\n+    if (UseObjectMonitorTable) {\n+      \/\/ Cache the monitor for unlock\n+      movptr(Address(box, BasicLock::object_monitor_cache_offset_in_bytes()), monitor);\n+    }\n@@ -697,1 +753,3 @@\n-  const Register top = reg_rax;\n+  const Register monitor = t;\n+  const Register top = UseObjectMonitorTable ? t : reg_rax;\n+  const Register box = reg_rax;\n@@ -709,0 +767,1 @@\n+  Label& slow_path = stub == nullptr ? dummy : stub->slow_path();\n@@ -715,2 +774,4 @@\n-    \/\/ Prefetch mark.\n-    movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    if (!UseObjectMonitorTable) {\n+      \/\/ Prefetch mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -733,0 +794,5 @@\n+    if (UseObjectMonitorTable) {\n+      \/\/ Load mark.\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n+\n@@ -754,0 +820,3 @@\n+    if (UseObjectMonitorTable) {\n+      movptr(mark, Address(obj, oopDesc::mark_offset_in_bytes()));\n+    }\n@@ -761,13 +830,14 @@\n-    \/\/ mark contains the tagged ObjectMonitor*.\n-    const Register monitor = mark;\n-\n-#ifndef _LP64\n-    \/\/ Check if recursive.\n-    xorptr(reg_rax, reg_rax);\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n-    jcc(Assembler::notZero, check_successor);\n-\n-    \/\/ Check if the entry lists are empty.\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    jcc(Assembler::notZero, check_successor);\n+    if (!UseObjectMonitorTable) {\n+      assert(mark == monitor, \"should be the same here\");\n+    } else {\n+      \/\/ Uses ObjectMonitorTable.  Look for the monitor in our BasicLock on the stack.\n+      movptr(monitor, Address(box, BasicLock::object_monitor_cache_offset_in_bytes()));\n+      \/\/ null check with ZF == 0, no valid pointer below alignof(ObjectMonitor*)\n+      cmpptr(monitor, alignof(ObjectMonitor*));\n+      jcc(Assembler::below, slow_path);\n+    }\n+    const ByteSize monitor_tag = in_ByteSize(UseObjectMonitorTable ? 0 : checked_cast<int>(markWord::monitor_value));\n+    const Address recursions_address{monitor, ObjectMonitor::recursions_offset() - monitor_tag};\n+    const Address cxq_address{monitor, ObjectMonitor::cxq_offset() - monitor_tag};\n+    const Address EntryList_address{monitor, ObjectMonitor::EntryList_offset() - monitor_tag};\n+    const Address owner_address{monitor, ObjectMonitor::owner_offset() - monitor_tag};\n@@ -775,3 +845,0 @@\n-    \/\/ Release lock.\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n-#else \/\/ _LP64\n@@ -781,1 +848,1 @@\n-    cmpptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)), 0);\n+    cmpptr(recursions_address, 0);\n@@ -785,2 +852,2 @@\n-    movptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(cxq)));\n-    orptr(reg_rax, Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(EntryList)));\n+    movptr(reg_rax, cxq_address);\n+    orptr(reg_rax, EntryList_address);\n@@ -790,1 +857,1 @@\n-    movptr(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(owner)), NULL_WORD);\n+    movptr(owner_address, NULL_WORD);\n@@ -795,1 +862,1 @@\n-    decrement(Address(monitor, OM_OFFSET_NO_MONITOR_VALUE_TAG(recursions)));\n+    decrement(recursions_address);\n@@ -797,1 +864,0 @@\n-#endif\n","filename":"src\/hotspot\/cpu\/x86\/c2_MacroAssembler_x86.cpp","additions":100,"deletions":34,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -1178,2 +1178,1 @@\n-      movl(tmp_reg, Address(tmp_reg, Klass::access_flags_offset()));\n-      testl(tmp_reg, JVM_ACC_IS_VALUE_BASED_CLASS);\n+      testb(Address(tmp_reg, Klass::misc_flags_offset()), KlassFlags::_misc_is_value_based_class);\n@@ -1186,0 +1185,1 @@\n+      lightweight_lock(lock_reg, obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1187,2 +1187,2 @@\n-      const Register thread = lock_reg;\n-      get_thread(thread);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n@@ -1190,1 +1190,0 @@\n-      lightweight_lock(obj_reg, swap_reg, thread, tmp_reg, slow_case);\n@@ -1252,9 +1251,3 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter_obj),\n-              obj_reg);\n-    } else {\n-      call_VM(noreg,\n-              CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n-              lock_reg);\n-    }\n+    call_VM(noreg,\n+            CAST_FROM_FN_PTR(address, InterpreterRuntime::monitorenter),\n+            lock_reg);\n@@ -1309,4 +1302,2 @@\n-      \/\/ This relies on the implementation of lightweight_unlock being able to handle\n-      \/\/ that the reg_rax and thread Register parameters may alias each other.\n-      get_thread(swap_reg);\n-      lightweight_unlock(obj_reg, swap_reg, swap_reg, header_reg, slow_case);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      jmp(slow_case);\n","filename":"src\/hotspot\/cpu\/x86\/interp_masm_x86.cpp","additions":9,"deletions":18,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -141,1 +141,1 @@\n-  __ jump (ExternalAddress(slow_case_addr));\n+  __ jump (RuntimeAddress(slow_case_addr));\n@@ -254,1 +254,1 @@\n-  __ jump (ExternalAddress(slow_case_addr));\n+  __ jump (RuntimeAddress(slow_case_addr));\n@@ -353,1 +353,1 @@\n-  __ jump (ExternalAddress(slow_case_addr));\n+  __ jump (RuntimeAddress(slow_case_addr));\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_32.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -121,1 +121,1 @@\n-  __ jump (ExternalAddress(slow_case_addr), rscratch1);\n+  __ jump (RuntimeAddress(slow_case_addr), rscratch1);\n@@ -209,1 +209,1 @@\n-  __ jump (ExternalAddress(slow_case_addr), rscratch1);\n+  __ jump (RuntimeAddress(slow_case_addr), rscratch1);\n","filename":"src\/hotspot\/cpu\/x86\/jniFastGetField_x86_64.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1306,1 +1306,1 @@\n-  jump(RuntimeAddress(StubRoutines::throw_delayed_StackOverflowError_entry()));\n+  jump(RuntimeAddress(SharedRuntime::throw_delayed_StackOverflowError_entry()));\n@@ -2332,1 +2332,1 @@\n-\n+  assert(!dst.rspec().reloc()->is_data(), \"should not use ExternalAddress for jump\");\n@@ -2343,1 +2343,1 @@\n-\n+  assert(!dst.rspec().reloc()->is_data(), \"should not use ExternalAddress for jump_cc\");\n@@ -4948,3 +4948,2 @@\n-  assert(Klass::SECONDARY_SUPERS_BITMAP_FULL == ~uintx(0), \"\");\n-  cmpq(r_bitmap, (int32_t)-1); \/\/ sign-extends immediate to 64-bit value\n-  jcc(Assembler::equal, L_huge);\n+  cmpl(r_array_length, (int32_t)Klass::SECONDARY_SUPERS_TABLE_SIZE - 2);\n+  jcc(Assembler::greater, L_huge);\n@@ -10279,1 +10278,1 @@\n-void MacroAssembler::lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n+void MacroAssembler::lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow) {\n@@ -10281,1 +10280,1 @@\n-  assert_different_registers(obj, reg_rax, thread, tmp);\n+  assert_different_registers(basic_lock, obj, reg_rax, thread, tmp);\n@@ -10290,0 +10289,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Clear cache in case fast locking succeeds.\n+    movptr(Address(basic_lock, BasicObjectLock::lock_offset() + in_ByteSize((BasicLock::object_monitor_cache_offset_in_bytes()))), 0);\n+  }\n+\n@@ -10328,3 +10332,0 @@\n-\/\/\n-\/\/ x86_32 Note: reg_rax and thread may alias each other due to limited register\n-\/\/              availiability.\n@@ -10333,2 +10334,1 @@\n-  assert_different_registers(obj, reg_rax, tmp);\n-  LP64_ONLY(assert_different_registers(obj, reg_rax, thread, tmp);)\n+  assert_different_registers(obj, reg_rax, thread, tmp);\n@@ -10374,4 +10374,0 @@\n-  if (thread == reg_rax) {\n-    \/\/ On x86_32 we may lose the thread.\n-    get_thread(thread);\n-  }\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.cpp","additions":13,"deletions":17,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2151,1 +2151,1 @@\n-  void lightweight_lock(Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n+  void lightweight_lock(Register basic_lock, Register obj, Register reg_rax, Register thread, Register tmp, Label& slow);\n","filename":"src\/hotspot\/cpu\/x86\/macroAssembler_x86.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -162,1 +162,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_AbstractMethodError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_AbstractMethodError_entry()));\n@@ -513,1 +513,1 @@\n-      __ jump(RuntimeAddress(StubRoutines::throw_IncompatibleClassChangeError_entry()));\n+      __ jump(RuntimeAddress(SharedRuntime::throw_IncompatibleClassChangeError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/methodHandles_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,3 +65,5 @@\n-    \/\/ check if monitor\n-    __ testptr(result, markWord::monitor_value);\n-    __ jcc(Assembler::notZero, slowCase);\n+    if (!UseObjectMonitorTable) {\n+      \/\/ check if monitor\n+      __ testptr(result, markWord::monitor_value);\n+      __ jcc(Assembler::notZero, slowCase);\n+    }\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86.cpp","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -59,0 +60,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -707,1 +714,1 @@\n-  __ lea(temp_reg, ExternalAddress(code_start));\n+  __ lea(temp_reg, AddressLiteral(code_start, relocInfo::none));\n@@ -710,1 +717,1 @@\n-  __ lea(temp_reg, ExternalAddress(code_end));\n+  __ lea(temp_reg, AddressLiteral(code_end, relocInfo::none));\n@@ -1689,1 +1696,2 @@\n-      __ lightweight_lock(obj_reg, swap_reg, thread, lock_reg, slow_path_lock);\n+      \/\/ Lacking registers and thread on x86_32. Always take slow path.\n+      __ jmp(slow_path_lock);\n@@ -2633,0 +2641,204 @@\n+\n+  \/\/------------------------------------------------------------------------------------------------------------------------\n+  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n+  \/\/ the current activation. Fabricates an exception oop and initiates normal\n+  \/\/ exception dispatching in this frame.\n+  \/\/\n+  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n+  \/\/ This is no longer true after adapter frames were removed but could possibly\n+  \/\/ be brought back in the future if the interpreter code was reworked and it\n+  \/\/ was deemed worthwhile. The comment below was left to describe what must\n+  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n+  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n+  \/\/ Since it doesn't make much difference we've chosen to leave it the\n+  \/\/ way it was in the callee save days and keep the comment.\n+\n+  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n+  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n+  \/\/ If the compiler needs all registers to be preserved between the fault\n+  \/\/ point and the exception handler then it must assume responsibility for that in\n+  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n+  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n+  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n+  \/\/ so caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    thread_off,    \/\/ last_java_sp\n+    arg1_off,\n+    arg2_off,\n+    rbp_off,       \/\/ callee saved register\n+    ret_pc,\n+    framesize\n+  };\n+\n+  int insts_size = 256;\n+  int locs_size  = 32;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+  Register java_thread = rbx;\n+  __ get_thread(java_thread);\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ pc and rbp, already pushed\n+  __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n+\n+  \/\/ Frame is now completed as far as size and linkage.\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ push java thread (becomes first argument of C function)\n+  __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n+\n+  \/\/ Call runtime\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+  \/\/ Generate oop map\n+  OopMap* map =  new OopMap(framesize, 0);\n+  oop_maps->add_gc_map(__ pc() - start, map);\n+\n+  \/\/ restore the thread (cannot use the pushed argument since arguments\n+  \/\/ may be overwritten by C code generated by an optimizing compiler);\n+  \/\/ however can use the register value directly if it is callee saved.\n+  __ get_thread(java_thread);\n+\n+  __ reset_last_Java_frame(java_thread, true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/* ASSERT *\/\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n+  return stub;\n+}\n+\n+#if INCLUDE_JFR\n+\n+static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n+  __ movptr(Address(rsp, 0), java_thread);\n+}\n+\n+\/\/ The handle is dereferenced through a load barrier.\n+static void jfr_epilogue(MacroAssembler* masm) {\n+  Register java_thread = rdi;\n+  __ get_thread(java_thread);\n+  __ reset_last_Java_frame(java_thread, true);\n+}\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    FPUState_off         = 0,\n+    rbp_off              = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  jfr_epilogue(masm);\n+  __ resolve_global_jobject(rax, rdi, rdx);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    FPUState_off = 0,\n+    rbp_off = FPUStateSizeInWords,\n+    rdi_off,\n+    rsi_off,\n+    rcx_off,\n+    rbx_off,\n+    saved_argument_off,\n+    saved_argument_off2, \/\/ 2nd half of double\n+    framesize\n+  };\n+\n+  int insts_size = 1024;\n+  int locs_size = 64;\n+  CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n+  OopMapSet* oop_maps = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+  __ enter();\n+  int frame_complete = __ pc() - start;\n+  address the_pc = __ pc();\n+  jfr_prologue(the_pc, masm);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  jfr_epilogue(masm);\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+    RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_32.cpp","additions":215,"deletions":3,"binary":false,"changes":218,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+#include \"runtime\/timerTrace.hpp\"\n@@ -73,0 +74,6 @@\n+#ifdef PRODUCT\n+#define BLOCK_COMMENT(str) \/* nothing *\/\n+#else\n+#define BLOCK_COMMENT(str) __ block_comment(str)\n+#endif \/\/ PRODUCT\n+\n@@ -827,1 +834,1 @@\n-  __ lea(temp_reg, ExternalAddress(code_start));\n+  __ lea(temp_reg, AddressLiteral(code_start, relocInfo::none));\n@@ -830,1 +837,1 @@\n-  __ lea(temp_reg, ExternalAddress(code_end));\n+  __ lea(temp_reg, AddressLiteral(code_end, relocInfo::none));\n@@ -2269,1 +2276,1 @@\n-      __ lightweight_lock(obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n+      __ lightweight_lock(lock_reg, obj_reg, swap_reg, r15_thread, rscratch1, slow_path_lock);\n@@ -3213,0 +3220,95 @@\n+\/\/ Continuation point for throwing of implicit exceptions that are\n+\/\/ not handled in the current activation. Fabricates an exception\n+\/\/ oop and initiates normal exception dispatching in this\n+\/\/ frame. Since we need to preserve callee-saved values (currently\n+\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n+\/\/ map and therefore have to make these stubs into RuntimeStubs\n+\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n+\/\/ be preserved between the fault point and the exception handler\n+\/\/ then it must assume responsibility for that in\n+\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n+\/\/ continuation_for_implicit_division_by_zero_exception. All other\n+\/\/ implicit exceptions (e.g., NullPointerException or\n+\/\/ AbstractMethodError on entry) are either at call sites or\n+\/\/ otherwise assume that stack unwinding will be initiated, so\n+\/\/ caller saved registers were assumed volatile in the compiler.\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  \/\/ Information about frame layout at time of blocking runtime call.\n+  \/\/ Note that we only have to preserve callee-saved registers since\n+  \/\/ the compilers are responsible for supplying a continuation point\n+  \/\/ if they expect all registers to be preserved.\n+  enum layout {\n+    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n+    rbp_off2,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  int insts_size = 512;\n+  int locs_size  = 64;\n+\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_throw_exception\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  CodeBuffer code(name, insts_size, locs_size);\n+  OopMapSet* oop_maps  = new OopMapSet();\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+\n+  address start = __ pc();\n+\n+  \/\/ This is an inlined and slightly modified version of call_VM\n+  \/\/ which has the ability to fetch the return PC out of\n+  \/\/ thread-local storage and also sets up last_Java_sp slightly\n+  \/\/ differently than the real call_VM\n+\n+  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n+\n+  \/\/ return address and rbp are already in place\n+  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n+\n+  int frame_complete = __ pc() - start;\n+\n+  \/\/ Set up last_Java_sp and last_Java_fp\n+  address the_pc = __ pc();\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n+\n+  \/\/ Call runtime\n+  __ movptr(c_rarg0, r15_thread);\n+  BLOCK_COMMENT(\"call runtime_entry\");\n+  __ call(RuntimeAddress(runtime_entry));\n+\n+  \/\/ Generate oop map\n+  OopMap* map = new OopMap(framesize, 0);\n+\n+  oop_maps->add_gc_map(the_pc - start, map);\n+\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n+\n+  \/\/ check for pending exceptions\n+#ifdef ASSERT\n+  Label L;\n+  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n+  __ jcc(Assembler::notEqual, L);\n+  __ should_not_reach_here();\n+  __ bind(L);\n+#endif \/\/ ASSERT\n+  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n+\n+\n+  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(name,\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps, false);\n+  return stub;\n+}\n+\n@@ -3478,0 +3580,91 @@\n+#if INCLUDE_JFR\n+\n+\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+\/\/ It returns a jobject handle to the event writer.\n+\/\/ The handle is dereferenced and the return value is the event writer oop.\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n+  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+\/\/ For c2: call to return a leased buffer.\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  enum layout {\n+    rbp_off,\n+    rbpH_off,\n+    return_off,\n+    return_off2,\n+    framesize \/\/ inclusive of return address\n+  };\n+\n+  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n+  MacroAssembler* masm = new MacroAssembler(&code);\n+  address start = __ pc();\n+\n+  __ enter();\n+  address the_pc = __ pc();\n+\n+  int frame_complete = the_pc - start;\n+\n+  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n+  __ movptr(c_rarg0, r15_thread);\n+  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n+  __ reset_last_Java_frame(true);\n+\n+  __ leave();\n+  __ ret(0);\n+\n+  OopMapSet* oop_maps = new OopMapSet();\n+  OopMap* map = new OopMap(framesize, 1);\n+  oop_maps->add_gc_map(frame_complete, map);\n+\n+  RuntimeStub* stub =\n+    RuntimeStub::new_runtime_stub(code.name(),\n+                                  &code,\n+                                  frame_complete,\n+                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n+                                  oop_maps,\n+                                  false);\n+  return stub;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/x86\/sharedRuntime_x86_64.cpp","additions":196,"deletions":3,"binary":false,"changes":199,"status":"modified"},{"patch":"@@ -3846,14 +3846,0 @@\n- public:\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    thread_off,    \/\/ last_java_sp\n-    arg1_off,\n-    arg2_off,\n-    rbp_off,       \/\/ callee saved register\n-    ret_pc,\n-    framesize\n-  };\n-\n@@ -3862,99 +3848,0 @@\n-#undef  __\n-#define __ masm->\n-\n-  \/\/------------------------------------------------------------------------------------------------------------------------\n-  \/\/ Continuation point for throwing of implicit exceptions that are not handled in\n-  \/\/ the current activation. Fabricates an exception oop and initiates normal\n-  \/\/ exception dispatching in this frame.\n-  \/\/\n-  \/\/ Previously the compiler (c2) allowed for callee save registers on Java calls.\n-  \/\/ This is no longer true after adapter frames were removed but could possibly\n-  \/\/ be brought back in the future if the interpreter code was reworked and it\n-  \/\/ was deemed worthwhile. The comment below was left to describe what must\n-  \/\/ happen here if callee saves were resurrected. As it stands now this stub\n-  \/\/ could actually be a vanilla BufferBlob and have now oopMap at all.\n-  \/\/ Since it doesn't make much difference we've chosen to leave it the\n-  \/\/ way it was in the callee save days and keep the comment.\n-\n-  \/\/ If we need to preserve callee-saved values we need a callee-saved oop map and\n-  \/\/ therefore have to make these stubs into RuntimeStubs rather than BufferBlobs.\n-  \/\/ If the compiler needs all registers to be preserved between the fault\n-  \/\/ point and the exception handler then it must assume responsibility for that in\n-  \/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-  \/\/ continuation_for_implicit_division_by_zero_exception. All other implicit\n-  \/\/ exceptions (e.g., NullPointerException or AbstractMethodError on entry) are\n-  \/\/ either at call sites or otherwise assume that stack unwinding will be initiated,\n-  \/\/ so caller saved registers were assumed volatile in the compiler.\n-  address generate_throw_exception(const char* name, address runtime_entry,\n-                                   Register arg1 = noreg, Register arg2 = noreg) {\n-\n-    int insts_size = 256;\n-    int locs_size  = 32;\n-\n-    CodeBuffer code(name, insts_size, locs_size);\n-    OopMapSet* oop_maps  = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-\n-    address start = __ pc();\n-\n-    \/\/ This is an inlined and slightly modified version of call_VM\n-    \/\/ which has the ability to fetch the return PC out of\n-    \/\/ thread-local storage and also sets up last_Java_sp slightly\n-    \/\/ differently than the real call_VM\n-    Register java_thread = rbx;\n-    __ get_thread(java_thread);\n-\n-    __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ pc and rbp, already pushed\n-    __ subptr(rsp, (framesize-2) * wordSize); \/\/ prolog\n-\n-    \/\/ Frame is now completed as far as size and linkage.\n-\n-    int frame_complete = __ pc() - start;\n-\n-    \/\/ push java thread (becomes first argument of C function)\n-    __ movptr(Address(rsp, thread_off * wordSize), java_thread);\n-    if (arg1 != noreg) {\n-      __ movptr(Address(rsp, arg1_off * wordSize), arg1);\n-    }\n-    if (arg2 != noreg) {\n-      assert(arg1 != noreg, \"missing reg arg\");\n-      __ movptr(Address(rsp, arg2_off * wordSize), arg2);\n-    }\n-\n-    \/\/ Set up last_Java_sp and last_Java_fp\n-    __ set_last_Java_frame(java_thread, rsp, rbp, nullptr, noreg);\n-\n-    \/\/ Call runtime\n-    BLOCK_COMMENT(\"call runtime_entry\");\n-    __ call(RuntimeAddress(runtime_entry));\n-    \/\/ Generate oop map\n-    OopMap* map =  new OopMap(framesize, 0);\n-    oop_maps->add_gc_map(__ pc() - start, map);\n-\n-    \/\/ restore the thread (cannot use the pushed argument since arguments\n-    \/\/ may be overwritten by C code generated by an optimizing compiler);\n-    \/\/ however can use the register value directly if it is callee saved.\n-    __ get_thread(java_thread);\n-\n-    __ reset_last_Java_frame(java_thread, true);\n-\n-    __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-    \/\/ check for pending exceptions\n-#ifdef ASSERT\n-    Label L;\n-    __ cmpptr(Address(java_thread, Thread::pending_exception_offset()), NULL_WORD);\n-    __ jcc(Assembler::notEqual, L);\n-    __ should_not_reach_here();\n-    __ bind(L);\n-#endif \/* ASSERT *\/\n-    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-    RuntimeStub* stub = RuntimeStub::new_runtime_stub(name, &code, frame_complete, framesize, oop_maps, false);\n-    return stub->entry_point();\n-  }\n-\n-\n@@ -4000,103 +3887,0 @@\n-#if INCLUDE_JFR\n-\n-  static void jfr_prologue(address the_pc, MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ set_last_Java_frame(java_thread, rsp, rbp, the_pc, noreg);\n-    __ movptr(Address(rsp, 0), java_thread);\n-  }\n-\n-  \/\/ The handle is dereferenced through a load barrier.\n-  static void jfr_epilogue(MacroAssembler* masm) {\n-    Register java_thread = rdi;\n-    __ get_thread(java_thread);\n-    __ reset_last_Java_frame(java_thread, true);\n-  }\n-\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  static RuntimeStub* generate_jfr_write_checkpoint() {\n-    enum layout {\n-      FPUState_off         = 0,\n-      rbp_off              = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_write_checkpoint\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-    jfr_epilogue(_masm);\n-    __ resolve_global_jobject(rax, rdi, rdx);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_write_checkpoint\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-  \/\/ For c2: call to return a leased buffer.\n-  static RuntimeStub* generate_jfr_return_lease() {\n-    enum layout {\n-      FPUState_off = 0,\n-      rbp_off = FPUStateSizeInWords,\n-      rdi_off,\n-      rsi_off,\n-      rcx_off,\n-      rbx_off,\n-      saved_argument_off,\n-      saved_argument_off2, \/\/ 2nd half of double\n-      framesize\n-    };\n-\n-    int insts_size = 1024;\n-    int locs_size = 64;\n-    CodeBuffer code(\"jfr_return_lease\", insts_size, locs_size);\n-    OopMapSet* oop_maps = new OopMapSet();\n-    MacroAssembler* masm = new MacroAssembler(&code);\n-    MacroAssembler* _masm = masm;\n-\n-    address start = __ pc();\n-    __ enter();\n-    int frame_complete = __ pc() - start;\n-    address the_pc = __ pc();\n-    jfr_prologue(the_pc, _masm);\n-    __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-    jfr_epilogue(_masm);\n-    __ leave();\n-    __ ret(0);\n-\n-    OopMap* map = new OopMap(framesize, 1); \/\/ rbp\n-    oop_maps->add_gc_map(the_pc - start, map);\n-\n-    RuntimeStub* stub = \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-      RuntimeStub::new_runtime_stub(\"jfr_return_lease\", &code, frame_complete,\n-                                    (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                    oop_maps, false);\n-    return stub;\n-  }\n-\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4133,6 +3917,0 @@\n-    \/\/ Build this early so it's available for the interpreter\n-    StubRoutines::_throw_StackOverflowError_entry          = generate_throw_exception(\"StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n-    StubRoutines::_throw_delayed_StackOverflowError_entry  = generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                                                                                      CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n-\n@@ -4191,2 +3969,0 @@\n-\n-    JFR_ONLY(generate_jfr_stubs();)\n@@ -4195,9 +3971,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs() {\n-    StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-    StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-    StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-    StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-  }\n-#endif \/\/ INCLUDE_JFR\n-\n@@ -4207,6 +3974,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in non-core builds\n-    \/\/ and need to be relocatable, so they each fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry         = generate_throw_exception(\"AbstractMethodError throw_exception\",          CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n-    StubRoutines::_throw_IncompatibleClassChangeError_entry= generate_throw_exception(\"IncompatibleClassChangeError throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n-    StubRoutines::_throw_NullPointerException_at_call_entry= generate_throw_exception(\"NullPointerException at call throw_exception\", CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_32.cpp","additions":0,"deletions":239,"binary":false,"changes":239,"status":"modified"},{"patch":"@@ -48,3 +48,0 @@\n-#if INCLUDE_JFR\n-#include \"jfr\/support\/jfrIntrinsics.hpp\"\n-#endif\n@@ -3705,1 +3702,1 @@\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n@@ -3781,192 +3778,0 @@\n-#if INCLUDE_JFR\n-\n-\/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-\/\/ It returns a jobject handle to the event writer.\n-\/\/ The handle is dereferenced and the return value is the event writer oop.\n-RuntimeStub* StubGenerator::generate_jfr_write_checkpoint() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_write_checkpoint\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::write_checkpoint), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  \/\/ rax is jobject handle result, unpack and process it through a barrier.\n-  __ resolve_global_jobject(rax, r15_thread, c_rarg0);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-\/\/ For c2: call to return a leased buffer.\n-RuntimeStub* StubGenerator::generate_jfr_return_lease() {\n-  enum layout {\n-    rbp_off,\n-    rbpH_off,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  CodeBuffer code(\"jfr_return_lease\", 1024, 64);\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-  address start = __ pc();\n-\n-  __ enter();\n-  address the_pc = __ pc();\n-\n-  int frame_complete = the_pc - start;\n-\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch2);\n-  __ movptr(c_rarg0, r15_thread);\n-  __ call_VM_leaf(CAST_FROM_FN_PTR(address, JfrIntrinsicSupport::return_lease), 1);\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave();\n-  __ ret(0);\n-\n-  OopMapSet* oop_maps = new OopMapSet();\n-  OopMap* map = new OopMap(framesize, 1);\n-  oop_maps->add_gc_map(frame_complete, map);\n-\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(code.name(),\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps,\n-                                  false);\n-  return stub;\n-}\n-\n-#endif \/\/ INCLUDE_JFR\n-\n-\/\/ Continuation point for throwing of implicit exceptions that are\n-\/\/ not handled in the current activation. Fabricates an exception\n-\/\/ oop and initiates normal exception dispatching in this\n-\/\/ frame. Since we need to preserve callee-saved values (currently\n-\/\/ only for C2, but done for C1 as well) we need a callee-saved oop\n-\/\/ map and therefore have to make these stubs into RuntimeStubs\n-\/\/ rather than BufferBlobs.  If the compiler needs all registers to\n-\/\/ be preserved between the fault point and the exception handler\n-\/\/ then it must assume responsibility for that in\n-\/\/ AbstractCompiler::continuation_for_implicit_null_exception or\n-\/\/ continuation_for_implicit_division_by_zero_exception. All other\n-\/\/ implicit exceptions (e.g., NullPointerException or\n-\/\/ AbstractMethodError on entry) are either at call sites or\n-\/\/ otherwise assume that stack unwinding will be initiated, so\n-\/\/ caller saved registers were assumed volatile in the compiler.\n-address StubGenerator::generate_throw_exception(const char* name,\n-                                                address runtime_entry,\n-                                                Register arg1,\n-                                                Register arg2) {\n-  \/\/ Information about frame layout at time of blocking runtime call.\n-  \/\/ Note that we only have to preserve callee-saved registers since\n-  \/\/ the compilers are responsible for supplying a continuation point\n-  \/\/ if they expect all registers to be preserved.\n-  enum layout {\n-    rbp_off = frame::arg_reg_save_area_bytes\/BytesPerInt,\n-    rbp_off2,\n-    return_off,\n-    return_off2,\n-    framesize \/\/ inclusive of return address\n-  };\n-\n-  int insts_size = 512;\n-  int locs_size  = 64;\n-\n-  CodeBuffer code(name, insts_size, locs_size);\n-  OopMapSet* oop_maps  = new OopMapSet();\n-  MacroAssembler* _masm = new MacroAssembler(&code);\n-\n-  address start = __ pc();\n-\n-  \/\/ This is an inlined and slightly modified version of call_VM\n-  \/\/ which has the ability to fetch the return PC out of\n-  \/\/ thread-local storage and also sets up last_Java_sp slightly\n-  \/\/ differently than the real call_VM\n-\n-  __ enter(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  assert(is_even(framesize\/2), \"sp not 16-byte aligned\");\n-\n-  \/\/ return address and rbp are already in place\n-  __ subptr(rsp, (framesize-4) << LogBytesPerInt); \/\/ prolog\n-\n-  int frame_complete = __ pc() - start;\n-\n-  \/\/ Set up last_Java_sp and last_Java_fp\n-  address the_pc = __ pc();\n-  __ set_last_Java_frame(rsp, rbp, the_pc, rscratch1);\n-  __ andptr(rsp, -(StackAlignmentInBytes));    \/\/ Align stack\n-\n-  \/\/ Call runtime\n-  if (arg1 != noreg) {\n-    assert(arg2 != c_rarg1, \"clobbered\");\n-    __ movptr(c_rarg1, arg1);\n-  }\n-  if (arg2 != noreg) {\n-    __ movptr(c_rarg2, arg2);\n-  }\n-  __ movptr(c_rarg0, r15_thread);\n-  BLOCK_COMMENT(\"call runtime_entry\");\n-  __ call(RuntimeAddress(runtime_entry));\n-\n-  \/\/ Generate oop map\n-  OopMap* map = new OopMap(framesize, 0);\n-\n-  oop_maps->add_gc_map(the_pc - start, map);\n-\n-  __ reset_last_Java_frame(true);\n-\n-  __ leave(); \/\/ required for proper stackwalking of RuntimeStub frame\n-\n-  \/\/ check for pending exceptions\n-#ifdef ASSERT\n-  Label L;\n-  __ cmpptr(Address(r15_thread, Thread::pending_exception_offset()), NULL_WORD);\n-  __ jcc(Assembler::notEqual, L);\n-  __ should_not_reach_here();\n-  __ bind(L);\n-#endif \/\/ ASSERT\n-  __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()));\n-\n-\n-  \/\/ codeBlob framesize is in words (not VMRegImpl::slot_size)\n-  RuntimeStub* stub =\n-    RuntimeStub::new_runtime_stub(name,\n-                                  &code,\n-                                  frame_complete,\n-                                  (framesize >> (LogBytesPerWord - LogBytesPerInt)),\n-                                  oop_maps, false);\n-  return stub->entry_point();\n-}\n-\n@@ -4090,11 +3895,0 @@\n-  \/\/ Build this early so it's available for the interpreter.\n-  StubRoutines::_throw_StackOverflowError_entry =\n-    generate_throw_exception(\"StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_StackOverflowError));\n-  StubRoutines::_throw_delayed_StackOverflowError_entry =\n-    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_delayed_StackOverflowError));\n@@ -4134,2 +3928,0 @@\n-\n-  JFR_ONLY(generate_jfr_stubs();)\n@@ -4138,9 +3930,0 @@\n-#if INCLUDE_JFR\n-void StubGenerator::generate_jfr_stubs() {\n-  StubRoutines::_jfr_write_checkpoint_stub = generate_jfr_write_checkpoint();\n-  StubRoutines::_jfr_write_checkpoint = StubRoutines::_jfr_write_checkpoint_stub->entry_point();\n-  StubRoutines::_jfr_return_lease_stub = generate_jfr_return_lease();\n-  StubRoutines::_jfr_return_lease = StubRoutines::_jfr_return_lease_stub->entry_point();\n-}\n-#endif\n-\n@@ -4150,21 +3933,0 @@\n-  \/\/ These entry points require SharedInfo::stack0 to be set up in\n-  \/\/ non-core builds and need to be relocatable, so they each\n-  \/\/ fabricate a RuntimeStub internally.\n-  StubRoutines::_throw_AbstractMethodError_entry =\n-    generate_throw_exception(\"AbstractMethodError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_AbstractMethodError));\n-\n-  StubRoutines::_throw_IncompatibleClassChangeError_entry =\n-    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_IncompatibleClassChangeError));\n-\n-  StubRoutines::_throw_NullPointerException_at_call_entry =\n-    generate_throw_exception(\"NullPointerException at call throw_exception\",\n-                             CAST_FROM_FN_PTR(address,\n-                                              SharedRuntime::\n-                                              throw_NullPointerException_at_call));\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.cpp","additions":1,"deletions":239,"binary":false,"changes":240,"status":"modified"},{"patch":"@@ -589,10 +589,0 @@\n-#if INCLUDE_JFR\n-  void generate_jfr_stubs();\n-  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n-  \/\/ It returns a jobject handle to the event writer.\n-  \/\/ The handle is dereferenced and the return value is the event writer oop.\n-  RuntimeStub* generate_jfr_write_checkpoint();\n-  \/\/ For c2: call to runtime to return a buffer lease.\n-  RuntimeStub* generate_jfr_return_lease();\n-#endif \/\/ INCLUDE_JFR\n-\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64.hpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -218,1 +218,1 @@\n-    ExternalAddress no_overlap(no_overlap_target);\n+    RuntimeAddress no_overlap(no_overlap_target);\n","filename":"src\/hotspot\/cpu\/x86\/stubGenerator_x86_64_arraycopy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -548,2 +548,2 @@\n-  assert(StubRoutines::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n-  __ jump(RuntimeAddress(StubRoutines::throw_StackOverflowError_entry()));\n+  assert(SharedRuntime::throw_StackOverflowError_entry() != nullptr, \"stub not yet generated\");\n+  __ jump(RuntimeAddress(SharedRuntime::throw_StackOverflowError_entry()));\n","filename":"src\/hotspot\/cpu\/x86\/templateInterpreterGenerator_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2582,2 +2582,1 @@\n-    __ movl(rdi, Address(rdi, Klass::access_flags_offset()));\n-    __ testl(rdi, JVM_ACC_HAS_FINALIZER);\n+    __ testb(Address(rdi, Klass::misc_flags_offset()), KlassFlags::_misc_has_finalizer);\n","filename":"src\/hotspot\/cpu\/x86\/templateTable_x86.cpp","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -13586,0 +13586,12 @@\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp()\n+%{\n+  match(ForwardException);\n+\n+  format %{ \"JMP    forward_exception_stub\" %}\n+  ins_encode %{\n+    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()), noreg);\n+  %}\n+  ins_pipe(pipe_jmp);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_32.ad","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -6391,1 +6391,1 @@\n-instruct cmovL_imm_01(rRegL dst, immI_1 src, rFlagsReg cr, cmpOp cop)\n+instruct cmovL_imm_01(rRegL dst, immL1 src, rFlagsReg cr, cmpOp cop)\n@@ -6429,1 +6429,1 @@\n-instruct cmovL_imm_01U(rRegL dst, immI_1 src, rFlagsRegU cr, cmpOpU cop)\n+instruct cmovL_imm_01U(rRegL dst, immL1 src, rFlagsRegU cr, cmpOpU cop)\n@@ -6455,1 +6455,1 @@\n-instruct cmovL_imm_01UCF(rRegL dst, immI_1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n+instruct cmovL_imm_01UCF(rRegL dst, immL1 src, rFlagsRegUCF cr, cmpOpUCF cop)\n@@ -12595,0 +12595,12 @@\n+\/\/ Forward exception.\n+instruct ForwardExceptionjmp()\n+%{\n+  match(ForwardException);\n+\n+  format %{ \"jmp     forward_exception_stub\" %}\n+  ins_encode %{\n+    __ jump(RuntimeAddress(StubRoutines::forward_exception_entry()), noreg);\n+  %}\n+  ins_pipe(pipe_jmp);\n+%}\n+\n","filename":"src\/hotspot\/cpu\/x86\/x86_64.ad","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -92,1 +92,1 @@\n-static RuntimeStub* generate_empty_runtime_stub(const char* name) {\n+static RuntimeStub* generate_empty_runtime_stub() {\n@@ -104,1 +104,0 @@\n-\n@@ -114,1 +113,5 @@\n-  return generate_empty_runtime_stub(\"resolve_blob\");\n+  return generate_empty_runtime_stub();\n+}\n+\n+RuntimeStub* SharedRuntime::generate_throw_exception(const char* name, address runtime_entry) {\n+  return generate_empty_runtime_stub();\n@@ -130,0 +133,12 @@\n+\n+#if INCLUDE_JFR\n+RuntimeStub* SharedRuntime::generate_jfr_write_checkpoint() {\n+  return nullptr;\n+}\n+\n+RuntimeStub* SharedRuntime::generate_jfr_return_lease() {\n+  return nullptr;\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n","filename":"src\/hotspot\/cpu\/zero\/sharedRuntime_zero.cpp","additions":18,"deletions":3,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -206,16 +206,0 @@\n-    \/\/ These entry points require SharedInfo::stack0 to be set up in\n-    \/\/ non-core builds and need to be relocatable, so they each\n-    \/\/ fabricate a RuntimeStub internally.\n-    StubRoutines::_throw_AbstractMethodError_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_NullPointerException_at_call_entry =\n-      ShouldNotCallThisStub();\n-\n-    StubRoutines::_throw_StackOverflowError_entry =\n-      ShouldNotCallThisStub();\n-\n-    \/\/ support for verify_oop (must happen after universe_init)\n-    StubRoutines::_verify_oop_subroutine_entry =\n-      ShouldNotCallThisStub();\n-\n","filename":"src\/hotspot\/cpu\/zero\/stubGenerator_zero.cpp","additions":0,"deletions":16,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -47,0 +48,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -334,13 +336,15 @@\n-    markWord disp = lockee->mark().set_unlocked();\n-    monitor->lock()->set_displaced_header(disp);\n-    bool call_vm = (LockingMode == LM_MONITOR);\n-    bool inc_monitor_count = true;\n-    if (call_vm || lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n-      \/\/ Is it simple recursive case?\n-      if (!call_vm && thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n-        monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-      } else {\n-        inc_monitor_count = false;\n-        CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n-        if (HAS_PENDING_EXCEPTION)\n-          goto unwind_and_return;\n+    bool success = false;\n+    if (LockingMode == LM_LEGACY) {\n+      markWord disp = lockee->mark().set_unlocked();\n+      monitor->lock()->set_displaced_header(disp);\n+      success = true;\n+      if (lockee->cas_set_mark(markWord::from_pointer(monitor), disp) != disp) {\n+        \/\/ Is it simple recursive case?\n+        if (thread->is_lock_owned((address) disp.clear_lock_bits().to_pointer())) {\n+          monitor->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+        } else {\n+          success = false;\n+        }\n+      }\n+      if (success) {\n+        THREAD->inc_held_monitor_count();\n@@ -349,2 +353,4 @@\n-    if (inc_monitor_count) {\n-      THREAD->inc_held_monitor_count();\n+    if (!success) {\n+      CALL_VM_NOCHECK(InterpreterRuntime::monitorenter(thread, monitor));\n+          if (HAS_PENDING_EXCEPTION)\n+            goto unwind_and_return;\n","filename":"src\/hotspot\/cpu\/zero\/zeroInterpreter_zero.cpp","additions":21,"deletions":15,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -476,3 +476,3 @@\n-#ifdef STATIC_BUILD\n-    strcat(buf, \"\/lib\");\n-#endif\n+    if (is_vm_statically_linked()) {\n+      strcat(buf, \"\/lib\");\n+    }\n@@ -1096,3 +1096,4 @@\n-#ifdef STATIC_BUILD\n-  return os::get_default_process_handle();\n-#else\n+  if (is_vm_statically_linked()) {\n+    return os::get_default_process_handle();\n+  }\n+\n@@ -1102,1 +1103,0 @@\n-#endif \/\/ STATIC_BUILD\n@@ -1106,3 +1106,4 @@\n-#ifdef STATIC_BUILD\n-  return os::get_default_process_handle();\n-#else\n+  if (is_vm_statically_linked()) {\n+    return os::get_default_process_handle();\n+  }\n+\n@@ -1272,1 +1273,0 @@\n-#endif \/\/ STATIC_BUILD\n","filename":"src\/hotspot\/os\/bsd\/os_bsd.cpp","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-    bool is_read_only() { return _read_only; }\n+    bool is_read_only() override { return _read_only; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV1Subsystem_linux.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Red Hat Inc.\n+ * Copyright (c) 2020, 2024, Red Hat Inc.\n@@ -131,2 +131,2 @@\n-    CachingCgroupController<CgroupMemoryController>* memory_controller() { return _memory; }\n-    CachingCgroupController<CgroupCpuController>* cpu_controller() { return _cpu; }\n+    CachingCgroupController<CgroupMemoryController>* memory_controller() override { return _memory; }\n+    CachingCgroupController<CgroupCpuController>* cpu_controller() override { return _cpu; }\n","filename":"src\/hotspot\/os\/linux\/cgroupV2Subsystem_linux.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,2 +41,0 @@\n-  \/*  NB: The default value of UseLinuxPosixThreadCPUClocks may be   *\/ \\\n-  \/* overridden in Arguments::parse_each_vm_init_arg.                *\/ \\\n@@ -44,1 +42,1 @@\n-          \"enable fast Linux Posix clocks where available\")             \\\n+          \"(Deprecated) enable fast Linux Posix clocks where available\") \\\n","filename":"src\/hotspot\/os\/linux\/globals_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-  friend class CgroupSubsystem;\n@@ -35,1 +34,0 @@\n-  friend class OSContainer;\n@@ -61,1 +59,0 @@\n-  static int active_processor_count();\n@@ -96,0 +93,1 @@\n+  static int active_processor_count();\n","filename":"src\/hotspot\/os\/linux\/os_linux.hpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -433,0 +433,2 @@\n+  PRAGMA_DIAG_PUSH\n+  PRAGMA_ZERO_AS_NULL_POINTER_CONSTANT_IGNORED\n@@ -434,0 +436,1 @@\n+  PRAGMA_DIAG_POP\n","filename":"src\/hotspot\/os\/linux\/os_perf_linux.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -22,1 +22,1 @@\n- *  \n+ *\n@@ -132,1 +132,1 @@\n-  probe CallNonvirtualVoidMethodV__entry(void*, void*, void*, uintptr_t);  \n+  probe CallNonvirtualVoidMethodV__entry(void*, void*, void*, uintptr_t);\n@@ -203,2 +203,2 @@\n-  probe CallStaticVoidMethod__return(); \n-  probe CallStaticVoidMethodV__entry(void*, void*, uintptr_t);  \n+  probe CallStaticVoidMethod__return();\n+  probe CallStaticVoidMethodV__entry(void*, void*, uintptr_t);\n@@ -206,1 +206,1 @@\n-  probe CallVoidMethodA__entry(void*, void*, uintptr_t);  \n+  probe CallVoidMethodA__entry(void*, void*, uintptr_t);\n@@ -208,3 +208,3 @@\n-  probe CallVoidMethod__entry(void*, void*, uintptr_t);  \n-  probe CallVoidMethod__return(); \n-  probe CallVoidMethodV__entry(void*, void*, uintptr_t);  \n+  probe CallVoidMethod__entry(void*, void*, uintptr_t);\n+  probe CallVoidMethod__return();\n+  probe CallVoidMethodV__entry(void*, void*, uintptr_t);\n@@ -232,1 +232,1 @@\n-  probe ExceptionDescribe__entry(void*);  \n+  probe ExceptionDescribe__entry(void*);\n@@ -355,0 +355,2 @@\n+  probe GetStringUTFLengthAsLong__entry(void*, void*);\n+  probe GetStringUTFLengthAsLong__return(uintptr_t);\n@@ -391,1 +393,1 @@\n-  probe NewObjectA__entry(void*, void*, uintptr_t);  \n+  probe NewObjectA__entry(void*, void*, uintptr_t);\n@@ -395,1 +397,1 @@\n-  probe NewObject__entry(void*, void*, uintptr_t); \n+  probe NewObject__entry(void*, void*, uintptr_t);\n@@ -397,1 +399,1 @@\n-  probe NewObjectV__entry(void*, void*, uintptr_t);  \n+  probe NewObjectV__entry(void*, void*, uintptr_t);\n@@ -411,1 +413,1 @@\n-  probe RegisterNatives__entry(void*, void*, const void*, uint32_t);  \n+  probe RegisterNatives__entry(void*, void*, const void*, uint32_t);\n@@ -493,2 +495,2 @@\n-  probe ThrowNew__entry(void*, void*, const char*);  \n-  probe ThrowNew__return(intptr_t);  \n+  probe ThrowNew__entry(void*, void*, const char*);\n+  probe ThrowNew__return(intptr_t);\n@@ -499,1 +501,1 @@\n-  probe UnregisterNatives__entry(void*, void*);  \n+  probe UnregisterNatives__entry(void*, void*);\n@@ -508,1 +510,0 @@\n-\n","filename":"src\/hotspot\/os\/posix\/dtrace\/hotspot_jni.d","additions":19,"deletions":18,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -1,43 +0,0 @@\n-\/*\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/z\/zUtils.hpp\"\n-#include \"utilities\/debug.hpp\"\n-#include \"utilities\/globalDefinitions.hpp\"\n-\n-#include <stdlib.h>\n-\n-uintptr_t ZUtils::alloc_aligned(size_t alignment, size_t size) {\n-  void* res = nullptr;\n-\n-  \/\/ Use raw posix_memalign as long as we have no wrapper for it\n-  ALLOW_C_FUNCTION(::posix_memalign, int rc = posix_memalign(&res, alignment, size);)\n-  if (rc != 0) {\n-    fatal(\"posix_memalign() failed\");\n-  }\n-\n-  memset(res, 0, size);\n-\n-  return (uintptr_t)res;\n-}\n","filename":"src\/hotspot\/os\/posix\/gc\/z\/zUtils_posix.cpp","additions":0,"deletions":43,"binary":false,"changes":43,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+#include \"utilities\/compilerWarnings.hpp\"\n@@ -38,0 +39,3 @@\n+\n+PRAGMA_DIAG_PUSH\n+PRAGMA_ZERO_AS_NULL_POINTER_CONSTANT_IGNORED\n@@ -39,0 +43,2 @@\n+PRAGMA_DIAG_POP\n+\n","filename":"src\/hotspot\/os\/posix\/threadCritical_posix.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -321,1 +321,1 @@\n-    _snprintf(msg, sizeof(msg), \"%d\\n\", result);\n+    os::snprintf(msg, sizeof(msg), \"%d\\n\", result);\n","filename":"src\/hotspot\/os\/windows\/attachListener_windows.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1,40 +0,0 @@\n-\/*\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#include \"precompiled.hpp\"\n-#include \"gc\/z\/zUtils.hpp\"\n-#include \"utilities\/debug.hpp\"\n-\n-#include <malloc.h>\n-\n-uintptr_t ZUtils::alloc_aligned(size_t alignment, size_t size) {\n-  void* const res = _aligned_malloc(size, alignment);\n-\n-  if (res == nullptr) {\n-    fatal(\"_aligned_malloc failed\");\n-  }\n-\n-  memset(res, 0, size);\n-\n-  return (uintptr_t)res;\n-}\n","filename":"src\/hotspot\/os\/windows\/gc\/z\/zUtils_windows.cpp","additions":0,"deletions":40,"binary":false,"changes":40,"status":"deleted"},{"patch":"@@ -1779,3 +1779,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load %s-bit .dll on a %s-bit platform\",\n-                lib_arch_str, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load %s-bit .dll on a %s-bit platform\",\n+                 lib_arch_str, running_arch_str);\n@@ -1784,3 +1784,3 @@\n-    ::_snprintf(ebuf, ebuflen - 1,\n-                \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n-                lib_arch, running_arch_str);\n+    os::snprintf(ebuf, ebuflen - 1,\n+                 \"Can't load this .dll (machine code=0x%x) on a %s-bit platform\",\n+                 lib_arch, running_arch_str);\n@@ -3465,1 +3465,2 @@\n-  assert(aligned_base != nullptr, \"Did not manage to re-map after %d attempts?\", max_attempts);\n+  assert(aligned_base != nullptr,\n+      \"Did not manage to re-map after %d attempts (size %zu, alignment %zu, file descriptor %d)\", max_attempts, size, alignment, file_desc);\n","filename":"src\/hotspot\/os\/windows\/os_windows.cpp","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -168,1 +168,1 @@\n-  _snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n+  os::snprintf(dirname, nbytes, \"%s\\\\%s_%s\", tmpdir, perfdir, user);\n@@ -458,1 +458,1 @@\n-  _snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n+  os::snprintf(name, nbytes, \"%s_%s_%u\", PERFDATA_NAME, user, vmid);\n@@ -474,1 +474,1 @@\n-  _snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n+  os::snprintf(name, nbytes, \"%s\\\\%d\", dirname, vmid);\n","filename":"src\/hotspot\/os\/windows\/perfMemory_windows.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -29,0 +29,2 @@\n+#include \"runtime\/atomic.hpp\"\n+\n@@ -31,0 +33,17 @@\n+template <typename T>\n+static void pd_conjoint_atomic_helper(const T* from, T* to, size_t count) {\n+  if (from > to) {\n+    while (count-- > 0) {\n+      \/\/ Copy forwards\n+      Atomic::store(to++, Atomic::load(from++));\n+    }\n+  } else {\n+    from += count - 1;\n+    to   += count - 1;\n+    while (count-- > 0) {\n+      \/\/ Copy backwards\n+      Atomic::store(to--, Atomic::load(from--));\n+    }\n+  }\n+}\n+\n@@ -74,13 +93,1 @@\n-  if (from > to) {\n-    while (count-- > 0) {\n-      \/\/ Copy forwards\n-      *to++ = *from++;\n-    }\n-  } else {\n-    from += count - 1;\n-    to   += count - 1;\n-    while (count-- > 0) {\n-      \/\/ Copy backwards\n-      *to-- = *from--;\n-    }\n-  }\n+  pd_conjoint_atomic_helper(from, to, count);\n@@ -90,13 +97,1 @@\n-  if (from > to) {\n-    while (count-- > 0) {\n-      \/\/ Copy forwards\n-      *to++ = *from++;\n-    }\n-  } else {\n-    from += count - 1;\n-    to   += count - 1;\n-    while (count-- > 0) {\n-      \/\/ Copy backwards\n-      *to-- = *from--;\n-    }\n-  }\n+  pd_conjoint_atomic_helper(from, to, count);\n@@ -106,1 +101,1 @@\n-  pd_conjoint_oops_atomic((const oop*)from, (oop*)to, count);\n+  pd_conjoint_atomic_helper(from, to, count);\n@@ -110,13 +105,1 @@\n- if (from > to) {\n-    while (count-- > 0) {\n-      \/\/ Copy forwards\n-      *to++ = *from++;\n-    }\n-  } else {\n-    from += count - 1;\n-    to   += count - 1;\n-    while (count-- > 0) {\n-      \/\/ Copy backwards\n-      *to-- = *from--;\n-    }\n-  }\n+ pd_conjoint_atomic_helper(from, to, count);\n","filename":"src\/hotspot\/os_cpu\/windows_aarch64\/copy_windows_aarch64.hpp","additions":23,"deletions":40,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,1 +183,1 @@\n-  masm->jump(ExternalAddress((address)&HandleExceptionFromCodeCache), rscratch1);\n+  masm->jump(RuntimeAddress((address)&HandleExceptionFromCodeCache), rscratch1);\n","filename":"src\/hotspot\/os_cpu\/windows_x86\/os_windows_x86.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -213,9 +213,10 @@\n-  if (_matrule->find_type(\"Goto\",          index)) return true;\n-  if (_matrule->find_type(\"If\",            index)) return true;\n-  if (_matrule->find_type(\"CountedLoopEnd\",index)) return true;\n-  if (_matrule->find_type(\"Return\",        index)) return true;\n-  if (_matrule->find_type(\"Rethrow\",       index)) return true;\n-  if (_matrule->find_type(\"TailCall\",      index)) return true;\n-  if (_matrule->find_type(\"TailJump\",      index)) return true;\n-  if (_matrule->find_type(\"Halt\",          index)) return true;\n-  if (_matrule->find_type(\"Jump\",          index)) return true;\n+  if (_matrule->find_type(\"Goto\",             index)) return true;\n+  if (_matrule->find_type(\"If\",               index)) return true;\n+  if (_matrule->find_type(\"CountedLoopEnd\",   index)) return true;\n+  if (_matrule->find_type(\"Return\",           index)) return true;\n+  if (_matrule->find_type(\"Rethrow\",          index)) return true;\n+  if (_matrule->find_type(\"TailCall\",         index)) return true;\n+  if (_matrule->find_type(\"TailJump\",         index)) return true;\n+  if (_matrule->find_type(\"ForwardException\", index)) return true;\n+  if (_matrule->find_type(\"Halt\",             index)) return true;\n+  if (_matrule->find_type(\"Jump\",             index)) return true;\n@@ -231,6 +232,7 @@\n-  if (_matrule->find_type(\"Goto\",    index)) return true;\n-  if (_matrule->find_type(\"Return\",  index)) return true;\n-  if (_matrule->find_type(\"Rethrow\", index)) return true;\n-  if (_matrule->find_type(\"TailCall\",index)) return true;\n-  if (_matrule->find_type(\"TailJump\",index)) return true;\n-  if (_matrule->find_type(\"Halt\",    index)) return true;\n+  if (_matrule->find_type(\"Goto\",             index)) return true;\n+  if (_matrule->find_type(\"Return\",           index)) return true;\n+  if (_matrule->find_type(\"Rethrow\",          index)) return true;\n+  if (_matrule->find_type(\"TailCall\",         index)) return true;\n+  if (_matrule->find_type(\"TailJump\",         index)) return true;\n+  if (_matrule->find_type(\"ForwardException\", index)) return true;\n+  if (_matrule->find_type(\"Halt\",             index)) return true;\n@@ -379,0 +381,1 @@\n+  if (_matrule->find_type(\"ForwardException\", index)) return true;\n@@ -897,0 +900,1 @@\n+      strcmp(_matrule->_opType,\"ForwardException\")==0 ||\n","filename":"src\/hotspot\/share\/adlc\/formssel.cpp","additions":19,"deletions":15,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -1392,0 +1392,5 @@\n+  if (next_bci() >= method()->code_size()) {\n+    \/\/ This can happen if the subroutine does not terminate with a ret,\n+    \/\/ effectively turning the jsr into a goto.\n+    BAILOUT(\"too-complicated jsr\/ret structure\");\n+  }\n@@ -1566,1 +1571,1 @@\n-       (scope()->wrote_final() ||\n+       (scope()->wrote_final() || scope()->wrote_stable() ||\n@@ -1744,4 +1749,0 @@\n-  if (field->is_final() && (code == Bytecodes::_putfield)) {\n-    scope()->set_wrote_final();\n-  }\n-\n@@ -1753,0 +1754,6 @@\n+    if (field->is_final()) {\n+      scope()->set_wrote_final();\n+    }\n+    if (field->is_stable()) {\n+      scope()->set_wrote_stable();\n+    }\n@@ -2117,1 +2124,1 @@\n-    assert(!target->can_be_statically_bound() || target == cha_monomorphic_target, \"\");\n+    assert(!target->can_be_statically_bound() || target->equals(cha_monomorphic_target), \"\");\n@@ -3737,0 +3744,3 @@\n+  if (next_bci() >= method()->code_size()) {\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/c1\/c1_GraphBuilder.cpp","additions":16,"deletions":6,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -149,0 +149,1 @@\n+  _wrote_stable       = false;\n","filename":"src\/hotspot\/share\/c1\/c1_IR.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -152,0 +152,1 @@\n+  bool          _wrote_stable;                   \/\/ has written @Stable field\n@@ -190,0 +191,2 @@\n+  void          set_wrote_stable()               { _wrote_stable = true; }\n+  bool          wrote_stable() const             { return _wrote_stable; }\n","filename":"src\/hotspot\/share\/c1\/c1_IR.hpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -760,2 +760,2 @@\n-  assert(LockingMode == LM_LIGHTWEIGHT || obj == lock->obj(), \"must match\");\n-  SharedRuntime::monitor_enter_helper(obj, LockingMode == LM_LIGHTWEIGHT ? nullptr : lock->lock(), current);\n+  assert(obj == lock->obj(), \"must match\");\n+  SharedRuntime::monitor_enter_helper(obj, lock->lock(), current);\n","filename":"src\/hotspot\/share\/c1\/c1_Runtime1.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -115,0 +115,6 @@\n+  \/\/ The minimum region size of all collectors that are supported by CDS in\n+  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n+  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n+  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n+  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n+\n@@ -122,6 +128,0 @@\n-  \/\/ The minimum region size of all collectors that are supported by CDS in\n-  \/\/ ArchiveHeapLoader::can_map() mode. Currently only G1 is supported. G1's region size\n-  \/\/ depends on -Xmx, but can never be smaller than 1 * M.\n-  \/\/ (TODO: Perhaps change to 256K to be compatible with Shenandoah)\n-  static constexpr int MIN_GC_REGION_ALIGNMENT = 1 * M;\n-\n","filename":"src\/hotspot\/share\/cds\/archiveHeapWriter.hpp","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -271,1 +271,0 @@\n-  st->print_cr(\"- narrow_oop_base:                \" INTPTR_FORMAT, p2i(_narrow_oop_base));\n@@ -2028,1 +2027,1 @@\n-        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC or UseParallelGC are required.\");\n+        log_info(cds)(\"Cannot use CDS heap data. UseEpsilonGC, UseG1GC, UseSerialGC, UseParallelGC, or UseShenandoahGC are required.\");\n@@ -2181,10 +2180,1 @@\n-  char* base = map_memory(_fd, _full_path, r->file_offset(),\n-                          addr, _mapped_heap_memregion.byte_size(), r->read_only(),\n-                          r->allow_exec());\n-  if (base == nullptr || base != addr) {\n-    dealloc_heap_region();\n-    log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n-                  INTPTR_FORMAT \", size = \" SIZE_FORMAT \" bytes\",\n-                  p2i(addr), _mapped_heap_memregion.byte_size());\n-    return false;\n-  }\n+  char* base;\n@@ -2192,4 +2182,27 @@\n-  if (VerifySharedSpaces && !r->check_region_crc(base)) {\n-    dealloc_heap_region();\n-    log_info(cds)(\"UseSharedSpaces: mapped heap region is corrupt\");\n-    return false;\n+  if (MetaspaceShared::use_windows_memory_mapping()) {\n+    if (!read_region(MetaspaceShared::hp, addr,\n+                     align_up(_mapped_heap_memregion.byte_size(), os::vm_page_size()),\n+                     \/* do_commit = *\/ true)) {\n+      dealloc_heap_region();\n+      log_error(cds)(\"Failed to read archived heap region into \" INTPTR_FORMAT, p2i(addr));\n+      return false;\n+    }\n+    \/\/ Checks for VerifySharedSpaces is already done inside read_region()\n+    base = addr;\n+  } else {\n+    base = map_memory(_fd, _full_path, r->file_offset(),\n+                      addr, _mapped_heap_memregion.byte_size(), r->read_only(),\n+                      r->allow_exec());\n+    if (base == nullptr || base != addr) {\n+      dealloc_heap_region();\n+      log_info(cds)(\"UseSharedSpaces: Unable to map at required address in java heap. \"\n+                    INTPTR_FORMAT \", size = \" SIZE_FORMAT \" bytes\",\n+                    p2i(addr), _mapped_heap_memregion.byte_size());\n+      return false;\n+    }\n+\n+    if (VerifySharedSpaces && !r->check_region_crc(base)) {\n+      dealloc_heap_region();\n+      log_info(cds)(\"UseSharedSpaces: mapped heap region is corrupt\");\n+      return false;\n+    }\n","filename":"src\/hotspot\/share\/cds\/filemap.cpp","additions":29,"deletions":16,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1557,1 +1557,0 @@\n-  int i;\n@@ -1648,24 +1647,0 @@\n-#ifndef PRODUCT\n-ResourceBitMap HeapShared::calculate_oopmap(MemRegion region) {\n-  size_t num_bits = region.byte_size() \/ (UseCompressedOops ? sizeof(narrowOop) : sizeof(oop));\n-  ResourceBitMap oopmap(num_bits);\n-\n-  HeapWord* p   = region.start();\n-  HeapWord* end = region.end();\n-  FindEmbeddedNonNullPointers finder((void*)p, &oopmap);\n-\n-  int num_objs = 0;\n-  while (p < end) {\n-    oop o = cast_to_oop(p);\n-    o->oop_iterate(&finder);\n-    p += o->size();\n-    ++ num_objs;\n-  }\n-\n-  log_info(cds, heap)(\"calculate_oopmap: objects = %6d, oop fields = %7d (nulls = %7d)\",\n-                      num_objs, finder.num_total_oops(), finder.num_null_oops());\n-  return oopmap;\n-}\n-\n-#endif \/\/ !PRODUCT\n-\n","filename":"src\/hotspot\/share\/cds\/heapShared.cpp","additions":0,"deletions":25,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -374,1 +374,0 @@\n-  static ResourceBitMap calculate_oopmap(MemRegion region); \/\/ marks all the oop pointers\n@@ -429,0 +428,1 @@\n+#ifndef PRODUCT\n@@ -430,0 +430,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/cds\/heapShared.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-  _has_finalizer = access_flags.has_finalizer();\n+  _has_finalizer = ik->has_finalizer();\n","filename":"src\/hotspot\/share\/ci\/ciInstanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -229,0 +229,9 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciKlass::misc_flags\n+klass_flags_t ciKlass::misc_flags() {\n+  assert(is_loaded(), \"not loaded\");\n+  GUARDED_VM_ENTRY(\n+    return get_Klass()->misc_flags();\n+  )\n+}\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,3 @@\n+  \/\/ Fetch Klass::misc_flags.\n+  klass_flags_t          misc_flags();\n+\n","filename":"src\/hotspot\/share\/ci\/ciKlass.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -784,0 +784,16 @@\n+\/\/ ------------------------------------------------------------------\n+\/\/ ciMethod::equals\n+\/\/\n+\/\/ Returns true if the methods are the same, taking redefined methods\n+\/\/ into account.\n+bool ciMethod::equals(const ciMethod* m) const {\n+  if (this == m) return true;\n+  VM_ENTRY_MARK;\n+  Method* m1 = this->get_Method();\n+  Method* m2 = m->get_Method();\n+  if (m1->is_old()) m1 = m1->get_new_method();\n+  if (m2->is_old()) m2 = m2->get_new_method();\n+  return m1 == m2;\n+}\n+\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.cpp","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -369,0 +369,2 @@\n+  bool equals(const ciMethod* m) const;\n+\n","filename":"src\/hotspot\/share\/ci\/ciMethod.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -5176,3 +5176,1 @@\n-  if (_is_hidden) {\n-    ik->set_is_hidden();\n-  }\n+  assert(!_is_hidden || ik->is_hidden(), \"must be set already\");\n","filename":"src\/hotspot\/share\/classfile\/classFileParser.cpp","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen).\n+\/\/ UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, size_t buflen).\n@@ -437,1 +437,1 @@\n-void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, int utf8_length) {\n+void HashtableTextDump::put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length) {\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -434,1 +434,1 @@\n-  static void put_utf8(outputStream* st, const char* utf8_string, int utf8_length);\n+  static void put_utf8(outputStream* st, const char* utf8_string, size_t utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/compactHashtable.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -307,1 +307,2 @@\n-    char* expected = UNICODE::as_utf8(unicode, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    char* expected = UNICODE::as_utf8(unicode, utf8_len);\n@@ -349,1 +350,1 @@\n-  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, (int)strlen(utf8_str), false)) {\n+  if (UTF8::is_legal_utf8((const unsigned char*)utf8_str, strlen(utf8_str), false)) {\n@@ -557,1 +558,1 @@\n-  int result_length;\n+  size_t result_length;\n@@ -569,2 +570,2 @@\n-  assert(result_length >= length + 1, \"must not be shorter\");\n-  assert(result_length == (int)strlen(result) + 1, \"must match\");\n+  assert(result_length >= (size_t)length + 1, \"must not be shorter\");\n+  assert(result_length == strlen(result) + 1, \"must match\");\n@@ -585,2 +586,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    Symbol* sym = SymbolTable::new_symbol(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    Symbol* sym = SymbolTable::new_symbol(base, checked_cast<int>(utf8_len));\n@@ -601,2 +603,3 @@\n-    const char* base = UNICODE::as_utf8(position, length);\n-    return SymbolTable::probe(base, length);\n+    size_t utf8_len = static_cast<size_t>(length);\n+    const char* base = UNICODE::as_utf8(position, utf8_len);\n+    return SymbolTable::probe(base, checked_cast<int>(utf8_len));\n@@ -606,1 +609,1 @@\n-int java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n+size_t java_lang_String::utf8_length(oop java_string, typeArrayOop value) {\n@@ -620,1 +623,1 @@\n-int java_lang_String::utf8_length(oop java_string) {\n+size_t java_lang_String::utf8_length(oop java_string) {\n@@ -625,0 +628,19 @@\n+int java_lang_String::utf8_length_as_int(oop java_string) {\n+  typeArrayOop value = java_lang_String::value(java_string);\n+  return utf8_length_as_int(java_string, value);\n+}\n+\n+int java_lang_String::utf8_length_as_int(oop java_string, typeArrayOop value) {\n+  assert(value_equals(value, java_lang_String::value(java_string)),\n+         \"value must be same as java_lang_String::value(java_string)\");\n+  int length = java_lang_String::length(java_string, value);\n+  if (length == 0) {\n+    return 0;\n+  }\n+  if (!java_lang_String::is_latin1(java_string)) {\n+    return UNICODE::utf8_length_as_int(value->char_at_addr(0), length);\n+  } else {\n+    return UNICODE::utf8_length_as_int(value->byte_at_addr(0), length);\n+  }\n+}\n+\n@@ -626,1 +648,1 @@\n-  int length;\n+  size_t length;\n@@ -630,1 +652,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, int& length) {\n+char* java_lang_String::as_utf8_string(oop java_string, size_t& length) {\n@@ -632,0 +654,2 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n@@ -645,1 +669,1 @@\n-char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, int buflen, int& utf8_len) {\n+char* java_lang_String::as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& utf8_len) {\n@@ -666,1 +690,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen) {\n@@ -680,1 +704,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, char* buf, size_t buflen) {\n@@ -686,0 +710,3 @@\n+  \/\/ `length` is used as the incoming number of characters to\n+  \/\/ convert, and then set as the number of bytes in the UTF8 sequence.\n+  size_t  length = static_cast<size_t>(len);\n@@ -691,1 +718,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -694,1 +721,1 @@\n-    return UNICODE::as_utf8(position, len);\n+    return UNICODE::as_utf8(position, length);\n@@ -698,1 +725,1 @@\n-char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen) {\n+char* java_lang_String::as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen) {\n@@ -1455,6 +1482,0 @@\n-\n-  \/\/ Init lock is a C union with component_mirror.  Only instanceKlass mirrors have\n-  \/\/ init_lock and only ArrayKlass mirrors have component_mirror.  Since both are oops\n-  \/\/ GC treats them the same.\n-  _init_lock_offset = _component_mirror_offset;\n-\n@@ -1467,1 +1488,0 @@\n-  f->do_u4((u4*)&_init_lock_offset);\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.cpp","additions":46,"deletions":26,"binary":false,"changes":72,"status":"modified"},{"patch":"@@ -134,2 +134,5 @@\n-  static int utf8_length(oop java_string);\n-  static int utf8_length(oop java_string, typeArrayOop string_value);\n+  static size_t utf8_length(oop java_string);\n+  static size_t utf8_length(oop java_string, typeArrayOop string_value);\n+  \/\/ Legacy variants that truncate the length if needed\n+  static int    utf8_length_as_int(oop java_string);\n+  static int    utf8_length_as_int(oop java_string, typeArrayOop string_value);\n@@ -139,3 +142,4 @@\n-  static char*  as_utf8_string(oop java_string, int& length);\n-  static char*  as_utf8_string_full(oop java_string, char* buf, int buflen, int& length);\n-  static char*  as_utf8_string(oop java_string, char* buf, int buflen);\n+  \/\/ `length` is set to the length of the utf8 sequence.\n+  static char*  as_utf8_string(oop java_string, size_t& length);\n+  static char*  as_utf8_string_full(oop java_string, char* buf, size_t buflen, size_t& length);\n+  static char*  as_utf8_string(oop java_string, char* buf, size_t buflen);\n@@ -143,2 +147,2 @@\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, int buflen);\n-  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, int buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, char* buf, size_t buflen);\n+  static char*  as_utf8_string(oop java_string, typeArrayOop value, int start, int len, char* buf, size_t buflen);\n@@ -212,0 +216,1 @@\n+  macro(java_lang_Class, init_lock,              object_signature,  false)\n","filename":"src\/hotspot\/share\/classfile\/javaClasses.hpp","additions":12,"deletions":7,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -75,1 +75,3 @@\n-  char* module_name = java_lang_String::as_utf8_string(name_oop, len);\n+  size_t utf8_len;\n+  char* module_name = java_lang_String::as_utf8_string(name_oop, utf8_len);\n+  len = checked_cast<int>(utf8_len); \/\/ module names are < 64K\n@@ -87,1 +89,1 @@\n-  int len;\n+  size_t len;\n@@ -89,1 +91,1 @@\n-  return SymbolTable::new_symbol(str, len);\n+  return SymbolTable::new_symbol(str, checked_cast<int>(len));\n@@ -145,2 +147,4 @@\n-static const char* as_internal_package(oop package_string, char* buf, int buflen, int& utf8_len) {\n-  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, utf8_len);\n+static const char* as_internal_package(oop package_string, char* buf, size_t buflen, int& utf8_len) {\n+  size_t full_utf8_len;\n+  char* package_name = java_lang_String::as_utf8_string_full(package_string, buf, buflen, full_utf8_len);\n+  utf8_len = checked_cast<int>(full_utf8_len); \/\/ package names are < 64K\n","filename":"src\/hotspot\/share\/classfile\/modules.cpp","additions":9,"deletions":5,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -689,1 +689,1 @@\n-    int utf8_length = length;\n+    size_t utf8_length = length;\n@@ -700,1 +700,1 @@\n-    st->print(\"%d: \", utf8_length);\n+    st->print(\"%zu: \", utf8_length);\n","filename":"src\/hotspot\/share\/classfile\/stringTable.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -352,0 +352,1 @@\n+  assert(len >= 0, \"negative length %d suggests integer overflow in the caller\", len);\n@@ -464,1 +465,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -466,1 +467,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -469,1 +470,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -474,1 +475,1 @@\n-    return new_symbol(chars, utf8_length);\n+    return new_symbol(chars, checked_cast<int>(utf8_length));\n@@ -480,1 +481,1 @@\n-  int utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n+  size_t utf8_length = UNICODE::utf8_length((jchar*) name, utf16_length);\n@@ -482,1 +483,1 @@\n-  if (utf8_length < (int) sizeof(stack_buf)) {\n+  if (utf8_length < sizeof(stack_buf)) {\n@@ -485,1 +486,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n@@ -490,1 +491,1 @@\n-    return lookup_only(chars, utf8_length, hash);\n+    return lookup_only(chars, checked_cast<int>(utf8_length), hash);\n","filename":"src\/hotspot\/share\/classfile\/symbolTable.cpp","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -264,1 +264,2 @@\n-  if ((int)strlen(name) > Symbol::max_length()) {\n+  size_t name_len = strlen(name);\n+  if (name_len > static_cast<size_t>(Symbol::max_length())) {\n@@ -266,5 +267,18 @@\n-    \/\/ into the constant pool.\n-    Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n-                       \"Class name exceeds maximum length of %d: %s\",\n-                       Symbol::max_length(),\n-                       name);\n+    \/\/ into the constant pool. If necessary report an abridged name\n+    \/\/ in the exception message.\n+    if (name_len > static_cast<size_t>(MaxStringPrintSize)) {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %.*s ... (%zu characters omitted) ... %.*s\",\n+                         Symbol::max_length(),\n+                         MaxStringPrintSize \/ 2,\n+                         name,\n+                         name_len - 2 * (MaxStringPrintSize \/ 2), \/\/ allows for odd value\n+                         MaxStringPrintSize \/ 2,\n+                         name + name_len - MaxStringPrintSize \/ 2);\n+    }\n+    else {\n+      Exceptions::fthrow(THREAD_AND_LOCATION, exception,\n+                         \"Class name exceeds maximum length of %d: %s\",\n+                         Symbol::max_length(),\n+                         name);\n+    }\n@@ -274,1 +288,2 @@\n-  assert(UTF8::is_legal_utf8((const unsigned char*)name, (int)strlen(name), false),\n+  assert(UTF8::is_legal_utf8((const unsigned char*)name,\n+                             static_cast<int>(name_len), false),\n","filename":"src\/hotspot\/share\/classfile\/systemDictionary.cpp","additions":22,"deletions":7,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -80,0 +80,1 @@\n+  do_klass(IllegalCallerException_klass,                java_lang_IllegalCallerException                      ) \\\n","filename":"src\/hotspot\/share\/classfile\/vmClassMacros.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -245,0 +245,2 @@\n+    case vmIntrinsics::_Continuation_pin:\n+    case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -603,0 +603,2 @@\n+  do_intrinsic(_Continuation_pin,          jdk_internal_vm_Continuation, pin_name, void_method_signature, F_SN)         \\\n+  do_intrinsic(_Continuation_unpin,        jdk_internal_vm_Continuation, unpin_name, void_method_signature, F_SN)       \\\n","filename":"src\/hotspot\/share\/classfile\/vmIntrinsics.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -206,0 +206,1 @@\n+  template(java_lang_IllegalCallerException,          \"java\/lang\/IllegalCallerException\")         \\\n@@ -409,0 +410,2 @@\n+  template(pin_name,                                  \"pin\")                                      \\\n+  template(unpin_name,                                \"unpin\")                                    \\\n@@ -589,1 +592,1 @@\n-  template(classloader_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/String;)J\")             \\\n+  template(classloader_class_string_string_long_signature,         \"(Ljava\/lang\/ClassLoader;Ljava\/lang\/Class;Ljava\/lang\/String;Ljava\/lang\/String;)J\")             \\\n","filename":"src\/hotspot\/share\/classfile\/vmSymbols.hpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -208,1 +208,1 @@\n-  const size_t min_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3); \/\/ Make sure we have enough space for VM internal code\n+  const size_t min_cache_size = CompilerConfig::min_code_cache_size(); \/\/ Make sure we have enough space for VM internal code\n","filename":"src\/hotspot\/share\/code\/codeCache.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -458,1 +458,1 @@\n-      int max_count = (ReservedCodeCacheSize - (CodeCacheMinimumUseSpace DEBUG_ONLY(* 3))) \/ (int)buffer_size;\n+      int max_count = (ReservedCodeCacheSize - (int)CompilerConfig::min_code_cache_size()) \/ (int)buffer_size;\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -182,0 +182,1 @@\n+#ifdef ASSERT\n@@ -184,0 +185,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/compiler\/compilationPolicy.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -478,2 +478,1 @@\n-  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n-  uint min_code_cache_size = CodeCacheMinimumUseSpace DEBUG_ONLY(* 3);\n+  size_t min_code_cache_size = CompilerConfig::min_code_cache_size();\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -151,0 +151,2 @@\n+  inline static size_t min_code_cache_size();\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -28,0 +28,6 @@\n+#ifdef COMPILER1\n+#include \"c1\/c1_Compiler.hpp\"\n+#endif\n+#ifdef COMPILER2\n+#include \"opto\/c2compiler.hpp\"\n+#endif\n@@ -135,0 +141,9 @@\n+inline size_t CompilerConfig::min_code_cache_size() {\n+  size_t min_code_cache_size = CodeCacheMinimumUseSpace;\n+  \/\/ Template Interpreter code is approximately 3X larger in debug builds.\n+  DEBUG_ONLY(min_code_cache_size *= 3);\n+  COMPILER1_PRESENT(min_code_cache_size += Compiler::code_buffer_size());\n+  COMPILER2_PRESENT(min_code_cache_size += C2Compiler::initial_code_buffer_size());\n+  return min_code_cache_size;\n+}\n+\n","filename":"src\/hotspot\/share\/compiler\/compilerDefinitions.inline.hpp","additions":15,"deletions":0,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2008, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2008, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+#include \"runtime\/java.hpp\"\n@@ -788,7 +789,7 @@\n-#ifdef STATIC_BUILD\n-  char* p = strrchr(buf, '\/');\n-  *p = '\\0';\n-  strcat(p, \"\/lib\/\");\n-  lib_offset = jvm_offset = (int)strlen(buf);\n-#else\n-  {\n+\n+  if (is_vm_statically_linked()) {\n+    char* p = strrchr(buf, '\/');\n+    *p = '\\0';\n+    strcat(p, \"\/lib\/\");\n+    lib_offset = jvm_offset = (int)strlen(buf);\n+  } else {\n@@ -808,1 +809,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/compiler\/disassembler.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -225,0 +225,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n@@ -235,0 +238,3 @@\n+          if (bci + Bytecodes::length_for(code) >= method_len) {\n+            break;\n+          }\n","filename":"src\/hotspot\/share\/compiler\/methodLiveness.cpp","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -247,0 +247,4 @@\n+  \/\/ The claim size for group cardsets should be smaller to facilitate\n+  \/\/ better work distribution. The group cardsets should be larger than\n+  \/\/ the per region cardsets.\n+  const static uint GroupBucketClaimSize = 4;\n@@ -350,1 +354,9 @@\n-    _table_scanner.set(&_table, BucketClaimSize);\n+    reset_table_scanner(BucketClaimSize);\n+  }\n+\n+  void reset_table_scanner_for_groups() {\n+    reset_table_scanner(GroupBucketClaimSize);\n+  }\n+\n+  void reset_table_scanner(uint claim_size) {\n+    _table_scanner.set(&_table, claim_size);\n@@ -1045,0 +1057,4 @@\n+\n+void G1CardSet::reset_table_scanner_for_groups() {\n+  _table->reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -383,0 +383,2 @@\n+  void reset_table_scanner_for_groups();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardSet.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-  virtual void do_card_ptr(CardValue* card_ptr, uint worker_id) = 0;\n+  virtual void do_card_ptr(CardValue* card_ptr) = 0;\n@@ -47,1 +47,1 @@\n-      do_card_ptr(card_ptr, worker_id);\n+      do_card_ptr(card_ptr);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CardTableEntryClosure.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1162,0 +1162,2 @@\n+  _young_regions_cardset_mm(card_set_config(), card_set_freelist_pool()),\n+  _young_regions_cardset(card_set_config(), &_young_regions_cardset_mm),\n@@ -2696,0 +2698,1 @@\n+  hr->install_group_cardset(young_regions_cardset());\n@@ -2905,0 +2908,2 @@\n+      \/\/ Install the group cardset.\n+      new_alloc_region->install_group_cardset(young_regions_cardset());\n@@ -3046,0 +3051,4 @@\n+\n+void G1CollectedHeap::prepare_group_cardsets_for_scan () {\n+  _young_regions_cardset.reset_table_scanner_for_groups();\n+}\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -782,0 +782,4 @@\n+  \/\/ Group cardsets\n+  G1CardSetMemoryManager _young_regions_cardset_mm;\n+  G1CardSet _young_regions_cardset;\n+\n@@ -783,0 +787,8 @@\n+  G1CardSetConfiguration* card_set_config() { return &_card_set_config; }\n+\n+  G1CardSet* young_regions_cardset() { return &_young_regions_cardset; };\n+\n+  G1CardSetMemoryManager* young_regions_card_set_mm() { return &_young_regions_cardset_mm; }\n+\n+  void prepare_group_cardsets_for_scan();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectedHeap.hpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -300,1 +300,1 @@\n-  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards);\n+  double predicted_base_time_ms = _policy->predict_base_time_ms(pending_cards, _g1h->young_regions_cardset()->occupied());\n","filename":"src\/hotspot\/share\/gc\/g1\/g1CollectionSet.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2983,0 +2983,1 @@\n+  _young_cardset_bytes_per_region(0),\n@@ -2993,0 +2994,7 @@\n+  uint num_young_regions = g1h->young_regions_count();\n+  size_t young_cardset_bytes = g1h->young_regions_cardset()->mem_size();\n+\n+  if (num_young_regions > 0) {\n+    _young_cardset_bytes_per_region = young_cardset_bytes \/ num_young_regions;\n+  }\n+\n@@ -3044,0 +3052,4 @@\n+  if (r->is_young()) {\n+    remset_bytes = _young_cardset_bytes_per_region;\n+  }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.cpp","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -961,0 +961,2 @@\n+  size_t _young_cardset_bytes_per_region;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentMark.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -257,1 +257,0 @@\n-  size_t _sampled_card_rs_length;\n@@ -262,1 +261,1 @@\n-    _sampled_card_rs_length(0), _sampled_code_root_rs_length(0) {}\n+    _sampled_code_root_rs_length(0) {}\n@@ -266,1 +265,0 @@\n-    _sampled_card_rs_length += rem_set->occupied();\n@@ -271,1 +269,0 @@\n-  size_t sampled_card_rs_length() const { return _sampled_card_rs_length; }\n@@ -289,0 +286,2 @@\n+    G1CollectedHeap* g1h = G1CollectedHeap::heap();\n+    G1CollectionSet* cset = g1h->collection_set();\n@@ -290,1 +289,0 @@\n-    G1CollectionSet* cset = G1CollectedHeap::heap()->collection_set();\n@@ -292,1 +290,5 @@\n-    _policy->revise_young_list_target_length(cl.sampled_card_rs_length(), cl.sampled_code_root_rs_length());\n+\n+    size_t card_rs_length = g1h->young_regions_cardset()->occupied();\n+\n+    size_t sampled_code_root_rs_length = cl.sampled_code_root_rs_length();\n+    _policy->revise_young_list_target_length(card_rs_length, sampled_code_root_rs_length);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ConcurrentRefine.cpp","additions":8,"deletions":6,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-  Atomic::add(&_direct_allocated, value);\n+  Atomic::add(&_direct_allocated, value, memory_order_relaxed);\n@@ -37,1 +37,1 @@\n-  Atomic::add(&_num_plab_filled, value);\n+  Atomic::add(&_num_plab_filled, value, memory_order_relaxed);\n@@ -41,1 +41,1 @@\n-  Atomic::add(&_num_direct_allocated, value);\n+  Atomic::add(&_num_direct_allocated, value, memory_order_relaxed);\n@@ -45,2 +45,2 @@\n-  Atomic::add(&_region_end_waste, value);\n-  Atomic::inc(&_regions_filled);\n+  Atomic::add(&_region_end_waste, value, memory_order_relaxed);\n+  Atomic::inc(&_regions_filled, memory_order_relaxed);\n@@ -50,2 +50,2 @@\n-  Atomic::add(&_failure_used, used);\n-  Atomic::add(&_failure_waste, waste);\n+  Atomic::add(&_failure_used, used, memory_order_relaxed);\n+  Atomic::add(&_failure_waste, waste, memory_order_relaxed);\n","filename":"src\/hotspot\/share\/gc\/g1\/g1EvacStats.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    hr->uninstall_group_cardset();\n@@ -250,0 +251,2 @@\n+  _heap->young_regions_cardset()->clear();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1FullCollector.cpp","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -122,0 +122,1 @@\n+  uninstall_group_cardset();\n@@ -218,0 +219,3 @@\n+  if (is_young()) {\n+    uninstall_group_cardset();\n+  }\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+class G1CardSet;\n@@ -511,0 +512,3 @@\n+  void install_group_cardset(G1CardSet* group_cardset);\n+  void uninstall_group_cardset();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.hpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -514,0 +514,8 @@\n+inline void G1HeapRegion::install_group_cardset(G1CardSet* group_cardset) {\n+  _rem_set->install_group_cardset(group_cardset);\n+}\n+\n+inline void G1HeapRegion::uninstall_group_cardset() {\n+  _rem_set->uninstall_group_cardset();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegion.inline.hpp","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,7 @@\n+void G1HeapRegionRemSet::uninstall_group_cardset() {\n+  if (_saved_card_set != nullptr) {\n+    _card_set = _saved_card_set;\n+    _saved_card_set = nullptr;\n+  }\n+}\n+\n@@ -62,1 +69,2 @@\n-  _card_set(config, &_card_set_mm),\n+  _card_set(new G1CardSet(config, &_card_set_mm)),\n+  _saved_card_set(nullptr),\n@@ -71,0 +79,1 @@\n+  assert(_saved_card_set == nullptr, \"pre-condition\");\n@@ -75,1 +84,1 @@\n-  _card_set.clear();\n+  _card_set->clear();\n@@ -86,1 +95,1 @@\n-  _card_set.reset_table_scanner();\n+  _card_set->reset_table_scanner();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -50,1 +50,2 @@\n-  G1CardSet _card_set;\n+  G1CardSet* _card_set;\n+  G1CardSet* _saved_card_set;\n@@ -61,0 +62,1 @@\n+  ~G1HeapRegionRemSet() { delete _card_set; }\n@@ -63,1 +65,15 @@\n-    return _card_set.is_empty();\n+    return _card_set->is_empty();\n+  }\n+\n+  void install_group_cardset(G1CardSet* group_cardset) {\n+    assert(group_cardset != nullptr, \"pre-condition\");\n+    assert(_saved_card_set == nullptr, \"pre-condition\");\n+\n+    _saved_card_set = _card_set;\n+    _card_set = group_cardset;\n+  }\n+\n+  void uninstall_group_cardset();\n+\n+  bool has_group_cardset() {\n+    return _saved_card_set != nullptr;\n@@ -71,1 +87,1 @@\n-    return (code_roots_list_length() == 0) && _card_set.occupancy_less_or_equal_to(occ);\n+    return (code_roots_list_length() == 0) && _card_set->occupancy_less_or_equal_to(occ);\n@@ -80,0 +96,3 @@\n+  template <class CardOrRangeVisitor>\n+  inline static void iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl);\n+\n@@ -81,1 +100,1 @@\n-    return _card_set.occupied();\n+    return _card_set->occupied();\n@@ -84,0 +103,2 @@\n+  G1CardSet* card_set() { return _card_set; }\n+\n@@ -128,1 +149,1 @@\n-    return _card_set.mem_size()\n+    return _card_set->mem_size()\n@@ -134,1 +155,1 @@\n-    return _card_set.unused_mem_size();\n+    return _card_set->unused_mem_size();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.hpp","additions":27,"deletions":6,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -111,5 +111,1 @@\n-  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(&_card_set,\n-                                                                                       cl,\n-                                                                                       _card_set.config()->log2_card_regions_per_heap_region(),\n-                                                                                       _card_set.config()->log2_cards_per_card_region());\n-  _card_set.iterate_containers(&cl2, true \/* at_safepoint *\/);\n+  iterate_for_merge(_card_set, cl);\n@@ -118,0 +114,8 @@\n+template <class CardOrRangeVisitor>\n+void G1HeapRegionRemSet::iterate_for_merge(G1CardSet* card_set, CardOrRangeVisitor& cl) {\n+  G1HeapRegionRemSetMergeCardClosure<CardOrRangeVisitor, G1ContainerCardsOrRanges> cl2(card_set,\n+                                                                                       cl,\n+                                                                                       card_set->config()->log2_card_regions_per_heap_region(),\n+                                                                                       card_set->config()->log2_cards_per_card_region());\n+  card_set->iterate_containers(&cl2, true \/* at_safepoint *\/);\n+}\n@@ -133,1 +137,1 @@\n-   return;\n+    return;\n@@ -136,1 +140,1 @@\n-  _card_set.add_card(to_card(from));\n+  _card_set->add_card(to_card(from));\n@@ -140,1 +144,1 @@\n-  return _card_set.contains_card(to_card(from));\n+  return _card_set->contains_card(to_card(from));\n@@ -144,1 +148,1 @@\n-  _card_set.print_info(st, to_card(from));\n+  _card_set->print_info(st, to_card(from));\n","filename":"src\/hotspot\/share\/gc\/g1\/g1HeapRegionRemSet.inline.hpp","additions":13,"deletions":9,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -46,0 +47,1 @@\n+#include \"runtime\/mutexLocker.hpp\"\n@@ -64,1 +66,2 @@\n-                                           G1EvacFailureRegions* evac_failure_regions)\n+                                           G1EvacFailureRegions* evac_failure_regions,\n+                                           PartialArrayStateAllocator* pas_allocator)\n@@ -83,2 +86,2 @@\n-    _partial_objarray_chunk_size(ParGCArrayScanChunk),\n-    _partial_array_stepper(num_workers),\n+    _partial_array_state_allocator(pas_allocator),\n+    _partial_array_stepper(num_workers, ParGCArrayScanChunk),\n@@ -172,1 +175,1 @@\n-void G1ParScanThreadState::verify_task(PartialArrayScanTask task) const {\n+void G1ParScanThreadState::verify_task(PartialArrayState* task) const {\n@@ -174,1 +177,1 @@\n-  oop p = task.to_source_array();\n+  oop p = task->source();\n@@ -183,2 +186,2 @@\n-  } else if (task.is_partial_array_task()) {\n-    verify_task(task.to_partial_array_task());\n+  } else if (task.is_partial_array_state()) {\n+    verify_task(task.to_partial_array_state());\n@@ -226,2 +229,2 @@\n-void G1ParScanThreadState::do_partial_array(PartialArrayScanTask task) {\n-  oop from_obj = task.to_source_array();\n+void G1ParScanThreadState::do_partial_array(PartialArrayState* state) {\n+  oop to_obj = state->destination();\n@@ -229,0 +232,2 @@\n+#ifdef ASSERT\n+  oop from_obj = state->source();\n@@ -232,2 +237,0 @@\n-\n-  oop to_obj = from_obj->forwardee();\n@@ -236,0 +239,2 @@\n+#endif \/\/ ASSERT\n+\n@@ -238,6 +243,9 @@\n-  PartialArrayTaskStepper::Step step\n-    = _partial_array_stepper.next(objArrayOop(from_obj),\n-                                  to_array,\n-                                  _partial_objarray_chunk_size);\n-  for (uint i = 0; i < step._ncreate; ++i) {\n-    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+  \/\/ Claim a chunk and get number of additional tasks to enqueue.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  \/\/ Push any additional partial scan tasks needed.  Pushed before processing\n+  \/\/ the claimed chunk to allow other workers to steal while we're processing.\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_on_queue(ScannerTask(state));\n+    }\n@@ -248,3 +256,1 @@\n-  \/\/ Process claimed task.  The length of to_array is not correct, but\n-  \/\/ fortunately the iteration ignores the length field and just relies\n-  \/\/ on start\/end.\n+  \/\/ Process claimed task.\n@@ -252,2 +258,4 @@\n-                              step._index,\n-                              step._index + _partial_objarray_chunk_size);\n+                              checked_cast<int>(step._index),\n+                              checked_cast<int>(step._index + _partial_array_stepper.chunk_size()));\n+  \/\/ Release reference to the state, now that we're done with it.\n+  _partial_array_state_allocator->release(_worker_id, state);\n@@ -263,1 +271,0 @@\n-  assert(from_obj != to_obj, \"should not be scanning self-forwarded objects\");\n@@ -268,4 +275,2 @@\n-  PartialArrayTaskStepper::Step step\n-    = _partial_array_stepper.start(objArrayOop(from_obj),\n-                                   to_array,\n-                                   _partial_objarray_chunk_size);\n+  size_t array_length = to_array->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n@@ -275,2 +280,15 @@\n-  for (uint i = 0; i < step._ncreate; ++i) {\n-    push_on_queue(ScannerTask(PartialArrayScanTask(from_obj)));\n+  if (step._ncreate > 0) {\n+    assert(step._index < array_length, \"invariant\");\n+    assert(((array_length - step._index) % _partial_array_stepper.chunk_size()) == 0,\n+           \"invariant\");\n+    PartialArrayState* state =\n+      _partial_array_state_allocator->allocate(_worker_id,\n+                                               from_obj, to_obj,\n+                                               step._index,\n+                                               array_length,\n+                                               step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_on_queue(ScannerTask(state));\n+    }\n+  } else {\n+    assert(step._index == array_length, \"invariant\");\n@@ -287,3 +305,2 @@\n-  \/\/ module. The length of to_array is not correct, but fortunately\n-  \/\/ the iteration ignores that length field and relies on start\/end.\n-  to_array->oop_iterate_range(&_scanner, 0, step._index);\n+  \/\/ module.\n+  to_array->oop_iterate_range(&_scanner, 0, checked_cast<int>(step._index));\n@@ -300,1 +317,1 @@\n-    do_partial_array(task.to_partial_array_task());\n+    do_partial_array(task.to_partial_array_state());\n@@ -585,1 +602,2 @@\n-                               _evac_failure_regions);\n+                               _evac_failure_regions,\n+                               &_partial_array_state_allocator);\n@@ -718,1 +736,3 @@\n-    _evac_failure_regions(evac_failure_regions) {\n+    _evac_failure_regions(evac_failure_regions),\n+    _partial_array_state_allocator(num_workers)\n+{\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.cpp","additions":55,"deletions":35,"binary":false,"changes":90,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -90,1 +91,2 @@\n-  int _partial_objarray_chunk_size;\n+  size_t _partial_objarray_chunk_size;\n+  PartialArrayStateAllocator* _partial_array_state_allocator;\n@@ -132,1 +134,2 @@\n-                       G1EvacFailureRegions* evac_failure_regions);\n+                       G1EvacFailureRegions* evac_failure_regions,\n+                       PartialArrayStateAllocator* partial_array_state_allocator);\n@@ -143,1 +146,1 @@\n-  void verify_task(PartialArrayScanTask task) const NOT_DEBUG_RETURN;\n+  void verify_task(PartialArrayState* task) const NOT_DEBUG_RETURN;\n@@ -172,1 +175,1 @@\n-  void do_partial_array(PartialArrayScanTask task);\n+  void do_partial_array(PartialArrayState* state);\n@@ -255,0 +258,1 @@\n+  PartialArrayStateAllocator _partial_array_state_allocator;\n","filename":"src\/hotspot\/share\/gc\/g1\/g1ParScanThreadState.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1092,0 +1092,5 @@\n+  return predict_base_time_ms(pending_cards, card_rs_length);\n+}\n+\n+double G1Policy::predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const {\n+  bool for_young_only_phase = collector_state()->in_young_only_phase();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -141,0 +141,2 @@\n+  double predict_base_time_ms(size_t pending_cards, size_t card_rs_length) const;\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1Policy.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1233,1 +1233,1 @@\n-    void do_card_ptr(CardValue* card_ptr, uint worker_id) {\n+    void do_card_ptr(CardValue* card_ptr) override {\n@@ -1237,1 +1237,0 @@\n-      \/\/ In this case worker_id should be the id of a GC worker thread.\n@@ -1345,0 +1344,1 @@\n+\n@@ -1382,0 +1382,4 @@\n+        if (_initial_evacuation) {\n+          G1HeapRegionRemSet::iterate_for_merge(g1h->young_regions_cardset(), merge);\n+        }\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSet.cpp","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -221,0 +221,1 @@\n+    size_t occupied_cards = hrrs->occupied();\n@@ -225,0 +226,8 @@\n+\n+    if (r->is_young()) {\n+      uint num_young  =  G1CollectedHeap::heap()->young_regions_count();\n+      occupied_cards \/= num_young;\n+      rs_unused_mem_sz \/= num_young;\n+      rs_mem_sz \/= num_young;\n+    }\n+\n@@ -229,1 +238,1 @@\n-    size_t occupied_cards = hrrs->occupied();\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1RemSetSummary.cpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -298,4 +298,3 @@\n-      \/\/ Sample card set sizes for young gen and humongous before GC: this makes\n-      \/\/ the policy to give back memory to the OS keep the most recent amount of\n-      \/\/ memory for these regions.\n-      if (hr->is_young() || hr->is_starts_humongous()) {\n+      \/\/ Sample card set sizes for humongous before GC: this makes the policy to give\n+      \/\/ back memory to the OS keep the most recent amount of memory for these regions.\n+      if (hr->is_starts_humongous()) {\n@@ -510,0 +509,3 @@\n+\n+    _g1h->prepare_group_cardsets_for_scan();\n+\n@@ -517,1 +519,4 @@\n-    _g1h->set_young_gen_card_set_stats(g1_prep_task.all_card_set_stats());\n+    G1MonotonicArenaMemoryStats sampled_card_set_stats = g1_prep_task.all_card_set_stats();\n+    sampled_card_set_stats.add(_g1h->young_regions_card_set_mm()->memory_stats());\n+    _g1h->set_young_gen_card_set_stats(sampled_card_set_stats);\n+\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungCollector.cpp","additions":10,"deletions":5,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -525,1 +525,1 @@\n-  void do_card_ptr(CardValue* card_ptr, uint worker_id) {\n+  void do_card_ptr(CardValue* card_ptr) override {\n@@ -676,0 +676,4 @@\n+\n+    \/\/ Add the cards from the group cardsets.\n+    _card_rs_length += g1h->young_regions_cardset()->occupied();\n+\n@@ -825,1 +829,0 @@\n-    stats()->account_card_rs_length(r);\n@@ -828,0 +831,2 @@\n+      \/\/ We only use card_rs_length statistics to estimate young regions length.\n+      stats()->account_card_rs_length(r);\n@@ -914,0 +919,2 @@\n+\n+    _g1h->young_regions_cardset()->clear();\n","filename":"src\/hotspot\/share\/gc\/g1\/g1YoungGCPostEvacuateTasks.cpp","additions":9,"deletions":2,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -524,1 +524,1 @@\n-void ParallelCompactData::verify_clear(const PSVirtualSpace* vspace)\n+void ParallelCompactData::verify_clear()\n@@ -526,2 +526,2 @@\n-  const size_t* const beg = (const size_t*)vspace->committed_low_addr();\n-  const size_t* const end = (const size_t*)vspace->committed_high_addr();\n+  const size_t* const beg = (const size_t*) _region_vspace->committed_low_addr();\n+  const size_t* const end = (const size_t*) _region_vspace->committed_high_addr();\n@@ -532,5 +532,0 @@\n-\n-void ParallelCompactData::verify_clear()\n-{\n-  verify_clear(_region_vspace);\n-}\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.cpp","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -377,3 +377,0 @@\n-  void clear_range(HeapWord* beg, HeapWord* end) {\n-    clear_range(addr_to_region_idx(beg), addr_to_region_idx(end));\n-  }\n@@ -396,1 +393,0 @@\n-  void verify_clear(const PSVirtualSpace* vspace);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psParallelCompact.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,2 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"gc\/shared\/partialArrayTaskStepper.inline.hpp\"\n@@ -45,0 +47,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -51,0 +54,1 @@\n+PartialArrayStateAllocator*    PSPromotionManager::_partial_array_state_allocator = nullptr;\n@@ -65,0 +69,4 @@\n+  assert(_partial_array_state_allocator == nullptr, \"Attempt to initialize twice\");\n+  _partial_array_state_allocator\n+    = new PartialArrayStateAllocator(ParallelGCThreads);\n+\n@@ -70,0 +78,1 @@\n+    _manager_array[i]._partial_array_state_allocator_index = i;\n@@ -127,0 +136,4 @@\n+  \/\/ All PartialArrayStates have been returned to the allocator, since the\n+  \/\/ claimed_stack_depths are all empty.  Leave them there for use by future\n+  \/\/ collections.\n+\n@@ -175,1 +188,4 @@\n-PSPromotionManager::PSPromotionManager() {\n+\/\/ Most members are initialized either by initialize() or reset().\n+PSPromotionManager::PSPromotionManager()\n+  : _partial_array_stepper(ParallelGCThreads, ParGCArrayScanChunk)\n+{\n@@ -185,1 +201,3 @@\n-  _array_chunk_size = ParGCArrayScanChunk;\n+  \/\/ Initialize to a bad value; fixed by initialize().\n+  _partial_array_state_allocator_index = UINT_MAX;\n+\n@@ -187,1 +205,1 @@\n-  _min_array_size_for_chunking = 3 * _array_chunk_size \/ 2;\n+  _min_array_size_for_chunking = (3 * ParGCArrayScanChunk \/ 2);\n@@ -280,7 +298,1 @@\n-void PSPromotionManager::process_array_chunk(PartialArrayScanTask task) {\n-  assert(PSChunkLargeArrays, \"invariant\");\n-\n-  oop old = task.to_source_array();\n-  assert(old->is_objArray(), \"invariant\");\n-  assert(old->is_forwarded(), \"invariant\");\n-\n+void PSPromotionManager::process_array_chunk(PartialArrayState* state) {\n@@ -289,11 +301,15 @@\n-  oop const obj = old->forwardee();\n-\n-  int start;\n-  int const end = arrayOop(old)->length();\n-  if (end > (int) _min_array_size_for_chunking) {\n-    \/\/ we'll chunk more\n-    start = end - _array_chunk_size;\n-    assert(start > 0, \"invariant\");\n-    arrayOop(old)->set_length(start);\n-    push_depth(ScannerTask(PartialArrayScanTask(old)));\n-    TASKQUEUE_STATS_ONLY(++_array_chunk_pushes);\n+  \/\/ Claim a chunk.  Push additional tasks before processing the claimed\n+  \/\/ chunk to allow other workers to steal while we're processing.\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.next(state);\n+  if (step._ncreate > 0) {\n+    state->add_references(step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n+  int start = checked_cast<int>(step._index);\n+  int end = checked_cast<int>(step._index + _partial_array_stepper.chunk_size());\n+  assert(start < end, \"invariant\");\n+  if (UseCompressedOops) {\n+    process_array_chunk_work<narrowOop>(state->destination(), start, end);\n@@ -301,4 +317,1 @@\n-    \/\/ this is the final chunk for this array\n-    start = 0;\n-    int const actual_length = arrayOop(obj)->length();\n-    arrayOop(old)->set_length(actual_length);\n+    process_array_chunk_work<oop>(state->destination(), start, end);\n@@ -306,0 +319,3 @@\n+  \/\/ Release reference to state, now that we're done with it.\n+  _partial_array_state_allocator->release(_partial_array_state_allocator_index, state);\n+}\n@@ -307,0 +323,22 @@\n+void PSPromotionManager::push_objArray(oop old_obj, oop new_obj) {\n+  assert(old_obj->is_objArray(), \"precondition\");\n+  assert(old_obj->is_forwarded(), \"precondition\");\n+  assert(old_obj->forwardee() == new_obj, \"precondition\");\n+  assert(new_obj->is_objArray(), \"precondition\");\n+\n+  size_t array_length = objArrayOop(new_obj)->length();\n+  PartialArrayTaskStepper::Step step = _partial_array_stepper.start(array_length);\n+\n+  if (step._ncreate > 0) {\n+    TASKQUEUE_STATS_ONLY(++_arrays_chunked);\n+    PartialArrayState* state =\n+      _partial_array_state_allocator->allocate(_partial_array_state_allocator_index,\n+                                               old_obj, new_obj,\n+                                               step._index,\n+                                               array_length,\n+                                               step._ncreate);\n+    for (uint i = 0; i < step._ncreate; ++i) {\n+      push_depth(ScannerTask(state));\n+    }\n+    TASKQUEUE_STATS_ONLY(_array_chunk_pushes += step._ncreate);\n+  }\n@@ -308,1 +346,1 @@\n-    process_array_chunk_work<narrowOop>(obj, start, end);\n+    process_array_chunk_work<narrowOop>(new_obj, 0, checked_cast<int>(step._index));\n@@ -310,1 +348,1 @@\n-    process_array_chunk_work<oop>(obj, start, end);\n+    process_array_chunk_work<oop>(new_obj, 0, checked_cast<int>(step._index));\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.cpp","additions":66,"deletions":28,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"gc\/shared\/partialArrayTaskStepper.hpp\"\n@@ -52,0 +53,2 @@\n+class PartialArrayState;\n+class PartialArrayStateAllocator;\n@@ -88,1 +91,3 @@\n-  uint                                _array_chunk_size;\n+  static PartialArrayStateAllocator*  _partial_array_state_allocator;\n+  PartialArrayTaskStepper             _partial_array_stepper;\n+  uint                                _partial_array_state_allocator_index;\n@@ -104,1 +109,2 @@\n-  void process_array_chunk(PartialArrayScanTask task);\n+  void process_array_chunk(PartialArrayState* state);\n+  void push_objArray(oop old_obj, oop new_obj);\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.hpp","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -279,3 +279,1 @@\n-      \/\/ we'll chunk it\n-      push_depth(ScannerTask(PartialArrayScanTask(o)));\n-      TASKQUEUE_STATS_ONLY(++_arrays_chunked; ++_array_chunk_pushes);\n+      push_objArray(o, new_obj);\n@@ -325,1 +323,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n@@ -327,1 +325,1 @@\n-    process_array_chunk(task.to_partial_array_task());\n+    process_array_chunk(task.to_partial_array_state());\n@@ -344,1 +342,1 @@\n-  if (task.is_partial_array_task()) {\n+  if (task.is_partial_array_state()) {\n","filename":"src\/hotspot\/share\/gc\/parallel\/psPromotionManager.inline.hpp","additions":5,"deletions":7,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -575,5 +575,0 @@\n-HeapWord* DefNewGeneration::expand_and_allocate(size_t size, bool is_tlab) {\n-  \/\/ We don't attempt to expand the young generation (but perhaps we should.)\n-  return allocate(size, is_tlab);\n-}\n-\n@@ -854,1 +849,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n@@ -863,6 +866,1 @@\n-\n-const char* DefNewGeneration::name() const {\n-  return \"def new generation\";\n-}\n-\n-HeapWord* DefNewGeneration::allocate(size_t word_size, bool is_tlab) {\n+HeapWord* DefNewGeneration::allocate(size_t word_size) {\n@@ -878,2 +876,1 @@\n-HeapWord* DefNewGeneration::par_allocate(size_t word_size,\n-                                         bool is_tlab) {\n+HeapWord* DefNewGeneration::par_allocate(size_t word_size) {\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.cpp","additions":11,"deletions":14,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -212,3 +212,3 @@\n-  HeapWord* allocate(size_t word_size, bool is_tlab);\n-\n-  HeapWord* par_allocate(size_t word_size, bool is_tlab);\n+  \/\/ Allocate requested size or return null; single-threaded and lock-free versions.\n+  HeapWord* allocate(size_t word_size);\n+  HeapWord* par_allocate(size_t word_size);\n@@ -230,2 +230,0 @@\n-  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n-\n@@ -239,2 +237,1 @@\n-  virtual const char* name() const;\n-  virtual const char* short_name() const { return \"DefNew\"; }\n+  const char* name() const { return \"DefNew\"; }\n","filename":"src\/hotspot\/share\/gc\/serial\/defNewGeneration.hpp","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -61,12 +61,0 @@\n-\n-void Generation::print() const { print_on(tty); }\n-\n-void Generation::print_on(outputStream* st)  const {\n-  st->print(\" %-20s\", name());\n-  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n-             capacity()\/K, used()\/K);\n-  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n-              p2i(_virtual_space.low_boundary()),\n-              p2i(_virtual_space.high()),\n-              p2i(_virtual_space.high_boundary()));\n-}\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.cpp","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -106,21 +106,0 @@\n-  \/\/ Allocate and returns a block of the requested size, or returns \"null\".\n-  \/\/ Assumes the caller has done any necessary locking.\n-  virtual HeapWord* allocate(size_t word_size, bool is_tlab) = 0;\n-\n-  \/\/ Like \"allocate\", but performs any necessary locking internally.\n-  virtual HeapWord* par_allocate(size_t word_size, bool is_tlab) = 0;\n-\n-  \/\/ Perform a heap collection, attempting to create (at least) enough\n-  \/\/ space to support an allocation of the given \"word_size\".  If\n-  \/\/ successful, perform the allocation and return the resulting\n-  \/\/ \"oop\" (initializing the allocated block). If the allocation is\n-  \/\/ still unsuccessful, return \"null\".\n-  virtual HeapWord* expand_and_allocate(size_t word_size, bool is_tlab) = 0;\n-\n-  \/\/ Printing\n-  virtual const char* name() const = 0;\n-  virtual const char* short_name() const = 0;\n-\n-  virtual void print() const;\n-  virtual void print_on(outputStream* st) const;\n-\n@@ -131,2 +110,1 @@\n-  virtual void update_counters() = 0;\n-  virtual CollectorCounters* counters() { return _gc_counters; }\n+  CollectorCounters* counters() { return _gc_counters; }\n","filename":"src\/hotspot\/share\/gc\/serial\/generation.hpp","additions":1,"deletions":23,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -159,1 +159,1 @@\n-  return old_gen()->allocate(word_size, false \/* is_tlab *\/);\n+  return old_gen()->allocate(word_size);\n@@ -295,1 +295,1 @@\n-    result = _old_gen->expand_and_allocate(size, is_tlab);\n+    result = _old_gen->expand_and_allocate(size);\n@@ -299,1 +299,2 @@\n-      result = _young_gen->expand_and_allocate(size, is_tlab);\n+      \/\/ Young-gen is not expanded.\n+      result = _young_gen->allocate(size);\n@@ -317,1 +318,1 @@\n-      result = young->par_allocate(size, is_tlab);\n+      result = young->par_allocate(size);\n@@ -409,1 +410,1 @@\n-    res = _young_gen->allocate(size, is_tlab);\n+    res = _young_gen->allocate(size);\n@@ -416,1 +417,1 @@\n-    res = _old_gen->allocate(size, is_tlab);\n+    res = _old_gen->allocate(size);\n@@ -884,6 +885,6 @@\n-  if (_young_gen != nullptr) {\n-    _young_gen->print_on(st);\n-  }\n-  if (_old_gen != nullptr) {\n-    _old_gen->print_on(st);\n-  }\n+  assert(_young_gen != nullptr, \"precondition\");\n+  assert(_old_gen   != nullptr, \"precondition\");\n+\n+  _young_gen->print_on(st);\n+  _old_gen->print_on(st);\n+\n@@ -910,1 +911,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(def_new_gen->name(),\n@@ -926,1 +927,1 @@\n-                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->short_name(),\n+                     HEAP_CHANGE_FORMAT_ARGS(old_gen()->name(),\n","filename":"src\/hotspot\/share\/gc\/serial\/serialHeap.cpp","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -400,1 +400,1 @@\n-  HeapWord* result = allocate(obj_size, false);\n+  HeapWord* result = allocate(obj_size);\n@@ -403,1 +403,1 @@\n-    result = expand_and_allocate(obj_size, false);\n+    result = expand_and_allocate(obj_size);\n@@ -410,2 +410,1 @@\n-TenuredGeneration::expand_and_allocate(size_t word_size, bool is_tlab) {\n-  assert(!is_tlab, \"TenuredGeneration does not support TLAB allocation\");\n+TenuredGeneration::expand_and_allocate(size_t word_size) {\n@@ -413,1 +412,1 @@\n-  return allocate(word_size, is_tlab);\n+  return allocate(word_size);\n@@ -444,1 +443,9 @@\n-  Generation::print_on(st);\n+  st->print(\" %-10s\", name());\n+\n+  st->print(\" total \" SIZE_FORMAT \"K, used \" SIZE_FORMAT \"K\",\n+            capacity()\/K, used()\/K);\n+  st->print_cr(\" [\" PTR_FORMAT \", \" PTR_FORMAT \", \" PTR_FORMAT \")\",\n+               p2i(_virtual_space.low_boundary()),\n+               p2i(_virtual_space.high()),\n+               p2i(_virtual_space.high_boundary()));\n+\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -124,2 +124,1 @@\n-  const char* name() const { return \"tenured generation\"; }\n-  const char* short_name() const { return \"Tenured\"; }\n+  const char* name() const { return \"Tenured\"; }\n@@ -133,2 +132,3 @@\n-  virtual inline HeapWord* allocate(size_t word_size, bool is_tlab);\n-  virtual inline HeapWord* par_allocate(size_t word_size, bool is_tlab);\n+  \/\/ Allocate and returns a block of the requested size, or returns \"null\".\n+  \/\/ Assumes the caller has done any necessary locking.\n+  inline HeapWord* allocate(size_t word_size);\n@@ -136,1 +136,2 @@\n-  HeapWord* expand_and_allocate(size_t size, bool is_tlab);\n+  \/\/ Expand the old-gen then invoke allocate above.\n+  HeapWord* expand_and_allocate(size_t size);\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.hpp","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -51,3 +51,1 @@\n-HeapWord* TenuredGeneration::allocate(size_t word_size,\n-                                      bool is_tlab) {\n-  assert(!is_tlab, \"TenuredGeneration does not support TLAB allocation\");\n+HeapWord* TenuredGeneration::allocate(size_t word_size) {\n@@ -61,10 +59,0 @@\n-HeapWord* TenuredGeneration::par_allocate(size_t word_size,\n-                                          bool is_tlab) {\n-  assert(!is_tlab, \"TenuredGeneration does not support TLAB allocation\");\n-  HeapWord* res = _the_space->par_allocate(word_size);\n-  if (res != nullptr) {\n-    _bts->update_for_block(res, res + word_size);\n-  }\n-  return res;\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/serial\/tenuredGeneration.inline.hpp","additions":1,"deletions":13,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+#include \"utilities\/ticks.hpp\"\n@@ -41,0 +42,21 @@\n+\/\/ GCLockerTimingDebugLogger tracks specific timing information for GC lock waits.\n+class GCLockerTimingDebugLogger : public StackObj {\n+  const char* _log_message;\n+  Ticks _start;\n+\n+public:\n+  GCLockerTimingDebugLogger(const char* log_message) : _log_message(log_message) {\n+    assert(_log_message != nullptr, \"GC locker debug message must be set.\");\n+    _start = Ticks::now();\n+  }\n+\n+  ~GCLockerTimingDebugLogger() {\n+    Log(gc, jni) log;\n+    if (log.is_debug()) {\n+      ResourceMark rm; \/\/ JavaThread::name() allocates to convert to UTF8\n+      const Tickspan elapsed_time = Ticks::now() - _start;\n+      log.debug(\"%s Resumed after \" UINT64_FORMAT \"ms. Thread \\\"%s\\\".\", _log_message, elapsed_time.milliseconds(), Thread::current()->name());\n+    }\n+  }\n+};\n+\n@@ -113,5 +135,5 @@\n-  }\n-\n-  \/\/ Wait for _needs_gc  to be cleared\n-  while (needs_gc()) {\n-    ml.wait();\n+    GCLockerTimingDebugLogger logger(\"Thread stalled by JNI critical section.\");\n+    \/\/ Wait for _needs_gc to be cleared\n+    while (needs_gc()) {\n+      ml.wait();\n+    }\n@@ -130,10 +152,14 @@\n-  while (needs_gc()) {\n-    \/\/ There's at least one thread that has not left the critical region (CR)\n-    \/\/ completely. When that last thread (no new threads can enter CR due to the\n-    \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n-    \/\/ to false and wakes up all blocked threads.\n-    \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n-    \/\/ in the code, but it's too strong; it's possible that the last thread\n-    \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n-    \/\/ a GCCause::_gc_locker GC.\n-    ml.wait();\n+  if (needs_gc()) {\n+    log_debug_jni(\"Blocking thread as there is a pending GC request\");\n+    GCLockerTimingDebugLogger logger(\"Thread blocked to enter critical region.\");\n+    while (needs_gc()) {\n+      \/\/ There's at least one thread that has not left the critical region (CR)\n+      \/\/ completely. When that last thread (no new threads can enter CR due to the\n+      \/\/ blocking) exits CR, it calls `jni_unlock`, which sets `_needs_gc`\n+      \/\/ to false and wakes up all blocked threads.\n+      \/\/ We would like to assert #threads in CR to be > 0, `_jni_lock_count > 0`\n+      \/\/ in the code, but it's too strong; it's possible that the last thread\n+      \/\/ has called `jni_unlock`, but not yet finished the call, e.g. initiating\n+      \/\/ a GCCause::_gc_locker GC.\n+      ml.wait();\n+    }\n@@ -151,0 +177,1 @@\n+  log_debug_jni(\"Thread exiting critical region.\");\n@@ -164,1 +191,1 @@\n-      log_debug_jni(\"Performing GC after exiting critical section.\");\n+      log_debug_jni(\"Last thread exiting. Performing GC after exiting critical section.\");\n","filename":"src\/hotspot\/share\/gc\/shared\/gcLocker.cpp","additions":43,"deletions":16,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -0,0 +1,153 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"gc\/shared\/partialArrayState.hpp\"\n+#include \"memory\/allocation.inline.hpp\"\n+#include \"memory\/arena.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/orderAccess.hpp\"\n+#include \"utilities\/debug.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+#include <new>\n+\n+PartialArrayState::PartialArrayState(oop src, oop dst,\n+                                     size_t index, size_t length,\n+                                     size_t initial_refcount)\n+  : _source(src),\n+    _destination(dst),\n+    _length(length),\n+    _index(index),\n+    _refcount(initial_refcount)\n+{\n+  assert(index <= length, \"precondition\");\n+}\n+\n+void PartialArrayState::add_references(size_t count) {\n+  size_t new_count = Atomic::add(&_refcount, count, memory_order_relaxed);\n+  assert(new_count >= count, \"reference count overflow\");\n+}\n+\n+class PartialArrayStateAllocator::Impl : public CHeapObj<mtGC> {\n+  struct FreeListEntry;\n+\n+  Arena* _arenas;\n+  FreeListEntry** _free_lists;\n+  uint _num_workers;\n+\n+public:\n+  Impl(uint num_workers);\n+  ~Impl();\n+\n+  NONCOPYABLE(Impl);\n+\n+  PartialArrayState* allocate(uint worker_id,\n+                              oop src, oop dst,\n+                              size_t index, size_t length,\n+                              size_t initial_refcount);\n+  void release(uint worker_id, PartialArrayState* state);\n+};\n+\n+struct PartialArrayStateAllocator::Impl::FreeListEntry {\n+  FreeListEntry* _next;\n+\n+  FreeListEntry(FreeListEntry* next) : _next(next) {}\n+  ~FreeListEntry() = default;\n+\n+  NONCOPYABLE(FreeListEntry);\n+};\n+\n+PartialArrayStateAllocator::Impl::Impl(uint num_workers)\n+  : _arenas(NEW_C_HEAP_ARRAY(Arena, num_workers, mtGC)),\n+    _free_lists(NEW_C_HEAP_ARRAY(FreeListEntry*, num_workers, mtGC)),\n+    _num_workers(num_workers)\n+{\n+  for (uint i = 0; i < _num_workers; ++i) {\n+    ::new (&_arenas[i]) Arena(mtGC);\n+    _free_lists[i] = nullptr;\n+  }\n+}\n+\n+PartialArrayStateAllocator::Impl::~Impl() {\n+  \/\/ We don't need to clean up the free lists.  Deallocating the entries\n+  \/\/ does nothing, since we're using arena allocation.  Instead, leave it\n+  \/\/ to the arena destructor to release the memory.\n+  FREE_C_HEAP_ARRAY(FreeListEntry*, _free_lists);\n+  for (uint i = 0; i < _num_workers; ++i) {\n+    _arenas[i].~Arena();\n+  }\n+  FREE_C_HEAP_ARRAY(Arena*, _arenas);\n+}\n+\n+PartialArrayState* PartialArrayStateAllocator::Impl::allocate(uint worker_id,\n+                                                              oop src, oop dst,\n+                                                              size_t index,\n+                                                              size_t length,\n+                                                              size_t initial_refcount) {\n+  void* p;\n+  FreeListEntry* head = _free_lists[worker_id];\n+  if (head == nullptr) {\n+    p = NEW_ARENA_OBJ(&_arenas[worker_id], PartialArrayState);\n+  } else {\n+    _free_lists[worker_id] = head->_next;\n+    head->~FreeListEntry();\n+    p = head;\n+  }\n+  return ::new (p) PartialArrayState(src, dst, index, length, initial_refcount);\n+}\n+\n+void PartialArrayStateAllocator::Impl::release(uint worker_id, PartialArrayState* state) {\n+  size_t refcount = Atomic::sub(&state->_refcount, size_t(1), memory_order_release);\n+  if (refcount != 0) {\n+    assert(refcount + 1 != 0, \"refcount underflow\");\n+  } else {\n+    OrderAccess::acquire();\n+    state->~PartialArrayState();\n+    _free_lists[worker_id] = ::new (state) FreeListEntry(_free_lists[worker_id]);\n+  }\n+}\n+\n+PartialArrayStateAllocator::PartialArrayStateAllocator(uint num_workers)\n+  : _impl(new Impl(num_workers))\n+{}\n+\n+PartialArrayStateAllocator::~PartialArrayStateAllocator() {\n+  delete _impl;\n+}\n+\n+PartialArrayState* PartialArrayStateAllocator::allocate(uint worker_id,\n+                                                        oop src, oop dst,\n+                                                        size_t index,\n+                                                        size_t length,\n+                                                        size_t initial_refcount) {\n+  return _impl->allocate(worker_id, src, dst, index, length, initial_refcount);\n+}\n+\n+void PartialArrayStateAllocator::release(uint worker_id, PartialArrayState* state) {\n+  _impl->release(worker_id, state);\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.cpp","additions":153,"deletions":0,"binary":false,"changes":153,"status":"added"},{"patch":"@@ -0,0 +1,137 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_GC_SHARED_PARTIALARRAYSTATE_HPP\n+#define SHARE_GC_SHARED_PARTIALARRAYSTATE_HPP\n+\n+#include \"memory\/allocation.hpp\"\n+#include \"oops\/oopsHierarchy.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+#include \"utilities\/macros.hpp\"\n+\n+class PartialArrayStateAllocator;\n+\n+\/\/ Instances of this class are used to represent processing progress for an\n+\/\/ array task in a taskqueue.  When a sufficiently large array needs to be\n+\/\/ processed, such that it is desirable to split up the processing into\n+\/\/ parallelizable subtasks, a state object is allocated for the array.\n+\/\/ Multiple tasks referring to the state can then be added to the taskqueue\n+\/\/ for later processing, either by the current thread or by some other thread\n+\/\/ that steals one of those tasks.\n+\/\/\n+\/\/ Processing a state involves using the state to claim a segment of the\n+\/\/ array, and processing that segment.  Claiming is done by atomically\n+\/\/ incrementing the index, thereby claiming the segment from the old to new\n+\/\/ index values.  New tasks should also be added as needed to ensure the\n+\/\/ entire array will be processed.  A PartialArrayTaskStepper can be used to\n+\/\/ help with this.\n+\/\/\n+\/\/ States are allocated and released using a PartialArrayStateAllocator.\n+\/\/ States are reference counted to aid in that management.  Each task\n+\/\/ referring to a given state that is added to a taskqueue must increase the\n+\/\/ reference count by one.  When the processing of a task referring to a state\n+\/\/ is complete, the reference count must be decreased by one.  When the\n+\/\/ reference count reaches zero the state should be released to the allocator\n+\/\/ for later reuse.\n+class PartialArrayState {\n+  oop _source;\n+  oop _destination;\n+  size_t _length;\n+  volatile size_t _index;\n+  volatile size_t _refcount;\n+\n+  friend class PartialArrayStateAllocator;\n+\n+  PartialArrayState(oop src, oop dst,\n+                    size_t index, size_t length,\n+                    size_t initial_refcount);\n+  ~PartialArrayState() = default;\n+\n+  NONCOPYABLE(PartialArrayState);\n+\n+public:\n+  \/\/ Add count references, one per referring task being added to a taskqueue.\n+  void add_references(size_t count);\n+\n+  \/\/ The source array oop.\n+  oop source() const { return _source; }\n+\n+  \/\/ The destination array oop.  In some circumstances the source and\n+  \/\/ destination may be the same.\n+  oop destination() const { return _destination; }\n+\n+  \/\/ The length of the array oop.\n+  size_t length() const { return _length; }\n+\n+  \/\/ A pointer to the start index for the next segment to process, for atomic\n+  \/\/ update.\n+  volatile size_t* index_addr() { return &_index; }\n+};\n+\n+\/\/ This class provides memory management for PartialArrayStates.\n+\/\/\n+\/\/ States are initially allocated from a set of arenas owned by the allocator.\n+\/\/ This allows the entire set of allocated states to be discarded without the\n+\/\/ need to keep track of or find them under some circumstances.  For example,\n+\/\/ if G1 concurrent marking is aborted and needs to restart because of a full\n+\/\/ marking queue, the queue doesn't need to be searched for tasks referring to\n+\/\/ states to allow releasing them.  Instead the queue contents can just be\n+\/\/ discarded, and the memory for the no longer referenced states will\n+\/\/ eventually be reclaimed when the arenas are reset.\n+\/\/\n+\/\/ A set of free-lists is placed in front of the arena allocators.  This\n+\/\/ causes the maximum number of allocated states to be based on the number of\n+\/\/ in-progress arrays, rather than the total number of arrays that need to be\n+\/\/ processed.  The use of free-list allocators is the reason for reference\n+\/\/ counting states.\n+\/\/\n+\/\/ The arena and free-list to use for an allocation operation is designated by\n+\/\/ the worker_id used in the operation.  This avoids locking and such on those\n+\/\/ data structures, at the cost of possibly doing more total arena allocation\n+\/\/ that would be needed with a single shared arena and free-list.\n+class PartialArrayStateAllocator : public CHeapObj<mtGC> {\n+  class Impl;\n+  Impl* _impl;\n+\n+public:\n+  PartialArrayStateAllocator(uint num_workers);\n+  ~PartialArrayStateAllocator();\n+\n+  NONCOPYABLE(PartialArrayStateAllocator);\n+\n+  \/\/ Create a new state, obtaining the memory for it from the free-list or\n+  \/\/ arena associated with worker_id.\n+  PartialArrayState* allocate(uint worker_id,\n+                              oop src, oop dst,\n+                              size_t index, size_t length,\n+                              size_t initial_refcount);\n+\n+  \/\/ Decrement the state's refcount.  If the new refcount is zero, add the\n+  \/\/ state to the free-list associated with worker_id.  The state must have\n+  \/\/ been allocated by this allocator, but that allocation doesn't need to\n+  \/\/ have been associated with worker_id.\n+  void release(uint worker_id, PartialArrayState* state);\n+};\n+\n+#endif \/\/ SHARE_GC_SHARED_PARTIALARRAYSTATE_HPP\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayState.hpp","additions":137,"deletions":0,"binary":false,"changes":137,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -51,1 +52,2 @@\n-PartialArrayTaskStepper::PartialArrayTaskStepper(uint n_workers) :\n+PartialArrayTaskStepper::PartialArrayTaskStepper(uint n_workers, size_t chunk_size) :\n+  _chunk_size(chunk_size),\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,3 @@\n-\/\/ Helper for handling PartialArrayTasks.\n+class PartialArrayState;\n+\n+\/\/ Helper for partial array chunking tasks.\n@@ -34,11 +36,4 @@\n-\/\/ processed in parallel.  Each task (implicitly) represents such a chunk.\n-\/\/ We can enqueue multiple tasks at the same time.  We want to enqueue\n-\/\/ enough tasks to benefit from the available parallelism, while not so many\n-\/\/ as to substantially expand the task queues.\n-\/\/\n-\/\/ A task directly refers to the from-space array.  The from-space array's\n-\/\/ forwarding pointer refers to the associated to-space array, and its\n-\/\/ length is the actual length. The to-space array's length field is used to\n-\/\/ indicate processing progress.  It is the starting index of the next chunk\n-\/\/ to process, or equals the actual length when there are no more chunks to\n-\/\/ be processed.\n+\/\/ processed in parallel.  Each task (implicitly) represents such a chunk.  We\n+\/\/ can enqueue multiple tasks at the same time.  We want to enqueue enough\n+\/\/ tasks to benefit from the available parallelism, while not so many as to\n+\/\/ substantially expand the task queues.\n@@ -47,1 +42,1 @@\n-  PartialArrayTaskStepper(uint n_workers);\n+  PartialArrayTaskStepper(uint n_workers, size_t chunk_size);\n@@ -50,1 +45,1 @@\n-    int _index;                 \/\/ Array index for the step.\n+    size_t _index;              \/\/ Array index for the step.\n@@ -54,5 +49,12 @@\n-  \/\/ Set to's length to the end of the initial chunk, which is the start of\n-  \/\/ the first partial task if the array is large enough to need splitting.\n-  \/\/ Returns a Step with _index being that index and _ncreate being the\n-  \/\/ initial number of partial tasks to enqueue.\n-  inline Step start(arrayOop from, arrayOop to, int chunk_size) const;\n+  \/\/ Called with the length of the array to be processed.  Returns a Step with\n+  \/\/ _index being the end of the initial chunk, which the caller should\n+  \/\/ process.  This is also the starting index for the next chunk to process.\n+  \/\/ The _ncreate is the number of tasks to enqueue to continue processing the\n+  \/\/ array.  If _ncreate is zero then _index will be length.\n+  inline Step start(size_t length) const;\n+\n+  \/\/ Atomically increment state's index by chunk_size() to claim the next\n+  \/\/ chunk.  Returns a Step with _index being the starting index of the\n+  \/\/ claimed chunk and _ncreate being the number of additional partial tasks\n+  \/\/ to enqueue.\n+  inline Step next(PartialArrayState* state) const;\n@@ -60,5 +62,2 @@\n-  \/\/ Increment to's length by chunk_size to claim the next chunk.  Returns a\n-  \/\/ Step with _index being the starting index of the claimed chunk and\n-  \/\/ _ncreate being the number of additional partial tasks to enqueue.\n-  \/\/ precondition: chunk_size must be the same as used to start the task sequence.\n-  inline Step next(arrayOop from, arrayOop to, int chunk_size) const;\n+  \/\/ The size of chunks to claim for each task.\n+  inline size_t chunk_size() const;\n@@ -69,0 +68,2 @@\n+  \/\/ Size (number of elements) of a chunk to process.\n+  size_t _chunk_size;\n@@ -74,6 +75,2 @@\n-  \/\/ Split start\/next into public part dealing with oops and private\n-  \/\/ impl dealing with lengths and pointers to lengths, for unit testing.\n-  \/\/ length is the actual length obtained from the from-space object.\n-  \/\/ to_length_addr is the address of the to-space object's length value.\n-  inline Step start_impl(int length, int* to_length_addr, int chunk_size) const;\n-  inline Step next_impl(int length, int* to_length_addr, int chunk_size) const;\n+  \/\/ For unit tests.\n+  inline Step next_impl(size_t length, volatile size_t* index_addr) const;\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.hpp","additions":28,"deletions":31,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,1 @@\n+#include \"gc\/shared\/partialArrayState.hpp\"\n@@ -29,2 +30,0 @@\n-\n-#include \"oops\/arrayOop.hpp\"\n@@ -32,0 +31,2 @@\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/debug.hpp\"\n@@ -33,17 +34,3 @@\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::start_impl(int length,\n-                                    int* to_length_addr,\n-                                    int chunk_size) const {\n-  assert(chunk_size > 0, \"precondition\");\n-\n-  int end = length % chunk_size; \/\/ End of initial chunk.\n-  \/\/ Set to's length to end of initial chunk.  Partial tasks use that length\n-  \/\/ field as the start of the next chunk to process.  Must be done before\n-  \/\/ enqueuing partial scan tasks, in case other threads steal any of those\n-  \/\/ tasks.\n-  \/\/\n-  \/\/ The value of end can be 0, either because of a 0-length array or\n-  \/\/ because length is a multiple of the chunk size.  Both of those are\n-  \/\/ relatively rare and handled in the normal course of the iteration, so\n-  \/\/ not worth doing anything special about here.\n-  *to_length_addr = end;\n+size_t PartialArrayTaskStepper::chunk_size() const {\n+  return _chunk_size;\n+}\n@@ -51,0 +38,3 @@\n+PartialArrayTaskStepper::Step\n+PartialArrayTaskStepper::start(size_t length) const {\n+  size_t end = length % _chunk_size; \/\/ End of initial chunk.\n@@ -54,2 +44,1 @@\n-  Step result = { end, (length > end) ? 1u : 0u };\n-  return result;\n+  return Step{ end, (length > end) ? 1u : 0u };\n@@ -59,11 +48,2 @@\n-PartialArrayTaskStepper::start(arrayOop from, arrayOop to, int chunk_size) const {\n-  return start_impl(from->length(), to->length_addr(), chunk_size);\n-}\n-\n-PartialArrayTaskStepper::Step\n-PartialArrayTaskStepper::next_impl(int length,\n-                                   int* to_length_addr,\n-                                   int chunk_size) const {\n-  assert(chunk_size > 0, \"precondition\");\n-\n-  \/\/ The start of the next task is in the length field of the to-space object.\n+PartialArrayTaskStepper::next_impl(size_t length, volatile size_t* index_addr) const {\n+  \/\/ The start of the next task is in the state's index.\n@@ -74,3 +54,3 @@\n-  int start = Atomic::fetch_then_add(to_length_addr,\n-                                     chunk_size,\n-                                     memory_order_relaxed);\n+  size_t start = Atomic::fetch_then_add(index_addr,\n+                                        _chunk_size,\n+                                        memory_order_relaxed);\n@@ -78,4 +58,4 @@\n-  assert(start < length, \"invariant: start %d, length %d\", start, length);\n-  assert(((length - start) % chunk_size) == 0,\n-         \"invariant: start %d, length %d, chunk size %d\",\n-         start, length, chunk_size);\n+  assert(start < length, \"invariant: start %zu, length %zu\", start, length);\n+  assert(((length - start) % _chunk_size) == 0,\n+         \"invariant: start %zu, length %zu, chunk size %zu\",\n+         start, length, _chunk_size);\n@@ -85,1 +65,1 @@\n-  uint task_num = (start \/ chunk_size);\n+  uint task_num = checked_cast<uint>(start \/ _chunk_size);\n@@ -87,1 +67,1 @@\n-  uint remaining_tasks = (length - start) \/ chunk_size;\n+  uint remaining_tasks = checked_cast<uint>((length - start) \/ _chunk_size);\n@@ -109,2 +89,1 @@\n-  Step result = { start, ncreate };\n-  return result;\n+  return Step{ start, ncreate };\n@@ -114,2 +93,2 @@\n-PartialArrayTaskStepper::next(arrayOop from, arrayOop to, int chunk_size) const {\n-  return next_impl(from->length(), to->length_addr(), chunk_size);\n+PartialArrayTaskStepper::next(PartialArrayState* state) const {\n+  return next_impl(state->length(), state->index_addr());\n","filename":"src\/hotspot\/share\/gc\/shared\/partialArrayTaskStepper.inline.hpp","additions":25,"deletions":46,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -576,5 +576,1 @@\n-\/\/ Wrapper over an oop that is a partially scanned array.\n-\/\/ Can be converted to a ScannerTask for placement in associated task queues.\n-\/\/ Refers to the partially copied source array oop.\n-class PartialArrayScanTask {\n-  oop _src;\n+class PartialArrayState;\n@@ -582,8 +578,1 @@\n-public:\n-  explicit PartialArrayScanTask(oop src_array) : _src(src_array) {}\n-  \/\/ Trivially copyable.\n-\n-  oop to_source_array() const { return _src; }\n-};\n-\n-\/\/ Discriminated union over oop*, narrowOop*, and PartialArrayScanTask.\n+\/\/ Discriminated union over oop*, narrowOop*, and PartialArrayState.\n@@ -627,2 +616,2 @@\n-  explicit ScannerTask(PartialArrayScanTask t) :\n-    _p(encode(t.to_source_array(), PartialArrayTag)) {}\n+  explicit ScannerTask(PartialArrayState* state) :\n+    _p(encode(state, PartialArrayTag)) {}\n@@ -642,1 +631,1 @@\n-  bool is_partial_array_task() const {\n+  bool is_partial_array_state() const {\n@@ -654,2 +643,2 @@\n-  PartialArrayScanTask to_partial_array_task() const {\n-    return PartialArrayScanTask(cast_to_oop(decode(PartialArrayTag)));\n+  PartialArrayState* to_partial_array_state() const {\n+    return static_cast<PartialArrayState*>(decode(PartialArrayTag));\n","filename":"src\/hotspot\/share\/gc\/shared\/taskqueue.hpp","additions":8,"deletions":19,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n-  if (!heap->is_in(loc)) return;\n+  if (!heap->is_in_reserved(loc)) return;\n@@ -80,1 +80,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -99,1 +99,1 @@\n-  if (heap->is_in(loc)) {\n+  if (heap->is_in_reserved(loc)) {\n@@ -116,1 +116,1 @@\n-  bool loc_in_heap = (loc != nullptr && heap->is_in(loc));\n+  bool loc_in_heap = (loc != nullptr && heap->is_in_reserved(loc));\n@@ -169,1 +169,1 @@\n-void ShenandoahAsserts::assert_in_heap(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds(void* interior_loc, oop obj, const char *file, int line) {\n@@ -172,3 +172,3 @@\n-  if (!heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap failed\",\n-                  \"oop must point to a heap address\",\n+  if (!heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds failed\",\n+                  \"oop must be in heap bounds\",\n@@ -179,1 +179,1 @@\n-void ShenandoahAsserts::assert_in_heap_or_null(void* interior_loc, oop obj, const char *file, int line) {\n+void ShenandoahAsserts::assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char *file, int line) {\n@@ -182,3 +182,3 @@\n-  if (obj != nullptr && !heap->is_in(obj)) {\n-    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_or_null failed\",\n-                  \"oop must point to a heap address\",\n+  if (obj != nullptr && !heap->is_in_reserved(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_heap_bounds_or_null failed\",\n+                  \"oop must be in heap bounds\",\n@@ -194,1 +194,1 @@\n-  if (!heap->is_in(obj)) {\n+  if (!heap->is_in_reserved(obj)) {\n@@ -196,1 +196,1 @@\n-                  \"oop must point to a heap address\",\n+                  \"oop must be in heap bounds\",\n@@ -213,0 +213,6 @@\n+  if (!heap->is_in(obj)) {\n+    print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                  \"Object should be in active region area\",\n+                  file, line);\n+  }\n+\n@@ -226,1 +232,1 @@\n-    if (!heap->is_in(fwd)) {\n+    if (!heap->is_in_reserved(fwd)) {\n@@ -228,1 +234,1 @@\n-                    \"Forwardee must point to a heap address\",\n+                    \"Forwardee must be in heap bounds\",\n@@ -239,0 +245,6 @@\n+    if (!heap->is_in(fwd)) {\n+      print_failure(_safe_oop, obj, interior_loc, nullptr, \"Shenandoah assert_correct failed\",\n+                    \"Forwardee should be in active region area\",\n+                    file, line);\n+    }\n+\n@@ -241,1 +253,1 @@\n-                    \"Non-trivial forwardee should in another region\",\n+                    \"Non-trivial forwardee should be in another region\",\n@@ -257,1 +269,1 @@\n-  if (java_lang_Class::is_instance(obj)) {\n+  if (Universe::is_fully_initialized() && (obj_klass == vmClasses::Class_klass())) {\n@@ -286,1 +298,3 @@\n-  if (alloc_size > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  HeapWord* obj_end = cast_from_oop<HeapWord*>(obj) + alloc_size;\n+\n+  if (ShenandoahHeapRegion::requires_humongous(alloc_size)) {\n@@ -288,2 +302,2 @@\n-    size_t num_regions = ShenandoahHeapRegion::required_regions(alloc_size * HeapWordSize);\n-    for (size_t i = idx; i < idx + num_regions; i++) {\n+    size_t end_idx = heap->heap_region_index_containing(obj_end - 1);\n+    for (size_t i = idx; i < end_idx; i++) {\n@@ -302,0 +316,6 @@\n+  } else {\n+    if (obj_end > r->top()) {\n+      print_failure(_safe_unknown, obj, interior_loc, nullptr, \"Shenandoah assert_in_correct_region failed\",\n+                    \"Object end should be within the active area of the region\",\n+                    file, line);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.cpp","additions":41,"deletions":21,"binary":false,"changes":62,"status":"modified"},{"patch":"@@ -56,2 +56,2 @@\n-  static void assert_in_heap(void* interior_loc, oop obj, const char* file, int line);\n-  static void assert_in_heap_or_null(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds(void* interior_loc, oop obj, const char* file, int line);\n+  static void assert_in_heap_bounds_or_null(void* interior_loc, oop obj, const char* file, int line);\n@@ -77,4 +77,4 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap(interior_loc, obj, __FILE__, __LINE__)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj) \\\n-                    ShenandoahAsserts::assert_in_heap_or_null(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds(interior_loc, obj, __FILE__, __LINE__)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj) \\\n+                    ShenandoahAsserts::assert_in_heap_bounds_or_null(interior_loc, obj, __FILE__, __LINE__)\n@@ -167,2 +167,2 @@\n-#define shenandoah_assert_in_heap(interior_loc, obj)\n-#define shenandoah_assert_in_heap_or_null(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds(interior_loc, obj)\n+#define shenandoah_assert_in_heap_bounds_or_null(interior_loc, obj)\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahAsserts.hpp","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  shenandoah_assert_in_heap_or_null(nullptr, p);\n+  shenandoah_assert_in_heap_bounds_or_null(nullptr, p);\n@@ -49,1 +49,1 @@\n-  assert(p == nullptr || _heap->is_in(p), \"Must be in the heap\");\n+  assert(p == nullptr || _heap->is_in_reserved(p), \"Must be in the heap\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahCollectionSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -616,6 +616,0 @@\n-      \/\/ Verify before arming for concurrent processing.\n-      \/\/ Otherwise, verification can trigger stack processing.\n-      if (ShenandoahVerify) {\n-        heap->verifier()->verify_during_evacuation();\n-      }\n-\n@@ -721,1 +715,1 @@\n-      shenandoah_assert_correct(p, obj);\n+      \/\/ Note: The obj is dead here. Do not touch it, just clear.\n@@ -826,1 +820,1 @@\n-    heap->rendezvous_threads();\n+    heap->rendezvous_threads(\"Shenandoah Concurrent Weak Roots\");\n@@ -924,1 +918,3 @@\n-  heap->set_update_refs_in_progress(true);\n+  if (ShenandoahVerify) {\n+    heap->verifier()->verify_before_updaterefs();\n+  }\n@@ -926,0 +922,1 @@\n+  heap->set_update_refs_in_progress(true);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentGC.cpp","additions":6,"deletions":9,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -182,1 +182,1 @@\n-    HandshakeClosure(\"Shenandoah Flush SATB Handshake\"),\n+    HandshakeClosure(\"Shenandoah Flush SATB\"),\n@@ -209,1 +209,4 @@\n-    Handshake::execute(&flush_satb);\n+    {\n+      ShenandoahTimingsTracker t(ShenandoahPhaseTimings::conc_mark_satb_flush, true);\n+      Handshake::execute(&flush_satb);\n+    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahConcurrentMark.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-  bool is_humongous = req.size() > ShenandoahHeapRegion::humongous_threshold_words();\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(req.size());\n@@ -83,1 +83,1 @@\n-  bool is_humongous = (words > ShenandoahHeapRegion::region_size_words());\n+  bool is_humongous = ShenandoahHeapRegion::requires_humongous(words);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahController.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -279,0 +279,4 @@\n+    if (ShenandoahVerify) {\n+      heap->verifier()->verify_before_evacuation();\n+    }\n+\n@@ -281,4 +285,0 @@\n-\n-    if(ShenandoahVerify) {\n-      heap->verifier()->verify_during_evacuation();\n-    }\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahDegeneratedGC.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-  shenandoah_assert_in_heap(nullptr, obj);\n+  shenandoah_assert_in_heap_bounds(nullptr, obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahForwarding.inline.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1311,1 +1311,1 @@\n-  if (req.size() > ShenandoahHeapRegion::humongous_threshold_words()) {\n+  if (ShenandoahHeapRegion::requires_humongous(req.size())) {\n@@ -1320,2 +1320,1 @@\n-        assert(false, \"Trying to allocate TLAB larger than the humongous threshold: \" SIZE_FORMAT \" > \" SIZE_FORMAT,\n-               req.size(), ShenandoahHeapRegion::humongous_threshold_words());\n+        assert(false, \"Trying to allocate TLAB in humongous region: \" SIZE_FORMAT, req.size());\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.cpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -280,1 +280,1 @@\n-  \/\/ Precondition: req.size() <= ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: !ShenandoahHeapRegion::requires_humongous(req.size())\n@@ -287,1 +287,1 @@\n-  \/\/ Precondition: req.size() > ShenandoahHeapRegion::humongous_threshold_words().\n+  \/\/ Precondition: ShenandoahHeapRegion::requires_humongous(req.size())\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahFreeSet.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -75,0 +75,1 @@\n+#include \"cds\/archiveHeapWriter.hpp\"\n@@ -286,8 +287,1 @@\n-#ifdef LINUX\n-  \/\/ In THP \"advise\" mode, we refrain from advising the system to use large pages\n-  \/\/ since we know these commits will be short lived, and there is no reason to trash\n-  \/\/ the THP area with this bitmap.\n-  if (UseTransparentHugePages) {\n-    aux_bitmap_page_size = os::vm_page_size();\n-  }\n-#endif\n+\n@@ -390,10 +384,0 @@\n-#ifdef LINUX\n-    \/\/ UseTransparentHugePages would madvise that backing memory can be coalesced into huge\n-    \/\/ pages. But, the kernel needs to know that every small page is used, in order to coalesce\n-    \/\/ them into huge one. Therefore, we need to pretouch with smaller pages.\n-    if (UseTransparentHugePages) {\n-      _pretouch_heap_page_size = (size_t)os::vm_page_size();\n-      _pretouch_bitmap_page_size = (size_t)os::vm_page_size();\n-    }\n-#endif\n-\n@@ -749,3 +733,12 @@\n-  HeapWord* heap_base = (HeapWord*) base();\n-  HeapWord* last_region_end = heap_base + ShenandoahHeapRegion::region_size_words() * num_regions();\n-  return p >= heap_base && p < last_region_end;\n+  if (is_in_reserved(p)) {\n+    if (is_full_gc_move_in_progress()) {\n+      \/\/ Full GC move is running, we do not have a consistent region\n+      \/\/ information yet. But we know the pointer is in heap.\n+      return true;\n+    }\n+    \/\/ Now check if we point to a live section in active region.\n+    ShenandoahHeapRegion* r = heap_region_containing(p);\n+    return (r->is_active() && p < r->top());\n+  } else {\n+    return false;\n+  }\n@@ -1747,1 +1740,1 @@\n-  inline ShenandoahRendezvousClosure() : HandshakeClosure(\"ShenandoahRendezvous\") {}\n+  inline ShenandoahRendezvousClosure(const char* name) : HandshakeClosure(name) {}\n@@ -1751,2 +1744,2 @@\n-void ShenandoahHeap::rendezvous_threads() {\n-  ShenandoahRendezvousClosure cl;\n+void ShenandoahHeap::rendezvous_threads(const char* name) {\n+  ShenandoahRendezvousClosure cl(name);\n@@ -2502,0 +2495,77 @@\n+\n+HeapWord* ShenandoahHeap::allocate_loaded_archive_space(size_t size) {\n+#if INCLUDE_CDS_JAVA_HEAP\n+  \/\/ CDS wants a continuous memory range to load a bunch of objects.\n+  \/\/ This effectively bypasses normal allocation paths, and requires\n+  \/\/ a bit of massaging to unbreak GC invariants.\n+\n+  ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared(size);\n+\n+  \/\/ Easy case: a single regular region, no further adjustments needed.\n+  if (!ShenandoahHeapRegion::requires_humongous(size)) {\n+    return allocate_memory(req);\n+  }\n+\n+  \/\/ Hard case: the requested size would cause a humongous allocation.\n+  \/\/ We need to make sure it looks like regular allocation to the rest of GC.\n+\n+  \/\/ CDS code would guarantee no objects straddle multiple regions, as long as\n+  \/\/ regions are as large as MIN_GC_REGION_ALIGNMENT. It is impractical at this\n+  \/\/ point to deal with case when Shenandoah runs with smaller regions.\n+  \/\/ TODO: This check can be dropped once MIN_GC_REGION_ALIGNMENT agrees more with Shenandoah.\n+  if (ShenandoahHeapRegion::region_size_bytes() < ArchiveHeapWriter::MIN_GC_REGION_ALIGNMENT) {\n+    return nullptr;\n+  }\n+\n+  HeapWord* mem = allocate_memory(req);\n+  size_t start_idx = heap_region_index_containing(mem);\n+  size_t num_regions = ShenandoahHeapRegion::required_regions(size * HeapWordSize);\n+\n+  \/\/ Flip humongous -> regular.\n+  {\n+    ShenandoahHeapLocker locker(lock(), false);\n+    for (size_t c = start_idx; c < start_idx + num_regions; c++) {\n+      get_region(c)->make_regular_bypass();\n+    }\n+  }\n+\n+  return mem;\n+#else\n+  assert(false, \"Archive heap loader should not be available, should not be here\");\n+  return nullptr;\n+#endif \/\/ INCLUDE_CDS_JAVA_HEAP\n+}\n+\n+void ShenandoahHeap::complete_loaded_archive_space(MemRegion archive_space) {\n+  \/\/ Nothing to do here, except checking that heap looks fine.\n+#ifdef ASSERT\n+  HeapWord* start = archive_space.start();\n+  HeapWord* end = archive_space.end();\n+\n+  \/\/ No unclaimed space between the objects.\n+  \/\/ Objects are properly allocated in correct regions.\n+  HeapWord* cur = start;\n+  while (cur < end) {\n+    oop oop = cast_to_oop(cur);\n+    shenandoah_assert_in_correct_region(nullptr, oop);\n+    cur += oop->size();\n+  }\n+\n+  \/\/ No unclaimed tail at the end of archive space.\n+  assert(cur == end,\n+         \"Archive space should be fully used: \" PTR_FORMAT \" \" PTR_FORMAT,\n+         p2i(cur), p2i(end));\n+\n+  \/\/ Region bounds are good.\n+  ShenandoahHeapRegion* begin_reg = heap_region_containing(start);\n+  ShenandoahHeapRegion* end_reg = heap_region_containing(end);\n+  assert(begin_reg->is_regular(), \"Must be\");\n+  assert(end_reg->is_regular(), \"Must be\");\n+  assert(begin_reg->bottom() == start,\n+         \"Must agree: archive-space-start: \" PTR_FORMAT \", begin-region-bottom: \" PTR_FORMAT,\n+         p2i(start), p2i(begin_reg->bottom()));\n+  assert(end_reg->top() == end,\n+         \"Must agree: archive-space-end: \" PTR_FORMAT \", end-region-top: \" PTR_FORMAT,\n+         p2i(end), p2i(end_reg->top()));\n+#endif\n+}\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":94,"deletions":24,"binary":false,"changes":118,"status":"modified"},{"patch":"@@ -403,1 +403,1 @@\n-  void rendezvous_threads();\n+  void rendezvous_threads(const char* name);\n@@ -496,0 +496,2 @@\n+  \/\/ Check the pointer is in active part of Java heap.\n+  \/\/ Use is_in_reserved to check if object is within heap bounds.\n@@ -542,0 +544,6 @@\n+\/\/ ---------- CDS archive support\n+\n+  bool can_load_archived_objects() const override { return UseCompressedOops; }\n+  HeapWord* allocate_loaded_archive_space(size_t size) override;\n+  void complete_loaded_archive_space(MemRegion archive_space) override;\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.hpp","additions":9,"deletions":1,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -54,2 +54,0 @@\n-size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;\n-size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;\n@@ -105,2 +103,4 @@\n-  assert (ShenandoahHeap::heap()->is_full_gc_in_progress() || ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n-          \"only for full or degen GC\");\n+  assert (!Universe::is_fully_initialized() ||\n+          ShenandoahHeap::heap()->is_full_gc_in_progress() ||\n+          ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),\n+          \"Only for STW GC or when Universe is initializing (CDS)\");\n@@ -601,9 +601,0 @@\n-  guarantee(HumongousThresholdWords == 0, \"we should only set it once\");\n-  HumongousThresholdWords = RegionSizeWords * ShenandoahHumongousThreshold \/ 100;\n-  HumongousThresholdWords = align_down(HumongousThresholdWords, MinObjAlignment);\n-  assert (HumongousThresholdWords <= RegionSizeWords, \"sanity\");\n-\n-  guarantee(HumongousThresholdBytes == 0, \"we should only set it once\");\n-  HumongousThresholdBytes = HumongousThresholdWords * HeapWordSize;\n-  assert (HumongousThresholdBytes <= RegionSizeBytes, \"sanity\");\n-\n@@ -611,2 +602,1 @@\n-  MaxTLABSizeWords = MIN2(RegionSizeWords, HumongousThresholdWords);\n-  MaxTLABSizeWords = align_down(MaxTLABSizeWords, MinObjAlignment);\n+  MaxTLABSizeWords = align_down(RegionSizeWords, MinObjAlignment);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.cpp","additions":5,"deletions":15,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -220,2 +220,0 @@\n-  static size_t HumongousThresholdBytes;\n-  static size_t HumongousThresholdWords;\n@@ -264,0 +262,4 @@\n+  inline static bool requires_humongous(size_t words) {\n+    return words > ShenandoahHeapRegion::RegionSizeWords;\n+  }\n+\n@@ -316,8 +318,0 @@\n-  inline static size_t humongous_threshold_bytes() {\n-    return ShenandoahHeapRegion::HumongousThresholdBytes;\n-  }\n-\n-  inline static size_t humongous_threshold_words() {\n-    return ShenandoahHeapRegion::HumongousThresholdWords;\n-  }\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeapRegion.hpp","additions":4,"deletions":10,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -46,1 +46,0 @@\n-  log_info(gc, init)(\"Humongous Object Threshold: \" EXACTFMT, EXACTFMTARGS(ShenandoahHeapRegion::humongous_threshold_bytes()));\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahInitLogger.cpp","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -125,1 +125,1 @@\n-  assert(ShenandoahHeap::heap()->is_in(addr),\n+  assert(ShenandoahHeap::heap()->is_in_reserved(addr),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkBitMap.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-  inline bool is_marked(oop) const;\n+  inline bool is_marked(oop obj) const;\n+  inline bool is_marked(HeapWord* raw_obj) const;\n@@ -68,0 +69,1 @@\n+  inline bool is_marked_strong(HeapWord* raw_obj) const;\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.hpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -41,1 +41,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked(cast_from_oop<HeapWord *>(obj));\n+  return is_marked(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked(raw_obj);\n@@ -45,1 +49,5 @@\n-  return allocated_after_mark_start(obj) || _mark_bit_map.is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+  return is_marked_strong(cast_from_oop<HeapWord*>(obj));\n+}\n+\n+inline bool ShenandoahMarkingContext::is_marked_strong(HeapWord* raw_obj) const {\n+  return allocated_after_mark_start(raw_obj) || _mark_bit_map.is_marked_strong(raw_obj);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahMarkingContext.inline.hpp","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -140,1 +140,5 @@\n-void ShenandoahPhaseTimings::set_cycle_data(Phase phase, double time) {\n+void ShenandoahPhaseTimings::set_cycle_data(Phase phase, double time, bool should_aggregate) {\n+  const double cycle_data = _cycle_data[phase];\n+  if (should_aggregate) {\n+    _cycle_data[phase] = (cycle_data == uninitialized()) ? time :  (cycle_data + time);\n+  } else {\n@@ -142,2 +146,1 @@\n-  double d = _cycle_data[phase];\n-  assert(d == uninitialized(), \"Should not be set yet: %s, current value: %lf\", phase_name(phase), d);\n+    assert(cycle_data == uninitialized(), \"Should not be set yet: %s, current value: %lf\", phase_name(phase), cycle_data);\n@@ -145,1 +148,2 @@\n-  _cycle_data[phase] = time;\n+    _cycle_data[phase] = time;\n+  }\n@@ -148,1 +152,1 @@\n-void ShenandoahPhaseTimings::record_phase_time(Phase phase, double time) {\n+void ShenandoahPhaseTimings::record_phase_time(Phase phase, double time, bool should_aggregate) {\n@@ -150,1 +154,1 @@\n-    set_cycle_data(phase, time);\n+    set_cycle_data(phase, time, should_aggregate);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.cpp","additions":10,"deletions":6,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -60,0 +60,1 @@\n+  f(conc_mark_satb_flush,                           \"  Flush SATB\")                    \\\n@@ -219,1 +220,1 @@\n-  void set_cycle_data(Phase phase, double time);\n+  void set_cycle_data(Phase phase, double time, bool should_aggregate = false);\n@@ -225,1 +226,1 @@\n-  void record_phase_time(Phase phase, double time);\n+  void record_phase_time(Phase phase, double time, bool should_aggregate = false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahPhaseTimings.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -86,0 +86,11 @@\n+inline oop reference_coop_decode_raw(narrowOop v) {\n+  return CompressedOops::is_null(v) ? nullptr : CompressedOops::decode_raw(v);\n+}\n+\n+inline oop reference_coop_decode_raw(oop v) {\n+  return v;\n+}\n+\n+\/\/ Raw referent, it can be dead. You cannot treat it as oop without additional safety\n+\/\/ checks, this is why it is HeapWord*. The decoding uses a special-case inlined\n+\/\/ CompressedOops::decode method that bypasses normal oop-ness checks.\n@@ -87,3 +98,3 @@\n-static oop reference_referent(oop reference) {\n-  T heap_oop = Atomic::load(reference_referent_addr<T>(reference));\n-  return CompressedOops::decode(heap_oop);\n+static HeapWord* reference_referent_raw(oop reference) {\n+  T raw_oop = Atomic::load(reference_referent_addr<T>(reference));\n+  return cast_from_oop<HeapWord*>(reference_coop_decode_raw(raw_oop));\n@@ -281,2 +292,2 @@\n-  const oop referent = reference_referent<T>(reference);\n-  if (referent == nullptr) {\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  if (raw_referent == nullptr) {\n@@ -292,1 +303,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked(raw_referent);\n@@ -294,1 +305,1 @@\n-    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(referent);\n+    return ShenandoahHeap::heap()->complete_marking_context()->is_marked_strong(raw_referent);\n@@ -306,1 +317,1 @@\n-    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent<T>(reference)), \"only make inactive final refs with alive referents\");\n+    assert(ShenandoahHeap::heap()->marking_context()->is_marked(reference_referent_raw<T>(reference)), \"only make inactive final refs with alive referents\");\n@@ -379,2 +390,2 @@\n-  oop referent = reference_referent<T>(reference);\n-  assert(referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(referent),\n+  HeapWord* raw_referent = reference_referent_raw<T>(reference);\n+  assert(raw_referent == nullptr || ShenandoahHeap::heap()->marking_context()->is_marked(raw_referent),\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahReferenceProcessor.cpp","additions":21,"deletions":10,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-    heap->rendezvous_threads();\n+    heap->rendezvous_threads(\"Shenandoah Class Unloading\");\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUnload.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -114,2 +114,2 @@\n-ShenandoahTimingsTracker::ShenandoahTimingsTracker(ShenandoahPhaseTimings::Phase phase) :\n-  _timings(ShenandoahHeap::heap()->phase_timings()), _phase(phase) {\n+ShenandoahTimingsTracker::ShenandoahTimingsTracker(ShenandoahPhaseTimings::Phase phase, bool should_aggregate) :\n+  _timings(ShenandoahHeap::heap()->phase_timings()), _phase(phase), _should_aggregate(should_aggregate) {\n@@ -124,1 +124,1 @@\n-  _timings->record_phase_time(_phase, os::elapsedTime() - _start);\n+  _timings->record_phase_time(_phase, os::elapsedTime() - _start, _should_aggregate);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -67,0 +67,1 @@\n+  const bool                            _should_aggregate;\n@@ -71,1 +72,1 @@\n-  ShenandoahTimingsTracker(ShenandoahPhaseTimings::Phase phase);\n+  ShenandoahTimingsTracker(ShenandoahPhaseTimings::Phase phase, bool should_aggregate = false);\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahUtils.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -54,7 +54,0 @@\n-class ShenandoahIgnoreReferenceDiscoverer : public ReferenceDiscoverer {\n-public:\n-  virtual bool discover_reference(oop obj, ReferenceType type) {\n-    return true;\n-  }\n-};\n-\n@@ -71,0 +64,1 @@\n+  ReferenceIterationMode _ref_mode;\n@@ -85,1 +79,7 @@\n-      set_ref_discoverer_internal(new ShenandoahIgnoreReferenceDiscoverer());\n+      \/\/ Unknown status for Reference.referent field. Do not touch it, it might be dead.\n+      \/\/ Normally, barriers would prevent us from seeing the dead referents, but verifier\n+      \/\/ runs with barriers disabled.\n+      _ref_mode = DO_FIELDS_EXCEPT_REFERENT;\n+    } else {\n+      \/\/ Otherwise do all fields.\n+      _ref_mode = DO_FIELDS;\n@@ -89,0 +89,4 @@\n+  ReferenceIterationMode reference_iteration_mode() override {\n+    return _ref_mode;\n+  }\n+\n@@ -122,2 +126,2 @@\n-    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in(obj),\n-              \"oop must be in heap\");\n+    check(ShenandoahAsserts::_safe_unknown, obj, _heap->is_in_reserved(obj),\n+              \"oop must be in heap bounds\");\n@@ -180,2 +184,2 @@\n-      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in(fwd),\n-             \"Forwardee must be in heap\");\n+      check(ShenandoahAsserts::_safe_oop, obj, _heap->is_in_reserved(fwd),\n+             \"Forwardee must be in heap bounds\");\n@@ -198,0 +202,3 @@\n+      check(ShenandoahAsserts::_safe_oop, obj, fwd_reg->is_active(),\n+            \"Forwardee should be in active region\");\n+\n@@ -218,1 +225,1 @@\n-    if (java_lang_Class::is_instance(obj)) {\n+    if (obj_klass == vmClasses::Class_klass()) {\n@@ -327,2 +334,2 @@\n-  virtual void do_oop(oop* p) { do_oop_work(p); }\n-  virtual void do_oop(narrowOop* p) { do_oop_work(p); }\n+  virtual void do_oop(oop* p) override { do_oop_work(p); }\n+  virtual void do_oop(narrowOop* p) override { do_oop_work(p); }\n@@ -657,8 +664,0 @@\n-      case _verify_gcstate_evacuation:\n-        enabled = true;\n-        expected = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::EVACUATION;\n-        if (!_heap->is_stw_gc_in_progress()) {\n-          \/\/ Only concurrent GC sets this.\n-          expected |= ShenandoahHeap::WEAK_ROOTS;\n-        }\n-        break;\n@@ -847,24 +846,0 @@\n-void ShenandoahVerifier::verify_during_evacuation() {\n-  verify_at_safepoint(\n-          \"During Evacuation\",\n-          _verify_forwarded_allow,    \/\/ some forwarded references are allowed\n-          _verify_marked_disable,     \/\/ walk only roots\n-          _verify_cset_disable,       \/\/ some cset references are not forwarded yet\n-          _verify_liveness_disable,   \/\/ liveness data might be already stale after pre-evacs\n-          _verify_regions_disable,    \/\/ trash regions not yet recycled\n-          _verify_gcstate_evacuation  \/\/ evacuation is in progress\n-  );\n-}\n-\n-void ShenandoahVerifier::verify_after_evacuation() {\n-  verify_at_safepoint(\n-          \"After Evacuation\",\n-          _verify_forwarded_allow,     \/\/ objects are still forwarded\n-          _verify_marked_complete,     \/\/ bitmaps might be stale, but alloc-after-mark should be well\n-          _verify_cset_forwarded,      \/\/ all cset refs are fully forwarded\n-          _verify_liveness_disable,    \/\/ no reliable liveness data anymore\n-          _verify_regions_notrash,     \/\/ trash regions have been recycled already\n-          _verify_gcstate_forwarded    \/\/ evacuation produced some forwarded objects\n-  );\n-}\n-\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.cpp","additions":22,"deletions":47,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -136,4 +136,1 @@\n-    _verify_gcstate_forwarded,\n-\n-    \/\/ Evacuation is in progress, some objects are forwarded\n-    _verify_gcstate_evacuation\n+    _verify_gcstate_forwarded\n@@ -178,2 +175,0 @@\n-  void verify_during_evacuation();\n-  void verify_after_evacuation();\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahVerifier.hpp","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -52,7 +52,0 @@\n-  product(intx, ShenandoahHumongousThreshold, 100, EXPERIMENTAL,            \\\n-          \"Humongous objects are allocated in separate regions. \"           \\\n-          \"This setting defines how large the object should be to be \"      \\\n-          \"deemed humongous. Value is in  percents of heap region size. \"   \\\n-          \"This also caps the maximum TLAB size.\")                          \\\n-          range(1, 100)                                                     \\\n-                                                                            \\\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoah_globals.hpp","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -330,1 +330,1 @@\n-    CodeBuffer cb(blob->content_begin(), (address)C->output()->scratch_locs_memory() - blob->content_begin());\n+    CodeBuffer cb(blob->content_begin(), checked_cast<CodeBuffer::csize_t>((address)C->output()->scratch_locs_memory() - blob->content_begin()));\n","filename":"src\/hotspot\/share\/gc\/z\/c2\/zBarrierSetC2.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,3 +96,1 @@\n-    check_oop_function = [](oopDesc* obj) {\n-      (void)to_zaddress(obj);\n-    };\n+    check_oop_function = &check_is_valid_zaddress;\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.cpp","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -336,2 +336,1 @@\n-inline zaddress to_zaddress(uintptr_t value) {\n-  const zaddress addr = zaddress(value);\n+inline void check_is_valid_zaddress(zaddress addr) {\n@@ -340,0 +339,13 @@\n+}\n+\n+inline void check_is_valid_zaddress(uintptr_t value) {\n+  check_is_valid_zaddress(zaddress(value));\n+}\n+\n+inline void check_is_valid_zaddress(oopDesc* o) {\n+  check_is_valid_zaddress(uintptr_t(o));\n+}\n+\n+inline zaddress to_zaddress(uintptr_t value) {\n+  const zaddress addr = zaddress(value);\n+  check_is_valid_zaddress(addr);\n@@ -347,1 +359,1 @@\n-inline oop to_oop(zaddress addr) {\n+inline void assert_is_oop_or_null(zaddress addr) {\n@@ -355,1 +367,10 @@\n-  return obj;\n+}\n+\n+inline void assert_is_oop(zaddress addr) {\n+  assert(!is_null(addr), \"Should not be null\");\n+  assert_is_oop_or_null(addr);\n+}\n+\n+inline oop to_oop(zaddress addr) {\n+  assert_is_oop_or_null(addr);\n+  return cast_to_oop(addr);\n@@ -381,1 +402,0 @@\n-\n","filename":"src\/hotspot\/share\/gc\/z\/zAddress.inline.hpp","additions":25,"deletions":5,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-    FLAG_SET_ERGO_IF_DEFAULT(MaxTenuringThreshold, ZTenuringThreshold);\n+    FLAG_SET_ERGO_IF_DEFAULT(MaxTenuringThreshold, (uint)ZTenuringThreshold);\n","filename":"src\/hotspot\/share\/gc\/z\/zArguments.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-  : ZArrayIteratorImpl<T, Parallel>(array->is_empty() ? nullptr : array->adr_at(0), array->length()) {}\n+  : ZArrayIteratorImpl<T, Parallel>(array->is_empty() ? nullptr : array->adr_at(0), (size_t)array->length()) {}\n","filename":"src\/hotspot\/share\/gc\/z\/zArray.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -294,1 +294,1 @@\n-    const uintptr_t base = (uintptr_t)referent_addr - java_lang_ref_Reference::referent_offset();\n+    const uintptr_t base = (uintptr_t)referent_addr - (size_t)java_lang_ref_Reference::referent_offset();\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -748,1 +748,1 @@\n-  assert(!ZVerifyOops || oopDesc::is_oop(to_oop(addr), false), \"must be oop\");\n+  assert_is_oop(addr);\n@@ -760,1 +760,1 @@\n-  assert(!ZVerifyOops || oopDesc::is_oop(to_oop(addr), false), \"must be oop\");\n+  assert_is_oop(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrier.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -433,1 +433,1 @@\n-  assert_is_valid(to_zaddress(src));\n+  check_is_valid_zaddress(src);\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSet.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  const uintptr_t new_color = *(int*)ZPointerStoreGoodMaskLowOrderBitsAddr;\n+  const uintptr_t new_color = *ZPointerStoreGoodMaskLowOrderBitsAddr;\n","filename":"src\/hotspot\/share\/gc\/z\/zBarrierSetNMethod.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  return os::processor_count();\n+  return (uint32_t)os::processor_count();\n","filename":"src\/hotspot\/share\/gc\/z\/zCPU.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-  return clamp<uint>(ceil(gc_workers), 1, ZYoungGCThreads);\n+  return clamp<uint>((uint)ceil(gc_workers), 1, ZYoungGCThreads);\n@@ -429,1 +429,1 @@\n-  const size_t used_threshold = soft_max_capacity * used_threshold_percent;\n+  const size_t used_threshold = (size_t)(soft_max_capacity * used_threshold_percent);\n@@ -500,1 +500,1 @@\n-  const int lookahead = stats._heap._total_collections - stats._old_stats._general._total_collections_at_start;\n+  const uint lookahead = stats._heap._total_collections - stats._old_stats._general._total_collections_at_start;\n@@ -506,1 +506,1 @@\n-  log_debug(gc, director)(\"Rule Major: Allocation Rate, ExtraYoungGCTime: %.3fs, OldGCTime: %.3fs, Lookahead: %d, ExtraYoungGCTimeForLookahead: %.3fs\",\n+  log_debug(gc, director)(\"Rule Major: Allocation Rate, ExtraYoungGCTime: %.3fs, OldGCTime: %.3fs, Lookahead: %u, ExtraYoungGCTimeForLookahead: %.3fs\",\n@@ -568,1 +568,1 @@\n-  const size_t used_increase_threshold = stats._heap._soft_max_heap_size * 0.10; \/\/ 10%\n+  const size_t used_increase_threshold = (size_t)(stats._heap._soft_max_heap_size * 0.10); \/\/ 10%\n","filename":"src\/hotspot\/share\/gc\/z\/zDirector.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -233,2 +233,2 @@\n-static bool should_clear_soft_references(GCCause::Cause cause) {\n-  \/\/ Clear soft references if implied by the GC cause\n+static bool should_clear_all_soft_references(GCCause::Cause cause) {\n+  \/\/ Clear all soft references if implied by the GC cause\n@@ -262,1 +262,1 @@\n-  \/\/ Clear soft references if threads are stalled waiting for an old collection\n+  \/\/ Clear all soft references if threads are stalled waiting for an old collection\n@@ -267,1 +267,1 @@\n-  \/\/ Don't clear\n+  \/\/ Don't clear all soft references\n@@ -305,5 +305,9 @@\n-  \/\/ It is important that when soft references are cleared, we also pre-clean the young\n-  \/\/ generation, as we might otherwise throw premature OOM. Therefore, all causes that\n-  \/\/ trigger soft ref cleaning must also trigger pre-cleaning of young gen. If allocations\n-  \/\/ stalled when checking for soft ref cleaning, then since we hold the driver locker all\n-  \/\/ the way until we check for young gen pre-cleaning, we can be certain that we should\n+  \/\/ We clear all soft references as a last-ditch effort to collect memory\n+  \/\/ before throwing an OOM. Therefore it is important that when the GC policy\n+  \/\/ is to clear all soft references, that we also pre-clean the young\n+  \/\/ generation, as we might otherwise throw premature OOM.\n+  \/\/\n+  \/\/ Therefore, all causes that trigger all soft ref clearing must also trigger\n+  \/\/ pre-cleaning of young gen. If allocations stalled when checking for all\n+  \/\/ soft ref clearing, then since we hold the driver locker all the way until\n+  \/\/ we check for young gen pre-cleaning, we can be certain that we should\n@@ -311,1 +315,1 @@\n-  assert(!should_clear_soft_references(cause), \"Clearing soft references without pre-cleaning young gen\");\n+  assert(!should_clear_all_soft_references(cause), \"Clearing all soft references without pre-cleaning young gen\");\n@@ -398,0 +402,4 @@\n+\n+    \/\/ Set up soft reference policy\n+    const bool clear_all = should_clear_all_soft_references(request.cause());\n+    ZGeneration::old()->set_soft_reference_policy(clear_all);\n@@ -447,2 +455,3 @@\n-static void handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_soft_refs);\n+static void handle_alloc_stalling_for_old() {\n+  const bool cleared_all = ZGeneration::old()->uses_clear_all_soft_reference_policy();\n+  ZHeap::heap()->handle_alloc_stalling_for_old(cleared_all);\n@@ -451,2 +460,2 @@\n-void ZDriverMajor::handle_alloc_stalls(bool cleared_soft_refs) const {\n-  handle_alloc_stalling_for_old(cleared_soft_refs);\n+void ZDriverMajor::handle_alloc_stalls() const {\n+  handle_alloc_stalling_for_old();\n@@ -467,4 +476,0 @@\n-    \/\/ Set up soft reference policy\n-    const bool clear_soft_refs = should_clear_soft_references(request.cause());\n-    ZGeneration::old()->set_soft_reference_policy(clear_soft_refs);\n-\n@@ -480,1 +485,1 @@\n-    handle_alloc_stalls(clear_soft_refs);\n+    handle_alloc_stalls();\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.cpp","additions":24,"deletions":19,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -115,1 +115,1 @@\n-  void handle_alloc_stalls(bool cleared_soft_refs) const;\n+  void handle_alloc_stalls() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zDriver.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-  return _end - _start;\n+  return (size_t)(_end - _start);\n","filename":"src\/hotspot\/share\/gc\/z\/zForwardingAllocator.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -302,1 +302,1 @@\n-ssize_t ZGeneration::freed() const {\n+size_t ZGeneration::freed() const {\n@@ -451,1 +451,1 @@\n-    ZStatSample(ZSamplerJavaThreads, Threads::number_of_threads());\n+    ZStatSample(ZSamplerJavaThreads, (uint64_t)Threads::number_of_threads());\n@@ -1289,0 +1289,4 @@\n+bool ZGenerationOld::uses_clear_all_soft_reference_policy() const {\n+  return _reference_processor.uses_clear_all_soft_reference_policy();\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.cpp","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -125,1 +125,1 @@\n-  ssize_t freed() const;\n+  size_t freed() const;\n@@ -312,0 +312,1 @@\n+  bool uses_clear_all_soft_reference_policy() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zGeneration.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -89,2 +89,2 @@\n-inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n-  _page_allocator.handle_alloc_stalling_for_old(cleared_soft_refs);\n+inline void ZHeap::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n+  _page_allocator.handle_alloc_stalling_for_old(cleared_all_soft_refs);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeap.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-    assert_is_valid(to_zaddress(o));\n+    check_is_valid_zaddress(o);\n@@ -207,1 +207,1 @@\n-      return HeapAccess<AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF>::oop_load_at(_base, _base->field_offset(p));\n+      return HeapAccess<AS_NO_KEEPALIVE | ON_UNKNOWN_OOP_REF>::oop_load_at(_base, (ptrdiff_t)_base->field_offset(p));\n@@ -450,1 +450,1 @@\n-  const int stride = MIN2<int>(length - start, ObjArrayMarkingStride);\n+  const int stride = MIN2<int>(length - start, (int)ObjArrayMarkingStride);\n","filename":"src\/hotspot\/share\/gc\/z\/zHeapIterator.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-  const size_t unclamped = MaxHeapSize * 0.03125;\n+  const size_t unclamped = (size_t)(MaxHeapSize * 0.03125);\n@@ -49,1 +49,1 @@\n-    ZPageSizeMediumShift        = log2i_exact(ZPageSizeMedium);\n+    ZPageSizeMediumShift        = (size_t)log2i_exact(ZPageSizeMedium);\n@@ -71,1 +71,1 @@\n-  return ceil(os::initial_active_processor_count() * cpu_share_in_percent \/ 100.0);\n+  return (uint)ceil(os::initial_active_processor_count() * cpu_share_in_percent \/ 100.0);\n@@ -75,1 +75,1 @@\n-  return (MaxHeapSize * (heap_share_in_percent \/ 100.0)) \/ ZPageSizeSmall;\n+  return (uint)(MaxHeapSize * (heap_share_in_percent \/ 100.0) \/ ZPageSizeSmall);\n@@ -104,1 +104,1 @@\n-  return MaxHeapSize * (ZFragmentationLimit \/ 100);\n+  return (size_t)(MaxHeapSize * (ZFragmentationLimit \/ 100));\n@@ -108,1 +108,1 @@\n-  return MaxHeapSize * (ZYoungCompactionLimit \/ 100);\n+  return (size_t)(MaxHeapSize * (ZYoungCompactionLimit \/ 100));\n","filename":"src\/hotspot\/share\/gc\/z\/zHeuristics.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    return (volatile int*)(align_up(_mem, ZCacheLineSize) + index * ZCacheLineSize);\n+    return (volatile int*)(align_up(_mem, ZCacheLineSize) + (size_t)index * ZCacheLineSize);\n@@ -139,1 +139,1 @@\n-    return sizeof(int) * claim_level_end_index(ClaimLevels);\n+    return sizeof(int) * (size_t)claim_level_end_index(ClaimLevels);\n","filename":"src\/hotspot\/share\/gc\/z\/zIndexDistributor.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-    _segment_shift(exact_log2(segment_size())) {}\n+    _segment_shift(log2i_exact(segment_size())) {}\n@@ -133,1 +133,1 @@\n-    _segment_shift = exact_log2(segment_size());\n+    _segment_shift = log2i_exact(segment_size());\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n-  size_t            _segment_shift;\n+  int               _segment_shift;\n","filename":"src\/hotspot\/share\/gc\/z\/zLiveMap.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -368,1 +368,1 @@\n-  assert_is_valid(to_zaddress(obj));\n+  check_is_valid_zaddress(obj);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n-  assert(!ZVerifyOops || oopDesc::is_oop(to_oop(addr)), \"Should be oop\");\n+  assert_is_oop(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zMark.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-  return ZMarkStripeShift + exact_log2(nstripes);\n+  return ZMarkStripeShift + (size_t)log2i_exact(nstripes);\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkCache.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -89,1 +89,1 @@\n-    index = spillover_worker_id * spillover_chunk;\n+    index = (size_t)(spillover_worker_id * spillover_chunk);\n","filename":"src\/hotspot\/share\/gc\/z\/zMarkStack.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n-    _start_ms = TimeHelper::counter_to_millis(now.value());\n+    _start_ms = (uint64_t)TimeHelper::counter_to_millis(now.value());\n@@ -50,1 +50,1 @@\n-    const uint64_t now_ms = TimeHelper::counter_to_millis(now.value());\n+    const uint64_t now_ms = (uint64_t)TimeHelper::counter_to_millis(now.value());\n@@ -52,1 +52,1 @@\n-    const int64_t timeout_ms = next_ms - now_ms;\n+    const int64_t timeout_ms = (int64_t)(next_ms - now_ms);\n@@ -60,1 +60,1 @@\n-        const uint64_t overslept = -timeout_ms;\n+        const uint64_t overslept = (uint64_t)-timeout_ms;\n","filename":"src\/hotspot\/share\/gc\/z\/zMetronome.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -305,2 +305,2 @@\n-  \/\/ color is stored at low order bits of int; implicit conversion to uintptr_t is fine\n-  return bs_nm->guard_value(nm);\n+  \/\/ color is stored at low order bits of int; conversion to uintptr_t is fine\n+  return (uintptr_t)bs_nm->guard_value(nm);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethod.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -147,3 +147,3 @@\n-  const size_t shrink_threshold = _size * 0.30;\n-  const size_t prune_threshold = _size * 0.65;\n-  const size_t grow_threshold = _size * 0.70;\n+  const size_t shrink_threshold = (size_t)(_size * 0.30);\n+  const size_t prune_threshold = (size_t)(_size * 0.65);\n+  const size_t grow_threshold = (size_t)(_size * 0.70);\n","filename":"src\/hotspot\/share\/gc\/z\/zNMethodTable.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -79,2 +79,2 @@\n-  const size_t base_offset_in_bytes = arrayOopDesc::base_offset_in_bytes(element_type);\n-  const size_t process_start_offset_in_bytes = align_up(base_offset_in_bytes, BytesPerWord);\n+  const size_t base_offset_in_bytes = (size_t)arrayOopDesc::base_offset_in_bytes(element_type);\n+  const size_t process_start_offset_in_bytes = align_up(base_offset_in_bytes, (size_t)BytesPerWord);\n","filename":"src\/hotspot\/share\/gc\/z\/zObjArrayAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -100,5 +100,0 @@\n-  case ZPageResetType::Splitting:\n-    \/\/ Page is on the way to be destroyed or reused, delay\n-    \/\/ clearing until the page is reset for Allocation.\n-    break;\n-\n@@ -191,0 +186,1 @@\n+  assert(vmem.end() == _virtual.start(), \"Should be consecutive\");\n@@ -193,3 +189,0 @@\n-  reset(_age, ZPageResetType::Splitting);\n-\n-  assert(vmem.end() == _virtual.start(), \"Should be consecutive\");\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.cpp","additions":1,"deletions":8,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -47,2 +47,0 @@\n-  \/\/ The page was split and needs to be reset\n-  Splitting,\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.hpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-    return ZObjectAlignmentSmallShift;\n+    return (size_t)ZObjectAlignmentSmallShift;\n@@ -89,1 +89,1 @@\n-    return ZObjectAlignmentMediumShift;\n+    return (size_t)ZObjectAlignmentMediumShift;\n@@ -92,1 +92,1 @@\n-    return ZObjectAlignmentLargeShift;\n+    return (size_t)ZObjectAlignmentLargeShift;\n@@ -103,1 +103,1 @@\n-    return ZObjectAlignmentSmall;\n+    return (size_t)ZObjectAlignmentSmall;\n@@ -106,1 +106,1 @@\n-    return ZObjectAlignmentMedium;\n+    return (size_t)ZObjectAlignmentMedium;\n@@ -109,1 +109,1 @@\n-    return ZObjectAlignmentLarge;\n+    return (size_t)ZObjectAlignmentLarge;\n@@ -314,1 +314,1 @@\n-  (void)to_oop(addr);\n+  assert_is_oop(addr);\n","filename":"src\/hotspot\/share\/gc\/z\/zPage.inline.hpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -988,1 +988,1 @@\n-void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_soft_refs) {\n+void ZPageAllocator::handle_alloc_stalling_for_old(bool cleared_all_soft_refs) {\n@@ -990,1 +990,1 @@\n-  if (cleared_soft_refs) {\n+  if (cleared_all_soft_refs) {\n","filename":"src\/hotspot\/share\/gc\/z\/zPageAllocator.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -311,1 +311,1 @@\n-  const uint64_t now = os::elapsedTime();\n+  const uint64_t now = (uint64_t)os::elapsedTime();\n@@ -332,1 +332,1 @@\n-  _last_commit = ceil(os::elapsedTime());\n+  _last_commit = (uint64_t)ceil(os::elapsedTime());\n","filename":"src\/hotspot\/share\/gc\/z\/zPageCache.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -72,1 +72,1 @@\n-    ZPage* const page = _table->at(index);\n+    ZPage* const page = _table->at(size_t(index));\n","filename":"src\/hotspot\/share\/gc\/z\/zPageTable.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -116,1 +116,1 @@\n-    _clear_all_soft_refs(false),\n+    _uses_clear_all_soft_reference_policy(false),\n@@ -124,1 +124,1 @@\n-void ZReferenceProcessor::set_soft_reference_policy(bool clear) {\n+void ZReferenceProcessor::set_soft_reference_policy(bool clear_all_soft_references) {\n@@ -128,1 +128,1 @@\n-  _clear_all_soft_refs = clear;\n+  _uses_clear_all_soft_reference_policy = clear_all_soft_references;\n@@ -130,1 +130,1 @@\n-  if (clear) {\n+  if (clear_all_soft_references) {\n@@ -139,0 +139,4 @@\n+bool ZReferenceProcessor::uses_clear_all_soft_reference_policy() const {\n+  return _uses_clear_all_soft_reference_policy;\n+}\n+\n@@ -146,1 +150,1 @@\n-    (void)to_zaddress(referent);\n+    check_is_valid_zaddress(referent);\n@@ -443,1 +447,1 @@\n-  if (_clear_all_soft_refs) {\n+  if (_uses_clear_all_soft_reference_policy) {\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-  bool                 _clear_all_soft_refs;\n+  bool                 _uses_clear_all_soft_reference_policy;\n@@ -72,1 +72,3 @@\n-  void set_soft_reference_policy(bool clear);\n+  void set_soft_reference_policy(bool clear_all_soft_references);\n+  bool uses_clear_all_soft_reference_policy() const;\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zReferenceProcessor.hpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -87,1 +87,1 @@\n-      _nforwardings(selector->selected_small()->length() + selector->selected_medium()->length()),\n+      _nforwardings((size_t)selector->selected_small()->length() + (size_t)selector->selected_medium()->length()),\n@@ -116,1 +116,1 @@\n-      install_small(forwarding, _medium->length() + page_index);\n+      install_small(forwarding, (size_t)_medium->length() + page_index);\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSet.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-    _page_fragmentation_limit(page_size * (fragmentation_limit \/ 100)),\n+    _page_fragmentation_limit((size_t)(page_size * (fragmentation_limit \/ 100))),\n@@ -75,1 +75,1 @@\n-  const size_t partition_size_shift = exact_log2(partition_size);\n+  const int partition_size_shift = log2i_exact(partition_size);\n@@ -138,1 +138,1 @@\n-    const int to = ceil((double)(from_live_bytes) \/ (double)(_page_size - _object_size_limit));\n+    const int to = (int)ceil(from_live_bytes \/ (double)(_page_size - _object_size_limit));\n","filename":"src\/hotspot\/share\/gc\/z\/zRelocationSetSelector.cpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,1 +128,1 @@\n-bool ZRemembered::scan_page(ZPage* page) const {\n+bool ZRemembered::scan_page_and_clear_remset(ZPage* page) const {\n@@ -154,0 +154,14 @@\n+  if (ZVerifyRemembered) {\n+    \/\/ Make sure self healing of pointers is ordered before clearing of\n+    \/\/ the previous bits so that ZVerify::after_scan can detect missing\n+    \/\/ remset entries accurately.\n+    OrderAccess::storestore();\n+  }\n+\n+  \/\/ If we have consumed the remset entries above we also clear them.\n+  \/\/ The exception is if the page is completely empty\/garbage, where we don't\n+  \/\/ want to race with an old collection modifying the remset as well.\n+  if (!can_trust_live_bits || page->is_marked()) {\n+    page->clear_remset_previous();\n+  }\n+\n@@ -503,10 +517,1 @@\n-          bool found_roots = _remembered->scan_page(page);\n-\n-          \/\/ ... and as a side-effect clear the previous entries\n-          if (ZVerifyRemembered) {\n-            \/\/ Make sure self healing of pointers is ordered before clearing of\n-            \/\/ the previous bits so that ZVerify::after_scan can detect missing\n-            \/\/ remset entries accurately.\n-            OrderAccess::storestore();\n-          }\n-          page->clear_remset_previous();\n+          bool found_roots = _remembered->scan_page_and_clear_remset(page);\n","filename":"src\/hotspot\/share\/gc\/z\/zRemembered.cpp","additions":16,"deletions":11,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -76,1 +76,1 @@\n-  bool scan_page(ZPage* page) const;\n+  bool scan_page_and_clear_remset(ZPage* page) const;\n","filename":"src\/hotspot\/share\/gc\/z\/zRemembered.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n-#include \"gc\/z\/zUtils.hpp\"\n+#include \"gc\/z\/zUtils.inline.hpp\"\n@@ -253,8 +253,8 @@\n-            TimeHelper::counter_to_millis(history.avg_10_seconds()),\n-            TimeHelper::counter_to_millis(history.max_10_seconds()),\n-            TimeHelper::counter_to_millis(history.avg_10_minutes()),\n-            TimeHelper::counter_to_millis(history.max_10_minutes()),\n-            TimeHelper::counter_to_millis(history.avg_10_hours()),\n-            TimeHelper::counter_to_millis(history.max_10_hours()),\n-            TimeHelper::counter_to_millis(history.avg_total()),\n-            TimeHelper::counter_to_millis(history.max_total()));\n+            TimeHelper::counter_to_millis((jlong)history.avg_10_seconds()),\n+            TimeHelper::counter_to_millis((jlong)history.max_10_seconds()),\n+            TimeHelper::counter_to_millis((jlong)history.avg_10_minutes()),\n+            TimeHelper::counter_to_millis((jlong)history.max_10_minutes()),\n+            TimeHelper::counter_to_millis((jlong)history.avg_10_hours()),\n+            TimeHelper::counter_to_millis((jlong)history.max_10_hours()),\n+            TimeHelper::counter_to_millis((jlong)history.avg_total()),\n+            TimeHelper::counter_to_millis((jlong)history.max_total()));\n@@ -367,1 +367,1 @@\n-  _base = ZUtils::alloc_aligned(ZCacheLineSize, size);\n+  _base = ZUtils::alloc_aligned_unfreeable(ZCacheLineSize, size);\n@@ -680,1 +680,1 @@\n-  ZStatSample(_sampler, duration.value());\n+  ZStatDurationSample(_sampler, duration);\n@@ -721,1 +721,1 @@\n-  ZStatSample(_sampler, duration.value());\n+  ZStatDurationSample(_sampler, duration);\n@@ -769,1 +769,1 @@\n-  ZStatSample(_sampler, duration.value());\n+  ZStatDurationSample(_sampler, duration);\n@@ -801,1 +801,1 @@\n-  ZStatSample(_sampler, duration.value());\n+  ZStatDurationSample(_sampler, duration);\n@@ -838,1 +838,1 @@\n-  ZStatSample(_sampler, duration.value());\n+  ZStatDurationSample(_sampler, duration);\n@@ -865,1 +865,1 @@\n-  ZStatSample(_sampler, duration.value());\n+  ZStatDurationSample(_sampler, duration);\n@@ -917,0 +917,4 @@\n+void ZStatDurationSample(const ZStatSampler& sampler, const Tickspan& duration) {\n+  ZStatSample(sampler, (uint64_t)duration.value());\n+}\n+\n@@ -1039,1 +1043,1 @@\n-  const uint64_t now = os::elapsedTime();\n+  const uint64_t now = (uint64_t)os::elapsedTime();\n@@ -1849,1 +1853,1 @@\n-  return _reclaimed_bytes.davg();\n+  return (size_t)_reclaimed_bytes.davg();\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.cpp","additions":23,"deletions":19,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -348,0 +348,1 @@\n+void ZStatDurationSample(const ZStatSampler& sampler, const Tickspan& duration);\n","filename":"src\/hotspot\/share\/gc\/z\/zStat.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-  for (int i = current(); i < (int)_buffer_length; ++i) {\n+  for (size_t i = current(); i < _buffer_length; ++i) {\n@@ -144,1 +144,1 @@\n-void ZStoreBarrierBuffer::on_new_phase_relocate(int i) {\n+void ZStoreBarrierBuffer::on_new_phase_relocate(size_t i) {\n@@ -163,1 +163,1 @@\n-void ZStoreBarrierBuffer::on_new_phase_remember(int i) {\n+void ZStoreBarrierBuffer::on_new_phase_remember(size_t i) {\n@@ -200,1 +200,1 @@\n-void ZStoreBarrierBuffer::on_new_phase_mark(int i) {\n+void ZStoreBarrierBuffer::on_new_phase_mark(size_t i) {\n@@ -232,1 +232,1 @@\n-  for (int i = current(); i < (int)_buffer_length; ++i) {\n+  for (size_t i = current(); i < _buffer_length; ++i) {\n@@ -262,2 +262,2 @@\n-  for (int i = current(); i < (int)_buffer_length; ++i) {\n-    st->print_cr(\" [%2d]: base: \" PTR_FORMAT \" p: \" PTR_FORMAT \" prev: \" PTR_FORMAT,\n+  for (size_t i = current(); i < _buffer_length; ++i) {\n+    st->print_cr(\" [%2zu]: base: \" PTR_FORMAT \" p: \" PTR_FORMAT \" prev: \" PTR_FORMAT,\n@@ -279,1 +279,1 @@\n-  for (int i = current(); i < (int)_buffer_length; ++i) {\n+  for (size_t i = current(); i < _buffer_length; ++i) {\n@@ -299,1 +299,1 @@\n-    for (int i = buffer->current(); i < (int)_buffer_length; ++i) {\n+    for (size_t i = buffer->current(); i < _buffer_length; ++i) {\n","filename":"src\/hotspot\/share\/gc\/z\/zStoreBarrierBuffer.cpp","additions":10,"deletions":10,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,3 +62,3 @@\n-  void on_new_phase_relocate(int i);\n-  void on_new_phase_remember(int i);\n-  void on_new_phase_mark(int i);\n+  void on_new_phase_relocate(size_t i);\n+  void on_new_phase_remember(size_t i);\n+  void on_new_phase_mark(size_t i);\n@@ -71,1 +71,1 @@\n-  intptr_t current() const;\n+  size_t current() const;\n","filename":"src\/hotspot\/share\/gc\/z\/zStoreBarrierBuffer.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,1 +33,1 @@\n-inline intptr_t ZStoreBarrierBuffer::current() const {\n+inline size_t ZStoreBarrierBuffer::current() const {\n","filename":"src\/hotspot\/share\/gc\/z\/zStoreBarrierBuffer.inline.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,1 +88,1 @@\n-  return align_up<size_t>(_page_allocator->max_capacity() * ZAsyncUnmappingLimit \/ 100.0, ZGranuleSize);\n+  return align_up((size_t)(_page_allocator->max_capacity() * ZAsyncUnmappingLimit \/ 100.0), ZGranuleSize);\n","filename":"src\/hotspot\/share\/gc\/z\/zUnmapper.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n-  static uintptr_t alloc_aligned(size_t alignment, size_t size);\n+  static uintptr_t alloc_aligned_unfreeable(size_t alignment, size_t size);\n","filename":"src\/hotspot\/share\/gc\/z\/zUtils.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,0 +31,1 @@\n+#include \"runtime\/os.hpp\"\n@@ -36,0 +37,12 @@\n+inline uintptr_t ZUtils::alloc_aligned_unfreeable(size_t alignment, size_t size) {\n+  const size_t padded_size = size + (alignment - 1);\n+  void* const addr = os::malloc(padded_size, mtGC);\n+  void* const aligned_addr = align_up(addr, alignment);\n+\n+  memset(aligned_addr, 0, size);\n+\n+  \/\/ Since free expects pointers returned by malloc, aligned_addr cannot be\n+  \/\/ freed since it is most likely not the same as addr after alignment.\n+  return (uintptr_t)aligned_addr;\n+}\n+\n","filename":"src\/hotspot\/share\/gc\/z\/zUtils.inline.hpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n-#include \"gc\/z\/zUtils.hpp\"\n+#include \"gc\/z\/zUtils.inline.hpp\"\n@@ -61,1 +61,1 @@\n-  _top = ZUtils::alloc_aligned(block_alignment, block_size);\n+  _top = ZUtils::alloc_aligned_unfreeable(block_alignment, block_size);\n","filename":"src\/hotspot\/share\/gc\/z\/zValue.inline.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -114,0 +114,10 @@\n+static void z_verify_oop_object(zaddress addr, zpointer o, void* p) {\n+  const oop obj = cast_to_oop(addr);\n+  guarantee(oopDesc::is_oop(obj), BAD_OOP_ARG(o, p));\n+}\n+\n+static void z_verify_root_oop_object(zaddress addr, void* p) {\n+  const oop obj = cast_to_oop(addr);\n+  guarantee(oopDesc::is_oop(obj), BAD_OOP_ARG(addr, p));\n+}\n+\n@@ -124,1 +134,1 @@\n-      guarantee(oopDesc::is_oop(to_oop(addr)), BAD_OOP_ARG(o, p));\n+      z_verify_oop_object(addr, o, p);\n@@ -146,1 +156,1 @@\n-      guarantee(oopDesc::is_oop(to_oop(ZPointer::uncolor(o))), BAD_OOP_ARG(o, p));\n+      z_verify_oop_object(ZPointer::uncolor(o), o, p);\n@@ -151,4 +161,0 @@\n-static void z_verify_root_oop_object(zaddress o, void* p) {\n-  guarantee(oopDesc::is_oop(to_oop(o)), BAD_OOP_ARG(o, p));\n-}\n-\n@@ -171,1 +177,1 @@\n-    guarantee(oopDesc::is_oop(to_oop(addr)), BAD_OOP_ARG(o, p));\n+    z_verify_oop_object(addr, o, p);\n@@ -214,1 +220,1 @@\n-      z_verify_root_oop_object(addr, p);\n+      z_verify_oop_object(addr, o, p);\n@@ -221,1 +227,1 @@\n-        z_verify_root_oop_object(addr, p);\n+        z_verify_oop_object(addr, o, p);\n@@ -586,1 +592,1 @@\n-    for (int i = buffer->current(); i < (int)ZStoreBarrierBuffer::_buffer_length; ++i) {\n+    for (size_t i = buffer->current(); i < ZStoreBarrierBuffer::_buffer_length; ++i) {\n","filename":"src\/hotspot\/share\/gc\/z\/zVerify.cpp","additions":17,"deletions":11,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -183,0 +183,3 @@\n+JNIEXPORT jboolean JNICALL\n+JVM_IsStaticallyLinked(void);\n+\n","filename":"src\/hotspot\/share\/include\/jvm.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -74,1 +74,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -728,1 +728,0 @@\n-  assert(LockingMode != LM_LIGHTWEIGHT, \"Should call monitorenter_obj() when using the new lightweight locking\");\n@@ -743,17 +742,0 @@\n-\/\/ NOTE: We provide a separate implementation for the new lightweight locking to workaround a limitation\n-\/\/ of registers in x86_32. This entry point accepts an oop instead of a BasicObjectLock*.\n-\/\/ The problem is that we would need to preserve the register that holds the BasicObjectLock,\n-\/\/ but we are using that register to hold the thread. We don't have enough registers to\n-\/\/ also keep the BasicObjectLock, but we don't really need it anyway, we only need\n-\/\/ the object. See also InterpreterMacroAssembler::lock_object().\n-\/\/ As soon as legacy stack-locking goes away we could remove the other monitorenter() entry\n-\/\/ point, and only use oop-accepting entries (same for monitorexit() below).\n-JRT_ENTRY_NO_ASYNC(void, InterpreterRuntime::monitorenter_obj(JavaThread* current, oopDesc* obj))\n-  assert(LockingMode == LM_LIGHTWEIGHT, \"Should call monitorenter() when not using the new lightweight locking\");\n-  Handle h_obj(current, cast_to_oop(obj));\n-  assert(Universe::heap()->is_in_or_null(h_obj()),\n-         \"must be null or an object\");\n-  ObjectSynchronizer::enter(h_obj, nullptr, current);\n-  return;\n-JRT_END\n-\n","filename":"src\/hotspot\/share\/interpreter\/interpreterRuntime.cpp","additions":1,"deletions":19,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -57,0 +58,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -64,0 +66,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -627,12 +630,16 @@\n-        \/\/ Traditional lightweight locking.\n-        markWord displaced = rcvr->mark().set_unlocked();\n-        mon->lock()->set_displaced_header(displaced);\n-        bool call_vm = (LockingMode == LM_MONITOR);\n-        bool inc_monitor_count = true;\n-        if (call_vm || rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n-          \/\/ Is it simple recursive case?\n-          if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-            mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-          } else {\n-            inc_monitor_count = false;\n-            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n+        bool success = false;\n+        if (LockingMode == LM_LEGACY) {\n+           \/\/ Traditional fast locking.\n+          markWord displaced = rcvr->mark().set_unlocked();\n+          mon->lock()->set_displaced_header(displaced);\n+          success = true;\n+          if (rcvr->cas_set_mark(markWord::from_pointer(mon), displaced) != displaced) {\n+            \/\/ Is it simple recursive case?\n+            if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+              mon->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+            } else {\n+              success = false;\n+            }\n+          }\n+          if (success) {\n+            THREAD->inc_held_monitor_count();\n@@ -641,2 +648,2 @@\n-        if (inc_monitor_count) {\n-          THREAD->inc_held_monitor_count();\n+        if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, mon), handle_exception);\n@@ -644,0 +651,1 @@\n+\n@@ -726,12 +734,16 @@\n-      \/\/ traditional lightweight locking\n-      markWord displaced = lockee->mark().set_unlocked();\n-      entry->lock()->set_displaced_header(displaced);\n-      bool call_vm = (LockingMode == LM_MONITOR);\n-      bool inc_monitor_count = true;\n-      if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-        \/\/ Is it simple recursive case?\n-        if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-          entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-        } else {\n-          inc_monitor_count = false;\n-          CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+      bool success = false;\n+      if (LockingMode == LM_LEGACY) {\n+        \/\/ Traditional fast locking.\n+        markWord displaced = lockee->mark().set_unlocked();\n+        entry->lock()->set_displaced_header(displaced);\n+        success = true;\n+        if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+          \/\/ Is it simple recursive case?\n+          if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+            entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+          } else {\n+            success = false;\n+          }\n+        }\n+        if (success) {\n+          THREAD->inc_held_monitor_count();\n@@ -740,2 +752,2 @@\n-      if (inc_monitor_count) {\n-        THREAD->inc_held_monitor_count();\n+      if (!success) {\n+        CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -743,0 +755,1 @@\n+\n@@ -1656,12 +1669,16 @@\n-          \/\/ traditional lightweight locking\n-          markWord displaced = lockee->mark().set_unlocked();\n-          entry->lock()->set_displaced_header(displaced);\n-          bool call_vm = (LockingMode == LM_MONITOR);\n-          bool inc_monitor_count = true;\n-          if (call_vm || lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n-            \/\/ Is it simple recursive case?\n-            if (!call_vm && THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n-              entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n-            } else {\n-              inc_monitor_count = false;\n-              CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            \/\/ Traditional fast locking.\n+            markWord displaced = lockee->mark().set_unlocked();\n+            entry->lock()->set_displaced_header(displaced);\n+            success = true;\n+            if (lockee->cas_set_mark(markWord::from_pointer(entry), displaced) != displaced) {\n+              \/\/ Is it simple recursive case?\n+              if (THREAD->is_lock_owned((address) displaced.clear_lock_bits().to_pointer())) {\n+                entry->lock()->set_displaced_header(markWord::from_pointer(nullptr));\n+              } else {\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->inc_held_monitor_count();\n@@ -1670,2 +1687,2 @@\n-          if (inc_monitor_count) {\n-            THREAD->inc_held_monitor_count();\n+          if (!success) {\n+            CALL_VM(InterpreterRuntime::monitorenter(THREAD, entry), handle_exception);\n@@ -1673,0 +1690,1 @@\n+\n@@ -1690,2 +1708,0 @@\n-            markWord header = lock->displaced_header();\n-            most_recent->set_obj(nullptr);\n@@ -1693,10 +1709,16 @@\n-            \/\/ If it isn't recursive we either must swap old header or call the runtime\n-            bool dec_monitor_count = true;\n-            bool call_vm = (LockingMode == LM_MONITOR);\n-            if (header.to_pointer() != nullptr || call_vm) {\n-              markWord old_header = markWord::encode(lock);\n-              if (call_vm || lockee->cas_set_mark(header, old_header) != old_header) {\n-                \/\/ restore object for the slow case\n-                most_recent->set_obj(lockee);\n-                dec_monitor_count = false;\n-                InterpreterRuntime::monitorexit(most_recent);\n+            bool success = false;\n+            if (LockingMode == LM_LEGACY) {\n+              \/\/ If it isn't recursive we either must swap old header or call the runtime\n+              most_recent->set_obj(nullptr);\n+              success = true;\n+              markWord header = lock->displaced_header();\n+              if (header.to_pointer() != nullptr) {\n+                markWord old_header = markWord::encode(lock);\n+                if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                  \/\/ restore object for the slow case\n+                  most_recent->set_obj(lockee);\n+                  success = false;\n+                }\n+              }\n+              if (success) {\n+                THREAD->dec_held_monitor_count();\n@@ -1705,2 +1727,2 @@\n-            if (dec_monitor_count) {\n-              THREAD->dec_held_monitor_count();\n+            if (!success) {\n+              InterpreterRuntime::monitorexit(most_recent);\n@@ -3128,12 +3150,18 @@\n-          markWord header = lock->displaced_header();\n-          end->set_obj(nullptr);\n-\n-          \/\/ If it isn't recursive we either must swap old header or call the runtime\n-          bool dec_monitor_count = true;\n-          if (header.to_pointer() != nullptr) {\n-            markWord old_header = markWord::encode(lock);\n-            if (lockee->cas_set_mark(header, old_header) != old_header) {\n-              \/\/ restore object for the slow case\n-              end->set_obj(lockee);\n-              dec_monitor_count = false;\n-              InterpreterRuntime::monitorexit(end);\n+\n+          bool success = false;\n+          if (LockingMode == LM_LEGACY) {\n+            markWord header = lock->displaced_header();\n+            end->set_obj(nullptr);\n+\n+            \/\/ If it isn't recursive we either must swap old header or call the runtime\n+            success = true;\n+            if (header.to_pointer() != nullptr) {\n+              markWord old_header = markWord::encode(lock);\n+              if (lockee->cas_set_mark(header, old_header) != old_header) {\n+                \/\/ restore object for the slow case\n+                end->set_obj(lockee);\n+                success = false;\n+              }\n+            }\n+            if (success) {\n+              THREAD->dec_held_monitor_count();\n@@ -3142,2 +3170,2 @@\n-          if (dec_monitor_count) {\n-            THREAD->dec_held_monitor_count();\n+          if (!success) {\n+            InterpreterRuntime::monitorexit(end);\n@@ -3191,1 +3219,1 @@\n-          } else if (LockingMode == LM_MONITOR) {\n+          } else if (LockingMode != LM_LEGACY) {\n","filename":"src\/hotspot\/share\/interpreter\/zero\/bytecodeInterpreter.cpp","additions":99,"deletions":71,"binary":false,"changes":170,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -295,1 +295,1 @@\n-    const size_t length = static_cast<size_t>(java_lang_String::utf8_length(string, value)) + 1;\n+    const size_t length = java_lang_String::utf8_length(string, value) + 1;\n@@ -298,1 +298,1 @@\n-    java_lang_String::as_utf8_string(string, value, str, static_cast<int>(length));\n+    java_lang_String::as_utf8_string(string, value, str, length);\n","filename":"src\/hotspot\/share\/jfr\/dcmd\/jfrDcmds.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -505,1 +505,1 @@\n-static char* allocate_string(bool c_heap, int length, Thread* thread) {\n+static char* allocate_string(bool c_heap, size_t length, Thread* thread) {\n@@ -514,1 +514,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJavaSupport.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -116,1 +116,1 @@\n-jboolean JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n+void JNICALL jfr_event_writer_flush(JNIEnv* env, jclass jvm, jobject writer, jint used_size, jint requested_size);\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrJniMethod.hpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -194,0 +194,4 @@\n+  if (!initialize(THREAD)) {\n+    log_error(jfr, system)(\"JfrUpcall could not be initialized.\");\n+    return false;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/jni\/jfrUpcalls.cpp","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n-* Copyright (c) 2016, 2022, Oracle and\/or its affiliates. All rights reserved.\n+* Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,1 +124,4 @@\n-  return name != nullptr ? java_lang_String::as_utf8_string(name, length) : nullptr;\n+  size_t utf8_len;\n+  const char* ret = name != nullptr ? java_lang_String::as_utf8_string(name, utf8_len) : nullptr;\n+  length = checked_cast<int>(utf8_len); \/\/ Thread names should be short\n+  return ret;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrThreadState.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -886,0 +886,9 @@\n+  if (is_initial_typeset_for_chunk()) {\n+    CldPtr bootloader = get_cld(Universe::boolArrayKlass());\n+    assert(bootloader != nullptr, \"invariant\");\n+    if (IS_NOT_SERIALIZED(bootloader)) {\n+      write__cld(_writer, bootloader);\n+      assert(IS_SERIALIZED(bootloader), \"invariant\");\n+      cldw.add(1);\n+    }\n+  }\n","filename":"src\/hotspot\/share\/jfr\/recorder\/checkpoint\/types\/jfrTypeSet.cpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -396,2 +396,1 @@\n-template <typename Instance, void(Instance::*func)()>\n-class JfrVMOperation : public VM_Operation {\n+class JfrSafepointClearVMOperation : public VM_Operation {\n@@ -399,1 +398,10 @@\n-  Instance& _instance;\n+  JfrRecorderService& _instance;\n+ public:\n+  JfrSafepointClearVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_clear(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointClear; }\n+};\n+\n+class JfrSafepointWriteVMOperation : public VM_Operation {\n+ private:\n+  JfrRecorderService& _instance;\n@@ -401,3 +409,3 @@\n-  JfrVMOperation(Instance& instance) : _instance(instance) {}\n-  void doit() { (_instance.*func)(); }\n-  VMOp_Type type() const { return VMOp_JFRCheckpoint; }\n+  JfrSafepointWriteVMOperation(JfrRecorderService& instance) : _instance(instance) {}\n+  void doit() { _instance.safepoint_write(); }\n+  VMOp_Type type() const { return VMOp_JFRSafepointWrite; }\n@@ -473,1 +481,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_clear> safepoint_task(*this);\n+  JfrSafepointClearVMOperation op(*this);\n@@ -475,1 +483,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n@@ -580,1 +588,1 @@\n-  JfrVMOperation<JfrRecorderService, &JfrRecorderService::safepoint_write> safepoint_task(*this);\n+  JfrSafepointWriteVMOperation op(*this);\n@@ -583,1 +591,1 @@\n-  VMThread::execute(&safepoint_task);\n+  VMThread::execute(&op);\n@@ -642,1 +650,1 @@\n-  total_elements += flush_storage(_storage, _chunkwriter);\n+  total_elements = flush_storage(_storage, _chunkwriter);\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.cpp","additions":19,"deletions":11,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+  friend class JfrSafepointClearVMOperation;\n+  friend class JfrSafepointWriteVMOperation;\n","filename":"src\/hotspot\/share\/jfr\/recorder\/service\/jfrRecorderService.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -139,1 +139,3 @@\n-  assert(h_array_list.not_null(), \"invariant\");\n+  if (h_array_list.is_null()) {\n+    return empty_java_util_arraylist;\n+  }\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrJdkJfrEvent.cpp","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,0 @@\n-#include \"classfile\/javaClasses.inline.hpp\"\n@@ -28,0 +27,1 @@\n+#include \"classfile\/javaClasses.hpp\"\n@@ -29,2 +29,1 @@\n-#include \"oops\/instanceKlass.hpp\"\n-#include \"oops\/oop.inline.hpp\"\n+#include \"oops\/klass.hpp\"\n@@ -203,1 +202,1 @@\n-  return mark((uintptr_t)sym->identity_hash(), sym, leakp);\n+  return mark(sym->identity_hash(), sym, leakp);\n@@ -239,35 +238,8 @@\n-* hidden classes symbol is the external name +\n-* the address of its InstanceKlass slash appended:\n-*   java.lang.invoke.LambdaForm$BMH\/22626602\n-*\n-* caller needs ResourceMark\n-*\/\n-\n-uintptr_t JfrSymbolTable::hidden_klass_name_hash(const InstanceKlass* ik) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  return (uintptr_t)mirror->identity_hash();\n-}\n-\n-static const char* create_hidden_klass_symbol(const InstanceKlass* ik, uintptr_t hash) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  assert(hash != 0, \"invariant\");\n-  char* hidden_symbol = nullptr;\n-  const oop mirror = ik->java_mirror_no_keepalive();\n-  assert(mirror != nullptr, \"invariant\");\n-  char hash_buf[40];\n-  os::snprintf_checked(hash_buf, sizeof(hash_buf), \"\/\" UINTX_FORMAT, hash);\n-  const size_t hash_len = strlen(hash_buf);\n-  const size_t result_len = ik->name()->utf8_length();\n-  hidden_symbol = NEW_RESOURCE_ARRAY(char, result_len + hash_len + 1);\n-  ik->name()->as_klass_external_name(hidden_symbol, (int)result_len + 1);\n-  assert(strlen(hidden_symbol) == result_len, \"invariant\");\n-  strcpy(hidden_symbol + result_len, hash_buf);\n-  assert(strlen(hidden_symbol) == result_len + hash_len, \"invariant\");\n-  return hidden_symbol;\n-}\n-\n-bool JfrSymbolTable::is_hidden_klass(const Klass* k) {\n+ * The hidden class symbol is the external name with the\n+ * address of its Klass slash appended.\n+ *\n+ * \"java.lang.invoke.LambdaForm$DMH\/0x0000000037144c00\"\n+ *\n+ * Caller needs ResourceMark.\n+ *\/\n+traceid JfrSymbolTable::mark_hidden_klass_name(const Klass* k, bool leakp) {\n@@ -275,9 +247,3 @@\n-  return k->is_instance_klass() && ((const InstanceKlass*)k)->is_hidden();\n-}\n-\n-traceid JfrSymbolTable::mark_hidden_klass_name(const InstanceKlass* ik, bool leakp) {\n-  assert(ik != nullptr, \"invariant\");\n-  assert(ik->is_hidden(), \"invariant\");\n-  const uintptr_t hash = hidden_klass_name_hash(ik);\n-  const char* const hidden_symbol = create_hidden_klass_symbol(ik, hash);\n-  return mark(hash, hidden_symbol, leakp);\n+  assert(k->is_hidden(), \"invariant\");\n+  const uintptr_t hash = k->name()->identity_hash();\n+  return mark(hash, k->external_name(), leakp);\n@@ -289,3 +255,2 @@\n-  if (is_hidden_klass(k)) {\n-    assert(k->is_instance_klass(), \"invariant\");\n-    symbol_id = mark_hidden_klass_name((const InstanceKlass*)k, leakp);\n+  if (k->is_hidden()) {\n+    symbol_id = mark_hidden_klass_name(k, leakp);\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.cpp","additions":17,"deletions":52,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,0 +103,1 @@\n+  traceid mark_hidden_klass_name(const Klass* k, bool leakp);\n@@ -109,4 +110,0 @@\n-  traceid mark_hidden_klass_name(const InstanceKlass* k, bool leakp);\n-  bool is_hidden_klass(const Klass* k);\n-  uintptr_t hidden_klass_name_hash(const InstanceKlass* ik);\n-\n","filename":"src\/hotspot\/share\/jfr\/support\/jfrSymbolTable.hpp","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -52,0 +53,1 @@\n+static int pin_offset = invalid_offset;\n@@ -101,0 +103,7 @@\n+\n+  const char pin_name[] = \"pinVirtualThread\";\n+  Symbol* const pin_sym = SymbolTable::new_symbol(valid_name);\n+  assert(pin_sym != nullptr, \"invariant\");\n+  assert(invalid_offset == pin_offset, \"invariant\");\n+  JfrJavaSupport::compute_field_offset(pin_offset, klass, pin_sym, vmSymbols::bool_signature());\n+  assert(pin_offset != invalid_offset, \"invariant\");\n@@ -222,0 +231,5 @@\n+static inline bool pin_virtual(const JavaThread* jt) {\n+  assert(jt != nullptr, \"invariant\");\n+  return JfrThreadLocal::is_vthread(jt) && VMContinuations;\n+}\n+\n@@ -228,1 +242,1 @@\n-  static const char signature[] = \"(JJJZZ)V\";\n+  static const char signature[] = \"(JJJZZZ)V\";\n@@ -237,0 +251,1 @@\n+  args.push_int(pin_virtual(THREAD) ? (jint)JNI_TRUE : (jint)JNI_FALSE);\n@@ -252,0 +267,1 @@\n+      writer->long_field_put(thread_id_offset, current_tid);\n@@ -254,1 +270,3 @@\n-      writer->long_field_put(thread_id_offset, current_tid);\n+      if (!excluded) {\n+        writer->bool_field_put(pin_offset, pin_virtual(jt));\n+      }\n","filename":"src\/hotspot\/share\/jfr\/writers\/jfrJavaEventWriter.cpp","additions":21,"deletions":3,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -552,2 +552,2 @@\n-    THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n-        err_msg(\"Expected interface type, got %s\", klass->external_name()));\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),\n+                   err_msg(\"Expected interface type, got %s\", klass->external_name()));\n@@ -592,1 +592,1 @@\n-    JVMCI_THROW_MSG_0(InternalError, err_msg(\"Primitive type %s should be handled in Java code\", str));\n+    JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Primitive type %s should be handled in Java code\", str));\n@@ -601,2 +601,2 @@\n-      THROW_MSG_0(vmSymbols::java_lang_Exception(),\n-                  err_msg(\"lookupTypeException: %s\", str));\n+      THROW_MSG_NULL(vmSymbols::java_lang_Exception(),\n+                     err_msg(\"lookupTypeException: %s\", str));\n@@ -620,1 +620,1 @@\n-        JVMCI_THROW_MSG_0(InternalError, err_msg(\"Illegal class loader value: %d\", accessing_klass_loader));\n+        JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Illegal class loader value: %d\", accessing_klass_loader));\n@@ -663,1 +663,1 @@\n-    BasicType type = JVMCIENV->typeCharToBasicType(type_char, JVMCI_CHECK_0);\n+    BasicType type = JVMCIENV->typeCharToBasicType(type_char, JVMCI_CHECK_NULL);\n@@ -713,2 +713,4 @@\n-    if (!THREAD->has_last_Java_frame()) {\n-        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor\"));\n+    \/\/ Ensure that current JNI handle scope is not the top-most JNIHandleBlock as handles\n+    \/\/ in that scope are only released when the thread exits.\n+    if (!THREAD->has_last_Java_frame() && THREAD->active_handles()->pop_frame_link() == nullptr) {\n+        JVMCI_THROW_MSG_0(IllegalStateException, err_msg(\"Cannot call getJObjectValue without Java frame anchor or a pushed JNI handle block\"));\n@@ -815,1 +817,1 @@\n-    JVMCI_THROW_MSG_0(IllegalArgumentException, err_msg(\"Unexpected constant pool tag at index %d: %d\", index, tag.value()));\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, err_msg(\"Unexpected constant pool tag at index %d: %d\", index, tag.value()));\n@@ -1972,1 +1974,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -1976,1 +1978,1 @@\n-    JVMCI_THROW_MSG_0(InternalError, err_msg(\"Class %s must be instance klass\", klass->external_name()));\n+    JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Class %s must be instance klass\", klass->external_name()));\n@@ -1996,1 +1998,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2005,2 +2007,2 @@\n-    JVMCI_THROW_MSG_0(NullPointerException,\n-                    err_msg(\"Component mirror for array class %s is null\", klass->external_name()))\n+    JVMCI_THROW_MSG_NULL(NullPointerException,\n+                         err_msg(\"Component mirror for array class %s is null\", klass->external_name()))\n@@ -2109,1 +2111,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2123,1 +2125,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2168,1 +2170,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2195,1 +2197,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2222,1 +2224,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2349,1 +2351,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2399,1 +2401,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2419,1 +2421,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2438,1 +2440,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2460,1 +2462,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2546,1 +2548,1 @@\n-      JVMCI_THROW_MSG_0(InternalError, err_msg(\"Error initializing JVMCI runtime %d\", runtime->id()));\n+      JVMCI_THROW_MSG_NULL(InternalError, err_msg(\"Error initializing JVMCI runtime %d\", runtime->id()));\n@@ -2551,1 +2553,1 @@\n-    JVMCI_THROW_0(NullPointerException);\n+    JVMCI_THROW_NULL(NullPointerException);\n@@ -2555,1 +2557,1 @@\n-    JVMCI_THROW_MSG_0(IllegalArgumentException, \"clazz is for primitive type\");\n+    JVMCI_THROW_MSG_NULL(IllegalArgumentException, \"clazz is for primitive type\");\n@@ -2590,1 +2592,1 @@\n-          JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(\"%s [neither %s nor %s exist in %s]\",\n+          JVMCI_THROW_MSG_NULL(UnsatisfiedLinkError, err_msg(\"%s [neither %s nor %s exist in %s]\",\n@@ -2597,1 +2599,1 @@\n-        JVMCI_THROW_MSG_0(UnsatisfiedLinkError, err_msg(\"%s [cannot re-link from \" PTR_FORMAT \" to \" PTR_FORMAT \"]\",\n+        JVMCI_THROW_MSG_NULL(UnsatisfiedLinkError, err_msg(\"%s [cannot re-link from \" PTR_FORMAT \" to \" PTR_FORMAT \"]\",\n@@ -2608,1 +2610,1 @@\n-  typeArrayOop info_oop = oopFactory::new_longArray(4, CHECK_0);\n+  typeArrayOop info_oop = oopFactory::new_longArray(4, CHECK_NULL);\n@@ -2610,1 +2612,1 @@\n-  runtime->init_JavaVM_info(info, JVMCI_CHECK_0);\n+  runtime->init_JavaVM_info(info, JVMCI_CHECK_NULL);\n@@ -3157,2 +3159,2 @@\n-  THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),\n-              err_msg(\"%d is not a valid thread local id\", id));\n+  THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),\n+                 err_msg(\"%d is not a valid thread local id\", id));\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.cpp","additions":36,"deletions":34,"binary":false,"changes":70,"status":"modified"},{"patch":"@@ -53,0 +53,1 @@\n+    static address SharedRuntime_throw_delayed_StackOverflowError_entry;\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVM.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -71,0 +71,1 @@\n+address CompilerToVM::Data::SharedRuntime_throw_delayed_StackOverflowError_entry;\n@@ -161,0 +162,1 @@\n+  SharedRuntime_throw_delayed_StackOverflowError_entry = SharedRuntime::throw_delayed_StackOverflowError_entry();\n","filename":"src\/hotspot\/share\/jvmci\/jvmciCompilerToVMInit.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/continuationEntry.hpp\"\n@@ -71,0 +72,2 @@\n+  static_field(CompilerToVM::Data,             SharedRuntime_throw_delayed_StackOverflowError_entry,                                 \\\n+                                                                                       address)                                      \\\n@@ -154,1 +157,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                      markWord)                                     \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                              uintptr_t)                                    \\\n@@ -244,0 +247,2 @@\n+  nonstatic_field(JavaThread,                  _om_cache,                                     OMCache)                               \\\n+  nonstatic_field(JavaThread,                  _cont_entry,                                   ContinuationEntry*)                    \\\n@@ -248,0 +253,1 @@\n+  nonstatic_field(ContinuationEntry,           _pin_count,                                    uint32_t)                              \\\n@@ -271,0 +277,1 @@\n+  nonstatic_field(Klass,                       _misc_flags._flags,                            u1)                                    \\\n@@ -330,2 +337,0 @@\n-  static_field(StubRoutines,                _throw_delayed_StackOverflowError_entry,          address)                               \\\n-                                                                                                                                     \\\n@@ -481,4 +486,0 @@\n-  declare_constant(JVM_ACC_HAS_FINALIZER)                                 \\\n-  declare_constant(JVM_ACC_IS_CLONEABLE_FAST)                             \\\n-  declare_constant(JVM_ACC_IS_HIDDEN_CLASS)                               \\\n-  declare_constant(JVM_ACC_IS_VALUE_BASED_CLASS)                          \\\n@@ -534,0 +535,2 @@\n+  declare_constant_with_value(\"OMCache::oop_to_oop_difference\", OMCache::oop_to_oop_difference()) \\\n+  declare_constant_with_value(\"OMCache::oop_to_monitor_difference\", OMCache::oop_to_monitor_difference()) \\\n@@ -730,0 +733,4 @@\n+  declare_constant(KlassFlags::_misc_is_hidden_class)                     \\\n+  declare_constant(KlassFlags::_misc_is_value_based_class)                \\\n+  declare_constant(KlassFlags::_misc_has_finalizer)                       \\\n+  declare_constant(KlassFlags::_misc_is_cloneable_fast)                   \\\n","filename":"src\/hotspot\/share\/jvmci\/vmStructs_jvmci.cpp","additions":14,"deletions":7,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -133,0 +133,1 @@\n+  LOG_TAG(monitortable) \\\n","filename":"src\/hotspot\/share\/logging\/logTag.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -133,1 +133,1 @@\n-void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size, bool is_class) {\n+void ClassLoaderMetaspace::deallocate(MetaWord* ptr, size_t word_size) {\n@@ -135,1 +135,2 @@\n-  if (Metaspace::using_class_space() && is_class) {\n+  const bool is_class = Metaspace::using_class_space() && Metaspace::is_in_class_space(ptr);\n+  if (is_class) {\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.cpp","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -95,1 +95,1 @@\n-  void deallocate(MetaWord* ptr, size_t word_size, bool is_class);\n+  void deallocate(MetaWord* ptr, size_t word_size);\n","filename":"src\/hotspot\/share\/memory\/classLoaderMetaspace.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size, false);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)data, size);\n@@ -71,1 +71,0 @@\n-      bool is_klass = md->is_klass();\n@@ -79,1 +78,1 @@\n-      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size, is_klass);\n+      loader_data->metaspace_non_null()->deallocate((MetaWord*)md, size);\n","filename":"src\/hotspot\/share\/memory\/metadataFactory.hpp","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -541,0 +541,2 @@\n+const void* Metaspace::_class_space_start = nullptr;\n+const void* Metaspace::_class_space_end = nullptr;\n@@ -573,0 +575,2 @@\n+  _class_space_start = rs.base();\n+  _class_space_end = rs.end();\n@@ -896,9 +900,11 @@\n-  Log(gc, metaspace, freelist, oom) log;\n-  if (log.is_info()) {\n-    log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n-             is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n-    ResourceMark rm;\n-    if (log.is_debug()) {\n-      if (loader_data->metaspace_or_null() != nullptr) {\n-        LogStream ls(log.debug());\n-        loader_data->print_value_on(&ls);\n+  {\n+    LogMessage(gc, metaspace, freelist, oom) log;\n+    if (log.is_info()) {\n+      log.info(\"Metaspace (%s) allocation failed for size \" SIZE_FORMAT,\n+               is_class_space_allocation(mdtype) ? \"class\" : \"data\", word_size);\n+      ResourceMark rm;\n+      if (log.is_debug()) {\n+        if (loader_data->metaspace_or_null() != nullptr) {\n+          NonInterleavingLogStream ls(LogLevelType::Debug, log);\n+          loader_data->print_value_on(&ls);\n+        }\n@@ -906,0 +912,3 @@\n+      NonInterleavingLogStream ls(LogLevelType::Info, log);\n+      \/\/ In case of an OOM, log out a short but still useful report.\n+      MetaspaceUtils::print_basic_report(&ls, 0);\n@@ -907,3 +916,0 @@\n-    LogStream ls(log.info());\n-    \/\/ In case of an OOM, log out a short but still useful report.\n-    MetaspaceUtils::print_basic_report(&ls, 0);\n@@ -980,6 +986,0 @@\n-bool Metaspace::contains(const void* ptr) {\n-  if (MetaspaceShared::is_in_shared_metaspace(ptr)) {\n-    return true;\n-  }\n-  return contains_non_shared(ptr);\n-}\n@@ -987,4 +987,5 @@\n-bool Metaspace::contains_non_shared(const void* ptr) {\n-  if (using_class_space() && VirtualSpaceList::vslist_class()->contains((MetaWord*)ptr)) {\n-     return true;\n-  }\n+\/\/ Returns true if pointer points into one of the metaspace regions, or\n+\/\/ into the class space.\n+bool Metaspace::is_in_shared_metaspace(const void* ptr) {\n+  return MetaspaceShared::is_in_shared_metaspace(ptr);\n+}\n@@ -992,0 +993,2 @@\n+\/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+bool Metaspace::is_in_nonclass_metaspace(const void* ptr) {\n@@ -994,0 +997,1 @@\n+\n","filename":"src\/hotspot\/share\/memory\/metaspace.cpp","additions":26,"deletions":22,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,0 +67,4 @@\n+  \/\/ For quick pointer testing: extent of class space; nullptr if no class space.\n+  static const void* _class_space_start;\n+  static const void* _class_space_end;\n+\n@@ -116,2 +120,26 @@\n-  static bool contains(const void* ptr);\n-  static bool contains_non_shared(const void* ptr);\n+  \/\/ Returns true if the pointer points into class space, non-class metaspace, or the\n+  \/\/ metadata portion of the CDS archive.\n+  static bool contains(const void* ptr) {\n+    return is_in_shared_metaspace(ptr) || \/\/ in cds\n+           is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if the pointer points into class space or into non-class metaspace\n+  static bool contains_non_shared(const void* ptr) {\n+    return is_in_class_space(ptr) ||      \/\/ in class space\n+           is_in_nonclass_metaspace(ptr); \/\/ in one of the non-class regions?\n+  }\n+\n+  \/\/ Returns true if pointer points into the CDS klass region.\n+  static bool is_in_shared_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into one of the non-class-space metaspace regions.\n+  static bool is_in_nonclass_metaspace(const void* ptr);\n+\n+  \/\/ Returns true if pointer points into class space, false if it doesn't or if\n+  \/\/ there is no class space. Class space is a contiguous region, which is why\n+  \/\/ two address comparisons are enough.\n+  static inline bool is_in_class_space(const void* ptr) {\n+    return ptr < _class_space_end && ptr >= _class_space_start;\n+  }\n","filename":"src\/hotspot\/share\/memory\/metaspace.hpp","additions":31,"deletions":3,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -181,2 +181,0 @@\n-\n-  #undef assrt0n\n","filename":"src\/hotspot\/share\/memory\/metaspace\/blockTree.cpp","additions":0,"deletions":2,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize);\n+  assert_is_aligned((p), metaspace::AllocationAlignmentByteSize)\n@@ -144,2 +144,2 @@\n-#define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS);\n-#define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__);\n+#define UL(level, message)        log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS)\n+#define UL2(level, message, ...)  log_##level(metaspace)(LOGFMT \": \" message, LOGFMT_ARGS, __VA_ARGS__)\n","filename":"src\/hotspot\/share\/memory\/metaspace\/metaspaceCommon.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include <limits>\n@@ -44,8 +45,1 @@\n-  struct StackIndex {\n-    friend NativeCallStackStorage;\n-    int32_t _stack_index;\n-  public:\n-    static constexpr const int32_t invalid = -1;\n-    static bool equals(const StackIndex& a, const StackIndex& b) {\n-      return a._stack_index == b._stack_index;\n-    }\n+  using StackIndex = int;\n@@ -53,4 +47,11 @@\n-    bool is_invalid() {\n-      return _stack_index == invalid;\n-    }\n-  };\n+private:\n+  constexpr static const StackIndex invalid = std::numeric_limits<StackIndex>::max() - 1;\n+\n+public:\n+  static bool equals(const StackIndex a, const StackIndex b) {\n+    return a == b;\n+  }\n+\n+  static bool is_invalid(StackIndex a) {\n+    return a == invalid;\n+  }\n@@ -86,1 +87,1 @@\n-      return StackIndex{StackIndex::invalid};\n+      return invalid;\n@@ -92,1 +93,1 @@\n-    if (si._stack_index == -1) {\n+    if (is_invalid(si)) {\n@@ -95,1 +96,1 @@\n-    return _stacks.at(si._stack_index);\n+    return _stacks.at(si);\n","filename":"src\/hotspot\/share\/nmt\/nmtNativeCallStackStorage.hpp","additions":16,"deletions":15,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -81,1 +81,1 @@\n-             NativeCallStackStorage::StackIndex::equals(a.stack_idx, b.stack_idx);\n+             NativeCallStackStorage::equals(a.stack_idx, b.stack_idx);\n@@ -115,1 +115,1 @@\n-    const NativeCallStackStorage::StackIndex stack() const {\n+    NativeCallStackStorage::StackIndex stack() const {\n","filename":"src\/hotspot\/share\/nmt\/vmatree.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    size_t hs = length_offset_in_bytes() + sizeof(int);\n+    int hs = length_offset_in_bytes() + (int)sizeof(int);\n@@ -74,1 +74,1 @@\n-    static size_t arrayoopdesc_hs = 0;\n+    static int arrayoopdesc_hs = 0;\n@@ -86,1 +86,1 @@\n-                               sizeof(arrayOopDesc);\n+                               (int)sizeof(arrayOopDesc);\n@@ -91,2 +91,2 @@\n-    size_t hs = header_size_in_bytes();\n-    return (int)(element_type_should_be_aligned(type) ? align_up(hs, BytesPerLong) : hs);\n+    int hs = header_size_in_bytes();\n+    return element_type_should_be_aligned(type) ? align_up(hs, BytesPerLong) : hs;\n@@ -137,1 +137,1 @@\n-    size_t hdr_size_in_bytes = base_offset_in_bytes(type);\n+    int hdr_size_in_bytes = base_offset_in_bytes(type);\n@@ -139,1 +139,1 @@\n-    size_t hdr_size_in_words = align_up(hdr_size_in_bytes, HeapWordSize) \/ HeapWordSize;\n+    int hdr_size_in_words = align_up(hdr_size_in_bytes, HeapWordSize) \/ HeapWordSize;\n@@ -142,1 +142,1 @@\n-      align_down((SIZE_MAX\/HeapWordSize - hdr_size_in_words), MinObjAlignment);\n+      align_down((SIZE_MAX\/HeapWordSize - (size_t)hdr_size_in_words), MinObjAlignment);\n@@ -144,1 +144,1 @@\n-      HeapWordSize * max_element_words_per_size_t \/ type2aelembytes(type);\n+      HeapWordSize * max_element_words_per_size_t \/ (size_t)type2aelembytes(type);\n","filename":"src\/hotspot\/share\/oops\/arrayOop.hpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,3 +439,0 @@\n-        assert(!fellThrough, \"should not happen\");\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n-        break;\n@@ -444,1 +441,4 @@\n-        bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        \/\/ If this is the last bytecode, there is no successor to mark\n+        if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+          bb_mark_fct(this, bci + Bytecodes::length_for(bytecode), nullptr);\n+        }\n@@ -505,1 +505,4 @@\n-            reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            \/\/ If this is the last bytecode, there is no successor to mark\n+            if (bci + Bytecodes::length_for(bytecode) < method()->code_size()) {\n+              reachable_basicblock(this, bci + Bytecodes::length_for(bytecode), &change);\n+            }\n@@ -589,3 +592,0 @@\n-\n-\n-\n","filename":"src\/hotspot\/share\/oops\/generateOopMap.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2662,2 +2662,2 @@\n-  \/\/ Initialize @ValueBased class annotation\n-  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation()) {\n+  \/\/ Initialize @ValueBased class annotation if not already set in the archived klass.\n+  if (DiagnoseSyncOnValueBasedClasses && has_value_based_class_annotation() && !is_value_based()) {\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -228,4 +228,0 @@\n-  \/\/ _is_marked_dependent can be set concurrently, thus cannot be part of the\n-  \/\/ _misc_flags.\n-  bool            _is_marked_dependent;     \/\/ used for marking during flushing and deoptimization\n-\n","filename":"src\/hotspot\/share\/oops\/instanceKlass.hpp","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -229,1 +229,1 @@\n-    f.print_value_on(_st, nullptr);\n+    f.print_value_on(_st);\n","filename":"src\/hotspot\/share\/oops\/instanceStackChunkKlass.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-  return _access_flags.is_cloneable_fast() ||\n+  return _misc_flags.is_cloneable_fast() ||\n@@ -79,1 +79,1 @@\n-    _access_flags.set_is_cloneable_fast();\n+    _misc_flags.set_is_cloneable_fast(true);\n@@ -309,0 +309,1 @@\n+    assert(secondaries->length() >= (int)population_count(bitmap), \"must be\");\n@@ -347,5 +348,6 @@\n-  \/\/ For performance reasons we don't use a hashed table unless there\n-  \/\/ are at least two empty slots in it. If there were only one empty\n-  \/\/ slot it'd take a long time to create the table and the resulting\n-  \/\/ search would be no faster than linear probing.\n-  if (length > SECONDARY_SUPERS_TABLE_SIZE - 2) {\n+  \/\/ Invariant: _secondary_supers.length >= population_count(_secondary_supers_bitmap)\n+\n+  \/\/ Don't attempt to hash a table that's completely full, because in\n+  \/\/ the case of an absent interface linear probing would not\n+  \/\/ terminate.\n+  if (length >= SECONDARY_SUPERS_TABLE_SIZE) {\n@@ -791,0 +793,1 @@\n+  assert(secondary_supers()->length() >= (int)population_count(_bitmap), \"must be\");\n@@ -975,0 +978,1 @@\n+  st->print(BULLET\"flags: \"); _misc_flags.print_on(st); st->cr();\n","filename":"src\/hotspot\/share\/oops\/klass.cpp","additions":11,"deletions":7,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+#include \"oops\/klassFlags.hpp\"\n@@ -168,0 +169,2 @@\n+                                \/\/ Some flags created by the JVM, not in the class file itself,\n+                                \/\/ are in _misc_flags below.\n@@ -197,0 +200,2 @@\n+  KlassFlags  _misc_flags;\n+\n@@ -431,0 +436,1 @@\n+  static ByteSize misc_flags_offset()            { return byte_offset_of(Klass, _misc_flags._flags); }\n@@ -695,6 +701,8 @@\n-  bool has_finalizer() const            { return _access_flags.has_finalizer(); }\n-  void set_has_finalizer()              { _access_flags.set_has_finalizer(); }\n-  bool is_hidden() const                { return access_flags().is_hidden_class(); }\n-  void set_is_hidden()                  { _access_flags.set_is_hidden_class(); }\n-  bool is_value_based()                 { return _access_flags.is_value_based_class(); }\n-  void set_is_value_based()             { _access_flags.set_is_value_based_class(); }\n+  bool has_finalizer() const            { return _misc_flags.has_finalizer(); }\n+  void set_has_finalizer()              { _misc_flags.set_has_finalizer(true); }\n+  bool is_hidden() const                { return _misc_flags.is_hidden_class(); }\n+  void set_is_hidden()                  { _misc_flags.set_is_hidden_class(true); }\n+  bool is_value_based() const           { return _misc_flags.is_value_based_class(); }\n+  void set_is_value_based()             { _misc_flags.set_is_value_based_class(true); }\n+\n+  klass_flags_t misc_flags() const      { return _misc_flags.value(); }\n","filename":"src\/hotspot\/share\/oops\/klass.hpp","additions":14,"deletions":6,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,2 +40,1 @@\n-  return access_flags().is_hidden_class() &&\n-         class_loader_data()->has_class_mirror_holder();\n+  return is_hidden() && class_loader_data()->has_class_mirror_holder();\n","filename":"src\/hotspot\/share\/oops\/klass.inline.hpp","additions":2,"deletions":3,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"oops\/klassFlags.hpp\"\n+#include \"utilities\/ostream.hpp\"\n+\n+void KlassFlags::print_on(outputStream* st) const {\n+#define KLASS_FLAGS_PRINT(name, ignore)          \\\n+  if (name()) st->print(#name \" \");\n+  KLASS_FLAGS_DO(KLASS_FLAGS_PRINT)\n+#undef KLASS_FLAGS_PRINT\n+}\n","filename":"src\/hotspot\/share\/oops\/klassFlags.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -0,0 +1,78 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_OOPS_KLASSFLAGS_HPP\n+#define SHARE_OOPS_KLASSFLAGS_HPP\n+\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+class outputStream;\n+\n+\/\/ The Klass class contains only parse-time flags and are used by generated code, even though\n+\/\/ most apply to InstanceKlass, access is more straightforward through Klass pointers.\n+\/\/ These flags are JVM internal and not part of the AccessFlags classfile specification.\n+\n+using klass_flags_t = u1;\n+\n+class KlassFlags {\n+  friend class VMStructs;\n+  friend class JVMCIVMStructs;\n+\n+ public:\n+#define KLASS_FLAGS_DO(flag)  \\\n+    flag(is_hidden_class              , 1 << 0) \\\n+    flag(is_value_based_class         , 1 << 1) \\\n+    flag(has_finalizer                , 1 << 2) \\\n+    flag(is_cloneable_fast            , 1 << 3) \\\n+    \/* end of list *\/\n+\n+#define KLASS_FLAGS_ENUM_NAME(name, value)    _misc_##name = value,\n+  enum {\n+    KLASS_FLAGS_DO(KLASS_FLAGS_ENUM_NAME)\n+  };\n+#undef KLASS_FLAGS_ENUM_NAME\n+\n+  \/\/ These flags are write-once before the class is published and then read-only\n+  \/\/ so don't require atomic updates.\n+  klass_flags_t _flags;\n+\n+ public:\n+  KlassFlags() : _flags(0) {}\n+\n+  klass_flags_t value() const { return _flags; }\n+\n+  \/\/ Create getters and setters for the flag values.\n+#define KLASS_FLAGS_GET_SET(name, ignore)          \\\n+  bool name() const { return (_flags & _misc_##name) != 0; } \\\n+  void set_##name(bool b) {         \\\n+    assert(!name(), \"set once\");    \\\n+    if (b) _flags |= _misc_##name; \\\n+  }\n+  KLASS_FLAGS_DO(KLASS_FLAGS_GET_SET)\n+#undef KLASS_FLAGS_GET_SET\n+\n+  void print_on(outputStream* st) const;\n+};\n+\n+#endif \/\/ SHARE_OOPS_KLASSFLAGS_HPP\n","filename":"src\/hotspot\/share\/oops\/klassFlags.hpp","additions":78,"deletions":0,"binary":false,"changes":78,"status":"added"},{"patch":"@@ -27,0 +27,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -70,1 +71,1 @@\n-    if (print_monitor_info) {\n+    if (print_monitor_info && !UseObjectMonitorTable) {\n","filename":"src\/hotspot\/share\/oops\/markWord.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -56,1 +56,2 @@\n-\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out)\n+\/\/    [ptr             | 10]  monitor            inflated lock (header is swapped out, UseObjectMonitorTable == false)\n+\/\/    [header          | 10]  monitor            inflated lock (UseObjectMonitorTable == true)\n@@ -200,0 +201,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -205,2 +207,5 @@\n-    return LockingMode == LM_LIGHTWEIGHT  ? lockbits == monitor_value   \/\/ monitor?\n-                                          : (lockbits & unlocked_value) == 0; \/\/ monitor | stack-locked?\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      return !UseObjectMonitorTable && lockbits == monitor_value;\n+    }\n+    \/\/ monitor (0b10) | stack-locked (0b00)?\n+    return (lockbits & unlocked_value) == 0;\n@@ -226,0 +231,1 @@\n+    assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use markWord for monitors\");\n@@ -230,0 +236,4 @@\n+  markWord set_has_monitor() const {\n+    return markWord((value() & ~lock_mask_in_place) | monitor_value);\n+  }\n+\n","filename":"src\/hotspot\/share\/oops\/markWord.hpp","additions":13,"deletions":3,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -169,1 +169,1 @@\n-  int quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n+  size_t quoted_length = UTF8::quoted_ascii_length(ptr, utf8_length());\n","filename":"src\/hotspot\/share\/oops\/symbol.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -318,1 +318,3 @@\n-      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ CompilationPolicy::min_invocations());\n+      \/\/ avoid division by 0, set divisor to at least 1\n+      int cp_min_inv = MAX2(1, CompilationPolicy::min_invocations());\n+      double min_freq = MAX2(MinInlineFrequencyRatio, 1.0 \/ cp_min_inv);\n","filename":"src\/hotspot\/share\/opto\/bytecodeInfo.cpp","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -106,0 +106,1 @@\n+  Label _slow_path;\n@@ -114,0 +115,1 @@\n+  Label& slow_path() { return _slow_path; }\n","filename":"src\/hotspot\/share\/opto\/c2_CodeStubs.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -734,0 +734,2 @@\n+  case vmIntrinsics::_Continuation_pin:\n+  case vmIntrinsics::_Continuation_unpin:\n","filename":"src\/hotspot\/share\/opto\/c2compiler.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -155,0 +155,11 @@\n+\/\/------------------------------ForwardExceptionNode---------------------------\n+\/\/ Pop stack frame and jump to StubRoutines::forward_exception_entry()\n+class ForwardExceptionNode : public ReturnNode {\n+public:\n+  ForwardExceptionNode(Node* cntrl, Node* i_o, Node* memory, Node* frameptr, Node* retadr)\n+    : ReturnNode(TypeFunc::Parms, cntrl, i_o, memory, frameptr, retadr) {\n+  }\n+\n+  virtual int Opcode() const;\n+};\n+\n","filename":"src\/hotspot\/share\/opto\/callnode.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -187,0 +187,1 @@\n+macro(ForwardException)\n","filename":"src\/hotspot\/share\/opto\/classes.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -1704,0 +1704,2 @@\n+      if (flat->offset() == in_bytes(Klass::misc_flags_offset()))\n+        alias_type(idx)->set_rewritable(false);\n","filename":"src\/hotspot\/share\/opto\/compile.cpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -242,0 +242,1 @@\n+  case Op_ForwardException:\n","filename":"src\/hotspot\/share\/opto\/domgraph.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2034,0 +2034,1 @@\n+  case Op_ForwardException:\n@@ -2087,0 +2088,1 @@\n+  case Op_ForwardException:\n@@ -2132,0 +2134,1 @@\n+  case Op_ForwardException:\n","filename":"src\/hotspot\/share\/opto\/gcm.cpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -258,7 +258,5 @@\n-  Node *exc_target = makecon(TypeRawPtr::make( StubRoutines::forward_exception_entry() ));\n-  Node *to_exc = new TailCallNode(if_not_null,\n-                                  i_o(),\n-                                  exit_memory,\n-                                  frameptr(),\n-                                  returnadr(),\n-                                  exc_target, null());\n+  Node *to_exc = new ForwardExceptionNode(if_not_null,\n+                                          i_o(),\n+                                          exit_memory,\n+                                          frameptr(),\n+                                          returnadr());\n","filename":"src\/hotspot\/share\/opto\/generateOptoStub.cpp","additions":6,"deletions":8,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -485,0 +485,3 @@\n+  case vmIntrinsics::_Continuation_pin:          return inline_native_Continuation_pinning(false);\n+  case vmIntrinsics::_Continuation_unpin:        return inline_native_Continuation_pinning(true);\n+\n@@ -3170,1 +3173,1 @@\n-                                              StubRoutines::jfr_return_lease(),\n+                                              SharedRuntime::jfr_return_lease(),\n@@ -3233,0 +3236,1 @@\n+ * bool pinVirtualThread;\n@@ -3237,0 +3241,1 @@\n+ *   pinVirtualThread = VMContinuations;\n@@ -3248,0 +3253,1 @@\n+ *   pinVirtualThread = false;\n@@ -3253,1 +3259,1 @@\n- *   setField(event_writer, \"threadID\", tid);\n+ *   setField(event_writer, \"pinVirtualThread\", pinVirtualThread);\n@@ -3255,0 +3261,1 @@\n+ *   setField(event_writer, \"threadID\", tid);\n@@ -3325,0 +3332,4 @@\n+  \/\/ Continuation support determines if a virtual thread should be pinned.\n+  Node* global_addr = makecon(TypeRawPtr::make((address)&VMContinuations));\n+  Node* continuation_support = make_load(control(), global_addr, TypeInt::BOOL, T_BOOLEAN, MemNode::unordered);\n+\n@@ -3369,1 +3380,1 @@\n-                                                  StubRoutines::jfr_write_checkpoint(),\n+                                                  SharedRuntime::jfr_write_checkpoint(),\n@@ -3415,0 +3426,2 @@\n+  PhiNode* pinVirtualThread = new PhiNode(vthread_compare_rgn, TypeInt::BOOL);\n+  record_for_igvn(pinVirtualThread);\n@@ -3427,0 +3440,2 @@\n+  pinVirtualThread->init_req(_true_path, _gvn.transform(continuation_support));\n+  pinVirtualThread->init_req(_false_path, _gvn.intcon(0));\n@@ -3450,0 +3465,3 @@\n+  \/\/ Get the field offset to, conditionally, store an updated pinVirtualThread value later.\n+  Node* const event_writer_pin_field = field_address_from_object(event_writer, \"pinVirtualThread\", \"Z\", false);\n+  const TypePtr* event_writer_pin_field_type = _gvn.type(event_writer_pin_field)->isa_ptr();\n@@ -3470,0 +3488,3 @@\n+  \/\/ Store the pin state to the event writer.\n+  store_to_memory(tid_is_not_equal, event_writer_pin_field, _gvn.transform(pinVirtualThread), T_BOOLEAN, event_writer_pin_field_type, MemNode::unordered);\n+\n@@ -3718,0 +3739,87 @@\n+\/\/------------------------inline_native_Continuation_pin and unpin-----------\n+\n+\/\/ Shared implementation routine for both pin and unpin.\n+bool LibraryCallKit::inline_native_Continuation_pinning(bool unpin) {\n+  enum { _true_path = 1, _false_path = 2, PATH_LIMIT };\n+\n+  \/\/ Save input memory.\n+  Node* input_memory_state = reset_memory();\n+  set_all_memory(input_memory_state);\n+\n+  \/\/ TLS\n+  Node* tls_ptr = _gvn.transform(new ThreadLocalNode());\n+  Node* last_continuation_offset = basic_plus_adr(top(), tls_ptr, in_bytes(JavaThread::cont_entry_offset()));\n+  Node* last_continuation = make_load(control(), last_continuation_offset, last_continuation_offset->get_ptr_type(), T_ADDRESS, MemNode::unordered);\n+\n+  \/\/ Null check the last continuation object.\n+  Node* continuation_cmp_null = _gvn.transform(new CmpPNode(last_continuation, null()));\n+  Node* test_continuation_not_equal_null = _gvn.transform(new BoolNode(continuation_cmp_null, BoolTest::ne));\n+  IfNode* iff_continuation_not_equal_null = create_and_map_if(control(), test_continuation_not_equal_null, PROB_MAX, COUNT_UNKNOWN);\n+\n+  \/\/ False path, last continuation is null.\n+  Node* continuation_is_null = _gvn.transform(new IfFalseNode(iff_continuation_not_equal_null));\n+\n+  \/\/ True path, last continuation is not null.\n+  Node* continuation_is_not_null = _gvn.transform(new IfTrueNode(iff_continuation_not_equal_null));\n+\n+  set_control(continuation_is_not_null);\n+\n+  \/\/ Load the pin count from the last continuation.\n+  Node* pin_count_offset = basic_plus_adr(top(), last_continuation, in_bytes(ContinuationEntry::pin_count_offset()));\n+  Node* pin_count = make_load(control(), pin_count_offset, TypeInt::INT, T_INT, MemNode::unordered);\n+\n+  \/\/ The loaded pin count is compared against a context specific rhs for over\/underflow detection.\n+  Node* pin_count_rhs;\n+  if (unpin) {\n+    pin_count_rhs = _gvn.intcon(0);\n+  } else {\n+    pin_count_rhs = _gvn.intcon(UINT32_MAX);\n+  }\n+  Node* pin_count_cmp = _gvn.transform(new CmpUNode(_gvn.transform(pin_count), pin_count_rhs));\n+  Node* test_pin_count_over_underflow = _gvn.transform(new BoolNode(pin_count_cmp, BoolTest::eq));\n+  IfNode* iff_pin_count_over_underflow = create_and_map_if(control(), test_pin_count_over_underflow, PROB_MIN, COUNT_UNKNOWN);\n+\n+  \/\/ False branch, no pin count over\/underflow. Increment or decrement pin count and store back.\n+  Node* valid_pin_count = _gvn.transform(new IfFalseNode(iff_pin_count_over_underflow));\n+  set_control(valid_pin_count);\n+\n+  Node* next_pin_count;\n+  if (unpin) {\n+    next_pin_count = _gvn.transform(new SubINode(pin_count, _gvn.intcon(1)));\n+  } else {\n+    next_pin_count = _gvn.transform(new AddINode(pin_count, _gvn.intcon(1)));\n+  }\n+\n+  Node* updated_pin_count_memory = store_to_memory(control(), pin_count_offset, next_pin_count, T_INT, Compile::AliasIdxRaw, MemNode::unordered);\n+\n+  \/\/ True branch, pin count over\/underflow.\n+  Node* pin_count_over_underflow = _gvn.transform(new IfTrueNode(iff_pin_count_over_underflow));\n+  {\n+    \/\/ Trap (but not deoptimize (Action_none)) and continue in the interpreter\n+    \/\/ which will throw IllegalStateException for pin count over\/underflow.\n+    PreserveJVMState pjvms(this);\n+    set_control(pin_count_over_underflow);\n+    set_all_memory(input_memory_state);\n+    uncommon_trap_exact(Deoptimization::Reason_intrinsic,\n+                        Deoptimization::Action_none);\n+    assert(stopped(), \"invariant\");\n+  }\n+\n+  \/\/ Result of top level CFG and Memory.\n+  RegionNode* result_rgn = new RegionNode(PATH_LIMIT);\n+  record_for_igvn(result_rgn);\n+  PhiNode* result_mem = new PhiNode(result_rgn, Type::MEMORY, TypePtr::BOTTOM);\n+  record_for_igvn(result_mem);\n+\n+  result_rgn->init_req(_true_path, _gvn.transform(valid_pin_count));\n+  result_rgn->init_req(_false_path, _gvn.transform(continuation_is_null));\n+  result_mem->init_req(_true_path, _gvn.transform(updated_pin_count_memory));\n+  result_mem->init_req(_false_path, _gvn.transform(input_memory_state));\n+\n+  \/\/ Set output state.\n+  set_control(_gvn.transform(result_rgn));\n+  set_all_memory(_gvn.transform(result_mem));\n+\n+  return true;\n+}\n+\n@@ -3755,1 +3863,1 @@\n-\/\/ Use this for JVM_ACC_INTERFACE, JVM_ACC_IS_CLONEABLE_FAST, JVM_ACC_HAS_FINALIZER.\n+\/\/ Use this for JVM_ACC_INTERFACE.\n@@ -3757,1 +3865,2 @@\n-Node* LibraryCallKit::generate_access_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {\n+Node* LibraryCallKit::generate_klass_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region,\n+                                                 ByteSize offset, const Type* type, BasicType bt) {\n@@ -3760,2 +3869,2 @@\n-  Node* modp = basic_plus_adr(kls, in_bytes(Klass::access_flags_offset()));\n-  Node* mods = make_load(nullptr, modp, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* modp = basic_plus_adr(kls, in_bytes(offset));\n+  Node* mods = make_load(nullptr, modp, type, bt, MemNode::unordered);\n@@ -3770,1 +3879,2 @@\n-  return generate_access_flags_guard(kls, JVM_ACC_INTERFACE, 0, region);\n+  return generate_klass_flags_guard(kls, JVM_ACC_INTERFACE, 0, region,\n+                                    Klass::access_flags_offset(), TypeInt::INT, T_INT);\n@@ -3772,0 +3882,7 @@\n+\n+\/\/ Use this for testing if Klass is_hidden, has_finalizer, and is_cloneable_fast.\n+Node* LibraryCallKit::generate_misc_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region) {\n+  return generate_klass_flags_guard(kls, modifier_mask, modifier_bits, region,\n+                                    Klass::misc_flags_offset(), TypeInt::UBYTE, T_BOOLEAN);\n+}\n+\n@@ -3773,1 +3890,1 @@\n-  return generate_access_flags_guard(kls, JVM_ACC_IS_HIDDEN_CLASS, 0, region);\n+  return generate_misc_flags_guard(kls, KlassFlags::_misc_is_hidden_class, 0, region);\n@@ -4607,7 +4724,8 @@\n-  \/\/ Test the header to see if it is safe to read w.r.t. locking.\n-  Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n-  Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n-  if (LockingMode == LM_LIGHTWEIGHT) {\n-    Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n-    Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n-    Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Test the header to see if it is safe to read w.r.t. locking.\n+    Node *lock_mask      = _gvn.MakeConX(markWord::lock_mask_in_place);\n+    Node *lmasked_header = _gvn.transform(new AndXNode(header, lock_mask));\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      Node *monitor_val   = _gvn.MakeConX(markWord::monitor_value);\n+      Node *chk_monitor   = _gvn.transform(new CmpXNode(lmasked_header, monitor_val));\n+      Node *test_monitor  = _gvn.transform(new BoolNode(chk_monitor, BoolTest::eq));\n@@ -4615,5 +4733,5 @@\n-    generate_slow_guard(test_monitor, slow_region);\n-  } else {\n-    Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n-    Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n-    Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n+      generate_slow_guard(test_monitor, slow_region);\n+    } else {\n+      Node *unlocked_val      = _gvn.MakeConX(markWord::unlocked_value);\n+      Node *chk_unlocked      = _gvn.transform(new CmpXNode(lmasked_header, unlocked_val));\n+      Node *test_not_unlocked = _gvn.transform(new BoolNode(chk_unlocked, BoolTest::ne));\n@@ -4621,1 +4739,2 @@\n-    generate_slow_guard(test_not_unlocked, slow_region);\n+      generate_slow_guard(test_not_unlocked, slow_region);\n+    }\n@@ -5213,6 +5332,6 @@\n-      generate_access_flags_guard(obj_klass,\n-                                  \/\/ Test both conditions:\n-                                  JVM_ACC_IS_CLONEABLE_FAST | JVM_ACC_HAS_FINALIZER,\n-                                  \/\/ Must be cloneable but not finalizer:\n-                                  JVM_ACC_IS_CLONEABLE_FAST,\n-                                  slow_region);\n+      generate_misc_flags_guard(obj_klass,\n+                                \/\/ Test both conditions:\n+                                KlassFlags::_misc_is_cloneable_fast | KlassFlags::_misc_has_finalizer,\n+                                \/\/ Must be cloneable but not finalizer:\n+                                KlassFlags::_misc_is_cloneable_fast,\n+                                slow_region);\n","filename":"src\/hotspot\/share\/opto\/library_call.cpp","additions":147,"deletions":28,"binary":false,"changes":175,"status":"modified"},{"patch":"@@ -159,3 +159,5 @@\n-  Node* generate_access_flags_guard(Node* kls,\n-                                    int modifier_mask, int modifier_bits,\n-                                    RegionNode* region);\n+  Node* generate_klass_flags_guard(Node* kls, int modifier_mask, int modifier_bits, RegionNode* region,\n+                                   ByteSize offset, const Type* type, BasicType bt);\n+  Node* generate_misc_flags_guard(Node* kls,\n+                                  int modifier_mask, int modifier_bits,\n+                                  RegionNode* region);\n@@ -244,0 +246,1 @@\n+  bool inline_native_Continuation_pinning(bool unpin);\n","filename":"src\/hotspot\/share\/opto\/library_call.hpp","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -1312,13 +1312,0 @@\n-Node* PhaseIdealLoop::cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop) {\n-  Node* castii = new CastIINode(ctrl, incr, TypeInt::INT, ConstraintCastNode::UnconditionalDependency);\n-  register_new_node(castii, ctrl);\n-  for (DUIterator_Fast imax, i = incr->fast_outs(imax); i < imax; i++) {\n-    Node* n = incr->fast_out(i);\n-    if (n->is_Phi() && n->in(0) == loop) {\n-      int nrep = n->replace_edge(incr, castii, &_igvn);\n-      return castii;\n-    }\n-  }\n-  return nullptr;\n-}\n-\n@@ -1683,3 +1670,0 @@\n-  \/\/ CastII for the main loop:\n-  Node* castii = cast_incr_before_loop(pre_incr, min_taken, main_head);\n-  assert(castii != nullptr, \"no castII inserted\");\n@@ -1687,1 +1671,1 @@\n-  copy_assertion_predicates_to_main_loop(pre_head, castii, stride, outer_loop, outer_main_head, dd_main_head,\n+  copy_assertion_predicates_to_main_loop(pre_head, pre_incr, stride, outer_loop, outer_main_head, dd_main_head,\n@@ -1690,1 +1674,1 @@\n-  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, post_incr, stride);\n+  copy_assertion_predicates_to_post_loop(outer_main_head, post_head, stride);\n@@ -1815,1 +1799,1 @@\n-  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, incr, main_head->stride());\n+  copy_assertion_predicates_to_post_loop(main_head->skip_strip_mined(), post_head, main_head->stride());\n@@ -1918,4 +1902,0 @@\n-  \/\/ CastII for the new post loop:\n-  incr = cast_incr_before_loop(zer_opaq->in(1), zer_taken, post_head);\n-  assert(incr != nullptr, \"no castII inserted\");\n-\n@@ -1937,6 +1917,0 @@\n-  if (init->is_CastII()) {\n-    \/\/ skip over the cast added by PhaseIdealLoop::cast_incr_before_loop() when pre\/post\/main loops are created because\n-    \/\/ it can get in the way of type propagation\n-    assert(init->as_CastII()->carry_dependency() && loop_head->skip_assertion_predicates_with_halt() == init->in(0), \"casted iv phi from pre loop expected\");\n-    init = init->in(1);\n-  }\n@@ -1991,1 +1965,3 @@\n-                                                            Node* init, Node* stride) {\n+                                                            Node* stride) {\n+  Node* opaq = post_loop_head->is_canonical_loop_entry();\n+  Node* init = opaq->in(1);\n","filename":"src\/hotspot\/share\/opto\/loopTransform.cpp","additions":6,"deletions":30,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -941,2 +941,0 @@\n-  Node* cast_incr_before_loop(Node* incr, Node* ctrl, Node* loop);\n-\n@@ -963,1 +961,1 @@\n-  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head, Node* init,\n+  void copy_assertion_predicates_to_post_loop(LoopNode* main_loop_head, CountedLoopNode* post_loop_head,\n@@ -1537,0 +1535,2 @@\n+  bool split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk);\n+\n@@ -1581,1 +1581,1 @@\n-  static bool is_divisor_counted_loop_phi(const Node* divisor, const Node* loop);\n+  static bool is_divisor_loop_phi(const Node* divisor, const Node* loop);\n","filename":"src\/hotspot\/share\/opto\/loopnode.hpp","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -298,1 +298,1 @@\n-  return is_divisor_counted_loop_phi(divisor, region) &&\n+  return is_divisor_loop_phi(divisor, region) &&\n@@ -302,2 +302,2 @@\n-bool PhaseIdealLoop::is_divisor_counted_loop_phi(const Node* divisor, const Node* loop) {\n-  return loop->is_BaseCountedLoop() && divisor->is_Phi() && divisor->in(0) == loop;\n+bool PhaseIdealLoop::is_divisor_loop_phi(const Node* divisor, const Node* loop) {\n+  return loop->is_Loop() && divisor->is_Phi() && divisor->in(0) == loop;\n@@ -1072,1 +1072,1 @@\n-            assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch(), \"must not be moved into inner loop\");\n+            assert(get_loop(lca)->_nest < n_loop->_nest || get_loop(lca)->_head->as_Loop()->is_in_infinite_subgraph(), \"must not be moved into inner loop\");\n@@ -1092,0 +1092,19 @@\n+\/\/ Split some nodes that take a counted loop phi as input at a counted\n+\/\/ loop can cause vectorization of some expressions to fail\n+bool PhaseIdealLoop::split_thru_phi_could_prevent_vectorization(Node* n, Node* n_blk) {\n+  if (!n_blk->is_CountedLoop()) {\n+    return false;\n+  }\n+\n+  int opcode = n->Opcode();\n+\n+  if (opcode != Op_AndI &&\n+      opcode != Op_MulI &&\n+      opcode != Op_RotateRight &&\n+      opcode != Op_RShiftI) {\n+    return false;\n+  }\n+\n+  return n->in(1) == n_blk->as_BaseCountedLoop()->phi();\n+}\n+\n@@ -1178,0 +1197,4 @@\n+  if (split_thru_phi_could_prevent_vectorization(n, n_blk)) {\n+    return n;\n+  }\n+\n@@ -1275,3 +1298,1 @@\n-    if (loop->is_member(get_loop(dom)) ||\n-        \/\/ NeverBranch nodes are not assigned to the loop when constructed\n-        (dom->is_NeverBranch() && loop->is_member(get_loop(dom->in(0))))) {\n+    if (loop->is_member(get_loop(dom))) {\n","filename":"src\/hotspot\/share\/opto\/loopopts.cpp","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -48,3 +48,3 @@\n-jdouble MachOper::constantD() const { ShouldNotReachHere(); return 0.0; }\n-jfloat  MachOper::constantF() const { ShouldNotReachHere(); return 0.0; }\n-jlong   MachOper::constantL() const { ShouldNotReachHere(); return CONST64(0) ; }\n+jdouble MachOper::constantD() const { ShouldNotReachHere(); }\n+jfloat  MachOper::constantF() const { ShouldNotReachHere(); }\n+jlong   MachOper::constantL() const { ShouldNotReachHere(); }\n@@ -65,2 +65,2 @@\n-Label*   MachOper::label()  const { ShouldNotReachHere(); return 0; }\n-intptr_t MachOper::method() const { ShouldNotReachHere(); return 0; }\n+Label*   MachOper::label()  const { ShouldNotReachHere(); }\n+intptr_t MachOper::method() const { ShouldNotReachHere(); }\n@@ -83,1 +83,0 @@\n-  return nullptr;\n@@ -96,1 +95,0 @@\n-  return 5;\n@@ -103,1 +101,0 @@\n-  return opcode() == oper.opcode();\n@@ -210,1 +207,0 @@\n-  return nullptr;\n","filename":"src\/hotspot\/share\/opto\/machnode.cpp","additions":5,"deletions":9,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -807,0 +807,4 @@\n+  \/\/ Input RegMask array shared by all ForwardExceptions\n+  uint forw_exc_edge_cnt = TypeFunc::Parms;\n+  RegMask* forw_exc_rms  = init_input_masks( forw_exc_edge_cnt + soe_cnt, _return_addr_mask, c_frame_ptr_mask );\n+\n@@ -866,0 +870,1 @@\n+      case Op_ForwardException: exit->_in_rms = forw_exc_rms; break;\n@@ -885,0 +890,1 @@\n+      forw_exc_rms [ forw_exc_edge_cnt] = mreg2regmask[i];\n@@ -902,0 +908,1 @@\n+        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n@@ -914,0 +921,1 @@\n+        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n@@ -928,0 +936,1 @@\n+        forw_exc_rms [ forw_exc_edge_cnt].Insert(OptoReg::Name(i+1));\n@@ -940,0 +949,1 @@\n+        forw_exc_rms [ forw_exc_edge_cnt] = RegMask::Empty;\n@@ -951,0 +961,1 @@\n+      forw_exc_edge_cnt++;\n@@ -954,1 +965,1 @@\n-      for( uint j=1; j < root->req(); j++ )\n+      for (uint j=1; j < root->req(); j++) {\n@@ -956,0 +967,1 @@\n+      }\n@@ -1073,0 +1085,1 @@\n+    case Op_ForwardException:\n","filename":"src\/hotspot\/share\/opto\/matcher.cpp","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -430,3 +431,9 @@\n-bool MemNode::all_controls_dominate(Node* dom, Node* sub) {\n-  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+\/\/ Returns 'DomResult::Dominate' if all control inputs of 'dom'\n+\/\/ dominate 'sub', 'DomResult::NotDominate' if not,\n+\/\/ and 'DomResult::EncounteredDeadCode' if we can't decide due to\n+\/\/ dead code, but at the end of IGVN, we know the definite result\n+\/\/ once the dead code is cleaned up.\n+Node::DomResult MemNode::maybe_all_controls_dominate(Node* dom, Node* sub) {\n+  if (dom == nullptr || dom->is_top() || sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -436,2 +443,3 @@\n-  if (dom == nullptr || dom->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (dom == nullptr || dom->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -442,1 +450,1 @@\n-    return false;\n+    return DomResult::NotDominate;\n@@ -445,2 +453,3 @@\n-  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub)\n-    return true;\n+  if (dom->is_Con() || dom->is_Start() || dom->is_Root() || dom == sub) {\n+    return DomResult::Dominate;\n+  }\n@@ -460,2 +469,3 @@\n-  if (sub == nullptr || sub->is_top())\n-    return false; \/\/ Conservative answer for dead code\n+  if (sub == nullptr || sub->is_top()) {\n+    return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+  }\n@@ -465,2 +475,3 @@\n-  if (sub == dom)\n-    return true;\n+  if (sub == dom) {\n+    return DomResult::Dominate;\n+  }\n@@ -468,2 +479,3 @@\n-  if (sub->is_Start() || sub->is_Root())\n-    return false;\n+  if (sub->is_Start() || sub->is_Root()) {\n+    return DomResult::NotDominate;\n+  }\n@@ -483,2 +495,3 @@\n-      if (n == orig_sub)\n-        return false; \/\/ One of dom's inputs dominated by sub.\n+      if (n == orig_sub) {\n+        return DomResult::NotDominate; \/\/ One of dom's inputs dominated by sub.\n+      }\n@@ -488,2 +501,3 @@\n-        if (n == nullptr || n->is_top())\n-          return false; \/\/ Conservative answer for dead code\n+        if (n == nullptr || n->is_top()) {\n+          return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+        }\n@@ -495,1 +509,2 @@\n-        if (n->dominates(sub, nlist))\n+        DomResult dom_result = n->dominates(sub, nlist);\n+        if (dom_result == DomResult::Dominate) {\n@@ -497,2 +512,3 @@\n-        else\n-          return false;\n+        } else {\n+          return dom_result;\n+        }\n@@ -503,2 +519,3 @@\n-          if (m->is_top())\n-            return false; \/\/ Conservative answer for dead code\n+          if (m->is_top()) {\n+            return DomResult::EncounteredDeadCode; \/\/ Conservative answer for dead code\n+          }\n@@ -511,1 +528,1 @@\n-          if (m == nullptr || m->is_top())\n+          if (m == nullptr || m->is_top()) {\n@@ -513,0 +530,1 @@\n+          }\n@@ -517,1 +535,1 @@\n-    return only_dominating_controls;\n+    return only_dominating_controls ? DomResult::Dominate : DomResult::NotDominate;\n@@ -729,1 +747,1 @@\n-      if (st_alloc == nullptr)\n+      if (st_alloc == nullptr) {\n@@ -731,0 +749,1 @@\n+      }\n@@ -733,1 +752,1 @@\n-      if (alloc == st_alloc)\n+      if (alloc == st_alloc) {\n@@ -735,1 +754,1 @@\n-      else if (alloc != nullptr)\n+      } else if (alloc != nullptr) {\n@@ -737,1 +756,1 @@\n-      else if (all_controls_dominate(this, st_alloc))\n+      } else if (all_controls_dominate(this, st_alloc)) {\n@@ -739,0 +758,1 @@\n+      }\n@@ -1569,1 +1589,1 @@\n-    if (!MemNode::all_controls_dominate(mem, base->in(0)))\n+    if (!MemNode::all_controls_dominate(mem, base->in(0))) {\n@@ -1571,0 +1591,1 @@\n+    }\n@@ -1661,0 +1682,1 @@\n+  DomResult dom_result = DomResult::Dominate;\n@@ -1665,2 +1687,2 @@\n-    if (!MemNode::all_controls_dominate(address, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(address, region);\n@@ -1671,2 +1693,2 @@\n-    if (!MemNode::all_controls_dominate(mem, region))\n-      return nullptr;\n+    \/\/ We will check `dom_result` later.\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, region);\n@@ -1675,1 +1697,2 @@\n-    if (MemNode::all_controls_dominate(mem, base->in(0))) {\n+    dom_result = MemNode::maybe_all_controls_dominate(mem, base->in(0));\n+    if (dom_result == DomResult::Dominate) {\n@@ -1677,2 +1700,0 @@\n-    } else if (MemNode::all_controls_dominate(address, mem->in(0))) {\n-      region = mem->in(0);\n@@ -1680,1 +1701,5 @@\n-      return nullptr; \/\/ complex graph\n+      dom_result = MemNode::maybe_all_controls_dominate(address, mem->in(0));\n+      if (dom_result == DomResult::Dominate) {\n+        region = mem->in(0);\n+      }\n+      \/\/ Otherwise we encountered a complex graph.\n@@ -1687,0 +1712,11 @@\n+  PhaseIterGVN* igvn = phase->is_IterGVN();\n+  if (dom_result != DomResult::Dominate) {\n+    if (dom_result == DomResult::EncounteredDeadCode) {\n+      \/\/ There is some dead code which eventually will be removed in IGVN.\n+      \/\/ Once this is the case, we get an unambiguous dominance result.\n+      \/\/ Push the node to the worklist again until the dead code is removed.\n+      igvn->_worklist.push(this);\n+    }\n+    return nullptr;\n+  }\n+\n@@ -1689,1 +1725,0 @@\n-  PhaseIterGVN* igvn = phase->is_IterGVN();\n@@ -1949,0 +1984,6 @@\n+  if (tkls->offset() == in_bytes(Klass::misc_flags_offset())) {\n+    \/\/ The field is Klass::_misc_flags.  Return its (constant) value.\n+    \/\/ (Folds up the 2nd indirection in Reflection.getClassAccessFlags(aClassConstant).)\n+    assert(this->Opcode() == Op_LoadUB, \"must load an unsigned byte from _misc_flags\");\n+    return TypeInt::make(klass->misc_flags());\n+  }\n@@ -4574,1 +4615,1 @@\n-      if (!MemNode::all_controls_dominate(n, this))\n+      if (!MemNode::all_controls_dominate(n, this)) {\n@@ -4576,0 +4617,1 @@\n+      }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":82,"deletions":40,"binary":false,"changes":122,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -108,2 +109,6 @@\n-  \/\/ This one should probably be a phase-specific function:\n-  static bool all_controls_dominate(Node* dom, Node* sub);\n+  \/\/ The following two should probably be phase-specific functions:\n+  static DomResult maybe_all_controls_dominate(Node* dom, Node* sub);\n+  static bool all_controls_dominate(Node* dom, Node* sub) {\n+    DomResult dom_result = maybe_all_controls_dominate(dom, sub);\n+    return dom_result == DomResult::Dominate;\n+  }\n","filename":"src\/hotspot\/share\/opto\/memnode.hpp","additions":7,"deletions":2,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -1252,1 +1253,1 @@\n-bool Node::dominates(Node* sub, Node_List &nlist) {\n+Node::DomResult Node::dominates(Node* sub, Node_List &nlist) {\n@@ -1272,1 +1273,4 @@\n-    if (sub->is_top())  break; \/\/ Conservative answer for dead code.\n+    if (sub->is_top()) {\n+      \/\/ Conservative answer for dead code.\n+      return DomResult::EncounteredDeadCode;\n+    }\n@@ -1277,1 +1281,1 @@\n-        return true;\n+        return DomResult::Dominate;\n@@ -1291,1 +1295,1 @@\n-      return met_dom;\n+      return met_dom ? DomResult::Dominate : DomResult::NotDominate;\n@@ -1322,1 +1326,1 @@\n-            return false;\n+            return DomResult::NotDominate;\n@@ -1365,2 +1369,1 @@\n-  \/\/ Conservative answer for dead code.\n-  return false;\n+  return DomResult::NotDominate;\n","filename":"src\/hotspot\/share\/opto\/node.cpp","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -837,0 +838,1 @@\n+#ifdef ASSERT\n@@ -838,0 +840,1 @@\n+#endif\n@@ -1108,0 +1111,6 @@\n+  \/\/ Results of the dominance analysis.\n+  enum class DomResult {\n+    NotDominate,         \/\/ 'this' node does not dominate 'sub'.\n+    Dominate,            \/\/ 'this' node dominates or is equal to 'sub'.\n+    EncounteredDeadCode  \/\/ Result is undefined due to encountering dead code.\n+  };\n@@ -1109,1 +1118,1 @@\n-  bool dominates(Node* sub, Node_List &nlist);\n+  DomResult dominates(Node* sub, Node_List &nlist);\n","filename":"src\/hotspot\/share\/opto\/node.hpp","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -361,1 +361,1 @@\n-  Node*         _alloc_with_final;   \/\/ An allocation node with final field\n+  Node*         _alloc_with_final_or_stable; \/\/ An allocation node with final or @Stable field\n@@ -406,4 +406,4 @@\n-  Node*    alloc_with_final() const   { return _alloc_with_final; }\n-  void set_alloc_with_final(Node* n)  {\n-    assert((_alloc_with_final == nullptr) || (_alloc_with_final == n), \"different init objects?\");\n-    _alloc_with_final = n;\n+  Node*    alloc_with_final_or_stable() const   { return _alloc_with_final_or_stable; }\n+  void set_alloc_with_final_or_stable(Node* n)  {\n+    assert((_alloc_with_final_or_stable == nullptr) || (_alloc_with_final_or_stable == n), \"different init objects?\");\n+    _alloc_with_final_or_stable = n;\n","filename":"src\/hotspot\/share\/opto\/parse.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -415,1 +415,1 @@\n-  _alloc_with_final = nullptr;\n+  _alloc_with_final_or_stable = nullptr;\n@@ -991,2 +991,2 @@\n-  \/\/ 1. The constructor wrote a final. The effects of all initializations\n-  \/\/    must be committed to memory before any code after the constructor\n+  \/\/ 1. The constructor wrote a final or a @Stable field. All these\n+  \/\/    initializations must be ordered before any code after the constructor\n@@ -1017,1 +1017,1 @@\n-       (wrote_final() ||\n+       (wrote_final() || wrote_stable() ||\n@@ -1020,0 +1020,1 @@\n+    Node* recorded_alloc = alloc_with_final_or_stable();\n@@ -1021,1 +1022,1 @@\n-                          alloc_with_final());\n+                          recorded_alloc);\n@@ -1026,2 +1027,2 @@\n-    if (DoEscapeAnalysis && alloc_with_final()) {\n-      AllocateNode* alloc = AllocateNode::Ideal_allocation(alloc_with_final());\n+    if (DoEscapeAnalysis && (recorded_alloc != nullptr)) {\n+      AllocateNode* alloc = AllocateNode::Ideal_allocation(recorded_alloc);\n@@ -1032,13 +1033,1 @@\n-      tty->print_cr(\" writes finals and needs a memory barrier\");\n-    }\n-  }\n-\n-  \/\/ Any method can write a @Stable field; insert memory barriers\n-  \/\/ after those also. Can't bind predecessor allocation node (if any)\n-  \/\/ with barrier because allocation doesn't always dominate\n-  \/\/ MemBarRelease.\n-  if (wrote_stable()) {\n-    _exits.insert_mem_bar(Op_MemBarRelease);\n-    if (PrintOpto && (Verbose || WizardMode)) {\n-      method()->print_name();\n-      tty->print_cr(\" writes @Stable and needs a memory barrier\");\n+      tty->print_cr(\" writes finals\/@Stable and needs a memory barrier\");\n@@ -2137,2 +2126,2 @@\n-  Node* access_flags_addr = basic_plus_adr(klass, klass, in_bytes(Klass::access_flags_offset()));\n-  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::INT, T_INT, MemNode::unordered);\n+  Node* access_flags_addr = basic_plus_adr(klass, klass, in_bytes(Klass::misc_flags_offset()));\n+  Node* access_flags = make_load(nullptr, access_flags_addr, TypeInt::UBYTE, T_BOOLEAN, MemNode::unordered);\n@@ -2140,1 +2129,1 @@\n-  Node* mask  = _gvn.transform(new AndINode(access_flags, intcon(JVM_ACC_HAS_FINALIZER)));\n+  Node* mask  = _gvn.transform(new AndINode(access_flags, intcon(KlassFlags::_misc_has_finalizer)));\n","filename":"src\/hotspot\/share\/opto\/parse1.cpp","additions":12,"deletions":23,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -239,1 +239,4 @@\n-    \/\/ Note the presence of writes to final non-static fields, so that we\n+    \/\/ If the field is @Stable, we can be in any method, but we only care about\n+    \/\/ constructors at this point.\n+    \/\/\n+    \/\/ Note the presence of writes to final\/@Stable non-static fields, so that we\n@@ -242,3 +245,7 @@\n-    \/\/ Any method can write a @Stable field; insert memory barriers after those also.\n-    if (field->is_final()) {\n-      set_wrote_final(true);\n+    if (field->is_final() || field->is_stable()) {\n+      if (field->is_final()) {\n+        set_wrote_final(true);\n+      }\n+      if (field->is_stable()) {\n+        set_wrote_stable(true);\n+      }\n@@ -248,2 +255,1 @@\n-        \/\/ Can't bind stable with its allocation, only record allocation for final field.\n-        set_alloc_with_final(obj);\n+        set_alloc_with_final_or_stable(obj);\n@@ -252,3 +258,0 @@\n-    if (field->is_stable()) {\n-      set_wrote_stable(true);\n-    }\n","filename":"src\/hotspot\/share\/opto\/parse3.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1626,17 +1626,0 @@\n-  \/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n-  \/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n-  if (cop == Op_CmpU &&\n-      cmp1_op == Op_AndI) {\n-    Node* bound = nullptr;\n-    if (_test._test == BoolTest::le) {\n-      bound = cmp2;\n-    } else if (_test._test == BoolTest::lt &&\n-               cmp2->Opcode() == Op_AddI &&\n-               cmp2->in(2)->find_int_con(0) == 1) {\n-      bound = cmp2->in(1);\n-    }\n-    if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n-      return ConINode::make(1);\n-    }\n-  }\n-\n@@ -1644,1 +1627,1 @@\n-  \/\/ This is the off-by-one variant of the above\n+  \/\/ This is the off-by-one variant of ((x & m) u<= m)\n@@ -1830,0 +1813,25 @@\n+\/\/ Change ((x & m) u<= m) or ((m & x) u<= m) to always true\n+\/\/ Same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+const Type* BoolNode::Value_cmpu_and_mask(PhaseValues* phase) const {\n+  Node* cmp = in(1);\n+  if (cmp != nullptr && cmp->Opcode() == Op_CmpU) {\n+    Node* cmp1 = cmp->in(1);\n+    Node* cmp2 = cmp->in(2);\n+\n+    if (cmp1->Opcode() == Op_AndI) {\n+      Node* bound = nullptr;\n+      if (_test._test == BoolTest::le) {\n+        bound = cmp2;\n+      } else if (_test._test == BoolTest::lt && cmp2->Opcode() == Op_AddI && cmp2->in(2)->find_int_con(0) == 1) {\n+        bound = cmp2->in(1);\n+      }\n+\n+      if (cmp1->in(2) == bound || cmp1->in(1) == bound) {\n+        return TypeInt::ONE;\n+      }\n+    }\n+  }\n+\n+  return nullptr;\n+}\n+\n@@ -1833,0 +1841,5 @@\n+  const Type* t = Value_cmpu_and_mask(phase);\n+  if (t != nullptr) {\n+    return t;\n+  }\n+\n","filename":"src\/hotspot\/share\/opto\/subnode.cpp","additions":32,"deletions":19,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -350,0 +350,1 @@\n+  const Type* Value_cmpu_and_mask(PhaseValues* phase) const;\n","filename":"src\/hotspot\/share\/opto\/subnode.hpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -694,3 +694,1 @@\n-  BasicType longer_bt = longer_type_for_conversion(s1);\n-  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2 ||\n-      (longer_bt != T_ILLEGAL && Matcher::max_vector_size_auto_vectorization(longer_bt) < 2)) {\n+  if (Matcher::max_vector_size_auto_vectorization(bt1) < 2) {\n@@ -2275,1 +2273,1 @@\n-  for (uint i = 1; i < pack->size(); i++) {\n+  for (uint i = 0; i < pack->size(); i++) {\n@@ -2445,21 +2443,0 @@\n-BasicType SuperWord::longer_type_for_conversion(Node* n) const {\n-  if (!(VectorNode::is_convert_opcode(n->Opcode()) ||\n-        VectorNode::is_scalar_op_that_returns_int_but_vector_op_returns_long(n->Opcode())) ||\n-      !in_bb(n->in(1))) {\n-    return T_ILLEGAL;\n-  }\n-  assert(in_bb(n), \"must be in the bb\");\n-  BasicType src_t = velt_basic_type(n->in(1));\n-  BasicType dst_t = velt_basic_type(n);\n-  \/\/ Do not use superword for non-primitives.\n-  \/\/ Superword does not support casting involving unsigned types.\n-  if (!is_java_primitive(src_t) || is_unsigned_subword_type(src_t) ||\n-      !is_java_primitive(dst_t) || is_unsigned_subword_type(dst_t)) {\n-    return T_ILLEGAL;\n-  }\n-  int src_size = type2aelembytes(src_t);\n-  int dst_size = type2aelembytes(dst_t);\n-  return src_size == dst_size ? T_ILLEGAL\n-                              : (src_size > dst_size ? src_t : dst_t);\n-}\n-\n","filename":"src\/hotspot\/share\/opto\/superword.cpp","additions":2,"deletions":25,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -626,3 +626,0 @@\n-  \/\/ Return the longer type for vectorizable type-conversion node or illegal type for other nodes.\n-  BasicType longer_type_for_conversion(Node* n) const;\n-\n","filename":"src\/hotspot\/share\/opto\/superword.hpp","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2010, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2010, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,1 @@\n-\/\/ *.include.hpp, since including them decreased build performance.\n+\/\/ *.inline.hpp, since including them decreased build performance.\n","filename":"src\/hotspot\/share\/precompiled\/precompiled.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -105,1 +105,1 @@\n-static jint CurrentVersion = JNI_VERSION_21;\n+static jint CurrentVersion = JNI_VERSION_24;\n@@ -1159,1 +1159,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1212,1 +1212,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1263,1 +1263,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_VIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1356,1 +1356,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1409,1 +1409,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1461,1 +1461,1 @@\n-  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_0); \\\n+  jni_invoke_nonstatic(env, &jvalue, obj, JNI_NONVIRTUAL, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1557,1 +1557,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1612,2 +1612,2 @@\n-  k->initialize(CHECK_0); \\\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  k->initialize(CHECK_(ResultType{})); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -1666,1 +1666,1 @@\n-  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_0); \\\n+  jni_invoke_static(env, &jvalue, nullptr, JNI_STATIC, methodID, &ap, CHECK_(ResultType{})); \\\n@@ -2224,1 +2224,1 @@\n- HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTH_ENTRY(env, string);\n@@ -2226,1 +2226,1 @@\n-  jsize ret = java_lang_String::utf8_length(java_string);\n+  jsize ret = java_lang_String::utf8_length_as_int(java_string);\n@@ -2231,0 +2231,8 @@\n+JNI_ENTRY(jlong, jni_GetStringUTFLengthAsLong(JNIEnv *env, jstring string))\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_ENTRY(env, string);\n+  oop java_string = JNIHandles::resolve_non_null(string);\n+  size_t ret = java_lang_String::utf8_length(java_string);\n+  HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_RETURN(ret);\n+return checked_cast<jlong>(ret);\n+JNI_END\n+\n@@ -2239,1 +2247,2 @@\n-    \/* JNI Specification states return null on OOM *\/\n+    \/\/ JNI Specification states return null on OOM.\n+    \/\/ The resulting sequence doesn't have to be NUL-terminated but we do.\n@@ -2242,1 +2251,1 @@\n-      java_lang_String::as_utf8_string(java_string, s_value, result, (int) length + 1);\n+      java_lang_String::as_utf8_string(java_string, s_value, result, length + 1);\n@@ -3400,1 +3409,5 @@\n-    jni_IsVirtualThread\n+    jni_IsVirtualThread,\n+\n+    \/\/ Large UTF8 support\n+\n+    jni_GetStringUTFLengthAsLong\n","filename":"src\/hotspot\/share\/prims\/jni.cpp","additions":29,"deletions":16,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -1514,0 +1514,21 @@\n+    jlong full_length =  UNCHECKED()->GetStringUTFLengthAsLong(env,str);\n+    if (full_length > result) {\n+      ResourceMark rm(thr);\n+      stringStream ss;\n+      ss.print(\"WARNING: large String with modified UTF-8 length \" JLONG_FORMAT\n+                \" is reporting a reduced length of %d - use GetStringUTFLengthAsLong instead\",\n+                full_length, result);\n+      NativeReportJNIWarning(thr, ss.as_string());\n+    }\n+    functionExit(thr);\n+    return result;\n+JNI_END\n+\n+JNI_ENTRY_CHECKED(jlong,\n+  checked_jni_GetStringUTFLengthAsLong(JNIEnv *env,\n+                                       jstring str))\n+    functionEnter(thr);\n+    IN_VM(\n+      checkString(thr, str);\n+    )\n+    jlong result = UNCHECKED()->GetStringUTFLengthAsLong(env,str);\n@@ -2286,1 +2307,6 @@\n-    checked_jni_IsVirtualThread\n+    checked_jni_IsVirtualThread,\n+\n+    \/\/ Large UTF8 support\n+\n+    checked_jni_GetStringUTFLengthAsLong\n+\n","filename":"src\/hotspot\/share\/prims\/jniCheck.cpp","additions":27,"deletions":1,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -3406,1 +3406,1 @@\n-      THROW_HANDLE_0(h_exception);\n+      THROW_HANDLE_NULL(h_exception);\n@@ -3451,0 +3451,4 @@\n+JVM_ENTRY_NO_ENV(jboolean, JVM_IsStaticallyLinked(void))\n+  return is_vm_statically_linked() ? JNI_TRUE : JNI_FALSE;\n+JVM_END\n+\n","filename":"src\/hotspot\/share\/prims\/jvm.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1324,1 +1324,1 @@\n-      int utf8_length = 0;\n+      size_t utf8_length = 0;\n@@ -2537,0 +2537,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2549,0 +2550,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2561,0 +2563,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n@@ -2573,0 +2576,1 @@\n+  JvmtiVTMSTransitionDisabler disabler;\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnv.cpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -59,0 +59,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1468,1 +1469,0 @@\n-  ObjectMonitor *mon = nullptr;\n@@ -1498,3 +1498,5 @@\n-  if (mark.has_monitor()) {\n-    mon = mark.monitor();\n-    assert(mon != nullptr, \"must have monitor\");\n+  ObjectMonitor* mon = mark.has_monitor()\n+      ? ObjectSynchronizer::read_monitor(current_thread, hobj(), mark)\n+      : nullptr;\n+\n+  if (mon != nullptr) {\n","filename":"src\/hotspot\/share\/prims\/jvmtiEnvBase.cpp","additions":6,"deletions":4,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"src\/hotspot\/share\/prims\/jvmtiEventController.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -932,3 +932,2 @@\n-    if (_thread->is_in_any_VTMS_transition()) {\n-      return; \/\/ no events should be posted if thread is in any VTMS transition\n-    }\n+    assert(!_thread->is_in_any_VTMS_transition(), \"CFLH events are not allowed in any VTMS transition\");\n+\n@@ -1094,2 +1093,3 @@\n-  if (JavaThread::current()->is_in_tmp_VTMS_transition()) {\n-    return false; \/\/ skip CFLH events in tmp VTMS transition\n+\n+  if (JavaThread::current()->is_in_any_VTMS_transition()) {\n+    return false; \/\/ no events should be posted if thread is in any VTMS transition\n","filename":"src\/hotspot\/share\/prims\/jvmtiExport.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -276,1 +276,9 @@\n-  Handle name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle jni_class(THREAD, method->method_holder()->java_mirror());\n+  Handle jni_name_arg = java_lang_String::create_from_str(jni_name, CHECK_NULL);\n+  Handle java_name_arg = java_lang_String::create_from_str(method->name()->as_C_string(), CHECK_NULL);\n+\n+  JavaCallArguments args;\n+  args.push_oop(loader);\n+  args.push_oop(jni_class);\n+  args.push_oop(jni_name_arg);\n+  args.push_oop(java_name_arg);\n@@ -282,4 +290,2 @@\n-                         vmSymbols::classloader_string_long_signature(),\n-                         \/\/ Arguments\n-                         loader,\n-                         name_arg,\n+                         vmSymbols::classloader_class_string_string_long_signature(),\n+                         &args,\n@@ -412,0 +418,8 @@\n+  if (THREAD->has_pending_exception()) {\n+    oop exception = THREAD->pending_exception();\n+    if (exception->is_a(vmClasses::IllegalCallerException_klass())) {\n+      \/\/ we already have a pending exception from the restricted method check, just return\n+      return nullptr;\n+    }\n+  }\n+\n","filename":"src\/hotspot\/share\/prims\/nativeLookup.cpp","additions":19,"deletions":5,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -802,0 +802,1 @@\n+    ResourceMark rm(THREAD);\n@@ -2584,1 +2585,1 @@\n-      current_frame->print_value_on(&st, nullptr);\n+      current_frame->print_value_on(&st);\n","filename":"src\/hotspot\/share\/prims\/whitebox.cpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -308,0 +308,2 @@\n+#define ILLEGAL_NATIVE_ACCESS \"illegal.native.access\"\n+#define ILLEGAL_NATIVE_ACCESS_LEN 21\n@@ -329,0 +331,1 @@\n+        matches_property_suffix(property_suffix, ILLEGAL_NATIVE_ACCESS, ILLEGAL_NATIVE_ACCESS_LEN) ||\n@@ -506,0 +509,3 @@\n+#ifdef LINUX\n+  { \"UseLinuxPosixThreadCPUClocks\", JDK_Version::jdk(24), JDK_Version::jdk(25), JDK_Version::jdk(26) },\n+#endif\n@@ -1819,0 +1825,4 @@\n+  if (UseObjectMonitorTable) {\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable not supported on this platform\");\n+  }\n@@ -1821,0 +1831,6 @@\n+  if (UseObjectMonitorTable && LockingMode != LM_LIGHTWEIGHT) {\n+    \/\/ ObjectMonitorTable requires lightweight locking.\n+    FLAG_SET_CMDLINE(UseObjectMonitorTable, false);\n+    warning(\"UseObjectMonitorTable requires LM_LIGHTWEIGHT\");\n+  }\n+\n@@ -2236,0 +2252,4 @@\n+    } else if (match_option(option, \"--illegal-native-access=\", &tail)) {\n+      if (!create_module_property(\"jdk.module.illegal.native.access\", tail, InternalProperty)) {\n+        return JNI_ENOMEM;\n+      }\n","filename":"src\/hotspot\/share\/runtime\/arguments.cpp","additions":20,"deletions":0,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -1121,1 +1122,1 @@\n-  size_t offset = pointer_delta(dest, aligned_dest, 1);\n+  uint32_t offset = checked_cast<uint32_t>(pointer_delta(dest, aligned_dest, 1));\n","filename":"src\/hotspot\/share\/runtime\/atomic.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -27,1 +27,2 @@\n-#include \"runtime\/basicLock.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n@@ -32,5 +33,12 @@\n-  markWord mark_word = displaced_header();\n-  if (mark_word.value() != 0) {\n-    \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n-    bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n-    mark_word.print_on(st, print_monitor_info);\n+  if (UseObjectMonitorTable) {\n+    ObjectMonitor* mon = object_monitor_cache();\n+    if (mon != nullptr) {\n+      mon->print_on(st);\n+    }\n+  } else if (LockingMode == LM_LEGACY) {\n+    markWord mark_word = displaced_header();\n+    if (mark_word.value() != 0) {\n+      \/\/ Print monitor info if there's an owning oop and it refers to this BasicLock.\n+      bool print_monitor_info = (owner != nullptr) && (owner->mark() == markWord::from_pointer((void*)this));\n+      mark_word.print_on(st, print_monitor_info);\n+    }\n@@ -85,0 +93,5 @@\n+  } else if (UseObjectMonitorTable) {\n+    \/\/ Preserve the ObjectMonitor*, the cache is cleared when a box is reused\n+    \/\/ and only read while the lock is held, so no stale ObjectMonitor* is\n+    \/\/ encountered.\n+    dest->set_object_monitor_cache(object_monitor_cache());\n@@ -88,1 +101,1 @@\n-    dest->set_displaced_header(markWord(badDispHeaderDeopt));\n+    dest->set_bad_metadata_deopt();\n","filename":"src\/hotspot\/share\/runtime\/basicLock.cpp","additions":20,"deletions":7,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -37,0 +38,3 @@\n+  \/\/ * For LM_MONITOR\n+  \/\/ Unused.\n+  \/\/ * For LM_LEGACY\n@@ -39,1 +43,9 @@\n-  volatile markWord _displaced_header;\n+  \/\/ * For LM_LIGHTWEIGHT\n+  \/\/ Used as a cache of the ObjectMonitor* used when locking. Must either\n+  \/\/ be nullptr or the ObjectMonitor* used when locking.\n+  volatile uintptr_t _metadata;\n+\n+  uintptr_t get_metadata() const { return Atomic::load(&_metadata); }\n+  void set_metadata(uintptr_t value) { Atomic::store(&_metadata, value); }\n+  static int metadata_offset_in_bytes() { return (int)offset_of(BasicLock, _metadata); }\n+\n@@ -41,3 +53,2 @@\n-  markWord displaced_header() const {\n-    return Atomic::load(&_displaced_header);\n-  }\n+  \/\/ LM_MONITOR\n+  void set_bad_metadata_deopt() { set_metadata(badDispHeaderDeopt); }\n@@ -45,3 +56,10 @@\n-  void set_displaced_header(markWord header) {\n-    Atomic::store(&_displaced_header, header);\n-  }\n+  \/\/ LM_LEGACY\n+  inline markWord displaced_header() const;\n+  inline void set_displaced_header(markWord header);\n+  static int displaced_header_offset_in_bytes() { return metadata_offset_in_bytes(); }\n+\n+  \/\/ LM_LIGHTWEIGHT\n+  inline ObjectMonitor* object_monitor_cache() const;\n+  inline void clear_object_monitor_cache();\n+  inline void set_object_monitor_cache(ObjectMonitor* mon);\n+  static int object_monitor_cache_offset_in_bytes() { return metadata_offset_in_bytes(); }\n@@ -53,2 +71,0 @@\n-\n-  static int displaced_header_offset_in_bytes() { return (int)offset_of(BasicLock, _displaced_header); }\n","filename":"src\/hotspot\/share\/runtime\/basicLock.hpp","additions":25,"deletions":9,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -0,0 +1,62 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+#define SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n+\n+#include \"runtime\/basicLock.hpp\"\n+\n+inline markWord BasicLock::displaced_header() const {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  return markWord(get_metadata());\n+}\n+\n+inline void BasicLock::set_displaced_header(markWord header) {\n+  assert(LockingMode == LM_LEGACY, \"must be\");\n+  Atomic::store(&_metadata, header.value());\n+}\n+\n+inline ObjectMonitor* BasicLock::object_monitor_cache() const {\n+  assert(UseObjectMonitorTable, \"must be\");\n+#if defined(X86) || defined(AARCH64) || defined(RISCV64)\n+  return reinterpret_cast<ObjectMonitor*>(get_metadata());\n+#else\n+  \/\/ Other platforms do not make use of the cache yet,\n+  \/\/ and are not as careful with maintaining the invariant\n+  \/\/ that the metadata either is nullptr or ObjectMonitor*.\n+  return nullptr;\n+#endif\n+}\n+\n+inline void BasicLock::clear_object_monitor_cache() {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(0);\n+}\n+\n+inline void BasicLock::set_object_monitor_cache(ObjectMonitor* mon) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  set_metadata(reinterpret_cast<uintptr_t>(mon));\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_BASICLOCK_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/basicLock.inline.hpp","additions":62,"deletions":0,"binary":false,"changes":62,"status":"added"},{"patch":"@@ -42,0 +42,1 @@\n+  friend class JVMCIVMStructs;\n@@ -81,1 +82,1 @@\n-  uint _pin_count;\n+  uint32_t _pin_count;\n@@ -111,1 +112,1 @@\n-    if (_pin_count == UINT_MAX) return false;\n+    if (_pin_count == UINT32_MAX) return false;\n","filename":"src\/hotspot\/share\/runtime\/continuationEntry.hpp","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -880,1 +880,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -889,1 +889,1 @@\n-    DEBUG_ONLY(hf.print_value_on(&ls, nullptr);)\n+    DEBUG_ONLY(hf.print_value_on(&ls);)\n@@ -2030,1 +2030,1 @@\n-    heap_frame.print_value_on(&ls, nullptr);\n+    heap_frame.print_value_on(&ls);\n@@ -2127,1 +2127,1 @@\n-    hf.print_value_on(&ls, nullptr);\n+    hf.print_value_on(&ls);\n@@ -2397,1 +2397,1 @@\n-    _cont.last_frame().print_value_on(&ls, nullptr);\n+    _cont.last_frame().print_value_on(&ls);\n@@ -2409,1 +2409,1 @@\n-    f.print_value_on(&ls, nullptr);\n+    f.print_value_on(&ls);\n@@ -2470,1 +2470,1 @@\n-    frame(sp).print_value_on(&ls, nullptr);\n+    frame(sp).print_value_on(&ls);\n","filename":"src\/hotspot\/share\/runtime\/continuationFreezeThaw.cpp","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -78,0 +79,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -87,1 +90,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -1637,1 +1640,11 @@\n-              mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              if (LockingMode == LM_LEGACY) {\n+                mon_info->lock()->set_displaced_header(markWord::unused_mark());\n+              } else if (UseObjectMonitorTable) {\n+                mon_info->lock()->clear_object_monitor_cache();\n+              }\n+#ifdef ASSERT\n+              else {\n+                assert(LockingMode == LM_MONITOR || !UseObjectMonitorTable, \"must be\");\n+                mon_info->lock()->set_bad_metadata_deopt();\n+              }\n+#endif\n@@ -1643,0 +1656,1 @@\n+        BasicLock* lock = mon_info->lock();\n@@ -1645,3 +1659,7 @@\n-          \/\/ Inflate the locks instead. Enter then inflate to avoid races with\n-          \/\/ deflation.\n-          ObjectSynchronizer::enter_for(obj, nullptr, deoptee_thread);\n+          \/\/ Entering may create an invalid lock stack. Inflate the lock if it\n+          \/\/ was fast_locked to restore the valid lock stack.\n+          ObjectSynchronizer::enter_for(obj, lock, deoptee_thread);\n+          if (deoptee_thread->lock_stack().contains(obj())) {\n+            LightweightSynchronizer::inflate_fast_locked_object(obj(), ObjectSynchronizer::InflateCause::inflate_cause_vm_internal,\n+                                                                deoptee_thread, thread);\n+          }\n@@ -1649,2 +1667,3 @@\n-          ObjectMonitor* mon = ObjectSynchronizer::inflate_for(deoptee_thread, obj(), ObjectSynchronizer::inflate_cause_vm_internal);\n-          assert(mon->owner() == deoptee_thread, \"must be\");\n+          assert(obj->mark().has_monitor(), \"must be\");\n+          assert(!deoptee_thread->lock_stack().contains(obj()), \"must be\");\n+          assert(ObjectSynchronizer::read_monitor(thread, obj(), obj->mark())->owner() == deoptee_thread, \"must be\");\n@@ -1652,1 +1671,0 @@\n-          BasicLock* lock = mon_info->lock();\n","filename":"src\/hotspot\/share\/runtime\/deoptimization.cpp","additions":26,"deletions":8,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -514,1 +514,1 @@\n-void frame::print_value_on(outputStream* st, JavaThread *thread) const {\n+void frame::print_value_on(outputStream* st) const {\n@@ -553,1 +553,1 @@\n-  print_value_on(st,nullptr);\n+  print_value_on(st);\n","filename":"src\/hotspot\/share\/runtime\/frame.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -390,0 +390,1 @@\n+#ifdef ASSERT\n@@ -391,0 +392,1 @@\n+#endif\n@@ -434,2 +436,2 @@\n-  void print_value() const { print_value_on(tty,nullptr); }\n-  void print_value_on(outputStream* st, JavaThread *thread) const;\n+  void print_value() const { print_value_on(tty); }\n+  void print_value_on(outputStream* st) const;\n@@ -441,0 +443,1 @@\n+#ifndef PRODUCT\n@@ -443,0 +446,1 @@\n+#endif\n@@ -495,0 +499,1 @@\n+#ifdef ASSERT\n@@ -498,0 +503,1 @@\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/frame.hpp","additions":8,"deletions":2,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -1959,0 +1959,11 @@\n+  product(bool, UseObjectMonitorTable, false, DIAGNOSTIC,                   \\\n+          \"With Lightweight Locking mode, use a table to record inflated \"  \\\n+          \"monitors rather than the first word of the object.\")             \\\n+                                                                            \\\n+  product(int, LightweightFastLockingSpins, 13, DIAGNOSTIC,                 \\\n+          \"Specifies the number of times lightweight fast locking will \"    \\\n+          \"attempt to CAS the markWord before inflating. Between each \"     \\\n+          \"CAS it will spin for exponentially more time, resulting in \"     \\\n+          \"a total number of spins on the order of O(2^value)\")             \\\n+          range(1, 30)                                                      \\\n+                                                                            \\\n","filename":"src\/hotspot\/share\/runtime\/globals.hpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -129,0 +129,1 @@\n+  \/\/ stub routines in initial blob are referenced by later generated code\n@@ -130,0 +131,2 @@\n+  \/\/ stack overflow exception blob is referenced by the interpreter\n+  SharedRuntime::generate_initial_stubs();\n@@ -147,0 +150,3 @@\n+#if INCLUDE_JFR\n+  SharedRuntime::generate_jfr_stubs();\n+#endif\n","filename":"src\/hotspot\/share\/runtime\/init.cpp","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,0 +62,3 @@\n+\/\/ This is defined in linkType.cpp due to linking restraints\n+extern bool is_vm_statically_linked();\n+\n","filename":"src\/hotspot\/share\/runtime\/java.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -360,8 +360,0 @@\n-  \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n-  \/\/ so we can go compiled via a i2c. Otherwise initial entry method will always\n-  \/\/ run interpreted.\n-  address entry_point = method->from_interpreted_entry();\n-  if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n-    entry_point = method->interpreter_entry();\n-  }\n-\n@@ -401,0 +393,12 @@\n+\n+      address entry_point;\n+      {\n+        \/\/ The enter_interp_only_mode use handshake to set interp_only mode\n+        \/\/ so no safepoint should be allowed between is_interp_only_mode() and call\n+        NoSafepointVerifier nsv;\n+        if (JvmtiExport::can_post_interpreter_events() && thread->is_interp_only_mode()) {\n+          entry_point = method->interpreter_entry();\n+        } else {\n+          \/\/ Since the call stub sets up like the interpreter we call the from_interpreted_entry\n+          \/\/ so we can go compiled via a i2c.\n+          entry_point = method->from_interpreted_entry();\n@@ -402,10 +406,13 @@\n-      \/\/ Gets the alternative target (if any) that should be called\n-      Handle alternative_target = args->alternative_target();\n-      if (!alternative_target.is_null()) {\n-        \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n-        \/\/ transition in JavaCallWrapper constructor so that it is safe with\n-        \/\/ respect to nmethod sweeping.\n-        address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n-        if (verified_entry_point != nullptr) {\n-          thread->set_jvmci_alternate_call_target(verified_entry_point);\n-          entry_point = method->adapter()->get_i2c_entry();\n+          \/\/ Gets the alternative target (if any) that should be called\n+          Handle alternative_target = args->alternative_target();\n+          if (!alternative_target.is_null()) {\n+            \/\/ Must extract verified entry point from HotSpotNmethod after VM to Java\n+            \/\/ transition in JavaCallWrapper constructor so that it is safe with\n+            \/\/ respect to nmethod sweeping.\n+            address verified_entry_point = (address) HotSpotJVMCI::InstalledCode::entryPoint(nullptr, alternative_target());\n+            if (verified_entry_point != nullptr) {\n+              thread->set_jvmci_alternate_call_target(verified_entry_point);\n+              entry_point = method->adapter()->get_i2c_entry();\n+            }\n+          }\n+#endif\n@@ -414,1 +421,0 @@\n-#endif\n","filename":"src\/hotspot\/share\/runtime\/javaCalls.cpp","additions":26,"deletions":20,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -507,1 +507,2 @@\n-  _lock_stack(this) {\n+  _lock_stack(this),\n+  _om_cache(this) {\n@@ -806,0 +807,2 @@\n+  om_clear_monitor_cache();\n+\n@@ -1906,1 +1909,1 @@\n-    fst.current()->print_value_on(tty, this);\n+    fst.current()->print_value_on(tty);\n","filename":"src\/hotspot\/share\/runtime\/javaThread.cpp","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -64,0 +64,1 @@\n+class ObjectMonitor;\n@@ -1168,0 +1169,1 @@\n+  OMCache _om_cache;\n@@ -1179,0 +1181,7 @@\n+  static ByteSize om_cache_offset()        { return byte_offset_of(JavaThread, _om_cache); }\n+  static ByteSize om_cache_oops_offset()   { return om_cache_offset() + OMCache::entries_offset(); }\n+\n+  void om_set_monitor_cache(ObjectMonitor* monitor);\n+  void om_clear_monitor_cache();\n+  ObjectMonitor* om_get_from_monitor_cache(oop obj);\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.hpp","additions":9,"deletions":0,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+#include \"runtime\/lockStack.inline.hpp\"\n@@ -40,0 +41,1 @@\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -242,0 +244,21 @@\n+inline void JavaThread::om_set_monitor_cache(ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor != nullptr, \"use om_clear_monitor_cache to clear\");\n+  assert(this == current() || monitor->owner_raw() == this, \"only add owned monitors for other threads\");\n+  assert(this == current() || is_obj_deopt_suspend(), \"thread must not run concurrently\");\n+\n+  _om_cache.set_monitor(monitor);\n+}\n+\n+inline void JavaThread::om_clear_monitor_cache() {\n+  if (UseObjectMonitorTable) {\n+    _om_cache.clear();\n+  }\n+}\n+\n+inline ObjectMonitor* JavaThread::om_get_from_monitor_cache(oop obj) {\n+  assert(obj != nullptr, \"do not look for null objects\");\n+  assert(this == current(), \"only get own thread locals\");\n+  return _om_cache.get_monitor(obj);\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/javaThread.inline.hpp","additions":23,"deletions":0,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,1223 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+\n+#include \"classfile\/vmSymbols.hpp\"\n+#include \"jfrfiles\/jfrEventClasses.hpp\"\n+#include \"logging\/log.hpp\"\n+#include \"memory\/allStatic.hpp\"\n+#include \"memory\/resourceArea.hpp\"\n+#include \"nmt\/memflags.hpp\"\n+#include \"oops\/oop.inline.hpp\"\n+#include \"runtime\/atomic.hpp\"\n+#include \"runtime\/basicLock.inline.hpp\"\n+#include \"runtime\/globals_extension.hpp\"\n+#include \"runtime\/interfaceSupport.inline.hpp\"\n+#include \"runtime\/javaThread.inline.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/lockStack.inline.hpp\"\n+#include \"runtime\/mutexLocker.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n+#include \"runtime\/os.hpp\"\n+#include \"runtime\/perfData.inline.hpp\"\n+#include \"runtime\/safepointMechanism.inline.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n+#include \"runtime\/trimNativeHeap.hpp\"\n+#include \"utilities\/concurrentHashTable.inline.hpp\"\n+#include \"utilities\/concurrentHashTableTasks.inline.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n+\n+\/\/ ConcurrentHashTable storing links from objects to ObjectMonitors\n+class ObjectMonitorTable : AllStatic {\n+  struct Config {\n+    using Value = ObjectMonitor*;\n+    static uintx get_hash(Value const& value, bool* is_dead) {\n+      return (uintx)value->hash();\n+    }\n+    static void* allocate_node(void* context, size_t size, Value const& value) {\n+      ObjectMonitorTable::inc_items_count();\n+      return AllocateHeap(size, MEMFLAGS::mtObjectMonitor);\n+    };\n+    static void free_node(void* context, void* memory, Value const& value) {\n+      ObjectMonitorTable::dec_items_count();\n+      FreeHeap(memory);\n+    }\n+  };\n+  using ConcurrentTable = ConcurrentHashTable<Config, MEMFLAGS::mtObjectMonitor>;\n+\n+  static ConcurrentTable* _table;\n+  static volatile size_t _items_count;\n+  static size_t _table_size;\n+  static volatile bool _resize;\n+\n+  class Lookup : public StackObj {\n+    oop _obj;\n+\n+   public:\n+    explicit Lookup(oop obj) : _obj(obj) {}\n+\n+    uintx get_hash() const {\n+      uintx hash = _obj->mark().hash();\n+      assert(hash != 0, \"should have a hash\");\n+      return hash;\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_refers_to(_obj);\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return false;\n+    }\n+  };\n+\n+  class LookupMonitor : public StackObj {\n+    ObjectMonitor* _monitor;\n+\n+   public:\n+    explicit LookupMonitor(ObjectMonitor* monitor) : _monitor(monitor) {}\n+\n+    uintx get_hash() const {\n+      return _monitor->hash();\n+    }\n+\n+    bool equals(ObjectMonitor** value) {\n+      return (*value) == _monitor;\n+    }\n+\n+    bool is_dead(ObjectMonitor** value) {\n+      assert(*value != nullptr, \"must be\");\n+      return (*value)->object_is_dead();\n+    }\n+  };\n+\n+  static void inc_items_count() {\n+    Atomic::inc(&_items_count);\n+  }\n+\n+  static void dec_items_count() {\n+    Atomic::dec(&_items_count);\n+  }\n+\n+  static double get_load_factor() {\n+    return (double)_items_count \/ (double)_table_size;\n+  }\n+\n+  static size_t table_size(Thread* current = Thread::current()) {\n+    return ((size_t)1) << _table->get_size_log2(current);\n+  }\n+\n+  static size_t max_log_size() {\n+    \/\/ TODO[OMTable]: Evaluate the max size.\n+    \/\/ TODO[OMTable]: Need to fix init order to use Universe::heap()->max_capacity();\n+    \/\/                Using MaxHeapSize directly this early may be wrong, and there\n+    \/\/                are definitely rounding errors (alignment).\n+    const size_t max_capacity = MaxHeapSize;\n+    const size_t min_object_size = CollectedHeap::min_dummy_object_size() * HeapWordSize;\n+    const size_t max_objects = max_capacity \/ MAX2(MinObjAlignmentInBytes, checked_cast<int>(min_object_size));\n+    const size_t log_max_objects = log2i_graceful(max_objects);\n+\n+    return MAX2(MIN2<size_t>(SIZE_BIG_LOG2, log_max_objects), min_log_size());\n+  }\n+\n+  static size_t min_log_size() {\n+    \/\/ ~= log(AvgMonitorsPerThreadEstimate default)\n+    return 10;\n+  }\n+\n+  template<typename V>\n+  static size_t clamp_log_size(V log_size) {\n+    return MAX2(MIN2(log_size, checked_cast<V>(max_log_size())), checked_cast<V>(min_log_size()));\n+  }\n+\n+  static size_t initial_log_size() {\n+    const size_t estimate = log2i(MAX2(os::processor_count(), 1)) + log2i(MAX2(AvgMonitorsPerThreadEstimate, size_t(1)));\n+    return clamp_log_size(estimate);\n+  }\n+\n+  static size_t grow_hint () {\n+    return ConcurrentTable::DEFAULT_GROW_HINT;\n+  }\n+\n+ public:\n+  static void create() {\n+    _table = new ConcurrentTable(initial_log_size(), max_log_size(), grow_hint());\n+    _items_count = 0;\n+    _table_size = table_size();\n+    _resize = false;\n+  }\n+\n+  static void verify_monitor_get_result(oop obj, ObjectMonitor* monitor) {\n+#ifdef ASSERT\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      bool has_monitor = obj->mark().has_monitor();\n+      assert(has_monitor == (monitor != nullptr),\n+          \"Inconsistency between markWord and ObjectMonitorTable has_monitor: %s monitor: \" PTR_FORMAT,\n+          BOOL_TO_STR(has_monitor), p2i(monitor));\n+    }\n+#endif\n+  }\n+\n+  static ObjectMonitor* monitor_get(Thread* current, oop obj) {\n+    ObjectMonitor* result = nullptr;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    verify_monitor_get_result(obj, result);\n+    return result;\n+  }\n+\n+  static void try_notify_grow() {\n+    if (!_table->is_max_size_reached() && !Atomic::load(&_resize)) {\n+      Atomic::store(&_resize, true);\n+      if (Service_lock->try_lock()) {\n+        Service_lock->notify();\n+        Service_lock->unlock();\n+      }\n+    }\n+  }\n+\n+  static bool should_shrink() {\n+    \/\/ Not implemented;\n+    return false;\n+  }\n+\n+  static constexpr double GROW_LOAD_FACTOR = 0.75;\n+\n+  static bool should_grow() {\n+    return get_load_factor() > GROW_LOAD_FACTOR && !_table->is_max_size_reached();\n+  }\n+\n+  static bool should_resize() {\n+    return should_grow() || should_shrink() || Atomic::load(&_resize);\n+  }\n+\n+  template<typename Task, typename... Args>\n+  static bool run_task(JavaThread* current, Task& task, const char* task_name, Args&... args) {\n+    if (task.prepare(current)) {\n+      log_trace(monitortable)(\"Started to %s\", task_name);\n+      TraceTime timer(task_name, TRACETIME_LOG(Debug, monitortable, perf));\n+      while (task.do_task(current, args...)) {\n+        task.pause(current);\n+        {\n+          ThreadBlockInVM tbivm(current);\n+        }\n+        task.cont(current);\n+      }\n+      task.done(current);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool grow(JavaThread* current) {\n+    ConcurrentTable::GrowTask grow_task(_table);\n+    if (run_task(current, grow_task, \"Grow\")) {\n+      _table_size = table_size(current);\n+      log_info(monitortable)(\"Grown to size: %zu\", _table_size);\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  static bool clean(JavaThread* current) {\n+    ConcurrentTable::BulkDeleteTask clean_task(_table);\n+    auto is_dead = [&](ObjectMonitor** monitor) {\n+      return (*monitor)->object_is_dead();\n+    };\n+    auto do_nothing = [&](ObjectMonitor** monitor) {};\n+    NativeHeapTrimmer::SuspendMark sm(\"ObjectMonitorTable\");\n+    return run_task(current, clean_task, \"Clean\", is_dead, do_nothing);\n+  }\n+\n+  static bool resize(JavaThread* current) {\n+    LogTarget(Info, monitortable) lt;\n+    bool success = false;\n+\n+    if (should_grow()) {\n+      lt.print(\"Start growing with load factor %f\", get_load_factor());\n+      success = grow(current);\n+    } else {\n+      if (!_table->is_max_size_reached() && Atomic::load(&_resize)) {\n+        lt.print(\"WARNING: Getting resize hints with load factor %f\", get_load_factor());\n+      }\n+      lt.print(\"Start cleaning with load factor %f\", get_load_factor());\n+      success = clean(current);\n+    }\n+\n+    Atomic::store(&_resize, false);\n+\n+    return success;\n+  }\n+\n+  static ObjectMonitor* monitor_put_get(Thread* current, ObjectMonitor* monitor, oop obj) {\n+    \/\/ Enter the monitor into the concurrent hashtable.\n+    ObjectMonitor* result = monitor;\n+    Lookup lookup_f(obj);\n+    auto found_f = [&](ObjectMonitor** found) {\n+      assert((*found)->object_peek() == obj, \"must be\");\n+      result = *found;\n+    };\n+    bool grow;\n+    _table->insert_get(current, lookup_f, monitor, found_f, &grow);\n+    verify_monitor_get_result(obj, result);\n+    if (grow) {\n+      try_notify_grow();\n+    }\n+    return result;\n+  }\n+\n+  static bool remove_monitor_entry(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    return _table->remove(current, lookup_f);\n+  }\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+    LookupMonitor lookup_f(monitor);\n+    bool result = false;\n+    auto found_f = [&](ObjectMonitor** found) {\n+      result = true;\n+    };\n+    _table->get(current, lookup_f, found_f);\n+    return result;\n+  }\n+\n+  static void print_on(outputStream* st) {\n+    auto printer = [&] (ObjectMonitor** entry) {\n+       ObjectMonitor* om = *entry;\n+       oop obj = om->object_peek();\n+       st->print(\"monitor=\" PTR_FORMAT \", \", p2i(om));\n+       st->print(\"object=\" PTR_FORMAT, p2i(obj));\n+       assert(obj->mark().hash() == om->hash(), \"hash must match\");\n+       st->cr();\n+       return true;\n+    };\n+    if (SafepointSynchronize::is_at_safepoint()) {\n+      _table->do_safepoint_scan(printer);\n+    } else {\n+      _table->do_scan(Thread::current(), printer);\n+    }\n+  }\n+};\n+\n+ObjectMonitorTable::ConcurrentTable* ObjectMonitorTable::_table = nullptr;\n+volatile size_t ObjectMonitorTable::_items_count = 0;\n+size_t ObjectMonitorTable::_table_size = 0;\n+volatile bool ObjectMonitorTable::_resize = false;\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  ObjectMonitor* monitor = get_monitor_from_table(current, object);\n+  if (monitor != nullptr) {\n+    *inserted = false;\n+    return monitor;\n+  }\n+\n+  ObjectMonitor* alloced_monitor = new ObjectMonitor(object);\n+  alloced_monitor->set_owner_anonymous();\n+\n+  \/\/ Try insert monitor\n+  monitor = add_monitor(current, alloced_monitor, object);\n+\n+  *inserted = alloced_monitor == monitor;\n+  if (!*inserted) {\n+    delete alloced_monitor;\n+  }\n+\n+  return monitor;\n+}\n+\n+static void log_inflate(Thread* current, oop object, ObjectSynchronizer::InflateCause cause) {\n+  if (log_is_enabled(Trace, monitorinflation)) {\n+    ResourceMark rm(current);\n+    log_trace(monitorinflation)(\"inflate: object=\" INTPTR_FORMAT \", mark=\"\n+                                INTPTR_FORMAT \", type='%s' cause=%s\", p2i(object),\n+                                object->mark().value(), object->klass()->external_name(),\n+                                ObjectSynchronizer::inflate_cause_name(cause));\n+  }\n+}\n+\n+static void post_monitor_inflate_event(EventJavaMonitorInflate* event,\n+                                       const oop obj,\n+                                       ObjectSynchronizer::InflateCause cause) {\n+  assert(event != nullptr, \"invariant\");\n+  event->set_monitorClass(obj->klass());\n+  event->set_address((uintptr_t)(void*)obj);\n+  event->set_cause((u1)cause);\n+  event->commit();\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  EventJavaMonitorInflate event;\n+\n+  bool inserted;\n+  ObjectMonitor* monitor = get_or_insert_monitor_from_table(object, current, &inserted);\n+\n+  if (inserted) {\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+\n+    \/\/ The monitor has an anonymous owner so it is safe from async deflation.\n+    ObjectSynchronizer::_in_use_list.add(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+\/\/ Add the hashcode to the monitor to match the object and put it in the hashtable.\n+ObjectMonitor* LightweightSynchronizer::add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(obj == monitor->object(), \"must be\");\n+\n+  intptr_t hash = obj->mark().hash();\n+  assert(hash != 0, \"must be set when claiming the object monitor\");\n+  monitor->set_hash(hash);\n+\n+  return ObjectMonitorTable::monitor_put_get(current, monitor, obj);\n+}\n+\n+bool LightweightSynchronizer::remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  assert(monitor->object_peek() == obj, \"must be, cleared objects are removed by is_dead\");\n+\n+  return ObjectMonitorTable::remove_monitor_entry(current, monitor);\n+}\n+\n+void LightweightSynchronizer::deflate_mark_word(oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  assert(!mark.has_no_hash(), \"obj with inflated monitor must have had a hash\");\n+\n+  while (mark.has_monitor()) {\n+    const markWord new_mark = mark.clear_lock_bits().set_unlocked();\n+    mark = obj->cas_set_mark(new_mark, mark);\n+  }\n+}\n+\n+void LightweightSynchronizer::initialize() {\n+  if (!UseObjectMonitorTable) {\n+    return;\n+  }\n+  ObjectMonitorTable::create();\n+}\n+\n+bool LightweightSynchronizer::needs_resize() {\n+  if (!UseObjectMonitorTable) {\n+    return false;\n+  }\n+  return ObjectMonitorTable::should_resize();\n+}\n+\n+bool LightweightSynchronizer::resize_table(JavaThread* current) {\n+  if (!UseObjectMonitorTable) {\n+    return true;\n+  }\n+  return ObjectMonitorTable::resize(current);\n+}\n+\n+class LightweightSynchronizer::LockStackInflateContendedLocks : private OopClosure {\n+ private:\n+  oop _contended_oops[LockStack::CAPACITY];\n+  int _length;\n+\n+  void do_oop(oop* o) final {\n+    oop obj = *o;\n+    if (obj->mark_acquire().has_monitor()) {\n+      if (_length > 0 && _contended_oops[_length - 1] == obj) {\n+        \/\/ Recursive\n+        return;\n+      }\n+      _contended_oops[_length++] = obj;\n+    }\n+  }\n+\n+  void do_oop(narrowOop* o) final {\n+    ShouldNotReachHere();\n+  }\n+\n+ public:\n+  LockStackInflateContendedLocks() :\n+    _contended_oops(),\n+    _length(0) {};\n+\n+  void inflate(JavaThread* current) {\n+    assert(current == JavaThread::current(), \"must be\");\n+    current->lock_stack().oops_do(this);\n+    for (int i = 0; i < _length; i++) {\n+      LightweightSynchronizer::\n+        inflate_fast_locked_object(_contended_oops[i], ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+};\n+\n+void LightweightSynchronizer::ensure_lock_stack_space(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  \/\/ Make room on lock_stack\n+  if (lock_stack.is_full()) {\n+    \/\/ Inflate contended objects\n+    LockStackInflateContendedLocks().inflate(current);\n+    if (lock_stack.is_full()) {\n+      \/\/ Inflate the oldest object\n+      inflate_fast_locked_object(lock_stack.bottom(), ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+}\n+\n+class LightweightSynchronizer::CacheSetter : StackObj {\n+  JavaThread* const _thread;\n+  BasicLock* const _lock;\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(CacheSetter);\n+\n+ public:\n+  CacheSetter(JavaThread* thread, BasicLock* lock) :\n+    _thread(thread),\n+    _lock(lock),\n+    _monitor(nullptr) {}\n+\n+  ~CacheSetter() {\n+    \/\/ Only use the cache if using the table.\n+    if (UseObjectMonitorTable) {\n+      if (_monitor != nullptr) {\n+        _thread->om_set_monitor_cache(_monitor);\n+        _lock->set_object_monitor_cache(_monitor);\n+      } else {\n+        _lock->clear_object_monitor_cache();\n+      }\n+    }\n+  }\n+\n+  void set_monitor(ObjectMonitor* monitor) {\n+    assert(_monitor == nullptr, \"only set once\");\n+    _monitor = monitor;\n+  }\n+\n+};\n+\n+class LightweightSynchronizer::VerifyThreadState {\n+  bool _no_safepoint;\n+\n+ public:\n+  VerifyThreadState(JavaThread* locking_thread, JavaThread* current) : _no_safepoint(locking_thread != current) {\n+    assert(current == Thread::current(), \"must be\");\n+    assert(locking_thread == current || locking_thread->is_obj_deopt_suspend(), \"locking_thread may not run concurrently\");\n+    if (_no_safepoint) {\n+      DEBUG_ONLY(JavaThread::current()->inc_no_safepoint_count();)\n+    }\n+  }\n+  ~VerifyThreadState() {\n+    if (_no_safepoint){\n+      DEBUG_ONLY(JavaThread::current()->dec_no_safepoint_count();)\n+    }\n+  }\n+};\n+\n+inline bool LightweightSynchronizer::fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current) {\n+  markWord mark = obj->mark();\n+  while (mark.is_unlocked()) {\n+    ensure_lock_stack_space(current);\n+    assert(!lock_stack.is_full(), \"must have made room on the lock stack\");\n+    assert(!lock_stack.contains(obj), \"thread must not already hold the lock\");\n+    \/\/ Try to swing into 'fast-locked' state.\n+    markWord locked_mark = mark.set_fast_locked();\n+    markWord old_mark = mark;\n+    mark = obj->cas_set_mark(locked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool LightweightSynchronizer::fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  \/\/ Will spin with exponential backoff with an accumulative O(2^spin_limit) spins.\n+  const int log_spin_limit = os::is_MP() ? LightweightFastLockingSpins : 1;\n+  const int log_min_safepoint_check_interval = 10;\n+\n+  markWord mark = obj->mark();\n+  const auto should_spin = [&]() {\n+    if (!mark.has_monitor()) {\n+      \/\/ Spin while not inflated.\n+      return true;\n+    } else if (observed_deflation) {\n+      \/\/ Spin while monitor is being deflated.\n+      ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+      return monitor == nullptr || monitor->is_being_async_deflated();\n+    }\n+    \/\/ Else stop spinning.\n+    return false;\n+  };\n+  \/\/ Always attempt to lock once even when safepoint synchronizing.\n+  bool should_process = false;\n+  for (int i = 0; should_spin() && !should_process && i < log_spin_limit; i++) {\n+    \/\/ Spin with exponential backoff.\n+    const int total_spin_count = 1 << i;\n+    const int inner_spin_count = MIN2(1 << log_min_safepoint_check_interval, total_spin_count);\n+    const int outer_spin_count = total_spin_count \/ inner_spin_count;\n+    for (int outer = 0; outer < outer_spin_count; outer++) {\n+      should_process = SafepointMechanism::should_process(current);\n+      if (should_process) {\n+        \/\/ Stop spinning for safepoint.\n+        break;\n+      }\n+      for (int inner = 1; inner < inner_spin_count; inner++) {\n+        SpinPause();\n+      }\n+    }\n+\n+    if (fast_lock_try_enter(obj, lock_stack, current)) return true;\n+  }\n+  return false;\n+}\n+\n+void LightweightSynchronizer::enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = JavaThread::current();\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, locking_thread);\n+  }\n+\n+  locking_thread->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(locking_thread, lock);\n+\n+  LockStack& lock_stack = locking_thread->lock_stack();\n+\n+  ObjectMonitor* monitor = nullptr;\n+  if (lock_stack.contains(obj())) {\n+    monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+    bool entered = monitor->enter_for(locking_thread);\n+    assert(entered, \"recursive ObjectMonitor::enter_for must succeed\");\n+  } else {\n+    \/\/ It is assumed that enter_for must enter on an object without contention.\n+    monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, locking_thread, current);\n+  }\n+\n+  assert(monitor != nullptr, \"LightweightSynchronizer::enter_for must succeed\");\n+  cache_setter.set_monitor(monitor);\n+}\n+\n+void LightweightSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (obj->klass()->is_value_based()) {\n+    ObjectSynchronizer::handle_sync_on_value_based_class(obj, current);\n+  }\n+\n+  current->inc_held_monitor_count();\n+\n+  CacheSetter cache_setter(current, lock);\n+\n+  \/\/ Used when deflation is observed. Progress here requires progress\n+  \/\/ from the deflator. After observing that the deflator is not\n+  \/\/ making progress (after two yields), switch to sleeping.\n+  SpinYield spin_yield(0, 2);\n+  bool observed_deflation = false;\n+\n+  LockStack& lock_stack = current->lock_stack();\n+\n+  if (!lock_stack.is_full() && lock_stack.try_recursive_enter(obj())) {\n+    \/\/ Recursively fast locked\n+    return;\n+  }\n+\n+  if (lock_stack.contains(obj())) {\n+    ObjectMonitor* monitor = inflate_fast_locked_object(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    bool entered = monitor->enter(current);\n+    assert(entered, \"recursive ObjectMonitor::enter must succeed\");\n+    cache_setter.set_monitor(monitor);\n+    return;\n+  }\n+\n+  while (true) {\n+    \/\/ Fast-locking does not use the 'lock' argument.\n+    \/\/ Fast-lock spinning to avoid inflating for short critical sections.\n+    \/\/ The goal is to only inflate when the extra cost of using ObjectMonitors\n+    \/\/ is worth it.\n+    \/\/ If deflation has been observed we also spin while deflation is ongoing.\n+    if (fast_lock_try_enter(obj(), lock_stack, current)) {\n+      return;\n+    } else if (UseObjectMonitorTable && fast_lock_spin_enter(obj(), lock_stack, current, observed_deflation)) {\n+      return;\n+    }\n+\n+    if (observed_deflation) {\n+      spin_yield.wait();\n+    }\n+\n+    ObjectMonitor* monitor = inflate_and_enter(obj(), ObjectSynchronizer::inflate_cause_monitor_enter, current, current);\n+    if (monitor != nullptr) {\n+      cache_setter.set_monitor(monitor);\n+      return;\n+    }\n+\n+    \/\/ If inflate_and_enter returns nullptr it is because a deflated monitor\n+    \/\/ was encountered. Fallback to fast locking. The deflater is responsible\n+    \/\/ for clearing out the monitor and transitioning the markWord back to\n+    \/\/ fast locking.\n+    observed_deflation = true;\n+  }\n+}\n+\n+void LightweightSynchronizer::exit(oop object, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  assert(current == Thread::current(), \"must be\");\n+\n+  markWord mark = object->mark();\n+  assert(!mark.is_unlocked(), \"must be\");\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (mark.is_fast_locked()) {\n+    if (lock_stack.try_recursive_exit(object)) {\n+      \/\/ This is a recursive exit which succeeded\n+      return;\n+    }\n+    if (lock_stack.is_recursive(object)) {\n+      \/\/ Must inflate recursive locks if try_recursive_exit fails\n+      \/\/ This happens for un-structured unlocks, could potentially\n+      \/\/ fix try_recursive_exit to handle these.\n+      inflate_fast_locked_object(object, ObjectSynchronizer::inflate_cause_vm_internal, current, current);\n+    }\n+  }\n+\n+  while (mark.is_fast_locked()) {\n+    markWord unlocked_mark = mark.set_unlocked();\n+    markWord old_mark = mark;\n+    mark = object->cas_set_mark(unlocked_mark, old_mark);\n+    if (old_mark == mark) {\n+      \/\/ CAS successful, remove from lock_stack\n+      size_t recursion = lock_stack.remove(object) - 1;\n+      assert(recursion == 0, \"Should not have unlocked here\");\n+      return;\n+    }\n+  }\n+\n+  assert(mark.has_monitor(), \"must be\");\n+  \/\/ The monitor exists\n+  ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, object, mark);\n+  if (monitor->is_owner_anonymous()) {\n+    assert(current->lock_stack().contains(object), \"current must have object on its lock stack\");\n+    monitor->set_owner_from_anonymous(current);\n+    monitor->set_recursions(current->lock_stack().remove(object) - 1);\n+  }\n+\n+  monitor->exit(current);\n+}\n+\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse is used to to get an inflated\n+\/\/ ObjectMonitor* with LM_LIGHTWEIGHT. It is used from contexts which require\n+\/\/ an inflated ObjectMonitor* for a monitor, and expects to throw a\n+\/\/ java.lang.IllegalMonitorStateException if it is not held by the current\n+\/\/ thread. Such as notify\/wait and jni_exit. LM_LIGHTWEIGHT keeps it invariant\n+\/\/ that it only inflates if it is already locked by the current thread or the\n+\/\/ current thread is in the process of entering. To maintain this invariant we\n+\/\/ need to throw a java.lang.IllegalMonitorStateException before inflating if\n+\/\/ the current thread is not the owner.\n+\/\/ LightweightSynchronizer::inflate_locked_or_imse facilitates this.\n+ObjectMonitor* LightweightSynchronizer::inflate_locked_or_imse(oop obj, ObjectSynchronizer::InflateCause cause, TRAPS) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+  JavaThread* current = THREAD;\n+\n+  for (;;) {\n+    markWord mark = obj->mark_acquire();\n+    if (mark.is_unlocked()) {\n+      \/\/ No lock, IMSE.\n+      THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                 \"current thread is not owner\", nullptr);\n+    }\n+\n+    if (mark.is_fast_locked()) {\n+      if (!current->lock_stack().contains(obj)) {\n+        \/\/ Fast locked by other thread, IMSE.\n+        THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                   \"current thread is not owner\", nullptr);\n+      } else {\n+        \/\/ Current thread owns the lock, must inflate\n+        return inflate_fast_locked_object(obj, cause, current, current);\n+      }\n+    }\n+\n+    assert(mark.has_monitor(), \"must be\");\n+    ObjectMonitor* monitor = ObjectSynchronizer::read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      if (monitor->is_owner_anonymous()) {\n+        LockStack& lock_stack = current->lock_stack();\n+        if (lock_stack.contains(obj)) {\n+          \/\/ Current thread owns the lock but someone else inflated it.\n+          \/\/ Fix owner and pop lock stack.\n+          monitor->set_owner_from_anonymous(current);\n+          monitor->set_recursions(lock_stack.remove(obj) - 1);\n+        } else {\n+          \/\/ Fast locked (and inflated) by other thread, or deflation in progress, IMSE.\n+          THROW_MSG_(vmSymbols::java_lang_IllegalMonitorStateException(),\n+                     \"current thread is not owner\", nullptr);\n+        }\n+      }\n+      return monitor;\n+    }\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current) {\n+\n+  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n+  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n+  \/\/ some other mechanism.\n+  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n+  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n+  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n+  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n+  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  EventJavaMonitorInflate event;\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - Just return if using stack-locking.\n+    \/\/                   If using fast-locking and the ObjectMonitor owner\n+    \/\/                   is anonymous and the inflating_thread owns the\n+    \/\/                   object lock, then we make the inflating_thread\n+    \/\/                   the ObjectMonitor owner and remove the lock from\n+    \/\/                   the inflating_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  unlocked     - Aggressively inflate the object.\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      ObjectMonitor* inf = mark.monitor();\n+      markWord dmw = inf->header();\n+      assert(dmw.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, dmw.value());\n+      if (inf->is_owner_anonymous() &&\n+          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n+        inf->set_owner_from_anonymous(inflating_thread);\n+        size_t removed = inflating_thread->lock_stack().remove(object);\n+        inf->set_recursions(removed - 1);\n+      }\n+      return inf;\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n+    \/\/\n+    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n+    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n+    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n+    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n+    \/\/ to anonymous. If we lose the race to set the object's mark to the\n+    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      ObjectMonitor* monitor = new ObjectMonitor(object);\n+      monitor->set_header(mark.set_unlocked());\n+      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n+      if (own) {\n+        \/\/ Owned by inflating_thread.\n+        monitor->set_owner_from(nullptr, inflating_thread);\n+      } else {\n+        \/\/ Owned by somebody else.\n+        monitor->set_owner_anonymous();\n+      }\n+      markWord monitor_mark = markWord::encode(monitor);\n+      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n+      if (old_mark == mark) {\n+        \/\/ Success! Return inflated monitor.\n+        if (own) {\n+          size_t removed = inflating_thread->lock_stack().remove(object);\n+          monitor->set_recursions(removed - 1);\n+        }\n+        \/\/ Once the ObjectMonitor is configured and object is associated\n+        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+        ObjectSynchronizer::_in_use_list.add(monitor);\n+\n+        \/\/ Hopefully the performance counters are allocated on distinct\n+        \/\/ cache lines to avoid false sharing on MP systems ...\n+        OM_PERFDATA_OP(Inflations, inc());\n+        log_inflate(current, object, cause);\n+        if (event.should_commit()) {\n+          post_monitor_inflate_event(&event, object, cause);\n+        }\n+        return monitor;\n+      } else {\n+        delete monitor;\n+        continue;  \/\/ Interference -- just retry\n+      }\n+    }\n+\n+    \/\/ CASE: unlocked\n+    \/\/ TODO-FIXME: for entry we currently inflate and then try to CAS _owner.\n+    \/\/ If we know we're inflating for entry it's better to inflate by swinging a\n+    \/\/ pre-locked ObjectMonitor pointer into the object header.   A successful\n+    \/\/ CAS inflates the object *and* confers ownership to the inflating thread.\n+    \/\/ In the current implementation we use a 2-step mechanism where we CAS()\n+    \/\/ to inflate and then CAS() again to try to swing _owner from null to current.\n+    \/\/ An inflateTry() method that we could call from enter() would be useful.\n+\n+    assert(mark.is_unlocked(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    ObjectMonitor* m = new ObjectMonitor(object);\n+    \/\/ prepare m for installation - set monitor to initial state\n+    m->set_header(mark);\n+\n+    if (object->cas_set_mark(markWord::encode(m), mark) != mark) {\n+      delete m;\n+      m = nullptr;\n+      continue;\n+      \/\/ interference - the markword changed - just retry.\n+      \/\/ The state-transitions are one-way, so there's no chance of\n+      \/\/ live-lock -- \"Inflated\" is an absorbing state.\n+    }\n+\n+    \/\/ Once the ObjectMonitor is configured and object is associated\n+    \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n+    ObjectSynchronizer::_in_use_list.add(m);\n+\n+    \/\/ Hopefully the performance counters are allocated on distinct\n+    \/\/ cache lines to avoid false sharing on MP systems ...\n+    OM_PERFDATA_OP(Inflations, inc());\n+    log_inflate(current, object, cause);\n+    if (event.should_commit()) {\n+      post_monitor_inflate_event(&event, object, cause);\n+    }\n+    return m;\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+  assert(locking_thread->lock_stack().contains(object), \"locking_thread must have object on its lock stack\");\n+\n+  ObjectMonitor* monitor;\n+\n+  if (!UseObjectMonitorTable) {\n+    return inflate_into_object_header(object, cause, locking_thread, current);\n+  }\n+\n+  \/\/ Inflating requires a hash code\n+  ObjectSynchronizer::FastHashCode(current, object);\n+\n+  markWord mark = object->mark_acquire();\n+  assert(!mark.is_unlocked(), \"Cannot be unlocked\");\n+\n+  for (;;) {\n+    \/\/ Fetch the monitor from the table\n+    monitor = get_or_insert_monitor(object, current, cause);\n+\n+    \/\/ ObjectMonitors are always inserted as anonymously owned, this thread is\n+    \/\/ the current holder of the monitor. So unless the entry is stale and\n+    \/\/ contains a deflating monitor it must be anonymously owned.\n+    if (monitor->is_owner_anonymous()) {\n+      \/\/ The monitor must be anonymously owned if it was added\n+      assert(monitor == get_monitor_from_table(current, object), \"The monitor must be found\");\n+      \/\/ New fresh monitor\n+      break;\n+    }\n+\n+    \/\/ If the monitor was not anonymously owned then we got a deflating monitor\n+    \/\/ from the table. We need to let the deflator make progress and remove this\n+    \/\/ entry before we are allowed to add a new one.\n+    os::naked_yield();\n+    assert(monitor->is_being_async_deflated(), \"Should be the reason\");\n+  }\n+\n+  \/\/ Set the mark word; loop to handle concurrent updates to other parts of the mark word\n+  while (mark.is_fast_locked()) {\n+    mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+  }\n+\n+  \/\/ Indicate that the monitor now has a known owner\n+  monitor->set_owner_from_anonymous(locking_thread);\n+\n+  \/\/ Remove the entry from the thread's lock stack\n+  monitor->set_recursions(locking_thread->lock_stack().remove(object) - 1);\n+\n+  if (locking_thread == current) {\n+    \/\/ Only change the thread local state of the current thread.\n+    locking_thread->om_set_monitor_cache(monitor);\n+  }\n+\n+  return monitor;\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current) {\n+  assert(LockingMode == LM_LIGHTWEIGHT, \"only used for lightweight\");\n+  VerifyThreadState vts(locking_thread, current);\n+\n+  \/\/ Note: In some paths (deoptimization) the 'current' thread inflates and\n+  \/\/ enters the lock on behalf of the 'locking_thread' thread.\n+\n+  ObjectMonitor* monitor = nullptr;\n+\n+  if (!UseObjectMonitorTable) {\n+    \/\/ Do the old inflate and enter.\n+    monitor = inflate_into_object_header(object, cause, locking_thread, current);\n+\n+    bool entered;\n+    if (locking_thread == current) {\n+      entered = monitor->enter(locking_thread);\n+    } else {\n+      entered = monitor->enter_for(locking_thread);\n+    }\n+\n+    \/\/ enter returns false for deflation found.\n+    return entered ? monitor : nullptr;\n+  }\n+\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ Lightweight monitors require that hash codes are installed first\n+  ObjectSynchronizer::FastHashCode(locking_thread, object);\n+\n+  \/\/ Try to get the monitor from the thread-local cache.\n+  \/\/ There's no need to use the cache if we are locking\n+  \/\/ on behalf of another thread.\n+  if (current == locking_thread) {\n+    monitor = current->om_get_from_monitor_cache(object);\n+  }\n+\n+  \/\/ Get or create the monitor\n+  if (monitor == nullptr) {\n+    monitor = get_or_insert_monitor(object, current, cause);\n+  }\n+\n+  if (monitor->try_enter(locking_thread)) {\n+    return monitor;\n+  }\n+\n+  \/\/ Holds is_being_async_deflated() stable throughout this function.\n+  ObjectMonitorContentionMark contention_mark(monitor);\n+\n+  \/\/\/ First handle the case where the monitor from the table is deflated\n+  if (monitor->is_being_async_deflated()) {\n+    \/\/ The MonitorDeflation thread is deflating the monitor. The locking thread\n+    \/\/ must spin until further progress has been made.\n+\n+    const markWord mark = object->mark_acquire();\n+\n+    if (mark.has_monitor()) {\n+      \/\/ Waiting on the deflation thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else if (mark.is_fast_locked()) {\n+      \/\/ Some other thread managed to fast-lock the lock, or this is a\n+      \/\/ recursive lock from the same thread; yield for the deflation\n+      \/\/ thread to remove the deflated monitor from the table.\n+      os::naked_yield();\n+\n+    } else {\n+      assert(mark.is_unlocked(), \"Implied\");\n+      \/\/ Retry immediately\n+    }\n+\n+    \/\/ Retry\n+    return nullptr;\n+  }\n+\n+  for (;;) {\n+    const markWord mark = object->mark_acquire();\n+    \/\/ The mark can be in one of the following states:\n+    \/\/ *  inflated     - If the ObjectMonitor owner is anonymous\n+    \/\/                   and the locking_thread owns the object\n+    \/\/                   lock, then we make the locking_thread\n+    \/\/                   the ObjectMonitor owner and remove the\n+    \/\/                   lock from the locking_thread's lock stack.\n+    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  neutral      - Inflate the object. Successful CAS is locked\n+\n+    \/\/ CASE: inflated\n+    if (mark.has_monitor()) {\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (monitor->is_owner_anonymous() && lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: fast-locked\n+    \/\/ Could be fast-locked either by locking_thread or by some other thread.\n+    \/\/\n+    if (mark.is_fast_locked()) {\n+      markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+      if (old_mark != mark) {\n+        \/\/ CAS failed\n+        continue;\n+      }\n+\n+      \/\/ Success! Return inflated monitor.\n+      LockStack& lock_stack = locking_thread->lock_stack();\n+      if (lock_stack.contains(object)) {\n+        \/\/ The lock is fast-locked by the locking thread,\n+        \/\/ convert it to a held monitor with a known owner.\n+        monitor->set_owner_from_anonymous(locking_thread);\n+        monitor->set_recursions(lock_stack.remove(object) - 1);\n+      }\n+\n+      break; \/\/ Success\n+    }\n+\n+    \/\/ CASE: neutral (unlocked)\n+\n+    \/\/ Catch if the object's header is not neutral (not locked and\n+    \/\/ not marked is what we care about here).\n+    assert(mark.is_neutral(), \"invariant: header=\" INTPTR_FORMAT, mark.value());\n+    markWord old_mark = object->cas_set_mark(mark.set_has_monitor(), mark);\n+    if (old_mark != mark) {\n+      \/\/ CAS failed\n+      continue;\n+    }\n+\n+    \/\/ Transitioned from unlocked to monitor means locking_thread owns the lock.\n+    monitor->set_owner_from_anonymous(locking_thread);\n+\n+    return monitor;\n+  }\n+\n+  if (current == locking_thread) {\n+    \/\/ One round of spinning\n+    if (monitor->spin_enter(locking_thread)) {\n+      return monitor;\n+    }\n+\n+    \/\/ Monitor is contended, take the time before entering to fix the lock stack.\n+    LockStackInflateContendedLocks().inflate(current);\n+  }\n+\n+  \/\/ enter can block for safepoints; clear the unhandled object oop\n+  PauseNoSafepointVerifier pnsv(&nsv);\n+  object = nullptr;\n+\n+  if (current == locking_thread) {\n+    monitor->enter_with_contention_mark(locking_thread, contention_mark);\n+  } else {\n+    monitor->enter_for_with_contention_mark(locking_thread, contention_mark);\n+  }\n+\n+  return monitor;\n+}\n+\n+void LightweightSynchronizer::deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor) {\n+  if (obj != nullptr) {\n+    deflate_mark_word(obj);\n+  }\n+  bool removed = remove_monitor(current, monitor, obj);\n+  if (obj != nullptr) {\n+    assert(removed, \"Should have removed the entry if obj was alive\");\n+  }\n+}\n+\n+ObjectMonitor* LightweightSynchronizer::get_monitor_from_table(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::monitor_get(current, obj);\n+}\n+\n+bool LightweightSynchronizer::contains_monitor(Thread* current, ObjectMonitor* monitor) {\n+  assert(UseObjectMonitorTable, \"must be\");\n+  return ObjectMonitorTable::contains_monitor(current, monitor);\n+}\n+\n+bool LightweightSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"must be\");\n+  assert(obj != nullptr, \"must be\");\n+  NoSafepointVerifier nsv;\n+\n+  \/\/ If quick_enter succeeds with entering, the cache should be in a valid initialized state.\n+  CacheSetter cache_setter(current, lock);\n+\n+  LockStack& lock_stack = current->lock_stack();\n+  if (lock_stack.is_full()) {\n+    \/\/ Always go into runtime if the lock stack is full.\n+    return false;\n+  }\n+\n+  const markWord mark = obj->mark();\n+\n+#ifndef _LP64\n+  \/\/ Only for 32bit which has limited support for fast locking outside the runtime.\n+  if (lock_stack.try_recursive_enter(obj)) {\n+    \/\/ Recursive lock successful.\n+    current->inc_held_monitor_count();\n+    return true;\n+  }\n+\n+  if (mark.is_unlocked()) {\n+    markWord locked_mark = mark.set_fast_locked();\n+    if (obj->cas_set_mark(locked_mark, mark) == mark) {\n+      \/\/ Successfully fast-locked, push object to lock-stack and return.\n+      lock_stack.push(obj);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+#endif\n+\n+  if (mark.has_monitor()) {\n+    ObjectMonitor* const monitor = UseObjectMonitorTable ? current->om_get_from_monitor_cache(obj) :\n+                                                           ObjectSynchronizer::read_monitor(mark);\n+\n+    if (monitor == nullptr) {\n+      \/\/ Take the slow-path on a cache miss.\n+      return false;\n+    }\n+\n+    if (monitor->try_enter(current)) {\n+      \/\/ ObjectMonitor enter successful.\n+      cache_setter.set_monitor(monitor);\n+      current->inc_held_monitor_count();\n+      return true;\n+    }\n+  }\n+\n+  \/\/ Slow-path.\n+  return false;\n+}\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.cpp","additions":1223,"deletions":0,"binary":false,"changes":1223,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+#define SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n+\n+#include \"memory\/allStatic.hpp\"\n+#include \"runtime\/javaThread.hpp\"\n+#include \"runtime\/objectMonitor.hpp\"\n+#include \"runtime\/synchronizer.hpp\"\n+\n+class ObjectMonitorTable;\n+\n+class LightweightSynchronizer : AllStatic {\n+ private:\n+  static ObjectMonitor* get_or_insert_monitor_from_table(oop object, JavaThread* current, bool* inserted);\n+  static ObjectMonitor* get_or_insert_monitor(oop object, JavaThread* current, ObjectSynchronizer::InflateCause cause);\n+\n+  static ObjectMonitor* add_monitor(JavaThread* current, ObjectMonitor* monitor, oop obj);\n+  static bool remove_monitor(Thread* current, ObjectMonitor* monitor, oop obj);\n+\n+  static void deflate_mark_word(oop object);\n+\n+  static void ensure_lock_stack_space(JavaThread* current);\n+\n+  class CacheSetter;\n+  class LockStackInflateContendedLocks;\n+  class VerifyThreadState;\n+\n+ public:\n+  static void initialize();\n+\n+  static bool needs_resize();\n+  static bool resize_table(JavaThread* current);\n+\n+ private:\n+  static inline bool fast_lock_try_enter(oop obj, LockStack& lock_stack, JavaThread* current);\n+  static bool fast_lock_spin_enter(oop obj, LockStack& lock_stack, JavaThread* current, bool observed_deflation);\n+\n+ public:\n+  static void enter_for(Handle obj, BasicLock* lock, JavaThread* locking_thread);\n+  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static void exit(oop object, JavaThread* current);\n+\n+  static ObjectMonitor* inflate_into_object_header(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* inflating_thread, Thread* current);\n+  static ObjectMonitor* inflate_locked_or_imse(oop object, ObjectSynchronizer::InflateCause cause, TRAPS);\n+  static ObjectMonitor* inflate_fast_locked_object(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+  static ObjectMonitor* inflate_and_enter(oop object, ObjectSynchronizer::InflateCause cause, JavaThread* locking_thread, JavaThread* current);\n+\n+  static void deflate_monitor(Thread* current, oop obj, ObjectMonitor* monitor);\n+\n+  static ObjectMonitor* get_monitor_from_table(Thread* current, oop obj);\n+\n+  static bool contains_monitor(Thread* current, ObjectMonitor* monitor);\n+\n+  static bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n+};\n+\n+#endif \/\/ SHARE_RUNTIME_LIGHTWEIGHTSYNCHRONIZER_HPP\n","filename":"src\/hotspot\/share\/runtime\/lightweightSynchronizer.hpp","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#include \"precompiled.hpp\"\n+#include \"runtime\/java.hpp\"\n+\n+\/\/ This is in a separate file since it will need to be compiled to two different\n+\/\/ object files, depending on if we are going to build a static or a dynamic\n+\/\/ library.\n+\n+bool is_vm_statically_linked(void) {\n+#ifdef STATIC_BUILD\n+  return true;\n+#else\n+  return false;\n+#endif\n+}\n","filename":"src\/hotspot\/share\/runtime\/linkType.cpp","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.inline.hpp\"\n@@ -37,0 +38,1 @@\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -43,0 +45,1 @@\n+#include \"utilities\/sizes.hpp\"\n@@ -117,0 +120,8 @@\n+\n+OMCache::OMCache(JavaThread* jt) : _entries() {\n+  STATIC_ASSERT(std::is_standard_layout<OMCache>::value);\n+  STATIC_ASSERT(std::is_standard_layout<OMCache::OMCacheEntry>::value);\n+  STATIC_ASSERT(offsetof(OMCache, _null_sentinel) == offsetof(OMCache, _entries) +\n+                offsetof(OMCache::OMCacheEntry, _oop) +\n+                OMCache::CAPACITY * in_bytes(oop_to_oop_difference()));\n+}\n","filename":"src\/hotspot\/share\/runtime\/lockStack.cpp","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+class ObjectMonitor;\n@@ -39,0 +40,1 @@\n+class Thread;\n@@ -44,1 +46,1 @@\n-public:\n+ public:\n@@ -46,1 +48,1 @@\n-private:\n+ private:\n@@ -76,1 +78,1 @@\n-public:\n+ public:\n@@ -126,0 +128,25 @@\n+class OMCache {\n+  friend class VMStructs;\n+ public:\n+  static constexpr int CAPACITY = 8;\n+\n+ private:\n+  struct OMCacheEntry {\n+    oop _oop = nullptr;\n+    ObjectMonitor* _monitor = nullptr;\n+  } _entries[CAPACITY];\n+  const oop _null_sentinel = nullptr;\n+\n+ public:\n+  static ByteSize entries_offset() { return byte_offset_of(OMCache, _entries); }\n+  static constexpr ByteSize oop_to_oop_difference() { return in_ByteSize(sizeof(OMCacheEntry)); }\n+  static constexpr ByteSize oop_to_monitor_difference() { return in_ByteSize(sizeof(oop)); }\n+\n+  explicit OMCache(JavaThread* jt);\n+\n+  inline ObjectMonitor* get_monitor(oop o);\n+  inline void set_monitor(ObjectMonitor* monitor);\n+  inline void clear();\n+\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.hpp","additions":30,"deletions":3,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -34,0 +34,2 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/objectMonitor.inline.hpp\"\n@@ -225,0 +227,50 @@\n+inline void OMCache::set_monitor(ObjectMonitor *monitor) {\n+  const int end = OMCache::CAPACITY - 1;\n+\n+  oop obj = monitor->object_peek();\n+  assert(obj != nullptr, \"must be alive\");\n+  assert(monitor == LightweightSynchronizer::get_monitor_from_table(JavaThread::current(), obj), \"must exist in table\");\n+\n+  OMCacheEntry to_insert = {obj, monitor};\n+\n+  for (int i = 0; i < end; ++i) {\n+    if (_entries[i]._oop == obj ||\n+        _entries[i]._monitor == nullptr ||\n+        _entries[i]._monitor->is_being_async_deflated()) {\n+      \/\/ Use stale slot.\n+      _entries[i] = to_insert;\n+      return;\n+    }\n+    \/\/ Swap with the most recent value.\n+    ::swap(to_insert, _entries[i]);\n+  }\n+  _entries[end] = to_insert;\n+}\n+\n+inline ObjectMonitor* OMCache::get_monitor(oop o) {\n+  for (int i = 0; i < CAPACITY; ++i) {\n+    if (_entries[i]._oop == o) {\n+      assert(_entries[i]._monitor != nullptr, \"monitor must exist\");\n+      if (_entries[i]._monitor->is_being_async_deflated()) {\n+        \/\/ Bad monitor\n+        \/\/ Shift down rest\n+        for (; i < CAPACITY - 1; ++i) {\n+          _entries[i] = _entries[i + 1];\n+        }\n+        \/\/ Clear end\n+        _entries[i] = {};\n+        return nullptr;\n+      }\n+      return _entries[i]._monitor;\n+    }\n+  }\n+  return nullptr;\n+}\n+\n+inline void OMCache::clear() {\n+  for (size_t i = 0; i < CAPACITY; ++i) {\n+    \/\/ Clear\n+    _entries[i] = {};\n+  }\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/lockStack.inline.hpp","additions":52,"deletions":0,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -270,2 +270,0 @@\n-  MUTEX_DEFN(JvmtiThreadState_lock           , PaddedMutex  , safepoint);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n-  MUTEX_DEFN(EscapeBarrier_lock              , PaddedMonitor, nosafepoint); \/\/ Used to synchronize object reallocation\/relocking triggered by JVMTI\n@@ -273,0 +271,1 @@\n+  MUTEX_DEFN(EscapeBarrier_lock              , PaddedMonitor, nosafepoint); \/\/ Used to synchronize object reallocation\/relocking triggered by JVMTI\n@@ -358,0 +357,1 @@\n+  MUTEX_DEFL(JvmtiThreadState_lock          , PaddedMutex  , JvmtiVTMSTransition_lock);   \/\/ Used by JvmtiThreadState\/JvmtiEventController\n","filename":"src\/hotspot\/share\/runtime\/mutexLocker.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -56,0 +57,1 @@\n+#include \"utilities\/debug.hpp\"\n@@ -249,1 +251,1 @@\n-  _header(markWord::zero()),\n+  _metadata(0),\n@@ -275,4 +277,0 @@\n-oop ObjectMonitor::object_peek() const {\n-  return _object.peek();\n-}\n-\n@@ -300,0 +298,6 @@\n+#define assert_mark_word_consistency()                                         \\\n+  assert(UseObjectMonitorTable || object()->mark() == markWord::encode(this),  \\\n+         \"object mark must match encoded this: mark=\" INTPTR_FORMAT            \\\n+         \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),            \\\n+         markWord::encode(this).value());\n+\n@@ -303,1 +307,17 @@\n-bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n+bool ObjectMonitor::enter_is_async_deflating() {\n+  if (is_being_async_deflated()) {\n+    if (!UseObjectMonitorTable) {\n+      const oop l_object = object();\n+      if (l_object != nullptr) {\n+        \/\/ Attempt to restore the header\/dmw to the object's header so that\n+        \/\/ we only retry once if the deflater thread happens to be slow.\n+        install_displaced_markword_in_object(l_object);\n+      }\n+    }\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+void ObjectMonitor::enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark) {\n@@ -308,0 +328,2 @@\n+  assert(contention_mark._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n@@ -309,2 +331,2 @@\n-  \/\/ Block out deflation as soon as possible.\n-  add_to_contentions(1);\n+\n+  void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -313,2 +335,0 @@\n-  if (!is_being_async_deflated()) {\n-    void* prev_owner = try_set_owner_from(nullptr, locking_thread);\n@@ -316,25 +336,12 @@\n-    if (prev_owner == nullptr) {\n-      assert(_recursions == 0, \"invariant\");\n-      success = true;\n-    } else if (prev_owner == locking_thread) {\n-      _recursions++;\n-      success = true;\n-    } else if (prev_owner == DEFLATER_MARKER) {\n-      \/\/ Racing with deflation.\n-      prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n-      if (prev_owner == DEFLATER_MARKER) {\n-        \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n-        add_to_contentions(1);\n-        success = true;\n-      } else if (prev_owner == nullptr) {\n-        \/\/ At this point we cannot race with deflation as we have both incremented\n-        \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n-        \/\/ success will only be false if this races with something other than\n-        \/\/ deflation.\n-        prev_owner = try_set_owner_from(nullptr, locking_thread);\n-        success = prev_owner == nullptr;\n-      }\n-    } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n-      assert(_recursions == 0, \"must be\");\n-      _recursions = 1;\n-      set_owner_from_BasicLock(prev_owner, locking_thread);\n+  if (prev_owner == nullptr) {\n+    assert(_recursions == 0, \"invariant\");\n+    success = true;\n+  } else if (prev_owner == locking_thread) {\n+    _recursions++;\n+    success = true;\n+  } else if (prev_owner == DEFLATER_MARKER) {\n+    \/\/ Racing with deflation.\n+    prev_owner = try_set_owner_from(DEFLATER_MARKER, locking_thread);\n+    if (prev_owner == DEFLATER_MARKER) {\n+      \/\/ Cancelled deflation. Increment contentions as part of the deflation protocol.\n+      add_to_contentions(1);\n@@ -342,0 +349,7 @@\n+    } else if (prev_owner == nullptr) {\n+      \/\/ At this point we cannot race with deflation as we have both incremented\n+      \/\/ contentions, seen contention > 0 and seen a DEFLATER_MARKER.\n+      \/\/ success will only be false if this races with something other than\n+      \/\/ deflation.\n+      prev_owner = try_set_owner_from(nullptr, locking_thread);\n+      success = prev_owner == nullptr;\n@@ -343,13 +357,5 @@\n-    assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n-           \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n-           p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n-  } else {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n+  } else if (LockingMode == LM_LEGACY && locking_thread->is_lock_owned((address)prev_owner)) {\n+    assert(_recursions == 0, \"must be\");\n+    _recursions = 1;\n+    set_owner_from_BasicLock(prev_owner, locking_thread);\n+    success = true;\n@@ -357,0 +363,6 @@\n+  assert(success, \"Failed to enter_for: locking_thread=\" INTPTR_FORMAT\n+          \", this=\" INTPTR_FORMAT \"{owner=\" INTPTR_FORMAT \"}, observed owner: \" INTPTR_FORMAT,\n+          p2i(locking_thread), p2i(this), p2i(owner_raw()), p2i(prev_owner));\n+}\n+\n+bool ObjectMonitor::enter_for(JavaThread* locking_thread) {\n@@ -358,1 +370,2 @@\n-  add_to_contentions(-1);\n+  \/\/ Block out deflation as soon as possible.\n+  ObjectMonitorContentionMark contention_mark(this);\n@@ -360,1 +373,4 @@\n-  assert(!success || owner_raw() == locking_thread, \"must be\");\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n@@ -362,1 +378,3 @@\n-  return success;\n+  enter_for_with_contention_mark(locking_thread, contention_mark);\n+  assert(owner_raw() == locking_thread, \"must be\");\n+  return true;\n@@ -365,7 +383,4 @@\n-bool ObjectMonitor::enter(JavaThread* current) {\n-  assert(current == JavaThread::current(), \"must be\");\n-  \/\/ The following code is ordered to check the most common cases first\n-  \/\/ and to reduce RTS->RTO cache line upgrades on SPARC and IA32 processors.\n-\n-  void* cur = try_set_owner_from(nullptr, current);\n-  if (cur == nullptr) {\n+bool ObjectMonitor::try_enter(JavaThread* current) {\n+  \/\/ TryLock avoids the CAS\n+  TryLockResult r = TryLock(current);\n+  if (r == TryLockResult::Success) {\n@@ -376,2 +391,1 @@\n-  if (cur == current) {\n-    \/\/ TODO-FIXME: check for integer overflow!  BUGID 6557169.\n+  if (r == TryLockResult::HasOwner && owner() == current) {\n@@ -382,1 +396,2 @@\n-  if (LockingMode != LM_LIGHTWEIGHT && current->is_lock_owned((address)cur)) {\n+  void* cur = owner_raw();\n+  if (LockingMode == LM_LEGACY && current->is_lock_owned((address)cur)) {\n@@ -389,0 +404,16 @@\n+  return false;\n+}\n+\n+bool ObjectMonitor::spin_enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  \/\/ Check for recursion.\n+  if (try_enter(current)) {\n+    return true;\n+  }\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n+    return false;\n+  }\n+\n@@ -391,3 +422,1 @@\n-  \/\/ Try one round of spinning *before* enqueueing current\n-  \/\/ and before going through the awkward and expensive state\n-  \/\/ transitions.  The following spin is strictly optional ...\n+  \/\/ Do one round of spinning.\n@@ -399,4 +428,11 @@\n-    assert(object()->mark() == markWord::encode(this),\n-           \"object mark must match encoded this: mark=\" INTPTR_FORMAT\n-           \", encoded this=\" INTPTR_FORMAT, object()->mark().value(),\n-           markWord::encode(this).value());\n+    assert_mark_word_consistency();\n+    return true;\n+  }\n+\n+  return false;\n+}\n+\n+bool ObjectMonitor::enter(JavaThread* current) {\n+  assert(current == JavaThread::current(), \"must be\");\n+\n+  if (spin_enter(current)) {\n@@ -411,13 +447,5 @@\n-  \/\/ Keep track of contention for JVM\/TI and M&M queries.\n-  add_to_contentions(1);\n-  if (is_being_async_deflated()) {\n-    \/\/ Async deflation is in progress and our contentions increment\n-    \/\/ above lost the race to async deflation. Undo the work and\n-    \/\/ force the caller to retry.\n-    const oop l_object = object();\n-    if (l_object != nullptr) {\n-      \/\/ Attempt to restore the header\/dmw to the object's header so that\n-      \/\/ we only retry once if the deflater thread happens to be slow.\n-      install_displaced_markword_in_object(l_object);\n-    }\n-    add_to_contentions(-1);\n+  \/\/ Keep is_being_async_deflated stable across the rest of enter\n+  ObjectMonitorContentionMark contention_mark(this);\n+\n+  \/\/ Check for deflation.\n+  if (enter_is_async_deflating()) {\n@@ -427,0 +455,11 @@\n+  \/\/ At this point this ObjectMonitor cannot be deflated, finish contended enter\n+  enter_with_contention_mark(current, contention_mark);\n+  return true;\n+}\n+\n+void ObjectMonitor::enter_with_contention_mark(JavaThread *current, ObjectMonitorContentionMark &cm) {\n+  assert(current == JavaThread::current(), \"must be\");\n+  assert(owner_raw() != current, \"must be\");\n+  assert(cm._monitor == this, \"must be\");\n+  assert(!is_being_async_deflated(), \"must be\");\n+\n@@ -483,1 +522,0 @@\n-  add_to_contentions(-1);\n@@ -490,1 +528,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -519,1 +557,0 @@\n-  return true;\n@@ -552,1 +589,1 @@\n-bool ObjectMonitor::deflate_monitor() {\n+bool ObjectMonitor::deflate_monitor(Thread* current) {\n@@ -623,0 +660,1 @@\n+  }\n@@ -624,0 +662,3 @@\n+  if (UseObjectMonitorTable) {\n+    LightweightSynchronizer::deflate_monitor(current, obj, this);\n+  } else if (obj != nullptr) {\n@@ -639,0 +680,1 @@\n+  assert(!UseObjectMonitorTable, \"ObjectMonitorTable has no dmw\");\n@@ -975,0 +1017,1 @@\n+  assert(current->thread_state() != _thread_blocked, \"invariant\");\n@@ -978,3 +1021,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n-\n-  assert(current->thread_state() != _thread_blocked, \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1045,1 +1086,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -1671,1 +1712,1 @@\n-  assert(object()->mark() == markWord::encode(this), \"invariant\");\n+  assert_mark_word_consistency();\n@@ -2188,1 +2229,1 @@\n-\/\/   _header = 0x0000000000000001\n+\/\/   _metadata = 0x0000000000000001\n@@ -2217,1 +2258,1 @@\n-  st->print_cr(\"  _header = \" INTPTR_FORMAT, header().value());\n+  st->print_cr(\"  _metadata = \" INTPTR_FORMAT, _metadata);\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.cpp","additions":133,"deletions":92,"binary":false,"changes":225,"status":"modified"},{"patch":"@@ -36,0 +36,1 @@\n+class ObjectMonitorContentionMark;\n@@ -72,1 +73,1 @@\n-\/\/ - The _header field must be at offset 0 because the displaced header\n+\/\/ - The _metadata field must be at offset 0 because the displaced header\n@@ -78,1 +79,1 @@\n-\/\/ - The _header and _owner fields should be separated by enough space\n+\/\/ - The _metadata and _owner fields should be separated by enough space\n@@ -82,1 +83,1 @@\n-\/\/     _header\n+\/\/     _metadata\n@@ -86,0 +87,1 @@\n+\/\/     <optional padding>\n@@ -109,10 +111,9 @@\n-\/\/   - Separating _owner from the <remaining_fields> by enough space to\n-\/\/     avoid false sharing might be profitable. Given\n-\/\/     http:\/\/blogs.oracle.com\/dave\/entry\/cas_and_cache_trivia_invalidate\n-\/\/     we know that the CAS in monitorenter will invalidate the line\n-\/\/     underlying _owner. We want to avoid an L1 data cache miss on that\n-\/\/     same line for monitorexit. Putting these <remaining_fields>:\n-\/\/     _recursions, _EntryList, _cxq, and _succ, all of which may be\n-\/\/     fetched in the inflated unlock path, on a different cache line\n-\/\/     would make them immune to CAS-based invalidation from the _owner\n-\/\/     field.\n+\/\/ - Separating _owner from the <remaining_fields> by enough space to\n+\/\/   avoid false sharing might be profitable. Given that the CAS in\n+\/\/   monitorenter will invalidate the line underlying _owner. We want\n+\/\/   to avoid an L1 data cache miss on that same line for monitorexit.\n+\/\/   Putting these <remaining_fields>:\n+\/\/   _recursions, _EntryList, _cxq, and _succ, all of which may be\n+\/\/   fetched in the inflated unlock path, on a different cache line\n+\/\/   would make them immune to CAS-based invalidation from the _owner\n+\/\/   field.\n@@ -120,3 +121,3 @@\n-\/\/   - The _recursions field should be of type int, or int32_t but not\n-\/\/     intptr_t. There's no reason to use a 64-bit type for this field\n-\/\/     in a 64-bit JVM.\n+\/\/ - The _recursions field should be of type int, or int32_t but not\n+\/\/   intptr_t. There's no reason to use a 64-bit type for this field\n+\/\/   in a 64-bit JVM.\n@@ -134,3 +135,7 @@\n-  \/\/ The sync code expects the header field to be at offset zero (0).\n-  \/\/ Enforced by the assert() in header_addr().\n-  volatile markWord _header;        \/\/ displaced object header word - mark\n+  \/\/ The sync code expects the metadata field to be at offset zero (0).\n+  \/\/ Enforced by the assert() in metadata_addr().\n+  \/\/ * LM_LIGHTWEIGHT with UseObjectMonitorTable:\n+  \/\/ Contains the _object's hashCode.\n+  \/\/ * LM_LEGACY, LM_MONITOR, LM_LIGHTWEIGHT without UseObjectMonitorTable:\n+  \/\/ Contains the displaced object header word - mark\n+  volatile uintptr_t _metadata;     \/\/ metadata\n@@ -138,2 +143,2 @@\n-  \/\/ Separate _header and _owner on different cache lines since both can\n-  \/\/ have busy multi-threaded access. _header and _object are set at initial\n+  \/\/ Separate _metadata and _owner on different cache lines since both can\n+  \/\/ have busy multi-threaded access. _metadata and _object are set at initial\n@@ -141,2 +146,2 @@\n-  \/\/ its cache line with _header.\n-  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(volatile markWord) +\n+  \/\/ its cache line with _metadata.\n+  DEFINE_PAD_MINUS_SIZE(0, OM_CACHE_LINE_SIZE, sizeof(_metadata) +\n@@ -152,2 +157,3 @@\n-  #define DEFLATER_MARKER reinterpret_cast<void*>(2)\n-public:\n+  static const uintptr_t DEFLATER_MARKER_VALUE = 2;\n+  #define DEFLATER_MARKER reinterpret_cast<void*>(DEFLATER_MARKER_VALUE)\n+ public:\n@@ -157,1 +163,1 @@\n-private:\n+ private:\n@@ -184,1 +190,1 @@\n- protected:\n+\n@@ -187,1 +193,0 @@\n- private:\n@@ -216,0 +221,1 @@\n+  static ByteSize metadata_offset()    { return byte_offset_of(ObjectMonitor, _metadata); }\n@@ -236,3 +242,9 @@\n-  markWord           header() const;\n-  volatile markWord* header_addr();\n-  void               set_header(markWord hdr);\n+  uintptr_t           metadata() const;\n+  void                set_metadata(uintptr_t value);\n+  volatile uintptr_t* metadata_addr();\n+\n+  markWord            header() const;\n+  void                set_header(markWord hdr);\n+\n+  intptr_t            hash() const;\n+  void                set_hash(intptr_t hash);\n@@ -309,0 +321,2 @@\n+  bool      object_is_dead() const;\n+  bool      object_refers_to(oop obj) const;\n@@ -331,0 +345,2 @@\n+\n+  bool      enter_is_async_deflating();\n@@ -332,0 +348,1 @@\n+  void      enter_for_with_contention_mark(JavaThread* locking_thread, ObjectMonitorContentionMark& contention_mark);\n@@ -334,0 +351,3 @@\n+  bool      try_enter(JavaThread* current);\n+  bool      spin_enter(JavaThread* current);\n+  void      enter_with_contention_mark(JavaThread* current, ObjectMonitorContentionMark& contention_mark);\n@@ -367,1 +387,2 @@\n-  bool      deflate_monitor();\n+  bool      deflate_monitor(Thread* current);\n+ private:\n@@ -371,0 +392,14 @@\n+\/\/ RAII object to ensure that ObjectMonitor::is_being_async_deflated() is\n+\/\/ stable within the context of this mark.\n+class ObjectMonitorContentionMark : StackObj {\n+  DEBUG_ONLY(friend class ObjectMonitor;)\n+\n+  ObjectMonitor* _monitor;\n+\n+  NONCOPYABLE(ObjectMonitorContentionMark);\n+\n+ public:\n+  explicit ObjectMonitorContentionMark(ObjectMonitor* monitor);\n+  ~ObjectMonitorContentionMark();\n+};\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.hpp","additions":67,"deletions":32,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"oops\/markWord.hpp\"\n@@ -33,0 +34,1 @@\n+#include \"runtime\/globals.hpp\"\n@@ -35,0 +37,2 @@\n+#include \"utilities\/checkedCast.hpp\"\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -52,2 +56,6 @@\n-inline markWord ObjectMonitor::header() const {\n-  return Atomic::load(&_header);\n+inline uintptr_t ObjectMonitor::metadata() const {\n+  return Atomic::load(&_metadata);\n+}\n+\n+inline void ObjectMonitor::set_metadata(uintptr_t value) {\n+  Atomic::store(&_metadata, value);\n@@ -56,2 +64,9 @@\n-inline volatile markWord* ObjectMonitor::header_addr() {\n-  return &_header;\n+inline volatile uintptr_t* ObjectMonitor::metadata_addr() {\n+  STATIC_ASSERT(std::is_standard_layout<ObjectMonitor>::value);\n+  STATIC_ASSERT(offsetof(ObjectMonitor, _metadata) == 0);\n+  return &_metadata;\n+}\n+\n+inline markWord ObjectMonitor::header() const {\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  return markWord(metadata());\n@@ -61,1 +76,12 @@\n-  Atomic::store(&_header, hdr);\n+  assert(!UseObjectMonitorTable, \"Lightweight locking with OM table does not use header\");\n+  set_metadata(hdr.value());\n+}\n+\n+inline intptr_t ObjectMonitor::hash() const {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  return metadata();\n+}\n+\n+inline void ObjectMonitor::set_hash(intptr_t hash) {\n+  assert(UseObjectMonitorTable, \"Only used by lightweight locking with OM table\");\n+  set_metadata(hash);\n@@ -183,0 +209,27 @@\n+inline ObjectMonitorContentionMark::ObjectMonitorContentionMark(ObjectMonitor* monitor)\n+  : _monitor(monitor) {\n+  _monitor->add_to_contentions(1);\n+}\n+\n+inline ObjectMonitorContentionMark::~ObjectMonitorContentionMark() {\n+  _monitor->add_to_contentions(-1);\n+}\n+\n+inline oop ObjectMonitor::object_peek() const {\n+  if (_object.is_null()) {\n+    return nullptr;\n+  }\n+  return _object.peek();\n+}\n+\n+inline bool ObjectMonitor::object_is_dead() const {\n+  return object_peek() == nullptr;\n+}\n+\n+inline bool ObjectMonitor::object_refers_to(oop obj) const {\n+  if (_object.is_null()) {\n+    return false;\n+  }\n+  return _object.peek() == obj;\n+}\n+\n","filename":"src\/hotspot\/share\/runtime\/objectMonitor.inline.hpp","additions":58,"deletions":5,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -1019,1 +1019,1 @@\n-                        bool print_ascii, int bytes_per_line, const_address logical_start) {\n+                        bool print_ascii, int bytes_per_line, const_address logical_start, const_address highlight_address) {\n@@ -1024,0 +1024,3 @@\n+  assert(highlight_address == nullptr || (highlight_address >= start && highlight_address < end),\n+         \"address %p to highlight not in range %p - %p\", highlight_address, start, end);\n+\n@@ -1040,1 +1043,5 @@\n-      st->print(PTR_FORMAT \":   \", p2i(logical_p));\n+      \/\/ highlight start of line if address of interest is located in the line\n+      const bool should_highlight = (highlight_address >= p && highlight_address < p + bytes_per_line);\n+      const char* const prefix =\n+        (highlight_address != nullptr) ? (should_highlight ? \"=>\" : \"  \") : \"\";\n+      st->print(\"%s\" PTR_FORMAT \":   \", prefix, p2i(logical_p));\n@@ -1085,1 +1092,1 @@\n-  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false);\n+  print_hex_dump(st, pc - 256, pc + 256, unitsize, \/* print_ascii=*\/false, pc);\n","filename":"src\/hotspot\/share\/runtime\/os.cpp","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -860,3 +860,3 @@\n-                             int bytes_per_line, const_address logical_start);\n-  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true) {\n-    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start);\n+                             int bytes_per_line, const_address logical_start, const_address highlight_address = nullptr);\n+  static void print_hex_dump(outputStream* st, const_address start, const_address end, int unitsize, bool print_ascii = true, const_address highlight_address = nullptr) {\n+    print_hex_dump(st, start, end, unitsize, print_ascii, \/*bytes_per_line=*\/16, \/*logical_start=*\/start, highlight_address);\n","filename":"src\/hotspot\/share\/runtime\/os.hpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1007,3 +1007,3 @@\n-          THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                      vmSymbols::throwable_void_signature(),\n-                      &args);\n+          THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                         vmSymbols::throwable_void_signature(),\n+                         &args);\n@@ -1031,3 +1031,3 @@\n-            THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-              vmSymbols::throwable_void_signature(),\n-              &args);\n+            THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                           vmSymbols::throwable_void_signature(),\n+                           &args);\n@@ -1120,3 +1120,3 @@\n-    THROW_ARG_0(vmSymbols::java_lang_reflect_InvocationTargetException(),\n-                vmSymbols::throwable_void_signature(),\n-                &args);\n+    THROW_ARG_NULL(vmSymbols::java_lang_reflect_InvocationTargetException(),\n+                   vmSymbols::throwable_void_signature(),\n+                   &args);\n","filename":"src\/hotspot\/share\/runtime\/reflection.cpp","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -156,0 +156,1 @@\n+#ifndef PRODUCT\n@@ -159,4 +160,0 @@\n-  void set_async(bool value)        { NOT_PRODUCT(_async = value;) }\n-  void set_skip_missing(bool value) { NOT_PRODUCT(_skip_missing = value;) }\n-\n-#ifndef PRODUCT\n@@ -169,0 +166,3 @@\n+  void set_async(bool value)        { NOT_PRODUCT(_async = value;) }\n+  void set_skip_missing(bool value) { NOT_PRODUCT(_skip_missing = value;) }\n+\n","filename":"src\/hotspot\/share\/runtime\/registerMap.hpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -734,0 +734,5 @@\n+\n+  \/\/ The oops in the monitor cache are cleared to prevent stale cache entries\n+  \/\/ from keeping dead objects alive. Because these oops are always cleared\n+  \/\/ before safepoint operations they are not visited in JavaThread::oops_do.\n+  _thread->om_clear_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/safepoint.cpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-#include \"memory\/universe.hpp\"\n@@ -37,0 +36,1 @@\n+#include \"memory\/universe.hpp\"\n@@ -38,0 +38,3 @@\n+#include \"prims\/jvmtiImpl.hpp\"\n+#include \"prims\/jvmtiTagMap.hpp\"\n+#include \"prims\/resolvedMethodTable.hpp\"\n@@ -43,1 +46,1 @@\n-#include \"runtime\/serviceThread.hpp\"\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -46,3 +49,1 @@\n-#include \"prims\/jvmtiImpl.hpp\"\n-#include \"prims\/jvmtiTagMap.hpp\"\n-#include \"prims\/resolvedMethodTable.hpp\"\n+#include \"runtime\/serviceThread.hpp\"\n@@ -97,0 +98,1 @@\n+    bool object_monitor_table_work = false;\n@@ -124,1 +126,2 @@\n-              (oopmap_cache_work = OopMapCache::has_cleanup_work())\n+              (oopmap_cache_work = OopMapCache::has_cleanup_work()) |\n+              (object_monitor_table_work = LightweightSynchronizer::needs_resize())\n@@ -186,0 +189,4 @@\n+\n+    if (object_monitor_table_work) {\n+      LightweightSynchronizer::resize_table(jt);\n+    }\n","filename":"src\/hotspot\/share\/runtime\/serviceThread.cpp","additions":13,"deletions":6,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -61,0 +61,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -72,1 +73,2 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n+#include \"runtime\/timerTrace.hpp\"\n@@ -79,0 +81,1 @@\n+#include \"utilities\/globalDefinitions.hpp\"\n@@ -89,1 +92,3 @@\n-\/\/ Shared stub locations\n+\/\/ Shared runtime stub routines reside in their own unique blob with a\n+\/\/ single entry point\n+\n@@ -96,1 +101,0 @@\n-address             SharedRuntime::_resolve_static_call_entry;\n@@ -103,0 +107,11 @@\n+RuntimeStub*        SharedRuntime::_throw_AbstractMethodError_blob;\n+RuntimeStub*        SharedRuntime::_throw_IncompatibleClassChangeError_blob;\n+RuntimeStub*        SharedRuntime::_throw_NullPointerException_at_call_blob;\n+RuntimeStub*        SharedRuntime::_throw_StackOverflowError_blob;\n+RuntimeStub*        SharedRuntime::_throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+RuntimeStub*        SharedRuntime::_jfr_write_checkpoint_blob = nullptr;\n+RuntimeStub*        SharedRuntime::_jfr_return_lease_blob = nullptr;\n+#endif\n+\n@@ -106,0 +121,7 @@\n+void SharedRuntime::generate_initial_stubs() {\n+  \/\/ Build this early so it's available for the interpreter.\n+  _throw_StackOverflowError_blob =\n+    generate_throw_exception(\"StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_StackOverflowError));\n+}\n+\n@@ -113,1 +135,16 @@\n-  _resolve_static_call_entry           = _resolve_static_call_blob->entry_point();\n+\n+  _throw_delayed_StackOverflowError_blob =\n+    generate_throw_exception(\"delayed StackOverflowError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_delayed_StackOverflowError));\n+\n+  _throw_AbstractMethodError_blob =\n+    generate_throw_exception(\"AbstractMethodError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_AbstractMethodError));\n+\n+  _throw_IncompatibleClassChangeError_blob =\n+    generate_throw_exception(\"IncompatibleClassChangeError throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_IncompatibleClassChangeError));\n+\n+  _throw_NullPointerException_at_call_blob =\n+    generate_throw_exception(\"NullPointerException at call throw_exception\",\n+                             CAST_FROM_FN_PTR(address, SharedRuntime::throw_NullPointerException_at_call));\n@@ -130,0 +167,13 @@\n+#if INCLUDE_JFR\n+\/\/------------------------------generate jfr runtime stubs ------\n+void SharedRuntime::generate_jfr_stubs() {\n+  ResourceMark rm;\n+  const char* timer_msg = \"SharedRuntime generate_jfr_stubs\";\n+  TraceTime timer(timer_msg, TRACETIME_LOG(Info, startuptime));\n+\n+  _jfr_write_checkpoint_blob = generate_jfr_write_checkpoint();\n+  _jfr_return_lease_blob = generate_jfr_return_lease();\n+}\n+\n+#endif \/\/ INCLUDE_JFR\n+\n@@ -868,1 +918,1 @@\n-        return StubRoutines::throw_StackOverflowError_entry();\n+        return SharedRuntime::throw_StackOverflowError_entry();\n@@ -894,1 +944,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -915,1 +965,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -926,1 +976,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -932,1 +982,1 @@\n-            return StubRoutines::throw_NullPointerException_at_call_entry();\n+            return SharedRuntime::throw_NullPointerException_at_call_entry();\n@@ -1468,1 +1518,1 @@\n-  address res = StubRoutines::throw_AbstractMethodError_entry();\n+  address res = SharedRuntime::throw_AbstractMethodError_entry();\n@@ -1886,1 +1936,1 @@\n-    if (ObjectSynchronizer::quick_enter(obj, current, lock)) {\n+    if (ObjectSynchronizer::quick_enter(obj, lock, current)) {\n@@ -2388,1 +2438,1 @@\n-                                                                StubRoutines::throw_AbstractMethodError_entry(),\n+                                                                SharedRuntime::throw_AbstractMethodError_entry(),\n@@ -2948,0 +2998,2 @@\n+      } else if (UseObjectMonitorTable) {\n+        buf[i] = (intptr_t)lock->object_monitor_cache();\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.cpp","additions":64,"deletions":12,"binary":false,"changes":76,"status":"modified"},{"patch":"@@ -57,1 +57,0 @@\n-  static address             _resolve_static_call_entry;\n@@ -67,0 +66,11 @@\n+  static RuntimeStub*        _throw_AbstractMethodError_blob;\n+  static RuntimeStub*        _throw_IncompatibleClassChangeError_blob;\n+  static RuntimeStub*        _throw_NullPointerException_at_call_blob;\n+  static RuntimeStub*        _throw_StackOverflowError_blob;\n+  static RuntimeStub*        _throw_delayed_StackOverflowError_blob;\n+\n+#if INCLUDE_JFR\n+  static RuntimeStub*        _jfr_write_checkpoint_blob;\n+  static RuntimeStub*        _jfr_return_lease_blob;\n+#endif\n+\n@@ -76,1 +86,1 @@\n-\n+  static RuntimeStub*   generate_throw_exception(const char* name, address runtime_entry);\n@@ -78,0 +88,1 @@\n+  static void generate_initial_stubs(void);\n@@ -79,0 +90,9 @@\n+#if INCLUDE_JFR\n+  static void generate_jfr_stubs(void);\n+  \/\/ For c2: c_rarg0 is junk, call to runtime to write a checkpoint.\n+  \/\/ It returns a jobject handle to the event writer.\n+  \/\/ The handle is dereferenced and the return value is the event writer oop.\n+  static RuntimeStub* generate_jfr_write_checkpoint();\n+  \/\/ For c2: call to runtime to return a buffer lease.\n+  static RuntimeStub* generate_jfr_return_lease();\n+#endif\n@@ -244,0 +264,12 @@\n+  \/\/ Implicit exceptions\n+  static address throw_AbstractMethodError_entry()          { return _throw_AbstractMethodError_blob->entry_point(); }\n+  static address throw_IncompatibleClassChangeError_entry() { return _throw_IncompatibleClassChangeError_blob->entry_point(); }\n+  static address throw_NullPointerException_at_call_entry() { return _throw_NullPointerException_at_call_blob->entry_point(); }\n+  static address throw_StackOverflowError_entry()           { return _throw_StackOverflowError_blob->entry_point(); }\n+  static address throw_delayed_StackOverflowError_entry()   { return _throw_delayed_StackOverflowError_blob->entry_point(); }\n+\n+#if INCLUDE_JFR\n+  static address jfr_write_checkpoint() { return _jfr_write_checkpoint_blob->entry_point(); }\n+  static address jfr_return_lease()     { return _jfr_return_lease_blob->entry_point(); }\n+#endif\n+\n","filename":"src\/hotspot\/share\/runtime\/sharedRuntime.hpp","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+#include \"sanitizers\/ub.hpp\"\n@@ -341,0 +342,1 @@\n+  ATTRIBUTE_NO_UBSAN\n","filename":"src\/hotspot\/share\/runtime\/signature.hpp","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,5 +64,0 @@\n-address StubRoutines::_throw_AbstractMethodError_entry          = nullptr;\n-address StubRoutines::_throw_IncompatibleClassChangeError_entry = nullptr;\n-address StubRoutines::_throw_NullPointerException_at_call_entry = nullptr;\n-address StubRoutines::_throw_StackOverflowError_entry           = nullptr;\n-address StubRoutines::_throw_delayed_StackOverflowError_entry   = nullptr;\n@@ -194,5 +189,0 @@\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_write_checkpoint_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_write_checkpoint = nullptr;)\n-JFR_ONLY(RuntimeStub* StubRoutines::_jfr_return_lease_stub = nullptr;)\n-JFR_ONLY(address StubRoutines::_jfr_return_lease = nullptr;)\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.cpp","additions":0,"deletions":10,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -39,1 +39,28 @@\n-\/\/ points are defined in the platform-specific inner class.\n+\/\/ points are defined in the platform-specific inner class. Most\n+\/\/ routines have a single (main) entry point. However, a few routines\n+\/\/ do provide alternative entry points.\n+\/\/\n+\/\/ Stub routines whose entries are advertised via class StubRoutines\n+\/\/ are generated in batches at well-defined stages during JVM init:\n+\/\/ initial stubs, continuation stubs, compiler stubs, final stubs.\n+\/\/ Each batch is embedded in a single, associated blob (an instance of\n+\/\/ BufferBlob) i.e. the blob to entry relationship is 1-m.\n+\/\/\n+\/\/ Note that this constrasts with the much smaller number of stub\n+\/\/ routines generated via classes SharedRuntime, c1_Runtime1 and\n+\/\/ OptoRuntime. The latter routines are also generated at well-defined\n+\/\/ points during JVM init. However, each stub routine has its own\n+\/\/ unique blob (various subclasses of RuntimeBlob) i.e. the blob to\n+\/\/ entry relationship is 1-1. The difference arises because\n+\/\/ SharedRuntime routines may need to be relocatable or advertise\n+\/\/ properties such as a frame size via their blob.\n+\/\/\n+\/\/ Staging of stub routine generation is needed in order to manage\n+\/\/ init dependencies between 1) stubs and other stubs or 2) stubs and\n+\/\/ other runtime components. For example, some exception throw stubs\n+\/\/ need to be generated before compiler stubs (such as the\n+\/\/ deoptimization stub) so that the latter can invoke the thrwo rotine\n+\/\/ in bail-out code. Likewise, stubs that access objects (such as the\n+\/\/ object array copy stub) need to be created after initialization of\n+\/\/ some GC constants and generation of the GC barrier stubs they might\n+\/\/ need to invoke.\n@@ -52,2 +79,1 @@\n-\/\/    stubRoutines_<os_family>.cpp       stubGenerator_<arch>.cpp\n-\/\/    stubRoutines_<os_arch>.cpp\n+\/\/                                       stubGenerator_<arch>.cpp\n@@ -78,0 +104,2 @@\n+\/\/ 5. ensure the entry is generated in the right blob to satisfy initialization\n+\/\/    dependencies between it and other stubs or runtime components.\n@@ -140,5 +168,0 @@\n-  static address _throw_AbstractMethodError_entry;\n-  static address _throw_IncompatibleClassChangeError_entry;\n-  static address _throw_NullPointerException_at_call_entry;\n-  static address _throw_StackOverflowError_entry;\n-  static address _throw_delayed_StackOverflowError_entry;\n@@ -272,5 +295,0 @@\n-  JFR_ONLY(static RuntimeStub* _jfr_write_checkpoint_stub;)\n-  JFR_ONLY(static address _jfr_write_checkpoint;)\n-  JFR_ONLY(static RuntimeStub* _jfr_return_lease_stub;)\n-  JFR_ONLY(static address _jfr_return_lease;)\n-\n@@ -332,6 +350,0 @@\n-  \/\/ Implicit exceptions\n-  static address throw_AbstractMethodError_entry()         { return _throw_AbstractMethodError_entry; }\n-  static address throw_IncompatibleClassChangeError_entry(){ return _throw_IncompatibleClassChangeError_entry; }\n-  static address throw_NullPointerException_at_call_entry(){ return _throw_NullPointerException_at_call_entry; }\n-  static address throw_StackOverflowError_entry()          { return _throw_StackOverflowError_entry; }\n-  static address throw_delayed_StackOverflowError_entry()  { return _throw_delayed_StackOverflowError_entry; }\n@@ -490,3 +502,0 @@\n-  JFR_ONLY(static address jfr_write_checkpoint() { return _jfr_write_checkpoint; })\n-  JFR_ONLY(static address jfr_return_lease() { return _jfr_return_lease; })\n-\n","filename":"src\/hotspot\/share\/runtime\/stubRoutines.hpp","additions":31,"deletions":22,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+#include \"runtime\/basicLock.inline.hpp\"\n@@ -44,0 +45,1 @@\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n@@ -55,1 +57,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -279,0 +281,4 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::initialize();\n+  }\n@@ -352,1 +358,5 @@\n-    ObjectMonitor* const mon = mark.monitor();\n+    ObjectMonitor* const mon = read_monitor(current, obj, mark);\n+    if (LockingMode == LM_LIGHTWEIGHT && mon == nullptr) {\n+      \/\/ Racing with inflation\/deflation go slow path\n+      return false;\n+    }\n@@ -379,0 +389,7 @@\n+static bool useHeavyMonitors() {\n+#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n+  return LockingMode == LM_MONITOR;\n+#else\n+  return false;\n+#endif\n+}\n@@ -386,2 +403,1 @@\n-bool ObjectSynchronizer::quick_enter(oop obj, JavaThread* current,\n-                                     BasicLock * lock) {\n+bool ObjectSynchronizer::quick_enter_legacy(oop obj, BasicLock* lock, JavaThread* current) {\n@@ -389,2 +405,0 @@\n-  NoSafepointVerifier nsv;\n-  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n@@ -392,2 +406,2 @@\n-  if (obj->klass()->is_value_based()) {\n-    return false;\n+  if (useHeavyMonitors()) {\n+    return false;  \/\/ Slow path\n@@ -397,10 +411,1 @@\n-    LockStack& lock_stack = current->lock_stack();\n-    if (lock_stack.is_full()) {\n-      \/\/ Always go into runtime if the lock stack is full.\n-      return false;\n-    }\n-    if (lock_stack.try_recursive_enter(obj)) {\n-      \/\/ Recursive lock successful.\n-      current->inc_held_monitor_count();\n-      return true;\n-    }\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n@@ -409,0 +414,2 @@\n+  assert(LockingMode == LM_LEGACY, \"legacy mode below\");\n+\n@@ -412,1 +419,2 @@\n-    ObjectMonitor* const m = mark.monitor();\n+\n+    ObjectMonitor* const m = read_monitor(mark);\n@@ -432,12 +440,10 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ This Java Monitor is inflated so obj's header will never be\n-      \/\/ displaced to this thread's BasicLock. Make the displaced header\n-      \/\/ non-null so this BasicLock is not seen as recursive nor as\n-      \/\/ being locked. We do this unconditionally so that this thread's\n-      \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n-      \/\/ performance reasons, stack walkers generally first check for\n-      \/\/ stack-locking in the object's header, the second check is for\n-      \/\/ recursive stack-locking in the displaced header in the BasicLock,\n-      \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n-      lock->set_displaced_header(markWord::unused_mark());\n-    }\n+    \/\/ This Java Monitor is inflated so obj's header will never be\n+    \/\/ displaced to this thread's BasicLock. Make the displaced header\n+    \/\/ non-null so this BasicLock is not seen as recursive nor as\n+    \/\/ being locked. We do this unconditionally so that this thread's\n+    \/\/ BasicLock cannot be mis-interpreted by any stack walkers. For\n+    \/\/ performance reasons, stack walkers generally first check for\n+    \/\/ stack-locking in the object's header, the second check is for\n+    \/\/ recursive stack-locking in the displaced header in the BasicLock,\n+    \/\/ and last are the inflated Java Monitor (ObjectMonitor) checks.\n+    lock->set_displaced_header(markWord::unused_mark());\n@@ -511,8 +517,0 @@\n-static bool useHeavyMonitors() {\n-#if defined(X86) || defined(AARCH64) || defined(PPC64) || defined(RISCV64) || defined(S390)\n-  return LockingMode == LM_MONITOR;\n-#else\n-  return false;\n-#endif\n-}\n-\n@@ -527,0 +525,5 @@\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::enter_for(obj, lock, locking_thread);\n+  }\n+\n@@ -543,2 +546,1 @@\n-void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n-  assert(current == Thread::current(), \"must be\");\n+void ObjectSynchronizer::enter_legacy(Handle obj, BasicLock* lock, JavaThread* current) {\n@@ -564,0 +566,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -572,55 +575,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = locking_thread->lock_stack();\n-      if (lock_stack.is_full()) {\n-        \/\/ We unconditionally make room on the lock stack by inflating\n-        \/\/ the least recently locked object on the lock stack.\n-\n-        \/\/ About the choice to inflate least recently locked object.\n-        \/\/ First we must chose to inflate a lock, either some lock on\n-        \/\/ the lock-stack or the lock that is currently being entered\n-        \/\/ (which may or may not be on the lock-stack).\n-        \/\/ Second the best lock to inflate is a lock which is entered\n-        \/\/ in a control flow where there are only a very few locks being\n-        \/\/ used, as the costly part of inflated locking is inflation,\n-        \/\/ not locking. But this property is entirely program dependent.\n-        \/\/ Third inflating the lock currently being entered on when it\n-        \/\/ is not present on the lock-stack will result in a still full\n-        \/\/ lock-stack. This creates a scenario where every deeper nested\n-        \/\/ monitorenter must call into the runtime.\n-        \/\/ The rational here is as follows:\n-        \/\/ Because we cannot (currently) figure out the second, and want\n-        \/\/ to avoid the third, we inflate a lock on the lock-stack.\n-        \/\/ The least recently locked lock is chosen as it is the lock\n-        \/\/ with the longest critical section.\n-\n-        log_info(monitorinflation)(\"LockStack capacity exceeded, inflating.\");\n-        ObjectMonitor* monitor = inflate_for(locking_thread, lock_stack.bottom(), inflate_cause_vm_internal);\n-        assert(monitor->owner() == Thread::current(), \"must be owner=\" PTR_FORMAT \" current=\" PTR_FORMAT \" mark=\" PTR_FORMAT,\n-               p2i(monitor->owner()), p2i(Thread::current()), monitor->object()->mark_acquire().value());\n-        assert(!lock_stack.is_full(), \"must have made room here\");\n-      }\n-\n-      markWord mark = obj()->mark_acquire();\n-      while (mark.is_unlocked()) {\n-        \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-        \/\/ Try to swing into 'fast-locked' state.\n-        assert(!lock_stack.contains(obj()), \"thread must not already hold the lock\");\n-        const markWord locked_mark = mark.set_fast_locked();\n-        const markWord old_mark = obj()->cas_set_mark(locked_mark, mark);\n-        if (old_mark == mark) {\n-          \/\/ Successfully fast-locked, push object to lock-stack and return.\n-          lock_stack.push(obj());\n-          return true;\n-        }\n-        mark = old_mark;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_enter(obj())) {\n-        \/\/ Recursive lock successful.\n-        return true;\n-      }\n-\n-      \/\/ Failed to fast lock.\n-      return false;\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -659,2 +608,2 @@\n-void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n-  current->dec_held_monitor_count();\n+void ObjectSynchronizer::exit_legacy(oop object, BasicLock* lock, JavaThread* current) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"Use LightweightSynchronizer\");\n@@ -664,26 +613,1 @@\n-    if (LockingMode == LM_LIGHTWEIGHT) {\n-      \/\/ Fast-locking does not use the 'lock' argument.\n-      LockStack& lock_stack = current->lock_stack();\n-      if (mark.is_fast_locked() && lock_stack.try_recursive_exit(object)) {\n-        \/\/ Recursively unlocked.\n-        return;\n-      }\n-\n-      if (mark.is_fast_locked() && lock_stack.is_recursive(object)) {\n-        \/\/ This lock is recursive but is not at the top of the lock stack so we're\n-        \/\/ doing an unbalanced exit. We have to fall thru to inflation below and\n-        \/\/ let ObjectMonitor::exit() do the unlock.\n-      } else {\n-        while (mark.is_fast_locked()) {\n-          \/\/ Retry until a lock state change has been observed. cas_set_mark() may collide with non lock bits modifications.\n-          const markWord unlocked_mark = mark.set_unlocked();\n-          const markWord old_mark = object->cas_set_mark(unlocked_mark, mark);\n-          if (old_mark == mark) {\n-            size_t recursions = lock_stack.remove(object) - 1;\n-            assert(recursions == 0, \"must not be recursive here\");\n-            return;\n-          }\n-          mark = old_mark;\n-        }\n-      }\n-    } else if (LockingMode == LM_LEGACY) {\n+    if (LockingMode == LM_LEGACY) {\n@@ -711,1 +635,1 @@\n-            ObjectMonitor* m = mark.monitor();\n+            ObjectMonitor* m = read_monitor(mark);\n@@ -755,2 +679,10 @@\n-    ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_jni_enter);\n-    if (monitor->enter(current)) {\n+    ObjectMonitor* monitor;\n+    bool entered;\n+    if (LockingMode == LM_LIGHTWEIGHT) {\n+      entered = LightweightSynchronizer::inflate_and_enter(obj(), inflate_cause_jni_enter, current, current) != nullptr;\n+    } else {\n+      monitor = inflate(current, obj(), inflate_cause_jni_enter);\n+      entered = monitor->enter(current);\n+    }\n+\n+    if (entered) {\n@@ -768,3 +700,8 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n-  ObjectMonitor* monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj, inflate_cause_jni_exit, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped inside exit() and the ObjectMonitor* must be !is_busy().\n+    monitor = inflate(current, obj, inflate_cause_jni_exit);\n+  }\n@@ -803,0 +740,1 @@\n+\n@@ -808,4 +746,10 @@\n-  \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n-  \/\/ field is incremented before ownership is dropped and decremented\n-  \/\/ after ownership is regained.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_wait);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK_0);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated because the _waiters\n+    \/\/ field is incremented before ownership is dropped and decremented\n+    \/\/ after ownership is regained.\n+    monitor = inflate(current, obj(), inflate_cause_wait);\n+  }\n@@ -828,3 +772,8 @@\n-  ObjectSynchronizer::inflate(THREAD,\n-                              obj(),\n-                              inflate_cause_wait)->wait(millis, false, THREAD);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_wait, CHECK);\n+  } else {\n+    monitor = inflate(THREAD, obj(), inflate_cause_wait);\n+  }\n+  monitor->wait(millis, false, THREAD);\n@@ -849,3 +798,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -871,3 +826,9 @@\n-  \/\/ The ObjectMonitor* can't be async deflated until ownership is\n-  \/\/ dropped by the calling thread.\n-  ObjectMonitor* monitor = inflate(current, obj(), inflate_cause_notify);\n+\n+  ObjectMonitor* monitor;\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    monitor = LightweightSynchronizer::inflate_locked_or_imse(obj(), inflate_cause_notify, CHECK);\n+  } else {\n+    \/\/ The ObjectMonitor* can't be async deflated until ownership is\n+    \/\/ dropped by the calling thread.\n+    monitor = inflate(current, obj(), inflate_cause_notify);\n+  }\n@@ -971,1 +932,1 @@\n-static inline intptr_t get_next_hash(Thread* current, oop obj) {\n+static intptr_t get_next_hash(Thread* current, oop obj) {\n@@ -1011,0 +972,21 @@\n+static intptr_t install_hash_code(Thread* current, oop obj) {\n+  assert(UseObjectMonitorTable && LockingMode == LM_LIGHTWEIGHT, \"must be\");\n+\n+  markWord mark = obj->mark_acquire();\n+  for (;;) {\n+    intptr_t hash = mark.hash();\n+    if (hash != 0) {\n+      return hash;\n+    }\n+\n+    hash = get_next_hash(current, obj);\n+    const markWord old_mark = mark;\n+    const markWord new_mark = old_mark.copy_set_hash(hash);\n+\n+    mark = obj->cas_set_mark(new_mark, old_mark);\n+    if (old_mark == mark) {\n+      return hash;\n+    }\n+  }\n+}\n+\n@@ -1012,0 +994,5 @@\n+  if (UseObjectMonitorTable) {\n+    \/\/ Since the monitor isn't in the object header, the hash can simply be\n+    \/\/ installed in the object header.\n+    return install_hash_code(current, obj);\n+  }\n@@ -1105,1 +1092,1 @@\n-      uintptr_t v = Atomic::cmpxchg((volatile uintptr_t*)monitor->header_addr(), mark.value(), temp.value());\n+      uintptr_t v = Atomic::cmpxchg(monitor->metadata_addr(), mark.value(), temp.value());\n@@ -1117,1 +1104,1 @@\n-      if (monitor->is_being_async_deflated()) {\n+      if (monitor->is_being_async_deflated() && !UseObjectMonitorTable) {\n@@ -1148,1 +1135,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(current, obj, mark);\n+    if (monitor != nullptr) {\n+      return monitor->is_entered(current) != 0;\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked, current could not have held the lock\n+      return false;\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1152,1 +1153,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1176,1 +1177,15 @@\n-  if (mark.has_monitor()) {\n+  while (LockingMode == LM_LIGHTWEIGHT && mark.has_monitor()) {\n+    ObjectMonitor* monitor = read_monitor(Thread::current(), obj, mark);\n+    if (monitor != nullptr) {\n+      return Threads::owning_thread_from_monitor(t_list, monitor);\n+    }\n+    \/\/ Racing with inflation\/deflation, retry\n+    mark = obj->mark_acquire();\n+\n+    if (mark.is_fast_locked()) {\n+      \/\/ Some other thread fast_locked\n+      return Threads::owning_thread_from_object(t_list, h_obj());\n+    }\n+  }\n+\n+  if (LockingMode != LM_LIGHTWEIGHT && mark.has_monitor()) {\n@@ -1180,1 +1195,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1392,0 +1407,1 @@\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n@@ -1394,1 +1410,1 @@\n-    ObjectMonitor* monitor = mark.monitor();\n+    ObjectMonitor* monitor = read_monitor(mark);\n@@ -1404,4 +1420,2 @@\n-  if (LockingMode == LM_LIGHTWEIGHT && current->is_Java_thread()) {\n-    return inflate_impl(JavaThread::cast(current), obj, cause);\n-  }\n-  return inflate_impl(nullptr, obj, cause);\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"only inflate through enter\");\n+  return inflate_impl(obj, cause);\n@@ -1412,12 +1426,6 @@\n-  return inflate_impl(thread, obj, cause);\n-}\n-\n-ObjectMonitor* ObjectSynchronizer::inflate_impl(JavaThread* inflating_thread, oop object, const InflateCause cause) {\n-  \/\/ The JavaThread* inflating_thread parameter is only used by LM_LIGHTWEIGHT and requires\n-  \/\/ that the inflating_thread == Thread::current() or is suspended throughout the call by\n-  \/\/ some other mechanism.\n-  \/\/ Even with LM_LIGHTWEIGHT the thread might be nullptr when called from a non\n-  \/\/ JavaThread. (As may still be the case from FastHashCode). However it is only\n-  \/\/ important for the correctness of the LM_LIGHTWEIGHT algorithm that the thread\n-  \/\/ is set when called from ObjectSynchronizer::enter from the owning thread,\n-  \/\/ ObjectSynchronizer::enter_for from any thread, or ObjectSynchronizer::exit.\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_for\");\n+  return inflate_impl(obj, cause);\n+}\n+\n+ObjectMonitor* ObjectSynchronizer::inflate_impl(oop object, const InflateCause cause) {\n+  assert(LockingMode != LM_LIGHTWEIGHT, \"LM_LIGHTWEIGHT cannot use inflate_impl\");\n@@ -1430,7 +1438,1 @@\n-    \/\/ *  inflated     - Just return if using stack-locking.\n-    \/\/                   If using fast-locking and the ObjectMonitor owner\n-    \/\/                   is anonymous and the inflating_thread owns the\n-    \/\/                   object lock, then we make the inflating_thread\n-    \/\/                   the ObjectMonitor owner and remove the lock from\n-    \/\/                   the inflating_thread's lock stack.\n-    \/\/ *  fast-locked  - Coerce it to inflated from fast-locked.\n+    \/\/ *  inflated     - Just return it.\n@@ -1447,6 +1449,0 @@\n-      if (LockingMode == LM_LIGHTWEIGHT && inf->is_owner_anonymous() &&\n-          inflating_thread != nullptr && inflating_thread->lock_stack().contains(object)) {\n-        inf->set_owner_from_anonymous(inflating_thread);\n-        size_t removed = inflating_thread->lock_stack().remove(object);\n-        inf->set_recursions(removed - 1);\n-      }\n@@ -1456,65 +1452,9 @@\n-    if (LockingMode != LM_LIGHTWEIGHT) {\n-      \/\/ New lightweight locking does not use INFLATING.\n-      \/\/ CASE: inflation in progress - inflating over a stack-lock.\n-      \/\/ Some other thread is converting from stack-locked to inflated.\n-      \/\/ Only that thread can complete inflation -- other threads must wait.\n-      \/\/ The INFLATING value is transient.\n-      \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n-      \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n-      if (mark == markWord::INFLATING()) {\n-        read_stable_mark(object);\n-        continue;\n-      }\n-    }\n-\n-    \/\/ CASE: fast-locked\n-    \/\/ Could be fast-locked either by the inflating_thread or by some other thread.\n-    \/\/\n-    \/\/ Note that we allocate the ObjectMonitor speculatively, _before_\n-    \/\/ attempting to set the object's mark to the new ObjectMonitor. If\n-    \/\/ the inflating_thread owns the monitor, then we set the ObjectMonitor's\n-    \/\/ owner to the inflating_thread. Otherwise, we set the ObjectMonitor's owner\n-    \/\/ to anonymous. If we lose the race to set the object's mark to the\n-    \/\/ new ObjectMonitor, then we just delete it and loop around again.\n-    \/\/\n-    LogStreamHandle(Trace, monitorinflation) lsh;\n-    if (LockingMode == LM_LIGHTWEIGHT && mark.is_fast_locked()) {\n-      ObjectMonitor* monitor = new ObjectMonitor(object);\n-      monitor->set_header(mark.set_unlocked());\n-      bool own = inflating_thread != nullptr && inflating_thread->lock_stack().contains(object);\n-      if (own) {\n-        \/\/ Owned by inflating_thread.\n-        monitor->set_owner_from(nullptr, inflating_thread);\n-      } else {\n-        \/\/ Owned by somebody else.\n-        monitor->set_owner_anonymous();\n-      }\n-      markWord monitor_mark = markWord::encode(monitor);\n-      markWord old_mark = object->cas_set_mark(monitor_mark, mark);\n-      if (old_mark == mark) {\n-        \/\/ Success! Return inflated monitor.\n-        if (own) {\n-          size_t removed = inflating_thread->lock_stack().remove(object);\n-          monitor->set_recursions(removed - 1);\n-        }\n-        \/\/ Once the ObjectMonitor is configured and object is associated\n-        \/\/ with the ObjectMonitor, it is safe to allow async deflation:\n-        _in_use_list.add(monitor);\n-\n-        \/\/ Hopefully the performance counters are allocated on distinct\n-        \/\/ cache lines to avoid false sharing on MP systems ...\n-        OM_PERFDATA_OP(Inflations, inc());\n-        if (log_is_enabled(Trace, monitorinflation)) {\n-          ResourceMark rm;\n-          lsh.print_cr(\"inflate(has_locker): object=\" INTPTR_FORMAT \", mark=\"\n-                       INTPTR_FORMAT \", type='%s'\", p2i(object),\n-                       object->mark().value(), object->klass()->external_name());\n-        }\n-        if (event.should_commit()) {\n-          post_monitor_inflate_event(&event, object, cause);\n-        }\n-        return monitor;\n-      } else {\n-        delete monitor;\n-        continue;  \/\/ Interference -- just retry\n-      }\n+    \/\/ CASE: inflation in progress - inflating over a stack-lock.\n+    \/\/ Some other thread is converting from stack-locked to inflated.\n+    \/\/ Only that thread can complete inflation -- other threads must wait.\n+    \/\/ The INFLATING value is transient.\n+    \/\/ Currently, we spin\/yield\/park and poll the markword, waiting for inflation to finish.\n+    \/\/ We could always eliminate polling by parking the thread on some auxiliary list.\n+    if (mark == markWord::INFLATING()) {\n+      read_stable_mark(object);\n+      continue;\n@@ -1534,0 +1474,1 @@\n+    LogStreamHandle(Trace, monitorinflation) lsh;\n@@ -1535,1 +1476,0 @@\n-      assert(LockingMode != LM_LIGHTWEIGHT, \"cannot happen with new lightweight locking\");\n@@ -1667,0 +1607,1 @@\n+  Thread* current = Thread::current();\n@@ -1673,1 +1614,1 @@\n-    if (mid->deflate_monitor()) {\n+    if (mid->deflate_monitor(current)) {\n@@ -1691,0 +1632,5 @@\n+    if (thread->is_Java_thread()) {\n+      \/\/ Clear OM cache\n+      JavaThread* jt = JavaThread::cast(thread);\n+      jt->om_clear_monitor_cache();\n+    }\n@@ -1837,0 +1783,8 @@\n+#ifdef ASSERT\n+    if (UseObjectMonitorTable) {\n+      for (ObjectMonitor* monitor : delete_list) {\n+        assert(!LightweightSynchronizer::contains_monitor(current, monitor), \"Should have been removed\");\n+      }\n+    }\n+#endif\n+\n@@ -2045,1 +1999,2 @@\n-  if (n->header().value() == 0) {\n+\n+  if (n->metadata() == 0) {\n@@ -2047,1 +2002,1 @@\n-                  \"have non-null _header field.\", p2i(n));\n+                  \"have non-null _metadata (header\/hash) field.\", p2i(n));\n@@ -2050,0 +2005,1 @@\n+\n@@ -2051,17 +2007,21 @@\n-  if (obj != nullptr) {\n-    const markWord mark = obj->mark();\n-    if (!mark.has_monitor()) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not think it has a monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n-                    p2i(obj), mark.value());\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n-    ObjectMonitor* const obj_mon = mark.monitor();\n-    if (n != obj_mon) {\n-      out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n-                    \"object does not refer to the same monitor: obj=\"\n-                    INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n-                    INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n-      *error_cnt_p = *error_cnt_p + 1;\n-    }\n+  if (obj == nullptr) {\n+    return;\n+  }\n+\n+  const markWord mark = obj->mark();\n+  if (!mark.has_monitor()) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not think it has a monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT, p2i(n),\n+                  p2i(obj), mark.value());\n+    *error_cnt_p = *error_cnt_p + 1;\n+    return;\n+  }\n+\n+  ObjectMonitor* const obj_mon = read_monitor(Thread::current(), obj, mark);\n+  if (n != obj_mon) {\n+    out->print_cr(\"ERROR: monitor=\" INTPTR_FORMAT \": in-use monitor's \"\n+                  \"object does not refer to the same monitor: obj=\"\n+                  INTPTR_FORMAT \", mark=\" INTPTR_FORMAT \", obj_mon=\"\n+                  INTPTR_FORMAT, p2i(n), p2i(obj), mark.value(), p2i(obj_mon));\n+    *error_cnt_p = *error_cnt_p + 1;\n@@ -2090,1 +2050,1 @@\n-        const markWord mark = monitor->header();\n+        const intptr_t hash = UseObjectMonitorTable ? monitor->hash() : monitor->header().hash();\n@@ -2093,1 +2053,1 @@\n-                   monitor->is_busy(), mark.hash() != 0, monitor->owner() != nullptr,\n+                   monitor->is_busy(), hash != 0, monitor->owner() != nullptr,\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.cpp","additions":228,"deletions":268,"binary":false,"changes":496,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+#include \"runtime\/javaThread.hpp\"\n@@ -96,2 +97,3 @@\n-  static void enter(Handle obj, BasicLock* lock, JavaThread* current);\n-  static void exit(oop obj, BasicLock* lock, JavaThread* current);\n+  static inline void enter(Handle obj, BasicLock* lock, JavaThread* current);\n+  static inline void exit(oop obj, BasicLock* lock, JavaThread* current);\n+\n@@ -109,0 +111,3 @@\n+  static bool quick_enter_legacy(oop obj, BasicLock* Lock, JavaThread* current);\n+  static void enter_legacy(Handle obj, BasicLock* Lock, JavaThread* current);\n+  static void exit_legacy(oop obj, BasicLock* lock, JavaThread* current);\n@@ -121,1 +126,1 @@\n-  static bool quick_enter(oop obj, JavaThread* current, BasicLock* Lock);\n+  static inline bool quick_enter(oop obj, BasicLock* Lock, JavaThread* current);\n@@ -135,1 +140,1 @@\n-  static ObjectMonitor* inflate_impl(JavaThread* thread, oop obj, const InflateCause cause);\n+  static ObjectMonitor* inflate_impl(oop obj, const InflateCause cause);\n@@ -142,0 +147,3 @@\n+  inline static ObjectMonitor* read_monitor(markWord mark);\n+  inline static ObjectMonitor* read_monitor(Thread* current, oop obj, markWord mark);\n+\n@@ -203,0 +211,1 @@\n+  friend class LightweightSynchronizer;\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.hpp","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,81 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+#ifndef SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+#define SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n+\n+#include \"runtime\/synchronizer.hpp\"\n+\n+#include \"runtime\/lightweightSynchronizer.hpp\"\n+#include \"runtime\/safepointVerifiers.hpp\"\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(markWord mark) {\n+  return mark.monitor();\n+}\n+\n+inline ObjectMonitor* ObjectSynchronizer::read_monitor(Thread* current, oop obj, markWord mark) {\n+  if (!UseObjectMonitorTable) {\n+    return read_monitor(mark);\n+  } else {\n+    return LightweightSynchronizer::get_monitor_from_table(current, obj);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::enter(Handle obj, BasicLock* lock, JavaThread* current) {\n+  assert(current == Thread::current(), \"must be\");\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::enter(obj, lock, current);\n+  } else {\n+    enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline bool ObjectSynchronizer::quick_enter(oop obj, BasicLock* lock, JavaThread* current) {\n+  assert(current->thread_state() == _thread_in_Java, \"invariant\");\n+  NoSafepointVerifier nsv;\n+  if (obj == nullptr) return false;       \/\/ Need to throw NPE\n+\n+  if (obj->klass()->is_value_based()) {\n+    return false;\n+  }\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    return LightweightSynchronizer::quick_enter(obj, lock, current);\n+  } else {\n+    return quick_enter_legacy(obj, lock, current);\n+  }\n+}\n+\n+inline void ObjectSynchronizer::exit(oop object, BasicLock* lock, JavaThread* current) {\n+  current->dec_held_monitor_count();\n+\n+  if (LockingMode == LM_LIGHTWEIGHT) {\n+    LightweightSynchronizer::exit(object, current);\n+  } else {\n+    exit_legacy(object, lock, current);\n+  }\n+}\n+\n+#endif \/\/ SHARE_RUNTIME_SYNCHRONIZER_INLINE_HPP\n","filename":"src\/hotspot\/share\/runtime\/synchronizer.inline.hpp","additions":81,"deletions":0,"binary":false,"changes":81,"status":"added"},{"patch":"@@ -987,0 +987,1 @@\n+  if (version == JNI_VERSION_24) return JNI_TRUE;\n","filename":"src\/hotspot\/share\/runtime\/threads.cpp","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-#include \"runtime\/synchronizer.hpp\"\n+#include \"runtime\/synchronizer.inline.hpp\"\n@@ -250,3 +250,6 @@\n-          if (mark.has_monitor() &&\n-              ( \/\/ we have marked ourself as pending on this monitor\n-                mark.monitor() == thread()->current_pending_monitor() ||\n+          if (mark.has_monitor()) {\n+            ObjectMonitor* mon = ObjectSynchronizer::read_monitor(current, monitor->owner(), mark);\n+            if (\/\/ if the monitor is null we must be in the process of locking\n+                mon == nullptr ||\n+                \/\/ we have marked ourself as pending on this monitor\n+                mon == thread()->current_pending_monitor() ||\n@@ -254,3 +257,3 @@\n-                !mark.monitor()->is_entered(thread())\n-              )) {\n-            lock_state = \"waiting to lock\";\n+                !mon->is_entered(thread())) {\n+              lock_state = \"waiting to lock\";\n+            }\n@@ -622,1 +625,1 @@\n-  if (WizardMode) _fr.print_value_on(output, nullptr);\n+  if (WizardMode) _fr.print_value_on(output);\n@@ -737,1 +740,1 @@\n-  _fr.print_value_on(output, nullptr);\n+  _fr.print_value_on(output);\n","filename":"src\/hotspot\/share\/runtime\/vframe.cpp","additions":12,"deletions":9,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -90,1 +90,2 @@\n-  template(JFRCheckpoint)                         \\\n+  template(JFRSafepointClear)                     \\\n+  template(JFRSafepointWrite)                     \\\n","filename":"src\/hotspot\/share\/runtime\/vmOperation.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -249,1 +249,0 @@\n-  nonstatic_field(InstanceKlass,               _is_marked_dependent,                          bool)                                  \\\n@@ -781,1 +780,1 @@\n-  volatile_nonstatic_field(ObjectMonitor,      _header,                                       markWord)                              \\\n+  volatile_nonstatic_field(ObjectMonitor,      _metadata,                                     uintptr_t)                             \\\n@@ -785,1 +784,1 @@\n-  volatile_nonstatic_field(BasicLock,          _displaced_header,                             markWord)                              \\\n+  volatile_nonstatic_field(BasicLock,          _metadata,                                     uintptr_t)                             \\\n@@ -1425,0 +1424,1 @@\n+  declare_c2_type(ForwardExceptionNode, ReturnNode)                       \\\n@@ -2018,2 +2018,0 @@\n-  declare_constant(JVM_ACC_HAS_FINALIZER)                                 \\\n-  declare_constant(JVM_ACC_IS_CLONEABLE_FAST)                             \\\n","filename":"src\/hotspot\/share\/runtime\/vmStructs.cpp","additions":3,"deletions":5,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -131,0 +131,16 @@\n+bool ClassLoadingService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose looks for a non-exact match for class+load,\n+    \/\/ so look for all tag sets that match class+load*\n+    if (ts->contains(LogTag::_class) &&\n+        ts->contains(LogTag::_load)) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l != LogLevel::Info && l != LogLevel::Debug && l != LogLevel::Trace) {\n+        return false;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/classLoadingService.cpp","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,1 @@\n+  static bool get_verbose() NOT_MANAGEMENT_RETURN_(false);\n@@ -66,1 +67,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, class, load); }\n","filename":"src\/hotspot\/share\/services\/classLoadingService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-    const int length = java_lang_String::utf8_length(string, value);\n+    const size_t length = java_lang_String::utf8_length(string, value);\n","filename":"src\/hotspot\/share\/services\/finalizerService.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1823,1 +1823,1 @@\n-    THROW_(vmSymbols::java_lang_NullPointerException(), 0);\n+    THROW_NULL(vmSymbols::java_lang_NullPointerException());\n@@ -1831,2 +1831,2 @@\n-    THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n-               \"The length of the given MemoryUsage array does not match the number of memory pools.\", 0);\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),\n+                   \"The length of the given MemoryUsage array does not match the number of memory pools.\");\n@@ -1839,2 +1839,2 @@\n-    THROW_MSG_(vmSymbols::java_lang_IllegalArgumentException(),\n-               \"The element type is not MemoryUsage class\", 0);\n+    THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(),\n+                   \"The element type is not MemoryUsage class\");\n","filename":"src\/hotspot\/share\/services\/management.cpp","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -205,0 +205,15 @@\n+bool MemoryService::get_verbose() {\n+  for (LogTagSet* ts = LogTagSet::first(); ts != nullptr; ts = ts->next()) {\n+    \/\/ set_verbose only sets gc and not gc*, so check for an exact match\n+    const bool is_gc_exact_match = ts->contains(LogTag::_gc) && ts->ntags() == 1;\n+    if (is_gc_exact_match) {\n+      LogLevelType l = ts->level_for(LogConfiguration::StdoutLog);\n+      if (l == LogLevel::Info || l == LogLevel::Debug || l == LogLevel::Trace) {\n+        return true;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n","filename":"src\/hotspot\/share\/services\/memoryService.cpp","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -109,1 +109,0 @@\n-  static bool get_verbose() { return log_is_enabled(Info, gc); }\n@@ -111,0 +110,1 @@\n+  static bool get_verbose();\n","filename":"src\/hotspot\/share\/services\/memoryService.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,3 +43,0 @@\n-  \/\/ HotSpot-specific access flags\n-  \/\/ These Klass flags should be migrated, to a field such as InstanceKlass::_misc_flags,\n-  \/\/ or to a similar flags field in Klass itself.\n@@ -47,4 +44,0 @@\n-  JVM_ACC_HAS_FINALIZER           = 0x40000000,     \/\/ True if klass has a non-empty finalize() method\n-  JVM_ACC_IS_CLONEABLE_FAST       = (int)0x80000000,\/\/ True if klass implements the Cloneable interface and can be optimized in generated code\n-  JVM_ACC_IS_HIDDEN_CLASS         = 0x04000000,     \/\/ True if klass is hidden\n-  JVM_ACC_IS_VALUE_BASED_CLASS    = 0x08000000,     \/\/ True if klass is marked as a ValueBased class\n@@ -80,6 +73,0 @@\n-  \/\/ Klass* flags\n-  bool has_finalizer           () const { return (_flags & JVM_ACC_HAS_FINALIZER          ) != 0; }\n-  bool is_cloneable_fast       () const { return (_flags & JVM_ACC_IS_CLONEABLE_FAST      ) != 0; }\n-  bool is_hidden_class         () const { return (_flags & JVM_ACC_IS_HIDDEN_CLASS        ) != 0; }\n-  bool is_value_based_class    () const { return (_flags & JVM_ACC_IS_VALUE_BASED_CLASS   ) != 0; }\n-\n@@ -105,7 +92,0 @@\n-  \/\/ Klass* flags\n-  \/\/ These are set at classfile parsing time so do not require atomic access.\n-  void set_has_finalizer()             { _flags |= JVM_ACC_HAS_FINALIZER; }\n-  void set_is_cloneable_fast()         { _flags |= JVM_ACC_IS_CLONEABLE_FAST; }\n-  void set_is_hidden_class()           { _flags |= JVM_ACC_IS_HIDDEN_CLASS; }\n-  void set_is_value_based_class()      { _flags |= JVM_ACC_IS_VALUE_BASED_CLASS; }\n-\n","filename":"src\/hotspot\/share\/utilities\/accessFlags.hpp","additions":1,"deletions":21,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+#include \"utilities\/checkedCast.hpp\"\n@@ -66,1 +67,1 @@\n-    return (((x & UINT16_C(0x00ff)) << 8) | ((x & UINT16_C(0xff00)) >> 8));\n+    return checked_cast<uint16_t>(((x & UINT16_C(0x00ff)) << 8) | ((x & UINT16_C(0xff00)) >> 8));\n","filename":"src\/hotspot\/share\/utilities\/byteswap.hpp","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -85,0 +85,4 @@\n+#ifndef PRAGMA_ZERO_AS_NULL_POINTER_CONSTANT_IGNORED\n+#define PRAGMA_ZERO_AS_NULL_POINTER_CONSTANT_IGNORED\n+#endif\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,0 +70,3 @@\n+#define PRAGMA_ZERO_AS_NULL_POINTER_CONSTANT_IGNORED \\\n+  PRAGMA_DISABLE_GCC_WARNING(\"-Wzero-as-null-pointer-constant\")\n+\n","filename":"src\/hotspot\/share\/utilities\/compilerWarnings_gcc.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    DEBUG_ONLY(size_t _saved_hash);\n@@ -80,0 +81,4 @@\n+#ifdef ASSERT\n+    size_t saved_hash() const         { return _saved_hash; }\n+    void set_saved_hash(size_t hash)  { _saved_hash = hash; }\n+#endif\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.hpp","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -682,1 +682,3 @@\n-        fatal(\"aux_index does not match even or odd indices\");\n+        const char* msg = \"Cannot resize table: Node hash code has changed possibly due to corruption of the contents.\";\n+        DEBUG_ONLY(fatal(\"%s Node hash code changed from \" SIZE_FORMAT \" to \" SIZE_FORMAT, msg, aux->saved_hash(), aux_hash);)\n+        NOT_DEBUG(fatal(\"%s\", msg);)\n@@ -895,0 +897,1 @@\n+  DEBUG_ONLY(new_node->set_saved_hash(hash);)\n@@ -1120,0 +1123,1 @@\n+  DEBUG_ONLY(new_node->set_saved_hash(hash);)\n","filename":"src\/hotspot\/share\/utilities\/concurrentHashTable.inline.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -786,0 +786,4 @@\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_ENTRY(arg0, arg1)\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_ENTRY_ENABLED()  0\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_RETURN(arg0)\n+#define HOTSPOT_JNI_GETSTRINGUTFLENGTHASLONG_RETURN_ENABLED()  0\n","filename":"src\/hotspot\/share\/utilities\/dtrace_disabled.hpp","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -154,1 +154,3 @@\n-void ExceptionsEventLog::log(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+void ExceptionsEventLog::log(Thread* thread, Handle h_exception,\n+                             const char* message, const char* file, int line,\n+                             int message_length_limit) {\n@@ -166,1 +168,5 @@\n-  st.print(\"%s%s> (\" PTR_FORMAT \") \\n\"\n+  if (message != nullptr) {\n+    int len = message_length_limit > 0 ? message_length_limit : (int)strlen(message);\n+    st.print(\": %.*s\", len, message);\n+  }\n+  st.print(\"> (\" PTR_FORMAT \") \\n\"\n@@ -168,1 +174,0 @@\n-           message ? \": \" : \"\", message ? message : \"\",\n","filename":"src\/hotspot\/share\/utilities\/events.cpp","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -210,1 +210,3 @@\n-  void log(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  \/\/ Message length limit of zero means no limit.\n+  void log(Thread* thread, Handle h_exception, const char* message,\n+           const char* file, int line, int message_length_limit = 0);\n@@ -278,1 +280,1 @@\n-  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line);\n+  static void log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line, int message_length_limit = 0);\n@@ -348,1 +350,3 @@\n-inline void Events::log_exception(Thread* thread, Handle h_exception, const char* message, const char* file, int line) {\n+inline void Events::log_exception(Thread* thread, Handle h_exception,\n+                                  const char* message, const char* file,\n+                                  int line, int message_length_limit) {\n@@ -350,1 +354,1 @@\n-    _exceptions->log(thread, h_exception, message, file, line);\n+    _exceptions->log(thread, h_exception, message, file, line, message_length_limit);\n","filename":"src\/hotspot\/share\/utilities\/events.hpp","additions":8,"deletions":4,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -186,1 +186,1 @@\n-  Events::log_exception(thread, h_exception, message, file, line);\n+  Events::log_exception(thread, h_exception, message, file, line, MAX_LEN);\n","filename":"src\/hotspot\/share\/utilities\/exceptions.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -314,0 +314,3 @@\n+#define THROW_HANDLE_NULL(e)                THROW_HANDLE_(e, nullptr)\n+#define THROW_ARG_NULL(name, signature, arg) THROW_ARG_(name, signature, arg, nullptr)\n+\n","filename":"src\/hotspot\/share\/utilities\/exceptions.hpp","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -624,1 +624,1 @@\n-#if INCLUDE_CDS && INCLUDE_G1GC && defined(_LP64) && !defined(_WINDOWS)\n+#if INCLUDE_CDS && INCLUDE_G1GC && defined(_LP64)\n","filename":"src\/hotspot\/share\/utilities\/macros.hpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -101,1 +101,7 @@\n-\/\/ Count bytes of the form 10xxxxxx and deduct this count\n+\/\/ The number of unicode characters in a utf8 sequence can be easily\n+\/\/ determined by noting that bytes of the form 10xxxxxx are part of\n+\/\/ a 2 or 3-byte multi-byte sequence, all others are either characters\n+\/\/ themselves or else the start of a multi-byte character.\n+\n+\/\/ Calculate the unicode length of a utf8 string of known size\n+\/\/ by counting bytes of the form 10xxxxxx and deducting this count\n@@ -104,2 +110,2 @@\n-int UTF8::unicode_length(const char* str, int len, bool& is_latin1, bool& has_multibyte) {\n-  int num_chars = len;\n+int UTF8::unicode_length(const char* str, size_t len, bool& is_latin1, bool& has_multibyte) {\n+  size_t num_chars = len;\n@@ -109,1 +115,1 @@\n-  for (int i = 0; i < len; i++) {\n+  for (size_t i = 0; i < len; i++) {\n@@ -121,1 +127,1 @@\n-  return num_chars;\n+  return checked_cast<int>(num_chars);\n@@ -124,3 +130,3 @@\n-\/\/ Count bytes of the utf8 string except those in form\n-\/\/ 10xxxxxx which only appear in multibyte characters.\n-\/\/ The utf8 string must be in legal form and has been\n+\/\/ Calculate the unicode length of a nul-terminated utf8 string\n+\/\/ by counting bytes of the utf8 string except those in the form\n+\/\/ 10xxxxxx. The utf8 string must be in legal form and has been\n@@ -198,1 +204,1 @@\n-int UTF8::quoted_ascii_length(const char* utf8_str, int utf8_length) {\n+size_t UTF8::quoted_ascii_length(const char* utf8_str, size_t utf8_length) {\n@@ -201,1 +207,1 @@\n-  int result = 0;\n+  size_t result = 0;\n@@ -215,1 +221,1 @@\n-void UTF8::as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen) {\n+void UTF8::as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen) {\n@@ -251,1 +257,1 @@\n-  int length = ptr - quoted_ascii_str;\n+  size_t length = ptr - quoted_ascii_str;\n@@ -333,1 +339,1 @@\n-bool UTF8::is_legal_utf8(const unsigned char* buffer, int length,\n+bool UTF8::is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -335,3 +341,3 @@\n-  int i = 0;\n-  int count = length >> 2;\n-  for (int k=0; k<count; k++) {\n+  size_t i = 0;\n+  size_t count = length >> 2;\n+  for (size_t k = 0; k < count; k++) {\n@@ -408,1 +414,1 @@\n-void UTF8::truncate_to_legal_utf8(unsigned char* buffer, int length) {\n+void UTF8::truncate_to_legal_utf8(unsigned char* buffer, size_t length) {\n@@ -436,1 +442,1 @@\n-  for (int index = length - 2; index > 0; index--) {\n+  for (size_t index = length - 2; index > 0; index--) {\n@@ -444,1 +450,1 @@\n-        if ((index - 3) >= 0 &&\n+        if (index >= 3 &&\n@@ -473,1 +479,1 @@\n-int UNICODE::utf8_size(jchar c) {\n+size_t UNICODE::utf8_size(jchar c) {\n@@ -484,1 +490,1 @@\n-int UNICODE::utf8_size(jbyte c) {\n+size_t UNICODE::utf8_size(jbyte c) {\n@@ -497,1 +503,10 @@\n-int UNICODE::utf8_length(const T* base, int length) {\n+size_t UNICODE::utf8_length(const T* base, int length) {\n+  size_t result = 0;\n+  for (int index = 0; index < length; index++) {\n+    result += utf8_size(base[index]);\n+  }\n+  return result;\n+}\n+\n+template<typename T>\n+int UNICODE::utf8_length_as_int(const T* base, int length) {\n@@ -501,1 +516,4 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    \/\/ If the length is > INT_MAX-1 we truncate at a completed\n+    \/\/ modified-UTF8 encoding. This allows for +1 to be added\n+    \/\/ by the caller for NUL-termination, without overflow.\n@@ -511,2 +529,3 @@\n-char* UNICODE::as_utf8(const T* base, int& length) {\n-  int utf8_len = utf8_length(base, length);\n+char* UNICODE::as_utf8(const T* base, size_t& length) {\n+  \/\/ Incoming length must be <= INT_MAX\n+  size_t utf8_len = utf8_length(base, static_cast<int>(length));\n@@ -514,3 +533,3 @@\n-  char* result = as_utf8(base, length, (char*) buf, utf8_len + 1);\n-  assert((int) strlen(result) == utf8_len, \"length prediction must be correct\");\n-  \/\/ Set string length to uft8 length\n+  char* result = as_utf8(base, static_cast<int>(length), (char*) buf, utf8_len + 1);\n+  assert(strlen(result) == utf8_len, \"length prediction must be correct\");\n+  \/\/ Set outgoing string length to uft8 length\n@@ -521,1 +540,1 @@\n-char* UNICODE::as_utf8(const jchar* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jchar* base, int length, char* buf, size_t buflen) {\n@@ -526,2 +545,3 @@\n-    buflen -= utf8_size(c);\n-    if (buflen <= 0) break; \/\/ string is truncated\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n+    buflen -= sz;\n@@ -534,1 +554,1 @@\n-char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, int buflen) {\n+char* UNICODE::as_utf8(const jbyte* base, int length, char* buf, size_t buflen) {\n@@ -539,1 +559,2 @@\n-    int sz = utf8_size(c);\n+    size_t sz = utf8_size(c);\n+    if (sz >= buflen) break; \/\/ string is truncated\n@@ -541,1 +562,0 @@\n-    if (buflen <= 0) break; \/\/ string is truncated\n@@ -546,0 +566,1 @@\n+      assert(sz == 2, \"must be!\");\n@@ -564,2 +585,2 @@\n-int UNICODE::quoted_ascii_length(const T* base, int length) {\n-  int result = 0;\n+size_t UNICODE::quoted_ascii_length(const T* base, int length) {\n+  size_t result = 0;\n@@ -579,1 +600,1 @@\n-void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, int buflen) {\n+void UNICODE::as_quoted_ascii(const T* base, int length, char* buf, size_t buflen) {\n@@ -597,8 +618,10 @@\n-template int UNICODE::utf8_length(const jbyte* base, int length);\n-template int UNICODE::utf8_length(const jchar* base, int length);\n-template char* UNICODE::as_utf8(const jbyte* base, int& length);\n-template char* UNICODE::as_utf8(const jchar* base, int& length);\n-template int UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n-template int UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n-template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, int buflen);\n-template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, int buflen);\n+template size_t UNICODE::utf8_length(const jbyte* base, int length);\n+template size_t UNICODE::utf8_length(const jchar* base, int length);\n+template int UNICODE::utf8_length_as_int(const jbyte* base, int length);\n+template int UNICODE::utf8_length_as_int(const jchar* base, int length);\n+template char* UNICODE::as_utf8(const jbyte* base, size_t& length);\n+template char* UNICODE::as_utf8(const jchar* base, size_t& length);\n+template size_t UNICODE::quoted_ascii_length<jbyte>(const jbyte* base, int length);\n+template size_t UNICODE::quoted_ascii_length<jchar>(const jchar* base, int length);\n+template void UNICODE::as_quoted_ascii<jbyte>(const jbyte* base, int length, char* buf, size_t buflen);\n+template void UNICODE::as_quoted_ascii<jchar>(const jchar* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.cpp","additions":68,"deletions":45,"binary":false,"changes":113,"status":"modified"},{"patch":"@@ -32,0 +32,39 @@\n+\/**\n+\n+String handling within Java and the VM requires a bit of explanation.\n+\n+Logically a java.lang.String is a sequence of 16-bit Unicode characters\n+encoded in UTF-16. In the past a String contained a Java char[] and so\n+could theoretically contain INT_MAX 16-bit characters. Then came JEP 254:\n+Compact Strings.\n+\n+With Compact Strings the Java char[] becomes a Java byte[], and that byte[]\n+contains either latin-1 characters all of which fit in 8-bits, or else each\n+pair of bytes represents a UTF-16 character. Consequently the maximum length\n+in characters of a latin-1 string is INT_MAX, whilst for non-latin-1 it is INT_MAX\/2.\n+\n+In the code below if we have latin-1 content then we treat the String's data\n+array as a jbyte[], else a jchar[]. The lengths of these arrays are specified\n+as an int value, with a nominal maximum of INT_MAX.\n+\n+The modified UTF-8 encoding specified for the VM, nominally encodes characters\n+in 1, 2, 3 or 6 bytes. The 6-byte representation is actually two 3-byte representations\n+for two UTF-16 characters forming a surrogate pair. If we are dealing with\n+a latin-1 string then each character will be encoded as either 1 or 2 bytes and so the\n+maximum UTF8 length is 2*INT_MAX. This can't be stored in an int so utf8 buffers must\n+use a size_t length. For non-latin-1 strings each UTF-16 character will encode as either\n+2 or 3 bytes, so the maximum UTF8 length in that case is 3 * INT_MAX\/2 i.e. 1.5*INT_MAX.\n+\n+The \"quoted ascii\" form of a unicode string is at worst 6 times longer than its\n+regular form, and so these lengths must always be size_t - though if we know we only\n+ever do this to symbols (or small symbol combinations) then we could use int.\n+\n+There is an additional assumption\/expectation that our UTF8 API's are never dealing with\n+invalid UTF8, and more generally that all UTF8 sequences could form valid Strings.\n+Consequently the Unicode length of a UTF8 sequence is assumed to always be representable\n+by an int. However, there are API's, such as JNI NewStringUTF, that do deal with such input\n+and could potentially have an unrepresentable string. The long standing position with JNI\n+is that the user must supply valid input so we do not try to account for these cases.\n+\n+*\/\n+\n@@ -44,1 +83,1 @@\n-  static int unicode_length(const char* utf8_str, int len) {\n+  static int unicode_length(const char* utf8_str, size_t len) {\n@@ -48,1 +87,1 @@\n-  static int unicode_length(const char* utf8_str, int len, bool& is_latin1, bool& has_multibyte);\n+  static int unicode_length(const char* utf8_str, size_t len, bool& is_latin1, bool& has_multibyte);\n@@ -54,1 +93,1 @@\n-  static int quoted_ascii_length(const char* utf8_str, int utf8_length);\n+  static size_t quoted_ascii_length(const char* utf8_str, size_t utf8_length);\n@@ -57,1 +96,1 @@\n-  static void as_quoted_ascii(const char* utf8_str, int utf8_length, char* buf, int buflen);\n+  static void as_quoted_ascii(const char* utf8_str, size_t utf8_length, char* buf, size_t buflen);\n@@ -85,1 +124,1 @@\n-  static bool   equal(const jbyte* base1, int length1, const jbyte* base2,int length2);\n+  static bool   equal(const jbyte* base1, int length1, const jbyte* base2, int length2);\n@@ -89,1 +128,1 @@\n-  static bool   is_legal_utf8(const unsigned char* buffer, int length,\n+  static bool   is_legal_utf8(const unsigned char* buffer, size_t length,\n@@ -91,1 +130,1 @@\n-  static void   truncate_to_legal_utf8(unsigned char* buffer, int length);\n+  static void   truncate_to_legal_utf8(unsigned char* buffer, size_t length);\n@@ -102,0 +141,6 @@\n+\n+  \/\/ returns the utf8 size of a unicode character\n+  \/\/ uses size_t for convenience in overflow checks\n+  static size_t utf8_size(jchar c);\n+  static size_t utf8_size(jbyte c);\n+\n@@ -109,4 +154,0 @@\n-  \/\/ returns the utf8 size of a unicode character\n-  static int utf8_size(jchar c);\n-  static int utf8_size(jbyte c);\n-\n@@ -114,1 +155,4 @@\n-  template<typename T> static int utf8_length(const T* base, int length);\n+  template<typename T> static size_t utf8_length(const T* base, int length);\n+\n+  \/\/ returns the utf8 length of a unicode string as an int - truncated if needed\n+  template<typename T> static int utf8_length_as_int(const T* base, int length);\n@@ -121,4 +165,4 @@\n-  \/\/ parameter is set to the length of the result utf8 string.\n-  template<typename T> static char* as_utf8(const T* base, int& length);\n-  static char* as_utf8(const jchar* base, int length, char* buf, int buflen);\n-  static char* as_utf8(const jbyte* base, int length, char* buf, int buflen);\n+  \/\/ parameter is set to the length of the resulting utf8 string.\n+  template<typename T> static char* as_utf8(const T* base, size_t& length);\n+  static char* as_utf8(const jchar* base, int length, char* buf, size_t buflen);\n+  static char* as_utf8(const jbyte* base, int length, char* buf, size_t buflen);\n@@ -127,1 +171,1 @@\n-  template<typename T> static int quoted_ascii_length(const T* base, int length);\n+  template<typename T> static size_t quoted_ascii_length(const T* base, int length);\n@@ -130,1 +174,1 @@\n-  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, int buflen);\n+  template<typename T> static void as_quoted_ascii(const T* base, int length, char* buf, size_t buflen);\n","filename":"src\/hotspot\/share\/utilities\/utf8.hpp","additions":62,"deletions":18,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -431,3 +431,3 @@\n-#ifdef STATIC_BUILD\n-    return JNI_TRUE;\n-#else\n+    if (JLI_IsStaticallyLinked()) {\n+        return JNI_TRUE;\n+    }\n@@ -441,1 +441,0 @@\n-#endif\n@@ -454,10 +453,11 @@\n-#ifdef STATIC_BUILD\n-        char jvm_cfg[MAXPATHLEN];\n-        JLI_Snprintf(jvm_cfg, sizeof(jvm_cfg), \"%s\/lib\/jvm.cfg\", path);\n-        if (access(jvm_cfg, F_OK) == 0) {\n-            return JNI_TRUE;\n-        }\n-#else\n-        JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n-        if (access(libjava, F_OK) == 0) {\n-            return JNI_TRUE;\n+        if (JLI_IsStaticallyLinked()) {\n+            char jvm_cfg[MAXPATHLEN];\n+            JLI_Snprintf(jvm_cfg, sizeof(jvm_cfg), \"%s\/lib\/jvm.cfg\", path);\n+            if (access(jvm_cfg, F_OK) == 0) {\n+                return JNI_TRUE;\n+            }\n+        } else {\n+            JLI_Snprintf(libjava, sizeof(libjava), \"%s\/lib\/\" JAVA_DLL, path);\n+            if (access(libjava, F_OK) == 0) {\n+                return JNI_TRUE;\n+            }\n@@ -465,1 +465,0 @@\n-#endif\n@@ -484,15 +483,17 @@\n-#ifdef STATIC_BUILD\n-    char jvm_cfg[MAXPATHLEN];\n-    char *p = NULL;\n-    strncpy(jvm_cfg, selfInfo.dli_fname, MAXPATHLEN);\n-    p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n-    p = strrchr(jvm_cfg, '\/');\n-    if (strcmp(p, \"\/.\") == 0) {\n-      *p = '\\0';\n-      p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n-    }\n-    else *p = '\\0';\n-    strncpy(path, jvm_cfg, pathsize);\n-    strncat(jvm_cfg, \"\/lib\/jvm.cfg\", MAXPATHLEN);\n-    if (access(jvm_cfg, F_OK) == 0) {\n-      return JNI_TRUE;\n+    if (JLI_IsStaticallyLinked()) {\n+        char jvm_cfg[MAXPATHLEN];\n+        char *p = NULL;\n+        strncpy(jvm_cfg, selfInfo.dli_fname, MAXPATHLEN);\n+        p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n+        p = strrchr(jvm_cfg, '\/');\n+        if (strcmp(p, \"\/.\") == 0) {\n+            *p = '\\0';\n+            p = strrchr(jvm_cfg, '\/'); *p = '\\0';\n+        } else {\n+          *p = '\\0';\n+        }\n+        strncpy(path, jvm_cfg, pathsize);\n+        strncat(jvm_cfg, \"\/lib\/jvm.cfg\", MAXPATHLEN);\n+        if (access(jvm_cfg, F_OK) == 0) {\n+           return JNI_TRUE;\n+        }\n@@ -500,1 +501,0 @@\n-#endif\n@@ -552,5 +552,6 @@\n-#ifndef STATIC_BUILD\n-    libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n-#else\n-    libjvm = dlopen(NULL, RTLD_FIRST);\n-#endif\n+    if (!JLI_IsStaticallyLinked()) {\n+        libjvm = dlopen(jvmpath, RTLD_NOW + RTLD_GLOBAL);\n+    } else {\n+        libjvm = dlopen(NULL, RTLD_FIRST);\n+    }\n+\n@@ -606,2 +607,0 @@\n-\n-#ifdef STATIC_BUILD\n@@ -609,5 +608,6 @@\n-        fptr = (void *)&SetExecname;\n-#else\n-        int (*fptr)();\n-        fptr = (int (*)())dlsym(RTLD_DEFAULT, \"main\");\n-#endif\n+\n+        if (JLI_IsStaticallyLinked()) {\n+            fptr = (void *)&SetExecname;\n+        } else {\n+            fptr = dlsym(RTLD_DEFAULT, \"main\");\n+        }\n","filename":"src\/java.base\/macosx\/native\/libjli\/java_md_macosx.m","additions":44,"deletions":44,"binary":false,"changes":88,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1994, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1994, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2120,0 +2120,5 @@\n+     * <p> If a file with the generated name cannot be created by the\n+     * underlying platform, then an {@code IOException} will be thrown.\n+     * This could occur for example if the supplied prefix or suffix contains\n+     * one or more characters not supported by the underlying file system.\n+     *\n","filename":"src\/java.base\/share\/classes\/java\/io\/File.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1275,1 +1275,1 @@\n-        if (cl != null && isCustomSubclass()) {\n+        if (isCustomSubclass()) {\n","filename":"src\/java.base\/share\/classes\/java\/io\/ObjectOutputStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2445,1 +2445,1 @@\n-    \/*\n+    \/**\n@@ -2447,0 +2447,17 @@\n+     * @param loader the class loader used to look up the native library symbol\n+     * @param clazz the class in which the native method is declared\n+     * @param entryName the native method's mangled name (this is the name used for the native lookup)\n+     * @param javaName the native method's declared name\n+     *\/\n+    static long findNative(ClassLoader loader, Class<?> clazz, String entryName, String javaName) {\n+        long addr = findNativeInternal(loader, entryName);\n+        if (addr != 0 && loader != null) {\n+            Reflection.ensureNativeAccess(clazz, clazz, javaName, true);\n+        }\n+        return addr;\n+    }\n+\n+    \/*\n+     * This is also called by SymbolLookup::loaderLookup. In that case, we need\n+     * to avoid a restricted check, as that check has already been performed when\n+     * obtaining the lookup.\n@@ -2448,1 +2465,1 @@\n-    static long findNative(ClassLoader loader, String entryName) {\n+    static long findNativeInternal(ClassLoader loader, String entryName) {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ClassLoader.java","additions":19,"deletions":2,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+import jdk.internal.misc.VM;\n@@ -66,0 +67,1 @@\n+import jdk.internal.module.ModuleBootstrap.IllegalNativeAccess;\n@@ -303,1 +305,1 @@\n-    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass) {\n+    void ensureNativeAccess(Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n@@ -306,3 +308,10 @@\n-        if (!EnableNativeAccess.isNativeAccessEnabled(target)) {\n-            if (ModuleBootstrap.hasEnableNativeAccessFlag()) {\n-                throw new IllegalCallerException(\"Illegal native access from: \" + this);\n+        ModuleBootstrap.IllegalNativeAccess illegalNativeAccess = ModuleBootstrap.illegalNativeAccess();\n+        if (illegalNativeAccess != ModuleBootstrap.IllegalNativeAccess.ALLOW &&\n+                !EnableNativeAccess.isNativeAccessEnabled(target)) {\n+            String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n+            if (currentClass != null) {\n+                \/\/ try to extract location of the current class (e.g. jar or folder)\n+                URL url = System.codeSource(currentClass);\n+                if (url != null) {\n+                    mod += \" (\" + url + \")\";\n+                }\n@@ -310,1 +319,3 @@\n-            if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n+            if (illegalNativeAccess == ModuleBootstrap.IllegalNativeAccess.DENY) {\n+                throw new IllegalCallerException(\"Illegal native access from \" + mod);\n+            } else if (EnableNativeAccess.trySetEnableNativeAccess(target)) {\n@@ -314,1 +325,0 @@\n-                String mod = isNamed() ? \"module \" + getName() : \"an unnamed module\";\n@@ -317,6 +327,15 @@\n-                System.err.printf(\"\"\"\n-                        WARNING: A restricted method in %s has been called\n-                        WARNING: %s has been called by %s in %s\n-                        WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n-                        WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n-                        %n\"\"\", cls, mtd, caller, mod, modflag);\n+                if (jni) {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A native method in %s has been bound\n+                            WARNING: %s is declared in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for native methods declared in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, mod, modflag);\n+                } else {\n+                    VM.initialErr().printf(\"\"\"\n+                            WARNING: A restricted method in %s has been called\n+                            WARNING: %s has been called by %s in %s\n+                            WARNING: Use --enable-native-access=%s to avoid a warning for callers in this module\n+                            WARNING: Restricted methods will be blocked in a future release unless native access is enabled\n+                            %n\"\"\", cls, mtd, caller, mod, modflag);\n+                }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Module.java","additions":31,"deletions":12,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -326,1 +326,1 @@\n-                \"enableNativeAccess\");\n+                \"enableNativeAccess\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/ModuleLayer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,0 +39,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -831,0 +832,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -837,0 +840,1 @@\n+    @Restricted\n@@ -838,1 +842,3 @@\n-        load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"load\", false);\n+        load0(caller, filename);\n@@ -897,0 +903,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -902,0 +910,1 @@\n+    @Restricted\n@@ -903,1 +912,3 @@\n-        loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, Runtime.class, \"loadLibrary\", false);\n+        loadLibrary0(caller, libname);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/Runtime.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -31,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -42,0 +44,92 @@\n+    static abstract class StringConcatBase {\n+        @Stable\n+        final String[] constants;\n+        final int      length;\n+        final byte     coder;\n+\n+        StringConcatBase(String[] constants) {\n+            int  length = 0;\n+            byte coder  = String.LATIN1;\n+            for (String c : constants) {\n+                length += c.length();\n+                coder  |= c.coder();\n+            }\n+            this.constants = constants;\n+            this.length    = length;\n+            this.coder     = coder;\n+        }\n+    }\n+\n+    static final class Concat1 extends StringConcatBase {\n+        Concat1(String[] constants) {\n+            super(constants);\n+        }\n+\n+        @ForceInline\n+        String concat0(String value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | value.coder());\n+            byte[] buf = newArray(length << coder);\n+            String prefix = constants[0];\n+            prefix.getBytes(buf, 0, coder);\n+            value.getBytes(buf, prefix.length(), coder);\n+            constants[1].getBytes(buf, prefix.length() + value.length(), coder);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(boolean value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(char value) {\n+            int length = stringSize(this.length, value);\n+            byte coder = (byte) (this.coder | stringCoder(value));\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(int value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(long value) {\n+            int length = stringSize(this.length, value);\n+            String suffix = constants[1];\n+            length -= suffix.length();\n+            byte[] buf = newArrayWithSuffix(suffix, length, coder);\n+            prepend(length, coder, buf, value, constants[0]);\n+            return new String(buf, coder);\n+        }\n+\n+        @ForceInline\n+        String concat(Object value) {\n+            return concat0(stringOf(value));\n+        }\n+\n+        @ForceInline\n+        String concat(float value) {\n+            return concat0(Float.toString(value));\n+        }\n+\n+        @ForceInline\n+        String concat(double value) {\n+            return concat0(Double.toString(value));\n+        }\n+    }\n@@ -378,0 +472,58 @@\n+    static String stringOf(float value) {\n+        return Float.toString(value);\n+    }\n+\n+    static String stringOf(double value) {\n+        return Double.toString(value);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, char value) {\n+        return checkOverflow(length + 1);\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, boolean value) {\n+        return checkOverflow(length + (value ? 4 : 5));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, int value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, long value) {\n+        return checkOverflow(length + DecimalDigits.stringSize(value));\n+    }\n+\n+    \/**\n+     * return add stringSize of value\n+     * @param length      length\n+     * @param value       value to add stringSize\n+     * @return            new length\n+     *\/\n+    static int stringSize(int length, String value) {\n+        return checkOverflow(length + value.length());\n+    }\n+\n@@ -443,0 +595,191 @@\n+    \/**\n+     * Allocates an uninitialized byte array based on the length and coder\n+     * information, then prepends the given suffix string at the end of the\n+     * byte array before returning it. The calling code must adjust the\n+     * indexCoder so that it's taken the coder of the suffix into account, but\n+     * subtracted the length of the suffix.\n+     *\n+     * @param suffix\n+     * @param indexCoder\n+     * @return the newly allocated byte array\n+     *\/\n+    @ForceInline\n+    static byte[] newArrayWithSuffix(String suffix, int index, byte coder) {\n+        byte[] buf = newArray((index + suffix.length()) << coder);\n+        if (coder == String.LATIN1) {\n+            suffix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            suffix.getBytes(buf, index, String.UTF16);\n+        }\n+        return buf;\n+    }\n+\n+    \/**\n+     * Return the coder for the character.\n+     * @param value character\n+     * @return      coder\n+     *\/\n+    static byte stringCoder(char value) {\n+        return StringLatin1.canEncode(value) ? String.LATIN1 : String.UTF16;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, boolean value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            if (value) {\n+                index -= 4;\n+                buf[index] = 't';\n+                buf[index + 1] = 'r';\n+                buf[index + 2] = 'u';\n+                buf[index + 3] = 'e';\n+            } else {\n+                index -= 5;\n+                buf[index] = 'f';\n+                buf[index + 1] = 'a';\n+                buf[index + 2] = 'l';\n+                buf[index + 3] = 's';\n+                buf[index + 4] = 'e';\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            if (value) {\n+                index -= 4;\n+                StringUTF16.putChar(buf, index, 't');\n+                StringUTF16.putChar(buf, index + 1, 'r');\n+                StringUTF16.putChar(buf, index + 2, 'u');\n+                StringUTF16.putChar(buf, index + 3, 'e');\n+            } else {\n+                index -= 5;\n+                StringUTF16.putChar(buf, index, 'f');\n+                StringUTF16.putChar(buf, index + 1, 'a');\n+                StringUTF16.putChar(buf, index + 2, 'l');\n+                StringUTF16.putChar(buf, index + 3, 's');\n+                StringUTF16.putChar(buf, index + 4, 'e');\n+            }\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      char value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, char value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            buf[--index] = (byte) (value & 0xFF);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            StringUTF16.putChar(buf, --index, value);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      int value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, int value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      long value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, long value, String prefix) {\n+        if (coder == String.LATIN1) {\n+            index = StringLatin1.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            index = StringUTF16.getChars(value, index, buf);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Prepends constant and the stringly representation of value into buffer,\n+     * given the coder and final index. Index is measured in chars, not in bytes!\n+     *\n+     * @param index     final char index in the buffer\n+     * @param coder     coder of the buffer\n+     * @param buf        buffer to append to\n+     * @param value      boolean value to encode\n+     * @param prefix     a constant to prepend before value\n+     * @return           updated index\n+     *\/\n+    static int prepend(int index, byte coder, byte[] buf, String value, String prefix) {\n+        index -= value.length();\n+        if (coder == String.LATIN1) {\n+            value.getBytes(buf, index, String.LATIN1);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.LATIN1);\n+        } else {\n+            value.getBytes(buf, index, String.UTF16);\n+            index -= prefix.length();\n+            prefix.getBytes(buf, index, String.UTF16);\n+        }\n+        return index;\n+    }\n+\n+    \/**\n+     * Check for overflow, throw exception on overflow.\n+     *\n+     * @param value\n+     * @return the given parameter value, if valid\n+     *\/\n+    @ForceInline\n+    static int checkOverflow(int value) {\n+        if (value >= 0) {\n+            return value;\n+        }\n+        throw new OutOfMemoryError(\"Overflow: String length out of range\");\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/StringConcatHelper.java","additions":343,"deletions":0,"binary":false,"changes":343,"status":"modified"},{"patch":"@@ -72,0 +72,1 @@\n+import jdk.internal.javac.Restricted;\n@@ -358,1 +359,1 @@\n-    private static URL codeSource(Class<?> clazz) {\n+    static URL codeSource(Class<?> clazz) {\n@@ -2020,0 +2021,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2026,0 +2029,1 @@\n+    @Restricted\n@@ -2027,1 +2031,3 @@\n-        Runtime.getRuntime().load0(Reflection.getCallerClass(), filename);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"load\", false);\n+        Runtime.getRuntime().load0(caller, filename);\n@@ -2058,0 +2064,2 @@\n+     * @throws     IllegalCallerException if the caller is in a module that\n+     *             does not have native access enabled.\n@@ -2064,0 +2072,1 @@\n+    @Restricted\n@@ -2065,1 +2074,3 @@\n-        Runtime.getRuntime().loadLibrary0(Reflection.getCallerClass(), libname);\n+        Class<?> caller = Reflection.getCallerClass();\n+        Reflection.ensureNativeAccess(caller, System.class, \"loadLibrary\", false);\n+        Runtime.getRuntime().loadLibrary0(caller, libname);\n@@ -2542,2 +2553,2 @@\n-            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass) {\n-                m.ensureNativeAccess(owner, methodName, currentClass);\n+            public void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni) {\n+                m.ensureNativeAccess(owner, methodName, currentClass, jni);\n@@ -2626,0 +2637,4 @@\n+            public Object stringConcat1(String[] constants) {\n+                return new StringConcatHelper.Concat1(constants);\n+            }\n+\n@@ -2644,1 +2659,1 @@\n-                return ClassLoader.findNative(loader, entry);\n+                return ClassLoader.findNativeInternal(loader, entry);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/System.java","additions":21,"deletions":6,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -40,1 +40,16 @@\n- * Models an annotation on a declaration.\n+ * Models an {@code annotation} structure (JVMS {@jvms 4.7.16}) or part of a {@code\n+ * type_annotation} structure (JVMS {@jvms 4.7.20}). This model indicates the\n+ * interface of the annotation and a set of element-value pairs.\n+ * <p>\n+ * This model can reconstruct an annotation, given the location of the modeled structure\n+ * in the class file and the definition of the annotation interface.\n+ * <p>\n+ * Two {@code Annotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n+ *\n+ * @apiNote\n+ * For Java programs, the location of the modeled structure indicates the source code\n+ * element or type (JLS {@jls 9.7.4}) on which the reconstructed annotation appears,\n+ * and the annotation interface definition determines whether the reconstructed annotation has\n+ * elements with default values (JLS {@jls 9.6.2}), and whether the reconstructed annotation\n+ * is a container annotation for multiple annotations (JLS {@jls 9.7.5}).\n@@ -44,0 +59,1 @@\n+ * @see TypeAnnotation\n@@ -49,1 +65,0 @@\n- * @sealedGraph\n@@ -54,1 +69,1 @@\n-        permits TypeAnnotation, AnnotationImpl {\n+        permits AnnotationImpl {\n@@ -57,1 +72,2 @@\n-     * {@return the class of the annotation}\n+     * {@return the constant pool entry holding the {@linkplain Class#descriptorString\n+     * descriptor string} of the annotation interface}\n@@ -62,1 +78,1 @@\n-     * {@return the class of the annotation, as a symbolic descriptor}\n+     * {@return the annotation interface, as a symbolic descriptor}\n@@ -69,1 +85,1 @@\n-     * {@return the elements of the annotation}\n+     * {@return the element-value pairs of the annotation}\n@@ -75,2 +91,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -85,2 +102,3 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the constant pool entry holding the descriptor string\n+     *                        of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -95,2 +113,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n@@ -105,2 +123,2 @@\n-     * @param annotationClass the class of the annotation\n-     * @param elements the elements of the annotation\n+     * @param annotationClass the descriptor of the annotation interface\n+     * @param elements the element-value pairs of the annotation\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Annotation.java","additions":32,"deletions":14,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -35,1 +35,7 @@\n- * Models a key-value pair of an annotation.\n+ * Models an element-value pair in the {@code element_value_pairs}\n+ * table in the {@code annotation} structure defined in JVMS\n+ * {@jvms 4.7.16} or the {@code type_annotation} structure defined\n+ * in JVMS {@jvms 4.7.20}.\n+ * <p>\n+ * Two {@code AnnotationElement} objects should be compared using the\n+ * {@link Object#equals(Object) equals} method.\n@@ -48,0 +54,6 @@\n+     *\n+     * @apiNote\n+     * In Java source code, by convention, the name of the sole element in a\n+     * single-element annotation interface is {@code value}. (JLS {@jls 9.6.1})\n+     * This is the case for single-element annotations (JLS {@jls 9.7.3}) and\n+     * container annotations for multiple annotations (JLS {@jls 9.6.3}).\n@@ -57,1 +69,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -67,1 +79,1 @@\n-     * {@return an annotation key-value pair}\n+     * {@return an element-value pair}\n@@ -77,1 +89,1 @@\n-     * {@return an annotation key-value pair for a class-valued annotation}\n+     * {@return an element-value pair for a class-valued element}\n@@ -80,0 +92,1 @@\n+     * @see AnnotationValue#ofClass(ClassDesc) AnnotationValue::ofClass\n@@ -87,1 +100,1 @@\n-     * {@return an annotation key-value pair for a string-valued annotation}\n+     * {@return an element-value pair for a string-valued element}\n@@ -90,0 +103,1 @@\n+     * @see AnnotationValue#ofString(String) AnnotationValue::ofString\n@@ -97,1 +111,1 @@\n-     * {@return an annotation key-value pair for a long-valued annotation}\n+     * {@return an element-value pair for a long-valued element}\n@@ -100,0 +114,1 @@\n+     * @see AnnotationValue#ofLong(long) AnnotationValue::ofLong\n@@ -107,1 +122,1 @@\n-     * {@return an annotation key-value pair for an int-valued annotation}\n+     * {@return an element-value pair for an int-valued element}\n@@ -110,0 +125,1 @@\n+     * @see AnnotationValue#ofInt(int) AnnotationValue::ofInt\n@@ -117,1 +133,1 @@\n-     * {@return an annotation key-value pair for a char-valued annotation}\n+     * {@return an element-value pair for a char-valued element}\n@@ -120,0 +136,1 @@\n+     * @see AnnotationValue#ofChar(char) AnnotationValue::ofChar\n@@ -127,1 +144,1 @@\n-     * {@return an annotation key-value pair for a short-valued annotation}\n+     * {@return an element-value pair for a short-valued element}\n@@ -130,0 +147,1 @@\n+     * @see AnnotationValue#ofShort(short) AnnotationValue::ofShort\n@@ -137,1 +155,1 @@\n-     * {@return an annotation key-value pair for a byte-valued annotation}\n+     * {@return an element-value pair for a byte-valued element}\n@@ -140,0 +158,1 @@\n+     * @see AnnotationValue#ofByte(byte) AnnotationValue::ofByte\n@@ -142,1 +161,1 @@\n-                                      byte value) {\n+                                    byte value) {\n@@ -147,1 +166,1 @@\n-     * {@return an annotation key-value pair for a boolean-valued annotation}\n+     * {@return an element-value pair for a boolean-valued element}\n@@ -150,0 +169,1 @@\n+     * @see AnnotationValue#ofBoolean(boolean) AnnotationValue::ofBoolean\n@@ -152,1 +172,1 @@\n-                                      boolean value) {\n+                                       boolean value) {\n@@ -157,1 +177,1 @@\n-     * {@return an annotation key-value pair for a double-valued annotation}\n+     * {@return an element-value pair for a double-valued element}\n@@ -160,0 +180,1 @@\n+     * @see AnnotationValue#ofDouble(double) AnnotationValue::ofDouble\n@@ -167,1 +188,1 @@\n-     * {@return an annotation key-value pair for a float-valued annotation}\n+     * {@return an element-value pair for a float-valued element}\n@@ -170,0 +191,1 @@\n+     * @see AnnotationValue#ofFloat(float) AnnotationValue::ofFloat\n@@ -177,1 +199,1 @@\n-     * {@return an annotation key-value pair for an annotation-valued annotation}\n+     * {@return an element-value pair for an annotation-valued element}\n@@ -180,0 +202,1 @@\n+     * @see AnnotationValue#ofAnnotation AnnotationValue::ofAnnotation\n@@ -187,1 +210,1 @@\n-     * {@return an annotation key-value pair for an array-valued annotation}\n+     * {@return an element-value pair for an array-valued element}\n@@ -190,0 +213,1 @@\n+     * @see AnnotationValue#ofArray(AnnotationValue...) AnnotationValue::ofArray\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationElement.java","additions":41,"deletions":17,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.classfile.constantpool.DynamicConstantPoolEntry;\n@@ -37,1 +38,1 @@\n-import java.lang.constant.ConstantDesc;\n+import java.lang.constant.Constable;\n@@ -43,1 +44,5 @@\n- * Models the value of a key-value pair of an annotation.\n+ * Models an {@code element_value} structure, or a value of an element-value\n+ * pair of an annotation, as defined in JVMS {@jvms 4.7.16.1}.\n+ * <p>\n+ * Two {@code AnnotationValue} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -52,4 +57,1 @@\n-public sealed interface AnnotationValue\n-        permits AnnotationValue.OfAnnotation, AnnotationValue.OfArray,\n-                AnnotationValue.OfConstant, AnnotationValue.OfClass,\n-                AnnotationValue.OfEnum {\n+public sealed interface AnnotationValue {\n@@ -58,1 +60,2 @@\n-     * Models an annotation-valued element\n+     * Models an annotation value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ANNOTATION}.\n@@ -65,1 +68,1 @@\n-        \/** {@return the annotation} *\/\n+        \/** {@return the annotation value} *\/\n@@ -70,1 +73,2 @@\n-     * Models an array-valued element\n+     * Models an array value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ARRAY}.\n@@ -77,1 +81,9 @@\n-        \/** {@return the values} *\/\n+        \/**\n+         * {@return the array elements of the array value}\n+         *\n+         * @apiNote\n+         * All array elements derived from Java source code have the same type,\n+         * which must not be an array type. (JLS {@jls 9.6.1}) If such elements are\n+         * annotations, they have the same annotation interface; if such elements\n+         * are enum, they belong to the same enum class.\n+         *\/\n@@ -82,1 +94,1 @@\n-     * Models a constant-valued element\n+     * Models a constant value of an element-value pair.\n@@ -88,7 +100,12 @@\n-    sealed interface OfConstant extends AnnotationValue\n-            permits AnnotationValue.OfString, AnnotationValue.OfDouble,\n-                    AnnotationValue.OfFloat, AnnotationValue.OfLong,\n-                    AnnotationValue.OfInteger, AnnotationValue.OfShort,\n-                    AnnotationValue.OfCharacter, AnnotationValue.OfByte,\n-                    AnnotationValue.OfBoolean, AnnotationImpl.OfConstantImpl {\n-        \/** {@return the constant} *\/\n+    sealed interface OfConstant extends AnnotationValue {\n+        \/**\n+         * {@return the constant pool entry backing this constant element}\n+         *\n+         * @apiNote\n+         * Different types of constant values may share the same type of entry\n+         * because they have the same {@linkplain TypeKind##computational-type\n+         * computational type}.\n+         * For example, {@link OfInt} and {@link OfChar} are both\n+         * backed by {@link IntegerEntry}. Use {@link #resolvedValue\n+         * resolvedValue()} for a value of accurate type.\n+         *\/\n@@ -96,3 +113,0 @@\n-        \/** {@return the constant} *\/\n-        ConstantDesc constantValue();\n-    }\n@@ -100,2 +114,19 @@\n-    \/**\n-     * Models a constant-valued element\n+        \/**\n+         * {@return the resolved live constant value, as an object} The type of\n+         * the returned value may be a wrapper class or {@link String}.\n+         *\n+         * @apiNote\n+         * The returned object, despite being {@link Constable}, may not\n+         * {@linkplain Constable#describeConstable() describe} the right constant\n+         * for encoding the annotation value in a class file. For example,\n+         * {@link Character} returned by {@link OfChar} describes itself as a\n+         * {@link DynamicConstantPoolEntry}, but it is actually backed by\n+         * {@link IntegerEntry} in annotation format.\n+         * Use {@link #constant constant()} for a correct constant pool representation.\n+         *\/\n+        Constable resolvedValue();\n+    }\n+\n+    \/**\n+     * Models a string value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_STRING}.\n@@ -106,1 +137,1 @@\n-    sealed interface OfString extends AnnotationValue.OfConstant\n+    sealed interface OfString extends OfConstant\n@@ -108,1 +139,5 @@\n-        \/** {@return the constant} *\/\n+        \/** {@return the backing UTF8 entry} *\/\n+        @Override\n+        Utf8Entry constant();\n+\n+        \/** {@return the constant string value} *\/\n@@ -110,0 +145,11 @@\n+\n+        \/**\n+         * {@return the resolved string value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #stringValue()}.\n+         *\/\n+        @Override\n+        default String resolvedValue() {\n+            return stringValue();\n+        }\n@@ -113,1 +159,2 @@\n-     * Models a constant-valued element\n+     * Models a double value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_DOUBLE}.\n@@ -118,1 +165,1 @@\n-    sealed interface OfDouble extends AnnotationValue.OfConstant\n+    sealed interface OfDouble extends OfConstant\n@@ -120,1 +167,5 @@\n-        \/** {@return the constant} *\/\n+        \/** {@return the backing double entry} *\/\n+        @Override\n+        DoubleEntry constant();\n+\n+        \/** {@return the constant double value} *\/\n@@ -122,0 +173,11 @@\n+\n+        \/**\n+         * {@return the resolved double value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #doubleValue()}.\n+         *\/\n+        @Override\n+        default Double resolvedValue() {\n+            return doubleValue();\n+        }\n@@ -125,1 +187,2 @@\n-     * Models a constant-valued element\n+     * Models a float value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_FLOAT}.\n@@ -130,1 +193,1 @@\n-    sealed interface OfFloat extends AnnotationValue.OfConstant\n+    sealed interface OfFloat extends OfConstant\n@@ -132,1 +195,5 @@\n-        \/** {@return the constant} *\/\n+        \/** {@return the backing float entry} *\/\n+        @Override\n+        FloatEntry constant();\n+\n+        \/** {@return the constant float value} *\/\n@@ -134,0 +201,11 @@\n+\n+        \/**\n+         * {@return the resolved float value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #floatValue()}.\n+         *\/\n+        @Override\n+        default Float resolvedValue() {\n+            return floatValue();\n+        }\n@@ -137,1 +215,2 @@\n-     * Models a constant-valued element\n+     * Models a long value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_LONG}.\n@@ -142,1 +221,1 @@\n-    sealed interface OfLong extends AnnotationValue.OfConstant\n+    sealed interface OfLong extends OfConstant\n@@ -144,1 +223,5 @@\n-        \/** {@return the constant} *\/\n+        \/** {@return the backing long entry} *\/\n+        @Override\n+        LongEntry constant();\n+\n+        \/** {@return the constant long value} *\/\n@@ -146,0 +229,11 @@\n+\n+        \/**\n+         * {@return the resolved long value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #longValue()}.\n+         *\/\n+        @Override\n+        default Long resolvedValue() {\n+            return longValue();\n+        }\n@@ -149,1 +243,2 @@\n-     * Models a constant-valued element\n+     * Models an int value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_INT}.\n@@ -154,3 +249,7 @@\n-    sealed interface OfInteger extends AnnotationValue.OfConstant\n-            permits AnnotationImpl.OfIntegerImpl {\n-        \/** {@return the constant} *\/\n+    sealed interface OfInt extends OfConstant\n+            permits AnnotationImpl.OfIntImpl {\n+        \/** {@return the backing integer entry} *\/\n+        @Override\n+        IntegerEntry constant();\n+\n+        \/** {@return the constant int value} *\/\n@@ -158,0 +257,11 @@\n+\n+        \/**\n+         * {@return the resolved int value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #intValue()}.\n+         *\/\n+        @Override\n+        default Integer resolvedValue() {\n+            return intValue();\n+        }\n@@ -161,1 +271,2 @@\n-     * Models a constant-valued element\n+     * Models a short value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_SHORT}.\n@@ -166,1 +277,1 @@\n-    sealed interface OfShort extends AnnotationValue.OfConstant\n+    sealed interface OfShort extends OfConstant\n@@ -168,1 +279,8 @@\n-        \/** {@return the constant} *\/\n+        \/** {@return the backing integer entry} *\/\n+        @Override\n+        IntegerEntry constant();\n+\n+        \/**\n+         * {@return the constant short value}\n+         * @jvms 2.11.1 Types and the Java Virtual Machine\n+         *\/\n@@ -170,0 +288,11 @@\n+\n+        \/**\n+         * {@return the resolved short value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #shortValue()}.\n+         *\/\n+        @Override\n+        default Short resolvedValue() {\n+            return shortValue();\n+        }\n@@ -173,1 +302,2 @@\n-     * Models a constant-valued element\n+     * Models a char value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CHAR}.\n@@ -178,3 +308,10 @@\n-    sealed interface OfCharacter extends AnnotationValue.OfConstant\n-            permits AnnotationImpl.OfCharacterImpl {\n-        \/** {@return the constant} *\/\n+    sealed interface OfChar extends OfConstant\n+            permits AnnotationImpl.OfCharImpl {\n+        \/** {@return the backing integer entry} *\/\n+        @Override\n+        IntegerEntry constant();\n+\n+        \/**\n+         * {@return the constant char value}\n+         * @jvms 2.11.1 Types and the Java Virtual Machine\n+         *\/\n@@ -182,0 +319,11 @@\n+\n+        \/**\n+         * {@return the resolved char value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #charValue()}.\n+         *\/\n+        @Override\n+        default Character resolvedValue() {\n+            return charValue();\n+        }\n@@ -185,1 +333,2 @@\n-     * Models a constant-valued element\n+     * Models a byte value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BYTE}.\n@@ -190,1 +339,1 @@\n-    sealed interface OfByte extends AnnotationValue.OfConstant\n+    sealed interface OfByte extends OfConstant\n@@ -192,1 +341,8 @@\n-        \/** {@return the constant} *\/\n+        \/** {@return the backing integer entry} *\/\n+        @Override\n+        IntegerEntry constant();\n+\n+        \/**\n+         * {@return the constant byte value}\n+         * @jvms 2.11.1 Types and the Java Virtual Machine\n+         *\/\n@@ -194,0 +350,11 @@\n+\n+        \/**\n+         * {@return the resolved byte value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #byteValue()}.\n+         *\/\n+        @Override\n+        default Byte resolvedValue() {\n+            return byteValue();\n+        }\n@@ -197,1 +364,2 @@\n-     * Models a constant-valued element\n+     * Models a boolean value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_BOOLEAN}.\n@@ -202,1 +370,1 @@\n-    sealed interface OfBoolean extends AnnotationValue.OfConstant\n+    sealed interface OfBoolean extends OfConstant\n@@ -204,1 +372,8 @@\n-        \/** {@return the constant} *\/\n+        \/** {@return the backing integer entry} *\/\n+        @Override\n+        IntegerEntry constant();\n+\n+        \/**\n+         * {@return the constant boolean value}\n+         * @jvms 2.3.4 The <i>boolean<\/i> Type\n+         *\/\n@@ -206,0 +381,11 @@\n+\n+        \/**\n+         * {@return the resolved boolean value}\n+         *\n+         * @implSpec\n+         * This method returns the same as {@link #booleanValue()}.\n+         *\/\n+        @Override\n+        default Boolean resolvedValue() {\n+            return booleanValue();\n+        }\n@@ -209,1 +395,2 @@\n-     * Models a class-valued element\n+     * Models a class value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_CLASS}.\n@@ -216,1 +403,1 @@\n-        \/** {@return the class name} *\/\n+        \/** {@return the class descriptor string} *\/\n@@ -219,1 +406,1 @@\n-        \/** {@return the class symbol} *\/\n+        \/** {@return the class descriptor} *\/\n@@ -226,1 +413,2 @@\n-     * Models an enum-valued element\n+     * Models an enum value of an element-value pair.\n+     * The {@linkplain #tag tag} of this value is {@value ClassFile#AEV_ENUM}.\n@@ -233,1 +421,1 @@\n-        \/** {@return the enum class name} *\/\n+        \/** {@return the enum class descriptor string} *\/\n@@ -236,1 +424,1 @@\n-        \/** {@return the enum class symbol} *\/\n+        \/** {@return the enum class descriptor} *\/\n@@ -246,1 +434,2 @@\n-     * {@return the tag character for this type as per {@jvms 4.7.16.1}}\n+     * {@return the tag character for this value as per JVMS {@jvms 4.7.16.1}}\n+     * The tag characters have a one-to-one mapping to the types of annotation element values.\n@@ -251,2 +440,2 @@\n-     * {@return an annotation element for a enum-valued element}\n-     * @param className the name of the enum class\n+     * {@return an enum value for an element-value pair}\n+     * @param className the descriptor string of the enum class\n@@ -261,2 +450,2 @@\n-     * {@return an annotation element for a enum-valued element}\n-     * @param className the name of the enum class\n+     * {@return an enum value for an element-value pair}\n+     * @param className the descriptor of the enum class\n@@ -271,2 +460,2 @@\n-     * {@return an annotation element for a class-valued element}\n-     * @param className the name of the enum class\n+     * {@return a class value for an element-value pair}\n+     * @param className the descriptor string of the class\n@@ -279,2 +468,2 @@\n-     * {@return an annotation element for a class-valued element}\n-     * @param className the name of the enum class\n+     * {@return a class value for an element-value pair}\n+     * @param className the descriptor of the class\n@@ -287,1 +476,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -290,1 +479,1 @@\n-    static OfConstant ofString(Utf8Entry value) {\n+    static OfString ofString(Utf8Entry value) {\n@@ -295,1 +484,1 @@\n-     * {@return an annotation element for a string-valued element}\n+     * {@return a string value for an element-value pair}\n@@ -298,1 +487,1 @@\n-    static OfConstant ofString(String value) {\n+    static OfString ofString(String value) {\n@@ -303,1 +492,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -306,1 +495,1 @@\n-    static OfConstant ofDouble(DoubleEntry value) {\n+    static OfDouble ofDouble(DoubleEntry value) {\n@@ -311,1 +500,1 @@\n-     * {@return an annotation element for a double-valued element}\n+     * {@return a double value for an element-value pair}\n@@ -314,1 +503,1 @@\n-    static OfConstant ofDouble(double value) {\n+    static OfDouble ofDouble(double value) {\n@@ -319,1 +508,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -322,1 +511,1 @@\n-    static OfConstant ofFloat(FloatEntry value) {\n+    static OfFloat ofFloat(FloatEntry value) {\n@@ -327,1 +516,1 @@\n-     * {@return an annotation element for a float-valued element}\n+     * {@return a float value for an element-value pair}\n@@ -330,1 +519,1 @@\n-    static OfConstant ofFloat(float value) {\n+    static OfFloat ofFloat(float value) {\n@@ -335,1 +524,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -338,1 +527,1 @@\n-    static OfConstant ofLong(LongEntry value) {\n+    static OfLong ofLong(LongEntry value) {\n@@ -343,1 +532,1 @@\n-     * {@return an annotation element for a long-valued element}\n+     * {@return a long value for an element-value pair}\n@@ -346,1 +535,1 @@\n-    static OfConstant ofLong(long value) {\n+    static OfLong ofLong(long value) {\n@@ -351,1 +540,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -354,2 +543,2 @@\n-    static OfConstant ofInt(IntegerEntry value) {\n-        return new AnnotationImpl.OfIntegerImpl(value);\n+    static OfInt ofInt(IntegerEntry value) {\n+        return new AnnotationImpl.OfIntImpl(value);\n@@ -359,1 +548,1 @@\n-     * {@return an annotation element for an int-valued element}\n+     * {@return an int value for an element-value pair}\n@@ -362,1 +551,1 @@\n-    static OfConstant ofInt(int value) {\n+    static OfInt ofInt(int value) {\n@@ -367,1 +556,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -370,1 +559,1 @@\n-    static OfConstant ofShort(IntegerEntry value) {\n+    static OfShort ofShort(IntegerEntry value) {\n@@ -375,1 +564,1 @@\n-     * {@return an annotation element for a short-valued element}\n+     * {@return a short value for an element-value pair}\n@@ -378,1 +567,1 @@\n-    static OfConstant ofShort(short value) {\n+    static OfShort ofShort(short value) {\n@@ -383,1 +572,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -386,2 +575,2 @@\n-    static OfConstant ofChar(IntegerEntry value) {\n-        return new AnnotationImpl.OfCharacterImpl(value);\n+    static OfChar ofChar(IntegerEntry value) {\n+        return new AnnotationImpl.OfCharImpl(value);\n@@ -391,1 +580,1 @@\n-     * {@return an annotation element for a char-valued element}\n+     * {@return a char value for an element-value pair}\n@@ -394,1 +583,1 @@\n-    static OfConstant ofChar(char value) {\n+    static OfChar ofChar(char value) {\n@@ -399,1 +588,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -402,1 +591,1 @@\n-    static OfConstant ofByte(IntegerEntry value) {\n+    static OfByte ofByte(IntegerEntry value) {\n@@ -407,1 +596,1 @@\n-     * {@return an annotation element for a byte-valued element}\n+     * {@return a byte value for an element-value pair}\n@@ -410,1 +599,1 @@\n-    static OfConstant ofByte(byte value) {\n+    static OfByte ofByte(byte value) {\n@@ -415,1 +604,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -418,1 +607,1 @@\n-    static OfConstant ofBoolean(IntegerEntry value) {\n+    static OfBoolean ofBoolean(IntegerEntry value) {\n@@ -423,1 +612,1 @@\n-     * {@return an annotation element for a boolean-valued element}\n+     * {@return a boolean value for an element-value pair}\n@@ -426,1 +615,1 @@\n-    static OfConstant ofBoolean(boolean value) {\n+    static OfBoolean ofBoolean(boolean value) {\n@@ -432,1 +621,1 @@\n-     * {@return an annotation element for an annotation-valued element}\n+     * {@return an annotation value for an element-value pair}\n@@ -440,2 +629,7 @@\n-     * {@return an annotation element for an array-valued element}\n-     * @param values the values\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n+     * @param values the array elements\n@@ -448,2 +642,7 @@\n-     * {@return an annotation element for an array-valued element}\n-     * @param values the values\n+     * {@return an array value for an element-value pair}\n+     *\n+     * @apiNote\n+     * See {@link AnnotationValue.OfArray#values() values()} for conventions\n+     * on array values derived from Java source code.\n+     *\n+     * @param values the array elements\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AnnotationValue.java","additions":308,"deletions":109,"binary":false,"changes":417,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -69,1 +69,1 @@\n- * Models a classfile attribute {@jvms 4.7}.  Many, though not all, subtypes of\n+ * Models a classfile attribute (JVMS {@jvms 4.7}).  Many, though not all, subtypes of\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Attribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n-public interface AttributeMapper<A> {\n+public interface AttributeMapper<A extends Attribute<A>> {\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/AttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -197,1 +197,1 @@\n-        return withField(name, descriptor, fb -> fb.withFlags(flags));\n+        return withField(name, descriptor, Util.buildingFlags(flags));\n@@ -244,1 +244,1 @@\n-        return withMethod(name, descriptor, methodFlags, mb -> mb.withCode(handler));\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n@@ -279,4 +279,1 @@\n-        return withMethodBody(constantPool().utf8Entry(name),\n-                              constantPool().utf8Entry(descriptor),\n-                              methodFlags,\n-                              handler);\n+        return withMethod(name, descriptor, methodFlags, Util.buildingCode(handler));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassBuilder.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n- * Models the generic signature of a class file, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a class file, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/ClassSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -265,1 +265,1 @@\n-        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || BytecodeHelpers.isUnconditionalBranch(opcode)) {\n@@ -315,1 +315,1 @@\n-        if (opcode.kind() != Opcode.Kind.BRANCH || opcode.primaryTypeKind() == TypeKind.VoidType) {\n+        if (opcode.kind() != Opcode.Kind.BRANCH || BytecodeHelpers.isUnconditionalBranch(opcode)) {\n@@ -553,1 +553,2 @@\n-     * @throws IllegalArgumentException for conversions of {@code VoidType} or {@code ReferenceType}\n+     * @throws IllegalArgumentException for conversions of {@link TypeKind#VOID void} or\n+     *         {@link TypeKind#REFERENCE reference}\n@@ -557,73 +558,47 @@\n-        return switch (fromType) {\n-            case IntType, ByteType, CharType, ShortType, BooleanType ->\n-                    switch (toType) {\n-                        case IntType -> this;\n-                        case LongType -> i2l();\n-                        case DoubleType -> i2d();\n-                        case FloatType -> i2f();\n-                        case ByteType -> i2b();\n-                        case CharType -> i2c();\n-                        case ShortType -> i2s();\n-                        case BooleanType -> iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case LongType ->\n-                    switch (toType) {\n-                        case IntType -> l2i();\n-                        case LongType -> this;\n-                        case DoubleType -> l2d();\n-                        case FloatType -> l2f();\n-                        case ByteType -> l2i().i2b();\n-                        case CharType -> l2i().i2c();\n-                        case ShortType -> l2i().i2s();\n-                        case BooleanType -> l2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case DoubleType ->\n-                    switch (toType) {\n-                        case IntType -> d2i();\n-                        case LongType -> d2l();\n-                        case DoubleType -> this;\n-                        case FloatType -> d2f();\n-                        case ByteType -> d2i().i2b();\n-                        case CharType -> d2i().i2c();\n-                        case ShortType -> d2i().i2s();\n-                        case BooleanType -> d2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case FloatType ->\n-                    switch (toType) {\n-                        case IntType -> f2i();\n-                        case LongType -> f2l();\n-                        case DoubleType -> f2d();\n-                        case FloatType -> this;\n-                        case ByteType -> f2i().i2b();\n-                        case CharType -> f2i().i2c();\n-                        case ShortType -> f2i().i2s();\n-                        case BooleanType -> f2i().iconst_1().iand();\n-                        case VoidType, ReferenceType ->\n-                            throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-                    };\n-            case VoidType, ReferenceType ->\n-                throw new IllegalArgumentException(String.format(\"convert %s -> %s\", fromType, toType));\n-        };\n-    }\n-\n-    \/**\n-     * Generate an instruction pushing a constant onto the operand stack\n-     * @see Opcode.Kind#CONSTANT\n-     * @param opcode the constant instruction opcode\n-     * @param value the constant value\n-     * @return this builder\n-     * @since 23\n-     *\/\n-    default CodeBuilder loadConstant(Opcode opcode, ConstantDesc value) {\n-        BytecodeHelpers.validateValue(opcode, value);\n-        return with(switch (opcode) {\n-            case SIPUSH, BIPUSH -> ConstantInstruction.ofArgument(opcode, ((Number)value).intValue());\n-            case LDC, LDC_W, LDC2_W -> ConstantInstruction.ofLoad(opcode, BytecodeHelpers.constantEntry(constantPool(), value));\n-            default -> ConstantInstruction.ofIntrinsic(opcode);\n-        });\n+        var computationalFrom = fromType.asLoadable();\n+        var computationalTo = toType.asLoadable();\n+        if (computationalFrom != computationalTo) {\n+            switch (computationalTo) {\n+                case INT -> {\n+                    switch (computationalFrom) {\n+                        case FLOAT -> f2i();\n+                        case LONG -> l2i();\n+                        case DOUBLE -> d2i();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case FLOAT -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2f();\n+                        case LONG -> l2f();\n+                        case DOUBLE -> d2f();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case LONG -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2l();\n+                        case FLOAT -> f2l();\n+                        case DOUBLE -> d2l();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+                case DOUBLE -> {\n+                    switch (computationalFrom) {\n+                        case INT -> i2d();\n+                        case FLOAT -> f2d();\n+                        case LONG -> l2d();\n+                        default -> throw BytecodeHelpers.cannotConvertException(fromType, toType);\n+                    }\n+                }\n+            }\n+        }\n+        if (computationalTo == TypeKind.INT && toType != TypeKind.INT) {\n+            switch (toType) {\n+                case BOOLEAN -> iconst_1().iand();\n+                case BYTE -> i2b();\n+                case CHAR -> i2c();\n+                case SHORT -> i2s();\n+            }\n+        }\n+        return this;\n@@ -642,26 +617,28 @@\n-        if (value instanceof Integer iVal)\n-            return switch (iVal) {\n-                case -1 -> iconst_m1();\n-                case  0 -> iconst_0();\n-                case  1 -> iconst_1();\n-                case  2 -> iconst_2();\n-                case  3 -> iconst_3();\n-                case  4 -> iconst_4();\n-                case  5 -> iconst_5();\n-                default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n-                         : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n-                         : ldc(constantPool().intEntry(iVal));\n-            };\n-        if (value instanceof Long lVal)\n-            return lVal == 0l ? lconst_0()\n-                 : lVal == 1l ? lconst_1()\n-                 : ldc(constantPool().longEntry(lVal));\n-        if (value instanceof Float fVal)\n-            return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n-                 : fVal == 1.0f ? fconst_1()\n-                 : fVal == 2.0f ? fconst_2()\n-                 : ldc(constantPool().floatEntry(fVal));\n-        if (value instanceof Double dVal)\n-            return Double.doubleToRawLongBits(dVal) == 0l ? dconst_0()\n-                 : dVal == 1.0d ? dconst_1()\n-                 : ldc(constantPool().doubleEntry(dVal));\n+        if (value instanceof Number) {\n+            if (value instanceof Integer iVal)\n+                return switch (iVal) {\n+                    case -1 -> iconst_m1();\n+                    case 0 -> iconst_0();\n+                    case 1 -> iconst_1();\n+                    case 2 -> iconst_2();\n+                    case 3 -> iconst_3();\n+                    case 4 -> iconst_4();\n+                    case 5 -> iconst_5();\n+                    default -> (iVal >= Byte.MIN_VALUE && iVal <= Byte.MAX_VALUE) ? bipush(iVal)\n+                            : (iVal >= Short.MIN_VALUE && iVal <= Short.MAX_VALUE) ? sipush(iVal)\n+                            : ldc(constantPool().intEntry(iVal));\n+                };\n+            if (value instanceof Long lVal)\n+                return lVal == 0L ? lconst_0()\n+                        : lVal == 1L ? lconst_1()\n+                        : ldc(constantPool().longEntry(lVal));\n+            if (value instanceof Float fVal)\n+                return Float.floatToRawIntBits(fVal) == 0 ? fconst_0()\n+                        : fVal == 1.0f ? fconst_1()\n+                        : fVal == 2.0f ? fconst_2()\n+                        : ldc(constantPool().floatEntry(fVal));\n+            if (value instanceof Double dVal)\n+                return Double.doubleToRawLongBits(dVal) == 0L ? dconst_0()\n+                        : dVal == 1.0d ? dconst_1()\n+                        : ldc(constantPool().doubleEntry(dVal));\n+        }\n@@ -843,1 +820,1 @@\n-        return arrayLoad(TypeKind.ReferenceType);\n+        return arrayLoad(TypeKind.REFERENCE);\n@@ -851,1 +828,1 @@\n-        return arrayStore(TypeKind.ReferenceType);\n+        return arrayStore(TypeKind.REFERENCE);\n@@ -864,1 +841,1 @@\n-        return loadLocal(TypeKind.ReferenceType, slot);\n+        return loadLocal(TypeKind.REFERENCE, slot);\n@@ -891,1 +868,1 @@\n-        return return_(TypeKind.ReferenceType);\n+        return return_(TypeKind.REFERENCE);\n@@ -912,1 +889,1 @@\n-        return storeLocal(TypeKind.ReferenceType, slot);\n+        return storeLocal(TypeKind.REFERENCE, slot);\n@@ -928,1 +905,1 @@\n-        return arrayLoad(TypeKind.ByteType);\n+        return arrayLoad(TypeKind.BYTE);\n@@ -936,1 +913,1 @@\n-        return arrayStore(TypeKind.ByteType);\n+        return arrayStore(TypeKind.BYTE);\n@@ -940,2 +917,2 @@\n-     * Generate an instruction pushing a byte onto the operand stack\n-     * @param b the byte\n+     * Generate an instruction pushing an int in the range of byte onto the operand stack.\n+     * @param b the int in the range of byte\n@@ -945,1 +922,1 @@\n-        return loadConstant(Opcode.BIPUSH, b);\n+        return with(ConstantInstruction.ofArgument(Opcode.BIPUSH, b));\n@@ -953,1 +930,1 @@\n-        return arrayLoad(TypeKind.CharType);\n+        return arrayLoad(TypeKind.CHAR);\n@@ -961,1 +938,1 @@\n-        return arrayStore(TypeKind.CharType);\n+        return arrayStore(TypeKind.CHAR);\n@@ -1020,1 +997,1 @@\n-        return arrayLoad(TypeKind.DoubleType);\n+        return arrayLoad(TypeKind.DOUBLE);\n@@ -1028,1 +1005,1 @@\n-        return arrayStore(TypeKind.DoubleType);\n+        return arrayStore(TypeKind.DOUBLE);\n@@ -1081,1 +1058,1 @@\n-        return loadLocal(TypeKind.DoubleType, slot);\n+        return loadLocal(TypeKind.DOUBLE, slot);\n@@ -1113,1 +1090,1 @@\n-        return return_(TypeKind.DoubleType);\n+        return return_(TypeKind.DOUBLE);\n@@ -1126,1 +1103,1 @@\n-        return storeLocal(TypeKind.DoubleType, slot);\n+        return storeLocal(TypeKind.DOUBLE, slot);\n@@ -1224,1 +1201,1 @@\n-        return arrayLoad(TypeKind.FloatType);\n+        return arrayLoad(TypeKind.FLOAT);\n@@ -1232,1 +1209,1 @@\n-        return arrayStore(TypeKind.FloatType);\n+        return arrayStore(TypeKind.FLOAT);\n@@ -1293,1 +1270,1 @@\n-        return loadLocal(TypeKind.FloatType, slot);\n+        return loadLocal(TypeKind.FLOAT, slot);\n@@ -1325,1 +1302,1 @@\n-        return return_(TypeKind.FloatType);\n+        return return_(TypeKind.FLOAT);\n@@ -1338,1 +1315,1 @@\n-        return storeLocal(TypeKind.FloatType, slot);\n+        return storeLocal(TypeKind.FLOAT, slot);\n@@ -1479,1 +1456,1 @@\n-        return arrayLoad(TypeKind.IntType);\n+        return arrayLoad(TypeKind.INT);\n@@ -1495,1 +1472,1 @@\n-        return arrayStore(TypeKind.IntType);\n+        return arrayStore(TypeKind.INT);\n@@ -1726,1 +1703,1 @@\n-        return loadLocal(TypeKind.IntType, slot);\n+        return loadLocal(TypeKind.INT, slot);\n@@ -1955,1 +1932,1 @@\n-        return return_(TypeKind.IntType);\n+        return return_(TypeKind.INT);\n@@ -1984,1 +1961,1 @@\n-        return storeLocal(TypeKind.IntType, slot);\n+        return storeLocal(TypeKind.INT, slot);\n@@ -2058,1 +2035,1 @@\n-        return arrayLoad(TypeKind.LongType);\n+        return arrayLoad(TypeKind.LONG);\n@@ -2074,1 +2051,1 @@\n-        return arrayStore(TypeKind.LongType);\n+        return arrayStore(TypeKind.LONG);\n@@ -2125,4 +2102,1 @@\n-        return with(ConstantInstruction.ofLoad(\n-                entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n-                : entry.index() > 0xff ? Opcode.LDC_W\n-                : Opcode.LDC, entry));\n+        return with(ConstantInstruction.ofLoad(BytecodeHelpers.ldcOpcode(entry), entry));\n@@ -2149,1 +2123,1 @@\n-        return loadLocal(TypeKind.LongType, slot);\n+        return loadLocal(TypeKind.LONG, slot);\n@@ -2189,1 +2163,1 @@\n-        return return_(TypeKind.LongType);\n+        return return_(TypeKind.LONG);\n@@ -2218,1 +2192,1 @@\n-        return storeLocal(TypeKind.LongType, slot);\n+        return storeLocal(TypeKind.LONG, slot);\n@@ -2388,1 +2362,1 @@\n-        return return_(TypeKind.VoidType);\n+        return return_(TypeKind.VOID);\n@@ -2396,1 +2370,1 @@\n-        return arrayLoad(TypeKind.ShortType);\n+        return arrayLoad(TypeKind.SHORT);\n@@ -2404,1 +2378,1 @@\n-        return arrayStore(TypeKind.ShortType);\n+        return arrayStore(TypeKind.SHORT);\n@@ -2408,2 +2382,2 @@\n-     * Generate an instruction pushing a short onto the operand stack\n-     * @param s the short\n+     * Generate an instruction pushing an int in the range of short onto the operand stack.\n+     * @param s the int in the range of short\n@@ -2413,1 +2387,1 @@\n-        return loadConstant(Opcode.SIPUSH, s);\n+        return with(ConstantInstruction.ofArgument(Opcode.SIPUSH, s));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/CodeBuilder.java","additions":118,"deletions":144,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the generic signature of a method, as defined by {@jvms 4.7.9}.\n+ * Models the generic signature of a method, as defined by JVMS {@jvms 4.7.9}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/MethodSignature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,2 +27,0 @@\n-import java.lang.constant.ConstantDesc;\n-import java.lang.constant.ConstantDescs;\n@@ -32,1 +30,1 @@\n- * Describes the opcodes of the JVM instruction set, as described in {@jvms 6.5}.\n+ * Describes the opcodes of the JVM instruction set, as described in JVMS {@jvms 6.5}.\n@@ -48,1 +46,1 @@\n-    ACONST_NULL(ClassFile.ACONST_NULL, 1, Kind.CONSTANT, TypeKind.ReferenceType, 0, ConstantDescs.NULL),\n+    ACONST_NULL(ClassFile.ACONST_NULL, 1, Kind.CONSTANT),\n@@ -51,1 +49,1 @@\n-    ICONST_M1(ClassFile.ICONST_M1, 1, Kind.CONSTANT, TypeKind.IntType, 0, -1),\n+    ICONST_M1(ClassFile.ICONST_M1, 1, Kind.CONSTANT),\n@@ -54,1 +52,1 @@\n-    ICONST_0(ClassFile.ICONST_0, 1, Kind.CONSTANT, TypeKind.IntType, 0, 0),\n+    ICONST_0(ClassFile.ICONST_0, 1, Kind.CONSTANT),\n@@ -57,1 +55,1 @@\n-    ICONST_1(ClassFile.ICONST_1, 1, Kind.CONSTANT, TypeKind.IntType, 0, 1),\n+    ICONST_1(ClassFile.ICONST_1, 1, Kind.CONSTANT),\n@@ -60,1 +58,1 @@\n-    ICONST_2(ClassFile.ICONST_2, 1, Kind.CONSTANT, TypeKind.IntType, 0, 2),\n+    ICONST_2(ClassFile.ICONST_2, 1, Kind.CONSTANT),\n@@ -63,1 +61,1 @@\n-    ICONST_3(ClassFile.ICONST_3, 1, Kind.CONSTANT, TypeKind.IntType, 0, 3),\n+    ICONST_3(ClassFile.ICONST_3, 1, Kind.CONSTANT),\n@@ -66,1 +64,1 @@\n-    ICONST_4(ClassFile.ICONST_4, 1, Kind.CONSTANT, TypeKind.IntType, 0, 4),\n+    ICONST_4(ClassFile.ICONST_4, 1, Kind.CONSTANT),\n@@ -69,1 +67,1 @@\n-    ICONST_5(ClassFile.ICONST_5, 1, Kind.CONSTANT, TypeKind.IntType, 0, 5),\n+    ICONST_5(ClassFile.ICONST_5, 1, Kind.CONSTANT),\n@@ -72,1 +70,1 @@\n-    LCONST_0(ClassFile.LCONST_0, 1, Kind.CONSTANT, TypeKind.LongType, 0, 0L),\n+    LCONST_0(ClassFile.LCONST_0, 1, Kind.CONSTANT),\n@@ -75,1 +73,1 @@\n-    LCONST_1(ClassFile.LCONST_1, 1, Kind.CONSTANT, TypeKind.LongType, 0, 1L),\n+    LCONST_1(ClassFile.LCONST_1, 1, Kind.CONSTANT),\n@@ -78,1 +76,1 @@\n-    FCONST_0(ClassFile.FCONST_0, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 0.0f),\n+    FCONST_0(ClassFile.FCONST_0, 1, Kind.CONSTANT),\n@@ -81,1 +79,1 @@\n-    FCONST_1(ClassFile.FCONST_1, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 1.0f),\n+    FCONST_1(ClassFile.FCONST_1, 1, Kind.CONSTANT),\n@@ -84,1 +82,1 @@\n-    FCONST_2(ClassFile.FCONST_2, 1, Kind.CONSTANT, TypeKind.FloatType, 0, 2.0f),\n+    FCONST_2(ClassFile.FCONST_2, 1, Kind.CONSTANT),\n@@ -87,1 +85,1 @@\n-    DCONST_0(ClassFile.DCONST_0, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 0.0d),\n+    DCONST_0(ClassFile.DCONST_0, 1, Kind.CONSTANT),\n@@ -90,1 +88,1 @@\n-    DCONST_1(ClassFile.DCONST_1, 1, Kind.CONSTANT, TypeKind.DoubleType, 0, 1.0d),\n+    DCONST_1(ClassFile.DCONST_1, 1, Kind.CONSTANT),\n@@ -93,1 +91,1 @@\n-    BIPUSH(ClassFile.BIPUSH, 2, Kind.CONSTANT, TypeKind.ByteType),\n+    BIPUSH(ClassFile.BIPUSH, 2, Kind.CONSTANT),\n@@ -96,1 +94,1 @@\n-    SIPUSH(ClassFile.SIPUSH, 3, Kind.CONSTANT, TypeKind.ShortType),\n+    SIPUSH(ClassFile.SIPUSH, 3, Kind.CONSTANT),\n@@ -108,1 +106,1 @@\n-    ILOAD(ClassFile.ILOAD, 2, Kind.LOAD, TypeKind.IntType, -1),\n+    ILOAD(ClassFile.ILOAD, 2, Kind.LOAD),\n@@ -111,1 +109,1 @@\n-    LLOAD(ClassFile.LLOAD, 2, Kind.LOAD, TypeKind.LongType, -1),\n+    LLOAD(ClassFile.LLOAD, 2, Kind.LOAD),\n@@ -114,1 +112,1 @@\n-    FLOAD(ClassFile.FLOAD, 2, Kind.LOAD, TypeKind.FloatType, -1),\n+    FLOAD(ClassFile.FLOAD, 2, Kind.LOAD),\n@@ -117,1 +115,1 @@\n-    DLOAD(ClassFile.DLOAD, 2, Kind.LOAD, TypeKind.DoubleType, -1),\n+    DLOAD(ClassFile.DLOAD, 2, Kind.LOAD),\n@@ -120,1 +118,1 @@\n-    ALOAD(ClassFile.ALOAD, 2, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ALOAD(ClassFile.ALOAD, 2, Kind.LOAD),\n@@ -123,1 +121,1 @@\n-    ILOAD_0(ClassFile.ILOAD_0, 1, Kind.LOAD, TypeKind.IntType, 0),\n+    ILOAD_0(ClassFile.ILOAD_0, 1, Kind.LOAD),\n@@ -126,1 +124,1 @@\n-    ILOAD_1(ClassFile.ILOAD_1, 1, Kind.LOAD, TypeKind.IntType, 1),\n+    ILOAD_1(ClassFile.ILOAD_1, 1, Kind.LOAD),\n@@ -129,1 +127,1 @@\n-    ILOAD_2(ClassFile.ILOAD_2, 1, Kind.LOAD, TypeKind.IntType, 2),\n+    ILOAD_2(ClassFile.ILOAD_2, 1, Kind.LOAD),\n@@ -132,1 +130,1 @@\n-    ILOAD_3(ClassFile.ILOAD_3, 1, Kind.LOAD, TypeKind.IntType, 3),\n+    ILOAD_3(ClassFile.ILOAD_3, 1, Kind.LOAD),\n@@ -135,1 +133,1 @@\n-    LLOAD_0(ClassFile.LLOAD_0, 1, Kind.LOAD, TypeKind.LongType, 0),\n+    LLOAD_0(ClassFile.LLOAD_0, 1, Kind.LOAD),\n@@ -138,1 +136,1 @@\n-    LLOAD_1(ClassFile.LLOAD_1, 1, Kind.LOAD, TypeKind.LongType, 1),\n+    LLOAD_1(ClassFile.LLOAD_1, 1, Kind.LOAD),\n@@ -141,1 +139,1 @@\n-    LLOAD_2(ClassFile.LLOAD_2, 1, Kind.LOAD, TypeKind.LongType, 2),\n+    LLOAD_2(ClassFile.LLOAD_2, 1, Kind.LOAD),\n@@ -144,1 +142,1 @@\n-    LLOAD_3(ClassFile.LLOAD_3, 1, Kind.LOAD, TypeKind.LongType, 3),\n+    LLOAD_3(ClassFile.LLOAD_3, 1, Kind.LOAD),\n@@ -147,1 +145,1 @@\n-    FLOAD_0(ClassFile.FLOAD_0, 1, Kind.LOAD, TypeKind.FloatType, 0),\n+    FLOAD_0(ClassFile.FLOAD_0, 1, Kind.LOAD),\n@@ -150,1 +148,1 @@\n-    FLOAD_1(ClassFile.FLOAD_1, 1, Kind.LOAD, TypeKind.FloatType, 1),\n+    FLOAD_1(ClassFile.FLOAD_1, 1, Kind.LOAD),\n@@ -153,1 +151,1 @@\n-    FLOAD_2(ClassFile.FLOAD_2, 1, Kind.LOAD, TypeKind.FloatType, 2),\n+    FLOAD_2(ClassFile.FLOAD_2, 1, Kind.LOAD),\n@@ -156,1 +154,1 @@\n-    FLOAD_3(ClassFile.FLOAD_3, 1, Kind.LOAD, TypeKind.FloatType, 3),\n+    FLOAD_3(ClassFile.FLOAD_3, 1, Kind.LOAD),\n@@ -159,1 +157,1 @@\n-    DLOAD_0(ClassFile.DLOAD_0, 1, Kind.LOAD, TypeKind.DoubleType, 0),\n+    DLOAD_0(ClassFile.DLOAD_0, 1, Kind.LOAD),\n@@ -162,1 +160,1 @@\n-    DLOAD_1(ClassFile.DLOAD_1, 1, Kind.LOAD, TypeKind.DoubleType, 1),\n+    DLOAD_1(ClassFile.DLOAD_1, 1, Kind.LOAD),\n@@ -165,1 +163,1 @@\n-    DLOAD_2(ClassFile.DLOAD_2, 1, Kind.LOAD, TypeKind.DoubleType, 2),\n+    DLOAD_2(ClassFile.DLOAD_2, 1, Kind.LOAD),\n@@ -168,1 +166,1 @@\n-    DLOAD_3(ClassFile.DLOAD_3, 1, Kind.LOAD, TypeKind.DoubleType, 3),\n+    DLOAD_3(ClassFile.DLOAD_3, 1, Kind.LOAD),\n@@ -171,1 +169,1 @@\n-    ALOAD_0(ClassFile.ALOAD_0, 1, Kind.LOAD, TypeKind.ReferenceType, 0),\n+    ALOAD_0(ClassFile.ALOAD_0, 1, Kind.LOAD),\n@@ -174,1 +172,1 @@\n-    ALOAD_1(ClassFile.ALOAD_1, 1, Kind.LOAD, TypeKind.ReferenceType, 1),\n+    ALOAD_1(ClassFile.ALOAD_1, 1, Kind.LOAD),\n@@ -177,1 +175,1 @@\n-    ALOAD_2(ClassFile.ALOAD_2, 1, Kind.LOAD, TypeKind.ReferenceType, 2),\n+    ALOAD_2(ClassFile.ALOAD_2, 1, Kind.LOAD),\n@@ -180,1 +178,1 @@\n-    ALOAD_3(ClassFile.ALOAD_3, 1, Kind.LOAD, TypeKind.ReferenceType, 3),\n+    ALOAD_3(ClassFile.ALOAD_3, 1, Kind.LOAD),\n@@ -183,1 +181,1 @@\n-    IALOAD(ClassFile.IALOAD, 1, Kind.ARRAY_LOAD, TypeKind.IntType),\n+    IALOAD(ClassFile.IALOAD, 1, Kind.ARRAY_LOAD),\n@@ -186,1 +184,1 @@\n-    LALOAD(ClassFile.LALOAD, 1, Kind.ARRAY_LOAD, TypeKind.LongType),\n+    LALOAD(ClassFile.LALOAD, 1, Kind.ARRAY_LOAD),\n@@ -189,1 +187,1 @@\n-    FALOAD(ClassFile.FALOAD, 1, Kind.ARRAY_LOAD, TypeKind.FloatType),\n+    FALOAD(ClassFile.FALOAD, 1, Kind.ARRAY_LOAD),\n@@ -192,1 +190,1 @@\n-    DALOAD(ClassFile.DALOAD, 1, Kind.ARRAY_LOAD, TypeKind.DoubleType),\n+    DALOAD(ClassFile.DALOAD, 1, Kind.ARRAY_LOAD),\n@@ -195,1 +193,1 @@\n-    AALOAD(ClassFile.AALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ReferenceType),\n+    AALOAD(ClassFile.AALOAD, 1, Kind.ARRAY_LOAD),\n@@ -198,1 +196,1 @@\n-    BALOAD(ClassFile.BALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ByteType),\n+    BALOAD(ClassFile.BALOAD, 1, Kind.ARRAY_LOAD),\n@@ -201,1 +199,1 @@\n-    CALOAD(ClassFile.CALOAD, 1, Kind.ARRAY_LOAD, TypeKind.CharType),\n+    CALOAD(ClassFile.CALOAD, 1, Kind.ARRAY_LOAD),\n@@ -204,1 +202,1 @@\n-    SALOAD(ClassFile.SALOAD, 1, Kind.ARRAY_LOAD, TypeKind.ShortType),\n+    SALOAD(ClassFile.SALOAD, 1, Kind.ARRAY_LOAD),\n@@ -207,1 +205,1 @@\n-    ISTORE(ClassFile.ISTORE, 2, Kind.STORE, TypeKind.IntType, -1),\n+    ISTORE(ClassFile.ISTORE, 2, Kind.STORE),\n@@ -210,1 +208,1 @@\n-    LSTORE(ClassFile.LSTORE, 2, Kind.STORE, TypeKind.LongType, -1),\n+    LSTORE(ClassFile.LSTORE, 2, Kind.STORE),\n@@ -213,1 +211,1 @@\n-    FSTORE(ClassFile.FSTORE, 2, Kind.STORE, TypeKind.FloatType, -1),\n+    FSTORE(ClassFile.FSTORE, 2, Kind.STORE),\n@@ -216,1 +214,1 @@\n-    DSTORE(ClassFile.DSTORE, 2, Kind.STORE, TypeKind.DoubleType, -1),\n+    DSTORE(ClassFile.DSTORE, 2, Kind.STORE),\n@@ -219,1 +217,1 @@\n-    ASTORE(ClassFile.ASTORE, 2, Kind.STORE, TypeKind.ReferenceType, -1),\n+    ASTORE(ClassFile.ASTORE, 2, Kind.STORE),\n@@ -222,1 +220,1 @@\n-    ISTORE_0(ClassFile.ISTORE_0, 1, Kind.STORE, TypeKind.IntType, 0),\n+    ISTORE_0(ClassFile.ISTORE_0, 1, Kind.STORE),\n@@ -225,1 +223,1 @@\n-    ISTORE_1(ClassFile.ISTORE_1, 1, Kind.STORE, TypeKind.IntType, 1),\n+    ISTORE_1(ClassFile.ISTORE_1, 1, Kind.STORE),\n@@ -228,1 +226,1 @@\n-    ISTORE_2(ClassFile.ISTORE_2, 1, Kind.STORE, TypeKind.IntType, 2),\n+    ISTORE_2(ClassFile.ISTORE_2, 1, Kind.STORE),\n@@ -231,1 +229,1 @@\n-    ISTORE_3(ClassFile.ISTORE_3, 1, Kind.STORE, TypeKind.IntType, 3),\n+    ISTORE_3(ClassFile.ISTORE_3, 1, Kind.STORE),\n@@ -234,1 +232,1 @@\n-    LSTORE_0(ClassFile.LSTORE_0, 1, Kind.STORE, TypeKind.LongType, 0),\n+    LSTORE_0(ClassFile.LSTORE_0, 1, Kind.STORE),\n@@ -237,1 +235,1 @@\n-    LSTORE_1(ClassFile.LSTORE_1, 1, Kind.STORE, TypeKind.LongType, 1),\n+    LSTORE_1(ClassFile.LSTORE_1, 1, Kind.STORE),\n@@ -240,1 +238,1 @@\n-    LSTORE_2(ClassFile.LSTORE_2, 1, Kind.STORE, TypeKind.LongType, 2),\n+    LSTORE_2(ClassFile.LSTORE_2, 1, Kind.STORE),\n@@ -243,1 +241,1 @@\n-    LSTORE_3(ClassFile.LSTORE_3, 1, Kind.STORE, TypeKind.LongType, 3),\n+    LSTORE_3(ClassFile.LSTORE_3, 1, Kind.STORE),\n@@ -246,1 +244,1 @@\n-    FSTORE_0(ClassFile.FSTORE_0, 1, Kind.STORE, TypeKind.FloatType, 0),\n+    FSTORE_0(ClassFile.FSTORE_0, 1, Kind.STORE),\n@@ -249,1 +247,1 @@\n-    FSTORE_1(ClassFile.FSTORE_1, 1, Kind.STORE, TypeKind.FloatType, 1),\n+    FSTORE_1(ClassFile.FSTORE_1, 1, Kind.STORE),\n@@ -252,1 +250,1 @@\n-    FSTORE_2(ClassFile.FSTORE_2, 1, Kind.STORE, TypeKind.FloatType, 2),\n+    FSTORE_2(ClassFile.FSTORE_2, 1, Kind.STORE),\n@@ -255,1 +253,1 @@\n-    FSTORE_3(ClassFile.FSTORE_3, 1, Kind.STORE, TypeKind.FloatType, 3),\n+    FSTORE_3(ClassFile.FSTORE_3, 1, Kind.STORE),\n@@ -258,1 +256,1 @@\n-    DSTORE_0(ClassFile.DSTORE_0, 1, Kind.STORE, TypeKind.DoubleType, 0),\n+    DSTORE_0(ClassFile.DSTORE_0, 1, Kind.STORE),\n@@ -261,1 +259,1 @@\n-    DSTORE_1(ClassFile.DSTORE_1, 1, Kind.STORE, TypeKind.DoubleType, 1),\n+    DSTORE_1(ClassFile.DSTORE_1, 1, Kind.STORE),\n@@ -264,1 +262,1 @@\n-    DSTORE_2(ClassFile.DSTORE_2, 1, Kind.STORE, TypeKind.DoubleType, 2),\n+    DSTORE_2(ClassFile.DSTORE_2, 1, Kind.STORE),\n@@ -267,1 +265,1 @@\n-    DSTORE_3(ClassFile.DSTORE_3, 1, Kind.STORE, TypeKind.DoubleType, 3),\n+    DSTORE_3(ClassFile.DSTORE_3, 1, Kind.STORE),\n@@ -270,1 +268,1 @@\n-    ASTORE_0(ClassFile.ASTORE_0, 1, Kind.STORE, TypeKind.ReferenceType, 0),\n+    ASTORE_0(ClassFile.ASTORE_0, 1, Kind.STORE),\n@@ -273,1 +271,1 @@\n-    ASTORE_1(ClassFile.ASTORE_1, 1, Kind.STORE, TypeKind.ReferenceType, 1),\n+    ASTORE_1(ClassFile.ASTORE_1, 1, Kind.STORE),\n@@ -276,1 +274,1 @@\n-    ASTORE_2(ClassFile.ASTORE_2, 1, Kind.STORE, TypeKind.ReferenceType, 2),\n+    ASTORE_2(ClassFile.ASTORE_2, 1, Kind.STORE),\n@@ -279,1 +277,1 @@\n-    ASTORE_3(ClassFile.ASTORE_3, 1, Kind.STORE, TypeKind.ReferenceType, 3),\n+    ASTORE_3(ClassFile.ASTORE_3, 1, Kind.STORE),\n@@ -282,1 +280,1 @@\n-    IASTORE(ClassFile.IASTORE, 1, Kind.ARRAY_STORE, TypeKind.IntType),\n+    IASTORE(ClassFile.IASTORE, 1, Kind.ARRAY_STORE),\n@@ -285,1 +283,1 @@\n-    LASTORE(ClassFile.LASTORE, 1, Kind.ARRAY_STORE, TypeKind.LongType),\n+    LASTORE(ClassFile.LASTORE, 1, Kind.ARRAY_STORE),\n@@ -288,1 +286,1 @@\n-    FASTORE(ClassFile.FASTORE, 1, Kind.ARRAY_STORE, TypeKind.FloatType),\n+    FASTORE(ClassFile.FASTORE, 1, Kind.ARRAY_STORE),\n@@ -291,1 +289,1 @@\n-    DASTORE(ClassFile.DASTORE, 1, Kind.ARRAY_STORE, TypeKind.DoubleType),\n+    DASTORE(ClassFile.DASTORE, 1, Kind.ARRAY_STORE),\n@@ -294,1 +292,1 @@\n-    AASTORE(ClassFile.AASTORE, 1, Kind.ARRAY_STORE, TypeKind.ReferenceType),\n+    AASTORE(ClassFile.AASTORE, 1, Kind.ARRAY_STORE),\n@@ -297,1 +295,1 @@\n-    BASTORE(ClassFile.BASTORE, 1, Kind.ARRAY_STORE, TypeKind.ByteType),\n+    BASTORE(ClassFile.BASTORE, 1, Kind.ARRAY_STORE),\n@@ -300,1 +298,1 @@\n-    CASTORE(ClassFile.CASTORE, 1, Kind.ARRAY_STORE, TypeKind.CharType),\n+    CASTORE(ClassFile.CASTORE, 1, Kind.ARRAY_STORE),\n@@ -303,1 +301,1 @@\n-    SASTORE(ClassFile.SASTORE, 1, Kind.ARRAY_STORE, TypeKind.ShortType),\n+    SASTORE(ClassFile.SASTORE, 1, Kind.ARRAY_STORE),\n@@ -333,1 +331,1 @@\n-    IADD(ClassFile.IADD, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IADD(ClassFile.IADD, 1, Kind.OPERATOR),\n@@ -336,1 +334,1 @@\n-    LADD(ClassFile.LADD, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LADD(ClassFile.LADD, 1, Kind.OPERATOR),\n@@ -339,1 +337,1 @@\n-    FADD(ClassFile.FADD, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FADD(ClassFile.FADD, 1, Kind.OPERATOR),\n@@ -342,1 +340,1 @@\n-    DADD(ClassFile.DADD, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DADD(ClassFile.DADD, 1, Kind.OPERATOR),\n@@ -345,1 +343,1 @@\n-    ISUB(ClassFile.ISUB, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISUB(ClassFile.ISUB, 1, Kind.OPERATOR),\n@@ -348,1 +346,1 @@\n-    LSUB(ClassFile.LSUB, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSUB(ClassFile.LSUB, 1, Kind.OPERATOR),\n@@ -351,1 +349,1 @@\n-    FSUB(ClassFile.FSUB, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FSUB(ClassFile.FSUB, 1, Kind.OPERATOR),\n@@ -354,1 +352,1 @@\n-    DSUB(ClassFile.DSUB, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DSUB(ClassFile.DSUB, 1, Kind.OPERATOR),\n@@ -357,1 +355,1 @@\n-    IMUL(ClassFile.IMUL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IMUL(ClassFile.IMUL, 1, Kind.OPERATOR),\n@@ -360,1 +358,1 @@\n-    LMUL(ClassFile.LMUL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LMUL(ClassFile.LMUL, 1, Kind.OPERATOR),\n@@ -363,1 +361,1 @@\n-    FMUL(ClassFile.FMUL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FMUL(ClassFile.FMUL, 1, Kind.OPERATOR),\n@@ -366,1 +364,1 @@\n-    DMUL(ClassFile.DMUL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DMUL(ClassFile.DMUL, 1, Kind.OPERATOR),\n@@ -369,1 +367,1 @@\n-    IDIV(ClassFile.IDIV, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IDIV(ClassFile.IDIV, 1, Kind.OPERATOR),\n@@ -372,1 +370,1 @@\n-    LDIV(ClassFile.LDIV, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LDIV(ClassFile.LDIV, 1, Kind.OPERATOR),\n@@ -375,1 +373,1 @@\n-    FDIV(ClassFile.FDIV, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FDIV(ClassFile.FDIV, 1, Kind.OPERATOR),\n@@ -378,1 +376,1 @@\n-    DDIV(ClassFile.DDIV, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DDIV(ClassFile.DDIV, 1, Kind.OPERATOR),\n@@ -381,1 +379,1 @@\n-    IREM(ClassFile.IREM, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IREM(ClassFile.IREM, 1, Kind.OPERATOR),\n@@ -384,1 +382,1 @@\n-    LREM(ClassFile.LREM, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LREM(ClassFile.LREM, 1, Kind.OPERATOR),\n@@ -387,1 +385,1 @@\n-    FREM(ClassFile.FREM, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FREM(ClassFile.FREM, 1, Kind.OPERATOR),\n@@ -390,1 +388,1 @@\n-    DREM(ClassFile.DREM, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DREM(ClassFile.DREM, 1, Kind.OPERATOR),\n@@ -393,1 +391,1 @@\n-    INEG(ClassFile.INEG, 1, Kind.OPERATOR, TypeKind.IntType),\n+    INEG(ClassFile.INEG, 1, Kind.OPERATOR),\n@@ -396,1 +394,1 @@\n-    LNEG(ClassFile.LNEG, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LNEG(ClassFile.LNEG, 1, Kind.OPERATOR),\n@@ -399,1 +397,1 @@\n-    FNEG(ClassFile.FNEG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FNEG(ClassFile.FNEG, 1, Kind.OPERATOR),\n@@ -402,1 +400,1 @@\n-    DNEG(ClassFile.DNEG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DNEG(ClassFile.DNEG, 1, Kind.OPERATOR),\n@@ -405,1 +403,1 @@\n-    ISHL(ClassFile.ISHL, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISHL(ClassFile.ISHL, 1, Kind.OPERATOR),\n@@ -408,1 +406,1 @@\n-    LSHL(ClassFile.LSHL, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSHL(ClassFile.LSHL, 1, Kind.OPERATOR),\n@@ -411,1 +409,1 @@\n-    ISHR(ClassFile.ISHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ISHR(ClassFile.ISHR, 1, Kind.OPERATOR),\n@@ -414,1 +412,1 @@\n-    LSHR(ClassFile.LSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LSHR(ClassFile.LSHR, 1, Kind.OPERATOR),\n@@ -417,1 +415,1 @@\n-    IUSHR(ClassFile.IUSHR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IUSHR(ClassFile.IUSHR, 1, Kind.OPERATOR),\n@@ -420,1 +418,1 @@\n-    LUSHR(ClassFile.LUSHR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LUSHR(ClassFile.LUSHR, 1, Kind.OPERATOR),\n@@ -423,1 +421,1 @@\n-    IAND(ClassFile.IAND, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IAND(ClassFile.IAND, 1, Kind.OPERATOR),\n@@ -426,1 +424,1 @@\n-    LAND(ClassFile.LAND, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LAND(ClassFile.LAND, 1, Kind.OPERATOR),\n@@ -429,1 +427,1 @@\n-    IOR(ClassFile.IOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IOR(ClassFile.IOR, 1, Kind.OPERATOR),\n@@ -432,1 +430,1 @@\n-    LOR(ClassFile.LOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LOR(ClassFile.LOR, 1, Kind.OPERATOR),\n@@ -435,1 +433,1 @@\n-    IXOR(ClassFile.IXOR, 1, Kind.OPERATOR, TypeKind.IntType),\n+    IXOR(ClassFile.IXOR, 1, Kind.OPERATOR),\n@@ -438,1 +436,1 @@\n-    LXOR(ClassFile.LXOR, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LXOR(ClassFile.LXOR, 1, Kind.OPERATOR),\n@@ -441,1 +439,1 @@\n-    IINC(ClassFile.IINC, 3, Kind.INCREMENT, TypeKind.IntType, -1),\n+    IINC(ClassFile.IINC, 3, Kind.INCREMENT),\n@@ -444,1 +442,1 @@\n-    I2L(ClassFile.I2L, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.LongType),\n+    I2L(ClassFile.I2L, 1, Kind.CONVERT),\n@@ -447,1 +445,1 @@\n-    I2F(ClassFile.I2F, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.FloatType),\n+    I2F(ClassFile.I2F, 1, Kind.CONVERT),\n@@ -450,1 +448,1 @@\n-    I2D(ClassFile.I2D, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.DoubleType),\n+    I2D(ClassFile.I2D, 1, Kind.CONVERT),\n@@ -453,1 +451,1 @@\n-    L2I(ClassFile.L2I, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.IntType),\n+    L2I(ClassFile.L2I, 1, Kind.CONVERT),\n@@ -456,1 +454,1 @@\n-    L2F(ClassFile.L2F, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.FloatType),\n+    L2F(ClassFile.L2F, 1, Kind.CONVERT),\n@@ -459,1 +457,1 @@\n-    L2D(ClassFile.L2D, 1, Kind.CONVERT, TypeKind.LongType, TypeKind.DoubleType),\n+    L2D(ClassFile.L2D, 1, Kind.CONVERT),\n@@ -462,1 +460,1 @@\n-    F2I(ClassFile.F2I, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.IntType),\n+    F2I(ClassFile.F2I, 1, Kind.CONVERT),\n@@ -465,1 +463,1 @@\n-    F2L(ClassFile.F2L, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.LongType),\n+    F2L(ClassFile.F2L, 1, Kind.CONVERT),\n@@ -468,1 +466,1 @@\n-    F2D(ClassFile.F2D, 1, Kind.CONVERT, TypeKind.FloatType, TypeKind.DoubleType),\n+    F2D(ClassFile.F2D, 1, Kind.CONVERT),\n@@ -471,1 +469,1 @@\n-    D2I(ClassFile.D2I, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.IntType),\n+    D2I(ClassFile.D2I, 1, Kind.CONVERT),\n@@ -474,1 +472,1 @@\n-    D2L(ClassFile.D2L, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.LongType),\n+    D2L(ClassFile.D2L, 1, Kind.CONVERT),\n@@ -477,1 +475,1 @@\n-    D2F(ClassFile.D2F, 1, Kind.CONVERT, TypeKind.DoubleType, TypeKind.FloatType),\n+    D2F(ClassFile.D2F, 1, Kind.CONVERT),\n@@ -480,1 +478,1 @@\n-    I2B(ClassFile.I2B, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ByteType),\n+    I2B(ClassFile.I2B, 1, Kind.CONVERT),\n@@ -483,1 +481,1 @@\n-    I2C(ClassFile.I2C, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.CharType),\n+    I2C(ClassFile.I2C, 1, Kind.CONVERT),\n@@ -486,1 +484,1 @@\n-    I2S(ClassFile.I2S, 1, Kind.CONVERT, TypeKind.IntType, TypeKind.ShortType),\n+    I2S(ClassFile.I2S, 1, Kind.CONVERT),\n@@ -489,1 +487,1 @@\n-    LCMP(ClassFile.LCMP, 1, Kind.OPERATOR, TypeKind.LongType),\n+    LCMP(ClassFile.LCMP, 1, Kind.OPERATOR),\n@@ -492,1 +490,1 @@\n-    FCMPL(ClassFile.FCMPL, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FCMPL(ClassFile.FCMPL, 1, Kind.OPERATOR),\n@@ -495,1 +493,1 @@\n-    FCMPG(ClassFile.FCMPG, 1, Kind.OPERATOR, TypeKind.FloatType),\n+    FCMPG(ClassFile.FCMPG, 1, Kind.OPERATOR),\n@@ -498,1 +496,1 @@\n-    DCMPL(ClassFile.DCMPL, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DCMPL(ClassFile.DCMPL, 1, Kind.OPERATOR),\n@@ -501,1 +499,1 @@\n-    DCMPG(ClassFile.DCMPG, 1, Kind.OPERATOR, TypeKind.DoubleType),\n+    DCMPG(ClassFile.DCMPG, 1, Kind.OPERATOR),\n@@ -504,1 +502,1 @@\n-    IFEQ(ClassFile.IFEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFEQ(ClassFile.IFEQ, 3, Kind.BRANCH),\n@@ -507,1 +505,1 @@\n-    IFNE(ClassFile.IFNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFNE(ClassFile.IFNE, 3, Kind.BRANCH),\n@@ -510,1 +508,1 @@\n-    IFLT(ClassFile.IFLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLT(ClassFile.IFLT, 3, Kind.BRANCH),\n@@ -513,1 +511,1 @@\n-    IFGE(ClassFile.IFGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGE(ClassFile.IFGE, 3, Kind.BRANCH),\n@@ -516,1 +514,1 @@\n-    IFGT(ClassFile.IFGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFGT(ClassFile.IFGT, 3, Kind.BRANCH),\n@@ -519,1 +517,1 @@\n-    IFLE(ClassFile.IFLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IFLE(ClassFile.IFLE, 3, Kind.BRANCH),\n@@ -522,1 +520,1 @@\n-    IF_ICMPEQ(ClassFile.IF_ICMPEQ, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPEQ(ClassFile.IF_ICMPEQ, 3, Kind.BRANCH),\n@@ -525,1 +523,1 @@\n-    IF_ICMPNE(ClassFile.IF_ICMPNE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPNE(ClassFile.IF_ICMPNE, 3, Kind.BRANCH),\n@@ -528,1 +526,1 @@\n-    IF_ICMPLT(ClassFile.IF_ICMPLT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLT(ClassFile.IF_ICMPLT, 3, Kind.BRANCH),\n@@ -531,1 +529,1 @@\n-    IF_ICMPGE(ClassFile.IF_ICMPGE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGE(ClassFile.IF_ICMPGE, 3, Kind.BRANCH),\n@@ -534,1 +532,1 @@\n-    IF_ICMPGT(ClassFile.IF_ICMPGT, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPGT(ClassFile.IF_ICMPGT, 3, Kind.BRANCH),\n@@ -537,1 +535,1 @@\n-    IF_ICMPLE(ClassFile.IF_ICMPLE, 3, Kind.BRANCH, TypeKind.IntType),\n+    IF_ICMPLE(ClassFile.IF_ICMPLE, 3, Kind.BRANCH),\n@@ -540,1 +538,1 @@\n-    IF_ACMPEQ(ClassFile.IF_ACMPEQ, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IF_ACMPEQ(ClassFile.IF_ACMPEQ, 3, Kind.BRANCH),\n@@ -543,1 +541,1 @@\n-    IF_ACMPNE(ClassFile.IF_ACMPNE, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IF_ACMPNE(ClassFile.IF_ACMPNE, 3, Kind.BRANCH),\n@@ -546,1 +544,1 @@\n-    GOTO(ClassFile.GOTO, 3, Kind.BRANCH, TypeKind.VoidType),\n+    GOTO(ClassFile.GOTO, 3, Kind.BRANCH),\n@@ -567,1 +565,1 @@\n-    IRETURN(ClassFile.IRETURN, 1, Kind.RETURN, TypeKind.IntType),\n+    IRETURN(ClassFile.IRETURN, 1, Kind.RETURN),\n@@ -570,1 +568,1 @@\n-    LRETURN(ClassFile.LRETURN, 1, Kind.RETURN, TypeKind.LongType),\n+    LRETURN(ClassFile.LRETURN, 1, Kind.RETURN),\n@@ -573,1 +571,1 @@\n-    FRETURN(ClassFile.FRETURN, 1, Kind.RETURN, TypeKind.FloatType),\n+    FRETURN(ClassFile.FRETURN, 1, Kind.RETURN),\n@@ -576,1 +574,1 @@\n-    DRETURN(ClassFile.DRETURN, 1, Kind.RETURN, TypeKind.DoubleType),\n+    DRETURN(ClassFile.DRETURN, 1, Kind.RETURN),\n@@ -579,1 +577,1 @@\n-    ARETURN(ClassFile.ARETURN, 1, Kind.RETURN, TypeKind.ReferenceType),\n+    ARETURN(ClassFile.ARETURN, 1, Kind.RETURN),\n@@ -582,1 +580,1 @@\n-    RETURN(ClassFile.RETURN, 1, Kind.RETURN, TypeKind.VoidType),\n+    RETURN(ClassFile.RETURN, 1, Kind.RETURN),\n@@ -624,1 +622,1 @@\n-    ARRAYLENGTH(ClassFile.ARRAYLENGTH, 1, Kind.OPERATOR, TypeKind.IntType),\n+    ARRAYLENGTH(ClassFile.ARRAYLENGTH, 1, Kind.OPERATOR),\n@@ -645,1 +643,1 @@\n-    IFNULL(ClassFile.IFNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IFNULL(ClassFile.IFNULL, 3, Kind.BRANCH),\n@@ -648,1 +646,1 @@\n-    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH, TypeKind.ReferenceType),\n+    IFNONNULL(ClassFile.IFNONNULL, 3, Kind.BRANCH),\n@@ -651,1 +649,1 @@\n-    GOTO_W(ClassFile.GOTO_W, 5, Kind.BRANCH, TypeKind.VoidType),\n+    GOTO_W(ClassFile.GOTO_W, 5, Kind.BRANCH),\n@@ -660,1 +658,1 @@\n-    ILOAD_W((ClassFile.WIDE << 8) | ClassFile.ILOAD, 4, Kind.LOAD, TypeKind.IntType, -1),\n+    ILOAD_W((ClassFile.WIDE << 8) | ClassFile.ILOAD, 4, Kind.LOAD),\n@@ -663,1 +661,1 @@\n-    LLOAD_W((ClassFile.WIDE << 8) | ClassFile.LLOAD, 4, Kind.LOAD, TypeKind.LongType, -1),\n+    LLOAD_W((ClassFile.WIDE << 8) | ClassFile.LLOAD, 4, Kind.LOAD),\n@@ -666,1 +664,1 @@\n-    FLOAD_W((ClassFile.WIDE << 8) | ClassFile.FLOAD, 4, Kind.LOAD, TypeKind.FloatType, -1),\n+    FLOAD_W((ClassFile.WIDE << 8) | ClassFile.FLOAD, 4, Kind.LOAD),\n@@ -669,1 +667,1 @@\n-    DLOAD_W((ClassFile.WIDE << 8) | ClassFile.DLOAD, 4, Kind.LOAD, TypeKind.DoubleType, -1),\n+    DLOAD_W((ClassFile.WIDE << 8) | ClassFile.DLOAD, 4, Kind.LOAD),\n@@ -672,1 +670,1 @@\n-    ALOAD_W((ClassFile.WIDE << 8) | ClassFile.ALOAD, 4, Kind.LOAD, TypeKind.ReferenceType, -1),\n+    ALOAD_W((ClassFile.WIDE << 8) | ClassFile.ALOAD, 4, Kind.LOAD),\n@@ -675,1 +673,1 @@\n-    ISTORE_W((ClassFile.WIDE << 8) | ClassFile.ISTORE, 4, Kind.STORE, TypeKind.IntType, -1),\n+    ISTORE_W((ClassFile.WIDE << 8) | ClassFile.ISTORE, 4, Kind.STORE),\n@@ -678,1 +676,1 @@\n-    LSTORE_W((ClassFile.WIDE << 8) | ClassFile.LSTORE, 4, Kind.STORE, TypeKind.LongType, -1),\n+    LSTORE_W((ClassFile.WIDE << 8) | ClassFile.LSTORE, 4, Kind.STORE),\n@@ -681,1 +679,1 @@\n-    FSTORE_W((ClassFile.WIDE << 8) | ClassFile.FSTORE, 4, Kind.STORE, TypeKind.FloatType, -1),\n+    FSTORE_W((ClassFile.WIDE << 8) | ClassFile.FSTORE, 4, Kind.STORE),\n@@ -684,1 +682,1 @@\n-    DSTORE_W((ClassFile.WIDE << 8) | ClassFile.DSTORE, 4, Kind.STORE, TypeKind.DoubleType, -1),\n+    DSTORE_W((ClassFile.WIDE << 8) | ClassFile.DSTORE, 4, Kind.STORE),\n@@ -687,1 +685,1 @@\n-    ASTORE_W((ClassFile.WIDE << 8) | ClassFile.ASTORE, 4, Kind.STORE, TypeKind.ReferenceType, -1),\n+    ASTORE_W((ClassFile.WIDE << 8) | ClassFile.ASTORE, 4, Kind.STORE),\n@@ -696,1 +694,1 @@\n-    IINC_W((ClassFile.WIDE << 8) | ClassFile.IINC, 6, Kind.INCREMENT, TypeKind.IntType, -1);\n+    IINC_W((ClassFile.WIDE << 8) | ClassFile.IINC, 6, Kind.INCREMENT);\n@@ -1081,4 +1079,0 @@\n-    private final TypeKind primaryTypeKind;\n-    private final TypeKind secondaryTypeKind;\n-    private final int slot;\n-    private final ConstantDesc constantValue;\n@@ -1087,26 +1081,0 @@\n-        this(bytecode, sizeIfFixed, kind, null, null, -1, null);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind) {\n-        this(bytecode, sizeIfFixed, kind, typeKind, null, -1, null);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind, int slot) {\n-        this(bytecode, sizeIfFixed, kind, typeKind, null, slot, null);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind typeKind, int slot, ConstantDesc constantValue) {\n-        this(bytecode, sizeIfFixed, kind, typeKind, null, slot, constantValue);\n-    }\n-\n-    Opcode(int bytecode, int sizeIfFixed, Kind kind, TypeKind primaryTypeKind, TypeKind secondaryTypeKind) {\n-        this(bytecode, sizeIfFixed, kind, primaryTypeKind, secondaryTypeKind, 0, null);\n-    }\n-\n-    Opcode(int bytecode,\n-           int sizeIfFixed,\n-           Kind kind,\n-           TypeKind primaryTypeKind,\n-           TypeKind secondaryTypeKind,\n-           int slot,\n-           ConstantDesc constantValue) {\n@@ -1116,4 +1084,0 @@\n-        this.primaryTypeKind = primaryTypeKind;\n-        this.secondaryTypeKind = secondaryTypeKind;\n-        this.slot = slot;\n-        this.constantValue = constantValue;\n@@ -1123,1 +1087,3 @@\n-     * {@return bytecode}\n+     * {@return the opcode value} For {@linkplain #isWide() wide} pseudo-opcodes, returns the\n+     * first 2 bytes of the instruction, which are the {@code wide} opcode and the functional\n+     * local variable opcode, as a U2 value.\n@@ -1128,1 +1094,14 @@\n-     * {@return true if the instruction has extended local variable index by additional bytes}\n+     * {@return true if this is a pseudo-opcode modified by {@code wide}}\n+     *\n+     * @see #ILOAD_W\n+     * @see #LLOAD_W\n+     * @see #FLOAD_W\n+     * @see #DLOAD_W\n+     * @see #ALOAD_W\n+     * @see #ISTORE_W\n+     * @see #LSTORE_W\n+     * @see #FSTORE_W\n+     * @see #DSTORE_W\n+     * @see #ASTORE_W\n+     * @see #RET_W\n+     * @see #IINC_W\n@@ -1133,1 +1112,2 @@\n-     * {@return size of the instruction if fixed, or -1 otherwise}\n+     * {@return size of the instruction in bytes if fixed, or -1 otherwise} This size includes\n+     * the opcode itself.\n@@ -1141,38 +1121,0 @@\n-\n-    \/**\n-     * {@return primary type kind for instructions operating with at least one type, or null otherwise}\n-     *\/\n-    public TypeKind primaryTypeKind() {\n-        return primaryTypeKind;\n-    }\n-\n-    \/**\n-     * {@return secondary type kind for instructions operating with two types, or null otherwise}\n-     *\/\n-    public TypeKind secondaryTypeKind() {\n-        return secondaryTypeKind;\n-    }\n-\n-    \/**\n-     * {@return local variable slot for instructions operating with local variable, or -1 otherwise}\n-     *\/\n-    public int slot() {\n-        return slot;\n-    }\n-\n-    \/**\n-     * {@return constant value for constant instructions, or null otherwise}\n-     *\/\n-    public ConstantDesc constantValue() {\n-        return constantValue;\n-    }\n-\n-    \/**\n-     * {@return true if the instruction represents an unconditional branch}\n-     *\/\n-    public boolean isUnconditionalBranch() {\n-        return switch (this) {\n-            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n-            default -> kind() == Kind.RETURN;\n-        };\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Opcode.java","additions":197,"deletions":255,"binary":false,"changes":452,"status":"modified"},{"patch":"@@ -37,1 +37,1 @@\n- * Models generic Java type signatures, as defined in {@jvms 4.7.9.1}.\n+ * Models generic Java type signatures, as defined in JVMS {@jvms 4.7.9.1}.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/Signature.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.lang.constant.ClassDesc;\n@@ -33,1 +32,0 @@\n-import java.lang.classfile.constantpool.Utf8Entry;\n@@ -59,1 +57,0 @@\n-import jdk.internal.classfile.impl.TemporaryConstantPool;\n@@ -63,1 +60,11 @@\n- * Models an annotation on a type use, as defined in {@jvms 4.7.19} and {@jvms 4.7.20}.\n+ * Models a {@code type_annotation} structure (JVMS {@jvms 4.7.20}). This model\n+ * indicates the annotated type within a declaration or expression and the part\n+ * of the indicated type that is annotated, in addition to what is {@linkplain\n+ * #annotation() available} in an {@code Annotation}.\n+ * <p>\n+ * This model can reconstruct an annotation on a type or a part of a type, given\n+ * the location of the {@code type_annotation} structure in the class file and\n+ * the definition of the annotation interface.\n+ * <p>\n+ * Two {@code TypeAnnotation} objects should be compared using the {@link\n+ * Object#equals(Object) equals} method.\n@@ -65,0 +72,1 @@\n+ * @see Annotation\n@@ -72,1 +80,0 @@\n-        extends Annotation\n@@ -76,1 +83,1 @@\n-     * The kind of target on which the annotation appears, as defined in {@jvms 4.7.20.1}.\n+     * The kind of target on which the annotation appears, as defined in JVMS {@jvms 4.7.20.1}.\n@@ -173,1 +180,1 @@\n-     * is annotated}\n+     * is annotated} This models the {@code target_type} and {@code target_info} items.\n@@ -183,19 +190,4 @@\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             List<AnnotationElement> annotationElements) {\n-        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath,\n-                annotationClassUtf8Entry, annotationElements);\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n+     * {@return the annotation applied to the part indicated by {@link #targetPath()}}\n+     * This models the interface of the annotation and the set of element-value pairs,\n+     * the subset of the {@code type_annotation} structure that is identical to the\n+     * {@code annotation} structure.\n@@ -203,19 +195,1 @@\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClass, List.of(annotationElements));\n-    }\n-\n-    \/**\n-     * {@return a type annotation}\n-     * @param targetInfo which type in a declaration or expression is annotated\n-     * @param targetPath which part of the type is annotated\n-     * @param annotationClass the annotation class\n-     * @param annotationElements the annotation elements\n-     *\/\n-    static TypeAnnotation of(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                             ClassDesc annotationClass,\n-                             List<AnnotationElement> annotationElements) {\n-        return of(targetInfo, targetPath,\n-                TemporaryConstantPool.INSTANCE.utf8Entry(annotationClass.descriptorString()), annotationElements);\n-    }\n+    Annotation annotation();\n@@ -224,1 +198,1 @@\n-     * {@return a type annotation}\n+     * {@return a {@code type_annotation} structure}\n@@ -227,2 +201,1 @@\n-     * @param annotationClassUtf8Entry the annotation class\n-     * @param annotationElements the annotation elements\n+     * @param annotation the annotation\n@@ -231,3 +204,2 @@\n-                             Utf8Entry annotationClassUtf8Entry,\n-                             AnnotationElement... annotationElements) {\n-        return of(targetInfo, targetPath, annotationClassUtf8Entry, List.of(annotationElements));\n+                             Annotation annotation) {\n+        return new UnboundAttribute.UnboundTypeAnnotation(targetInfo, targetPath, annotation);\n@@ -776,1 +748,1 @@\n-     * as defined in {@jvms 4.7.20.2}\n+     * as defined in JVMS {@jvms 4.7.20.2}\n@@ -785,1 +757,1 @@\n-         * Type path kind, as defined in {@jvms 4.7.20.2}\n+         * Type path kind, as defined in JVMS {@jvms 4.7.20.2}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeAnnotation.java","additions":26,"deletions":54,"binary":false,"changes":80,"status":"modified"},{"patch":"@@ -28,0 +28,3 @@\n+import java.lang.classfile.instruction.DiscontinuedInstruction;\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n@@ -30,0 +33,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -32,1 +36,7 @@\n- * Describes the types that can be part of a field or method descriptor.\n+ * Describes the data types Java Virtual Machine operates on.\n+ * This omits {@code returnAddress} (JVMS {@jvms 2.3.3}),\n+ * which is only used by discontinued {@link\n+ * DiscontinuedInstruction.JsrInstruction jsr} and {@link\n+ * DiscontinuedInstruction.RetInstruction ret} instructions,\n+ * and includes {@link #VOID void} (JVMS {@jvms 4.3.3}), which\n+ * appears as a method return type.\n@@ -34,0 +44,12 @@\n+ * <h2 id=\"computational-type\">Computational Type<\/h2>\n+ * In the {@code class} file format, local variables (JVMS {@jvms 2.6.1}),\n+ * and the operand stack (JVMS {@jvms 2.6.2}) of the Java Virtual Machine,\n+ * {@link #BOOLEAN boolean}, {@link #BYTE byte}, {@link #CHAR char},\n+ * {@link #SHORT short} types do not exist and are {@linkplain\n+ * #asLoadable() represented} by the {@link #INT int} computational type.\n+ * {@link #INT int}, {@link #FLOAT float}, {@link #REFERENCE reference},\n+ * {@code returnAddress}, {@link #LONG long}, and {@link #DOUBLE doule}\n+ * are the computational types of the Java Virtual Machine.\n+ *\n+ * @jvms 2.2 Data Types\n+ * @jvms 2.11.1 Types and the Java Virtual Machine\n@@ -38,20 +60,67 @@\n-    \/** the primitive type byte *\/\n-    ByteType(\"byte\", \"B\", 8),\n-    \/** the primitive type short *\/\n-    ShortType(\"short\", \"S\", 9),\n-    \/** the primitive type int *\/\n-    IntType(\"int\", \"I\", 10),\n-    \/** the primitive type float *\/\n-    FloatType(\"float\", \"F\", 6),\n-    \/** the primitive type long *\/\n-    LongType(\"long\", \"J\", 11),\n-    \/** the primitive type double *\/\n-    DoubleType(\"double\", \"D\", 7),\n-    \/** a reference type *\/\n-    ReferenceType(\"reference type\", \"L\", -1),\n-    \/** the primitive type char *\/\n-    CharType(\"char\", \"C\", 5),\n-    \/** the primitive type boolean *\/\n-    BooleanType(\"boolean\", \"Z\", 4),\n-    \/** void *\/\n-    VoidType(\"void\", \"V\", -1);\n+    \/\/ Elements are grouped so frequently used switch ranges such as\n+    \/\/ primitives (boolean - double) and computational (int - void) are together.\n+    \/\/ This also follows the order of typed opcodes\n+    \/\/ Begin primitive types\n+    \/**\n+     * The primitive type {@code boolean}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. {@code 0} represents {@code false},\n+     * and {@code 1} represents {@code true}. It is zero-extended to an {@code int}\n+     * when loaded onto the operand stack and narrowed by taking the bitwise AND\n+     * with {@code 1} when stored.\n+     *\n+     * @jvms 2.3.4 The {@code boolean} Type\n+     *\/\n+    BOOLEAN(1, 4),\n+    \/**\n+     * The primitive type {@code byte}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is sign-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    BYTE(1, 8),\n+    \/**\n+     * The primitive type {@code char}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is zero-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    CHAR(1, 5),\n+    \/**\n+     * The primitive type {@code short}. Its {@linkplain ##computational-type\n+     * computational type} is {@link #INT int}. It is sign-extended to an\n+     * {@code int} when loaded onto the operand stack and truncated when\n+     * stored.\n+     *\/\n+    SHORT(1, 9),\n+    \/\/ Begin computational types\n+    \/**\n+     * The primitive type {@code int}.\n+     *\/\n+    INT(1, 10),\n+    \/**\n+     * The primitive type {@code long}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    LONG(2, 11),\n+    \/**\n+     * The primitive type {@code float}.\n+     *\/\n+    FLOAT(1, 6),\n+    \/**\n+     * The primitive type {@code double}. It is of {@linkplain #slotSize() category} 2.\n+     *\/\n+    DOUBLE(2, 7),\n+    \/\/ End primitive types\n+    \/**\n+     * A reference type.\n+     * @jvms 2.4 Reference Types and Values\n+     *\/\n+    REFERENCE(1, -1),\n+    \/**\n+     * The {@code void} type, for absence of a value. While this is not a data type,\n+     * this can be a method return type indicating no change in {@linkplain #slotSize()\n+     * operand stack depth}.\n+     *\n+     * @jvms 4.3.3 Method Descriptors\n+     *\/\n+    VOID(0, -1);\n+    \/\/ End computational types\n@@ -59,2 +128,2 @@\n-    private final String name;\n-    private final String descriptor;\n+    private @Stable ClassDesc upperBound;\n+    private final int slots;\n@@ -63,2 +132,4 @@\n-    \/** {@return the human-readable name corresponding to this type} *\/\n-    public String typeName() { return name; }\n+    TypeKind(int slots, int newarrayCode) {\n+        this.slots = slots;\n+        this.newarrayCode = newarrayCode;\n+    }\n@@ -66,2 +137,27 @@\n-    \/** {@return the field descriptor character corresponding to this type} *\/\n-    public String descriptor() { return descriptor; }\n+    \/**\n+     * {@return the most specific upper bound field descriptor that can store any value\n+     * of this type} This is the primitive class descriptor for primitive types and\n+     * {@link #VOID void} and {@link ConstantDescs#CD_Object Object} descriptor for\n+     * {@link #REFERENCE reference}.\n+     *\/\n+    public ClassDesc upperBound() {\n+        var upper = this.upperBound;\n+        if (upper == null)\n+            return this.upperBound = fetchUpperBound();\n+        return upper;\n+    }\n+\n+    private ClassDesc fetchUpperBound() {\n+        return switch (this) {\n+            case BOOLEAN -> ConstantDescs.CD_boolean;\n+            case BYTE -> ConstantDescs.CD_byte;\n+            case CHAR -> ConstantDescs.CD_char;\n+            case SHORT -> ConstantDescs.CD_short;\n+            case INT -> ConstantDescs.CD_int;\n+            case FLOAT -> ConstantDescs.CD_float;\n+            case LONG -> ConstantDescs.CD_long;\n+            case DOUBLE -> ConstantDescs.CD_double;\n+            case REFERENCE -> ConstantDescs.CD_Object;\n+            case VOID -> ConstantDescs.CD_void;\n+        };\n+    }\n@@ -70,1 +166,2 @@\n-     * {@return the code used by the {@code newarray} opcode corresponding to this type}\n+     * {@return the code used by the {@link Opcode#NEWARRAY newarray} instruction to create an array\n+     * of this component type, or {@code -1} if this type is not supported by {@code newarray}}\n@@ -72,0 +169,1 @@\n+     * @jvms 6.5.newarray <i>newarray<\/i>\n@@ -78,1 +176,6 @@\n-     * {@return the number of local variable slots consumed by this type}\n+     * {@return the number of local variable index or operand stack depth consumed by this type}\n+     * This is also the category of this type for instructions operating on the operand stack without\n+     * regard to type (JVMS {@jvms 2.11.1}), such as {@link Opcode#POP pop} versus {@link Opcode#POP2\n+     * pop2}.\n+     * @jvms 2.6.1 Local Variables\n+     * @jvms 2.6.2 Operand Stacks\n@@ -81,5 +184,1 @@\n-        return switch (this) {\n-            case VoidType -> 0;\n-            case LongType, DoubleType -> 2;\n-            default -> 1;\n-        };\n+        return this.slots;\n@@ -89,3 +188,2 @@\n-     * Erase this type kind to the type which will be used for xLOAD, xSTORE,\n-     * and xRETURN bytecodes\n-     * @return the erased type kind\n+     * {@return the {@linkplain ##computational-type computational type} for this type, or {@link #VOID void}\n+     * for {@code void}}\n@@ -94,10 +192,1 @@\n-        return switch (this) {\n-            case BooleanType, ByteType, CharType, ShortType -> TypeKind.IntType;\n-            default -> this;\n-        };\n-    }\n-\n-    TypeKind(String name, String descriptor, int newarrayCode) {\n-        this.name = name;\n-        this.descriptor = descriptor;\n-        this.newarrayCode = newarrayCode;\n+        return ordinal() < 4 ? INT : this;\n@@ -107,2 +196,2 @@\n-     * {@return the type kind associated with the array type described by the\n-     * array code used as an operand to {@code newarray}}\n+     * {@return the component type described by the array code used as an operand to {@link Opcode#NEWARRAY\n+     * newarray}}\n@@ -112,0 +201,1 @@\n+     * @jvms 6.5.newarray <i>newarray<\/i>\n@@ -115,8 +205,8 @@\n-            case 4 -> TypeKind.BooleanType;\n-            case 5 -> TypeKind.CharType;\n-            case 6 -> TypeKind.FloatType;\n-            case 7 -> TypeKind.DoubleType;\n-            case 8 -> TypeKind.ByteType;\n-            case 9 -> TypeKind.ShortType;\n-            case 10 -> TypeKind.IntType;\n-            case 11 -> TypeKind.LongType;\n+            case 4 -> BOOLEAN;\n+            case 5 -> CHAR;\n+            case 6 -> FLOAT;\n+            case 7 -> DOUBLE;\n+            case 8 -> BYTE;\n+            case 9 -> SHORT;\n+            case 10 -> INT;\n+            case 11 -> LONG;\n@@ -128,1 +218,1 @@\n-     * {@return the type kind associated with the specified field descriptor}\n+     * {@return the type associated with the specified field descriptor}\n@@ -137,10 +227,10 @@\n-            case '[', 'L' -> TypeKind.ReferenceType;\n-            case 'B' -> TypeKind.ByteType;\n-            case 'C' -> TypeKind.CharType;\n-            case 'Z' -> TypeKind.BooleanType;\n-            case 'S' -> TypeKind.ShortType;\n-            case 'I' -> TypeKind.IntType;\n-            case 'F' -> TypeKind.FloatType;\n-            case 'J' -> TypeKind.LongType;\n-            case 'D' -> TypeKind.DoubleType;\n-            case 'V' -> TypeKind.VoidType;\n+            case '[', 'L' -> REFERENCE;\n+            case 'B' -> BYTE;\n+            case 'C' -> CHAR;\n+            case 'Z' -> BOOLEAN;\n+            case 'S' -> SHORT;\n+            case 'I' -> INT;\n+            case 'F' -> FLOAT;\n+            case 'J' -> LONG;\n+            case 'D' -> DOUBLE;\n+            case 'V' -> VOID;\n@@ -152,1 +242,1 @@\n-     * {@return the type kind associated with the specified field descriptor}\n+     * {@return the type associated with the specified field descriptor}\n@@ -158,1 +248,1 @@\n-                : TypeKind.ReferenceType;\n+                : REFERENCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/TypeKind.java","additions":160,"deletions":70,"binary":false,"changes":230,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code AnnotationDefault} attribute {@jvms 4.7.22}, which can\n+ * Models the {@code AnnotationDefault} attribute (JVMS {@jvms 4.7.22}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/AnnotationDefaultAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code BootstrapMethods} attribute {@jvms 4.7.23}, which serves as\n+ * Models the {@code BootstrapMethods} attribute (JVMS {@jvms 4.7.23}), which serves as\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/BootstrapMethodsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n- * Models the {@code Code} attribute {@jvms 4.7.3}, appears on non-native,\n+ * Models the {@code Code} attribute (JVMS {@jvms 4.7.3}), appears on non-native,\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/CodeAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code ConstantValue} attribute {@jvms 4.7.2}, which can appear on\n+ * Models the {@code ConstantValue} attribute (JVMS {@jvms 4.7.2}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ConstantValueAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code Deprecated} attribute {@jvms 4.7.15}, which can appear on\n+ * Models the {@code Deprecated} attribute (JVMS {@jvms 4.7.15}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/DeprecatedAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * Models the {@code EnclosingMethod} attribute {@jvms 4.7.7}, which can appear\n+ * Models the {@code EnclosingMethod} attribute (JVMS {@jvms 4.7.7}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/EnclosingMethodAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code Exceptions} attribute {@jvms 4.7.5}, which can appear on\n+ * Models the {@code Exceptions} attribute (JVMS {@jvms 4.7.5}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ExceptionsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code InnerClasses} attribute {@jvms 4.7.6}, which can\n+ * Models the {@code InnerClasses} attribute (JVMS {@jvms 4.7.6}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/InnerClassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LineNumberTable} attribute {@jvms 4.7.12}, which can appear\n+ * Models the {@code LineNumberTable} attribute (JVMS {@jvms 4.7.12}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LineNumberTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,1 @@\n- * Models the {@code LocalVariableTable} attribute {@jvms 4.7.13}, which can appear\n+ * Models the {@code LocalVariableTable} attribute (JVMS {@jvms 4.7.13}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code LocalVariableTypeTable} attribute {@jvms 4.7.14}, which can appear\n+ * Models the {@code LocalVariableTypeTable} attribute (JVMS {@jvms 4.7.14}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/LocalVariableTypeTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code MethodParameters} attribute {@jvms 4.7.24}, which can\n+ * Models the {@code MethodParameters} attribute (JVMS {@jvms 4.7.24}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/MethodParametersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -49,1 +49,1 @@\n- * Models the {@code Module} attribute {@jvms 4.7.25}, which can\n+ * Models the {@code Module} attribute (JVMS {@jvms 4.7.25}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code ModuleMainClass} attribute {@jvms 4.7.27}, which can\n+ * Models the {@code ModuleMainClass} attribute (JVMS {@jvms 4.7.27}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModuleMainClassAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code ModulePackages} attribute {@jvms 4.7.26}, which can\n+ * Models the {@code ModulePackages} attribute (JVMS {@jvms 4.7.26}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/ModulePackagesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code NestHost} attribute {@jvms 4.7.28}, which can\n+ * Models the {@code NestHost} attribute (JVMS {@jvms 4.7.28}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestHostAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code NestMembers} attribute {@jvms 4.7.29}, which can\n+ * Models the {@code NestMembers} attribute (JVMS {@jvms 4.7.29}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/NestMembersAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * Models the {@code PermittedSubclasses} attribute {@jvms 4.7.31}, which can\n+ * Models the {@code PermittedSubclasses} attribute (JVMS {@jvms 4.7.31}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/PermittedSubclassesAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Record} attribute {@jvms 4.7.30}, which can\n+ * Models the {@code Record} attribute (JVMS {@jvms 4.7.30}), which can\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RecordAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeInvisibleAnnotations} attribute {@jvms 4.7.17}, which\n+ * Models the {@code RuntimeInvisibleAnnotations} attribute (JVMS {@jvms 4.7.17}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * {@jvms 4.7.19}, which can appear on methods. Delivered as a {@link\n+ * (JVMS {@jvms 4.7.19}), which can appear on methods. Delivered as a {@link\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeInvisibleTypeAnnotations} attribute {@jvms 4.7.21}, which\n+ * Models the {@code RuntimeInvisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.21}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeInvisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,1 @@\n- * Models the {@code RuntimeVisibleAnnotations} attribute {@jvms 4.7.16}, which\n+ * Models the {@code RuntimeVisibleAnnotations} attribute (JVMS {@jvms 4.7.16}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models the {@code RuntimeVisibleParameterAnnotations} attribute {@jvms 4.7.18}, which\n+ * Models the {@code RuntimeVisibleParameterAnnotations} attribute (JVMS {@jvms 4.7.18}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleParameterAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * Models the {@code RuntimeVisibleTypeAnnotations} attribute {@jvms 4.7.20}, which\n+ * Models the {@code RuntimeVisibleTypeAnnotations} attribute (JVMS {@jvms 4.7.20}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/RuntimeVisibleTypeAnnotationsAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * Models the {@code Signature} attribute {@jvms 4.7.9}, which\n+ * Models the {@code Signature} attribute (JVMS {@jvms 4.7.9}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SignatureAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -38,1 +38,1 @@\n- * Models the {@code SourceFile} attribute {@jvms 4.7.10}, which\n+ * Models the {@code SourceFile} attribute (JVMS {@jvms 4.7.10}), which\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SourceFileAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * Models stack map frame of {@code StackMapTable} attribute {@jvms 4.7.4}.\n+ * Models stack map frame of {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}).\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapFrameInfo.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code StackMapTable} attribute {@jvms 4.7.4}, which can appear\n+ * Models the {@code StackMapTable} attribute (JVMS {@jvms 4.7.4}), which can appear\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/StackMapTableAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * Models the {@code Synthetic} attribute {@jvms 4.7.8}, which can appear on\n+ * Models the {@code Synthetic} attribute (JVMS {@jvms 4.7.8}), which can appear on\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/attribute\/SyntheticAttribute.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -184,1 +184,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/components\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,1 @@\n+import java.lang.classfile.AnnotationValue;\n@@ -31,2 +32,4 @@\n- * A constant pool entry that may be used as an annotation constant,\n- * which includes the four kinds of primitive constants, and UTF8 constants.\n+ * A constant pool entry that may be used by annotation constant values,\n+ * which includes the four kinds of primitive constants and UTF8 constants.\n+ * These entries are also the only entries that do not refer to other\n+ * constant pool entries.\n@@ -34,0 +37,7 @@\n+ * @apiNote\n+ * An annotation constant value entry alone is not sufficient to determine\n+ * the annotation constant; for example, an {@link IntegerEntry} of {@code 1}\n+ * can mean {@code true} in {@link AnnotationValue.OfBoolean} or {@code 1}\n+ * in {@link AnnotationValue.OfInt}.\n+ *\n+ * @see AnnotationValue.OfConstant\n@@ -43,1 +53,2 @@\n-     * {@link Long}, {@link Float}, {@link Double}, or {@link String}.\n+     * {@link Long}, {@link Float}, {@link Double} for the primitive constants,\n+     * or {@link String} for UTF8 constants.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/AnnotationConstantValueEntry.java","additions":15,"deletions":4,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -368,1 +368,1 @@\n-     * @param refKind the reference kind of the method handle {@jvms 4.4.8}\n+     * @param refKind the reference kind of the method handle (JVMS {@jvms 4.4.8})\n@@ -511,19 +511,0 @@\n-    }\n-\n-    \/**\n-     * {@return An {@link AnnotationConstantValueEntry} describing the provided\n-     * constant}  The constant should be an Integer, String, Long, Float,\n-     * Double, ClassDesc (for a Class constant), or MethodTypeDesc (for a MethodType\n-     * constant.)\n-     *\n-     * @param c the constant\n-     *\/\n-    default AnnotationConstantValueEntry annotationConstantValueEntry(ConstantDesc c) {\n-        if (c instanceof Integer i) return intEntry(i);\n-        if (c instanceof String s) return utf8Entry(s);\n-        if (c instanceof Long l) return longEntry(l);\n-        if (c instanceof Float f) return floatEntry(f);\n-        if (c instanceof Double d) return doubleEntry(d);\n-        if (c instanceof ClassDesc cd) return utf8Entry(cd);\n-        if (c instanceof MethodTypeDesc mtd) return utf8Entry(mtd);\n-        throw new IllegalArgumentException(\"Illegal type: \" + (c == null ? null : c.getClass()));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/ConstantPoolBuilder.java","additions":1,"deletions":20,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.DoubleType;\n+        return TypeKind.DOUBLE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/DoubleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n-        return TypeKind.FloatType;\n+        return TypeKind.FLOAT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/FloatEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.IntType;\n+        return TypeKind.INT;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/IntegerEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-        return TypeKind.ReferenceType;\n+        return TypeKind.REFERENCE;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LoadableConstantEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n-        return TypeKind.LongType;\n+        return TypeKind.LONG;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/LongEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n-     * {@return the reference kind of this method handle {@jvms 4.4.8}}\n+     * {@return the reference kind of this method handle (JVMS {@jvms 4.4.8})}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/constantpool\/MethodHandleEntry.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type load instruction {@link Opcode#BALOAD baload} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayLoadInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,3 @@\n-     * {@return the component type of the array}\n+     * {@return the component type of the array} The {@link TypeKind#BYTE byte}\n+     * type store instruction {@link Opcode#BASTORE bastore} also operates on\n+     * {@link TypeKind#BOOLEAN boolean} arrays.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ArrayStoreInstruction.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,0 +36,1 @@\n+import jdk.internal.classfile.impl.BytecodeHelpers;\n@@ -77,1 +78,1 @@\n-            return opcode().primaryTypeKind();\n+            return BytecodeHelpers.intrinsicConstantType(opcode());\n@@ -100,1 +101,1 @@\n-            return opcode().primaryTypeKind();\n+            return TypeKind.INT;\n@@ -139,1 +140,1 @@\n-        if (op.constantValue() == null)\n+        if (op.sizeIfFixed() != 1)\n@@ -147,2 +148,2 @@\n-     * @param op the opcode for the specific type of intrinsic constant instruction,\n-     *           which must be of kind {@link Opcode.Kind#CONSTANT}\n+     * @param op the opcode for the specific type of argument constant instruction,\n+     *           which must be {@link Opcode#BIPUSH} or {@link Opcode#SIPUSH}\n@@ -151,1 +152,2 @@\n-     *                                  or {@link Opcode#SIPUSH}\n+     *         or {@link Opcode#SIPUSH}, or if the constant value is out of range\n+     *         for the opcode\n@@ -154,2 +156,5 @@\n-        Util.checkKind(op, Opcode.Kind.CONSTANT);\n-        if (op != Opcode.BIPUSH && op != Opcode.SIPUSH)\n+        if (op == Opcode.BIPUSH) {\n+            BytecodeHelpers.validateBipush(value);\n+        } else if (op == Opcode.SIPUSH) {\n+            BytecodeHelpers.validateSipush(value);\n+        } else {\n@@ -157,0 +162,1 @@\n+        }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/ConstantInstruction.java","additions":15,"deletions":9,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n-     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in {@jvms 6.5}\n+     * {@return the {@code count} value of an {@code invokeinterface} instruction, as defined in JVMS {@jvms 6.5}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/InvokeInstruction.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -60,1 +60,1 @@\n-            throw new IllegalArgumentException(\"Illegal component type: \" + typeKind.typeName());\n+            throw new IllegalArgumentException(\"Illegal component type for primitive array: \" + typeKind.name());\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/instruction\/NewPrimitiveArrayInstruction.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,2 +29,2 @@\n- * modifying Java class files, as specified in Chapter {@jvms 4} of the <cite>Java\n- * Java Virtual Machine Specification<\/cite>.\n+ * modifying Java class files, as specified in Chapter {@jvms 4} of the\n+ * <cite>Java Virtual Machine Specification<\/cite>.\n@@ -150,1 +150,1 @@\n- * java.lang.Object)} method for mapping back to the classfile format.  It also\n+ * java.lang.classfile.Attribute)} method for mapping back to the classfile format.  It also\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -384,1 +384,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"src\/java.base\/share\/classes\/java\/lang\/classfile\/snippet-files\/PackageSnippets.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -39,0 +39,1 @@\n+import static jdk.internal.constant.ConstantUtils.forPrimitiveType;\n@@ -167,1 +168,1 @@\n-               ? Wrapper.forPrimitiveType(descriptor.charAt(0)).basicClassDescriptor()\n+               ? forPrimitiveType(descriptor, 0)\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ClassDesc.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -243,1 +243,1 @@\n-    public static final ClassDesc CD_int = new PrimitiveClassDescImpl(\"I\");\n+    public static final ClassDesc CD_int = PrimitiveClassDescImpl.CD_int;\n@@ -246,1 +246,1 @@\n-    public static final ClassDesc CD_long = new PrimitiveClassDescImpl(\"J\");\n+    public static final ClassDesc CD_long = PrimitiveClassDescImpl.CD_long;\n@@ -249,1 +249,1 @@\n-    public static final ClassDesc CD_float = new PrimitiveClassDescImpl(\"F\");\n+    public static final ClassDesc CD_float = PrimitiveClassDescImpl.CD_float;\n@@ -252,1 +252,1 @@\n-    public static final ClassDesc CD_double = new PrimitiveClassDescImpl(\"D\");\n+    public static final ClassDesc CD_double = PrimitiveClassDescImpl.CD_double;\n@@ -255,1 +255,1 @@\n-    public static final ClassDesc CD_short = new PrimitiveClassDescImpl(\"S\");\n+    public static final ClassDesc CD_short = PrimitiveClassDescImpl.CD_short;\n@@ -258,1 +258,1 @@\n-    public static final ClassDesc CD_byte = new PrimitiveClassDescImpl(\"B\");\n+    public static final ClassDesc CD_byte = PrimitiveClassDescImpl.CD_byte;\n@@ -261,1 +261,1 @@\n-    public static final ClassDesc CD_char = new PrimitiveClassDescImpl(\"C\");\n+    public static final ClassDesc CD_char = PrimitiveClassDescImpl.CD_char;\n@@ -264,1 +264,1 @@\n-    public static final ClassDesc CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+    public static final ClassDesc CD_boolean = PrimitiveClassDescImpl.CD_boolean;\n@@ -267,1 +267,1 @@\n-    public static final ClassDesc CD_void = new PrimitiveClassDescImpl(\"V\");\n+    public static final ClassDesc CD_void = PrimitiveClassDescImpl.CD_void;\n","filename":"src\/java.base\/share\/classes\/java\/lang\/constant\/ConstantDescs.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -111,1 +111,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/AddressLayout.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -616,1 +616,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -687,1 +687,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -736,1 +736,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/Linker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -577,1 +577,3 @@\n-     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}.\n+     * Otherwise, the returned method handle throws {@link IndexOutOfBoundsException}. Moreover,\n+     * the value of {@code b} must be such that the computation for {@code offset} does not overflow,\n+     * or the returned method handle throws {@link ArithmeticException}.\n@@ -667,3 +669,4 @@\n-     * {@code P} and {@code P'} are derived, where P contains all the path elements from\n-     * 0 to {@code k - 1} and {@code P'} contains all the path elements from {@code k + 1}\n-     * to {@code m} (if any). Then, the returned var handle is computed as follows:\n+     * {@code P} and {@code Q} are derived, where P contains all the path elements from\n+     * 0 to {@code k - 1} and {@code Q} contains all the path elements from {@code k + 1}\n+     * to {@code m} ({@code Q} could be an empty layout path if {@code k == m}).\n+     * Then, the returned var handle is computed as follows:\n@@ -674,1 +677,1 @@\n-     * VarHandle targetHandle = target.varHandle(P);\n+     * VarHandle targetHandle = target.varHandle(Q);\n@@ -947,1 +950,1 @@\n-         *    <li>if {@code F < 0}, then {@code B = ceilDiv(-(S + 1), -F)}<\/li>\n+         *    <li>if {@code F < 0}, then {@code B = ceilDiv(S + 1, -F)}<\/li>\n@@ -975,2 +978,2 @@\n-         * {@return a path element that dereferences an address layout as its\n-         * {@linkplain AddressLayout#targetLayout() target layout} (where set)}\n+         * {@return a path element that selects the {@linkplain AddressLayout#targetLayout() target layout} of\n+         * an address layout (where set)}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemoryLayout.java","additions":11,"deletions":8,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -478,1 +478,1 @@\n- *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 4, scope = arena.scope()\n+ *       ptr = z.reinterpret(16, arena, null);                       \/\/ size = 16, scope = arena.scope()\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/MemorySegment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -288,1 +288,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -295,1 +295,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n@@ -322,1 +322,1 @@\n-     * @throws IllegalCallerException If the caller is in a module that does not have\n+     * @throws IllegalCallerException if the caller is in a module that does not have\n@@ -329,1 +329,1 @@\n-                SymbolLookup.class, \"libraryLookup\");\n+                SymbolLookup.class, \"libraryLookup\", false);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/SymbolLookup.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -168,4 +168,5 @@\n- * the special value {@code ALL-UNNAMED} can be used). If this option is specified,\n- * access to restricted methods are only granted to the modules listed by that option.\n- * If this option is not specified, access to restricted methods is enabled for all\n- * modules, but access to restricted methods will result in runtime warnings.\n+ * the special value {@code ALL-UNNAMED} can be used). Access to restricted methods\n+ * from modules not listed by that option is deemed <em>illegal<\/em>. Clients can\n+ * control how access to restricted methods is handled, using the command line\n+ * option {@code --illegal-native-access}. If this option is not specified,\n+ * illegal access to restricted methods will result in runtime warnings.\n","filename":"src\/java.base\/share\/classes\/java\/lang\/foreign\/package-info.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import java.lang.invoke.InnerClassLambdaMetafactory.MethodBody;\n@@ -71,2 +70,0 @@\n-    private static final Consumer<FieldBuilder> STATIC_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_STATIC);\n-    private static final Consumer<FieldBuilder> FINAL_FIELD_FLAGS = new InnerClassLambdaMetafactory.FieldFlags(ACC_FINAL);\n@@ -628,1 +625,1 @@\n-                       .withField(sdFieldName, CD_SPECIES_DATA, STATIC_FIELD_FLAGS);\n+                       .withField(sdFieldName, CD_SPECIES_DATA, ACC_STATIC);\n@@ -712,1 +709,1 @@\n-                        clb.withField(field.name, field.desc, FINAL_FIELD_FLAGS);\n+                        clb.withField(field.name, field.desc, ACC_FINAL);\n@@ -716,2 +713,2 @@\n-                    clb.withMethod(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(SPECIES_DATA_NAME, MTD_SPECIES_DATA, (SPECIES_DATA_MODS & ACC_PPP) | ACC_FINAL,\n+                            new Consumer<>() {\n@@ -723,1 +720,1 @@\n-                            }));\n+                            });\n@@ -730,2 +727,2 @@\n-                    clb.withMethod(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(INIT_NAME, methodDesc(thisCtorType), ACC_PRIVATE,\n+                            new Consumer<>() {\n@@ -756,1 +753,1 @@\n-                            }));\n+                            });\n@@ -760,2 +757,2 @@\n-                    clb.withMethod(\"make\", methodDesc(ftryType), ACC_STATIC,\n-                            new MethodBody(new Consumer<CodeBuilder>() {\n+                    clb.withMethodBody(\"make\", methodDesc(ftryType), ACC_STATIC,\n+                            new Consumer<>() {\n@@ -776,1 +773,1 @@\n-                            }));\n+                            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ClassSpecializer.java","additions":12,"deletions":15,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.constant.ConstantUtils;\n@@ -115,1 +116,1 @@\n-        return Wrapper.forPrimitiveType(name.charAt(0)).primitiveType();\n+        return ConstantUtils.forPrimitiveType(name, 0).resolveConstantDesc(lookup);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/ConstantBootstraps.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -75,14 +75,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    record FieldFlags(int flags) implements Consumer<FieldBuilder> {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(flags);\n-        }\n-    };\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -327,1 +313,1 @@\n-                    clb.withField(argNames[i], argDescs[i], new FieldFlags(ACC_PRIVATE | ACC_FINAL));\n+                    clb.withField(argNames[i], argDescs[i], ACC_PRIVATE | ACC_FINAL);\n@@ -337,1 +323,1 @@\n-                clb.withMethod(interfaceMethodName,\n+                clb.withMethodBody(interfaceMethodName,\n@@ -345,1 +331,1 @@\n-                        clb.withMethod(interfaceMethodName,\n+                        clb.withMethodBody(interfaceMethodName,\n@@ -379,1 +365,1 @@\n-        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, new FieldFlags(ACC_PRIVATE | ACC_STATIC | ACC_FINAL));\n+        clb.withField(LAMBDA_INSTANCE_FIELD, lambdaTypeDescriptor, ACC_PRIVATE | ACC_STATIC | ACC_FINAL);\n@@ -382,1 +368,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -392,1 +378,1 @@\n-        }));\n+        });\n@@ -400,2 +386,2 @@\n-        clb.withMethod(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(INIT_NAME, constructorTypeDesc, ACC_PRIVATE,\n+                new Consumer<>() {\n@@ -415,1 +401,1 @@\n-                }));\n+                });\n@@ -442,2 +428,2 @@\n-        clb.withMethod(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n-                new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(SerializationSupport.NAME_METHOD_WRITE_REPLACE, SerializationSupport.MTD_Object, ACC_PRIVATE | ACC_FINAL,\n+                new Consumer<>() {\n@@ -471,1 +457,1 @@\n-                }));\n+                });\n@@ -507,2 +493,2 @@\n-    Consumer<MethodBuilder> forwardingMethod(MethodType methodType) {\n-        return new MethodBody(new Consumer<CodeBuilder>() {\n+    Consumer<CodeBuilder> forwardingMethod(MethodType methodType) {\n+        return new Consumer<>() {\n@@ -545,1 +531,1 @@\n-        });\n+        };\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InnerClassLambdaMetafactory.java","additions":15,"deletions":29,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,15 +86,0 @@\n-    \/\/ Static builders to avoid lambdas\n-    private static final Consumer<FieldBuilder> STATIC_FINAL_FIELD = new Consumer<FieldBuilder>() {\n-        @Override\n-        public void accept(FieldBuilder fb) {\n-            fb.withFlags(ACC_STATIC | ACC_FINAL);\n-        }\n-    };\n-\n-    record MethodBody(Consumer<CodeBuilder> code) implements Consumer<MethodBuilder> {\n-        @Override\n-        public void accept(MethodBuilder mb) {\n-            mb.withCode(code);\n-        }\n-    };\n-\n@@ -331,1 +316,1 @@\n-            clb.withField(p.name, p.desc, STATIC_FINAL_FIELD);\n+            clb.withField(p.name, p.desc, ACC_STATIC | ACC_FINAL);\n@@ -334,1 +319,1 @@\n-        clb.withMethod(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+        clb.withMethodBody(CLASS_INIT_NAME, MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -359,1 +344,1 @@\n-        }));\n+        });\n@@ -386,3 +371,3 @@\n-            case BooleanType -> emitReferenceCast(cob, Boolean.class, null);\n-            case CharType -> emitReferenceCast(cob, Character.class, null);\n-            case ByteType, DoubleType, FloatType, IntType, LongType, ShortType ->\n+            case BOOLEAN -> emitReferenceCast(cob, Boolean.class, null);\n+            case CHAR -> emitReferenceCast(cob, Character.class, null);\n+            case BYTE, DOUBLE, FLOAT, INT, LONG, SHORT ->\n@@ -461,1 +446,1 @@\n-            emitStoreInsn(cob, TypeKind.ReferenceType, writeBack.index());\n+            emitStoreInsn(cob, TypeKind.REFERENCE, writeBack.index());\n@@ -919,1 +904,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStoreInsn(cob, TypeKind.REFERENCE, receiver.index());  \/\/ store the MH in the receiver slot\n@@ -931,1 +916,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, receiver.index());  \/\/ store the MH in the receiver slot\n+        emitStoreInsn(cob, TypeKind.REFERENCE, receiver.index());  \/\/ store the MH in the receiver slot\n@@ -1169,1 +1154,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, casesLocal);\n+        emitStoreInsn(cob, TypeKind.REFERENCE, casesLocal);\n@@ -1190,1 +1175,1 @@\n-            emitLoadInsn(cob, TypeKind.ReferenceType, casesLocal);\n+            emitLoadInsn(cob, TypeKind.REFERENCE, casesLocal);\n@@ -1329,1 +1314,1 @@\n-        emitStoreInsn(cob, TypeKind.ReferenceType, clauseDataIndex);\n+        emitStoreInsn(cob, TypeKind.REFERENCE, clauseDataIndex);\n@@ -1416,1 +1401,1 @@\n-        emitLoadInsn(cob, TypeKind.ReferenceType, clauseDataSlot);\n+        emitLoadInsn(cob, TypeKind.REFERENCE, clauseDataSlot);\n@@ -1515,1 +1500,1 @@\n-        if (from != to && from != TypeKind.BooleanType) try {\n+        if (from != to && from != TypeKind.BOOLEAN) try {\n@@ -1674,1 +1659,1 @@\n-            clb.withMethod(\"dummy\", MTD_void, ACC_STATIC, new MethodBody(new Consumer<CodeBuilder>() {\n+            clb.withMethodBody(\"dummy\", MTD_void, ACC_STATIC, new Consumer<>() {\n@@ -1681,1 +1666,1 @@\n-            }));\n+            });\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/InvokerBytecodeGenerator.java","additions":17,"deletions":32,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -141,6 +141,6 @@\n-        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.ReferenceType), \/\/ all reference types\n-        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.IntType),\n-        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LongType),\n-        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FloatType),\n-        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DoubleType),  \/\/ all primitive types\n-        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VoidType);    \/\/ not valid in all contexts\n+        L_TYPE('L', Object.class, Wrapper.OBJECT, TypeKind.REFERENCE), \/\/ all reference types\n+        I_TYPE('I', int.class,    Wrapper.INT,    TypeKind.INT),\n+        J_TYPE('J', long.class,   Wrapper.LONG,   TypeKind.LONG),\n+        F_TYPE('F', float.class,  Wrapper.FLOAT,  TypeKind.FLOAT),\n+        D_TYPE('D', double.class, Wrapper.DOUBLE, TypeKind.DOUBLE),  \/\/ all primitive types\n+        V_TYPE('V', void.class,   Wrapper.VOID,   TypeKind.VOID);    \/\/ not valid in all contexts\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/LambdaForm.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -31,0 +32,2 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n+import jdk.internal.constant.ReferenceClassDescImpl;\n@@ -33,0 +36,2 @@\n+import jdk.internal.util.ReferenceKey;\n+import jdk.internal.util.ReferencedKeyMap;\n@@ -36,0 +41,1 @@\n+import java.lang.classfile.Annotation;\n@@ -39,0 +45,1 @@\n+import java.lang.classfile.MethodBuilder;\n@@ -40,0 +47,1 @@\n+import java.lang.classfile.attribute.RuntimeVisibleAnnotationsAttribute;\n@@ -41,1 +49,0 @@\n-import java.lang.constant.ConstantDescs;\n@@ -44,1 +51,2 @@\n-import java.lang.reflect.AccessFlag;\n+import java.lang.ref.SoftReference;\n+import java.util.Map;\n@@ -47,0 +55,1 @@\n+import java.util.concurrent.ConcurrentHashMap;\n@@ -48,0 +57,1 @@\n+import java.util.function.Supplier;\n@@ -49,1 +59,2 @@\n-import static java.lang.invoke.MethodHandles.Lookup.ClassOption.STRONG;\n+import static java.lang.classfile.ClassFile.*;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -110,1 +121,0 @@\n-\n@@ -112,0 +122,1 @@\n+    private static final int FORCE_INLINE_THRESHOLD;\n@@ -115,1 +126,4 @@\n-        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 20;\n+        HIGH_ARITY_THRESHOLD = highArity != null ? Integer.parseInt(highArity) : 0;\n+\n+        String inlineThreshold = VM.getSavedProperty(\"java.lang.invoke.StringConcat.inlineThreshold\");\n+        FORCE_INLINE_THRESHOLD = inlineThreshold != null ? Integer.parseInt(inlineThreshold) : 16;\n@@ -374,7 +388,7 @@\n-            if (concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n-                return new ConstantCallSite(\n-                        generateMHInlineCopy(concatType, constantStrings)\n-                                .viewAsType(concatType, true));\n-            } else {\n-                return new ConstantCallSite(\n-                        SimpleStringBuilderStrategy.generate(lookup, concatType, constantStrings));\n+            MethodHandle mh = makeSimpleConcat(concatType, constantStrings);\n+            if (mh == null && concatType.parameterCount() <= HIGH_ARITY_THRESHOLD) {\n+                mh = generateMHInlineCopy(concatType, constantStrings);\n+            }\n+\n+            if (mh == null) {\n+                mh = InlineHiddenClassStrategy.generate(lookup, concatType, constantStrings);\n@@ -382,0 +396,3 @@\n+            mh = mh.viewAsType(concatType, true);\n+\n+            return new ConstantCallSite(mh);\n@@ -430,1 +447,1 @@\n-                consts[oCount++] = acc.length() > 0 ? acc.toString() : null;\n+                consts[oCount++] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -446,1 +463,1 @@\n-        consts[oCount] = acc.length() > 0 ? acc.toString() : null;\n+        consts[oCount] = acc.length() > 0 ? acc.toString() : \"\";\n@@ -469,8 +486,1 @@\n-    \/**\n-     * <p>This strategy replicates what StringBuilders are doing: it builds the\n-     * byte[] array on its own and passes that byte[] array to String\n-     * constructor. This strategy requires access to some private APIs in JDK,\n-     * most notably, the private String constructor that accepts byte[] arrays\n-     * without copying.\n-     *\/\n-    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+    private static MethodHandle makeSimpleConcat(MethodType mt, String[] constants) {\n@@ -487,2 +497,2 @@\n-            if (prefix == null) {\n-                if (suffix == null) {\n+            if (prefix.isEmpty()) {\n+                if (suffix.isEmpty()) {\n@@ -493,1 +503,1 @@\n-            } else if (suffix == null && !mt.hasPrimitives()) {\n+            } else if (suffix.isEmpty() && !mt.hasPrimitives()) {\n@@ -497,3 +507,2 @@\n-        }\n-        if (paramCount == 2 && !mt.hasPrimitives() && suffix == null\n-                && constants[0] == null && constants[1] == null) {\n+        } else if (paramCount == 2 && !mt.hasPrimitives() && suffix.isEmpty()\n+                && constants[0].isEmpty() && constants[1].isEmpty()) {\n@@ -503,0 +512,16 @@\n+\n+        return null;\n+    }\n+\n+    \/**\n+     * <p>This strategy replicates what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n+     *\/\n+    private static MethodHandle generateMHInlineCopy(MethodType mt, String[] constants) {\n+        int paramCount = mt.parameterCount();\n+        String suffix = constants[paramCount];\n+\n+\n@@ -1046,1 +1071,1 @@\n-     * Bytecode StringBuilder strategy.\n+     * Implement efficient hidden class strategy for String concatenation\n@@ -1048,2 +1073,5 @@\n-     * <p>This strategy emits StringBuilder chains as similar as possible\n-     * to what javac would. No exact sizing of parameters or estimates.\n+     * <p>This strategy replicates based on the bytecode what StringBuilders are doing: it builds the\n+     * byte[] array on its own and passes that byte[] array to String\n+     * constructor. This strategy requires access to some private APIs in JDK,\n+     * most notably, the private String constructor that accepts byte[] arrays\n+     * without copying.\n@@ -1051,3 +1079,4 @@\n-    private static final class SimpleStringBuilderStrategy {\n-        static final String METHOD_NAME = \"concat\";\n-        static final ClassDesc STRING_BUILDER = ClassDesc.ofDescriptor(\"Ljava\/lang\/StringBuilder;\");\n+    private static final class InlineHiddenClassStrategy {\n+        static final String CLASS_NAME   = \"java.lang.String$$StringConcat\";\n+        static final String METHOD_NAME  = \"concat\";\n+\n@@ -1056,10 +1085,86 @@\n-        static final MethodTypeDesc APPEND_BOOLEAN_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_boolean);\n-        static final MethodTypeDesc APPEND_CHAR_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_char);\n-        static final MethodTypeDesc APPEND_DOUBLE_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_double);\n-        static final MethodTypeDesc APPEND_FLOAT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_float);\n-        static final MethodTypeDesc APPEND_INT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_int);\n-        static final MethodTypeDesc APPEND_LONG_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_long);\n-        static final MethodTypeDesc APPEND_OBJECT_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_Object);\n-        static final MethodTypeDesc APPEND_STRING_TYPE = MethodTypeDesc.of(STRING_BUILDER, ConstantDescs.CD_String);\n-        static final MethodTypeDesc INT_CONSTRUCTOR_TYPE = MethodTypeDesc.of(ConstantDescs.CD_void, ConstantDescs.CD_int);\n-        static final MethodTypeDesc TO_STRING_TYPE = MethodTypeDesc.of(ConstantDescs.CD_String);\n+        static final MethodHandles.Lookup STR_LOOKUP = new MethodHandles.Lookup(String.class);\n+\n+        static final ClassDesc CD_CONCAT             = ConstantUtils.binaryNameToDesc(CLASS_NAME);\n+        static final ClassDesc CD_StringConcatHelper = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper;\");\n+        static final ClassDesc CD_StringConcatBase   = ReferenceClassDescImpl.ofValidated(\"Ljava\/lang\/StringConcatHelper$StringConcatBase;\");\n+        static final ClassDesc CD_Array_byte         = ReferenceClassDescImpl.ofValidated(\"[B\");\n+        static final ClassDesc CD_Array_String       = ReferenceClassDescImpl.ofValidated(\"[Ljava\/lang\/String;\");\n+\n+        static final MethodTypeDesc MTD_byte_char       = MethodTypeDescImpl.ofValidated(CD_byte, CD_char);\n+        static final MethodTypeDesc MTD_byte            = MethodTypeDescImpl.ofValidated(CD_byte);\n+        static final MethodTypeDesc MTD_int             = MethodTypeDescImpl.ofValidated(CD_int);\n+        static final MethodTypeDesc MTD_int_int_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_boolean);\n+        static final MethodTypeDesc MTD_int_int_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_char);\n+        static final MethodTypeDesc MTD_int_int_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_int);\n+        static final MethodTypeDesc MTD_int_int_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_long);\n+        static final MethodTypeDesc MTD_int_int_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_String);\n+        static final MethodTypeDesc MTD_String_float    = MethodTypeDescImpl.ofValidated(CD_String, CD_float);\n+        static final MethodTypeDesc MTD_String_double   = MethodTypeDescImpl.ofValidated(CD_String, CD_double);\n+        static final MethodTypeDesc MTD_String_Object   = MethodTypeDescImpl.ofValidated(CD_String, CD_Object);\n+\n+        static final MethodTypeDesc MTD_INIT             = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_String);\n+        static final MethodTypeDesc MTD_NEW_ARRAY_SUFFIX = MethodTypeDescImpl.ofValidated(CD_Array_byte, CD_String, CD_int, CD_byte);\n+        static final MethodTypeDesc MTD_STRING_INIT      = MethodTypeDescImpl.ofValidated(CD_void, CD_Array_byte, CD_byte);\n+\n+        static final MethodTypeDesc PREPEND_int     = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_int, CD_String);\n+        static final MethodTypeDesc PREPEND_long    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_long, CD_String);\n+        static final MethodTypeDesc PREPEND_boolean = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_boolean, CD_String);\n+        static final MethodTypeDesc PREPEND_char    = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_char, CD_String);\n+        static final MethodTypeDesc PREPEND_String  = MethodTypeDescImpl.ofValidated(CD_int, CD_int, CD_byte, CD_Array_byte, CD_String, CD_String);\n+\n+        static final RuntimeVisibleAnnotationsAttribute FORCE_INLINE = RuntimeVisibleAnnotationsAttribute.of(Annotation.of(ClassDesc.ofDescriptor(\"Ljdk\/internal\/vm\/annotation\/ForceInline;\")));\n+\n+        static final MethodType CONSTRUCTOR_METHOD_TYPE        = MethodType.methodType(void.class, String[].class);\n+        static final Consumer<CodeBuilder> CONSTRUCTOR_BUILDER = new Consumer<CodeBuilder>() {\n+            @Override\n+            public void accept(CodeBuilder cb) {\n+                \/*\n+                 * super(constants);\n+                 *\/\n+                int thisSlot      = cb.receiverSlot(),\n+                    constantsSlot = cb.parameterSlot(0);\n+                cb.aload(thisSlot)\n+                  .aload(constantsSlot)\n+                  .invokespecial(CD_StringConcatBase, INIT_NAME, MTD_INIT, false)\n+                  .return_();\n+            }\n+        };\n+\n+        static final ReferencedKeyMap<MethodType, SoftReference<MethodHandlePair>> CACHE =\n+                ReferencedKeyMap.create(true, true,\n+                        new Supplier<>() {\n+                            @Override\n+                            public Map<ReferenceKey<MethodType>, SoftReference<MethodHandlePair>> get() {\n+                                return new ConcurrentHashMap<>(64);\n+                            }\n+                        });\n+\n+        private InlineHiddenClassStrategy() {\n+            \/\/ no instantiation\n+        }\n+\n+        private record MethodHandlePair(MethodHandle constructor, MethodHandle concatenator) { };\n+\n+        \/**\n+         * The parameter types are normalized into 7 types: int,long,boolean,char,float,double,Object\n+         *\/\n+        private static MethodType erasedArgs(MethodType args) {\n+            int parameterCount = args.parameterCount();\n+            var paramTypes = new Class<?>[parameterCount];\n+            boolean changed = false;\n+            for (int i = 0; i < parameterCount; i++) {\n+                Class<?> cl = args.parameterType(i);\n+                \/\/ Use int as the logical type for subword integral types\n+                \/\/ (byte and short). char and boolean require special\n+                \/\/ handling so don't change the logical type of those\n+                if (cl == byte.class || cl == short.class) {\n+                    cl = int.class;\n+                    changed = true;\n+                } else if (cl != Object.class && !cl.isPrimitive()) {\n+                    cl = Object.class;\n+                    changed = true;\n+                }\n+                paramTypes[i] = cl;\n+            }\n+            return changed ? MethodType.methodType(args.returnType(), paramTypes, true) : args;\n+        }\n@@ -1068,2 +1173,8 @@\n-         * Ensure a capacity in the initial StringBuilder to accommodate all\n-         * constants plus this factor times the number of arguments.\n+         * Construct the MethodType of the prepend method, The parameters only support 5 types:\n+         * int\/long\/char\/boolean\/String. Not int\/long\/char\/boolean type, use String type<p>\n+         *\n+         * The following is an example of the generated target code:\n+         * <blockquote><pre>\n+         *  int prepend(int length, byte coder, byte[] buff,  String[] constants\n+         *      int arg0, long arg1, boolean arg2, char arg3, String arg5)\n+         * <\/pre><\/blockquote>\n@@ -1071,1 +1182,14 @@\n-        static final int ARGUMENT_SIZE_FACTOR = 4;\n+        private static MethodTypeDesc prependArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            var paramTypes = new ClassDesc[parameterCount + 4];\n+            paramTypes[0] = CD_int;          \/\/ length\n+            paramTypes[1] = CD_byte;         \/\/ coder\n+            paramTypes[2] = CD_Array_byte;   \/\/ buff\n+            paramTypes[3] = CD_Array_String; \/\/ constants\n+\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + 4] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n+        }\n@@ -1073,1 +1197,6 @@\n-        static final Set<Lookup.ClassOption> SET_OF_STRONG = Set.of(STRONG);\n+        \/**\n+         * Construct the MethodType of the coder method. The first parameter is the initialized coder.\n+         * Only parameter types which can be UTF16 are added. Returns null if no such parameter exists.\n+         *\/\n+        private static MethodTypeDesc coderArgsIfMaybeUTF16(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n@@ -1075,2 +1204,35 @@\n-        private SimpleStringBuilderStrategy() {\n-            \/\/ no instantiation\n+            int maybeUTF16Count = 0;\n+            for (int i = 0; i < parameterCount; i++) {\n+                if (maybeUTF16(concatArgs.parameterType(i))) {\n+                    maybeUTF16Count++;\n+                }\n+            }\n+\n+            if (maybeUTF16Count == 0) {\n+                return null;\n+            }\n+\n+            var paramTypes = new ClassDesc[maybeUTF16Count + 1];\n+            paramTypes[0] = CD_int; \/\/ init coder\n+            for (int i = 0, paramIndex = 1; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                if (maybeUTF16(cl)) {\n+                    paramTypes[paramIndex++] = cl == char.class ? CD_char : CD_String;\n+                }\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n+        }\n+\n+        \/**\n+         * Construct the MethodType of the length method,\n+         * The first parameter is the initialized length\n+         *\/\n+        private static MethodTypeDesc lengthArgs(MethodType concatArgs) {\n+            int parameterCount = concatArgs.parameterCount();\n+            var paramTypes = new ClassDesc[parameterCount + 1];\n+            paramTypes[0] = CD_int; \/\/ init long\n+            for (int i = 0; i < parameterCount; i++) {\n+                var cl = concatArgs.parameterType(i);\n+                paramTypes[i + 1] = needStringOf(cl) ? CD_String : ConstantUtils.classDesc(cl);\n+            }\n+            return MethodTypeDescImpl.ofValidated(CD_int, paramTypes);\n@@ -1080,1 +1242,25 @@\n-            String className = getClassName(lookup.lookupClass());\n+            lookup = STR_LOOKUP;\n+            final MethodType concatArgs = erasedArgs(args);\n+\n+            \/\/ 1 argment use built-in method\n+            if (args.parameterCount() == 1) {\n+                Object concat1 = JLA.stringConcat1(constants);\n+                var handle = lookup.findVirtual(concat1.getClass(), METHOD_NAME, concatArgs);\n+                return handle.bindTo(concat1);\n+            }\n+\n+            var weakConstructorHandle = CACHE.get(concatArgs);\n+            if (weakConstructorHandle != null) {\n+                MethodHandlePair handlePair = weakConstructorHandle.get();\n+                if (handlePair != null) {\n+                    try {\n+                        var instance = handlePair.constructor.invoke(constants);\n+                        return handlePair.concatenator.bindTo(instance);\n+                    } catch (Throwable e) {\n+                        throw new StringConcatException(\"Exception while utilizing the hidden class\", e);\n+                    }\n+                }\n+            }\n+            MethodTypeDesc lengthArgs  = lengthArgs(concatArgs),\n+                           coderArgs   = coderArgsIfMaybeUTF16(concatArgs),\n+                           prependArgs = prependArgs(concatArgs);\n@@ -1082,1 +1268,1 @@\n-            byte[] classBytes = ClassFile.of().build(ConstantUtils.binaryNameToDesc(className),\n+            byte[] classBytes = ClassFile.of().build(CD_CONCAT,\n@@ -1084,0 +1270,2 @@\n+                        final boolean forceInline = concatArgs.parameterCount() < FORCE_INLINE_THRESHOLD;\n+\n@@ -1086,5 +1274,55 @@\n-                            clb.withFlags(AccessFlag.FINAL, AccessFlag.SUPER, AccessFlag.SYNTHETIC)\n-                                .withMethodBody(METHOD_NAME,\n-                                        ConstantUtils.methodTypeDesc(args),\n-                                        ClassFile.ACC_FINAL | ClassFile.ACC_PRIVATE | ClassFile.ACC_STATIC,\n-                                        generateMethod(constants, args));\n+                            clb.withSuperclass(CD_StringConcatBase)\n+                                .withFlags(ACC_FINAL | ACC_SUPER | ACC_SYNTHETIC)\n+                                .withMethodBody(INIT_NAME, MTD_INIT, 0, CONSTRUCTOR_BUILDER)\n+                                .withMethod(\"length\",\n+                                        lengthArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateLengthMethod(lengthArgs));\n+                                            }\n+                                        })\n+                                .withMethod(\"prepend\",\n+                                        prependArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generatePrependMethod(prependArgs));\n+                                            }\n+                                        })\n+                                .withMethod(METHOD_NAME,\n+                                        ConstantUtils.methodTypeDesc(concatArgs),\n+                                        ACC_FINAL,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateConcatMethod(\n+                                                        CD_CONCAT,\n+                                                        concatArgs,\n+                                                        lengthArgs,\n+                                                        coderArgs,\n+                                                        prependArgs));\n+                                            }\n+                                        });\n+\n+                            if (coderArgs != null) {\n+                                clb.withMethod(\"coder\",\n+                                        coderArgs,\n+                                        ACC_STATIC | ACC_PRIVATE,\n+                                        new Consumer<MethodBuilder>() {\n+                                            public void accept(MethodBuilder mb) {\n+                                                if (forceInline) {\n+                                                    mb.with(FORCE_INLINE);\n+                                                }\n+                                                mb.withCode(generateCoderMethod(coderArgs));\n+                                            }\n+                                        });\n+                            }\n@@ -1093,5 +1331,8 @@\n-                Lookup hiddenLookup = lookup.makeHiddenClassDefiner(className, classBytes, SET_OF_STRONG, DUMPER)\n-                                            .defineClassAsLookup(true);\n-                Class<?> innerClass = hiddenLookup.lookupClass();\n-                return hiddenLookup.findStatic(innerClass, METHOD_NAME, args);\n-            } catch (Exception e) {\n+                var hiddenClass = lookup.makeHiddenClassDefiner(CLASS_NAME, classBytes, Set.of(), DUMPER)\n+                                        .defineClass(true, null);\n+                var constructor = lookup.findConstructor(hiddenClass, CONSTRUCTOR_METHOD_TYPE);\n+                var concat      = lookup.findVirtual(hiddenClass, METHOD_NAME, concatArgs);\n+                CACHE.put(concatArgs, new SoftReference<>(new MethodHandlePair(constructor, concat)));\n+                var instance = hiddenClass.cast(constructor.invoke(constants));\n+                return concat.bindTo(instance);\n+            } catch (Throwable e) {\n@@ -1102,1 +1343,71 @@\n-        private static Consumer<CodeBuilder> generateMethod(String[] constants, MethodType args) {\n+        \/**\n+         * Generate InlineCopy-based code. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         *  import static java.lang.StringConcatHelper.newArrayWithSuffix;\n+         *  import static java.lang.StringConcatHelper.prepend;\n+         *  import static java.lang.StringConcatHelper.stringCoder;\n+         *  import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         *  class StringConcat extends java.lang.StringConcatHelper.StringConcatBase {\n+         *      \/\/ super class defines\n+         *      \/\/ String[] constants;\n+         *      \/\/ int length;\n+         *      \/\/ byte coder;\n+         *\n+         *      StringConcat(String[] constants) {\n+         *          super(constants);\n+         *      }\n+         *\n+         *      String concat(int arg0, long arg1, boolean arg2, char arg3, String arg4,\n+         *          float arg5, double arg6, Object arg7\n+         *      ) {\n+         *          \/\/ Types other than byte\/short\/int\/long\/boolean\/String require a local variable to store\n+         *          String str4 = stringOf(arg4);\n+         *          String str5 = stringOf(arg5);\n+         *          String str6 = stringOf(arg6);\n+         *          String str7 = stringOf(arg7);\n+         *\n+         *          int coder  = coder(this.coder, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *          int length = length(this.length, arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7);\n+         *          String[] constants = this.constants;\n+         *          byte[] buf = newArrayWithSuffix(constants[paramCount], length. coder);\n+         *\n+         *          prepend(length, coder, buf, constants, arg0, arg1, arg2, arg3, str4, str5, str6, str7);\n+         *\n+         *          return new String(buf, coder);\n+         *      }\n+         *\n+         *      static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                       String arg4, String arg5, String arg6, String arg7) {\n+         *          return stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(stringSize(\n+         *                      length, arg0), arg1), arg2), arg3), arg4), arg5), arg6), arg7);\n+         *      }\n+         *\n+         *      static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *          return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         *      }\n+         *\n+         *      static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                     int arg0, long arg1, boolean arg2, char arg3,\n+         *                     String str4, String str5, String str6, String str7) {\n+         *          \/\/ StringConcatHelper.prepend\n+         *          return prepend(prepend(prepend(prepend(\n+         *                  prepend(apppend(prepend(prepend(length,\n+         *                       buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                       buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                       buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                       buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         *      }\n+         *  }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateConcatMethod(\n+                ClassDesc      concatClass,\n+                MethodType     concatArgs,\n+                MethodTypeDesc lengthArgs,\n+                MethodTypeDesc coderArgs,\n+                MethodTypeDesc prependArgs\n+        ) {\n@@ -1106,7 +1417,35 @@\n-                    cb.new_(STRING_BUILDER);\n-                    cb.dup();\n-\n-                    int len = 0;\n-                    for (String constant : constants) {\n-                        if (constant != null) {\n-                            len += constant.length();\n+                    \/\/ Compute parameter variable slots\n+                    int paramCount    = concatArgs.parameterCount(),\n+                        thisSlot      = cb.receiverSlot(),\n+                        lengthSlot    = cb.allocateLocal(TypeKind.INT),\n+                        coderSlot     = cb.allocateLocal(TypeKind.BYTE),\n+                        bufSlot       = cb.allocateLocal(TypeKind.REFERENCE),\n+                        constantsSlot = cb.allocateLocal(TypeKind.REFERENCE),\n+                        suffixSlot    = cb.allocateLocal(TypeKind.REFERENCE);\n+\n+                    \/*\n+                     * Types other than int\/long\/char\/boolean require local variables to store the result of stringOf.\n+                     *\n+                     * stringSlots stores the slots of parameters relative to local variables\n+                     *\n+                     * str0 = stringOf(arg0);\n+                     * str1 = stringOf(arg1);\n+                     * ...\n+                     * strN = toString(argN);\n+                     *\/\n+                    int[] stringSlots = new int[paramCount];\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        if (needStringOf(cl)) {\n+                            MethodTypeDesc methodTypeDesc;\n+                            if (cl == float.class) {\n+                                methodTypeDesc = MTD_String_float;\n+                            } else if (cl == double.class) {\n+                                methodTypeDesc = MTD_String_double;\n+                            } else {\n+                                methodTypeDesc = MTD_String_Object;\n+                            }\n+                            stringSlots[i] = cb.allocateLocal(TypeKind.REFERENCE);\n+                            cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                              .invokestatic(CD_StringConcatHelper, \"stringOf\", methodTypeDesc)\n+                              .astore(stringSlots[i]);\n@@ -1115,11 +1454,15 @@\n-                    len += args.parameterCount() * ARGUMENT_SIZE_FACTOR;\n-                    cb.loadConstant(len);\n-                    cb.invokespecial(STRING_BUILDER, \"<init>\", INT_CONSTRUCTOR_TYPE);\n-\n-                    \/\/ At this point, we have a blank StringBuilder on stack, fill it in with .append calls.\n-                    {\n-                        int off = 0;\n-                        for (int c = 0; c < args.parameterCount(); c++) {\n-                            if (constants[c] != null) {\n-                                cb.ldc(constants[c]);\n-                                cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+\n+                    \/*\n+                     * coder = coder(this.coder, arg0, arg1, ... argN);\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"coder\", CD_byte);\n+                    if (coderArgs != null) {\n+                        for (int i = 0; i < paramCount; i++) {\n+                            var cl = concatArgs.parameterType(i);\n+                            if (maybeUTF16(cl)) {\n+                                if (cl == char.class) {\n+                                    cb.loadLocal(TypeKind.CHAR, cb.parameterSlot(i));\n+                                } else {\n+                                    cb.aload(stringSlots[i]);\n+                                }\n@@ -1127,6 +1470,0 @@\n-                            Class<?> cl = args.parameterType(c);\n-                            TypeKind kind = TypeKind.from(cl);\n-                            cb.loadLocal(kind, off);\n-                            off += kind.slotSize();\n-                            MethodTypeDesc desc = getSBAppendDesc(cl);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", desc);\n@@ -1134,3 +1471,62 @@\n-                        if (constants[constants.length - 1] != null) {\n-                            cb.ldc(constants[constants.length - 1]);\n-                            cb.invokevirtual(STRING_BUILDER, \"append\", APPEND_STRING_TYPE);\n+                        cb.invokestatic(concatClass, \"coder\", coderArgs);\n+                    }\n+                    cb.istore(coderSlot);\n+\n+                    \/*\n+                     * length = length(this.length, arg0, arg1, ..., argN);\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"length\", CD_int);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl        = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            cl = String.class;\n+                        }\n+                        cb.loadLocal(TypeKind.from(cl), paramSlot);\n+                    }\n+                    cb.invokestatic(concatClass, \"length\", lengthArgs);\n+\n+                    \/*\n+                     * String[] constants = this.constants;\n+                     * suffix  = constants[paramCount];\n+                     * length -= suffix.length();\n+                     *\/\n+                    cb.aload(thisSlot)\n+                      .getfield(concatClass, \"constants\", CD_Array_String)\n+                      .dup()\n+                      .astore(constantsSlot)\n+                      .ldc(paramCount)\n+                      .aaload()\n+                      .dup()\n+                      .astore(suffixSlot)\n+                      .invokevirtual(CD_String, \"length\", MTD_int)\n+                      .isub()\n+                      .istore(lengthSlot);\n+\n+                    \/*\n+                     * Allocate buffer :\n+                     *\n+                     *  buf = newArrayWithSuffix(suffix, length, coder)\n+                     *\/\n+                    cb.aload(suffixSlot)\n+                      .iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .invokestatic(CD_StringConcatHelper, \"newArrayWithSuffix\", MTD_NEW_ARRAY_SUFFIX)\n+                      .astore(bufSlot);\n+\n+                    \/*\n+                     * prepend(length, coder, buf, constants, ar0, ar1, ..., argN);\n+                     *\/\n+                    cb.iload(lengthSlot)\n+                      .iload(coderSlot)\n+                      .aload(bufSlot)\n+                      .aload(constantsSlot);\n+                    for (int i = 0; i < paramCount; i++) {\n+                        var cl = concatArgs.parameterType(i);\n+                        int paramSlot = cb.parameterSlot(i);\n+                        var kind = TypeKind.from(cl);\n+                        if (needStringOf(cl)) {\n+                            paramSlot = stringSlots[i];\n+                            kind = TypeKind.REFERENCE;\n@@ -1138,0 +1534,1 @@\n+                        cb.loadLocal(kind, paramSlot);\n@@ -1139,0 +1536,12 @@\n+                    cb.invokestatic(concatClass, \"prepend\", prependArgs);\n+\n+                    \/\/ return new String(buf, coder);\n+                    cb.new_(CD_String)\n+                      .dup()\n+                      .aload(bufSlot)\n+                      .iload(coderSlot)\n+                      .invokespecial(CD_String, INIT_NAME, MTD_STRING_INIT)\n+                      .areturn();\n+                }\n+            };\n+        }\n@@ -1140,2 +1549,38 @@\n-                    cb.invokevirtual(STRING_BUILDER, \"toString\", TO_STRING_TYPE);\n-                    cb.areturn();\n+        \/**\n+         * Generate length method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringSize;\n+         *\n+         * static int length(int length, int arg0, long arg1, boolean arg2, char arg3,\n+         *                  String arg4, String arg5, String arg6, String arg7) {\n+         *     return stringSize(stringSize(stringSize(length, arg0), arg1), ..., arg7);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generateLengthMethod(MethodTypeDesc lengthArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    int lengthSlot = cb.parameterSlot(0);\n+                    cb.iload(lengthSlot);\n+                    for (int i = 1; i < lengthArgs.parameterCount(); i++) {\n+                        var cl = lengthArgs.parameterType(i);\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_char) {\n+                            methodTypeDesc = MTD_int_int_char;\n+                        } else if (cl == CD_int) {\n+                            methodTypeDesc = MTD_int_int_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = MTD_int_int_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = MTD_int_int_boolean;\n+                        } else {\n+                            methodTypeDesc = MTD_int_int_String;\n+                        }\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i))\n+                          .invokestatic(CD_StringConcatHelper, \"stringSize\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n@@ -1147,3 +1592,11 @@\n-         * The generated class is in the same package as the host class as\n-         * it's the implementation of the string concatenation for the host\n-         * class.\n+         * Generate coder method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.stringCoder;\n+         *\n+         * static int cocder(int coder, char arg3, String str4, String str5, String str6, String str7) {\n+         *     return coder | stringCoder(arg3) | str4.coder() | str5.coder() | str6.coder() | str7.coder();\n+         * }\n+         * <\/pre><\/blockquote>\n@@ -1151,4 +1604,22 @@\n-        private static String getClassName(Class<?> hostClass) {\n-            String name = hostClass.isHidden() ? hostClass.getName().replace('\/', '_')\n-                    : hostClass.getName();\n-            return name + \"$$StringConcat\";\n+        private static Consumer<CodeBuilder> generateCoderMethod(MethodTypeDesc coderArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/*\n+                     * return coder | stringCoder(argN) | ... | arg1.coder() | arg0.coder();\n+                     *\/\n+                    int coderSlot = cb.parameterSlot(0);\n+                    cb.iload(coderSlot);\n+                    for (int i = 1; i < coderArgs.parameterCount(); i++) {\n+                        var cl = coderArgs.parameterType(i);\n+                        cb.loadLocal(TypeKind.from(cl), cb.parameterSlot(i));\n+                        if (cl == CD_char) {\n+                            cb.invokestatic(CD_StringConcatHelper, \"stringCoder\", MTD_byte_char);\n+                        } else {\n+                            cb.invokevirtual(CD_String, \"coder\", MTD_byte);\n+                        }\n+                        cb.ior();\n+                    }\n+                    cb.ireturn();\n+                }\n+            };\n@@ -1157,16 +1628,68 @@\n-        private static MethodTypeDesc getSBAppendDesc(Class<?> cl) {\n-            if (cl.isPrimitive()) {\n-                if (cl == Integer.TYPE || cl == Byte.TYPE || cl == Short.TYPE) {\n-                    return APPEND_INT_TYPE;\n-                } else if (cl == Boolean.TYPE) {\n-                    return APPEND_BOOLEAN_TYPE;\n-                } else if (cl == Character.TYPE) {\n-                    return APPEND_CHAR_TYPE;\n-                } else if (cl == Double.TYPE) {\n-                    return APPEND_DOUBLE_TYPE;\n-                } else if (cl == Float.TYPE) {\n-                    return APPEND_FLOAT_TYPE;\n-                } else if (cl == Long.TYPE) {\n-                    return APPEND_LONG_TYPE;\n-                } else {\n-                    throw new IllegalStateException(\"Unhandled primitive StringBuilder.append: \" + cl);\n+        \/**\n+         * Generate prepend method. <p>\n+         *\n+         * The following is an example of the generated target code:\n+         *\n+         * <blockquote><pre>\n+         * import static java.lang.StringConcatHelper.prepend;\n+         *\n+         * static int prepend(int length, int coder, byte[] buf, String[] constants,\n+         *                int arg0, long arg1, boolean arg2, char arg3,\n+         *                String str4, String str5, String str6, String str7) {\n+         *\n+         *     return prepend(prepend(prepend(prepend(\n+         *             prepend(prepend(prepend(prepend(length,\n+         *                  buf, str7, constant[7]), buf, str6, constant[6]),\n+         *                  buf, str5, constant[5]), buf, str4, constant[4]),\n+         *                  buf, arg3, constant[3]), buf, arg2, constant[2]),\n+         *                  buf, arg1, constant[1]), buf, arg0, constant[0]);\n+         * }\n+         * <\/pre><\/blockquote>\n+         *\/\n+        private static Consumer<CodeBuilder> generatePrependMethod(MethodTypeDesc prependArgs) {\n+            return new Consumer<CodeBuilder>() {\n+                @Override\n+                public void accept(CodeBuilder cb) {\n+                    \/\/ Compute parameter variable slots\n+                    int lengthSlot    = cb.parameterSlot(0),\n+                        coderSlot     = cb.parameterSlot(1),\n+                        bufSlot       = cb.parameterSlot(2),\n+                        constantsSlot = cb.parameterSlot(3);\n+                    \/*\n+                     * \/\/ StringConcatHelper.prepend\n+                     * return prepend(prepend(prepend(prepend(\n+                     *         prepend(apppend(prepend(prepend(length,\n+                     *              buf, str7, constant[7]), buf, str6, constant[6]),\n+                     *              buf, str5, constant[5]), buf, arg4, constant[4]),\n+                     *              buf, arg3, constant[3]), buf, arg2, constant[2]),\n+                     *              buf, arg1, constant[1]), buf, arg0, constant[0]);\n+                     *\/\n+                    cb.iload(lengthSlot);\n+                    for (int i = prependArgs.parameterCount() - 1; i >= 4; i--) {\n+                        var cl   = prependArgs.parameterType(i);\n+                        var kind = TypeKind.from(cl);\n+\n+                        \/\/ There are only 5 types of parameters: int, long, boolean, char, String\n+                        MethodTypeDesc methodTypeDesc;\n+                        if (cl == CD_int) {\n+                            methodTypeDesc = PREPEND_int;\n+                        } else if (cl == CD_long) {\n+                            methodTypeDesc = PREPEND_long;\n+                        } else if (cl == CD_boolean) {\n+                            methodTypeDesc = PREPEND_boolean;\n+                        } else if (cl == CD_char) {\n+                            methodTypeDesc = PREPEND_char;\n+                        } else {\n+                            kind = TypeKind.REFERENCE;\n+                            methodTypeDesc = PREPEND_String;\n+                        }\n+\n+                        cb.iload(coderSlot)\n+                          .aload(bufSlot)\n+                          .loadLocal(kind, cb.parameterSlot(i))\n+                          .aload(constantsSlot)\n+                          .ldc(i - 4)\n+                          .aaload()\n+                          .invokestatic(CD_StringConcatHelper, \"prepend\", methodTypeDesc);\n+                    }\n+                    cb.ireturn();\n@@ -1174,5 +1697,9 @@\n-            } else if (cl == String.class) {\n-                return APPEND_STRING_TYPE;\n-            } else {\n-                return APPEND_OBJECT_TYPE;\n-            }\n+            };\n+        }\n+\n+        static boolean needStringOf(Class<?> cl) {\n+            return cl != int.class && cl != long.class && cl != boolean.class && cl != char.class;\n+        }\n+\n+        static boolean maybeUTF16(Class<?> cl) {\n+            return cl == char.class || !cl.isPrimitive();\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/StringConcatFactory.java","additions":647,"deletions":120,"binary":false,"changes":767,"status":"modified"},{"patch":"@@ -72,8 +72,8 @@\n-        if (type == Integer.class)   return TypeKind.IntType;\n-        if (type == Long.class)      return TypeKind.LongType;\n-        if (type == Boolean.class)   return TypeKind.BooleanType;\n-        if (type == Short.class)     return TypeKind.ShortType;\n-        if (type == Byte.class)      return TypeKind.ByteType;\n-        if (type == Character.class) return TypeKind.CharType;\n-        if (type == Float.class)     return TypeKind.FloatType;\n-        if (type == Double.class)    return TypeKind.DoubleType;\n+        if (type == Integer.class)   return TypeKind.INT;\n+        if (type == Long.class)      return TypeKind.LONG;\n+        if (type == Boolean.class)   return TypeKind.BOOLEAN;\n+        if (type == Short.class)     return TypeKind.SHORT;\n+        if (type == Byte.class)      return TypeKind.BYTE;\n+        if (type == Character.class) return TypeKind.CHAR;\n+        if (type == Float.class)     return TypeKind.FLOAT;\n+        if (type == Double.class)    return TypeKind.DOUBLE;\n@@ -97,8 +97,8 @@\n-            case BooleanType -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n-            case ByteType    -> cob.invokestatic(BoxHolder.BOX_BYTE);\n-            case CharType    -> cob.invokestatic(BoxHolder.BOX_CHAR);\n-            case DoubleType  -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n-            case FloatType   -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n-            case IntType     -> cob.invokestatic(BoxHolder.BOX_INT);\n-            case LongType    -> cob.invokestatic(BoxHolder.BOX_LONG);\n-            case ShortType   -> cob.invokestatic(BoxHolder.BOX_SHORT);\n+            case BOOLEAN -> cob.invokestatic(BoxHolder.BOX_BOOLEAN);\n+            case BYTE -> cob.invokestatic(BoxHolder.BOX_BYTE);\n+            case CHAR -> cob.invokestatic(BoxHolder.BOX_CHAR);\n+            case DOUBLE -> cob.invokestatic(BoxHolder.BOX_DOUBLE);\n+            case FLOAT -> cob.invokestatic(BoxHolder.BOX_FLOAT);\n+            case INT -> cob.invokestatic(BoxHolder.BOX_INT);\n+            case LONG -> cob.invokestatic(BoxHolder.BOX_LONG);\n+            case SHORT -> cob.invokestatic(BoxHolder.BOX_SHORT);\n@@ -110,8 +110,8 @@\n-            case BooleanType -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n-            case ByteType    -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n-            case CharType    -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n-            case DoubleType  -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n-            case FloatType   -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n-            case IntType     -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n-            case LongType    -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n-            case ShortType   -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n+            case BOOLEAN -> cob.invokevirtual(BoxHolder.UNBOX_BOOLEAN);\n+            case BYTE -> cob.invokevirtual(BoxHolder.UNBOX_BYTE);\n+            case CHAR -> cob.invokevirtual(BoxHolder.UNBOX_CHAR);\n+            case DOUBLE -> cob.invokevirtual(BoxHolder.UNBOX_DOUBLE);\n+            case FLOAT -> cob.invokevirtual(BoxHolder.UNBOX_FLOAT);\n+            case INT -> cob.invokevirtual(BoxHolder.UNBOX_INT);\n+            case LONG -> cob.invokevirtual(BoxHolder.UNBOX_LONG);\n+            case SHORT -> cob.invokevirtual(BoxHolder.UNBOX_SHORT);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/TypeConvertingMethodAdapter.java","additions":24,"deletions":24,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import jdk.internal.foreign.Utils;\n@@ -31,0 +32,1 @@\n+import java.lang.foreign.MemoryLayout;\n@@ -48,1 +50,1 @@\n-    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, long.class);\n+    static final VarForm FORM = new VarForm(VarHandleSegmentAs$Type$s.class, MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -56,1 +58,1 @@\n-        return accessType.accessModeType(MemorySegment.class, $type$.class, long.class);\n+        return accessType.accessModeType(MemorySegment.class, $type$.class, MemoryLayout.class, long.class, long.class);\n@@ -100,1 +102,1 @@\n-    static AbstractMemorySegmentImpl checkReadOnly(Object obb, boolean ro) {\n+    static AbstractMemorySegmentImpl checkSegment(Object obb, Object encl, long base, boolean ro) {\n@@ -102,1 +104,1 @@\n-        oo.checkReadOnly(ro);\n+        oo.checkEnclosingLayout(base, (MemoryLayout)encl, ro);\n@@ -107,1 +109,1 @@\n-    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long offset, long alignmentMask) {\n+    static long offsetNonPlain(AbstractMemorySegmentImpl bb, long base, long offset, long alignmentMask) {\n@@ -111,1 +113,1 @@\n-        return offsetPlain(bb, offset);\n+        return offsetPlain(bb, base, offset);\n@@ -115,3 +117,3 @@\n-    static long offsetPlain(AbstractMemorySegmentImpl bb, long offset) {\n-        long base = bb.unsafeGetOffset();\n-        return base + offset;\n+    static long offsetPlain(AbstractMemorySegmentImpl bb, long base, long offset) {\n+        long segment_base = bb.unsafeGetOffset();\n+        return segment_base + base + offset;\n@@ -121,1 +123,1 @@\n-    static $type$ get(VarHandle ob, Object obb, long base) {\n+    static $type$ get(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -123,1 +125,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -127,1 +129,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -134,1 +136,1 @@\n-                offsetPlain(bb, base));\n+                offsetPlain(bb, base, offset));\n@@ -138,1 +140,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -145,1 +147,1 @@\n-    static void set(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void set(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -147,1 +149,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -151,1 +153,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -158,1 +160,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -163,1 +165,1 @@\n-                offsetPlain(bb, base),\n+                offsetPlain(bb, base, offset),\n@@ -171,1 +173,1 @@\n-    static $type$ getVolatile(VarHandle ob, Object obb, long base) {\n+    static $type$ getVolatile(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -173,1 +175,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -177,1 +179,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -181,1 +183,1 @@\n-    static void setVolatile(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setVolatile(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -183,1 +185,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -186,1 +188,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -191,1 +193,1 @@\n-    static $type$ getAcquire(VarHandle ob, Object obb, long base) {\n+    static $type$ getAcquire(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -193,1 +195,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -197,1 +199,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -201,1 +203,1 @@\n-    static void setRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -203,1 +205,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -206,1 +208,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -211,1 +213,1 @@\n-    static $type$ getOpaque(VarHandle ob, Object obb, long base) {\n+    static $type$ getOpaque(VarHandle ob, Object obb, Object encl, long base, long offset) {\n@@ -213,1 +215,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, true);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, true);\n@@ -217,1 +219,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask)));\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask)));\n@@ -221,1 +223,1 @@\n-    static void setOpaque(VarHandle ob, Object obb, long base, $type$ value) {\n+    static void setOpaque(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -223,1 +225,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -226,1 +228,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -232,1 +234,1 @@\n-    static boolean compareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean compareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -234,1 +236,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -237,1 +239,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -242,1 +244,1 @@\n-    static $type$ compareAndExchange(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchange(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -244,1 +246,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -248,1 +250,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -253,1 +255,1 @@\n-    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -255,1 +257,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -259,1 +261,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -264,1 +266,1 @@\n-    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static $type$ compareAndExchangeRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -266,1 +268,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -270,1 +272,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -275,1 +277,1 @@\n-    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetPlain(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -277,1 +279,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -280,1 +282,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -285,1 +287,1 @@\n-    static boolean weakCompareAndSet(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -287,1 +289,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -290,1 +292,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -295,1 +297,1 @@\n-    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -297,1 +299,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -300,1 +302,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -305,1 +307,1 @@\n-    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, long base, $type$ expected, $type$ value) {\n+    static boolean weakCompareAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ expected, $type$ value) {\n@@ -307,1 +309,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -310,1 +312,1 @@\n-                offsetNonPlain(bb, base, handle.alignmentMask),\n+                offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -315,1 +317,1 @@\n-    static $type$ getAndSet(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSet(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -317,1 +319,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -321,1 +323,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -326,1 +328,1 @@\n-    static $type$ getAndSetAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -328,1 +330,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -332,1 +334,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -337,1 +339,1 @@\n-    static $type$ getAndSetRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndSetRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -339,1 +341,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -343,1 +345,1 @@\n-                                  offsetNonPlain(bb, base, handle.alignmentMask),\n+                                  offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -350,1 +352,1 @@\n-    static $type$ getAndAdd(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAdd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -352,1 +354,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -356,1 +358,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -359,1 +361,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -364,1 +366,1 @@\n-    static $type$ getAndAddAcquire(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -366,1 +368,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -370,1 +372,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -373,1 +375,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -378,1 +380,1 @@\n-    static $type$ getAndAddRelease(VarHandle ob, Object obb, long base, $type$ delta) {\n+    static $type$ getAndAddRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ delta) {\n@@ -380,1 +382,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -384,1 +386,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -387,1 +389,1 @@\n-            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), delta);\n+            return getAndAddConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), delta);\n@@ -406,1 +408,1 @@\n-    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOr(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -408,1 +410,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -412,1 +414,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -415,1 +417,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -420,1 +422,1 @@\n-    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -422,1 +424,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -426,1 +428,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -429,1 +431,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -434,1 +436,1 @@\n-    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseOrAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -436,1 +438,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -440,1 +442,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -443,1 +445,1 @@\n-            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseOrConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -460,1 +462,1 @@\n-    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAnd(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -462,1 +464,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -466,1 +468,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -469,1 +471,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -474,1 +476,1 @@\n-    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -476,1 +478,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -480,1 +482,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -483,1 +485,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -488,1 +490,1 @@\n-    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseAndAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -490,1 +492,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -494,1 +496,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -497,1 +499,1 @@\n-            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseAndConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -515,1 +517,1 @@\n-    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXor(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -517,1 +519,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -521,1 +523,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -524,1 +526,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -529,1 +531,1 @@\n-    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorRelease(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -531,1 +533,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -535,1 +537,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -538,1 +540,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n@@ -543,1 +545,1 @@\n-    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, long base, $type$ value) {\n+    static $type$ getAndBitwiseXorAcquire(VarHandle ob, Object obb, Object encl, long base, long offset, $type$ value) {\n@@ -545,1 +547,1 @@\n-        AbstractMemorySegmentImpl bb = checkReadOnly(obb, false);\n+        AbstractMemorySegmentImpl bb = checkSegment(obb, encl, base, false);\n@@ -549,1 +551,1 @@\n-                    offsetNonPlain(bb, base, handle.alignmentMask),\n+                    offsetNonPlain(bb, base, offset, handle.alignmentMask),\n@@ -552,1 +554,1 @@\n-            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, handle.alignmentMask), value);\n+            return getAndBitwiseXorConvEndianWithCAS(bb, offsetNonPlain(bb, base, offset, handle.alignmentMask), value);\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/X-VarHandleSegmentView.java.template","additions":120,"deletions":118,"binary":false,"changes":238,"status":"modified"},{"patch":"@@ -157,3 +157,3 @@\n- * specific. In the JDK the default set of root modules contains every module\n- * that is observable on the upgrade module path or among the system modules,\n- * and that exports at least one package without qualification. <\/p>\n+ * specific. In the JDK the default set of root modules contains every module on\n+ * the upgrade module path or among the system modules that exports at least one\n+ * package, without qualification. <\/p>\n","filename":"src\/java.base\/share\/classes\/java\/lang\/module\/package-info.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -168,0 +168,8 @@\n+    \/\/ Creates a new root constructor with a custom accessor for serialization hooks.\n+    Constructor<T> newWithAccessor(ConstructorAccessor accessor) {\n+        var res = new Constructor<>(clazz, parameterTypes, exceptionTypes, modifiers, slot,\n+                signature, annotations, parameterAnnotations);\n+        res.constructorAccessor = accessor;\n+        return res;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Constructor.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -176,15 +176,0 @@\n-    \/**\n-     * Make a copy of a leaf method.\n-     *\/\n-    Method leafCopy() {\n-        if (this.root == null)\n-            throw new IllegalArgumentException(\"Can only leafCopy a non-root Method\");\n-\n-        Method res = new Method(clazz, name, parameterTypes, returnType,\n-                exceptionTypes, modifiers, slot, signature,\n-                annotations, parameterAnnotations, annotationDefault);\n-        res.root = root;\n-        res.methodAccessor = methodAccessor;\n-        return res;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/Method.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import jdk.internal.reflect.MethodAccessor;\n+import jdk.internal.access.JavaLangReflectAccess;\n@@ -34,53 +34,3 @@\n-\n-class ReflectAccess implements jdk.internal.access.JavaLangReflectAccess {\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations)\n-    {\n-        return new Constructor<>(declaringClass,\n-                                  parameterTypes,\n-                                  checkedExceptions,\n-                                  modifiers,\n-                                  slot,\n-                                  signature,\n-                                  annotations,\n-                                  parameterAnnotations);\n-    }\n-\n-    public MethodAccessor getMethodAccessor(Method m) {\n-        return m.getMethodAccessor();\n-    }\n-\n-    public void setMethodAccessor(Method m, MethodAccessor accessor) {\n-        m.setMethodAccessor(accessor);\n-    }\n-\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return c.getConstructorAccessor();\n-    }\n-\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        c.setConstructorAccessor(accessor);\n-    }\n-\n-    public int getConstructorSlot(Constructor<?> c) {\n-        return c.getSlot();\n-    }\n-\n-    public String getConstructorSignature(Constructor<?> c) {\n-        return c.getSignature();\n-    }\n-\n-    public byte[] getConstructorAnnotations(Constructor<?> c) {\n-        return c.getRawAnnotations();\n-    }\n-\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c) {\n-        return c.getRawParameterAnnotations();\n+final class ReflectAccess implements JavaLangReflectAccess {\n+    public <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor) {\n+        return original.newWithAccessor(accessor);\n@@ -108,3 +58,0 @@\n-    public Method      leafCopyMethod(Method arg) {\n-        return arg.leafCopy();\n-    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/reflect\/ReflectAccess.java","additions":5,"deletions":58,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-import java.util.stream.Stream;\n+\n@@ -53,0 +53,1 @@\n+import jdk.internal.constant.MethodTypeDescImpl;\n@@ -84,0 +85,2 @@\n+    private static final ClassDesc CD_BiPredicate = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/function\/BiPredicate;\");\n+    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n@@ -85,1 +88,11 @@\n-    private static final MethodType TYPES_SWITCH_TYPE = MethodType.methodType(int.class,\n+    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n+            MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int, ConstantDescs.CD_int, ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int);\n+    private static final MethodTypeDesc MTD_TYPE_SWITCH_EXTRA = MethodTypeDescImpl.ofValidated(ConstantDescs.CD_int,\n+            ConstantDescs.CD_Object,\n+            ConstantDescs.CD_int,\n+            CD_BiPredicate,\n+            ConstantDescs.CD_List);\n+    private static final MethodType MT_TYPE_SWITCH_EXTRA = MethodType.methodType(int.class,\n@@ -90,7 +103,3 @@\n-\n-    private static final MethodTypeDesc TYPES_SWITCH_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(Ljava\/lang\/Object;ILjava\/util\/function\/BiPredicate;Ljava\/util\/List;)I\");\n-    private static final MethodTypeDesc CHECK_INDEX_DESCRIPTOR =\n-            MethodTypeDesc.ofDescriptor(\"(II)I\");\n-\n-    private static final ClassDesc CD_Objects = ReferenceClassDescImpl.ofValidated(\"Ljava\/util\/Objects;\");\n+    private static final MethodType MT_TYPE_SWITCH = MethodType.methodType(int.class,\n+            Object.class,\n+            int.class);\n@@ -183,1 +192,1 @@\n-\n+        target = target.asType(invocationType);\n@@ -275,1 +284,0 @@\n-        requireNonNull(labels);\n@@ -277,1 +285,1 @@\n-        labels = labels.clone();\n+        labels = labels.clone(); \/\/ implicit null check\n@@ -304,1 +312,0 @@\n-\n@@ -437,0 +444,27 @@\n+    \/**\n+     * Check if the labelConstants can be converted statically to bytecode, or\n+     * whether we'll need to compute and pass in extra information at the call site.\n+     *\/\n+    private static boolean needsExtraInfo(Class<?> selectorType, Object[] labelConstants) {\n+        for (int idx = labelConstants.length - 1; idx >= 0; idx--) {\n+            Object currentLabel = labelConstants[idx];\n+            if (currentLabel instanceof Class<?> classLabel) {\n+                \/\/ No extra info needed for exact matches or primitives\n+                if (unconditionalExactnessCheck(selectorType, classLabel) || classLabel.isPrimitive()) {\n+                    continue;\n+                }\n+                \/\/ Hidden classes - or arrays thereof - can't be nominally\n+                \/\/ represented. Passed in as arguments.\n+                while (classLabel.isArray()) {\n+                    classLabel = classLabel.getComponentType();\n+                }\n+                if (classLabel.isHidden()) {\n+                    return true;\n+                }\n+            } else if (currentLabel instanceof EnumDesc<?>) {\n+                \/\/ EnumDescs labels needs late binding\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n@@ -470,3 +504,4 @@\n-            record Element(Label target, Label next, Object caseLabel) { }\n-            List<Element> cases = new ArrayList<>();\n-            List<SwitchCase> switchCases = new ArrayList<>();\n+            Label[] caseTargets = new Label[labelConstants.length];\n+            Label[] caseNext = new Label[labelConstants.length];\n+            Object[] caseLabels = new Object[labelConstants.length];\n+            SwitchCase[] switchCases = new SwitchCase[labelConstants.length];\n@@ -481,1 +516,1 @@\n-                    next = cases.getLast().next();\n+                    next = caseNext[idx + 1];\n@@ -483,1 +518,1 @@\n-                    next = cases.getLast().target();\n+                    next = caseTargets[idx + 1];\n@@ -486,2 +521,4 @@\n-                cases.add(new Element(target, next, currentLabel));\n-                switchCases.add(SwitchCase.of(idx, target));\n+                caseTargets[idx] = target;\n+                caseNext[idx] = next;\n+                caseLabels[idx] = currentLabel;\n+                switchCases[idx] = SwitchCase.of(idx, target);\n@@ -489,8 +526,6 @@\n-            cases = cases.reversed();\n-            switchCases = switchCases.reversed();\n-            cb.tableswitch(0, labelConstants.length - 1, dflt, switchCases);\n-            for (int idx = 0; idx < cases.size(); idx++) {\n-                Element element = cases.get(idx);\n-                Label next = element.next();\n-                cb.labelBinding(element.target());\n-                if (element.caseLabel() instanceof Class<?> classLabel) {\n+            cb.tableswitch(0, labelConstants.length - 1, dflt, Arrays.asList(switchCases));\n+            for (int idx = 0; idx < labelConstants.length; idx++) {\n+                Label next = caseNext[idx];\n+                Object caseLabel = caseLabels[idx];\n+                cb.labelBinding(caseTargets[idx]);\n+                if (caseLabel instanceof Class<?> classLabel) {\n@@ -580,1 +615,1 @@\n-                } else if (element.caseLabel() instanceof EnumDesc<?> enumLabel) {\n+                } else if (caseLabel instanceof EnumDesc<?> enumLabel) {\n@@ -590,1 +625,1 @@\n-                    cb.invokeinterface(referenceClassDesc(BiPredicate.class),\n+                    cb.invokeinterface(CD_BiPredicate,\n@@ -596,1 +631,1 @@\n-                } else if (element.caseLabel() instanceof String stringLabel) {\n+                } else if (caseLabel instanceof String stringLabel) {\n@@ -604,1 +639,1 @@\n-                } else if (element.caseLabel() instanceof Integer integerLabel) {\n+                } else if (caseLabel instanceof Integer integerLabel) {\n@@ -629,5 +664,5 @@\n-                } else if ((element.caseLabel() instanceof Long ||\n-                        element.caseLabel() instanceof Float ||\n-                        element.caseLabel() instanceof Double ||\n-                        element.caseLabel() instanceof Boolean)) {\n-                    if (element.caseLabel() instanceof Boolean c) {\n+                } else if ((caseLabel instanceof Long ||\n+                        caseLabel instanceof Float ||\n+                        caseLabel instanceof Double ||\n+                        caseLabel instanceof Boolean)) {\n+                    if (caseLabel instanceof Boolean c) {\n@@ -636,1 +671,1 @@\n-                        cb.loadConstant((ConstantDesc) element.caseLabel());\n+                        cb.loadConstant((ConstantDesc) caseLabel);\n@@ -638,1 +673,1 @@\n-                    var caseLabelWrapper = Wrapper.forWrapperType(element.caseLabel().getClass());\n+                    var caseLabelWrapper = Wrapper.forWrapperType(caseLabel.getClass());\n@@ -651,1 +686,1 @@\n-                            element.caseLabel().getClass());\n+                            caseLabel.getClass());\n@@ -657,1 +692,1 @@\n-            cb.loadConstant(cases.size());\n+            cb.loadConstant(labelConstants.length);\n@@ -666,2 +701,3 @@\n-        List<EnumDesc<?>> enumDescs = new ArrayList<>();\n-        List<Class<?>> extraClassLabels = new ArrayList<>();\n+        boolean addExtraInfo = needsExtraInfo(selectorType, labelConstants);\n+        List<EnumDesc<?>> enumDescs = addExtraInfo ? new ArrayList<>() : null;\n+        List<Class<?>> extraClassLabels = addExtraInfo ? new ArrayList<>() : null;\n@@ -673,1 +709,1 @@\n-                                       TYPES_SWITCH_DESCRIPTOR,\n+                                       addExtraInfo ? MTD_TYPE_SWITCH_EXTRA : MTD_TYPE_SWITCH,\n@@ -684,7 +720,5 @@\n-                                                        TYPES_SWITCH_TYPE);\n-            typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n-                                                       List.copyOf(extraClassLabels));\n-            typeSwitch = MethodHandles.explicitCastArguments(typeSwitch,\n-                                                             MethodType.methodType(int.class,\n-                                                                                   selectorType,\n-                                                                                   int.class));\n+                                                        addExtraInfo ? MT_TYPE_SWITCH_EXTRA : MT_TYPE_SWITCH);\n+            if (addExtraInfo) {\n+                typeSwitch = MethodHandles.insertArguments(typeSwitch, 2, new ResolvedEnumLabels(caller, enumDescs.toArray(new EnumDesc<?>[0])),\n+                        List.copyOf(extraClassLabels));\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/runtime\/SwitchBootstraps.java","additions":85,"deletions":51,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -398,1 +398,1 @@\n-     *          socket is already bound.\n+     *          socket is already bound or is closed.\n@@ -425,0 +425,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -464,1 +469,1 @@\n-     *         may be thrown if connect fails, for example, if the\n+     *         if the port is 0 or connect fails, for example, if the\n@@ -487,0 +492,5 @@\n+     * <p> If this socket is already connected, then this method will attempt to\n+     * connect to the given address. If this connect fails then the state of\n+     * this socket is unknown - it may or may not be connected to the address\n+     * that it was previously connected to.\n+     *\n@@ -646,1 +656,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -705,1 +715,1 @@\n-     * @throws     IOException  if an I\/O error occurs.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n@@ -773,1 +783,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -787,1 +798,2 @@\n-     * @throws SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -823,2 +835,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -844,2 +856,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -881,2 +893,2 @@\n-     * @throws    SocketException if there is an error in\n-     * the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -902,1 +914,2 @@\n-     * @throws    SocketException if there is an error in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -962,2 +975,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -986,3 +999,2 @@\n-     * @throws  SocketException\n-     *          if there is an error in the underlying protocol, such as an UDP\n-     *          error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1006,2 +1018,2 @@\n-     * @throws    SocketException if there is an error\n-     * in the underlying protocol, such as an UDP error.\n+     * @throws SocketException if there is an error in the underlying protocol,\n+     *         such as an UDP error, or the socket is closed.\n@@ -1052,2 +1064,2 @@\n-     * @throws SocketException if there is an error setting the\n-     * traffic class or type-of-service\n+     * @throws SocketException if there is an error setting the traffic class or type-of-service,\n+     *         or the socket is closed.\n@@ -1077,2 +1089,2 @@\n-     * @throws SocketException if there is an error obtaining the\n-     * traffic class or type-of-service value.\n+     * @throws SocketException if there is an error obtaining the traffic class\n+     *         or type-of-service value, or the socket is closed.\n@@ -1095,0 +1107,3 @@\n+     *\n+     * <p> Once closed, several of the methods defined by this class will throw\n+     * an exception if invoked on the closed socket.\n@@ -1302,1 +1317,1 @@\n-     *         multicasting\n+     *         multicasting, or the socket is closed\n@@ -1346,1 +1361,1 @@\n-     *         is not a multicast address.\n+     *         is not a multicast address, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/DatagramSocket.java","additions":42,"deletions":27,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -224,1 +224,1 @@\n-     *             while setting the default time-to-live value\n+     *             while setting the default time-to-live value, or the socket is closed.\n@@ -253,1 +253,1 @@\n-     *          default time-to-live value\n+     *          default time-to-live value, or the socket is closed.\n@@ -268,1 +268,1 @@\n-     * while getting the default time-to-live value\n+     *            while getting the default time-to-live value, or the socket is closed.\n@@ -288,1 +288,1 @@\n-     * getting the default time-to-live value\n+     *            getting the default time-to-live value, or the socket is closed.\n@@ -314,1 +314,1 @@\n-     *             or the platform does not support multicasting\n+     *             or the platform does not support multicasting, or the socket is closed.\n@@ -342,1 +342,1 @@\n-     *             or when the address is not a multicast address.\n+     *             or when the address is not a multicast address, or the socket is closed.\n@@ -396,1 +396,1 @@\n-     *             the underlying protocol, such as a TCP error.\n+     *             the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -416,1 +416,1 @@\n-     *             underlying protocol, such as a TCP error.\n+     *             underlying protocol, such as a TCP error, or the socket is closed.\n@@ -437,1 +437,1 @@\n-     * the underlying protocol, such as a TCP error.\n+     *            the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -457,1 +457,1 @@\n-     *         the underlying protocol, such as a TCP error.\n+     *         the underlying protocol, such as a TCP error, or the socket is closed.\n@@ -479,1 +479,2 @@\n-     * @throws     SocketException if an error occurs while setting the value\n+     * @throws     SocketException if an error occurs while setting the value, or\n+     *             the socket is closed.\n@@ -496,1 +497,2 @@\n-     * @throws     SocketException if an error occurs while getting the value\n+     * @throws     SocketException if an error occurs while getting the value, or\n+     *             the socket is closed.\n@@ -537,2 +539,1 @@\n-     * @throws     IOException is raised if an error occurs i.e\n-     *             error while setting ttl.\n+     * @throws     IOException  if an I\/O error occurs, or the socket is closed.\n","filename":"src\/java.base\/share\/classes\/java\/net\/MulticastSocket.java","additions":15,"deletions":14,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -655,1 +655,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -657,0 +656,3 @@\n+            roundedNumber = roundedNumber \/ divisor;\n+            decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -663,2 +665,0 @@\n-                    roundedNumber = roundedNumber \/ divisor;\n-                    decimalFormat.setDigitList(roundedNumber, isNegative, getMaximumFractionDigits());\n@@ -737,1 +737,0 @@\n-                val = getNumberValue(number, divisor);\n@@ -739,0 +738,12 @@\n+            var noFraction = number % divisor == 0;\n+            if (noFraction) {\n+                number = number \/ divisor;\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store\n+                \/\/ the value in double and follow double path instead of\n+                \/\/ long path\n+                double dNumber = (double) number \/ divisor;\n+                decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -744,18 +755,4 @@\n-                    if ((number % divisor == 0)) {\n-                        number = number \/ divisor;\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store\n-                        \/\/ the value in double and follow double path instead of\n-                        \/\/ long path\n-                        double dNumber = (double) number \/ divisor;\n-                        decimalFormat.setDigitList(dNumber, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                            isNegative, noFraction, getMaximumIntegerDigits(),\n+                            getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                            getMinimumFractionDigits());\n@@ -836,1 +833,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -838,0 +834,3 @@\n+            number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+            decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -843,2 +842,0 @@\n-                    number = number.divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                    decimalFormat.setDigitList(number, isNegative, getMaximumFractionDigits());\n@@ -907,1 +904,0 @@\n-                val = getNumberValue(number.doubleValue(), divisor.doubleValue());\n@@ -909,0 +905,14 @@\n+            var noFraction = number.mod(new BigInteger(divisor.toString()))\n+                    .compareTo(BigInteger.ZERO) == 0;\n+            if (noFraction) {\n+                number = number.divide(new BigInteger(divisor.toString()));\n+                decimalFormat.setDigitList(number, isNegative, 0);\n+            } else {\n+                \/\/ To avoid truncation of fractional part store the value in\n+                \/\/ BigDecimal and follow BigDecimal path instead of\n+                \/\/ BigInteger path\n+                BigDecimal nDecimal = new BigDecimal(number)\n+                        .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n+                decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n+            }\n+            val = decimalFormat.getDigitList().getDouble();\n@@ -914,21 +924,4 @@\n-                    if (number.mod(new BigInteger(divisor.toString()))\n-                            .compareTo(BigInteger.ZERO) == 0) {\n-                        number = number.divide(new BigInteger(divisor.toString()));\n-\n-                        decimalFormat.setDigitList(number, isNegative, 0);\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, true, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    } else {\n-                        \/\/ To avoid truncation of fractional part store the value in\n-                        \/\/ BigDecimal and follow BigDecimal path instead of\n-                        \/\/ BigInteger path\n-                        BigDecimal nDecimal = new BigDecimal(number)\n-                                .divide(new BigDecimal(divisor.toString()), getRoundingMode());\n-                        decimalFormat.setDigitList(nDecimal, isNegative, getMaximumFractionDigits());\n-                        decimalFormat.subformatNumber(result, delegate,\n-                                isNegative, false, getMaximumIntegerDigits(),\n-                                getMinimumIntegerDigits(), getMaximumFractionDigits(),\n-                                getMinimumFractionDigits());\n-                    }\n+                    decimalFormat.subformatNumber(result, delegate,\n+                        isNegative, noFraction, getMaximumIntegerDigits(),\n+                        getMinimumIntegerDigits(), getMaximumFractionDigits(),\n+                        getMinimumFractionDigits());\n","filename":"src\/java.base\/share\/classes\/java\/text\/CompactNumberFormat.java","additions":40,"deletions":47,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -1802,0 +1802,8 @@\n+    \/**\n+     * {@return the {@code DigitList} used by this {@code DecimalFormat} instance}\n+     * Declared as package-private, intended for {@code CompactNumberFormat}.\n+     *\/\n+    DigitList getDigitList() {\n+        return digitList;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/java\/text\/DecimalFormat.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -223,3 +223,3 @@\n-    private final byte BITARRAYMASK = (byte)0x1;\n-    private final int  BYTEPOWER = 3;\n-    private final int  BYTEMASK = (1 << BYTEPOWER) - 1;\n+    private static final byte BITARRAYMASK = (byte)0x1;\n+    private static final int BYTEPOWER = 3;\n+    private static final int BYTEMASK = (1 << BYTEPOWER) - 1;\n","filename":"src\/java.base\/share\/classes\/java\/text\/MergeCollation.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -695,1 +695,4 @@\n-     * does not necessarily equal the previously applied pattern.\n+     * does not necessarily equal the previously applied pattern. The order of\n+     * {@code FormatStyle} matching is not guaranteed. That is, a {@code\n+     * FormatStyle} produced may not be equivalent to the corresponding style passed,\n+     * in the instance that multiple styles are equivalent.\n","filename":"src\/java.base\/share\/classes\/java\/text\/MessageFormat.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1969,0 +1969,8 @@\n+        formatTo(buf);\n+        return buf.toString();\n+    }\n+\n+    \/**\n+     * Prints the toString result to the given buf, avoiding extra string allocations.\n+     *\/\n+    void formatTo(StringBuilder buf) {\n@@ -1972,1 +1980,0 @@\n-        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/LocalDateTime.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1926,1 +1926,4 @@\n-        return dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(29 + offsetStr.length());\n+        dateTime.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetDateTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1401,1 +1401,4 @@\n-        return time.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var buf = new StringBuilder(18 + offsetStr.length());\n+        time.formatTo(buf);\n+        return buf.append(offsetStr).toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/OffsetTime.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -2217,1 +2217,3 @@\n-        String str = dateTime.toString() + offset.toString();\n+        var offsetStr = offset.toString();\n+        var zoneStr = (String) null;\n+        int length = 29 + offsetStr.length();\n@@ -2219,1 +2221,2 @@\n-            str += '[' + zone.toString() + ']';\n+            zoneStr = zone.toString();\n+            length += zoneStr.length() + 2;\n@@ -2221,1 +2224,7 @@\n-        return str;\n+        var buf = new StringBuilder(length);\n+        dateTime.formatTo(buf);\n+        buf.append(offsetStr);\n+        if (zoneStr != null) {\n+            buf.append('[').append(zoneStr).append(']');\n+        }\n+        return buf.toString();\n","filename":"src\/java.base\/share\/classes\/java\/time\/ZonedDateTime.java","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1585,0 +1585,7 @@\n+\n+        @Override\n+        public void sort(Comparator<? super E> c) {\n+            checkForComodification();\n+            root.sortRange(c, offset, offset + size);\n+            updateSizeAndModCount(0);\n+        }\n@@ -1802,1 +1809,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -1804,0 +1810,5 @@\n+        sortRange(c, 0, size);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void sortRange(Comparator<? super E> c, int fromIndex, int toIndex) {\n@@ -1805,1 +1816,1 @@\n-        Arrays.sort((E[]) elementData, 0, size, c);\n+        Arrays.sort((E[]) elementData, fromIndex, toIndex, c);\n","filename":"src\/java.base\/share\/classes\/java\/util\/ArrayList.java","additions":14,"deletions":3,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -166,1 +166,1 @@\n- *    <td>{@link #getFirst() getFirst()}<\/td>\n+ *    <td>{@link #peekFirst() peekFirst()}<\/td>\n","filename":"src\/java.base\/share\/classes\/java\/util\/Deque.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -3024,9 +3024,1 @@\n-    private static class FixedString implements FormatString {\n-        private final String s;\n-        private final int start;\n-        private final int end;\n-        FixedString(String s, int start, int end) {\n-            this.s = s;\n-            this.start = start;\n-            this.end = end;\n-        }\n+    private record FixedString(String s, int start, int end) implements FormatString {\n","filename":"src\/java.base\/share\/classes\/java\/util\/Formatter.java","additions":1,"deletions":9,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -991,1 +991,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(baseloc, LOCALE_CREATOR);\n+            return LocaleCache.cache(baseloc);\n@@ -994,1 +994,1 @@\n-            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+            return LocaleCache.cache(key);\n@@ -998,2 +998,9 @@\n-    private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n-            = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+    private static final class LocaleCache implements Function<Object, Locale> {\n+        private static final ReferencedKeyMap<Object, Locale> LOCALE_CACHE\n+                = ReferencedKeyMap.create(true, ReferencedKeyMap.concurrentHashMapSupplier());\n+\n+        private static final Function<Object, Locale> LOCALE_CREATOR = new LocaleCache();\n+\n+        public static Locale cache(Object key) {\n+            return LOCALE_CACHE.computeIfAbsent(key, LOCALE_CREATOR);\n+        }\n@@ -1001,1 +1008,0 @@\n-    private static final Function<Object, Locale> LOCALE_CREATOR = new Function<>() {\n@@ -1010,1 +1016,1 @@\n-    };\n+    }\n","filename":"src\/java.base\/share\/classes\/java\/util\/Locale.java","additions":12,"deletions":6,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2808,1 +2808,1 @@\n-     * before the given timeout.\n+     * before the given timeout elapsed.\n@@ -2828,1 +2828,1 @@\n-     * otherwise completed before the given timeout.\n+     * otherwise completed before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CompletableFuture.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -103,0 +103,2 @@\n+    private static final Object[] EMPTY_ELEMENTDATA = {};\n+\n@@ -131,1 +133,1 @@\n-        setArray(new Object[0]);\n+        setArray(EMPTY_ELEMENTDATA);\n@@ -146,0 +148,2 @@\n+        else if (c.isEmpty())\n+            es = EMPTY_ELEMENTDATA;\n@@ -162,1 +166,4 @@\n-        setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));\n+        if (toCopyIn.length == 0)\n+            setArray(EMPTY_ELEMENTDATA);\n+        else\n+            setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));\n@@ -536,0 +543,2 @@\n+            else if (len == 1)\n+                newElements = EMPTY_ELEMENTDATA;\n@@ -621,0 +630,5 @@\n+            if (len == 1) {\n+                \/\/ one element exists and that element should be removed\n+                setArray(EMPTY_ELEMENTDATA);\n+                return true;\n+            }\n@@ -807,1 +821,1 @@\n-            setArray(new Object[0]);\n+            setArray(EMPTY_ELEMENTDATA);\n@@ -1025,1 +1039,1 @@\n-        Object[] es = new Object[len];\n+        Object[] es = (len == 0 ? EMPTY_ELEMENTDATA : new Object[len]);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/CopyOnWriteArrayList.java","additions":18,"deletions":4,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -142,7 +142,1 @@\n-     * contention. We approach this by defining the Nodes that we need\n-     * anyway as ThreadLocals, and include in them per-thread index\n-     * and related bookkeeping state. (We can safely reuse per-thread\n-     * nodes rather than creating them fresh each time because slots\n-     * alternate between pointing to a node vs null, so cannot\n-     * encounter ABA problems. However, we do need some care in\n-     * resetting them between uses.)\n+     * contention.\n@@ -150,13 +144,22 @@\n-     * Implementing an effective arena requires allocating a bunch of\n-     * space, so we only do so upon detecting contention (except on\n-     * uniprocessors, where they wouldn't help, so aren't used).\n-     * Otherwise, exchanges use the single-slot slotExchange method.\n-     * On contention, not only must the slots be in different\n-     * locations, but the locations must not encounter memory\n-     * contention due to being on the same cache line (or more\n-     * generally, the same coherence unit).  Because, as of this\n-     * writing, there is no way to determine cacheline size, we define\n-     * a value that is enough for common platforms.  Additionally,\n-     * extra care elsewhere is taken to avoid other false\/unintended\n-     * sharing and to enhance locality, including adding padding (via\n-     * @Contended) to Nodes, embedding \"bound\" as an Exchanger field.\n+     * We approach this by defining the Nodes holding references to\n+     * transfered items as ThreadLocals, and include in them\n+     * per-thread index and related bookkeeping state. We can safely\n+     * reuse per-thread nodes rather than creating them fresh each\n+     * time because slots alternate between pointing to a node vs\n+     * null, so cannot encounter ABA problems. However, we must ensure\n+     * that object transfer fields are reset between uses. Given this,\n+     * Participant nodes can be defined as static ThreadLocals. As\n+     * seen for example in class Striped64, using indices established\n+     * in one instance across others usually improves overall\n+     * performance.  Nodes also include a participant-local random\n+     * number generator.\n+     *\n+     * Spreading out contention requires that the memory locations\n+     * used by the arena slots don't share a cache line -- otherwise,\n+     * the arena would have almost no benefit. We arrange this by\n+     * adding another level of indirection: The arena elements point\n+     * to \"Slots\", each of which is padded using @Contended. We only\n+     * create a single Slot on intialization, adding more when\n+     * needed. The per-thread Participant Nodes may also be subject to\n+     * false-sharing contention, but tend to be more scattered in\n+     * memory, so are unpadded, with some occasional performance impact.\n@@ -166,13 +169,6 @@\n-     * while trying to exchange. By nature of the above algorithm, the\n-     * only kinds of collision that reliably indicate contention are\n-     * when two attempted releases collide -- one of two attempted\n-     * offers can legitimately fail to CAS without indicating\n-     * contention by more than one other thread. (Note: it is possible\n-     * but not worthwhile to more precisely detect contention by\n-     * reading slot values after CAS failures.)  When a thread has\n-     * collided at each slot within the current arena bound, it tries\n-     * to expand the arena size by one. We track collisions within\n-     * bounds by using a version (sequence) number on the \"bound\"\n-     * field, and conservatively reset collision counts when a\n-     * participant notices that bound has been updated (in either\n-     * direction).\n+     * while trying to exchange. And shrink it via \"spinouts\" in which\n+     * threads give up waiting at a slot.  By nature of the above\n+     * algorithm, the only kinds of collision that reliably indicate\n+     * contention are when two attempted releases collide -- one of\n+     * two attempted offers can legitimately fail to CAS without\n+     * indicating contention by more than one other thread.\n@@ -180,25 +176,15 @@\n-     * The effective arena size is reduced (when there is more than\n-     * one slot) by giving up on waiting after a while and trying to\n-     * decrement the arena size on expiration. The value of \"a while\"\n-     * is an empirical matter.  We implement by piggybacking on the\n-     * use of spin->yield->block that is essential for reasonable\n-     * waiting performance anyway -- in a busy exchanger, offers are\n-     * usually almost immediately released, in which case context\n-     * switching on multiprocessors is extremely slow\/wasteful.  Arena\n-     * waits just omit the blocking part, and instead cancel. The spin\n-     * count is empirically chosen to be a value that avoids blocking\n-     * 99% of the time under maximum sustained exchange rates on a\n-     * range of test machines. Spins and yields entail some limited\n-     * randomness (using a cheap xorshift) to avoid regular patterns\n-     * that can induce unproductive grow\/shrink cycles. (Using a\n-     * pseudorandom also helps regularize spin cycle duration by\n-     * making branches unpredictable.)  Also, during an offer, a\n-     * waiter can \"know\" that it will be released when its slot has\n-     * changed, but cannot yet proceed until match is set.  In the\n-     * mean time it cannot cancel the offer, so instead spins\/yields.\n-     * Note: It is possible to avoid this secondary check by changing\n-     * the linearization point to be a CAS of the match field (as done\n-     * in one case in the Scott & Scherer DISC paper), which also\n-     * increases asynchrony a bit, at the expense of poorer collision\n-     * detection and inability to always reuse per-thread nodes. So\n-     * the current scheme is typically a better tradeoff.\n+     * Arena size (the value of field \"bound\") is controlled by random\n+     * sampling. On each miss (collision or spinout), a thread chooses\n+     * a new random index within the arena.  Upon the third collision\n+     * with the same current bound, it tries to grow the arena. And\n+     * upon the second spinout, it tries to shrink. The asymmetry in\n+     * part reflects relative costs, and reduces flailing. Because\n+     * they cannot be changed without also changing the sampling\n+     * strategy, these rules are directly incorporated into uses of\n+     * the xchg \"misses\" variable.  The bound field is tagged with\n+     * sequence numbers to reduce stale decisions. Uniform random\n+     * indices are generated using XorShift with enough bits so that\n+     * bias (See Knuth TAoCP vol 2) is negligible for moduli used here\n+     * (at most 256) without requiring rejection tests. Using\n+     * nonuniform randoms with greater weight to higher indices is\n+     * also possible but does not seem worthwhile in practice.\n@@ -206,11 +192,15 @@\n-     * On collisions, indices traverse the arena cyclically in reverse\n-     * order, restarting at the maximum index (which will tend to be\n-     * sparsest) when bounds change. (On expirations, indices instead\n-     * are halved until reaching 0.) It is possible (and has been\n-     * tried) to use randomized, prime-value-stepped, or double-hash\n-     * style traversal instead of simple cyclic traversal to reduce\n-     * bunching.  But empirically, whatever benefits these may have\n-     * don't overcome their added overhead: We are managing operations\n-     * that occur very quickly unless there is sustained contention,\n-     * so simpler\/faster control policies work better than more\n-     * accurate but slower ones.\n+     * These mechanics rely on a reasonable choice of constant SPINS.\n+     * The time cost of SPINS * Thread.onSpinWait() should be at least\n+     * the expected cost of a park\/unpark context switch, and larger\n+     * than that of two failed CASes, but still small enough to avoid\n+     * excessive delays during arena shrinkage.  We also deal with the\n+     * possibility that when an offering thread waits for a release,\n+     * spin-waiting would be useless because the releasing thread is\n+     * descheduled. On multiprocessors, we cannot know this in\n+     * general. But when Virtual Threads are used, method\n+     * ForkJoinWorkerThread.hasKnownQueuedWork serves as a guide to\n+     * whether to spin or immediately block, allowing a context switch\n+     * that may enable a releaser.  Note also that when many threads\n+     * are being run on few cores, enountering enough collisions to\n+     * trigger arena growth is rare, and soon followed by shrinkage,\n+     * so this doesn't require special handling.\n@@ -218,5 +208,5 @@\n-     * Because we use expiration for arena size control, we cannot\n-     * throw TimeoutExceptions in the timed version of the public\n-     * exchange method until the arena size has shrunken to zero (or\n-     * the arena isn't enabled). This may delay response to timeout\n-     * but is still within spec.\n+     * The basic exchange mechanics rely on checks that Node item\n+     * fields are not null, which doesn't work when offered items are\n+     * null. We trap this case by translating nulls to the\n+     * (un-Exchangeable) value of the static Participant\n+     * reference.\n@@ -224,10 +214,8 @@\n-     * Essentially all of the implementation is in methods\n-     * slotExchange and arenaExchange. These have similar overall\n-     * structure, but differ in too many details to combine. The\n-     * slotExchange method uses the single Exchanger field \"slot\"\n-     * rather than arena array elements. However, it still needs\n-     * minimal collision detection to trigger arena construction.\n-     * (The messiest part is making sure interrupt status and\n-     * InterruptedExceptions come out right during transitions when\n-     * both methods may be called. This is done by using null return\n-     * as a sentinel to recheck interrupt status.)\n+     * Essentially all of the implementation is in method xchg.  As is\n+     * too common in this sort of code, most of the logic relies on\n+     * reads of fields that are maintained as local variables so can't\n+     * be nicely factored. It is structured as a main loop with a\n+     * leading volatile read (of field bound), that causes others to\n+     * be freshly read even though declared in plain mode.  We don't\n+     * use compareAndExchange that would otherwise save some re-reads\n+     * because of the need to recheck indices and bounds on failures.\n@@ -235,18 +223,15 @@\n-     * As is too common in this sort of code, methods are monolithic\n-     * because most of the logic relies on reads of fields that are\n-     * maintained as local variables so can't be nicely factored --\n-     * mainly, here, bulky spin->yield->block\/cancel code.  Note that\n-     * field Node.item is not declared as volatile even though it is\n-     * read by releasing threads, because they only do so after CAS\n-     * operations that must precede access, and all uses by the owning\n-     * thread are otherwise acceptably ordered by other operations.\n-     * (Because the actual points of atomicity are slot CASes, it\n-     * would also be legal for the write to Node.match in a release to\n-     * be weaker than a full volatile write. However, this is not done\n-     * because it could allow further postponement of the write,\n-     * delaying progress.)\n-     *\/\n-\n-    \/**\n-     * The index distance (as a shift value) between any two used slots\n-     * in the arena, spacing them out to avoid false sharing.\n+     * Support for optional timeouts in a single method adds further\n+     * complexity. Note that for the sake of arena bounds control,\n+     * time bounds must be ignored during spinouts, which may delay\n+     * TimeoutExceptions (but no more so than would excessive context\n+     * switching that could occur otherwise).  Responses to\n+     * interruption are handled similarly, postponing commitment to\n+     * throw InterruptedException until successfully cancelled.\n+     *\n+     * Design differences from previous releases include:\n+     * * Accommodation of VirtualThreads.\n+     * * Use of Slots vs spaced indices for the arena and static\n+     *   ThreadLocals, avoiding separate arena vs non-arena modes.\n+     * * Use of random sampling for grow\/shrink decisions, with typically\n+     *   faster and more stable adaptation (as was mentioned as a\n+     *   possible improvement in previous version).\n@@ -254,1 +239,0 @@\n-    private static final int ASHIFT = 5;\n@@ -258,3 +242,3 @@\n-     * arena size is MMASK + 1. Must be a power of two minus one, less\n-     * than (1<<(31-ASHIFT)). The cap of 255 (0xff) more than suffices\n-     * for the expected scaling limits of the main algorithms.\n+     * arena size is MMASK + 1. Must be a power of two minus one. The\n+     * cap of 255 (0xff) more than suffices for the expected scaling\n+     * limits of the main algorithms.\n@@ -270,3 +254,0 @@\n-    \/** The number of CPUs, for sizing and spin control *\/\n-    private static final int NCPU = Runtime.getRuntime().availableProcessors();\n-\n@@ -274,10 +255,2 @@\n-     * The maximum slot index of the arena: The number of slots that\n-     * can in principle hold all threads without contention, or at\n-     * most the maximum indexable value.\n-     *\/\n-    static final int FULL = (NCPU >= (MMASK << 1)) ? MMASK : NCPU >>> 1;\n-\n-    \/**\n-     * The bound for spins while waiting for a match. The actual\n-     * number of iterations will on average be about twice this value\n-     * due to randomization. Note: Spinning is disabled when NCPU==1.\n+     * The bound for spins while waiting for a match before either\n+     * blocking or possibly shrinking arena.\n@@ -288,10 +261,1 @@\n-     * Value representing null arguments\/returns from public\n-     * methods. Needed because the API originally didn't disallow null\n-     * arguments, which it should have.\n-     *\/\n-    private static final Object NULL_ITEM = new Object();\n-\n-    \/**\n-     * Sentinel value returned by internal exchange methods upon\n-     * timeout, to avoid need for separate timed versions of these\n-     * methods.\n+     * Padded arena cells to avoid false-sharing memory contention\n@@ -299,1 +263,4 @@\n-    private static final Object TIMED_OUT = new Object();\n+    @jdk.internal.vm.annotation.Contended\n+    static final class Slot {\n+        Node entry;\n+    }\n@@ -303,1 +270,1 @@\n-     * bookkeeping. Padded via @Contended to reduce memory contention.\n+     * bookkeeping.\n@@ -305,1 +272,2 @@\n-    @jdk.internal.vm.annotation.Contended static final class Node {\n+    static final class Node {\n+        long seed;              \/\/ Random seed\n@@ -307,3 +275,0 @@\n-        int bound;              \/\/ Last recorded value of Exchanger.bound\n-        int collides;           \/\/ Number of CAS failures at current bound\n-        int hash;               \/\/ Pseudo-random for spins\n@@ -313,0 +278,4 @@\n+        Node() {\n+            index = -1;         \/\/ initialize on first use\n+            seed = Thread.currentThread().threadId();\n+        }\n@@ -321,1 +290,4 @@\n-     * Per-thread state.\n+     * The participant thread-locals. Because it is impossible to\n+     * exchange, we also use this reference for dealing with null user\n+     * arguments that are translated in and out of this value\n+     * surrounding use.\n@@ -323,1 +295,1 @@\n-    private final Participant participant;\n+    private static final Participant participant = new Participant();\n@@ -326,2 +298,2 @@\n-     * Elimination array; null until enabled (within slotExchange).\n-     * Element accesses use emulation of volatile gets and CAS.\n+     * Elimination array; element accesses use emulation of volatile\n+     * gets and CAS.\n@@ -329,1 +301,1 @@\n-    private volatile Node[] arena;\n+    private final Slot[] arena;\n@@ -332,1 +304,2 @@\n-     * Slot used until contention detected.\n+     * Number of cores, for sizing and spin control. Computed only\n+     * upon construction.\n@@ -334,1 +307,1 @@\n-    private volatile Node slot;\n+    private final int ncpu;\n@@ -337,4 +310,1 @@\n-     * The index of the largest valid arena position, OR'ed with SEQ\n-     * number in high bits, incremented on each update.  The initial\n-     * update from 0 to SEQ is used to ensure that the arena array is\n-     * constructed only once.\n+     * The index of the largest valid arena position.\n@@ -345,1 +315,1 @@\n-     * Exchange function when arenas enabled. See above for explanation.\n+     * Exchange function. See above for explanation.\n@@ -347,5 +317,5 @@\n-     * @param item the (non-null) item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if interrupted; or\n-     * TIMED_OUT if timed and timed out\n+     * @param x the item to exchange\n+     * @param deadline if zero, untimed, else timeout deadline\n+     * @return the other thread's item\n+     * @throws InterruptedException if interrupted while waiting\n+     * @throws TimeoutException if deadline nonzero and timed out\n@@ -353,2 +323,3 @@\n-    private final Object arenaExchange(Object item, boolean timed, long ns) {\n-        Node[] a = arena;\n+    private final V xchg(V x, long deadline)\n+        throws InterruptedException, TimeoutException {\n+        Slot[] a = arena;\n@@ -356,14 +327,39 @@\n-        Node p = participant.get();\n-        for (int i = p.index;;) {                      \/\/ access slot at i\n-            int b, m, c;\n-            int j = (i << ASHIFT) + ((1 << ASHIFT) - 1);\n-            if (j < 0 || j >= alen)\n-                j = alen - 1;\n-            Node q = (Node)AA.getAcquire(a, j);\n-            if (q != null && AA.compareAndSet(a, j, q, null)) {\n-                Object v = q.item;                     \/\/ release\n-                q.match = item;\n-                Thread w = q.parked;\n-                if (w != null)\n-                    LockSupport.unpark(w);\n-                return v;\n+        Participant ps = participant;\n+        Object item = (x == null) ? ps : x;      \/\/ translate nulls\n+        Node p = ps.get();\n+        int i = p.index;                         \/\/ if < 0, move\n+        int misses = 0;                          \/\/ ++ on collide, -- on spinout\n+        Object offered = null;                   \/\/ for cleanup\n+        Object v = null;\n+        outer: for (;;) {\n+            int b, m; Slot s; Node q;\n+            if ((m = (b = bound) & MMASK) == 0)  \/\/ volatile read\n+                i = 0;\n+            if (i < 0 || i > m || i >= alen || (s = a[i]) == null) {\n+                long r = p.seed;                 \/\/ randomly move\n+                r ^= r << 13; r ^= r >>> 7; r ^= r << 17; \/\/ xorShift\n+                i = p.index = (int)((p.seed = r) % (m + 1));\n+            }\n+            else if ((q = s.entry) != null) {    \/\/ try release\n+                if (ENTRY.compareAndSet(s, q, null)) {\n+                    Thread w;\n+                    v = q.item;\n+                    q.match = item;\n+                    if (i == 0 && (w = q.parked) != null)\n+                        LockSupport.unpark(w);\n+                    break;\n+                }\n+                else {                           \/\/ collision\n+                    int nb;\n+                    i = -1;                      \/\/ move index\n+                    if (b != bound)              \/\/ stale\n+                        misses = 0;\n+                    else if (misses <= 2)        \/\/ continue sampling\n+                        ++misses;\n+                    else if ((nb = (b + 1) & MMASK) < alen) {\n+                        misses = 0;              \/\/ try to grow\n+                        if (BOUND.compareAndSet(this, b, b + 1 + SEQ) &&\n+                            a[i = p.index = nb] == null)\n+                            AA.compareAndSet(a, nb, null, new Slot());\n+                    }\n+                }\n@@ -371,12 +367,15 @@\n-            else if (i <= (m = (b = bound) & MMASK) && q == null) {\n-                p.item = item;                         \/\/ offer\n-                if (AA.compareAndSet(a, j, null, p)) {\n-                    long end = (timed && m == 0) ? System.nanoTime() + ns : 0L;\n-                    Thread t = Thread.currentThread(); \/\/ wait\n-                    for (int h = p.hash, spins = SPINS;;) {\n-                        Object v = p.match;\n-                        if (v != null) {\n-                            MATCH.setRelease(p, null);\n-                            p.item = null;             \/\/ clear for next use\n-                            p.hash = h;\n-                            return v;\n+            else {                               \/\/ try offer\n+                if (offered == null)\n+                    offered = p.item = item;\n+                if (ENTRY.compareAndSet(s, null, p)) {\n+                    boolean tryCancel;           \/\/ true if interrupted\n+                    Thread t = Thread.currentThread();\n+                    if (!(tryCancel = t.isInterrupted()) && ncpu > 1 &&\n+                        (i != 0 ||               \/\/ check for busy VTs\n+                         (!ForkJoinWorkerThread.hasKnownQueuedWork()))) {\n+                        for (int j = SPINS; j > 0; --j) {\n+                            if ((v = p.match) != null) {\n+                                MATCH.set(p, null);\n+                                break outer;     \/\/ spin wait\n+                            }\n+                            Thread.onSpinWait();\n@@ -384,7 +383,5 @@\n-                        else if (spins > 0) {\n-                            h ^= h << 1; h ^= h >>> 3; h ^= h << 10; \/\/ xorshift\n-                            if (h == 0)                \/\/ initialize hash\n-                                h = SPINS | (int)t.threadId();\n-                            else if (h < 0 &&          \/\/ approx 50% true\n-                                     (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                                Thread.yield();        \/\/ two yields per wait\n+                    }\n+                    for (long ns = 1L;;) {       \/\/ block or cancel offer\n+                        if ((v = p.match) != null) {\n+                            MATCH.set(p, null);\n+                            break outer;\n@@ -392,8 +389,6 @@\n-                        else if (AA.getAcquire(a, j) != p)\n-                            spins = SPINS;       \/\/ releaser hasn't set match yet\n-                        else if (!t.isInterrupted() && m == 0 &&\n-                                 (!timed ||\n-                                  (ns = end - System.nanoTime()) > 0L)) {\n-                            p.parked = t;              \/\/ minimize window\n-                            if (AA.getAcquire(a, j) == p) {\n-                                if (ns == 0L)\n+                        if (i == 0 && !tryCancel &&\n+                            (deadline == 0L ||\n+                             ((ns = deadline - System.nanoTime()) > 0L))) {\n+                            p.parked = t;        \/\/ emable unpark and recheck\n+                            if (p.match == null) {\n+                                if (deadline == 0L)\n@@ -403,0 +398,1 @@\n+                                tryCancel = t.isInterrupted();\n@@ -406,7 +402,2 @@\n-                        else if (AA.getAcquire(a, j) == p &&\n-                                 AA.compareAndSet(a, j, p, null)) {\n-                            if (m != 0)                \/\/ try to shrink\n-                                BOUND.compareAndSet(this, b, b + SEQ - 1);\n-                            p.item = null;\n-                            p.hash = h;\n-                            i = p.index >>>= 1;        \/\/ descend\n+                        else if (ENTRY.compareAndSet(s, p, null)) { \/\/ cancel\n+                            offered = p.item = null;\n@@ -414,4 +405,13 @@\n-                                return null;\n-                            if (timed && m == 0 && ns <= 0L)\n-                                return TIMED_OUT;\n-                            break;                     \/\/ expired; restart\n+                                throw new InterruptedException();\n+                            if (deadline != 0L && ns <= 0L)\n+                                throw new TimeoutException();\n+                            i = -1;              \/\/ move and restart\n+                            if (bound != b)\n+                                misses = 0;      \/\/ stale\n+                            else if (misses >= 0)\n+                                --misses;        \/\/ continue sampling\n+                            else if ((b & MMASK) != 0) {\n+                                misses = 0;      \/\/ try to shrink\n+                                BOUND.compareAndSet(this, b, b - 1 + SEQ);\n+                            }\n+                            continue outer;\n@@ -421,91 +421,0 @@\n-                else\n-                    p.item = null;                     \/\/ clear offer\n-            }\n-            else {\n-                if (p.bound != b) {                    \/\/ stale; reset\n-                    p.bound = b;\n-                    p.collides = 0;\n-                    i = (i != m || m == 0) ? m : m - 1;\n-                }\n-                else if ((c = p.collides) < m || m == FULL ||\n-                         !BOUND.compareAndSet(this, b, b + SEQ + 1)) {\n-                    p.collides = c + 1;\n-                    i = (i == 0) ? m : i - 1;          \/\/ cyclically traverse\n-                }\n-                else\n-                    i = m + 1;                         \/\/ grow\n-                p.index = i;\n-            }\n-        }\n-    }\n-\n-    \/**\n-     * Exchange function used until arenas enabled. See above for explanation.\n-     *\n-     * @param item the item to exchange\n-     * @param timed true if the wait is timed\n-     * @param ns if timed, the maximum wait time, else 0L\n-     * @return the other thread's item; or null if either the arena\n-     * was enabled or the thread was interrupted before completion; or\n-     * TIMED_OUT if timed and timed out\n-     *\/\n-    private final Object slotExchange(Object item, boolean timed, long ns) {\n-        Node p = participant.get();\n-        Thread t = Thread.currentThread();\n-        if (t.isInterrupted()) \/\/ preserve interrupt status so caller can recheck\n-            return null;\n-\n-        for (Node q;;) {\n-            if ((q = slot) != null) {\n-                if (SLOT.compareAndSet(this, q, null)) {\n-                    Object v = q.item;\n-                    q.match = item;\n-                    Thread w = q.parked;\n-                    if (w != null)\n-                        LockSupport.unpark(w);\n-                    return v;\n-                }\n-                \/\/ create arena on contention, but continue until slot null\n-                if (NCPU > 1 && bound == 0 &&\n-                    BOUND.compareAndSet(this, 0, SEQ))\n-                    arena = new Node[(FULL + 2) << ASHIFT];\n-            }\n-            else if (arena != null)\n-                return null; \/\/ caller must reroute to arenaExchange\n-            else {\n-                p.item = item;\n-                if (SLOT.compareAndSet(this, null, p))\n-                    break;\n-                p.item = null;\n-            }\n-        }\n-\n-        \/\/ await release\n-        int h = p.hash;\n-        long end = timed ? System.nanoTime() + ns : 0L;\n-        int spins = (NCPU > 1) ? SPINS : 1;\n-        Object v;\n-        while ((v = p.match) == null) {\n-            if (spins > 0) {\n-                h ^= h << 1; h ^= h >>> 3; h ^= h << 10;\n-                if (h == 0)\n-                    h = SPINS | (int)t.threadId();\n-                else if (h < 0 && (--spins & ((SPINS >>> 1) - 1)) == 0)\n-                    Thread.yield();\n-            }\n-            else if (slot != p)\n-                spins = SPINS;\n-            else if (!t.isInterrupted() && arena == null &&\n-                     (!timed || (ns = end - System.nanoTime()) > 0L)) {\n-                p.parked = t;\n-                if (slot == p) {\n-                    if (ns == 0L)\n-                        LockSupport.park(this);\n-                    else\n-                        LockSupport.parkNanos(this, ns);\n-                }\n-                p.parked = null;\n-            }\n-            else if (SLOT.compareAndSet(this, p, null)) {\n-                v = timed && ns <= 0L && !t.isInterrupted() ? TIMED_OUT : null;\n-                break;\n@@ -514,4 +423,4 @@\n-        MATCH.setRelease(p, null);\n-        p.item = null;\n-        p.hash = h;\n-        return v;\n+        if (offered != null)                     \/\/ cleanup\n+            p.item = null;\n+        @SuppressWarnings(\"unchecked\") V ret = (v == participant) ? null : (V)v;\n+        return ret;\n@@ -524,1 +433,3 @@\n-        participant = new Participant();\n+        int h = (ncpu = Runtime.getRuntime().availableProcessors()) >>> 1;\n+        int size = (h == 0) ? 1 : (h > MMASK) ? MMASK + 1 : h;\n+        (arena = new Slot[size])[0] = new Slot();\n@@ -560,1 +471,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -562,9 +472,5 @@\n-        Object v;\n-        Node[] a;\n-        Object item = (x == null) ? NULL_ITEM : x; \/\/ translate null args\n-        if (((a = arena) != null ||\n-             (v = slotExchange(item, false, 0L)) == null) &&\n-            (Thread.interrupted() || \/\/ disambiguates null return\n-             (v = arenaExchange(item, false, 0L)) == null))\n-            throw new InterruptedException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        try {\n+            return xchg(x, 0L);\n+        } catch (TimeoutException cannotHappen) {\n+            return null; \/\/ not reached\n+        }\n@@ -615,1 +521,0 @@\n-    @SuppressWarnings(\"unchecked\")\n@@ -618,11 +523,2 @@\n-        Object v;\n-        Object item = (x == null) ? NULL_ITEM : x;\n-        long ns = unit.toNanos(timeout);\n-        if ((arena != null ||\n-             (v = slotExchange(item, true, ns)) == null) &&\n-            (Thread.interrupted() ||\n-             (v = arenaExchange(item, true, ns)) == null))\n-            throw new InterruptedException();\n-        if (v == TIMED_OUT)\n-            throw new TimeoutException();\n-        return (v == NULL_ITEM) ? null : (V)v;\n+        long d = unit.toNanos(timeout) + System.nanoTime();\n+        return xchg(x, (d == 0L) ? 1L : d); \/\/ avoid zero deadline\n@@ -633,1 +529,0 @@\n-    private static final VarHandle SLOT;\n@@ -635,0 +530,1 @@\n+    private static final VarHandle ENTRY;\n@@ -640,1 +536,0 @@\n-            SLOT = l.findVarHandle(Exchanger.class, \"slot\", Node.class);\n@@ -642,1 +537,2 @@\n-            AA = MethodHandles.arrayElementVarHandle(Node[].class);\n+            ENTRY = l.findVarHandle(Slot.class, \"entry\", Node.class);\n+            AA = MethodHandles.arrayElementVarHandle(Slot[].class);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/Exchanger.java","additions":223,"deletions":327,"binary":false,"changes":550,"status":"modified"},{"patch":"@@ -673,1 +673,1 @@\n-     * released soon therafter. This is checked by setting the\n+     * released soon thereafter. This is checked by setting the\n@@ -858,1 +858,1 @@\n-     * exceptions is preferred to throwing InterruptedExecptions,\n+     * exceptions is preferred to throwing InterruptedExceptions,\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinPool.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1075,1 +1075,1 @@\n-     * (possibly exceptionally) before the given timeout and\n+     * (possibly exceptionally) before the given timeout elapsed and\n@@ -1100,1 +1100,1 @@\n-     * (possibly exceptionally) before the given timeout.\n+     * (possibly exceptionally) before the given timeout elapsed.\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinTask.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -42,0 +42,2 @@\n+import jdk.internal.access.JavaLangAccess;\n+import jdk.internal.access.SharedSecrets;\n@@ -205,0 +207,24 @@\n+    \/**\n+     * Returns true if the current task is being executed by a\n+     * ForkJoinWorkerThread that is momentarily known to have one or\n+     * more queued tasks that it could execute immediately. This\n+     * method is approximate and useful only as a heuristic indicator\n+     * within a running task.\n+     *\n+     * @return true if the current task is being executed by a worker\n+     * that has queued work\n+     *\/\n+    static boolean hasKnownQueuedWork() {\n+        ForkJoinWorkerThread wt; ForkJoinPool.WorkQueue q, sq;\n+        ForkJoinPool p; ForkJoinPool.WorkQueue[] qs; int i;\n+        Thread c = JLA.currentCarrierThread();\n+        return ((c instanceof ForkJoinWorkerThread) &&\n+                (p = (wt = (ForkJoinWorkerThread)c).pool) != null &&\n+                (q = wt.workQueue) != null &&\n+                (i = q.source) >= 0 && \/\/ check local and current source queues\n+                (((qs = p.queues) != null && qs.length > i &&\n+                  (sq = qs[i]) != null && sq.top - sq.base > 0) ||\n+                 q.top - q.base > 0));\n+    }\n+    private static final JavaLangAccess JLA = SharedSecrets.getJavaLangAccess();\n+\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ForkJoinWorkerThread.java","additions":26,"deletions":0,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -429,2 +429,2 @@\n-            if (w.isVirtual())             \/\/ don't spin\n-                spin = false;\n+            if (spin && ForkJoinWorkerThread.hasKnownQueuedWork())\n+                spin = false;              \/\/ don't spin\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/LinkedTransferQueue.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -185,0 +185,5 @@\n+    \/**\n+     * Maximum delay is effectively 146 years\n+     *\/\n+    private static final long MAX_NANOS = (Long.MAX_VALUE >>> 1) - 1;\n+\n@@ -528,19 +533,1 @@\n-        return System.nanoTime() +\n-            ((delay < (Long.MAX_VALUE >> 1)) ? delay : overflowFree(delay));\n-    }\n-\n-    \/**\n-     * Constrains the values of all delays in the queue to be within\n-     * Long.MAX_VALUE of each other, to avoid overflow in compareTo.\n-     * This may occur if a task is eligible to be dequeued, but has\n-     * not yet been, while some other task is added with a delay of\n-     * Long.MAX_VALUE.\n-     *\/\n-    private long overflowFree(long delay) {\n-        Delayed head = (Delayed) super.getQueue().peek();\n-        if (head != null) {\n-            long headDelay = head.getDelay(NANOSECONDS);\n-            if (headDelay < 0 && (delay - headDelay < 0))\n-                delay = Long.MAX_VALUE + headDelay;\n-        }\n-        return delay;\n+        return System.nanoTime() + Math.min(delay, MAX_NANOS);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/ScheduledThreadPoolExecutor.java","additions":6,"deletions":19,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -280,0 +280,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, long arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -372,1 +406,0 @@\n-                long nanos;\n@@ -374,6 +407,12 @@\n-                if (!timed)\n-                    LockSupport.park(this);\n-                else if ((nanos = time - System.nanoTime()) > 0L)\n-                    LockSupport.parkNanos(this, nanos);\n-                else\n-                    break;\n+                try {\n+                    long nanos;\n+                    if (!timed)\n+                        LockSupport.park(this);\n+                    else if ((nanos = time - System.nanoTime()) > 0L)\n+                        LockSupport.parkNanos(this, nanos);\n+                    else\n+                        break;\n+                } catch (Error | RuntimeException ex) {\n+                    cancelAcquire(node, interrupted, interruptible); \/\/ cancel & rethrow\n+                    throw ex;\n+                }\n@@ -1297,1 +1336,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1344,1 +1383,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1387,1 +1426,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1431,1 +1470,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1476,1 +1515,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedLongSynchronizer.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -659,0 +659,34 @@\n+    \/**\n+     * Repeatedly invokes acquire, if its execution throws an Error or a Runtime Exception,\n+     * using an Unsafe.park-based backoff\n+     * @param node which to reacquire\n+     * @param arg the acquire argument\n+     *\/\n+    private final void reacquire(Node node, int arg) {\n+        try {\n+            acquire(node, arg, false, false, false, 0L);\n+        } catch (Error | RuntimeException firstEx) {\n+            \/\/ While we currently do not emit an JFR events in this situation, mainly\n+            \/\/ because the conditions under which this happens are such that it\n+            \/\/ cannot be presumed to be possible to actually allocate an event, and\n+            \/\/ using a preconstructed one would have limited value in serviceability.\n+            \/\/ Having said that, the following place would be the more appropriate\n+            \/\/ place to put such logic:\n+            \/\/     emit JFR event\n+\n+            for (long nanos = 1L;;) {\n+                U.park(false, nanos); \/\/ must use Unsafe park to sleep\n+                if (nanos < 1L << 30)            \/\/ max about 1 second\n+                    nanos <<= 1;\n+\n+                try {\n+                    acquire(node, arg, false, false, false, 0L);\n+                } catch (Error | RuntimeException ignored) {\n+                    continue;\n+                }\n+\n+                throw firstEx;\n+            }\n+        }\n+    }\n+\n@@ -751,1 +785,0 @@\n-                long nanos;\n@@ -753,6 +786,12 @@\n-                if (!timed)\n-                    LockSupport.park(this);\n-                else if ((nanos = time - System.nanoTime()) > 0L)\n-                    LockSupport.parkNanos(this, nanos);\n-                else\n-                    break;\n+                try {\n+                    long nanos;\n+                    if (!timed)\n+                        LockSupport.park(this);\n+                    else if ((nanos = time - System.nanoTime()) > 0L)\n+                        LockSupport.parkNanos(this, nanos);\n+                    else\n+                        break;\n+                } catch (Error | RuntimeException ex) {\n+                    cancelAcquire(node, interrupted, interruptible); \/\/ cancel & rethrow\n+                    throw ex;\n+                }\n@@ -1676,1 +1715,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1723,1 +1762,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1766,1 +1805,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1810,1 +1849,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n@@ -1855,1 +1894,1 @@\n-            acquire(node, savedState, false, false, false, 0L);\n+            reacquire(node, savedState);\n","filename":"src\/java.base\/share\/classes\/java\/util\/concurrent\/locks\/AbstractQueuedSynchronizer.java","additions":51,"deletions":12,"binary":false,"changes":63,"status":"modified"},{"patch":"@@ -197,7 +197,10 @@\n-            static final TerminalOp<?, ?> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n-\n-            static final TerminalOp<?, ?> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.REFERENCE, Optional.empty(),\n-                    Optional::isPresent, FindSink.OfRef::new);\n+            static final TerminalOp<?, ?> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<Optional<Object>> isPresent = Optional::isPresent;\n+                Supplier<TerminalSink<Object, Optional<Object>>> newSink\n+                        = FindSink.OfRef::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.REFERENCE,\n+                        Optional.empty(), isPresent, newSink);\n+            }\n@@ -220,6 +223,10 @@\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n-            static final TerminalOp<Integer, OptionalInt> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.INT_VALUE, OptionalInt.empty(),\n-                    OptionalInt::isPresent, FindSink.OfInt::new);\n+            static final TerminalOp<Integer, OptionalInt> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalInt> isPresent = OptionalInt::isPresent;\n+                Supplier<TerminalSink<Integer, OptionalInt>> newSink\n+                        = FindSink.OfInt::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.INT_VALUE,\n+                        OptionalInt.empty(), isPresent, newSink);\n+            }\n@@ -242,6 +249,10 @@\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n-            static final TerminalOp<Long, OptionalLong> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.LONG_VALUE, OptionalLong.empty(),\n-                    OptionalLong::isPresent, FindSink.OfLong::new);\n+            static final TerminalOp<Long, OptionalLong> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalLong> isPresent = OptionalLong::isPresent;\n+                Supplier<TerminalSink<Long, OptionalLong>> newSink\n+                        = FindSink.OfLong::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.LONG_VALUE,\n+                        OptionalLong.empty(), isPresent, newSink);\n+            }\n@@ -264,6 +275,10 @@\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST = new FindOp<>(true,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n-            static final TerminalOp<Double, OptionalDouble> OP_FIND_ANY = new FindOp<>(false,\n-                    StreamShape.DOUBLE_VALUE, OptionalDouble.empty(),\n-                    OptionalDouble::isPresent, FindSink.OfDouble::new);\n+            static final TerminalOp<Double, OptionalDouble> OP_FIND_FIRST, OP_FIND_ANY;\n+            static {\n+                Predicate<OptionalDouble> isPresent = OptionalDouble::isPresent;\n+                Supplier<TerminalSink<Double, OptionalDouble>> newSink\n+                        = FindSink.OfDouble::new;\n+                OP_FIND_FIRST = new FindOp<>(true, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+                OP_FIND_ANY = new FindOp<>(false, StreamShape.DOUBLE_VALUE,\n+                        OptionalDouble.empty(), isPresent, newSink);\n+            }\n","filename":"src\/java.base\/share\/classes\/java\/util\/stream\/FindOps.java","additions":40,"deletions":25,"binary":false,"changes":65,"status":"modified"},{"patch":"@@ -284,2 +284,6 @@\n-     * Ensure that the given module has native access. If not, warn or\n-     * throw exception depending on the configuration.\n+     * Ensure that the given module has native access. If not, warn or throw exception depending on the configuration.\n+     * @param m the module in which native access occurred\n+     * @param owner the owner of the restricted method being called (or the JNI method being bound)\n+     * @param methodName the name of the restricted method being called (or the JNI method being bound)\n+     * @param currentClass the class calling the restricted method (for JNI, this is the same as {@code owner})\n+     * @param jni {@code true}, if this event is related to a JNI method being bound\n@@ -287,1 +291,1 @@\n-    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass);\n+    void ensureNativeAccess(Module m, Class<?> owner, String methodName, Class<?> currentClass, boolean jni);\n@@ -449,0 +453,2 @@\n+    Object stringConcat1(String[] constants);\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangAccess.java","additions":9,"deletions":3,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,2 +32,1 @@\n-    internals of java.lang.reflect. *\/\n-\n+    internals of java.lang.reflect. Use as a last resort! *\/\n@@ -35,25 +34,5 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-      per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public <T> Constructor<T> newConstructor(Class<T> declaringClass,\n-                                             Class<?>[] parameterTypes,\n-                                             Class<?>[] checkedExceptions,\n-                                             int modifiers,\n-                                             int slot,\n-                                             String signature,\n-                                             byte[] annotations,\n-                                             byte[] parameterAnnotations);\n-\n-    \/** Gets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public MethodAccessor getMethodAccessor(Method m);\n-\n-    \/** Sets the MethodAccessor object for a java.lang.reflect.Method *\/\n-    public void setMethodAccessor(Method m, MethodAccessor accessor);\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c);\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor);\n+    \/**\n+     * Creates a new root constructor from the original one, with\n+     * a custom accessor. Used by serialization hooks.\n+     *\/\n+    <T> Constructor<T> newConstructorWithAccessor(Constructor<T> original, ConstructorAccessor accessor);\n@@ -64,12 +43,0 @@\n-    \/** Gets the \"slot\" field from a Constructor (used for serialization) *\/\n-    public int getConstructorSlot(Constructor<?> c);\n-\n-    \/** Gets the \"signature\" field from a Constructor (used for serialization) *\/\n-    public String getConstructorSignature(Constructor<?> c);\n-\n-    \/** Gets the \"annotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorAnnotations(Constructor<?> c);\n-\n-    \/** Gets the \"parameterAnnotations\" field from a Constructor (used for serialization) *\/\n-    public byte[] getConstructorParameterAnnotations(Constructor<?> c);\n-\n@@ -82,1 +49,0 @@\n-    \/\/\n@@ -85,1 +51,0 @@\n-    \/\/\n@@ -90,3 +55,0 @@\n-    \/** Makes a copy of this non-root a Method *\/\n-    public Method      leafCopyMethod(Method arg);\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/JavaLangReflectAccess.java","additions":7,"deletions":45,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -56,1 +56,7 @@\n-    for this purpose, namely the loss of compile-time checking. *\/\n+    for this purpose, namely the loss of compile-time checking.\n+ * <p><strong>\n+ * Usage of these APIs often means bad encapsulation designs,\n+ * increased complexity and lack of sustainability.\n+ * Use this only as a last resort!\n+ * <\/strong>\n+ *\/\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/access\/SharedSecrets.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n@@ -717,1 +717,1 @@\n-            AnnotationReader.writeAnnotations(buf, attr.annotations());\n+            AnnotationReader.writeTypeAnnotations(buf, attr.annotations());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractAttributeMapper.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -148,1 +148,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.loadType(op);\n@@ -176,1 +176,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.storeType(op);\n@@ -803,1 +803,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.loadType(op);\n@@ -834,1 +834,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.storeType(op);\n@@ -996,1 +996,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.returnType(op);\n@@ -1229,1 +1229,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.arrayLoadType(op);\n@@ -1242,1 +1242,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.arrayStoreType(op);\n@@ -1289,1 +1289,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.convertFromType(op);\n@@ -1294,1 +1294,1 @@\n-            return op.secondaryTypeKind();\n+            return BytecodeHelpers.convertToType(op);\n@@ -1307,1 +1307,1 @@\n-            return op.primaryTypeKind();\n+            return BytecodeHelpers.operatorOperandType(op);\n@@ -1313,2 +1313,0 @@\n-        final ConstantDesc constant;\n-\n@@ -1317,6 +1315,0 @@\n-            constant = op.constantValue();\n-        }\n-\n-        @Override\n-        public void writeTo(DirectCodeBuilder writer) {\n-            super.writeTo(writer);\n@@ -1327,1 +1319,1 @@\n-            return constant;\n+            return BytecodeHelpers.intrinsicConstantValue(op);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractInstruction.java","additions":11,"deletions":19,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -537,9 +537,0 @@\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (o == this) { return true; }\n-            if (o instanceof AbstractNamedEntry ne) {\n-                return tag == ne.tag() && name().equals(ref1());\n-            }\n-            return false;\n-        }\n@@ -1042,22 +1033,1 @@\n-    abstract static sealed class PrimitiveEntry<T extends ConstantDesc>\n-            extends AbstractPoolEntry {\n-        protected final T val;\n-\n-        public PrimitiveEntry(ConstantPool constantPool, int tag, int index, T val) {\n-            super(constantPool, tag, index, hash1(tag, val.hashCode()));\n-            this.val = val;\n-        }\n-\n-        public T value() {\n-            return val;\n-        }\n-\n-        public ConstantDesc constantValue() {\n-            return value();\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return \"\" + tag() + value();\n-        }\n-    }\n+    public static final class IntegerEntryImpl extends AbstractPoolEntry implements IntegerEntry {\n@@ -1065,2 +1035,1 @@\n-    public static final class IntegerEntryImpl extends PrimitiveEntry<Integer>\n-            implements IntegerEntry {\n+        private final int val;\n@@ -1069,1 +1038,2 @@\n-            super(cpm, ClassFile.TAG_INTEGER, index, i);\n+            super(cpm, ClassFile.TAG_INTEGER, index, hash1(ClassFile.TAG_INTEGER, Integer.hashCode(i)));\n+            val = i;\n@@ -1085,1 +1055,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1098,1 +1073,1 @@\n-    public static final class FloatEntryImpl extends PrimitiveEntry<Float>\n+    public static final class FloatEntryImpl extends AbstractPoolEntry\n@@ -1101,0 +1076,2 @@\n+        private final float val;\n+\n@@ -1102,1 +1079,2 @@\n-            super(cpm, ClassFile.TAG_FLOAT, index, f);\n+            super(cpm, ClassFile.TAG_FLOAT, index, hash1(ClassFile.TAG_FLOAT, Float.hashCode(f)));\n+            val = f;\n@@ -1118,1 +1096,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1131,1 +1114,3 @@\n-    public static final class LongEntryImpl extends PrimitiveEntry<Long> implements LongEntry {\n+    public static final class LongEntryImpl extends AbstractPoolEntry implements LongEntry {\n+\n+        private final long val;\n@@ -1134,1 +1119,2 @@\n-            super(cpm, ClassFile.TAG_LONG, index, l);\n+            super(cpm, ClassFile.TAG_LONG, index, hash1(ClassFile.TAG_LONG, Long.hashCode(l)));\n+            val = l;\n@@ -1150,1 +1136,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n@@ -1163,1 +1154,3 @@\n-    public static final class DoubleEntryImpl extends PrimitiveEntry<Double> implements DoubleEntry {\n+    public static final class DoubleEntryImpl extends AbstractPoolEntry implements DoubleEntry {\n+\n+        private final double val;\n@@ -1166,1 +1159,2 @@\n-            super(cpm, ClassFile.TAG_DOUBLE, index, d);\n+            super(cpm, ClassFile.TAG_DOUBLE, index, hash1(ClassFile.TAG_DOUBLE, Double.hashCode(d)));\n+            val = d;\n@@ -1182,1 +1176,6 @@\n-            return value();\n+            return val;\n+        }\n+\n+        @Override\n+        public ConstantDesc constantValue() {\n+            return val;\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AbstractPoolEntry.java","additions":43,"deletions":44,"binary":false,"changes":87,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import java.lang.constant.ConstantDesc;\n@@ -36,1 +35,1 @@\n-        implements Annotation, Util.Writable {\n+        implements Annotation {\n@@ -41,10 +40,0 @@\n-    @Override\n-    public void writeTo(BufWriterImpl buf) {\n-        buf.writeIndex(className());\n-        buf.writeU2(elements().size());\n-        for (var e : elements) {\n-            buf.writeIndex(e.name());\n-            AnnotationReader.writeAnnotationValue(buf, e.value());\n-        }\n-    }\n-\n@@ -56,8 +45,0 @@\n-        if (!evps.isEmpty())\n-            sb.append(\" [\");\n-        for (AnnotationElement evp : evps) {\n-            sb.append(evp.name().stringValue())\n-                    .append(\"=\")\n-                    .append(evp.value().toString())\n-                    .append(\", \");\n-        }\n@@ -65,2 +46,1 @@\n-            sb.delete(sb.length()-1, sb.length());\n-            sb.append(\"]\");\n+            sb.append(' ').append(evps);\n@@ -74,2 +54,1 @@\n-            implements AnnotationElement, Util.Writable {\n-\n+            implements AnnotationElement {\n@@ -77,3 +56,2 @@\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeIndex(name());\n-            AnnotationReader.writeAnnotationValue(buf, value());\n+        public String toString() {\n+            return name + \"=\" + value;\n@@ -83,20 +61,0 @@\n-    public sealed interface OfConstantImpl extends AnnotationValue.OfConstant, Util.Writable\n-            permits AnnotationImpl.OfStringImpl, AnnotationImpl.OfDoubleImpl,\n-                    AnnotationImpl.OfFloatImpl, AnnotationImpl.OfLongImpl,\n-                    AnnotationImpl.OfIntegerImpl, AnnotationImpl.OfShortImpl,\n-                    AnnotationImpl.OfCharacterImpl, AnnotationImpl.OfByteImpl,\n-                    AnnotationImpl.OfBooleanImpl {\n-\n-        @Override\n-        default void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(constant());\n-        }\n-\n-        @Override\n-        default ConstantDesc constantValue() {\n-            return constant().constantValue();\n-        }\n-\n-    }\n-\n@@ -104,2 +62,1 @@\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfString {\n-\n+            implements AnnotationValue.OfString {\n@@ -118,2 +75,1 @@\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfDouble {\n-\n+            implements AnnotationValue.OfDouble {\n@@ -132,2 +88,1 @@\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfFloat {\n-\n+            implements AnnotationValue.OfFloat {\n@@ -146,2 +101,1 @@\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfLong {\n-\n+            implements AnnotationValue.OfLong {\n@@ -159,3 +113,2 @@\n-    public record OfIntegerImpl(IntegerEntry constant)\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfInteger {\n-\n+    public record OfIntImpl(IntegerEntry constant)\n+            implements AnnotationValue.OfInt {\n@@ -174,2 +127,1 @@\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfShort {\n-\n+            implements AnnotationValue.OfShort {\n@@ -183,1 +135,1 @@\n-            return (short)constant().intValue();\n+            return (short) constant().intValue();\n@@ -187,3 +139,2 @@\n-    public record OfCharacterImpl(IntegerEntry constant)\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfCharacter {\n-\n+    public record OfCharImpl(IntegerEntry constant)\n+            implements AnnotationValue.OfChar {\n@@ -197,1 +148,1 @@\n-            return (char)constant().intValue();\n+            return (char) constant().intValue();\n@@ -202,2 +153,1 @@\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfByte {\n-\n+            implements AnnotationValue.OfByte {\n@@ -211,1 +161,1 @@\n-            return (byte)constant().intValue();\n+            return (byte) constant().intValue();\n@@ -216,2 +166,1 @@\n-            implements AnnotationImpl.OfConstantImpl, AnnotationValue.OfBoolean {\n-\n+            implements AnnotationValue.OfBoolean {\n@@ -225,1 +174,1 @@\n-            return constant().intValue() == 1;\n+            return constant().intValue() != 0;\n@@ -230,4 +179,3 @@\n-            implements AnnotationValue.OfArray, Util.Writable {\n-\n-        public OfArrayImpl(List<AnnotationValue> values) {\n-            this.values = List.copyOf(values);\n+            implements AnnotationValue.OfArray {\n+        public OfArrayImpl {\n+            values = List.copyOf(values);\n@@ -240,10 +188,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeU2(values.size());\n-            for (var e : values) {\n-                AnnotationReader.writeAnnotationValue(buf, e);\n-            }\n-        }\n-\n@@ -253,1 +191,1 @@\n-            implements AnnotationValue.OfEnum, Util.Writable {\n+            implements AnnotationValue.OfEnum {\n@@ -258,8 +196,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-            buf.writeIndex(constantName);\n-        }\n-\n@@ -269,1 +199,1 @@\n-            implements AnnotationValue.OfAnnotation, Util.Writable {\n+            implements AnnotationValue.OfAnnotation {\n@@ -274,7 +204,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            AnnotationReader.writeAnnotation(buf, annotation);\n-        }\n-\n@@ -284,1 +207,1 @@\n-            implements AnnotationValue.OfClass, Util.Writable {\n+            implements AnnotationValue.OfClass {\n@@ -289,7 +212,0 @@\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            buf.writeU1(tag());\n-            buf.writeIndex(className);\n-        }\n-\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationImpl.java","additions":26,"deletions":110,"binary":false,"changes":136,"status":"modified"},{"patch":"@@ -63,1 +63,1 @@\n-            case AEV_CHAR -> new AnnotationImpl.OfCharacterImpl(classReader.readEntry(p, IntegerEntry.class));\n+            case AEV_CHAR -> new AnnotationImpl.OfCharImpl(classReader.readEntry(p, IntegerEntry.class));\n@@ -66,1 +66,1 @@\n-            case AEV_INT -> new AnnotationImpl.OfIntegerImpl(classReader.readEntry(p, IntegerEntry.class));\n+            case AEV_INT -> new AnnotationImpl.OfIntImpl(classReader.readEntry(p, IntegerEntry.class));\n@@ -244,4 +244,2 @@\n-        Utf8Entry type = classReader.readEntry(p, Utf8Entry.class);\n-        p += 2;\n-        return TypeAnnotation.of(targetInfo, List.of(typePath), type,\n-                                 readAnnotationElementValuePairs(classReader, p));\n+        var anno = readAnnotation(classReader, p);\n+        return TypeAnnotation.of(targetInfo, List.of(typePath), anno);\n@@ -286,3 +284,7 @@\n-        \/\/ handles annotations and type annotations\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) annotation).writeTo(buf);\n+        buf.writeIndex(annotation.className());\n+        var elements = annotation.elements();\n+        buf.writeU2(elements.size());\n+        for (var e : elements) {\n+            buf.writeIndex(e.name());\n+            AnnotationReader.writeAnnotationValue(buf, e.value());\n+        }\n@@ -291,2 +293,1 @@\n-    public static void writeAnnotations(BufWriter buf, List<? extends Annotation> list) {\n-        \/\/ handles annotations and type annotations\n+    public static void writeAnnotations(BufWriter buf, List<Annotation> list) {\n@@ -300,0 +301,60 @@\n+    private static int labelToBci(LabelContext lr, Label label, TypeAnnotation ta) {\n+        \/\/helper method to avoid NPE\n+        if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(ta.targetInfo().targetType()));\n+        return lr.labelToBci(label);\n+    }\n+\n+    public static void writeTypeAnnotation(BufWriterImpl buf, TypeAnnotation ta) {\n+        LabelContext lr = buf.labelContext();\n+        \/\/ target_type\n+        buf.writeU1(ta.targetInfo().targetType().targetTypeValue());\n+\n+        \/\/ target_info\n+        switch (ta.targetInfo()) {\n+            case TypeAnnotation.TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n+            case TypeAnnotation.SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n+            case TypeAnnotation.TypeParameterBoundTarget tpbt -> {\n+                buf.writeU1(tpbt.typeParameterIndex());\n+                buf.writeU1(tpbt.boundIndex());\n+            }\n+            case TypeAnnotation.EmptyTarget _ -> {\n+                \/\/ nothing to write\n+            }\n+            case TypeAnnotation.FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n+            case TypeAnnotation.ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n+            case TypeAnnotation.LocalVarTarget lvt -> {\n+                buf.writeU2(lvt.table().size());\n+                for (var e : lvt.table()) {\n+                    int startPc = labelToBci(lr, e.startLabel(), ta);\n+                    buf.writeU2(startPc);\n+                    buf.writeU2(labelToBci(lr, e.endLabel(), ta) - startPc);\n+                    buf.writeU2(e.index());\n+                }\n+            }\n+            case TypeAnnotation.CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n+            case TypeAnnotation.OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target(), ta));\n+            case TypeAnnotation.TypeArgumentTarget tat -> {\n+                buf.writeU2(labelToBci(lr, tat.target(), ta));\n+                buf.writeU1(tat.typeArgumentIndex());\n+            }\n+        }\n+\n+        \/\/ target_path\n+        buf.writeU1(ta.targetPath().size());\n+        for (TypeAnnotation.TypePathComponent component : ta.targetPath()) {\n+            buf.writeU1(component.typePathKind().tag());\n+            buf.writeU1(component.typeArgumentIndex());\n+        }\n+\n+        \/\/ annotation data\n+        writeAnnotation(buf, ta.annotation());\n+    }\n+\n+    public static void writeTypeAnnotations(BufWriter buf, List<TypeAnnotation> list) {\n+        var internalBuf = (BufWriterImpl) buf;\n+        internalBuf.writeU2(list.size());\n+        for (var e : list) {\n+            writeTypeAnnotation(internalBuf, e);\n+        }\n+    }\n+\n@@ -301,2 +362,21 @@\n-        \/\/ TODO annotation cleanup later\n-        ((Util.Writable) value).writeTo(buf);\n+        var tag = value.tag();\n+        buf.writeU1(tag);\n+        switch (value.tag()) {\n+            case AEV_BOOLEAN, AEV_BYTE, AEV_CHAR, AEV_DOUBLE, AEV_FLOAT, AEV_INT, AEV_LONG, AEV_SHORT, AEV_STRING ->\n+                    buf.writeIndex(((AnnotationValue.OfConstant) value).constant());\n+            case AEV_CLASS -> buf.writeIndex(((AnnotationValue.OfClass) value).className());\n+            case AEV_ENUM -> {\n+                var enumValue = (AnnotationValue.OfEnum) value;\n+                buf.writeIndex(enumValue.className());\n+                buf.writeIndex(enumValue.constantName());\n+            }\n+            case AEV_ANNOTATION -> writeAnnotation(buf, ((AnnotationValue.OfAnnotation) value).annotation());\n+            case AEV_ARRAY -> {\n+                var array = ((AnnotationValue.OfArray) value).values();\n+                buf.writeU2(array.size());\n+                for (var e : array) {\n+                    writeAnnotationValue(buf, e);\n+                }\n+            }\n+            default -> throw new InternalError(\"Unknown value \" + value);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AnnotationReader.java","additions":93,"deletions":13,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -56,0 +56,8 @@\n+    @SuppressWarnings(\"unchecked\")\n+    <A extends Attribute<A>> A get(AttributeMapper<A> am) {\n+        for (Attribute<?> a : attributes)\n+            if (a.attributeMapper() == am)\n+                return (A)a;\n+        return null;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/AttributeHolder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-            if (element instanceof Instruction i && i.opcode().isUnconditionalBranch())\n+            if (element instanceof Instruction i && BytecodeHelpers.isUnconditionalBranch(i.opcode()))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BlockCodeBuilderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -151,1 +151,1 @@\n-                filled.add((Attribute<?>) Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n+                filled.add(Objects.requireNonNull(mapper.readAttribute(enclosing, reader, p)));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BoundAttribute.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -94,1 +94,2 @@\n-        writeIntBytes(1, x);\n+        reserveSpace(1);\n+        elems[offset++] = (byte) x;\n@@ -99,1 +100,6 @@\n-        writeIntBytes(2, x);\n+        reserveSpace(2);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 8);\n+        elems[offset + 1] = (byte) x;\n+        this.offset = offset + 2;\n@@ -104,1 +110,8 @@\n-        writeIntBytes(4, x);\n+        reserveSpace(4);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 24);\n+        elems[offset + 1] = (byte) (x >> 16);\n+        elems[offset + 2] = (byte) (x >> 8);\n+        elems[offset + 3] = (byte)  x;\n+        this.offset = offset + 4;\n@@ -114,1 +127,12 @@\n-        writeIntBytes(8, x);\n+        reserveSpace(8);\n+        byte[] elems = this.elems;\n+        int offset = this.offset;\n+        elems[offset    ] = (byte) (x >> 56);\n+        elems[offset + 1] = (byte) (x >> 48);\n+        elems[offset + 2] = (byte) (x >> 40);\n+        elems[offset + 3] = (byte) (x >> 32);\n+        elems[offset + 4] = (byte) (x >> 24);\n+        elems[offset + 5] = (byte) (x >> 16);\n+        elems[offset + 6] = (byte) (x >> 8);\n+        elems[offset + 7] = (byte)  x;\n+        this.offset = offset + 8;\n@@ -156,6 +180,3 @@\n-        if (offset + freeBytes > elems.length) {\n-            int newsize = elems.length * 2;\n-            while (offset + freeBytes > newsize) {\n-                newsize *= 2;\n-            }\n-            elems = Arrays.copyOf(elems, newsize);\n+        int minCapacity = offset + freeBytes;\n+        if (minCapacity > elems.length) {\n+            grow(minCapacity);\n@@ -165,0 +186,8 @@\n+    private void grow(int minCapacity) {\n+        int newsize = elems.length * 2;\n+        while (minCapacity > newsize) {\n+            newsize *= 2;\n+        }\n+        elems = Arrays.copyOf(elems, newsize);\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufWriterImpl.java","additions":39,"deletions":10,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -176,6 +176,1 @@\n-            builder.withCode(new Consumer<>() {\n-                @Override\n-                public void accept(CodeBuilder cb) {\n-                    forEach(cb);\n-                }\n-            });\n+            builder.withCode(Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedCodeBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -107,6 +107,1 @@\n-            builder.withField(name, desc, new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fieldBuilder) {\n-                    elements.forEach(fieldBuilder);\n-                }\n-            });\n+            builder.withField(name, desc, Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedFieldBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -208,6 +208,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(), new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BufferedMethodBuilder.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,2 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -48,0 +49,5 @@\n+import static java.lang.classfile.ClassFile.*;\n+\n+\/**\n+ * Note: This class switches on opcode.bytecode for code size\n+ *\/\n@@ -53,0 +59,4 @@\n+    public static IllegalArgumentException cannotConvertException(TypeKind from, TypeKind to) {\n+        return new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+    }\n+\n@@ -55,36 +65,57 @@\n-            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n-                case 0 -> Opcode.ILOAD_0;\n-                case 1 -> Opcode.ILOAD_1;\n-                case 2 -> Opcode.ILOAD_2;\n-                case 3 -> Opcode.ILOAD_3;\n-                default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n-            };\n-            case LongType -> switch (slot) {\n-                case 0 -> Opcode.LLOAD_0;\n-                case 1 -> Opcode.LLOAD_1;\n-                case 2 -> Opcode.LLOAD_2;\n-                case 3 -> Opcode.LLOAD_3;\n-                default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n-            };\n-            case DoubleType -> switch (slot) {\n-                case 0 -> Opcode.DLOAD_0;\n-                case 1 -> Opcode.DLOAD_1;\n-                case 2 -> Opcode.DLOAD_2;\n-                case 3 -> Opcode.DLOAD_3;\n-                default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n-            };\n-            case FloatType -> switch (slot) {\n-                case 0 -> Opcode.FLOAD_0;\n-                case 1 -> Opcode.FLOAD_1;\n-                case 2 -> Opcode.FLOAD_2;\n-                case 3 -> Opcode.FLOAD_3;\n-                default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n-            };\n-            case ReferenceType -> switch (slot) {\n-                case 0 -> Opcode.ALOAD_0;\n-                case 1 -> Opcode.ALOAD_1;\n-                case 2 -> Opcode.ALOAD_2;\n-                case 3 -> Opcode.ALOAD_3;\n-                default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n-            };\n-            case VoidType -> throw new IllegalArgumentException(\"void\");\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> iload(slot);\n+            case LONG      -> lload(slot);\n+            case DOUBLE    -> dload(slot);\n+            case FLOAT     -> fload(slot);\n+            case REFERENCE -> aload(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode aload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ALOAD_0;\n+            case 1 -> Opcode.ALOAD_1;\n+            case 2 -> Opcode.ALOAD_2;\n+            case 3 -> Opcode.ALOAD_3;\n+            default -> (slot < 256) ? Opcode.ALOAD : Opcode.ALOAD_W;\n+        };\n+    }\n+\n+    public static Opcode fload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.FLOAD_0;\n+            case 1 -> Opcode.FLOAD_1;\n+            case 2 -> Opcode.FLOAD_2;\n+            case 3 -> Opcode.FLOAD_3;\n+            default -> (slot < 256) ? Opcode.FLOAD : Opcode.FLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode dload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.DLOAD_0;\n+            case 1 -> Opcode.DLOAD_1;\n+            case 2 -> Opcode.DLOAD_2;\n+            case 3 -> Opcode.DLOAD_3;\n+            default -> (slot < 256) ? Opcode.DLOAD : Opcode.DLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode lload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.LLOAD_0;\n+            case 1 -> Opcode.LLOAD_1;\n+            case 2 -> Opcode.LLOAD_2;\n+            case 3 -> Opcode.LLOAD_3;\n+            default -> (slot < 256) ? Opcode.LLOAD : Opcode.LLOAD_W;\n+        };\n+    }\n+\n+    public static Opcode iload(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ILOAD_0;\n+            case 1 -> Opcode.ILOAD_1;\n+            case 2 -> Opcode.ILOAD_2;\n+            case 3 -> Opcode.ILOAD_3;\n+            default -> (slot < 256) ? Opcode.ILOAD : Opcode.ILOAD_W;\n@@ -96,36 +127,57 @@\n-            case IntType, ShortType, ByteType, CharType, BooleanType -> switch (slot) {\n-                case 0 -> Opcode.ISTORE_0;\n-                case 1 -> Opcode.ISTORE_1;\n-                case 2 -> Opcode.ISTORE_2;\n-                case 3 -> Opcode.ISTORE_3;\n-                default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n-            };\n-            case LongType -> switch (slot) {\n-                case 0 -> Opcode.LSTORE_0;\n-                case 1 -> Opcode.LSTORE_1;\n-                case 2 -> Opcode.LSTORE_2;\n-                case 3 -> Opcode.LSTORE_3;\n-                default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n-            };\n-            case DoubleType -> switch (slot) {\n-                case 0 -> Opcode.DSTORE_0;\n-                case 1 -> Opcode.DSTORE_1;\n-                case 2 -> Opcode.DSTORE_2;\n-                case 3 -> Opcode.DSTORE_3;\n-                default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n-            };\n-            case FloatType -> switch (slot) {\n-                case 0 -> Opcode.FSTORE_0;\n-                case 1 -> Opcode.FSTORE_1;\n-                case 2 -> Opcode.FSTORE_2;\n-                case 3 -> Opcode.FSTORE_3;\n-                default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n-            };\n-            case ReferenceType -> switch (slot) {\n-                case 0 -> Opcode.ASTORE_0;\n-                case 1 -> Opcode.ASTORE_1;\n-                case 2 -> Opcode.ASTORE_2;\n-                case 3 -> Opcode.ASTORE_3;\n-                default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n-            };\n-            case VoidType -> throw new IllegalArgumentException(\"void\");\n+            case INT, SHORT, BYTE, CHAR, BOOLEAN\n+                           -> istore(slot);\n+            case LONG      -> lstore(slot);\n+            case DOUBLE    -> dstore(slot);\n+            case FLOAT     -> fstore(slot);\n+            case REFERENCE -> astore(slot);\n+            case VOID      -> throw new IllegalArgumentException(\"void\");\n+        };\n+    }\n+\n+    public static Opcode astore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ASTORE_0;\n+            case 1 -> Opcode.ASTORE_1;\n+            case 2 -> Opcode.ASTORE_2;\n+            case 3 -> Opcode.ASTORE_3;\n+            default -> (slot < 256) ? Opcode.ASTORE : Opcode.ASTORE_W;\n+        };\n+    }\n+\n+    public static Opcode fstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.FSTORE_0;\n+            case 1 -> Opcode.FSTORE_1;\n+            case 2 -> Opcode.FSTORE_2;\n+            case 3 -> Opcode.FSTORE_3;\n+            default -> (slot < 256) ? Opcode.FSTORE : Opcode.FSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode dstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.DSTORE_0;\n+            case 1 -> Opcode.DSTORE_1;\n+            case 2 -> Opcode.DSTORE_2;\n+            case 3 -> Opcode.DSTORE_3;\n+            default -> (slot < 256) ? Opcode.DSTORE : Opcode.DSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode lstore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.LSTORE_0;\n+            case 1 -> Opcode.LSTORE_1;\n+            case 2 -> Opcode.LSTORE_2;\n+            case 3 -> Opcode.LSTORE_3;\n+            default -> (slot < 256) ? Opcode.LSTORE : Opcode.LSTORE_W;\n+        };\n+    }\n+\n+    public static Opcode istore(int slot) {\n+        return switch (slot) {\n+            case 0 -> Opcode.ISTORE_0;\n+            case 1 -> Opcode.ISTORE_1;\n+            case 2 -> Opcode.ISTORE_2;\n+            case 3 -> Opcode.ISTORE_3;\n+            default -> (slot < 256) ? Opcode.ISTORE : Opcode.ISTORE_W;\n@@ -137,6 +189,6 @@\n-            case ByteType, ShortType, IntType, CharType, BooleanType -> Opcode.IRETURN;\n-            case FloatType -> Opcode.FRETURN;\n-            case LongType -> Opcode.LRETURN;\n-            case DoubleType -> Opcode.DRETURN;\n-            case ReferenceType -> Opcode.ARETURN;\n-            case VoidType -> Opcode.RETURN;\n+            case BYTE, SHORT, INT, CHAR, BOOLEAN -> Opcode.IRETURN;\n+            case FLOAT -> Opcode.FRETURN;\n+            case LONG -> Opcode.LRETURN;\n+            case DOUBLE -> Opcode.DRETURN;\n+            case REFERENCE -> Opcode.ARETURN;\n+            case VOID -> Opcode.RETURN;\n@@ -148,9 +200,9 @@\n-            case ByteType, BooleanType -> Opcode.BALOAD;\n-            case ShortType -> Opcode.SALOAD;\n-            case IntType -> Opcode.IALOAD;\n-            case FloatType -> Opcode.FALOAD;\n-            case LongType -> Opcode.LALOAD;\n-            case DoubleType -> Opcode.DALOAD;\n-            case ReferenceType -> Opcode.AALOAD;\n-            case CharType -> Opcode.CALOAD;\n-            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+            case BYTE, BOOLEAN -> Opcode.BALOAD;\n+            case SHORT -> Opcode.SALOAD;\n+            case INT -> Opcode.IALOAD;\n+            case FLOAT -> Opcode.FALOAD;\n+            case LONG -> Opcode.LALOAD;\n+            case DOUBLE -> Opcode.DALOAD;\n+            case REFERENCE -> Opcode.AALOAD;\n+            case CHAR -> Opcode.CALOAD;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n@@ -162,9 +214,9 @@\n-            case ByteType, BooleanType -> Opcode.BASTORE;\n-            case ShortType -> Opcode.SASTORE;\n-            case IntType -> Opcode.IASTORE;\n-            case FloatType -> Opcode.FASTORE;\n-            case LongType -> Opcode.LASTORE;\n-            case DoubleType -> Opcode.DASTORE;\n-            case ReferenceType -> Opcode.AASTORE;\n-            case CharType -> Opcode.CASTORE;\n-            case VoidType -> throw new IllegalArgumentException(\"void not an allowable array type\");\n+            case BYTE, BOOLEAN -> Opcode.BASTORE;\n+            case SHORT -> Opcode.SASTORE;\n+            case INT -> Opcode.IASTORE;\n+            case FLOAT -> Opcode.FASTORE;\n+            case LONG -> Opcode.LASTORE;\n+            case DOUBLE -> Opcode.DASTORE;\n+            case REFERENCE -> Opcode.AASTORE;\n+            case CHAR -> Opcode.CASTORE;\n+            case VOID -> throw new IllegalArgumentException(\"void not an allowable array type\");\n@@ -192,1 +244,1 @@\n-            default -> throw new IllegalArgumentException(\"Unknown branch instruction: \" + op);\n+            default -> throw Util.badOpcodeKindException(op, Opcode.Kind.BRANCH);\n@@ -198,1 +250,1 @@\n-            case IntType ->\n+            case INT ->\n@@ -200,7 +252,7 @@\n-                        case LongType -> Opcode.I2L;\n-                        case FloatType -> Opcode.I2F;\n-                        case DoubleType -> Opcode.I2D;\n-                        case ByteType -> Opcode.I2B;\n-                        case CharType -> Opcode.I2C;\n-                        case ShortType -> Opcode.I2S;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case LONG -> Opcode.I2L;\n+                        case FLOAT -> Opcode.I2F;\n+                        case DOUBLE -> Opcode.I2D;\n+                        case BYTE -> Opcode.I2B;\n+                        case CHAR -> Opcode.I2C;\n+                        case SHORT -> Opcode.I2S;\n+                        default -> throw cannotConvertException(from, to);\n@@ -208,1 +260,1 @@\n-            case LongType ->\n+            case LONG ->\n@@ -210,4 +262,4 @@\n-                        case FloatType -> Opcode.L2F;\n-                        case DoubleType -> Opcode.L2D;\n-                        case IntType -> Opcode.L2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case FLOAT -> Opcode.L2F;\n+                        case DOUBLE -> Opcode.L2D;\n+                        case INT -> Opcode.L2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -215,1 +267,1 @@\n-            case DoubleType ->\n+            case DOUBLE ->\n@@ -217,4 +269,4 @@\n-                        case FloatType -> Opcode.D2F;\n-                        case LongType -> Opcode.D2L;\n-                        case IntType -> Opcode.D2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case FLOAT -> Opcode.D2F;\n+                        case LONG -> Opcode.D2L;\n+                        case INT -> Opcode.D2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -222,1 +274,1 @@\n-            case FloatType ->\n+            case FLOAT ->\n@@ -224,4 +276,4 @@\n-                        case LongType -> Opcode.F2L;\n-                        case DoubleType -> Opcode.F2D;\n-                        case IntType -> Opcode.F2I;\n-                        default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+                        case LONG -> Opcode.F2L;\n+                        case DOUBLE -> Opcode.F2D;\n+                        case INT -> Opcode.F2I;\n+                        default -> throw cannotConvertException(from, to);\n@@ -229,1 +281,1 @@\n-            default -> throw new IllegalArgumentException(String.format(\"convert %s -> %s\", from, to));\n+            default -> throw cannotConvertException(from, to);\n@@ -233,9 +285,8 @@\n-    static void validateSIPUSH(ConstantDesc d) {\n-        if (d instanceof Integer iVal && Short.MIN_VALUE <= iVal && iVal <= Short.MAX_VALUE)\n-            return;\n-\n-        if (d instanceof Long lVal && Short.MIN_VALUE <= lVal && Short.MAX_VALUE <= lVal)\n-            return;\n-\n-        throw new IllegalArgumentException(\"SIPUSH: value must be within: Short.MIN_VALUE <= value <= Short.MAX_VALUE\"\n-                                           + \", found: \" + d);\n+    public static TypeKind convertFromType(Opcode opcode) {\n+        return switch (opcode) {\n+            case I2D, I2F, I2L, I2B, I2C, I2S -> TypeKind.INT;\n+            case L2D, L2F, L2I -> TypeKind.LONG;\n+            case F2D, F2I, F2L -> TypeKind.FLOAT;\n+            case D2F, D2I, D2L -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONVERT);\n+        };\n@@ -244,3 +295,12 @@\n-    static void validateBIPUSH(ConstantDesc d) {\n-        if (d instanceof Integer iVal && Byte.MIN_VALUE <= iVal && iVal <= Byte.MAX_VALUE)\n-            return;\n+    public static TypeKind convertToType(Opcode opcode) {\n+        return switch (opcode) {\n+            case I2B -> TypeKind.BYTE;\n+            case I2C -> TypeKind.CHAR;\n+            case I2S -> TypeKind.SHORT;\n+            case L2I, F2I, D2I -> TypeKind.INT;\n+            case I2L, F2L, D2L -> TypeKind.LONG;\n+            case I2F, L2F, D2F -> TypeKind.FLOAT;\n+            case I2D, L2D, F2D -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONVERT);\n+        };\n+    }\n@@ -248,2 +308,6 @@\n-        if (d instanceof Long lVal && Byte.MIN_VALUE <= lVal && Byte.MAX_VALUE <= lVal)\n-            return;\n+    public static void validateSipush(int value) {\n+        if (value != (short) value)\n+            throw new IllegalArgumentException(\n+                    \"SIPUSH: value must be within: Short.MIN_VALUE <= value <= Short.MAX_VALUE, found: \"\n+                            .concat(Long.toString(value)));\n+    }\n@@ -251,2 +315,5 @@\n-        throw new IllegalArgumentException(\"BIPUSH: value must be within: Byte.MIN_VALUE <= value <= Byte.MAX_VALUE\"\n-                                           + \", found: \" + d);\n+    public static void validateBipush(int value) {\n+        if (value != (byte) value)\n+            throw new IllegalArgumentException(\n+                    \"BIPUSH: value must be within: Byte.MIN_VALUE <= value <= Byte.MAX_VALUE, found: \"\n+                            .concat(Long.toString(value)));\n@@ -278,9 +345,1 @@\n-\n-        var bootstrapDesc = desc.bootstrapMethod();\n-        ClassEntry bsOwner = constantPool.classEntry(bootstrapDesc.owner());\n-        NameAndTypeEntry bsNameAndType = constantPool.nameAndTypeEntry(bootstrapDesc.methodName(),\n-                                                               bootstrapDesc.invocationType());\n-        int bsRefKind = bootstrapDesc.refKind();\n-\n-        MemberRefEntry memberRefEntry = toBootstrapMemberRef(constantPool, bsRefKind, bsOwner, bsNameAndType, bootstrapDesc.isOwnerInterface());\n-        MethodHandleEntry methodHandleEntry = constantPool.methodHandleEntry(bsRefKind, memberRefEntry);\n+        MethodHandleEntry methodHandleEntry = handleDescToHandleInfo(constantPool, desc.bootstrapMethod());\n@@ -293,24 +352,4 @@\n-    public static void validateValue(Opcode opcode, ConstantDesc v) {\n-        switch (opcode) {\n-            case ACONST_NULL -> {\n-                if (v != null && v != ConstantDescs.NULL)\n-                    throw new IllegalArgumentException(\"value must be null or ConstantDescs.NULL with opcode ACONST_NULL\");\n-            }\n-            case SIPUSH ->\n-                    validateSIPUSH(v);\n-            case BIPUSH ->\n-                    validateBIPUSH(v);\n-            case LDC, LDC_W, LDC2_W -> {\n-                if (v == null)\n-                    throw new IllegalArgumentException(\"`null` must use ACONST_NULL\");\n-            }\n-            default -> {\n-                var exp = opcode.constantValue();\n-                if (exp == null)\n-                    throw new IllegalArgumentException(\"Can not use Opcode: \" + opcode + \" with constant()\");\n-                if (v == null || !(v.equals(exp) || (exp instanceof Long l && v.equals(l.intValue())))) {\n-                    var t = (exp instanceof Long) ? \"L\" : (exp instanceof Float) ? \"f\" : (exp instanceof Double) ? \"d\" : \"\";\n-                    throw new IllegalArgumentException(\"value must be \" + exp + t + \" with opcode \" + opcode.name());\n-                }\n-            }\n-        }\n+    public static Opcode ldcOpcode(LoadableConstantEntry entry) {\n+        return entry.typeKind().slotSize() == 2 ? Opcode.LDC2_W\n+                : entry.index() > 0xff ? Opcode.LDC_W\n+                : Opcode.LDC;\n@@ -350,0 +389,141 @@\n+\n+    public static ConstantDesc intrinsicConstantValue(Opcode opcode) {\n+        return switch (opcode) {\n+            case ACONST_NULL -> ConstantDescs.NULL;\n+            case ICONST_M1 -> -1;\n+            case ICONST_0 -> 0;\n+            case ICONST_1 -> 1;\n+            case ICONST_2 -> 2;\n+            case ICONST_3 -> 3;\n+            case ICONST_4 -> 4;\n+            case ICONST_5 -> 5;\n+            case LCONST_0 -> 0L;\n+            case LCONST_1 -> 1L;\n+            case FCONST_0 -> 0F;\n+            case FCONST_1 -> 1F;\n+            case FCONST_2 -> 2F;\n+            case DCONST_0 -> 0D;\n+            case DCONST_1 -> 1D;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONSTANT);\n+        };\n+    }\n+\n+    public static TypeKind intrinsicConstantType(Opcode opcode) {\n+        return switch (opcode) {\n+            case ACONST_NULL -> TypeKind.REFERENCE;\n+            case ICONST_M1, ICONST_0, ICONST_1, ICONST_2, ICONST_3, ICONST_4, ICONST_5 -> TypeKind.INT;\n+            case LCONST_0, LCONST_1 -> TypeKind.LONG;\n+            case FCONST_0, FCONST_1, FCONST_2 -> TypeKind.FLOAT;\n+            case DCONST_0, DCONST_1 -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(opcode, Opcode.Kind.CONSTANT);\n+        };\n+    }\n+\n+    public static boolean isUnconditionalBranch(Opcode opcode) {\n+        return switch (opcode) {\n+            case GOTO, ATHROW, GOTO_W, LOOKUPSWITCH, TABLESWITCH -> true;\n+            default -> opcode.kind() == Opcode.Kind.RETURN;\n+        };\n+    }\n+\n+    \/\/ Must check Opcode.sizeIfFixed() == 1 before call!\n+    public static int intrinsicLoadSlot(Opcode loadOpcode) {\n+        return switch (loadOpcode) {\n+            case ILOAD_0, LLOAD_0, FLOAD_0, DLOAD_0, ALOAD_0 -> 0;\n+            case ILOAD_1, LLOAD_1, FLOAD_1, DLOAD_1, ALOAD_1 -> 1;\n+            case ILOAD_2, LLOAD_2, FLOAD_2, DLOAD_2, ALOAD_2 -> 2;\n+            case ILOAD_3, LLOAD_3, FLOAD_3, DLOAD_3, ALOAD_3 -> 3;\n+            default -> throw Util.badOpcodeKindException(loadOpcode, Opcode.Kind.LOAD);\n+        };\n+    }\n+\n+    \/\/ Must check Opcode.sizeIfFixed() == 1 before call!\n+    public static int intrinsicStoreSlot(Opcode storeOpcode) {\n+        return switch (storeOpcode) {\n+            case ISTORE_0, LSTORE_0, FSTORE_0, DSTORE_0, ASTORE_0 -> 0;\n+            case ISTORE_1, LSTORE_1, FSTORE_1, DSTORE_1, ASTORE_1 -> 1;\n+            case ISTORE_2, LSTORE_2, FSTORE_2, DSTORE_2, ASTORE_2 -> 2;\n+            case ISTORE_3, LSTORE_3, FSTORE_3, DSTORE_3, ASTORE_3 -> 3;\n+            default -> throw Util.badOpcodeKindException(storeOpcode, Opcode.Kind.STORE);\n+        };\n+    }\n+\n+    public static TypeKind loadType(Opcode loadOpcode) {\n+        \/\/ Note: 0xFF handles wide pseudo-opcodes\n+        return switch (loadOpcode.bytecode() & 0xFF) {\n+            case ILOAD, ILOAD_0, ILOAD_1, ILOAD_2, ILOAD_3 -> TypeKind.INT;\n+            case LLOAD, LLOAD_0, LLOAD_1, LLOAD_2, LLOAD_3 -> TypeKind.LONG;\n+            case FLOAD, FLOAD_0, FLOAD_1, FLOAD_2, FLOAD_3 -> TypeKind.FLOAT;\n+            case DLOAD, DLOAD_0, DLOAD_1, DLOAD_2, DLOAD_3 -> TypeKind.DOUBLE;\n+            case ALOAD, ALOAD_0, ALOAD_1, ALOAD_2, ALOAD_3 -> TypeKind.REFERENCE;\n+            default -> throw Util.badOpcodeKindException(loadOpcode, Opcode.Kind.LOAD);\n+        };\n+    }\n+\n+    public static TypeKind storeType(Opcode storeOpcode) {\n+        \/\/ Note: 0xFF handles wide pseudo-opcodes\n+        return switch (storeOpcode.bytecode() & 0xFF) {\n+            case ISTORE, ISTORE_0, ISTORE_1, ISTORE_2, ISTORE_3 -> TypeKind.INT;\n+            case LSTORE, LSTORE_0, LSTORE_1, LSTORE_2, LSTORE_3 -> TypeKind.LONG;\n+            case FSTORE, FSTORE_0, FSTORE_1, FSTORE_2, FSTORE_3 -> TypeKind.FLOAT;\n+            case DSTORE, DSTORE_0, DSTORE_1, DSTORE_2, DSTORE_3 -> TypeKind.DOUBLE;\n+            case ASTORE, ASTORE_0, ASTORE_1, ASTORE_2, ASTORE_3 -> TypeKind.REFERENCE;\n+            default -> throw Util.badOpcodeKindException(storeOpcode, Opcode.Kind.STORE);\n+        };\n+    }\n+\n+    public static TypeKind arrayLoadType(Opcode arrayLoadOpcode) {\n+        return switch (arrayLoadOpcode) {\n+            case IALOAD -> TypeKind.INT;\n+            case LALOAD -> TypeKind.LONG;\n+            case FALOAD -> TypeKind.FLOAT;\n+            case DALOAD -> TypeKind.DOUBLE;\n+            case AALOAD -> TypeKind.REFERENCE;\n+            case BALOAD -> TypeKind.BYTE;\n+            case CALOAD -> TypeKind.CHAR;\n+            case SALOAD -> TypeKind.SHORT;\n+            default -> throw Util.badOpcodeKindException(arrayLoadOpcode, Opcode.Kind.ARRAY_LOAD);\n+        };\n+    }\n+\n+    public static TypeKind arrayStoreType(Opcode arrayStoreOpcode) {\n+        return switch (arrayStoreOpcode) {\n+            case IASTORE -> TypeKind.INT;\n+            case LASTORE -> TypeKind.LONG;\n+            case FASTORE -> TypeKind.FLOAT;\n+            case DASTORE -> TypeKind.DOUBLE;\n+            case AASTORE -> TypeKind.REFERENCE;\n+            case BASTORE -> TypeKind.BYTE;\n+            case CASTORE -> TypeKind.CHAR;\n+            case SASTORE -> TypeKind.SHORT;\n+            default -> throw Util.badOpcodeKindException(arrayStoreOpcode, Opcode.Kind.ARRAY_STORE);\n+        };\n+    }\n+\n+    public static TypeKind returnType(Opcode returnOpcode) {\n+        return switch (returnOpcode) {\n+            case IRETURN -> TypeKind.INT;\n+            case LRETURN -> TypeKind.LONG;\n+            case FRETURN -> TypeKind.FLOAT;\n+            case DRETURN -> TypeKind.DOUBLE;\n+            case ARETURN -> TypeKind.REFERENCE;\n+            case RETURN -> TypeKind.VOID;\n+            default -> throw Util.badOpcodeKindException(returnOpcode, Opcode.Kind.RETURN);\n+        };\n+    }\n+\n+    public static TypeKind operatorOperandType(Opcode operationOpcode) {\n+        return switch (operationOpcode) {\n+            case IADD, ISUB, IMUL, IDIV, IREM, INEG,\n+                 ISHL, ISHR, IUSHR, IAND, IOR, IXOR,\n+                 ARRAYLENGTH -> TypeKind.INT;\n+            case LADD, LSUB, LMUL, LDIV, LREM, LNEG,\n+                 LSHL, LSHR, LUSHR, LAND, LOR, LXOR,\n+                 LCMP -> TypeKind.LONG;\n+            case FADD, FSUB, FMUL, FDIV, FREM, FNEG,\n+                 FCMPL, FCMPG -> TypeKind.FLOAT;\n+            case DADD, DSUB, DMUL, DDIV, DREM, DNEG,\n+                 DCMPL, DCMPG -> TypeKind.DOUBLE;\n+            default -> throw Util.badOpcodeKindException(operationOpcode, Opcode.Kind.OPERATOR);\n+        };\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/BytecodeHelpers.java","additions":351,"deletions":171,"binary":false,"changes":522,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -81,0 +82,9 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var mb = new BufferedMethodBuilder(terminal.constantPool, terminal.context,\n+                constantPool().utf8Entry(name), constantPool().utf8Entry(descriptor), flags, null);\n+        mb.mDesc = descriptor;\n+        consumer.accept(mb.run(handler).toModel());\n+        return this;\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ChainedClassBuilder.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,11 +86,22 @@\n-            switch (o) {\n-                case StackMapsOption oo -> smo = oo;\n-                case DebugElementsOption oo -> deo = oo;\n-                case LineNumbersOption oo -> lno = oo;\n-                case AttributesProcessingOption oo -> apo = oo;\n-                case ConstantPoolSharingOption oo -> cpso = oo;\n-                case ShortJumpsOption oo -> sjo = oo;\n-                case DeadCodeOption oo -> dco = oo;\n-                case DeadLabelsOption oo -> dlo = oo;\n-                case ClassHierarchyResolverOption oo -> chro = oo;\n-                case AttributeMapperOption oo -> amo = oo;\n+            if (o instanceof StackMapsOption oo) {\n+                smo = oo;\n+            } else if (o instanceof DebugElementsOption oo) {\n+                deo = oo;\n+            } else if (o instanceof LineNumbersOption oo) {\n+                lno = oo;\n+            } else if (o instanceof AttributesProcessingOption oo) {\n+                apo = oo;\n+            } else if (o instanceof ConstantPoolSharingOption oo) {\n+                cpso = oo;\n+            } else if (o instanceof ShortJumpsOption oo) {\n+                sjo = oo;\n+            } else if (o instanceof DeadCodeOption oo) {\n+                dco = oo;\n+            } else if (o instanceof DeadLabelsOption oo) {\n+                dlo = oo;\n+            } else if (o instanceof ClassHierarchyResolverOption oo) {\n+                chro = oo;\n+            } else if (o instanceof AttributeMapperOption oo) {\n+                amo = oo;\n+            } else { \/\/ null or unknown Option type\n+                throw new IllegalArgumentException(\"Invalid option: \" + o);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassFileImpl.java","additions":23,"deletions":12,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -510,9 +510,9 @@\n-            case OfString cv -> leafs(\"string\", String.valueOf(cv.constantValue()));\n-            case OfDouble cv -> leafs(\"double\", String.valueOf(cv.constantValue()));\n-            case OfFloat cv -> leafs(\"float\", String.valueOf(cv.constantValue()));\n-            case OfLong cv -> leafs(\"long\", String.valueOf(cv.constantValue()));\n-            case OfInteger cv -> leafs(\"int\", String.valueOf(cv.constantValue()));\n-            case OfShort cv -> leafs(\"short\", String.valueOf(cv.constantValue()));\n-            case OfCharacter cv -> leafs(\"char\", String.valueOf(cv.constantValue()));\n-            case OfByte cv -> leafs(\"byte\", String.valueOf(cv.constantValue()));\n-            case OfBoolean cv -> leafs(\"boolean\", String.valueOf((int)cv.constantValue() != 0));\n+            case OfString cv -> leafs(\"string\", String.valueOf(cv.stringValue()));\n+            case OfDouble cv -> leafs(\"double\", String.valueOf(cv.doubleValue()));\n+            case OfFloat cv -> leafs(\"float\", String.valueOf(cv.floatValue()));\n+            case OfLong cv -> leafs(\"long\", String.valueOf(cv.longValue()));\n+            case OfInt cv -> leafs(\"int\", String.valueOf(cv.intValue()));\n+            case OfShort cv -> leafs(\"short\", String.valueOf(cv.shortValue()));\n+            case OfChar cv -> leafs(\"char\", String.valueOf(cv.charValue()));\n+            case OfByte cv -> leafs(\"byte\", String.valueOf(cv.byteValue()));\n+            case OfBoolean cv -> leafs(\"boolean\", String.valueOf(cv.booleanValue()));\n@@ -854,1 +854,1 @@\n-                                \"descriptor\", newa.typeKind().typeName()));\n+                                \"descriptor\", newa.typeKind().upperBound().displayName()));\n@@ -1041,1 +1041,1 @@\n-                        .with(leaf(\"annotation class\", a.className().stringValue()),\n+                        .with(leaf(\"annotation class\", a.annotation().className().stringValue()),\n@@ -1043,1 +1043,1 @@\n-                        .with(elementValuePairsToTree(a.elements()))));\n+                        .with(elementValuePairsToTree(a.annotation().elements()))));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassPrinterImpl.java","additions":13,"deletions":13,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -261,2 +261,1 @@\n-                    cob.loadConstant(ldc.opcode(),\n-                            mapConstantValue(ldc.constantValue()));\n+                    cob.ldc(mapConstantValue(ldc.constantValue()));\n@@ -404,3 +403,1 @@\n-                a.targetPath(), map(a.classSymbol()),\n-                a.elements().stream().map(el -> AnnotationElement.of(el.name(),\n-                        mapAnnotationValue(el.value()))).toList())).toList();\n+                a.targetPath(), mapAnnotation(a.annotation()))).toList();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/ClassRemapperImpl.java","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -58,1 +58,1 @@\n-                    case LOAD -> LoadInstruction.of(o, o.slot());\n+                    case LOAD -> LoadInstruction.of(o, BytecodeHelpers.intrinsicLoadSlot(o));\n@@ -64,1 +64,1 @@\n-                    case STORE -> StoreInstruction.of(o, o.slot());\n+                    case STORE -> StoreInstruction.of(o, BytecodeHelpers.intrinsicStoreSlot(o));\n@@ -150,6 +150,1 @@\n-                                    new Consumer<CodeBuilder>() {\n-                                        @Override\n-                                        public void accept(CodeBuilder cb) {\n-                                            forEach(cb);\n-                                        }\n-                                    },\n+                                    Util.writingAll(this),\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeImpl.java","additions":3,"deletions":8,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n-                        shift(cob, ii.slot(), TypeKind.IntType),\n+                        shift(cob, ii.slot(), TypeKind.INT),\n@@ -76,1 +76,1 @@\n-                                        : TypeKind.ReferenceType),\n+                                        : TypeKind.REFERENCE),\n@@ -86,1 +86,1 @@\n-        if (tk == TypeKind.VoidType)  throw new IllegalArgumentException(\"Illegal local void type\");\n+        if (tk == TypeKind.VOID)  throw new IllegalArgumentException(\"Illegal local void type\");\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeLocalsShifterImpl.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -149,1 +149,1 @@\n-            if (type != TypeKind.VoidType) stack.push(type);\n+            if (type != TypeKind.VOID) stack.push(type);\n@@ -231,1 +231,1 @@\n-                pop(i.dimensions());push(TypeKind.ReferenceType);\n+                pop(i.dimensions());push(TypeKind.REFERENCE);\n@@ -234,1 +234,1 @@\n-                push(TypeKind.ReferenceType);\n+                push(TypeKind.REFERENCE);\n@@ -236,1 +236,1 @@\n-                pop(1);push(TypeKind.ReferenceType);\n+                pop(1);push(TypeKind.REFERENCE);\n@@ -239,1 +239,1 @@\n-                pop(1);push(TypeKind.ReferenceType);\n+                pop(1);push(TypeKind.REFERENCE);\n@@ -332,1 +332,1 @@\n-                        pop(1);push(TypeKind.ReferenceType);\n+                        pop(1);push(TypeKind.REFERENCE);\n@@ -335,1 +335,1 @@\n-                        pop(1);push(TypeKind.IntType);\n+                        pop(1);push(TypeKind.INT);\n@@ -340,1 +340,1 @@\n-                map.put(i.handler(), new Stack(new Item(TypeKind.ReferenceType, null), 1, 1));\n+                map.put(i.handler(), new Stack(new Item(TypeKind.REFERENCE, null), 1, 1));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/CodeStackTrackerImpl.java","additions":9,"deletions":9,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.lang.constant.MethodTypeDesc;\n@@ -109,0 +110,7 @@\n+    @Override\n+    public ClassBuilder withMethod(String name, MethodTypeDesc descriptor, int flags, Consumer<? super MethodBuilder> handler) {\n+        var method = new DirectMethodBuilder(constantPool, context, constantPool.utf8Entry(name), constantPool.utf8Entry(descriptor), flags, null);\n+        method.mDesc = descriptor;\n+        return withMethod(method.run(handler));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectClassBuilder.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -27,9 +28,0 @@\n-import java.util.ArrayList;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.IdentityHashMap;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.function.Consumer;\n-import java.util.function.Function;\n-\n@@ -46,1 +38,0 @@\n-import java.lang.classfile.instruction.SwitchCase;\n@@ -58,0 +49,1 @@\n+import java.lang.classfile.constantpool.MethodRefEntry;\n@@ -62,0 +54,12 @@\n+import java.lang.classfile.instruction.SwitchCase;\n+import java.lang.constant.ConstantDesc;\n+import java.util.ArrayList;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static java.lang.classfile.Opcode.*;\n@@ -63,8 +67,1 @@\n-import static java.lang.classfile.Opcode.GOTO;\n-import static java.lang.classfile.Opcode.GOTO_W;\n-import static java.lang.classfile.Opcode.IINC;\n-import static java.lang.classfile.Opcode.IINC_W;\n-import static java.lang.classfile.Opcode.JSR;\n-import static java.lang.classfile.Opcode.JSR_W;\n-import static java.lang.classfile.Opcode.LDC2_W;\n-import static java.lang.classfile.Opcode.LDC_W;\n+import static jdk.internal.classfile.impl.BytecodeHelpers.*;\n@@ -546,1 +543,1 @@\n-        writeBytecode(Opcode.LOOKUPSWITCH);\n+        writeBytecode(LOOKUPSWITCH);\n@@ -567,1 +564,1 @@\n-        writeBytecode(Opcode.TABLESWITCH);\n+        writeBytecode(TABLESWITCH);\n@@ -603,1 +600,1 @@\n-        writeBytecode(Opcode.INVOKEDYNAMIC);\n+        writeBytecode(INVOKEDYNAMIC);\n@@ -609,1 +606,1 @@\n-        writeBytecode(Opcode.NEW);\n+        writeBytecode(NEW);\n@@ -614,1 +611,1 @@\n-        writeBytecode(Opcode.NEWARRAY);\n+        writeBytecode(NEWARRAY);\n@@ -619,1 +616,1 @@\n-        writeBytecode(Opcode.ANEWARRAY);\n+        writeBytecode(ANEWARRAY);\n@@ -624,1 +621,1 @@\n-        writeBytecode(Opcode.MULTIANEWARRAY);\n+        writeBytecode(MULTIANEWARRAY);\n@@ -780,0 +777,745 @@\n+\n+    \/\/ Fast overrides to avoid intermediate instructions\n+    \/\/ These are helpful for direct class building\n+\n+    @Override\n+    public CodeBuilder return_(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.returnOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder storeLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.storeOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder loadLocal(TypeKind tk, int slot) {\n+        writeLocalVar(BytecodeHelpers.loadOpcode(tk, slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invoke(Opcode opcode, MemberRefEntry ref) {\n+        if (opcode == INVOKEINTERFACE) {\n+            int slots = Util.parameterSlots(Util.methodTypeSymbol(ref.nameAndType())) + 1;\n+            writeInvokeInterface(opcode, (InterfaceMethodRefEntry) ref, slots);\n+        } else {\n+            writeInvokeNormal(opcode, ref);\n+        }\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fieldAccess(Opcode opcode, FieldRefEntry ref) {\n+        writeFieldAccess(opcode, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayLoad(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayLoadOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arrayStore(TypeKind tk) {\n+        writeBytecode(BytecodeHelpers.arrayStoreOpcode(tk));\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder branch(Opcode op, Label target) {\n+        writeBranch(op, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder nop() {\n+        writeBytecode(NOP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder aconst_null() {\n+        writeBytecode(ACONST_NULL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder aload(int slot) {\n+        writeLocalVar(BytecodeHelpers.aload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder anewarray(ClassEntry entry) {\n+        writeNewReferenceArray(entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder arraylength() {\n+        writeBytecode(ARRAYLENGTH);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder astore(int slot) {\n+        writeLocalVar(BytecodeHelpers.astore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder athrow() {\n+        writeBytecode(ATHROW);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder bipush(int b) {\n+        BytecodeHelpers.validateBipush(b);\n+        writeArgumentConstant(BIPUSH, b);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder checkcast(ClassEntry type) {\n+        writeTypeCheck(CHECKCAST, type);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2f() {\n+        writeBytecode(D2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2i() {\n+        writeBytecode(D2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder d2l() {\n+        writeBytecode(D2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dadd() {\n+        writeBytecode(DADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpg() {\n+        writeBytecode(DCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dcmpl() {\n+        writeBytecode(DCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_0() {\n+        writeBytecode(DCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dconst_1() {\n+        writeBytecode(DCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ddiv() {\n+        writeBytecode(DDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dload(int slot) {\n+        writeLocalVar(BytecodeHelpers.dload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dmul() {\n+        writeBytecode(DMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dneg() {\n+        writeBytecode(DNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder drem() {\n+        writeBytecode(DREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.dstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dsub() {\n+        writeBytecode(DSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup() {\n+        writeBytecode(DUP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2() {\n+        writeBytecode(DUP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x1() {\n+        writeBytecode(DUP2_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup2_x2() {\n+        writeBytecode(DUP2_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x1() {\n+        writeBytecode(DUP_X1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder dup_x2() {\n+        writeBytecode(DUP_X2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2d() {\n+        writeBytecode(F2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2i() {\n+        writeBytecode(F2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder f2l() {\n+        writeBytecode(F2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fadd() {\n+        writeBytecode(FADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpg() {\n+        writeBytecode(FCMPG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fcmpl() {\n+        writeBytecode(FCMPL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_0() {\n+        writeBytecode(FCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_1() {\n+        writeBytecode(FCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fconst_2() {\n+        writeBytecode(FCONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fdiv() {\n+        writeBytecode(FDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fload(int slot) {\n+        writeLocalVar(BytecodeHelpers.fload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fmul() {\n+        writeBytecode(FMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fneg() {\n+        writeBytecode(FNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder frem() {\n+        writeBytecode(FREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.fstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder fsub() {\n+        writeBytecode(FSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2b() {\n+        writeBytecode(I2B);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2c() {\n+        writeBytecode(I2C);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2d() {\n+        writeBytecode(I2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2f() {\n+        writeBytecode(I2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2l() {\n+        writeBytecode(I2L);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder i2s() {\n+        writeBytecode(I2S);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iadd() {\n+        writeBytecode(IADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iand() {\n+        writeBytecode(IAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_0() {\n+        writeBytecode(ICONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_1() {\n+        writeBytecode(ICONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_2() {\n+        writeBytecode(ICONST_2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_3() {\n+        writeBytecode(ICONST_3);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_4() {\n+        writeBytecode(ICONST_4);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_5() {\n+        writeBytecode(ICONST_5);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iconst_m1() {\n+        writeBytecode(ICONST_M1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder idiv() {\n+        writeBytecode(IDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iinc(int slot, int val) {\n+        writeIncrement(slot, val);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iload(int slot) {\n+        writeLocalVar(BytecodeHelpers.iload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder imul() {\n+        writeBytecode(IMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ineg() {\n+        writeBytecode(INEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder instanceOf(ClassEntry target) {\n+        writeTypeCheck(INSTANCEOF, target);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokedynamic(InvokeDynamicEntry ref) {\n+        writeInvokeDynamic(ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokeinterface(InterfaceMethodRefEntry ref) {\n+        writeInvokeInterface(INVOKEINTERFACE, ref, Util.parameterSlots(ref.typeSymbol()) + 1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokespecial(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESPECIAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(InterfaceMethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokestatic(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKESTATIC, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder invokevirtual(MethodRefEntry ref) {\n+        writeInvokeNormal(INVOKEVIRTUAL, ref);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ior() {\n+        writeBytecode(IOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder irem() {\n+        writeBytecode(IREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishl() {\n+        writeBytecode(ISHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ishr() {\n+        writeBytecode(ISHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder istore(int slot) {\n+        writeLocalVar(BytecodeHelpers.istore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder isub() {\n+        writeBytecode(ISUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder iushr() {\n+        writeBytecode(IUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ixor() {\n+        writeBytecode(IXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lookupswitch(Label defaultTarget, List<SwitchCase> cases) {\n+        writeLookupSwitch(defaultTarget, cases);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2d() {\n+        writeBytecode(L2D);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2f() {\n+        writeBytecode(L2F);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder l2i() {\n+        writeBytecode(L2I);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ladd() {\n+        writeBytecode(LADD);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder land() {\n+        writeBytecode(LAND);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lcmp() {\n+        writeBytecode(LCMP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_0() {\n+        writeBytecode(LCONST_0);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lconst_1() {\n+        writeBytecode(LCONST_1);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldc(LoadableConstantEntry entry) {\n+        writeLoadConstant(BytecodeHelpers.ldcOpcode(entry), entry);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder ldiv() {\n+        writeBytecode(LDIV);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lload(int slot) {\n+        writeLocalVar(BytecodeHelpers.lload(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lmul() {\n+        writeBytecode(LMUL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lneg() {\n+        writeBytecode(LNEG);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lor() {\n+        writeBytecode(LOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lrem() {\n+        writeBytecode(LREM);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshl() {\n+        writeBytecode(LSHL);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lshr() {\n+        writeBytecode(LSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lstore(int slot) {\n+        writeLocalVar(BytecodeHelpers.lstore(slot), slot);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lsub() {\n+        writeBytecode(LSUB);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lushr() {\n+        writeBytecode(LUSHR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder lxor() {\n+        writeBytecode(LXOR);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorenter() {\n+        writeBytecode(MONITORENTER);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder monitorexit() {\n+        writeBytecode(MONITOREXIT);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder multianewarray(ClassEntry array, int dims) {\n+        writeNewMultidimensionalArray(dims, array);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder new_(ClassEntry clazz) {\n+        writeNewObject(clazz);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder newarray(TypeKind typeKind) {\n+        int atype = typeKind.newarrayCode(); \/\/ implicit null check\n+        if (atype < 0)\n+            throw new IllegalArgumentException(\"Illegal component type: \".concat(typeKind.upperBound().displayName()));\n+        writeNewPrimitiveArray(atype);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop() {\n+        writeBytecode(POP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder pop2() {\n+        writeBytecode(POP2);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder sipush(int s) {\n+        BytecodeHelpers.validateSipush(s);\n+        writeArgumentConstant(SIPUSH, s);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder swap() {\n+        writeBytecode(SWAP);\n+        return this;\n+    }\n+\n+    @Override\n+    public CodeBuilder tableswitch(int low, int high, Label defaultTarget, List<SwitchCase> cases) {\n+        writeTableSwitch(low, high, defaultTarget, cases);\n+        return this;\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/DirectCodeBuilder.java","additions":767,"deletions":25,"binary":false,"changes":792,"status":"modified"},{"patch":"@@ -102,6 +102,1 @@\n-            builder.withField(fieldName(), fieldType(), new Consumer<>() {\n-                @Override\n-                public void accept(FieldBuilder fb) {\n-                    FieldImpl.this.forEach(fb);\n-                }\n-            });\n+            builder.withField(fieldName(), fieldType(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/FieldImpl.java","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -139,7 +139,1 @@\n-            builder.withMethod(methodName(), methodType(), methodFlags(),\n-                               new Consumer<>() {\n-                @Override\n-                public void accept(MethodBuilder mb) {\n-                    MethodImpl.this.forEach(mb);\n-                }\n-            });\n+            builder.withMethod(methodName(), methodType(), methodFlags(), Util.writingAll(this));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/MethodImpl.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -269,2 +269,2 @@\n-    private <T extends ConstantDesc> PoolEntry findPrimitiveEntry(int tag, T val) {\n-        int hash = AbstractPoolEntry.hash1(tag, val.hashCode());\n+    private IntegerEntry findIntEntry(int val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_INTEGER, Integer.hashCode(val));\n@@ -274,4 +274,55 @@\n-            if (e.tag() == tag\n-                && e instanceof AbstractPoolEntry.PrimitiveEntry<?> ce\n-                && ce.value().equals(val))\n-                return e;\n+            if (e.tag() == TAG_INTEGER\n+                    && e instanceof AbstractPoolEntry.IntegerEntryImpl ce\n+                    && ce.intValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findIntEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private LongEntry findLongEntry(long val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_LONG, Long.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_LONG\n+                    && e instanceof AbstractPoolEntry.LongEntryImpl ce\n+                    && ce.longValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findLongEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private FloatEntry findFloatEntry(float val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_FLOAT, Float.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_FLOAT\n+                    && e instanceof AbstractPoolEntry.FloatEntryImpl ce\n+                    && ce.floatValue() == val)\n+                return ce;\n+        }\n+        if (!doneFullScan) {\n+            fullScan();\n+            return findFloatEntry(val);\n+        }\n+        return null;\n+    }\n+\n+    private DoubleEntry findDoubleEntry(double val) {\n+        int hash = AbstractPoolEntry.hash1(TAG_DOUBLE, Double.hashCode(val));\n+        EntryMap<PoolEntry> map = map();\n+        for (int token = map.firstToken(hash); token != -1; token = map.nextToken(hash, token)) {\n+            PoolEntry e = map.getElementByToken(token);\n+            if (e.tag() == TAG_DOUBLE\n+                    && e instanceof AbstractPoolEntry.DoubleEntryImpl ce\n+                    && ce.doubleValue() == val)\n+                return ce;\n@@ -281,1 +332,1 @@\n-            return findPrimitiveEntry(tag, val);\n+            return findDoubleEntry(val);\n@@ -545,1 +596,1 @@\n-        var e = (IntegerEntry) findPrimitiveEntry(TAG_INTEGER, value);\n+        var e = findIntEntry(value);\n@@ -551,1 +602,1 @@\n-        var e = (FloatEntry) findPrimitiveEntry(TAG_FLOAT, value);\n+        var e = findFloatEntry(value);\n@@ -557,1 +608,1 @@\n-        var e = (LongEntry) findPrimitiveEntry(TAG_LONG, value);\n+        var e = findLongEntry(value);\n@@ -563,1 +614,1 @@\n-        var e = (DoubleEntry) findPrimitiveEntry(TAG_DOUBLE, value);\n+        var e = findDoubleEntry(value);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/SplitConstantPool.java","additions":62,"deletions":11,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.lang.classfile.Attributes;\n@@ -29,0 +30,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -32,0 +35,1 @@\n+import java.lang.constant.ClassDesc;\n@@ -38,0 +42,1 @@\n+import java.util.stream.Collectors;\n@@ -40,2 +45,0 @@\n-import java.lang.constant.ClassDesc;\n-import java.util.stream.Collectors;\n@@ -50,0 +53,1 @@\n+                dcb.attributes.get(Attributes.stackMapTable()),\n@@ -100,0 +104,1 @@\n+                     StackMapTableAttribute smta,\n@@ -114,1 +119,2 @@\n-        maxStack = stack = rets = 0;\n+        stack = rets = 0;\n+        maxStack = handlers.isEmpty() ? 0 : 1;\n@@ -116,0 +122,11 @@\n+        if (smta != null) {\n+            for (var smfi : smta.entries()) {\n+                int frameStack = smfi.stack().size();\n+                for (var vti : smfi.stack()) {\n+                    if (vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG\n+                     || vti == StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_DOUBLE) frameStack++;\n+                }\n+                if (maxStack < frameStack) maxStack = frameStack;\n+                targets.add(new Target(labelContext.labelToBci(smfi.target()), frameStack));\n+            }\n+        }\n@@ -316,1 +333,1 @@\n-                        addStackSlot(Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd));\n+                        var delta = Util.slotSize(mtd.returnType()) - Util.parameterSlots(mtd);\n@@ -318,1 +335,1 @@\n-                            addStackSlot(-1);\n+                            delta--;\n@@ -320,0 +337,1 @@\n+                        addStackSlot(delta);\n@@ -322,1 +340,1 @@\n-                        addStackSlot (1 - bcs.getU1(bcs.bci + 3));\n+                        addStackSlot(1 - bcs.getU1(bcs.bci + 3));\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackCounter.java","additions":24,"deletions":6,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import java.util.Arrays;\n+import java.util.Comparator;\n@@ -40,1 +42,0 @@\n-import java.util.TreeMap;\n@@ -49,0 +50,1 @@\n+    private static final StackMapFrameInfo[] NO_STACK_FRAME_INFOS = new StackMapFrameInfo[0];\n@@ -106,1 +108,2 @@\n-        var map = new TreeMap<Integer, StackMapFrameInfo>();\n+        \/\/ avoid using method handles due to early bootstrap\n+        StackMapFrameInfo[] infos = entries.toArray(NO_STACK_FRAME_INFOS);\n@@ -108,7 +111,11 @@\n-        for (var fr : entries) {\n-            map.put(dcb.labelToBci(fr.target()), fr);\n-        }\n-        b.writeU2(map.size());\n-        for (var me : map.entrySet()) {\n-            int offset = me.getKey();\n-            var fr = me.getValue();\n+        Arrays.sort(infos, new Comparator<StackMapFrameInfo>() {\n+            public int compare(final StackMapFrameInfo o1, final StackMapFrameInfo o2) {\n+                return Integer.compare(dcb.labelToBci(o1.target()), dcb.labelToBci(o2.target()));\n+            }\n+        });\n+        b.writeU2(infos.length);\n+        for (var fr : infos) {\n+            int offset = dcb.labelToBci(fr.target());\n+            if (offset == prevOffset) {\n+                throw new IllegalArgumentException(\"Duplicated stack frame bytecode index: \" + offset);\n+            }\n@@ -164,2 +171,2 @@\n-        switch (vti) {\n-            case SimpleVerificationTypeInfo svti ->\n+        switch (vti.tag()) {\n+            case VT_TOP, VT_INTEGER, VT_FLOAT, VT_DOUBLE, VT_LONG, VT_NULL, VT_UNINITIALIZED_THIS ->\n@@ -167,4 +174,5 @@\n-            case ObjectVerificationTypeInfo ovti ->\n-                bw.writeIndex(ovti.className());\n-            case UninitializedVerificationTypeInfo uvti ->\n-                bw.writeU2(bw.labelContext().labelToBci(uvti.newTarget()));\n+            case VT_OBJECT ->\n+                bw.writeIndex(((ObjectVerificationTypeInfo)vti).className());\n+            case VT_UNINITIALIZED ->\n+                bw.writeU2(bw.labelContext().labelToBci(((UninitializedVerificationTypeInfo)vti).newTarget()));\n+            default -> throw new IllegalArgumentException(\"Invalid verification type tag: \" + vti.tag());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/StackMapDecoder.java","additions":23,"deletions":15,"binary":false,"changes":38,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import java.lang.classfile.AnnotationElement;\n@@ -39,1 +38,0 @@\n-import java.lang.classfile.Label;\n@@ -761,52 +759,1 @@\n-                                        Utf8Entry className,\n-                                        List<AnnotationElement> elements) implements TypeAnnotation, Util.Writable {\n-\n-        public UnboundTypeAnnotation(TargetInfo targetInfo, List<TypePathComponent> targetPath,\n-                                     Utf8Entry className, List<AnnotationElement> elements) {\n-            this.targetInfo = targetInfo;\n-            this.targetPath = List.copyOf(targetPath);\n-            this.className = className;\n-            this.elements = List.copyOf(elements);\n-        }\n-\n-        private int labelToBci(LabelContext lr, Label label) {\n-            \/\/helper method to avoid NPE\n-            if (lr == null) throw new IllegalArgumentException(\"Illegal targetType '%s' in TypeAnnotation outside of Code attribute\".formatted(targetInfo.targetType()));\n-            return lr.labelToBci(label);\n-        }\n-\n-        @Override\n-        public void writeTo(BufWriterImpl buf) {\n-            LabelContext lr = buf.labelContext();\n-            \/\/ target_type\n-            buf.writeU1(targetInfo.targetType().targetTypeValue());\n-\n-            \/\/ target_info\n-            switch (targetInfo) {\n-                case TypeParameterTarget tpt -> buf.writeU1(tpt.typeParameterIndex());\n-                case SupertypeTarget st -> buf.writeU2(st.supertypeIndex());\n-                case TypeParameterBoundTarget tpbt -> {\n-                    buf.writeU1(tpbt.typeParameterIndex());\n-                    buf.writeU1(tpbt.boundIndex());\n-                }\n-                case EmptyTarget et -> {\n-                    \/\/ nothing to write\n-                }\n-                case FormalParameterTarget fpt -> buf.writeU1(fpt.formalParameterIndex());\n-                case ThrowsTarget tt -> buf.writeU2(tt.throwsTargetIndex());\n-                case LocalVarTarget lvt -> {\n-                    buf.writeU2(lvt.table().size());\n-                    for (var e : lvt.table()) {\n-                        int startPc = labelToBci(lr, e.startLabel());\n-                        buf.writeU2(startPc);\n-                        buf.writeU2(labelToBci(lr, e.endLabel()) - startPc);\n-                        buf.writeU2(e.index());\n-                    }\n-                }\n-                case CatchTarget ct -> buf.writeU2(ct.exceptionTableIndex());\n-                case OffsetTarget ot -> buf.writeU2(labelToBci(lr, ot.target()));\n-                case TypeArgumentTarget tat -> {\n-                    buf.writeU2(labelToBci(lr, tat.target()));\n-                    buf.writeU1(tat.typeArgumentIndex());\n-                }\n-            }\n+                                        Annotation annotation) implements TypeAnnotation {\n@@ -814,16 +761,2 @@\n-            \/\/ target_path\n-            buf.writeU1(targetPath().size());\n-            for (TypePathComponent component : targetPath()) {\n-                buf.writeU1(component.typePathKind().tag());\n-                buf.writeU1(component.typeArgumentIndex());\n-            }\n-\n-            \/\/ type_index\n-            buf.writeIndex(className);\n-\n-            \/\/ element_value_pairs\n-            buf.writeU2(elements.size());\n-            for (AnnotationElement pair : elements()) {\n-                buf.writeIndex(pair.name());\n-                AnnotationReader.writeAnnotationValue(buf, pair.value());\n-            }\n+        public UnboundTypeAnnotation {\n+            targetPath = List.copyOf(targetPath);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/UnboundAttribute.java","additions":3,"deletions":70,"binary":false,"changes":73,"status":"modified"},{"patch":"@@ -27,0 +27,1 @@\n+import java.lang.classfile.CodeBuilder;\n@@ -28,0 +29,2 @@\n+import java.lang.classfile.FieldBuilder;\n+import java.lang.classfile.MethodBuilder;\n@@ -66,0 +69,30 @@\n+    public static <T> Consumer<Consumer<T>> writingAll(Iterable<T> container) {\n+        record ForEachConsumer<T>(Iterable<T> container) implements Consumer<Consumer<T>> {\n+            @Override\n+            public void accept(Consumer<T> consumer) {\n+                container.forEach(consumer);\n+            }\n+        }\n+        return new ForEachConsumer<>(container);\n+    }\n+\n+    public static Consumer<MethodBuilder> buildingCode(Consumer<? super CodeBuilder> codeHandler) {\n+        record WithCodeMethodHandler(Consumer<? super CodeBuilder> codeHandler) implements Consumer<MethodBuilder> {\n+            @Override\n+            public void accept(MethodBuilder builder) {\n+                builder.withCode(codeHandler);\n+            }\n+        }\n+        return new WithCodeMethodHandler(codeHandler);\n+    }\n+\n+    public static Consumer<FieldBuilder> buildingFlags(int flags) {\n+        record WithFlagFieldHandler(int flags) implements Consumer<FieldBuilder> {\n+            @Override\n+            public void accept(FieldBuilder builder) {\n+                builder.withFlags(flags);\n+            }\n+        }\n+        return new WithFlagFieldHandler(flags);\n+    }\n+\n@@ -155,2 +188,6 @@\n-            throw new IllegalArgumentException(\n-                    String.format(\"Wrong opcode kind specified; found %s(%s), expected %s\", op, op.kind(), k));\n+            throw badOpcodeKindException(op, k);\n+    }\n+\n+    public static IllegalArgumentException badOpcodeKindException(Opcode op, Opcode.Kind k) {\n+        return new IllegalArgumentException(\n+                String.format(\"Wrong opcode kind specified; found %s(%s), expected %s\", op, op.kind(), k));\n@@ -194,1 +231,1 @@\n-    private static <T> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n+    private static <T extends Attribute<T>> void writeAttribute(BufWriterImpl writer, Attribute<?> attr) {\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/Util.java","additions":40,"deletions":3,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,6 +233,6 @@\n-                    case BooleanType, ByteType, CharType, IntType, ShortType -> cve instanceof IntegerEntry;\n-                    case DoubleType -> cve instanceof DoubleEntry;\n-                    case FloatType -> cve instanceof FloatEntry;\n-                    case LongType -> cve instanceof LongEntry;\n-                    case ReferenceType -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n-                    case VoidType -> false;\n+                    case BOOLEAN, BYTE, CHAR, INT, SHORT -> cve instanceof IntegerEntry;\n+                    case DOUBLE -> cve instanceof DoubleEntry;\n+                    case FLOAT -> cve instanceof FloatEntry;\n+                    case LONG -> cve instanceof LongEntry;\n+                    case REFERENCE -> type.equals(ConstantDescs.CD_String) && cve instanceof StringEntry;\n+                    case VOID -> false;\n@@ -396,1 +396,1 @@\n-            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an);\n+            l += 2 + an.targetInfo().size() + 2 * an.targetPath().size() + annotationSize(an.annotation());\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/classfile\/impl\/verifier\/ParserVerifier.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -38,0 +38,2 @@\n+import static jdk.internal.constant.PrimitiveClassDescImpl.*;\n+\n@@ -272,33 +274,13 @@\n-    \/**\n-     * Parses a method descriptor string, and return a list of field descriptor\n-     * strings, return type first, then parameter types\n-     *\n-     * @param descriptor the descriptor string\n-     * @return the list of types\n-     * @throws IllegalArgumentException if the descriptor string is not valid\n-     *\/\n-    public static List<ClassDesc> parseMethodDescriptor(String descriptor) {\n-        int cur = 0, end = descriptor.length();\n-        ArrayList<ClassDesc> ptypes = new ArrayList<>();\n-        ptypes.add(null); \/\/ placeholder for return type\n-\n-        if (cur >= end || descriptor.charAt(cur) != '(')\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-\n-        ++cur;  \/\/ skip '('\n-        while (cur < end && descriptor.charAt(cur) != ')') {\n-            int len = skipOverFieldSignature(descriptor, cur, end, false);\n-            if (len == 0)\n-                throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-            ptypes.add(resolveClassDesc(descriptor, cur, len));\n-            cur += len;\n-        }\n-        if (cur >= end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ++cur;  \/\/ skip ')'\n-\n-        int rLen = skipOverFieldSignature(descriptor, cur, end, true);\n-        if (rLen == 0 || cur + rLen != end)\n-            throw new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n-        ptypes.set(0, resolveClassDesc(descriptor, cur, rLen));\n-        return ptypes;\n+    public static PrimitiveClassDescImpl forPrimitiveType(String descriptor, int offset) {\n+        return switch (descriptor.charAt(offset)) {\n+            case JVM_SIGNATURE_BYTE    -> CD_byte;\n+            case JVM_SIGNATURE_CHAR    -> CD_char;\n+            case JVM_SIGNATURE_FLOAT   -> CD_float;\n+            case JVM_SIGNATURE_DOUBLE  -> CD_double;\n+            case JVM_SIGNATURE_INT     -> CD_int;\n+            case JVM_SIGNATURE_LONG    -> CD_long;\n+            case JVM_SIGNATURE_SHORT   -> CD_short;\n+            case JVM_SIGNATURE_VOID    -> CD_void;\n+            case JVM_SIGNATURE_BOOLEAN -> CD_boolean;\n+            default -> throw badMethodDescriptor(descriptor);\n+        };\n@@ -307,1 +289,1 @@\n-    private static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n+    static ClassDesc resolveClassDesc(String descriptor, int start, int len) {\n@@ -309,1 +291,1 @@\n-            return Wrapper.forPrimitiveType(descriptor.charAt(start)).basicClassDescriptor();\n+            return forPrimitiveType(descriptor, start);\n@@ -311,1 +293,2 @@\n-        \/\/ Pre-verified in parseMethodDescriptor; avoid redundant verification\n+\n+        \/\/ Pre-verified in MethodTypeDescImpl#ofDescriptor; avoid redundant verification\n@@ -315,0 +298,4 @@\n+    static IllegalArgumentException badMethodDescriptor(String descriptor) {\n+        return new IllegalArgumentException(\"Bad method descriptor: \" + descriptor);\n+    }\n+\n@@ -319,2 +306,0 @@\n-    private static final char JVM_SIGNATURE_ENDCLASS = ';';\n-    private static final char JVM_SIGNATURE_ENUM = 'E';\n@@ -323,2 +308,0 @@\n-    private static final char JVM_SIGNATURE_FUNC = '(';\n-    private static final char JVM_SIGNATURE_ENDFUNC = ')';\n@@ -337,1 +320,0 @@\n-     * @param voidOK is void acceptable?\n@@ -341,2 +323,1 @@\n-    @SuppressWarnings(\"fallthrough\")\n-    static int skipOverFieldSignature(String descriptor, int start, int end, boolean voidOK) {\n+    static int skipOverFieldSignature(String descriptor, int start, int end) {\n@@ -345,3 +326,10 @@\n-        while (index < end) {\n-            switch (descriptor.charAt(index)) {\n-                case JVM_SIGNATURE_VOID: if (!voidOK) { return 0; }\n+        if (index < end) {\n+            char ch;\n+            while ((ch = descriptor.charAt(index++)) == JVM_SIGNATURE_ARRAY) {\n+                arrayDim++;\n+            }\n+            if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n+                throw maxArrayTypeDescDimensions();\n+            }\n+\n+            switch (ch) {\n@@ -356,1 +344,1 @@\n-                    return index - start + 1;\n+                    return index - start;\n@@ -361,2 +349,2 @@\n-                    while (++index < end) {\n-                        switch (descriptor.charAt(index)) {\n+                    while (index < end) {\n+                        switch (descriptor.charAt(index++)) {\n@@ -365,1 +353,1 @@\n-                                return legal ? index - start + 1 : 0;\n+                                return legal ? index - start : 0;\n@@ -380,10 +368,0 @@\n-                    return 0;\n-                case JVM_SIGNATURE_ARRAY:\n-                    arrayDim++;\n-                    if (arrayDim > MAX_ARRAY_TYPE_DESC_DIMENSIONS) {\n-                        throw new IllegalArgumentException(String.format(\"Cannot create an array type descriptor with more than %d dimensions\",\n-                                ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n-                    }\n-                    \/\/ The rest of what's there better be a legal descriptor\n-                    index++;\n-                    voidOK = false;\n@@ -392,1 +370,1 @@\n-                    return 0;\n+                    break;\n@@ -397,0 +375,6 @@\n+\n+    private static IllegalArgumentException maxArrayTypeDescDimensions() {\n+        return new IllegalArgumentException(String.format(\n+                        \"Cannot create an array type descriptor with more than %d dimensions\",\n+                        ConstantUtils.MAX_ARRAY_TYPE_DESC_DIMENSIONS));\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ConstantUtils.java","additions":45,"deletions":61,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import java.lang.constant.ConstantDescs;\n@@ -35,0 +37,1 @@\n+import java.util.ArrayList;\n@@ -41,0 +44,6 @@\n+import static jdk.internal.constant.ConstantUtils.badMethodDescriptor;\n+import static jdk.internal.constant.ConstantUtils.resolveClassDesc;\n+import static jdk.internal.constant.ConstantUtils.skipOverFieldSignature;\n+import static jdk.internal.constant.ConstantUtils.EMPTY_CLASSDESC;\n+import static jdk.internal.constant.PrimitiveClassDescImpl.CD_void;\n+\n@@ -94,1 +103,1 @@\n-            return new MethodTypeDescImpl(returnType, ConstantUtils.EMPTY_CLASSDESC);\n+            return new MethodTypeDescImpl(returnType, EMPTY_CLASSDESC);\n@@ -108,8 +117,17 @@\n-        \/\/ Implicit null-check of descriptor\n-        List<ClassDesc> ptypes = ConstantUtils.parseMethodDescriptor(descriptor);\n-        int args = ptypes.size() - 1;\n-        ClassDesc[] paramTypes = args > 0\n-                ? ptypes.subList(1, args + 1).toArray(ConstantUtils.EMPTY_CLASSDESC)\n-                : ConstantUtils.EMPTY_CLASSDESC;\n-\n-        MethodTypeDescImpl result = ofValidated(ptypes.get(0), paramTypes);\n+        int length = descriptor.length();\n+        int rightBracket, retTypeLength;\n+        if (descriptor.charAt(0) != '('\n+                || (rightBracket = (descriptor.charAt(1) == ')' ? 1 : descriptor.lastIndexOf(')'))) <= 0\n+                || (retTypeLength = length - rightBracket - 1) == 0\n+                || (retTypeLength != 1 \/\/ if retTypeLength == 1, check correctness in resolveClassDesc\n+                    && retTypeLength != skipOverFieldSignature(descriptor, rightBracket + 1, length))\n+        ) {\n+            throw badMethodDescriptor(descriptor);\n+        }\n+\n+        var returnType = resolveClassDesc(descriptor, rightBracket + 1, retTypeLength);\n+        if (length == 3 && returnType == CD_void) {\n+            return (MethodTypeDescImpl) ConstantDescs.MTD_void;\n+        }\n+        var paramTypes = paramTypes(descriptor, 1, rightBracket);\n+        var result = new MethodTypeDescImpl(returnType, paramTypes);\n@@ -120,0 +138,71 @@\n+    private static ClassDesc[] paramTypes(String descriptor, int start, int end) {\n+        if (start == end) {\n+            return EMPTY_CLASSDESC;\n+        }\n+\n+        \/*\n+         * If the length of the first 8 parameters is < 256, save them in lengths to avoid ArrayList allocation\n+         * Stop storing for the last parameter (we can compute length), or if too many parameters or too long.\n+         *\/\n+        \/\/ little endian storage - lowest byte is encoded length 0\n+        long packedLengths = 0;\n+        int packedCount = 0;\n+        int cur = start;\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0) {\n+                throw badMethodDescriptor(descriptor);\n+            }\n+            cur += len;\n+            if (len > 0xFF || packedCount >= Long.SIZE \/ Byte.SIZE || cur == end) {\n+                \/\/ Cannot or do not have to pack this item, but is already scanned and valid\n+                break;\n+            }\n+            packedLengths = packedLengths | (((long) len) << (Byte.SIZE * packedCount++));\n+        }\n+\n+        \/\/ Invariant: packedCount parameters encoded in packedLengths,\n+        \/\/ And another valid parameter pointed by cur\n+\n+        \/\/ Recover encoded elements\n+        ClassDesc[]     paramTypes    = null;\n+        List<ClassDesc> paramTypeList = null;\n+        if (cur == end) {\n+            paramTypes = new ClassDesc[packedCount + 1];\n+        } else {\n+            paramTypeList = new ArrayList<>(32);\n+        }\n+\n+        int last = start;\n+        for (int i = 0; i < packedCount; i++) {\n+            int len = Byte.toUnsignedInt((byte) (packedLengths >> (Byte.SIZE * i)));\n+            var cd = resolveClassDesc(descriptor, last, len);\n+            if (paramTypes != null) {\n+                paramTypes[i] = cd;\n+            } else {\n+                paramTypeList.add(cd);\n+            }\n+            last += len;\n+        }\n+        var lastCd = resolveClassDesc(descriptor, last, cur - last);\n+\n+        if (paramTypes != null) {\n+            paramTypes[packedCount] = lastCd;\n+            return paramTypes;\n+        }\n+        paramTypeList.add(lastCd);\n+        return buildParamTypes(descriptor, cur, end, paramTypeList);\n+    }\n+\n+    \/\/ slow path\n+    private static ClassDesc[] buildParamTypes(String descriptor, int cur, int end, List<ClassDesc> list) {\n+        while (cur < end) {\n+            int len = skipOverFieldSignature(descriptor, cur, end);\n+            if (len == 0)\n+                throw badMethodDescriptor(descriptor);\n+            list.add(resolveClassDesc(descriptor, cur, len));\n+            cur += len;\n+        }\n+\n+        return list.toArray(EMPTY_CLASSDESC);\n+    }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/MethodTypeDescImpl.java","additions":98,"deletions":9,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -32,0 +32,1 @@\n+import jdk.internal.vm.annotation.Stable;\n@@ -43,0 +44,27 @@\n+    \/** {@link ClassDesc} representing the primitive type {@code int} *\/\n+    public static final PrimitiveClassDescImpl CD_int = new PrimitiveClassDescImpl(\"I\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code long} *\/\n+    public static final PrimitiveClassDescImpl CD_long = new PrimitiveClassDescImpl(\"J\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code float} *\/\n+    public static final PrimitiveClassDescImpl CD_float = new PrimitiveClassDescImpl(\"F\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code double} *\/\n+    public static final PrimitiveClassDescImpl CD_double = new PrimitiveClassDescImpl(\"D\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code short} *\/\n+    public static final PrimitiveClassDescImpl CD_short = new PrimitiveClassDescImpl(\"S\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code byte} *\/\n+    public static final PrimitiveClassDescImpl CD_byte = new PrimitiveClassDescImpl(\"B\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code char} *\/\n+    public static final PrimitiveClassDescImpl CD_char = new PrimitiveClassDescImpl(\"C\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code boolean} *\/\n+    public static final PrimitiveClassDescImpl CD_boolean = new PrimitiveClassDescImpl(\"Z\");\n+\n+    \/** {@link ClassDesc} representing the primitive type {@code void} *\/\n+    public static final PrimitiveClassDescImpl CD_void = new PrimitiveClassDescImpl(\"V\");\n+\n@@ -44,0 +72,1 @@\n+    private @Stable Wrapper lazyWrapper; \/\/ initialized only after this\n@@ -55,1 +84,1 @@\n-    public PrimitiveClassDescImpl(String descriptor) {\n+    private PrimitiveClassDescImpl(String descriptor) {\n@@ -57,3 +86,0 @@\n-        if (descriptor.length() != 1\n-            || \"VIJCSBFDZ\".indexOf(descriptor.charAt(0)) < 0)\n-            throw new IllegalArgumentException(String.format(\"not a valid primitive type descriptor: %s\", descriptor));\n@@ -63,0 +89,7 @@\n+    public Wrapper wrapper() {\n+        var wrapper = this.lazyWrapper;\n+        if (wrapper != null)\n+            return wrapper;\n+        return this.lazyWrapper = Wrapper.forBasicType(descriptorString().charAt(0));\n+    }\n+\n@@ -70,1 +103,1 @@\n-        return Wrapper.forBasicType(descriptorString().charAt(0)).primitiveType();\n+        return wrapper().primitiveType();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/PrimitiveClassDescImpl.java","additions":38,"deletions":5,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen, false);\n+        int len = ConstantUtils.skipOverFieldSignature(descriptor, 0, dLen);\n@@ -69,1 +69,1 @@\n-        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length(), false)\n+        assert ConstantUtils.skipOverFieldSignature(descriptor, 0, descriptor.length())\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/constant\/ReferenceClassDescImpl.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -54,0 +54,1 @@\n+import jdk.internal.util.Architecture;\n@@ -155,1 +156,1 @@\n-        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\");\n+        Reflection.ensureNativeAccess(callerClass, MemorySegment.class, \"reinterpret\", false);\n@@ -191,0 +192,4 @@\n+    \/\/ FILL_NATIVE_THRESHOLD must be a power of two and should be greater than 2^3\n+    \/\/ Update the value for Aarch64 once 8338975 is fixed.\n+    private static final long FILL_NATIVE_THRESHOLD = 1L << (Architecture.isAARCH64() ? 10 : 5);\n+\n@@ -192,3 +197,41 @@\n-    public final MemorySegment fill(byte value){\n-        checkAccess(0, length, false);\n-        SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+    @ForceInline\n+    public final MemorySegment fill(byte value) {\n+        checkReadOnly(false);\n+        if (length == 0) {\n+            \/\/ Implicit state check\n+            checkValidState();\n+        } else if (length < FILL_NATIVE_THRESHOLD) {\n+            \/\/ 0 <= length < FILL_NATIVE_LIMIT : 0...0X...XXXX\n+\n+            \/\/ Handle smaller segments directly without transitioning to native code\n+            final long u = Byte.toUnsignedLong(value);\n+            final long longValue = u << 56 | u << 48 | u << 40 | u << 32 | u << 24 | u << 16 | u << 8 | u;\n+\n+            int offset = 0;\n+            \/\/ 0...0X...X000\n+            final int limit = (int) (length & (FILL_NATIVE_THRESHOLD - 8));\n+            for (; offset < limit; offset += 8) {\n+                SCOPED_MEMORY_ACCESS.putLong(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, longValue);\n+            }\n+            int remaining = (int) length - limit;\n+            \/\/ 0...0X00\n+            if (remaining >= 4) {\n+                SCOPED_MEMORY_ACCESS.putInt(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (int) longValue);\n+                offset += 4;\n+                remaining -= 4;\n+            }\n+            \/\/ 0...00X0\n+            if (remaining >= 2) {\n+                SCOPED_MEMORY_ACCESS.putShort(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, (short) longValue);\n+                offset += 2;\n+                remaining -= 2;\n+            }\n+            \/\/ 0...000X\n+            if (remaining == 1) {\n+                SCOPED_MEMORY_ACCESS.putByte(sessionImpl(), unsafeGetBase(), unsafeGetOffset() + offset, value);\n+            }\n+            \/\/ We have now fully handled 0...0X...XXXX\n+        } else {\n+            \/\/ Handle larger segments via native calls\n+            SCOPED_MEMORY_ACCESS.setMemory(sessionImpl(), unsafeGetBase(), unsafeGetOffset(), length, value);\n+        }\n@@ -376,0 +419,10 @@\n+    @ForceInline\n+    public final void checkEnclosingLayout(long offset, MemoryLayout enclosing, boolean readOnly) {\n+        checkAccess(offset, enclosing.byteSize(), readOnly);\n+        if (!isAlignedForElement(offset, enclosing)) {\n+            throw new IllegalArgumentException(String.format(\n+                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n+                    , offset, enclosing.byteAlignment(), enclosing, this));\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/AbstractMemorySegmentImpl.java","additions":57,"deletions":4,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-    private static final MethodHandle MH_ADD;\n+    private static final MethodHandle MH_ADD_EXACT;\n@@ -83,2 +83,2 @@\n-                    MethodType.methodType(MemorySegment.class, MemorySegment.class, MemoryLayout.class));\n-            MH_ADD = lookup.findStatic(Long.class, \"sum\",\n+                    MethodType.methodType(MemorySegment.class, MemorySegment.class));\n+            MH_ADD_EXACT = lookup.findStatic(Math.class, \"addExact\",\n@@ -183,2 +183,1 @@\n-        handle = MethodHandles.filterReturnValue(handle,\n-                MethodHandles.insertArguments(MH_SEGMENT_RESIZE, 1, derefLayout));\n+        handle = MethodHandles.filterReturnValue(handle, MH_SEGMENT_RESIZE);\n@@ -188,2 +187,4 @@\n-    private static MemorySegment resizeSegment(MemorySegment segment, MemoryLayout layout) {\n-        return Utils.longToAddress(segment.address(), layout.byteSize(), layout.byteAlignment());\n+    private static MemorySegment resizeSegment(MemorySegment segment) {\n+        \/\/ Avoid adapting for specific target layout. The check for the root layout\n+        \/\/ size and alignment will be inserted by LayoutPath::dereferenceHandle anyway.\n+        return Utils.longToAddress(segment.address(), Long.MAX_VALUE, 1);\n@@ -208,13 +209,9 @@\n-        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);\n-        handle = MethodHandles.collectCoordinates(handle, 1, offsetHandle());\n-\n-        \/\/ we only have to check the alignment of the root layout for the first dereference we do,\n-        \/\/ as each dereference checks the alignment of the target address when constructing its segment\n-        \/\/ (see Utils::longToAddress)\n-        if (derefAdapters.length == 0) {\n-            \/\/ insert align check for the root layout on the initial MS + offset\n-            List<Class<?>> coordinateTypes = handle.coordinateTypes();\n-            MethodHandle alignCheck = MethodHandles.insertArguments(MH_CHECK_ENCL_LAYOUT, 2, rootLayout());\n-            handle = MethodHandles.collectCoordinates(handle, 0, alignCheck);\n-            int[] reorder = IntStream.concat(IntStream.of(0, 1), IntStream.range(0, coordinateTypes.size())).toArray();\n-            handle = MethodHandles.permuteCoordinates(handle, coordinateTypes, reorder);\n+        VarHandle handle = Utils.makeRawSegmentViewVarHandle(valueLayout);              \/\/ (MS, ML, long, long)\n+        handle = MethodHandles.insertCoordinates(handle, 1, rootLayout());          \/\/ (MS, long, long)\n+        if (strides.length > 0) {\n+            MethodHandle offsetAdapter = offsetHandle();\n+            offsetAdapter = MethodHandles.insertArguments(offsetAdapter, 0, 0L);\n+            handle = MethodHandles.collectCoordinates(handle, 2, offsetAdapter);    \/\/ (MS, long)\n+        } else {\n+            \/\/ simpler adaptation\n+            handle = MethodHandles.insertCoordinates(handle, 2, offset);            \/\/ (MS, long)\n@@ -244,0 +241,2 @@\n+        \/\/ note: the below can overflow, depending on 'base'. When constructing var handles\n+        \/\/ through the layout API, this is never the case, as the injected 'base' is always 0.\n@@ -248,1 +247,1 @@\n-        MethodHandle mh = MethodHandles.insertArguments(MH_ADD, 0, offset);\n+        MethodHandle mh = MH_ADD_EXACT;\n@@ -251,3 +250,7 @@\n-            \/\/ (J, ...) -> J to (J, J, ...) -> J\n-            \/\/ i.e. new coord is prefixed. Last coord will correspond to innermost layout\n-            mh = MethodHandles.collectArguments(mh, 0, collector);\n+            \/\/ (J, J, ...) -> J to (J, J, J, ...) -> J\n+            \/\/ 1. the leading argument is the base offset (externally provided).\n+            \/\/ 2. index arguments are added. The last index correspond to the innermost layout.\n+            \/\/ 3. overflow can only occur at the outermost layer, due to the final addition with the base offset.\n+            \/\/ This is because the layout API ensures (by construction) that all offsets generated from layout paths\n+            \/\/ are always < Long.MAX_VALUE.\n+            mh = MethodHandles.collectArguments(mh, 1, collector);\n@@ -255,2 +258,1 @@\n-\n-        return mh;\n+        return MethodHandles.insertArguments(mh, 1, offset);\n@@ -288,6 +290,1 @@\n-        ((AbstractMemorySegmentImpl)segment).checkAccess(offset, enclosing.byteSize(), true);\n-        if (!((AbstractMemorySegmentImpl) segment).isAlignedForElement(offset, enclosing)) {\n-            throw new IllegalArgumentException(String.format(\n-                    \"Target offset %d is incompatible with alignment constraint %d (of %s) for segment %s\"\n-                    , offset, enclosing.byteAlignment(), enclosing, segment));\n-        }\n+        ((AbstractMemorySegmentImpl)segment).checkEnclosingLayout(offset, enclosing, true);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/LayoutPath.java","additions":29,"deletions":32,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -66,1 +66,2 @@\n-    private static final MethodHandle LONG_TO_ADDRESS;\n+    private static final MethodHandle LONG_TO_ADDRESS_TARGET;\n+    private static final MethodHandle LONG_TO_ADDRESS_NO_TARGET;\n@@ -77,2 +78,4 @@\n-            LONG_TO_ADDRESS = lookup.findStatic(Utils.class, \"longToAddress\",\n-                    MethodType.methodType(MemorySegment.class, long.class, long.class, long.class));\n+            LONG_TO_ADDRESS_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class, AddressLayout.class));\n+            LONG_TO_ADDRESS_NO_TARGET = lookup.findStatic(Utils.class, \"longToAddress\",\n+                    MethodType.methodType(MemorySegment.class, long.class));\n@@ -132,5 +135,4 @@\n-            handle = MethodHandles.filterValue(handle,\n-                    MethodHandles.explicitCastArguments(ADDRESS_TO_LONG, MethodType.methodType(baseCarrier, MemorySegment.class)),\n-                    MethodHandles.explicitCastArguments(MethodHandles.insertArguments(LONG_TO_ADDRESS, 1,\n-                                    pointeeByteSize(addressLayout), pointeeByteAlign(addressLayout)),\n-                            MethodType.methodType(MemorySegment.class, baseCarrier)));\n+            MethodHandle longToAddressAdapter = addressLayout.targetLayout().isPresent() ?\n+                    MethodHandles.insertArguments(LONG_TO_ADDRESS_TARGET, 1, addressLayout) :\n+                    LONG_TO_ADDRESS_NO_TARGET;\n+            handle = MethodHandles.filterValue(handle, ADDRESS_TO_LONG, longToAddressAdapter);\n@@ -149,0 +151,10 @@\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr) {\n+        return longToAddress(addr, 0, 1);\n+    }\n+\n+    @ForceInline\n+    public static MemorySegment longToAddress(long addr, AddressLayout layout) {\n+        return longToAddress(addr, pointeeByteSize(layout), pointeeByteAlign(layout));\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/Utils.java","additions":20,"deletions":8,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -83,1 +83,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -91,1 +91,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"downcallHandle\", false);\n@@ -118,1 +118,1 @@\n-        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\");\n+        Reflection.ensureNativeAccess(Reflection.getCallerClass(), Linker.class, \"upcallStub\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/AbstractLinker.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -276,1 +276,1 @@\n-                    int scopeLocal = cb.allocateLocal(ReferenceType);\n+                    int scopeLocal = cb.allocateLocal(REFERENCE);\n@@ -279,1 +279,1 @@\n-                    cb.storeLocal(ReferenceType, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n+                    cb.storeLocal(REFERENCE, scopeLocal); \/\/ need to initialize all scope locals here in case an exception occurs\n@@ -295,2 +295,2 @@\n-        contextIdx = cb.allocateLocal(ReferenceType);\n-        cb.storeLocal(ReferenceType, contextIdx);\n+        contextIdx = cb.allocateLocal(REFERENCE);\n+        cb.storeLocal(REFERENCE, contextIdx);\n@@ -303,2 +303,2 @@\n-            returnBufferIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, returnBufferIdx);\n+            returnBufferIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, returnBufferIdx);\n@@ -327,1 +327,1 @@\n-                    cb.loadLocal(ReferenceType, returnBufferIdx);\n+                    cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -342,2 +342,2 @@\n-                    returnBufferIdx = cb.allocateLocal(ReferenceType);\n-                    cb.storeLocal(ReferenceType, returnBufferIdx);\n+                    returnBufferIdx = cb.allocateLocal(REFERENCE);\n+                    cb.storeLocal(REFERENCE, returnBufferIdx);\n@@ -358,1 +358,1 @@\n-            cb.loadLocal(ReferenceType, 0); \/\/ load target arg\n+            cb.loadLocal(REFERENCE, 0); \/\/ load target arg\n@@ -509,1 +509,1 @@\n-            cb.loadLocal(ReferenceType, scopeSlots[i]);\n+            cb.loadLocal(REFERENCE, scopeSlots[i]);\n@@ -518,1 +518,1 @@\n-        cb.storeLocal(ReferenceType, nextScopeLocal); \/\/ store off one to release later\n+        cb.storeLocal(REFERENCE, nextScopeLocal); \/\/ store off one to release later\n@@ -532,1 +532,1 @@\n-            cb.loadLocal(ReferenceType, scopeLocal);\n+            cb.loadLocal(REFERENCE, scopeLocal);\n@@ -534,1 +534,1 @@\n-                ifCb.loadLocal(ReferenceType, scopeLocal);\n+                ifCb.loadLocal(REFERENCE, scopeLocal);\n@@ -554,1 +554,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -562,1 +562,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -567,1 +567,1 @@\n-        cb.loadLocal(ReferenceType, contextIdx);\n+        cb.loadLocal(REFERENCE, contextIdx);\n@@ -588,1 +588,1 @@\n-            cb.loadLocal(ReferenceType, returnAllocatorIdx);\n+            cb.loadLocal(REFERENCE, returnAllocatorIdx);\n@@ -621,4 +621,4 @@\n-            int longValueIdx = cb.allocateLocal(LongType);\n-            cb.storeLocal(LongType, longValueIdx);\n-            int writeAddrIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, writeAddrIdx);\n+            int longValueIdx = cb.allocateLocal(LONG);\n+            cb.storeLocal(LONG, longValueIdx);\n+            int writeAddrIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, writeAddrIdx);\n@@ -651,1 +651,1 @@\n-                cb.loadLocal(LongType, longValueIdx);\n+                cb.loadLocal(LONG, longValueIdx);\n@@ -665,1 +665,1 @@\n-                cb.loadLocal(ReferenceType, writeAddrIdx);\n+                cb.loadLocal(REFERENCE, writeAddrIdx);\n@@ -697,1 +697,1 @@\n-                cb.loadLocal(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -717,1 +717,1 @@\n-                cb.loadLocal(ReferenceType, returnBufferIdx);\n+                cb.loadLocal(REFERENCE, returnBufferIdx);\n@@ -817,2 +817,2 @@\n-            int readAddrIdx = cb.allocateLocal(ReferenceType);\n-            cb.storeLocal(ReferenceType, readAddrIdx);\n+            int readAddrIdx = cb.allocateLocal(REFERENCE);\n+            cb.storeLocal(REFERENCE, readAddrIdx);\n@@ -821,2 +821,2 @@\n-            int resultIdx = cb.allocateLocal(LongType);\n-            cb.storeLocal(LongType, resultIdx);\n+            int resultIdx = cb.allocateLocal(LONG);\n+            cb.storeLocal(LONG, resultIdx);\n@@ -851,1 +851,1 @@\n-                cb.loadLocal(ReferenceType, readAddrIdx);\n+                cb.loadLocal(REFERENCE, readAddrIdx);\n@@ -866,1 +866,1 @@\n-                cb.loadLocal(LongType, resultIdx);\n+                cb.loadLocal(LONG, resultIdx);\n@@ -868,1 +868,1 @@\n-                cb.storeLocal(LongType, resultIdx);\n+                cb.storeLocal(LONG, resultIdx);\n@@ -874,1 +874,1 @@\n-            cb.loadLocal(LongType, resultIdx);\n+            cb.loadLocal(LONG, resultIdx);\n@@ -900,2 +900,2 @@\n-        int storeIdx = cb.allocateLocal(ReferenceType);\n-        cb.storeLocal(ReferenceType, storeIdx);\n+        int storeIdx = cb.allocateLocal(REFERENCE);\n+        cb.storeLocal(REFERENCE, storeIdx);\n@@ -906,1 +906,1 @@\n-        cb.loadLocal(ReferenceType, storeIdx);\n+        cb.loadLocal(REFERENCE, storeIdx);\n@@ -985,5 +985,5 @@\n-            case BooleanType, ByteType, ShortType, CharType, IntType -> cb.iconst_0();\n-            case LongType -> cb.lconst_0();\n-            case FloatType -> cb.fconst_0();\n-            case DoubleType -> cb.dconst_0();\n-            case ReferenceType -> cb.aconst_null();\n+            case BOOLEAN, BYTE, SHORT, CHAR, INT -> cb.iconst_0();\n+            case LONG -> cb.lconst_0();\n+            case FLOAT -> cb.fconst_0();\n+            case DOUBLE -> cb.dconst_0();\n+            case REFERENCE -> cb.aconst_null();\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/BindingSpecializer.java","additions":42,"deletions":42,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/abi\/fallback\/LibFallback.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -335,1 +335,1 @@\n-            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\");\n+            Reflection.ensureNativeAccess(Reflection.getCallerClass(), AddressLayout.class, \"withTargetLayout\", false);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/foreign\/layout\/ValueLayouts.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+                    @SuppressWarnings(\"restricted\")\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/jimage\/NativeImageBuffer.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import java.io.InterruptedIOException;\n@@ -90,18 +89,0 @@\n-\n-        \/\/ This code has been uglified to protect against interrupts.\n-        \/\/ Even if a thread has been interrupted when loading resources,\n-        \/\/ the IO should not abort, so must carefully retry, failing only\n-        \/\/ if the retry leads to some other IO exception.\n-\n-        boolean isInterrupted = Thread.interrupted();\n-        int len;\n-        for (;;) {\n-            try {\n-                len = getContentLength();\n-                break;\n-            } catch (InterruptedIOException iioe) {\n-                Thread.interrupted();\n-                isInterrupted = true;\n-            }\n-        }\n-\n@@ -109,0 +90,1 @@\n+            int len = getContentLength();\n@@ -124,7 +106,1 @@\n-                int cc = 0;\n-                try {\n-                    cc = in.read(b, pos, bytesToRead);\n-                } catch (InterruptedIOException iioe) {\n-                    Thread.interrupted();\n-                    isInterrupted = true;\n-                }\n+                int cc = in.read(b, pos, bytesToRead);\n@@ -146,2 +122,0 @@\n-            } catch (InterruptedIOException iioe) {\n-                isInterrupted = true;\n@@ -149,4 +123,0 @@\n-\n-            if (isInterrupted) {\n-                Thread.currentThread().interrupt();\n-            }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/Resource.java","additions":3,"deletions":33,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,0 @@\n-import java.util.zip.ZipEntry;\n@@ -442,1 +441,2 @@\n-            Loader loader;\n+            Loader loader = null;\n+            final URL[] loaderClassPathURLs;\n@@ -447,4 +447,1 @@\n-                URL[] urls = loader.getClassPath();\n-                if (urls != null) {\n-                    push(urls);\n-                }\n+                loaderClassPathURLs = loader.getClassPath();\n@@ -452,1 +449,8 @@\n-                \/\/ Silently ignore for now...\n+                \/\/ log the error and close the unusable loader (if any)\n+                if (DEBUG) {\n+                    System.err.println(\"Failed to construct a loader or construct its\" +\n+                            \" local classpath for \" + url + \", cause:\" + e);\n+                }\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -455,3 +459,3 @@\n-                \/\/ Always silently ignore. The context, if there is one, that\n-                \/\/ this URLClassPath was given during construction will never\n-                \/\/ have permission to access the URL.\n+                \/\/ log the error and close the unusable loader (if any).\n+                \/\/ The context, if there is one, that this URLClassPath was\n+                \/\/ given during construction will never have permission to access the URL.\n@@ -461,0 +465,3 @@\n+                if (loader != null) {\n+                    closeQuietly(loader);\n+                }\n@@ -463,0 +470,3 @@\n+            if (loaderClassPathURLs != null) {\n+                push(loaderClassPathURLs);\n+            }\n@@ -470,0 +480,11 @@\n+    \/\/ closes the given loader and ignores any IOException that may occur during close\n+    private static void closeQuietly(final Loader loader) {\n+        try {\n+            loader.close();\n+        } catch (IOException ioe) {\n+            if (DEBUG) {\n+                System.err.println(\"ignoring exception \" + ioe + \" while closing loader \" + loader);\n+            }\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/loader\/URLClassPath.java","additions":32,"deletions":11,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -790,1 +790,0 @@\n-    private static final boolean HAS_ENABLE_NATIVE_ACCESS_FLAG;\n@@ -793,0 +792,1 @@\n+    private static final IllegalNativeAccess ILLEGAL_NATIVE_ACCESS;\n@@ -794,2 +794,8 @@\n-    public static boolean hasEnableNativeAccessFlag() {\n-        return HAS_ENABLE_NATIVE_ACCESS_FLAG;\n+    public enum IllegalNativeAccess {\n+        ALLOW,\n+        WARN,\n+        DENY\n+    }\n+\n+    public static IllegalNativeAccess illegalNativeAccess() {\n+        return ILLEGAL_NATIVE_ACCESS;\n@@ -799,0 +805,1 @@\n+        ILLEGAL_NATIVE_ACCESS = addIllegalNativeAccess();\n@@ -800,1 +807,0 @@\n-        HAS_ENABLE_NATIVE_ACCESS_FLAG = !USER_NATIVE_ACCESS_MODULES.isEmpty();\n@@ -850,0 +856,21 @@\n+    \/**\n+     * Process the --illegal-native-access option (and its default).\n+     *\/\n+    private static IllegalNativeAccess addIllegalNativeAccess() {\n+        String value = getAndRemoveProperty(\"jdk.module.illegal.native.access\");\n+        \/\/ don't use a switch: bootstrapping issues!\n+        if (value == null) {\n+            return IllegalNativeAccess.WARN; \/\/ default\n+        } else if (value.equals(\"deny\")) {\n+            return IllegalNativeAccess.DENY;\n+        } else if (value.equals(\"allow\")) {\n+            return IllegalNativeAccess.ALLOW;\n+        } else if (value.equals(\"warn\")) {\n+            return IllegalNativeAccess.WARN;\n+        } else {\n+            fail(\"Value specified to --illegal-native-access not recognized:\"\n+                    + \" '\" + value + \"'\");\n+            return null;\n+        }\n+    }\n+\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/module\/ModuleBootstrap.java","additions":31,"deletions":4,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -114,1 +114,1 @@\n-    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName) {\n+    public static void ensureNativeAccess(Class<?> currentClass, Class<?> owner, String methodName, boolean jni) {\n@@ -122,1 +122,4 @@\n-        Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass);\n+        if (module != null) {\n+            \/\/ not in init phase\n+            Holder.JLA.ensureNativeAccess(module, owner, methodName, currentClass, jni);\n+        }\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/Reflection.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -182,35 +182,0 @@\n-    \/** Creates a new java.lang.reflect.Constructor. Access checks as\n-        per java.lang.reflect.AccessibleObject are not overridden. *\/\n-    public Constructor<?> newConstructor(Class<?> declaringClass,\n-                                         Class<?>[] parameterTypes,\n-                                         Class<?>[] checkedExceptions,\n-                                         int modifiers,\n-                                         int slot,\n-                                         String signature,\n-                                         byte[] annotations,\n-                                         byte[] parameterAnnotations)\n-    {\n-        return langReflectAccess.newConstructor(declaringClass,\n-                                                parameterTypes,\n-                                                checkedExceptions,\n-                                                modifiers,\n-                                                slot,\n-                                                signature,\n-                                                annotations,\n-                                                parameterAnnotations);\n-    }\n-\n-    \/** Gets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public ConstructorAccessor getConstructorAccessor(Constructor<?> c) {\n-        return langReflectAccess.getConstructorAccessor(c);\n-    }\n-\n-    \/** Sets the ConstructorAccessor object for a\n-        java.lang.reflect.Constructor *\/\n-    public void setConstructorAccessor(Constructor<?> c,\n-                                       ConstructorAccessor accessor)\n-    {\n-        langReflectAccess.setConstructorAccessor(c, accessor);\n-    }\n-\n@@ -228,1 +193,2 @@\n-        return langReflectAccess.leafCopyMethod(arg);\n+        Method root = langReflectAccess.getRoot(arg);\n+        return langReflectAccess.copyMethod(root);\n@@ -231,1 +197,0 @@\n-\n@@ -372,9 +337,0 @@\n-\n-        Constructor<?> ctor = newConstructor(constructorToCall.getDeclaringClass(),\n-                                             constructorToCall.getParameterTypes(),\n-                                             constructorToCall.getExceptionTypes(),\n-                                             constructorToCall.getModifiers(),\n-                                             langReflectAccess.getConstructorSlot(constructorToCall),\n-                                             langReflectAccess.getConstructorSignature(constructorToCall),\n-                                             langReflectAccess.getConstructorAnnotations(constructorToCall),\n-                                             langReflectAccess.getConstructorParameterAnnotations(constructorToCall));\n@@ -389,1 +345,1 @@\n-            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, ctor);\n+            acc = MethodHandleAccessorFactory.newSerializableConstructorAccessor(cl, constructorToCall);\n@@ -391,1 +347,4 @@\n-        setConstructorAccessor(ctor, acc);\n+        \/\/ Unlike other root constructors, this constructor is not copied for mutation\n+        \/\/ but directly mutated, as it is not cached. To cache this constructor,\n+        \/\/ setAccessible call must be done on a copy and return that copy instead.\n+        Constructor<?> ctor = langReflectAccess.newConstructorWithAccessor(constructorToCall, acc);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/reflect\/ReflectionFactory.java","additions":8,"deletions":49,"binary":false,"changes":57,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import sun.security.action.GetPropertyAction;\n@@ -83,1 +82,5 @@\n-        String value = GetPropertyAction.privilegedGetProperty(key);\n+        \/*\n+         * GetPropertyAction.privilegedGetProperty cannot be used here, Using VM.getSavedProperty to avoid a bootstrap\n+         * circularity issue in the java\/lang\/String\/concat\/WithSecurityManager.java test\n+         *\/\n+        String value = VM.getSavedProperty(key);\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ClassFileDumper.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,0 @@\n-        Objects.requireNonNull(key, \"key must not be null\");\n@@ -224,0 +223,7 @@\n+        return getNoCheckStale(key);\n+    }\n+\n+    \/\/ Internal get(key) without removing stale references that would modify the keyset.\n+    \/\/ Use when iterating or streaming over the keys to avoid ConcurrentModificationException.\n+    private V getNoCheckStale(Object key) {\n+        Objects.requireNonNull(key, \"key must not be null\");\n@@ -294,1 +300,1 @@\n-                .map(k -> new AbstractMap.SimpleEntry<>(k, get(k)))\n+                .map(k -> new AbstractMap.SimpleEntry<>(k, getNoCheckStale(k)))\n@@ -338,1 +344,1 @@\n-                .map(k -> k + \"=\" + get(k))\n+                .map(k -> k + \"=\" + getNoCheckStale(k))\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/util\/ReferencedKeyMap.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -430,0 +430,1 @@\n+    @IntrinsicCandidate\n@@ -437,0 +438,1 @@\n+    @IntrinsicCandidate\n","filename":"src\/java.base\/share\/classes\/jdk\/internal\/vm\/Continuation.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -259,1 +259,2 @@\n-        jdk.internal.vm.ci;\n+        jdk.internal.vm.ci,\n+        jdk.jfr;\n","filename":"src\/java.base\/share\/classes\/module-info.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -307,15 +307,0 @@\n-    \/** Return the wrapper that corresponds to the provided basic type char.\n-     *  The basic type char must be for one of the eight primitive types, or void.\n-     *  @throws IllegalArgumentException for unexpected types\n-     *\/\n-    public static Wrapper forPrimitiveType(char basicTypeChar) {\n-        Wrapper w = FROM_CHAR[(basicTypeChar + (basicTypeChar >> 1)) & 0xf];\n-        if (w == null || w.basicTypeChar != basicTypeChar) {\n-            throw basicTypeError(basicTypeChar);\n-        }\n-        if (w == OBJECT) {\n-            throw newIllegalArgumentException(\"not primitive: \" + basicTypeChar);\n-        }\n-        return w;\n-    }\n-\n","filename":"src\/java.base\/share\/classes\/sun\/invoke\/util\/Wrapper.java","additions":0,"deletions":15,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -68,0 +68,5 @@\n+\\    --illegal-native-access=<value>\\n\\\n+\\                  allow or deny access to code and data outside the Java runtime\\n\\\n+\\                  by code in modules for which native access is not explicitly enabled.\\n\\\n+\\                  <value> is one of \"deny\", \"warn\" or \"allow\". The default value is \"warn\".\\n\\\n+\\                  This option will be removed in a future release.\\n\\\n","filename":"src\/java.base\/share\/classes\/sun\/launcher\/resources\/launcher.properties","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -677,1 +677,0 @@\n-                nanos = Long.MAX_VALUE;\n@@ -687,0 +686,1 @@\n+            long remainingNanos = nanos;\n@@ -692,1 +692,0 @@\n-                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n@@ -713,1 +712,0 @@\n-                            \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -715,0 +713,1 @@\n+                                \/\/ copy bytes to the DatagramPacket, and set length and sender\n@@ -722,0 +721,8 @@\n+                            } else {\n+                                \/\/ need to retry, adjusting timeout if needed\n+                                if (nanos > 0) {\n+                                    remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                                    if (remainingNanos <= 0) {\n+                                        throw new SocketTimeoutException(\"Receive timed out\");\n+                                    }\n+                                }\n@@ -748,0 +755,1 @@\n+        assert nanos >= 0;\n@@ -759,3 +767,8 @@\n-                long remainingNanos = nanos - (System.nanoTime() - startNanos);\n-                if (remainingNanos <= 0) {\n-                    throw new SocketTimeoutException(\"Receive timed out\");\n+                if (nanos > 0) {\n+                    long remainingNanos = nanos - (System.nanoTime() - startNanos);\n+                    if (remainingNanos <= 0) {\n+                        throw new SocketTimeoutException(\"Receive timed out\");\n+                    }\n+                    park(Net.POLLIN, remainingNanos);\n+                } else {\n+                    park(Net.POLLIN);\n@@ -763,1 +776,0 @@\n-                park(Net.POLLIN, remainingNanos);\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/ch\/DatagramChannelImpl.java","additions":19,"deletions":7,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -405,1 +405,1 @@\n-                        char c = UNMAPPABLE_DECODING;\n+                        char c;\n@@ -455,1 +455,1 @@\n-                    char c =  UNMAPPABLE_DECODING;\n+                    char c;\n@@ -506,2 +506,2 @@\n-        private final int SS2 =  0x8E;\n-        private final int SS3 =  0x8F;\n+        private static final int SS2 = 0x8E;\n+        private static final int SS3 = 0x8F;\n@@ -559,1 +559,1 @@\n-        protected final int MAX_SINGLEBYTE = 0xff;\n+        protected static final int MAX_SINGLEBYTE = 0xff;\n@@ -662,1 +662,1 @@\n-                        return CoderResult.OVERFLOW;\n+                            return CoderResult.OVERFLOW;\n","filename":"src\/java.base\/share\/classes\/sun\/nio\/cs\/DoubleByte.java","additions":7,"deletions":7,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -1142,1 +1142,3 @@\n-            NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                NewSessionTicket.t13PosthandshakeProducer.produce(shc);\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/Finished.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import java.math.BigInteger;\n@@ -33,0 +32,1 @@\n+import java.util.Arrays;\n@@ -121,5 +121,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -224,5 +219,0 @@\n-        @Override\n-        public SSLHandshake handshakeType() {\n-            return NEW_SESSION_TICKET;\n-        }\n-\n@@ -304,1 +294,1 @@\n-        } catch  (GeneralSecurityException gse) {\n+        } catch (GeneralSecurityException gse) {\n@@ -335,2 +325,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -354,2 +343,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -366,2 +354,1 @@\n-                        SSLLogger.fine(\n-                                \"No session ticket produced: \" +\n+                        SSLLogger.fine(\"No session ticket produced: \" +\n@@ -378,6 +365,2 @@\n-            SessionId newId = new SessionId(true,\n-                hc.sslContext.getSecureRandom());\n-\n-            SecretKey resumptionMasterSecret =\n-                hc.handshakeSession.getResumptionMasterSecret();\n-            if (resumptionMasterSecret == null) {\n+            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n+            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n@@ -385,3 +368,2 @@\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"no resumption secret\");\n+                    SSLLogger.fine(\"No session ticket produced: \" +\n+                            \"session timeout is too long\");\n@@ -393,13 +375,11 @@\n-            \/\/ construct the PSK and handshake message\n-            BigInteger nonce = hc.handshakeSession.incrTicketNonceCounter();\n-            byte[] nonceArr = nonce.toByteArray();\n-            SecretKey psk = derivePreSharedKey(\n-                    hc.negotiatedCipherSuite.hashAlg,\n-                    resumptionMasterSecret, nonceArr);\n-\n-            int sessionTimeoutSeconds = sessionCache.getSessionTimeout();\n-            if (sessionTimeoutSeconds > MAX_TICKET_LIFETIME) {\n-                if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n-                    SSLLogger.fine(\n-                            \"No session ticket produced: \" +\n-                            \"session timeout\");\n+            \/\/ Send NewSessionTickets to the client based\n+            if (SSLConfiguration.serverNewSessionTicketCount > 0) {\n+                int i = 0;\n+                NewSessionTicketMessage nstm;\n+                while (i < SSLConfiguration.serverNewSessionTicketCount) {\n+                    nstm = generateNST(hc, sessionCache);\n+                    if (nstm == null) {\n+                        break;\n+                    }\n+                    nstm.write(hc.handshakeOutput);\n+                    i++;\n@@ -408,1 +388,28 @@\n-                return null;\n+                hc.handshakeOutput.flush();\n+            }\n+            \/*\n+             * With large NST counts, a client that quickly closes after\n+             * TLS Finished completes can cause SocketExceptions such as:\n+             * Windows servers read-side throwing SocketException:\n+             *   \"An established connection was aborted by the software in\n+             *    your host machine\", which relates to error WSAECONNABORTED.\n+             * A SocketException caused by a \"broken pipe\" has been observed on\n+             * other systems.\n+             * These are very unlikely situations when client and server are on\n+             * different machines.\n+             *\n+             * RFC 8446 does not put requirements when an NST needs to be\n+             * sent, but it should be sent very soon after TLS Finished for\n+             * clients that will quickly resume to create more sessions.\n+             * TLS 1.3 is different from TLS 1.2, there is more data the client\n+             * should be aware of\n+             *\/\n+\n+            \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n+            \/\/\n+            \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n+            \/\/ of this post-handshake message will indicate the FINISHED\n+            \/\/ handshake status.  It is not needed to have a follow-on\n+            \/\/ SSLEngine.wrap() any longer.\n+            if (hc.conContext.needHandshakeFinishedStatus) {\n+                hc.conContext.needHandshakeFinishedStatus = false;\n@@ -411,1 +418,16 @@\n-            NewSessionTicketMessage nstm = null;\n+            \/\/ clean the post handshake context\n+            hc.conContext.finishPostHandshake();\n+\n+            \/\/ The message has been delivered.\n+            return null;\n+        }\n+\n+        private NewSessionTicketMessage generateNST(HandshakeContext hc,\n+            SSLSessionContextImpl sessionCache) throws IOException {\n+\n+            NewSessionTicketMessage nstm;\n+            SessionId newId = new SessionId(true,\n+                hc.sslContext.getSecureRandom());\n+\n+            \/\/ construct the PSK and handshake message\n+            byte[] nonce = hc.handshakeSession.incrTicketNonceCounter();\n@@ -414,2 +436,4 @@\n-                    new SSLSessionImpl(hc.handshakeSession, newId);\n-            sessionCopy.setPreSharedKey(psk);\n+                new SSLSessionImpl(hc.handshakeSession, newId);\n+            sessionCopy.setPreSharedKey(derivePreSharedKey(\n+                hc.negotiatedCipherSuite.hashAlg,\n+                hc.handshakeSession.getResumptionMasterSecret(), nonce));\n@@ -422,1 +446,1 @@\n-                        sessionTimeoutSeconds,\n+                        sessionCache.getSessionTimeout(),\n@@ -424,1 +448,1 @@\n-                        nonceArr,\n+                        nonce,\n@@ -431,2 +455,1 @@\n-                        SSLLogger.fine(\n-                            \"Produced NewSessionTicket stateless \" +\n+                        SSLLogger.fine(\"Produced NewSessionTicket stateless \" +\n@@ -436,0 +459,1 @@\n+                return nstm;\n@@ -441,3 +465,4 @@\n-                nstm = new T13NewSessionTicketMessage(hc, sessionTimeoutSeconds,\n-                        hc.sslContext.getSecureRandom(), nonceArr,\n-                        newId.getId());\n+                nstm = new T13NewSessionTicketMessage(hc,\n+                    sessionCache.getSessionTimeout(),\n+                    hc.sslContext.getSecureRandom(), nonce,\n+                    newId.getId());\n@@ -445,3 +470,2 @@\n-                    SSLLogger.fine(\n-                            \"Produced NewSessionTicket post-handshake message\",\n-                            nstm);\n+                    SSLLogger.fine(\"Produced NewSessionTicket \" +\n+                        \"post-handshake message\", nstm);\n@@ -456,0 +480,1 @@\n+                return nstm;\n@@ -458,15 +483,2 @@\n-            \/\/ Output the handshake message.\n-            if (nstm != null) {\n-                \/\/ should never be null\n-                nstm.write(hc.handshakeOutput);\n-                hc.handshakeOutput.flush();\n-\n-                \/\/ See note on TransportContext.needHandshakeFinishedStatus.\n-                \/\/\n-                \/\/ Reset the needHandshakeFinishedStatus flag.  The delivery\n-                \/\/ of this post-handshake message will indicate the FINISHED\n-                \/\/ handshake status.  It is not needed to have a follow-on\n-                \/\/ SSLEngine.wrap() any longer.\n-                if (hc.conContext.needHandshakeFinishedStatus) {\n-                    hc.conContext.needHandshakeFinishedStatus = false;\n-                }\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"No NewSessionTicket created\");\n@@ -475,4 +487,0 @@\n-            \/\/ clean the post handshake context\n-            hc.conContext.finishPostHandshake();\n-\n-            \/\/ The message has been delivered.\n@@ -500,2 +508,3 @@\n-            \/\/ Is this session resumable?\n-            if (!shc.handshakeSession.isRejoinable()) {\n+            \/\/ Are new tickets allowed?  If so, is this session resumable?\n+            if (SSLConfiguration.serverNewSessionTicketCount == 0 ||\n+                !shc.handshakeSession.isRejoinable()) {\n@@ -581,1 +590,0 @@\n-                sessionCache.remove(hc.handshakeSession.getSessionId());\n@@ -622,1 +630,6 @@\n-            sessionCache.put(sessionCopy);\n+            sessionCache.put(sessionCopy, sessionCopy.isPSK());\n+\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\"MultiNST PSK (Server): \" +\n+                    Utilities.toHexString(Arrays.copyOf(nstm.ticket, 16)));\n+            }\n@@ -629,0 +642,1 @@\n+    \/* TLS 1.2 spec does not specify multiple NST behavior.*\/\n@@ -677,2 +691,1 @@\n-                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" +\n-                        nstm.toString());\n+                SSLLogger.fine(\"Consuming NewSessionTicket\\n\" + nstm);\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/NewSessionTicket.java","additions":93,"deletions":80,"binary":false,"changes":173,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -702,1 +702,1 @@\n-            sessionCache.remove(chc.resumingSession.getSessionId());\n+            sessionCache.remove(chc.resumingSession.getSessionId(), true);\n@@ -707,0 +707,2 @@\n+                SSLLogger.fine(\n+                    \"MultiNST PSK (Client): \" + Utilities.toHexString(Arrays.copyOf(chc.pskIdentity, 16)));\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/PreSharedKeyExtension.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -124,0 +124,5 @@\n+    \/\/ Number of NewSessionTickets that will be sent by the server.\n+    static final int serverNewSessionTicketCount;\n+    \/\/ Default for NewSessionTickets\n+    static final int SERVER_NST_DEFAULT = 1;\n+\n@@ -185,1 +190,1 @@\n-                \"jdk.tls.client.maxInboundCertificateChainLength\");\n+            \"jdk.tls.client.maxInboundCertificateChainLength\");\n@@ -194,0 +199,27 @@\n+\n+        \/*\n+         * jdk.tls.server.newSessionTicketCount system property\n+         * Sets the number of NewSessionTickets sent to a TLS 1.3 resumption\n+         * client.  The value must be between 0 and 10.  Default is defined by\n+         * SERVER_NST_DEFAULT.\n+         *\/\n+        Integer nstServerCount = GetIntegerAction.privilegedGetProperty(\n+            \"jdk.tls.server.newSessionTicketCount\");\n+        if (nstServerCount == null || nstServerCount < 0 ||\n+            nstServerCount > 10) {\n+            serverNewSessionTicketCount = SERVER_NST_DEFAULT;\n+            if (nstServerCount != null && SSLLogger.isOn &&\n+                SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount defaults to \" +\n+                        SERVER_NST_DEFAULT + \" as the property was not \" +\n+                        \"between 0 and 10\");\n+            }\n+        } else {\n+            serverNewSessionTicketCount = nstServerCount;\n+            if (SSLLogger.isOn && SSLLogger.isOn(\"ssl,handshake\")) {\n+                SSLLogger.fine(\n+                    \"jdk.tls.server.newSessionTicketCount set to \" +\n+                        serverNewSessionTicketCount);\n+            }\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLConfiguration.java","additions":34,"deletions":2,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -419,5 +419,6 @@\n-        if ((conContext.handshakeContext == null) &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            conContext.handshakeContext == null &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLEngineImpl.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1999, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1999, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,0 +66,1 @@\n+    private static final int DEFAULT_MAX_QUEUE_SIZE = 10;\n@@ -90,2 +91,0 @@\n-        sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n-        sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -93,0 +92,2 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n@@ -95,1 +96,1 @@\n-            \/\/ but doesn't necessarily has to be a true random number.\n+            \/\/ but doesn't necessarily have to be a true random number.\n@@ -98,0 +99,3 @@\n+            sessionCache = Cache.newSoftMemoryCache(cacheLimit, timeout);\n+            sessionHostPortCache = Cache.newSoftMemoryQueue(cacheLimit, timeout,\n+                DEFAULT_MAX_QUEUE_SIZE);\n@@ -280,0 +284,10 @@\n+        put(s, false);\n+    }\n+\n+    \/**\n+     * Put an entry in the cache\n+     * @param s SSLSessionImpl entry to be stored\n+     * @param canQueue True if multiple entries may exist under one\n+     *                 session entry.\n+     *\/\n+    void put(SSLSessionImpl s, boolean canQueue) {\n@@ -285,1 +299,1 @@\n-                getKey(s.getPeerHost(), s.getPeerPort()), s);\n+                getKey(s.getPeerHost(), s.getPeerPort()), s, canQueue);\n@@ -293,0 +307,3 @@\n+        remove(key, false);\n+    }\n+    void remove(SessionId key, boolean isClient) {\n@@ -296,1 +313,3 @@\n-            sessionHostPortCache.remove(\n+            \/\/ A client keeps the cache entry for queued NST resumption.\n+            if (!isClient) {\n+                sessionHostPortCache.remove(\n@@ -298,0 +317,1 @@\n+            }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionContextImpl.java","additions":26,"deletions":6,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,0 @@\n-import java.util.Enumeration;\n@@ -135,1 +134,5 @@\n-    private BigInteger ticketNonceCounter = BigInteger.ONE;\n+    private byte ticketNonceCounter = 1;\n+\n+    \/\/ This boolean is true when a new set of NewSessionTickets are needed after\n+    \/\/ the initial ones sent after the handshake.\n+    boolean updateNST = false;\n@@ -495,1 +498,1 @@\n-                buf.get(b, 0 , i);\n+                buf.get(b, 0, i);\n@@ -504,2 +507,7 @@\n-                this.pskIdentity = new byte[buf.get()];\n-                buf.get(pskIdentity);\n+                i = buf.get();\n+                if (i > 0) {\n+                    this.pskIdentity = new byte[buf.get()];\n+                    buf.get(pskIdentity);\n+                } else {\n+                    this.pskIdentity = null;\n+                }\n@@ -718,4 +726,2 @@\n-    BigInteger incrTicketNonceCounter() {\n-        BigInteger result = ticketNonceCounter;\n-        ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);\n-        return result;\n+    byte[] incrTicketNonceCounter() {\n+        return new byte[] {ticketNonceCounter++};\n@@ -725,1 +731,1 @@\n-        return (ticketNonceCounter.compareTo(BigInteger.ZERO) > 0);\n+        return (ticketNonceCounter > 0);\n@@ -784,0 +790,4 @@\n+    public boolean isPSK() {\n+        return (pskIdentity != null && pskIdentity.length > 0);\n+    }\n+\n@@ -1233,1 +1243,0 @@\n-    boolean updateNST;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSessionImpl.java","additions":21,"deletions":12,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -1324,1 +1324,0 @@\n-                conContext.conSession.updateNST = false;\n@@ -1559,6 +1558,7 @@\n-        if (!conContext.sslConfig.isClientMode &&\n-                conContext.protocolVersion.useTLS13PlusSpec() &&\n-                conContext.handshakeContext == null &&\n-                !conContext.isOutboundClosed() &&\n-                !conContext.isInboundClosed() &&\n-                !conContext.isBroken) {\n+        if (SSLConfiguration.serverNewSessionTicketCount > 0 &&\n+            !conContext.sslConfig.isClientMode &&\n+            conContext.protocolVersion.useTLS13PlusSpec() &&\n+            conContext.handshakeContext == null &&\n+            !conContext.isOutboundClosed() &&\n+            !conContext.isInboundClosed() &&\n+            !conContext.isBroken) {\n@@ -1568,0 +1568,1 @@\n+            conContext.conSession.updateNST = false;\n","filename":"src\/java.base\/share\/classes\/sun\/security\/ssl\/SSLSocketImpl.java","additions":8,"deletions":7,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,3 @@\n+import javax.net.ssl.SSLSession;\n+import java.lang.ref.ReferenceQueue;\n+import java.lang.ref.SoftReference;\n@@ -29,1 +32,2 @@\n-import java.lang.ref.*;\n+import java.util.concurrent.ConcurrentLinkedQueue;\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -93,0 +97,9 @@\n+    \/**\n+     * Add V to the cache with the option to use a QueueCacheEntry if the\n+     * cache is configured for it.  If the cache is not configured for a queue,\n+     * V will silently add the entry directly.\n+     *\/\n+    public void put(K key, V value, boolean canQueue) {\n+        put(key, value);\n+    }\n+\n@@ -140,0 +153,5 @@\n+    public static <K,V> Cache<K,V> newSoftMemoryQueue(int size, int timeout,\n+        int maxQueueSize) {\n+        return new MemoryCache<>(true, size, timeout, maxQueueSize);\n+    }\n+\n@@ -251,3 +269,1 @@\n-    private static final float LOAD_FACTOR = 0.75f;\n-\n-    \/\/ XXXX\n+    \/\/ Debugging\n@@ -258,0 +274,1 @@\n+    final private int maxQueueSize;\n@@ -266,1 +283,1 @@\n-        this(soft, maxSize, 0);\n+        this(soft, maxSize, 0, 0);\n@@ -270,0 +287,4 @@\n+        this(soft, maxSize, lifetime, 0);\n+    }\n+\n+    public MemoryCache(boolean soft, int maxSize, int lifetime, int qSize) {\n@@ -271,0 +292,1 @@\n+        this.maxQueueSize = qSize;\n@@ -272,1 +294,1 @@\n-        if (soft)\n+        if (soft) {\n@@ -274,1 +296,1 @@\n-        else\n+        } else {\n@@ -276,2 +298,4 @@\n-\n-        cacheMap = new LinkedHashMap<>(1, LOAD_FACTOR, true);\n+        }\n+        \/\/ LinkedHashMap is needed for its access order.  0.75f load factor is\n+        \/\/ default.\n+        cacheMap = new LinkedHashMap<>(1, 0.75f, true);\n@@ -341,0 +365,4 @@\n+                \/\/ If this is a queue, check for some expired entries\n+                if (entry instanceof QueueCacheEntry<K,V> qe) {\n+                    qe.getQueue().removeIf(e -> !e.isValid(time));\n+                }\n@@ -370,1 +398,20 @@\n-    public synchronized void put(K key, V value) {\n+    public void put(K key, V value) {\n+        put(key, value, false);\n+    }\n+\n+    \/**\n+     * This puts an entry into the cacheMap.\n+     *\n+     * If canQueue is true, V will be added using a QueueCacheEntry which\n+     * is added to cacheMap.  If false, V is added to the cacheMap directly.\n+     * The caller must keep a consistent canQueue value, mixing them can\n+     * result in a queue being replaced with a single entry.\n+     *\n+     * This method is synchronized to avoid multiple QueueCacheEntry\n+     * overwriting the same key.\n+     *\n+     * @param key key to the cacheMap\n+     * @param value value to be stored\n+     * @param canQueue can the value be put into a QueueCacheEntry\n+     *\/\n+    public synchronized void put(K key, V value, boolean canQueue) {\n@@ -372,2 +419,2 @@\n-        long expirationTime = (lifetime == 0) ? 0 :\n-                                        System.currentTimeMillis() + lifetime;\n+        long expirationTime =\n+            (lifetime == 0) ? 0 : System.currentTimeMillis() + lifetime;\n@@ -378,4 +425,27 @@\n-        CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n-        if (oldEntry != null) {\n-            oldEntry.invalidate();\n-            return;\n+        if (maxQueueSize == 0 || !canQueue) {\n+            CacheEntry<K,V> oldEntry = cacheMap.put(key, newEntry);\n+            if (oldEntry != null) {\n+                oldEntry.invalidate();\n+            }\n+        } else {\n+            CacheEntry<K, V> entry = cacheMap.get(key);\n+            switch (entry) {\n+                case QueueCacheEntry<K, V> qe -> {\n+                    qe.putValue(newEntry);\n+                    if (DEBUG) {\n+                        System.out.println(\"QueueCacheEntry= \" + qe);\n+                        final AtomicInteger i = new AtomicInteger(1);\n+                        qe.queue.stream().forEach(e ->\n+                            System.out.println(i.getAndIncrement() + \"= \" + e));\n+                    }\n+                }\n+                case null, default ->\n+                    cacheMap.put(key, new QueueCacheEntry<>(key, newEntry,\n+                        expirationTime, maxQueueSize));\n+            }\n+\n+            if (DEBUG) {\n+                System.out.println(\"Cache entry added: key=\" +\n+                    key.toString() + \", class=\" +\n+                    (entry != null ? entry.getClass().getName() : null));\n+            }\n@@ -404,2 +474,3 @@\n-        long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n-        if (!entry.isValid(time)) {\n+\n+        if (lifetime > 0 && !entry.isValid(System.currentTimeMillis())) {\n+            cacheMap.remove(key);\n@@ -409,1 +480,0 @@\n-            cacheMap.remove(key);\n@@ -412,0 +482,9 @@\n+\n+        \/\/ If the value is a queue, return a queue entry.\n+        if (entry instanceof QueueCacheEntry<K, V> qe) {\n+            V result = qe.getValue(lifetime);\n+            if (qe.isEmpty()) {\n+                removeImpl(key);\n+            }\n+            return result;\n+        }\n@@ -417,0 +496,4 @@\n+        removeImpl(key);\n+    }\n+\n+    private void removeImpl(Object key) {\n@@ -422,1 +505,0 @@\n-\n@@ -553,3 +635,2 @@\n-    private static class SoftCacheEntry<K,V>\n-            extends SoftReference<V>\n-            implements CacheEntry<K,V> {\n+    private static class SoftCacheEntry<K,V> extends SoftReference<V>\n+        implements CacheEntry<K,V> {\n@@ -592,0 +673,7 @@\n+\n+        @Override\n+        public String toString() {\n+            if (get() instanceof SSLSession se)\n+                return HexFormat.of().formatHex(se.getId());\n+            return super.toString();\n+        }\n@@ -594,1 +682,104 @@\n-}\n+    \/**\n+     * This CacheEntry<K,V> type allows multiple V entries to be stored in\n+     * one key in the cacheMap.\n+     *\n+     * This implementation is need for TLS clients that receive multiple\n+     * PSKs or NewSessionTickets for server resumption.\n+     *\/\n+    private static class QueueCacheEntry<K,V> implements CacheEntry<K,V> {\n+\n+        \/\/ Limit the number of queue entries.\n+        private final int MAXQUEUESIZE;\n+\n+        final boolean DEBUG = false;\n+        private K key;\n+        private long expirationTime;\n+        final Queue<CacheEntry<K,V>> queue = new ConcurrentLinkedQueue<>();\n+\n+        QueueCacheEntry(K key, CacheEntry<K,V> entry, long expirationTime,\n+            int maxSize) {\n+            this.key = key;\n+            this.expirationTime = expirationTime;\n+            this.MAXQUEUESIZE = maxSize;\n+            queue.add(entry);\n+        }\n+\n+        public K getKey() {\n+            return key;\n+        }\n+\n+        public V getValue() {\n+            return getValue(0);\n+        }\n+\n+        public V getValue(long lifetime) {\n+            long time = (lifetime == 0) ? 0 : System.currentTimeMillis();\n+            do {\n+                var entry = queue.poll();\n+                if (entry == null) {\n+                    return null;\n+                }\n+                if (entry.isValid(time)) {\n+                    return entry.getValue();\n+                }\n+                entry.invalidate();\n+            } while (!queue.isEmpty());\n+\n+            return null;\n+        }\n+\n+        public long getExpirationTime() {\n+            return expirationTime;\n+        }\n+\n+        public void setExpirationTime(long time) {\n+            expirationTime = time;\n+        }\n+\n+        public void putValue(CacheEntry<K,V> entry) {\n+            if (DEBUG) {\n+                System.out.println(\"Added to queue (size=\" + queue.size() +\n+                    \"): \" + entry.getKey().toString() + \",  \" + entry);\n+            }\n+            \/\/ Update the cache entry's expiration time to the latest entry.\n+            \/\/ The getValue() calls will remove expired tickets.\n+            expirationTime = entry.getExpirationTime();\n+            \/\/ Limit the number of queue entries, removing the oldest.\n+            if (queue.size() >= MAXQUEUESIZE) {\n+                queue.remove();\n+            }\n+            queue.add(entry);\n+        }\n+\n+        public boolean isValid(long currentTime) {\n+            boolean valid = (currentTime <= expirationTime) && !queue.isEmpty();\n+            if (!valid) {\n+                invalidate();\n+            }\n+            return valid;\n+        }\n+\n+        public boolean isValid() {\n+            return isValid(System.currentTimeMillis());\n+        }\n+\n+        public void invalidate() {\n+            clear();\n+            key = null;\n+            expirationTime = -1;\n+        }\n+\n+        public void clear() {\n+            queue.forEach(CacheEntry::invalidate);\n+            queue.clear();\n+        }\n+\n+        public boolean isEmpty() {\n+            return queue.isEmpty();\n+        }\n+\n+        public Queue<CacheEntry<K,V>> getQueue() {\n+            return queue;\n+        }\n+    }\n+}\n\\ No newline at end of file\n","filename":"src\/java.base\/share\/classes\/sun\/security\/util\/Cache.java","additions":216,"deletions":25,"binary":false,"changes":241,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,0 +56,16 @@\n+    },\n+\n+    \/**\n+     * Distrust TLS Server certificates anchored by an Entrust root CA and\n+     * issued after October 31, 2024. If enabled, this policy is currently\n+     * enforced by the PKIX and SunX509 TrustManager implementations\n+     * of the SunJSSE provider implementation.\n+     *\/\n+    ENTRUST_TLS {\n+        void checkDistrust(String variant, X509Certificate[] chain)\n+                           throws ValidatorException {\n+            if (!variant.equals(Validator.VAR_TLS_SERVER)) {\n+                return;\n+            }\n+            EntrustTLSPolicy.checkDistrust(chain);\n+        }\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/CADistrustPolicy.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package sun.security.validator;\n+\n+import java.security.cert.X509Certificate;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.time.ZoneOffset;\n+import java.util.Date;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import sun.security.util.Debug;\n+import sun.security.x509.X509CertImpl;\n+\n+\/**\n+ * This class checks if Entrust issued TLS Server certificates should be\n+ * restricted.\n+ *\/\n+final class EntrustTLSPolicy {\n+\n+    private static final Debug debug = Debug.getInstance(\"certpath\");\n+\n+    \/\/ SHA-256 certificate fingerprints of distrusted roots\n+    private static final Set<String> FINGERPRINTS = Set.of(\n+        \/\/ cacerts alias: entrustevca\n+        \/\/ DN: CN=Entrust Root Certification Authority,\n+        \/\/     OU=(c) 2006 Entrust, Inc.,\n+        \/\/     OU=www.entrust.net\/CPS is incorporated by reference,\n+        \/\/     O=Entrust, Inc., C=US\n+        \"73C176434F1BC6D5ADF45B0E76E727287C8DE57616C1E6E6141A2B2CBC7D8E4C\",\n+        \/\/ cacerts alias: entrustrootcaec1\n+        \/\/ DN: CN=Entrust Root Certification Authority - EC1,\n+        \/\/     OU=(c) 2012 Entrust, Inc. - for authorized use only,\n+        \/\/     OU=See www.entrust.net\/legal-terms, O=Entrust, Inc., C=US\n+        \"02ED0EB28C14DA45165C566791700D6451D7FB56F0B2AB1D3B8EB070E56EDFF5\",\n+        \/\/ cacerts alias: entrustrootcag2\n+        \/\/ DN: CN=Entrust Root Certification Authority - G2,\n+        \/\/     OU=(c) 2009 Entrust, Inc. - for authorized use only,\n+        \/\/     OU=See www.entrust.net\/legal-terms, O=Entrust, Inc., C=US\n+        \"43DF5774B03E7FEF5FE40D931A7BEDF1BB2E6B42738C4E6D3841103D3AA7F339\",\n+        \/\/ cacerts alias: entrustrootcag4\n+        \/\/ DN: CN=Entrust Root Certification Authority - G4\n+        \/\/     OU=(c) 2015 Entrust, Inc. - for authorized use only,\n+        \/\/     OU=See www.entrust.net\/legal-terms, O=Entrust, Inc., C=US,\n+        \"DB3517D1F6732A2D5AB97C533EC70779EE3270A62FB4AC4238372460E6F01E88\",\n+        \/\/ cacerts alias: entrust2048ca\n+        \/\/ DN: CN=Entrust.net Certification Authority (2048),\n+        \/\/     OU=(c) 1999 Entrust.net Limited,\n+        \/\/     OU=www.entrust.net\/CPS_2048 incorp. by ref. (limits liab.),\n+        \/\/     O=Entrust.net\n+        \"6DC47172E01CBCB0BF62580D895FE2B8AC9AD4F873801E0C10B9C837D21EB177\",\n+        \/\/ cacerts alias: affirmtrustcommercialca\n+        \/\/ DN: CN=AffirmTrust Commercial, O=AffirmTrust, C=US\n+        \"0376AB1D54C5F9803CE4B2E201A0EE7EEF7B57B636E8A93C9B8D4860C96F5FA7\",\n+        \/\/ cacerts alias: affirmtrustnetworkingca\n+        \/\/ DN: CN=AffirmTrust Networking, O=AffirmTrust, C=US\n+        \"0A81EC5A929777F145904AF38D5D509F66B5E2C58FCDB531058B0E17F3F0B41B\",\n+        \/\/ cacerts alias: affirmtrustpremiumca\n+        \/\/ DN: CN=AffirmTrust Premium, O=AffirmTrust, C=US\n+        \"70A73F7F376B60074248904534B11482D5BF0E698ECC498DF52577EBF2E93B9A\",\n+        \/\/ cacerts alias: affirmtrustpremiumeccca\n+        \/\/ DN: CN=AffirmTrust Premium ECC, O=AffirmTrust, C=US\n+        \"BD71FDF6DA97E4CF62D1647ADD2581B07D79ADF8397EB4ECBA9C5E8488821423\"\n+    );\n+\n+    \/\/ Any TLS Server certificate that is anchored by one of the Entrust\n+    \/\/ roots above and is issued after this date will be distrusted.\n+    private static final LocalDate OCTOBER_31_2024 =\n+        LocalDate.of(2024, Month.OCTOBER, 31);\n+\n+    \/**\n+     * This method assumes the eeCert is a TLS Server Cert and chains back to\n+     * the anchor.\n+     *\n+     * @param chain the end-entity's certificate chain. The end entity cert\n+     *              is at index 0, the trust anchor at index n-1.\n+     * @throws ValidatorException if the certificate is distrusted\n+     *\/\n+    static void checkDistrust(X509Certificate[] chain)\n+                              throws ValidatorException {\n+        X509Certificate anchor = chain[chain.length-1];\n+        String fp = fingerprint(anchor);\n+        if (fp == null) {\n+            throw new ValidatorException(\"Cannot generate fingerprint for \"\n+                + \"trust anchor of TLS server certificate\");\n+        }\n+        if (FINGERPRINTS.contains(fp)) {\n+            Date notBefore = chain[0].getNotBefore();\n+            LocalDate ldNotBefore = LocalDate.ofInstant(notBefore.toInstant(),\n+                                                        ZoneOffset.UTC);\n+            \/\/ reject if certificate is issued after October 31, 2024\n+            checkNotBefore(ldNotBefore, OCTOBER_31_2024, anchor);\n+        }\n+    }\n+\n+    private static String fingerprint(X509Certificate cert) {\n+        return X509CertImpl.getFingerprint(\"SHA-256\", cert, debug);\n+    }\n+\n+    private static void checkNotBefore(LocalDate notBeforeDate,\n+            LocalDate distrustDate, X509Certificate anchor)\n+            throws ValidatorException {\n+        if (notBeforeDate.isAfter(distrustDate)) {\n+            throw new ValidatorException\n+                (\"TLS Server certificate issued after \" + distrustDate +\n+                 \" and anchored by a distrusted legacy Entrust root CA: \"\n+                 + anchor.getSubjectX500Principal(),\n+                 ValidatorException.T_UNTRUSTED_CERT, anchor);\n+        }\n+    }\n+\n+    private EntrustTLSPolicy() {}\n+}\n","filename":"src\/java.base\/share\/classes\/sun\/security\/validator\/EntrustTLSPolicy.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -41,1 +41,0 @@\n-import java.util.function.UnaryOperator;\n@@ -94,4 +93,0 @@\n-    \/\/ Interned BaseLocale cache\n-    private static final ReferencedKeySet<BaseLocale> CACHE =\n-            ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n-\n@@ -166,13 +161,3 @@\n-        return CACHE.intern(new BaseLocale(language, script, region, variant),\n-                \/\/ Avoid lambdas since this may be on the bootstrap path in many locales\n-                INTERNER);\n-    }\n-\n-    public static final UnaryOperator<BaseLocale> INTERNER = new UnaryOperator<>() {\n-        @Override\n-        public BaseLocale apply(BaseLocale b) {\n-            return new BaseLocale(\n-                    LocaleUtils.toLowerString(b.language).intern(),\n-                    LocaleUtils.toTitleString(b.script).intern(),\n-                    LocaleUtils.toUpperString(b.region).intern(),\n-                    b.variant.intern());\n+        class InterningCache { \/\/ TODO: StableValue\n+            private static final ReferencedKeySet<BaseLocale> CACHE =\n+                    ReferencedKeySet.create(true, ReferencedKeySet.concurrentHashMapSupplier());\n@@ -180,1 +165,6 @@\n-    };\n+        return InterningCache.CACHE.intern(new BaseLocale(\n+                language.intern(), \/\/ guaranteed to be lower-case\n+                LocaleUtils.toTitleString(script).intern(),\n+                region.intern(), \/\/ guaranteed to be upper-case\n+                variant.intern()));\n+    }\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/BaseLocale.java","additions":9,"deletions":19,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,0 +65,1 @@\n+import jdk.internal.util.StaticProperty;\n@@ -292,0 +293,10 @@\n+        \/\/ Get names for old ISO codes with new ISO code resources\n+        if (StaticProperty.javaLocaleUseOldISOCodes().equalsIgnoreCase(\"true\")) {\n+            key = switch (key) {\n+                case \"iw\" -> \"he\";\n+                case \"in\" -> \"id\";\n+                case \"ji\" -> \"yi\";\n+                default -> key;\n+            };\n+        }\n+\n","filename":"src\/java.base\/share\/classes\/sun\/util\/locale\/provider\/LocaleResources.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -1333,0 +1333,3 @@\n+#   ENTRUST_TLS : Distrust TLS Server certificates anchored by\n+#   an Entrust root CA and issued after October 31, 2024.\n+#\n@@ -1344,1 +1347,1 @@\n-jdk.security.caDistrustPolicies=SYMANTEC_TLS\n+jdk.security.caDistrustPolicies=SYMANTEC_TLS,ENTRUST_TLS\n","filename":"src\/java.base\/share\/conf\/security\/java.security","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -555,8 +555,32 @@\n-Methods that provide native access are restricted, and by default their\n-use causes warnings.\n-This option allows code in the specified modules to use restricted\n-methods without warnings.\n-\\f[I]module\\f[R] can be \\f[V]ALL-UNNAMED\\f[R] to indicate code on the\n-class path.\n-When this option is present, any use of restricted methods by code\n-outside the specified modules causes an\n+Native access can occur as a result of calling a method that is either\n+\\f[B]restricted\\f[R] [https:\/\/openjdk.org\/jeps\/454#Safety], or\n+\\f[V]native\\f[R].\n+This option allows code in the specified modules to perform native\n+access.\n+Native access occurring in a module that has not been explicitly enabled\n+is deemed \\f[I]illegal\\f[R].\n+.RS\n+.PP\n+\\f[I]module\\f[R] can be a module name, or \\f[V]ALL-UNNAMED\\f[R] to\n+indicate code on the class path.\n+.RE\n+.TP\n+-\\f[V]--illegal-native-access=\\f[R]\\f[I]parameter\\f[R]\n+This option specifies a mode for how illegal native access is handled:\n+.RS\n+.RS\n+.PP\n+\\f[B]Note:\\f[R] This option will be removed in a future release.\n+.RE\n+.IP \\[bu] 2\n+\\f[V]allow\\f[R]: This mode allows illegal native access in all modules,\n+without any warings.\n+.IP \\[bu] 2\n+\\f[V]warn\\f[R]: This mode is identical to \\f[V]allow\\f[R] except that a\n+warning message is issued for the first illegal native access found in a\n+module.\n+This mode is the default for the current JDK but will change in a future\n+release.\n+.IP \\[bu] 2\n+\\f[V]deny\\f[R]: This mode disables illegal native access.\n+That is, any illegal native access causes an\n@@ -564,0 +588,6 @@\n+This mode will become the default in a future release.\n+.PP\n+To verify that your application is ready for a future version of the\n+JDK, run it with \\f[V]--illegal-native-access=deny\\f[R] along with any\n+necessary \\f[V]--enable-native-access\\f[R] options.\n+.RE\n","filename":"src\/java.base\/share\/man\/java.1","additions":38,"deletions":8,"binary":false,"changes":46,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1996, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1996, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -778,0 +778,6 @@\n+\n+    \/* Large UTF8 Support *\/\n+\n+    jlong (JNICALL *GetStringUTFLengthAsLong)\n+      (JNIEnv *env, jstring str);\n+\n@@ -1626,0 +1632,3 @@\n+    jlong GetStringUTFLengthAsLong(jstring str) {\n+        return functions->GetStringUTFLengthAsLong(this,str);\n+    }\n@@ -1996,0 +2005,1 @@\n+#define JNI_VERSION_24  0x00180000\n","filename":"src\/java.base\/share\/native\/include\/jni.h","additions":11,"deletions":1,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1995, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1995, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,19 @@\n-    JLI_CmdToArgs(GetCommandLine());\n+\n+    \/\/ Obtain the command line in UTF-16, then convert it to ANSI code page\n+    \/\/ without the \"best-fit\" option\n+    LPWSTR wcCmdline = GetCommandLineW();\n+    int mbSize = WideCharToMultiByte(CP_ACP,\n+        WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR,\n+        wcCmdline, -1, NULL, 0, NULL, NULL);\n+    \/\/ If the call to WideCharToMultiByte() fails, it returns 0, which\n+    \/\/ will then make the following JLI_MemAlloc() to issue exit(1)\n+    LPSTR mbCmdline = JLI_MemAlloc(mbSize);\n+    if (WideCharToMultiByte(CP_ACP, WC_NO_BEST_FIT_CHARS | WC_COMPOSITECHECK | WC_DEFAULTCHAR,\n+        wcCmdline, -1, mbCmdline, mbSize, NULL, NULL) == 0) {\n+        perror(\"command line encoding conversion failure\");\n+        exit(1);\n+    }\n+\n+    JLI_CmdToArgs(mbCmdline);\n+    JLI_MemFree(mbCmdline);\n+\n","filename":"src\/java.base\/share\/native\/launcher\/main.c","additions":20,"deletions":2,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -116,0 +116,3 @@\n+\/\/ This is defined in link_type.c due to linking restraints\n+jboolean JLI_IsStaticallyLinked();\n+\n","filename":"src\/java.base\/share\/native\/libjli\/jli_util.h","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,38 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include \"jni.h\"\n+\n+\/\/ This is in a separate file since it will need to be compiled to two different\n+\/\/ object files, depending on if we are going to build a static or a dynamic\n+\/\/ library.\n+\n+jboolean JLI_IsStaticallyLinked(void) {\n+#ifdef STATIC_BUILD\n+  return JNI_TRUE;\n+#else\n+  return JNI_FALSE;\n+#endif\n+}\n","filename":"src\/java.base\/share\/native\/libjli\/link_type.c","additions":38,"deletions":0,"binary":false,"changes":38,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,0 @@\n-    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n@@ -54,0 +53,1 @@\n+    outputConsumedID = (*env)->GetFieldID(env, cls, \"outputConsumed\", \"I\");\n","filename":"src\/java.base\/share\/native\/libzip\/Inflater.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,2 +36,2 @@\n-    private long st_dev;    \/\/ ID of device\n-    private long st_ino;    \/\/ Inode number\n+    private final long st_dev;    \/\/ ID of device\n+    private final long st_ino;    \/\/ Inode number\n@@ -39,1 +39,4 @@\n-    private FileKey() { }\n+    private FileKey(long st_dev, long st_ino) {\n+        this.st_dev = st_dev;\n+        this.st_ino = st_ino;\n+    }\n@@ -42,3 +45,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        long finfo[] = new long[2];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1]);\n@@ -62,2 +65,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, long[] finfo)\n+        throws IOException;\n@@ -66,1 +69,1 @@\n-        initIDs();\n+        IOUtil.load();\n","filename":"src\/java.base\/unix\/classes\/sun\/nio\/ch\/FileKey.java","additions":13,"deletions":10,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -664,2 +664,0 @@\n-    char fn[32];\n-    char exePath[PATH_MAX];\n@@ -668,1 +666,0 @@\n-    int ret;\n","filename":"src\/java.base\/unix\/native\/libjava\/ProcessHandleImpl_unix.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -44,2 +44,0 @@\n-static char *isFileIdentical(char* buf, size_t size, char *pathname);\n-\n@@ -62,4 +60,0 @@\n-#if defined(_AIX)\n-static const char *ETC_ENVIRONMENT_FILE = \"\/etc\/environment\";\n-#endif\n-\n@@ -67,0 +61,1 @@\n+static char *isFileIdentical(char* buf, size_t size, char *pathname);\n@@ -359,0 +354,1 @@\n+static const char *ETC_ENVIRONMENT_FILE = \"\/etc\/environment\";\n","filename":"src\/java.base\/unix\/native\/libjava\/TimeZone_md.c","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -33,12 +33,0 @@\n-static jfieldID key_st_dev;    \/* id for FileKey.st_dev *\/\n-static jfieldID key_st_ino;    \/* id for FileKey.st_ino *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_st_dev = (*env)->GetFieldID(env, clazz, \"st_dev\", \"J\"));\n-    CHECK_NULL(key_st_ino = (*env)->GetFieldID(env, clazz, \"st_ino\", \"J\"));\n-}\n-\n-\n@@ -46,1 +34,2 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv* env, jclass clazz, jobject fdo,\n+    jlongArray finfo)\n@@ -50,0 +39,1 @@\n+    jlong deviceAndInode[2];\n@@ -51,1 +41,2 @@\n-    RESTARTABLE(fstat(fdval(env, fdo), &fbuf), res);\n+    int fd = fdval(env, fdo);\n+    RESTARTABLE(fstat(fd, &fbuf), res);\n@@ -55,2 +46,3 @@\n-        (*env)->SetLongField(env, this, key_st_dev, (jlong)fbuf.st_dev);\n-        (*env)->SetLongField(env, this, key_st_ino, (jlong)fbuf.st_ino);\n+        deviceAndInode[0] = (jlong)fbuf.st_dev;\n+        deviceAndInode[1] = (jlong)fbuf.st_ino;\n+        (*env)->SetLongArrayRegion(env, finfo, 0, 2, deviceAndInode);\n","filename":"src\/java.base\/unix\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":16,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -136,3 +136,4 @@\n-#ifndef STATX_ALL\n-#define STATX_ALL (STATX_BTIME | STATX_BASIC_STATS)\n-#endif\n+\/\/\n+\/\/ STATX_ALL is deprecated; use a different name to avoid confusion.\n+\/\/\n+#define LOCAL_STATX_ALL (STATX_BASIC_STATS | STATX_BTIME)\n@@ -257,0 +258,17 @@\n+#if defined(__linux__) && defined(__arm__)\n+\/**\n+ * Lookup functions with time_t parameter. Try to use 64 bit symbol\n+ * if sizeof(time_t) exceeds 32 bit.\n+ *\/\n+static void* lookup_time_t_function(const char* symbol, const char* symbol64) {\n+    void *func_ptr = NULL;\n+    if (sizeof(time_t) > 4) {\n+        func_ptr = dlsym(RTLD_DEFAULT, symbol64);\n+    }\n+    if (func_ptr == NULL) {\n+        return dlsym(RTLD_DEFAULT, symbol);\n+    }\n+    return func_ptr;\n+}\n+#endif\n+\n@@ -354,0 +372,8 @@\n+#if defined(__linux__) && defined(__arm__)\n+    my_futimesat_func = (futimesat_func*) lookup_time_t_function(\"futimesat\",\n+        \"__futimesat64\");\n+    my_lutimes_func = (lutimes_func*) lookup_time_t_function(\"lutimes\",\n+        \"__lutimes64\");\n+    my_futimens_func = (futimens_func*) lookup_time_t_function(\"futimens\",\n+        \"__futimens64\");\n+#else\n@@ -359,0 +385,1 @@\n+#endif\n@@ -596,2 +623,13 @@\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec, (jlong)buf->stx_btime.tv_sec);\n-    (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec, (jlong)buf->stx_btime.tv_nsec);\n+    if ((buf->stx_mask & STATX_BTIME) != 0) {\n+        \/\/  Birth time was filled in so use it\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_btime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_btime.tv_nsec);\n+    } else {\n+        \/\/  Birth time was not filled in: fall back to last modification time\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_sec,\n+                             (jlong)buf->stx_mtime.tv_sec);\n+        (*env)->SetLongField(env, attrs, attrs_st_birthtime_nsec,\n+                             (jlong)buf->stx_mtime.tv_nsec);\n+    }\n@@ -651,1 +689,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -683,1 +721,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -714,1 +752,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n@@ -747,1 +785,1 @@\n-    unsigned int mask = STATX_ALL;\n+    unsigned int mask = LOCAL_STATX_ALL;\n","filename":"src\/java.base\/unix\/native\/libnio\/fs\/UnixNativeDispatcher.c","additions":47,"deletions":9,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -36,3 +36,3 @@\n-    private int dwVolumeSerialNumber;\n-    private int nFileIndexHigh;\n-    private int nFileIndexLow;\n+    private final int dwVolumeSerialNumber;\n+    private final int nFileIndexHigh;\n+    private final int nFileIndexLow;\n@@ -40,1 +40,6 @@\n-    private FileKey() { }\n+    private FileKey(int dwVolumeSerialNumber, int nFileIndexHigh,\n+        int nFileIndexLow) {\n+        this.dwVolumeSerialNumber = dwVolumeSerialNumber;\n+        this.nFileIndexHigh = nFileIndexHigh;\n+        this.nFileIndexLow = nFileIndexLow;\n+    }\n@@ -43,3 +48,3 @@\n-        FileKey fk = new FileKey();\n-        fk.init(fd);\n-        return fk;\n+        int finfo[] = new int[3];\n+        init(fd, finfo);\n+        return new FileKey(finfo[0], finfo[1], finfo[2]);\n@@ -63,2 +68,2 @@\n-    private native void init(FileDescriptor fd) throws IOException;\n-    private static native void initIDs();\n+    private static native void init(FileDescriptor fd, int[] finfo)\n+        throws IOException;\n@@ -68,1 +73,0 @@\n-        initIDs();\n","filename":"src\/java.base\/windows\/classes\/sun\/nio\/ch\/FileKey.java","additions":14,"deletions":10,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -331,1 +331,1 @@\n-        _snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n+        snprintf(cptr, MAX_PATH, \"\\\"%s\\\" %s\", argv[0], cmdline);\n","filename":"src\/java.base\/windows\/native\/libjli\/cmdtoargs.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -33,14 +33,0 @@\n-static jfieldID key_volumeSN;    \/* id for FileKey.dwVolumeSerialNumber *\/\n-static jfieldID key_indexHigh;   \/* id for FileKey.nFileIndexHigh *\/\n-static jfieldID key_indexLow;    \/* id for FileKey.nFileIndexLow *\/\n-\n-\n-JNIEXPORT void JNICALL\n-Java_sun_nio_ch_FileKey_initIDs(JNIEnv *env, jclass clazz)\n-{\n-    CHECK_NULL(key_volumeSN = (*env)->GetFieldID(env, clazz, \"dwVolumeSerialNumber\", \"I\"));\n-    CHECK_NULL(key_indexHigh = (*env)->GetFieldID(env, clazz, \"nFileIndexHigh\", \"I\"));\n-    CHECK_NULL(key_indexLow = (*env)->GetFieldID(env, clazz, \"nFileIndexLow\", \"I\"));\n-}\n-\n-\n@@ -48,1 +34,1 @@\n-Java_sun_nio_ch_FileKey_init(JNIEnv *env, jobject this, jobject fdo)\n+Java_sun_nio_ch_FileKey_init(JNIEnv *env, jclass clazz, jobject fdo, jintArray finfo)\n@@ -50,1 +36,1 @@\n-    HANDLE fileHandle = (HANDLE)(handleval(env, fdo));\n+    HANDLE fileHandle = (HANDLE)handleval(env, fdo);\n@@ -53,0 +39,1 @@\n+    jint info[3];\n@@ -56,3 +43,4 @@\n-        (*env)->SetIntField(env, this, key_volumeSN, fileInfo.dwVolumeSerialNumber);\n-        (*env)->SetIntField(env, this, key_indexHigh, fileInfo.nFileIndexHigh);\n-        (*env)->SetIntField(env, this, key_indexLow, fileInfo.nFileIndexLow);\n+        info[0] = (jint)fileInfo.dwVolumeSerialNumber;\n+        info[1] = (jint)fileInfo.nFileIndexHigh;\n+        info[2] = (jint)fileInfo.nFileIndexLow;\n+        (*env)->SetIntArrayRegion(env, finfo, 0, 3, info);\n","filename":"src\/java.base\/windows\/native\/libnio\/ch\/FileKey.c","additions":8,"deletions":20,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.tools.JavaFileManager;\n@@ -31,1 +30,0 @@\n-import javax.lang.model.element.TypeElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/annotation\/processing\/Filer.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -28,4 +28,0 @@\n-import java.util.Collections;\n-import java.util.Set;\n-import java.util.HashSet;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/SourceVersion.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,2 +30,0 @@\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Element.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,4 +54,30 @@\n-    \/** The modifier {@code public} *\/          PUBLIC,\n-    \/** The modifier {@code protected} *\/       PROTECTED,\n-    \/** The modifier {@code private} *\/         PRIVATE,\n-    \/** The modifier {@code abstract} *\/        ABSTRACT,\n+    \/**\n+     * The modifier {@code public}\n+     *\n+     * @jls 6.6 Access Control\n+     *\/\n+    PUBLIC,\n+\n+    \/**\n+     * The modifier {@code protected}\n+     *\n+     * @jls 6.6 Access Control\n+     *\/\n+    PROTECTED,\n+\n+    \/**\n+     * The modifier {@code private}\n+     *\n+     * @jls 6.6 Access Control\n+     *\/\n+    PRIVATE,\n+\n+    \/**\n+     * The modifier {@code abstract}\n+     *\n+     * @jls 8.1.1.1 {@code abstract} Classes\n+     * @jls 8.4.3.1 {@code abstract} Methods\n+     * @jls 9.1.1.1 {@code abstract} Interfaces\n+     *\/\n+    ABSTRACT,\n+\n@@ -60,0 +86,2 @@\n+     *\n+     * @jls 9.4 Method Declarations\n@@ -63,1 +91,10 @@\n-    \/** The modifier {@code static} *\/          STATIC,\n+\n+    \/**\n+     * The modifier {@code static}\n+     *\n+     * @jls 8.1.1.4 {@code static} Classes\n+     * @jls 8.3.1.1 {@code static} Fields\n+     * @jls 8.4.3.2 {@code static} Methods\n+     * @jls 9.1.1.3 {@code static} Interfaces\n+     *\/\n+    STATIC,\n@@ -67,0 +104,3 @@\n+     *\n+     * @jls 8.1.1.2 {@code sealed}, {@code non-sealed}, and {@code final} Classes\n+     * @jls 9.1.1.4 {@code sealed} and {@code non-sealed} Interfaces\n@@ -73,0 +113,3 @@\n+     *\n+     * @jls 8.1.1.2 {@code sealed}, {@code non-sealed}, and {@code final} Classes\n+     * @jls 9.1.1.4 {@code sealed} and {@code non-sealed} Interfaces\n@@ -80,6 +123,45 @@\n-    \/** The modifier {@code final} *\/           FINAL,\n-    \/** The modifier {@code transient} *\/       TRANSIENT,\n-    \/** The modifier {@code volatile} *\/        VOLATILE,\n-    \/** The modifier {@code synchronized} *\/    SYNCHRONIZED,\n-    \/** The modifier {@code native} *\/          NATIVE,\n-    \/** The modifier {@code strictfp} *\/        STRICTFP;\n+    \/**\n+     * The modifier {@code final}\n+     *\n+     * @jls 8.1.1.2 {@code sealed}, {@code non-sealed}, and {@code final} Classes\n+     * @jls 8.3.1.2 {@code final} Fields\n+     * @jls 8.4.3.3 {@code final} Methods\n+     *\/\n+    FINAL,\n+\n+    \/**\n+     * The modifier {@code transient}\n+     *\n+     * @jls 8.3.1.3 {@code transient} Fields\n+     *\/\n+    TRANSIENT,\n+\n+    \/**\n+     * The modifier {@code volatile}\n+     *\n+     * @jls 8.3.1.4 {@code volatile} Fields\n+     *\/\n+    VOLATILE,\n+\n+    \/**\n+     * The modifier {@code synchronized}\n+     *\n+     * @jls 8.4.3.6 {@code synchronized} Methods\n+     *\/\n+    SYNCHRONIZED,\n+\n+    \/**\n+     * The modifier {@code native}\n+     *\n+     * @jls 8.4.3.4 {@code native} Methods\n+     *\/\n+    NATIVE,\n+\n+    \/**\n+     * The modifier {@code strictfp}\n+     *\n+     * @jls 8.1.1.3 {@code strictfp} Classes\n+     * @jls 8.4.3.5 {@code strictfp} Methods\n+     * @jls 9.1.1.2 {@code strictfp} Interfaces\n+     *\/\n+    STRICTFP;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/Modifier.java","additions":94,"deletions":12,"binary":false,"changes":106,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/TypeElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,2 +28,0 @@\n-import jdk.internal.javac.PreviewFeature;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/element\/VariableElement.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,2 +31,0 @@\n-import javax.lang.model.util.Types;\n-\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVariable.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,0 @@\n-import javax.lang.model.element.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/type\/TypeVisitor.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import javax.lang.model.type.*;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/AbstractTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -33,1 +33,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner14.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScanner9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,2 +30,0 @@\n-import java.util.List;\n-import java.util.ArrayList;\n@@ -35,2 +33,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/ElementScannerPreview.java","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleAnnotationValueVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -31,1 +31,0 @@\n-import javax.lang.model.element.ElementVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,3 +32,0 @@\n-import javax.lang.model.SourceVersion;\n-import javax.lang.model.element.ElementVisitor;\n-import javax.lang.model.element.RecordComponentElement;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleElementVisitorPreview.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor6.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.type.TypeVisitor;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor7.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -30,1 +30,0 @@\n-import javax.lang.model.type.IntersectionType;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitor9.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/SimpleTypeVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -32,1 +32,0 @@\n-import javax.lang.model.SourceVersion;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/TypeKindVisitorPreview.java","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -28,3 +28,0 @@\n-import java.lang.annotation.Annotation;\n-import java.lang.annotation.AnnotationTypeMismatchException;\n-import java.lang.annotation.IncompleteAnnotationException;\n","filename":"src\/java.compiler\/share\/classes\/javax\/lang\/model\/util\/Types.java","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,2 +64,0 @@\n-    private static final Object FLAVOR_MAP_KEY = new Object();\n-\n","filename":"src\/java.datatransfer\/share\/classes\/java\/awt\/datatransfer\/SystemFlavorMap.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -496,3 +496,0 @@\n-    char **mclr;\n-    int  mccr = 0;\n-    char *dsr;\n","filename":"src\/java.desktop\/aix\/native\/libawt_xawt\/awt\/awt_InputMethod.c","additions":0,"deletions":3,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -61,1 +61,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/eio\/FileManager.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,1 +68,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaFileView.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -391,1 +391,3 @@\n-            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\"\n+            \"ctrl shift DOWN\", \"selectLastRowExtendSelection\",\n+            \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n+            \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\"\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaKeyBindings.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -157,1 +157,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaLookAndFeel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaMenuBarUI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaNativeResources.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,6 +28,24 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import java.beans.*;\n-import java.util.*;\n-\n-import javax.swing.*;\n+import java.awt.Adjustable;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Dimension;\n+import java.awt.Graphics;\n+import java.awt.Insets;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.event.ActionEvent;\n+import java.awt.event.ActionListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.MouseMotionListener;\n+\n+import java.beans.PropertyChangeEvent;\n+import java.beans.PropertyChangeListener;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import javax.swing.BoundedRangeModel;\n+import javax.swing.JComponent;\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.LookAndFeel;\n@@ -35,5 +53,13 @@\n-import javax.swing.event.*;\n-import javax.swing.plaf.*;\n-\n-import apple.laf.*;\n-import apple.laf.JRSUIConstants.*;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+import javax.swing.plaf.ComponentUI;\n+import javax.swing.plaf.ScrollBarUI;\n+\n+import apple.laf.JRSUIStateFactory;\n+import apple.laf.JRSUIConstants.Hit;\n+import apple.laf.JRSUIConstants.NothingToScroll;\n+import apple.laf.JRSUIConstants.Orientation;\n+import apple.laf.JRSUIConstants.ScrollBarHit;\n+import apple.laf.JRSUIConstants.ScrollBarPart;\n+import apple.laf.JRSUIConstants.ShowArrows;\n+import apple.laf.JRSUIConstants.State;\n@@ -41,0 +67,1 @@\n+import apple.laf.JRSUIUtils;\n@@ -530,0 +557,15 @@\n+            Component parent = fScrollBar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        fScrollBar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/AquaScrollBarUI.java","additions":54,"deletions":12,"binary":false,"changes":66,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/com\/apple\/laf\/ScreenMenu.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -80,1 +80,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/CAccessibility.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -149,1 +149,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/macosx\/classes\/sun\/lwawt\/macosx\/LWCToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,0 +120,1 @@\n+    BOOL isApplicationOwner = NO;\n@@ -122,1 +123,4 @@\n-        if ([NSApp isKindOfClass:[NSApplicationAWT class]]) shouldInstall = YES;\n+        if ([NSApp isKindOfClass:[NSApplicationAWT class]]) {\n+            shouldInstall = YES;\n+            isApplicationOwner = YES;\n+        }\n@@ -125,1 +129,5 @@\n-    if (!shouldInstall) return nil;\n+    if (!shouldInstall) {\n+        [ThreadUtilities setApplicationOwner:NO];\n+        return nil;\n+    }\n+    [ThreadUtilities setApplicationOwner:isApplicationOwner];\n","filename":"src\/java.desktop\/macosx\/native\/libawt_lwawt\/awt\/ApplicationDelegate.m","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -134,0 +134,1 @@\n++ (void)setApplicationOwner:(BOOL)owner;\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/ThreadUtilities.h","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+static BOOL isNSApplicationOwner = NO;\n@@ -62,0 +63,4 @@\n++ (void)setApplicationOwner:(BOOL)owner {\n+    isNSApplicationOwner = owner;\n+}\n+\n@@ -64,2 +69,7 @@\n-    if (appKitEnv == NULL) {\n-        attachCurrentThread((void **)&appKitEnv);\n+    if (isNSApplicationOwner) {\n+        if (appKitEnv == NULL) {\n+            attachCurrentThread((void **)&appKitEnv);\n+        }\n+        return appKitEnv;\n+    } else {\n+        return [ThreadUtilities getJNIEnvUncached];\n@@ -67,1 +77,0 @@\n-    return appKitEnv;\n","filename":"src\/java.desktop\/macosx\/native\/libosxapp\/ThreadUtilities.m","additions":13,"deletions":4,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageReader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/jpeg\/JPEGImageWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -29,0 +29,1 @@\n+import java.awt.image.BufferedImage;\n@@ -922,2 +923,14 @@\n-            Rectangle rect = new Rectangle(minX, row, width, 1);\n-            Raster ras = image.getData(rect);\n+            Raster ras;\n+            if (image instanceof BufferedImage bi) {\n+                \/\/ Use the raster directly (no copy).\n+                ras = bi.getRaster();\n+            } else if (image.getNumXTiles() == 1 && image.getNumYTiles() == 1 &&\n+                       image.getTileWidth() == width && image.getTileHeight() == height) {\n+                \/\/ Use the single tile directly (no copy).\n+                ras = image.getTile(image.getMinTileX(), image.getMinTileY());\n+            } else {\n+                \/\/ Make a copy of the raster data.\n+                Rectangle rect = new Rectangle(minX, row, width, 1);\n+                ras = image.getData(rect);\n+            }\n+\n@@ -925,2 +938,1 @@\n-                ras = ras.createChild(minX, row, width, 1, minX, row,\n-                                      sourceBands);\n+                ras = ras.createChild(minX, row, width, 1, minX, row, sourceBands);\n@@ -932,1 +944,1 @@\n-                WritableRaster wr = ras.createCompatibleWritableRaster();\n+                WritableRaster wr = ras.createCompatibleWritableRaster(minX, row, width, 1);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/imageio\/plugins\/png\/PNGImageWriter.java","additions":17,"deletions":5,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -64,1 +64,1 @@\n-    \/** This enum mirrors that in gtk2_interface.h *\/\n+    \/** This enum mirrors that in gtk_interface.h *\/\n@@ -496,5 +496,4 @@\n-        if(GTKLookAndFeel.is3()) {\n-            if (parent != null && parent.getParent() instanceof JComboBox) {\n-                if (parent.getParent().hasFocus()) {\n-                    synthState |= SynthConstants.FOCUSED;\n-                }\n+\n+        if (parent != null && parent.getParent() instanceof JComboBox) {\n+            if (parent.getParent().hasFocus()) {\n+                synthState |= SynthConstants.FOCUSED;\n@@ -503,0 +502,1 @@\n+\n@@ -631,1 +631,1 @@\n-    \/* GtkSettings enum mirrors that in gtk2_interface.h *\/\n+    \/* GtkSettings enum mirrors that in gtk_interface.h *\/\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKEngine.java","additions":8,"deletions":8,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n-    static final int DEFAULT_TOGGLE_MENU_ITEM_SIZE = 12; \/\/ For pre-gtk2.4\n+    static final int DEFAULT_TOGGLE_MENU_ITEM_SIZE = 12;\n@@ -217,1 +217,1 @@\n-            if (GTKLookAndFeel.is3() && region == Region.MENU) {\n+            if (region == Region.MENU) {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKIconFactory.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -80,1 +80,0 @@\n-    private static boolean IS_22;\n@@ -127,11 +126,0 @@\n-    \/**\n-     * Returns true if running on system containing at least 2.2.\n-     *\/\n-    static boolean is2_2() {\n-        \/\/ NOTE: We're currently hard coding to use 2.2.\n-        \/\/ If we want to support both GTK 2.0 and 2.2, we'll\n-        \/\/ need to get the major\/minor\/micro version from the .so.\n-        \/\/ Refer to bug 4912613 for details.\n-        return IS_22;\n-    }\n-\n@@ -1073,1 +1061,1 @@\n-                     \"ctrl shift RIGHT\", \"selectNextColumnExtendSelection\",\n+                     \"ctrl shift RIGHT\", \"selectLastColumnExtendSelection\",\n@@ -1081,1 +1069,1 @@\n-                      \"ctrl shift LEFT\", \"selectPreviousColumnExtendSelection\",\n+                      \"ctrl shift LEFT\", \"selectFirstColumnExtendSelection\",\n@@ -1457,11 +1445,1 @@\n-        if (UNIXToolkit.getGtkVersion() == UNIXToolkit.GtkVersions.GTK2) {\n-            @SuppressWarnings(\"removal\")\n-            String version = AccessController.doPrivileged(\n-                    new GetPropertyAction(\"jdk.gtk.version\"));\n-            if (version != null) {\n-                IS_22 = version.equals(\"2.2\");\n-            } else {\n-                IS_22 = true;\n-            }\n-        } else if (UNIXToolkit.getGtkVersion() ==\n-                                UNIXToolkit.GtkVersions.GTK3) {\n+        if (UNIXToolkit.getGtkVersion() == UNIXToolkit.GtkVersions.GTK3) {\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKLookAndFeel.java","additions":3,"deletions":25,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -214,14 +214,1 @@\n-            if (GTKLookAndFeel.is3()) {\n-                paintComponentBackground(context, g, x, y, w, h);\n-                return;\n-            }\n-            synchronized (UNIXToolkit.GTK_LOCK) {\n-                if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {\n-                    ShadowType shadow = (GTKLookAndFeel.is2_2() ?\n-                        ShadowType.NONE : ShadowType.OUT);\n-                    ENGINE.startPainting(g, x, y, w, h, id);\n-                    ENGINE.paintBox(g, context, id, gtkState,\n-                            shadow, \"menuitem\", x, y, w, h);\n-                    ENGINE.finishPainting();\n-                }\n-            }\n+            paintComponentBackground(context, g, x, y, w, h);\n@@ -573,15 +560,1 @@\n-            if (GTKLookAndFeel.is3()) {\n-                paintComponentBackground(context, g, x, y, w, h);\n-                return;\n-            }\n-            Region id = Region.MENU_ITEM;\n-            synchronized (UNIXToolkit.GTK_LOCK) {\n-                if (! ENGINE.paintCachedImage(g, x, y, w, h, id)) {\n-                    ShadowType shadow = (GTKLookAndFeel.is2_2() ?\n-                        ShadowType.NONE : ShadowType.OUT);\n-                    ENGINE.startPainting(g, x, y, w, h, id);\n-                    ENGINE.paintBox(g, context, id, gtkState, shadow,\n-                            \"menuitem\", x, y, w, h);\n-                    ENGINE.finishPainting();\n-                }\n-            }\n+            paintComponentBackground(context, g, x, y, w, h);\n@@ -701,7 +674,4 @@\n-            if (GTKLookAndFeel.is3()) {\n-                if (id == Region.POPUP_MENU_SEPARATOR) {\n-                    detail = \"menuitem\";\n-                    h -= (insets.top + insets.bottom);\n-                } else {\n-                    detail = \"separator\";\n-                }\n+\n+            if (id == Region.POPUP_MENU_SEPARATOR) {\n+                detail = \"menuitem\";\n+                h -= (insets.top + insets.bottom);\n@@ -709,2 +679,1 @@\n-                detail = orientation == JSeparator.HORIZONTAL ?\n-                                                    \"hseparator\" : \"vseparator\";\n+                detail = \"separator\";\n@@ -712,0 +681,1 @@\n+\n@@ -826,8 +796,7 @@\n-        if (GTKLookAndFeel.is3()) {\n-            if (slider.getOrientation() == JSlider.VERTICAL) {\n-                y += 1;\n-                h -= 2;\n-            } else {\n-                x += 1;\n-                w -= 2;\n-            }\n+\n+        if (slider.getOrientation() == JSlider.VERTICAL) {\n+            y += 1;\n+            h -= 2;\n+        } else {\n+            x += 1;\n+            w -= 2;\n@@ -835,0 +804,1 @@\n+\n@@ -868,1 +838,1 @@\n-        boolean hasFocus = GTKLookAndFeel.is3() &&\n+        boolean hasFocus =\n@@ -968,4 +938,0 @@\n-        Region id = context.getRegion();\n-        int state = context.getComponentState();\n-        int gtkState = ((state & SynthConstants.SELECTED) != 0 ?\n-            SynthConstants.ENABLED : SynthConstants.PRESSED);\n@@ -973,1 +939,6 @@\n-        int placement = pane.getTabPlacement();\n+        if (UIManager.getBoolean(\"TabbedPane.tabsOpaque\") || pane.isOpaque()) {\n+            Region id = context.getRegion();\n+            int state = context.getComponentState();\n+            int gtkState = ((state & SynthConstants.SELECTED) != 0 ?\n+                    SynthConstants.ENABLED : SynthConstants.PRESSED);\n+            int placement = pane.getTabPlacement();\n@@ -975,2 +946,2 @@\n-        \/\/ Fill the tab rect area\n-        g.fillRect(x, y, w, h);\n+            \/\/ Fill the tab rect area\n+            g.fillRect(x, y, w, h);\n@@ -978,9 +949,10 @@\n-        synchronized (UNIXToolkit.GTK_LOCK) {\n-            if (! ENGINE.paintCachedImage(g, x, y, w, h,\n-                    id, gtkState, placement, tabIndex)) {\n-                PositionType side = POSITIONS[placement - 1];\n-                ENGINE.startPainting(g, x, y, w, h,\n-                        id, gtkState, placement, tabIndex);\n-                ENGINE.paintExtension(g, context, id, gtkState,\n-                        ShadowType.OUT, \"tab\", x, y, w, h, side, tabIndex);\n-                ENGINE.finishPainting();\n+            synchronized (UNIXToolkit.GTK_LOCK) {\n+                if (!ENGINE.paintCachedImage(g, x, y, w, h,\n+                        id, gtkState, placement, tabIndex)) {\n+                    PositionType side = POSITIONS[placement - 1];\n+                    ENGINE.startPainting(g, x, y, w, h,\n+                            id, gtkState, placement, tabIndex);\n+                    ENGINE.paintExtension(g, context, id, gtkState,\n+                            ShadowType.OUT, \"tab\", x, y, w, h, side, tabIndex);\n+                    ENGINE.finishPainting();\n+                }\n@@ -1062,4 +1034,2 @@\n-            if (GTKLookAndFeel.is3()) {\n-                ENGINE.paintBackground(g, context, id, gtkState, null,\n-                                                                    x, y, w, h);\n-            }\n+            ENGINE.paintBackground(g, context, id, gtkState, null,\n+                                                                x, y, w, h);\n@@ -1068,9 +1038,0 @@\n-            if (!GTKLookAndFeel.is3()) {\n-                ENGINE.paintFlatBox(g, context, id,\n-                        gtkState, ShadowType.NONE, \"entry_bg\",\n-                        x + xThickness,\n-                        y + yThickness,\n-                        w - (2 * xThickness),\n-                        h - (2 * yThickness),\n-                        ColorType.TEXT_BACKGROUND);\n-            }\n@@ -1087,3 +1048,3 @@\n-                        y += focusSize + (GTKLookAndFeel.is3() ? 3 : 1);\n-                        w -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 1);\n-                        h -= 2 * focusSize + (GTKLookAndFeel.is3() ? 6 : 2);\n+                        y += focusSize + 3;\n+                        w -= 2 * focusSize + 4;\n+                        h -= 2 * focusSize + 6;\n@@ -1091,4 +1052,4 @@\n-                        x += focusSize + (GTKLookAndFeel.is3() ? 2 : 0);\n-                        y += focusSize + (GTKLookAndFeel.is3() ? 2 :0 );\n-                        w -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 0);\n-                        h -= 2 * focusSize + (GTKLookAndFeel.is3() ? 4 : 0);\n+                        x += focusSize + 2;\n+                        y += focusSize + 2;\n+                        w -= 2 * focusSize + 4;\n+                        h -= 2 * focusSize + 4;\n@@ -1440,5 +1401,0 @@\n-        if (!GTKLookAndFeel.is3()) {\n-            x += 3;\n-            y += 3;\n-            w = h = 7;\n-        }\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKPainter.java","additions":44,"deletions":88,"binary":false,"changes":132,"status":"modified"},{"patch":"@@ -754,8 +754,1 @@\n-        if (!GTKLookAndFeel.is3()) {\n-            if (region == Region.FORMATTED_TEXT_FIELD ||\n-                  region == Region.PASSWORD_FIELD ||\n-                  region == Region.SPINNER ||\n-                  region == Region.TEXT_FIELD) {\n-                return true;\n-            }\n-        }\n+\n@@ -887,1 +880,1 @@\n-        } else if (GTKLookAndFeel.is3() && \"ComboBox.forceOpaque\".equals(key)) {\n+        } else if (\"ComboBox.forceOpaque\".equals(key)) {\n@@ -898,5 +891,1 @@\n-        GTKStockIcon stockIcon = null;\n-        synchronized (ICONS_MAP) {\n-            stockIcon = ICONS_MAP.get(key);\n-        }\n-\n+        GTKStockIcon stockIcon = ICONS_MAP.get(key);\n@@ -1189,7 +1178,7 @@\n-        ICONS_MAP = new HashMap<String, GTKStockIcon>();\n-        ICONS_MAP.put(\"FileChooser.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n-        ICONS_MAP.put(\"FileChooser.okIcon\",     new GTKStockIcon(\"gtk-ok\",     4));\n-        ICONS_MAP.put(\"OptionPane.yesIcon\", new GTKStockIcon(\"gtk-yes\", 4));\n-        ICONS_MAP.put(\"OptionPane.noIcon\", new GTKStockIcon(\"gtk-no\", 4));\n-        ICONS_MAP.put(\"OptionPane.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n-        ICONS_MAP.put(\"OptionPane.okIcon\", new GTKStockIcon(\"gtk-ok\", 4));\n+        Map<String,GTKStockIcon> iconsMap = new HashMap<>();\n+        iconsMap.put(\"FileChooser.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n+        iconsMap.put(\"FileChooser.okIcon\",     new GTKStockIcon(\"gtk-ok\",     4));\n+        iconsMap.put(\"OptionPane.yesIcon\", new GTKStockIcon(\"gtk-yes\", 4));\n+        iconsMap.put(\"OptionPane.noIcon\", new GTKStockIcon(\"gtk-no\", 4));\n+        iconsMap.put(\"OptionPane.cancelIcon\", new GTKStockIcon(\"gtk-cancel\", 4));\n+        iconsMap.put(\"OptionPane.okIcon\", new GTKStockIcon(\"gtk-ok\", 4));\n@@ -1201,4 +1190,4 @@\n-            ICONS_MAP.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"dialog-error\", 6));\n-            ICONS_MAP.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"dialog-information\", 6));\n-            ICONS_MAP.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"dialog-warning\", 6));\n-            ICONS_MAP.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"dialog-question\", 6));\n+            iconsMap.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"dialog-error\", 6));\n+            iconsMap.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"dialog-information\", 6));\n+            iconsMap.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"dialog-warning\", 6));\n+            iconsMap.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"dialog-question\", 6));\n@@ -1206,4 +1195,4 @@\n-            ICONS_MAP.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"gtk-dialog-error\", 6));\n-            ICONS_MAP.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"gtk-dialog-info\", 6));\n-            ICONS_MAP.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"gtk-dialog-warning\", 6));\n-            ICONS_MAP.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"gtk-dialog-question\", 6));\n+            iconsMap.put(\"OptionPane.errorIcon\", new GTKStockIcon(\"gtk-dialog-error\", 6));\n+            iconsMap.put(\"OptionPane.informationIcon\", new GTKStockIcon(\"gtk-dialog-info\", 6));\n+            iconsMap.put(\"OptionPane.warningIcon\", new GTKStockIcon(\"gtk-dialog-warning\", 6));\n+            iconsMap.put(\"OptionPane.questionIcon\", new GTKStockIcon(\"gtk-dialog-question\", 6));\n@@ -1211,0 +1200,1 @@\n+        ICONS_MAP = Collections.unmodifiableMap(iconsMap);\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/java\/swing\/plaf\/gtk\/GTKStyle.java","additions":19,"deletions":29,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -77,1 +77,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/com\/sun\/media\/sound\/Platform.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -124,1 +124,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/SplashScreen.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1378,1 +1378,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/Toolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/event\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/java\/awt\/image\/ColorModel.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-import javax.swing.event.*;\n+import javax.swing.event.ChangeListener;\n@@ -43,1 +43,1 @@\n- * must greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n+ * must be greater than or equal to <code>minimum<\/code>, and <code>maximum<\/code>\n@@ -231,1 +231,1 @@\n-     * This method sets all of the model's data with a single method call.\n+     * This method sets all the model's data with a single method call.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/BoundedRangeModel.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -886,0 +886,5 @@\n+        if (parentComponent != null) {\n+            parentComponent.revalidate();\n+            parentComponent.repaint();\n+        }\n+\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/JOptionPane.java","additions":6,"deletions":1,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -730,0 +730,2 @@\n+            \/\/ The above margin has vastly larger horizontal values when\n+            \/\/ compared to other look and feels that don't rely on these values\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicLookAndFeel.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import javax.swing.JFrame;\n@@ -1611,0 +1612,19 @@\n+            \/\/ If frame is disabled and timer is started in mousePressed\n+            \/\/ and mouseReleased is not called, then timer will not be stopped\n+            \/\/ Stop the timer if frame is disabled\n+            Component parent = scrollbar.getParent();\n+            do {\n+                if (parent instanceof JFrame par) {\n+                    if (!par.isEnabled()) {\n+                        ((Timer)e.getSource()).stop();\n+                        buttonListener.handledEvent = false;\n+                        scrollbar.setValueIsAdjusting(false);\n+                        return;\n+                    }\n+                    break;\n+                } else {\n+                    if (parent != null) {\n+                        parent = parent.getParent();\n+                    }\n+                }\n+            } while (parent != null);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicScrollBarUI.java","additions":21,"deletions":1,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1997, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1997, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -397,1 +397,4 @@\n-     * divider is contained in changes. Will create the\n+     * divider is contained in changes.\n+     * If a particular L&amp;F supports this Swing\n+     * \"SplitPane.supportsOneTouchButtons\" property\n+     * it will create the\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/basic\/BasicSplitPaneDivider.java","additions":5,"deletions":2,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,7 @@\n-import java.awt.*;\n+import java.awt.Color;\n+import java.awt.Component;\n+import java.awt.Container;\n+import java.awt.Frame;\n+import java.awt.Insets;\n+import java.awt.Toolkit;\n+import java.awt.Window;\n@@ -31,6 +37,0 @@\n-import javax.swing.plaf.*;\n-import javax.swing.*;\n-import javax.swing.plaf.basic.*;\n-import javax.swing.text.DefaultEditorKit;\n-\n-import java.awt.Color;\n@@ -39,1 +39,0 @@\n-\n@@ -42,1 +41,27 @@\n-import sun.awt.*;\n+import javax.swing.ButtonModel;\n+import javax.swing.DefaultButtonModel;\n+import javax.swing.Icon;\n+import javax.swing.ImageIcon;\n+import javax.swing.JComponent;\n+import javax.swing.JDialog;\n+import javax.swing.JFrame;\n+import javax.swing.JRootPane;\n+import javax.swing.JTextField;\n+import javax.swing.JToggleButton;\n+import javax.swing.LayoutStyle;\n+import javax.swing.LookAndFeel;\n+import javax.swing.SwingConstants;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIDefaults;\n+import javax.swing.UIManager;\n+import javax.swing.plaf.BorderUIResource;\n+import javax.swing.plaf.ColorUIResource;\n+import javax.swing.plaf.FontUIResource;\n+import javax.swing.plaf.InsetsUIResource;\n+import javax.swing.plaf.UIResource;\n+import javax.swing.plaf.basic.BasicLookAndFeel;\n+import javax.swing.text.DefaultEditorKit;\n+\n+import sun.awt.AppContext;\n+import sun.awt.OSInfo;\n+import sun.awt.SunToolkit;\n@@ -45,2 +70,0 @@\n-import static javax.swing.UIDefaults.LazyValue;\n-\n@@ -50,0 +73,2 @@\n+import static javax.swing.UIDefaults.LazyValue;\n+\n@@ -785,0 +810,2 @@\n+            \/\/ Button default margin is (2, 14, 2, 14), defined in\n+            \/\/ BasicLookAndFeel via \"Button.margin\" UI property.\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/metal\/MetalLookAndFeel.java","additions":39,"deletions":12,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -2101,18 +2101,21 @@\n-        if (orientation == JTabbedPane.LEFT) {\n-            AffineTransform transform = new AffineTransform();\n-            transform.scale(-1, 1);\n-            transform.rotate(Math.toRadians(90));\n-            paintBackground(context, g, y, x, h, w, transform);\n-        } else if (orientation == JTabbedPane.RIGHT) {\n-            AffineTransform transform = new AffineTransform();\n-            transform.rotate(Math.toRadians(90));\n-            transform.translate(0, -(x + w));\n-            paintBackground(context, g, y, 0, h, w, transform);\n-        } else if (orientation == JTabbedPane.BOTTOM) {\n-            AffineTransform transform = new AffineTransform();\n-            transform.translate(x,y);\n-            transform.scale(1, -1);\n-            transform.translate(0,-h);\n-            paintBackground(context, g, 0, 0, w, h, transform);\n-        } else {\n-            paintBackground(context, g, x, y, w, h, null);\n+        JTabbedPane pane = (JTabbedPane)context.getComponent();\n+        if (UIManager.getBoolean(\"TabbedPane.tabsOpaque\") || pane.isOpaque()) {\n+            if (orientation == JTabbedPane.LEFT) {\n+                AffineTransform transform = new AffineTransform();\n+                transform.scale(-1, 1);\n+                transform.rotate(Math.toRadians(90));\n+                paintBackground(context, g, y, x, h, w, transform);\n+            } else if (orientation == JTabbedPane.RIGHT) {\n+                AffineTransform transform = new AffineTransform();\n+                transform.rotate(Math.toRadians(90));\n+                transform.translate(0, -(x + w));\n+                paintBackground(context, g, y, 0, h, w, transform);\n+            } else if (orientation == JTabbedPane.BOTTOM) {\n+                AffineTransform transform = new AffineTransform();\n+                transform.translate(x, y);\n+                transform.scale(1, -1);\n+                transform.translate(0, -h);\n+                paintBackground(context, g, 0, 0, w, h, transform);\n+            } else {\n+                paintBackground(context, g, x, y, w, h, null);\n+            }\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/nimbus\/SynthPainterImpl.java","additions":21,"deletions":18,"binary":false,"changes":39,"status":"modified"},{"patch":"@@ -130,1 +130,0 @@\n-    private boolean tabsOpaque = true;\n@@ -159,1 +158,0 @@\n-        tabsOpaque = UIManager.getBoolean(\"TabbedPane.tabsOpaque\");\n@@ -658,4 +656,2 @@\n-        if (tabsOpaque || tabPane.isOpaque()) {\n-            tabContext.getPainter().paintTabbedPaneTabBackground(tabContext, g,\n-                    x, y, width, height, tabIndex, placement);\n-        }\n+        tabContext.getPainter().paintTabbedPaneTabBackground(tabContext, g,\n+                x, y, width, height, tabIndex, placement);\n","filename":"src\/java.desktop\/share\/classes\/javax\/swing\/plaf\/synth\/SynthTabbedPaneUI.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -54,1 +54,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/ImagingLib.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -45,1 +45,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/JPEGImageDecoder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -55,1 +55,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/awt\/image\/NativeLibLoader.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/font\/FontManagerNativeLibrary.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/Disposer.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -146,1 +146,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/cmm\/lcms\/LCMS.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,4 @@\n-import jdk.internal.misc.Unsafe;\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.lang.foreign.ValueLayout;\n+import static java.lang.foreign.ValueLayout.*;\n@@ -32,1 +35,1 @@\n- * The RenderBuffer class is a simplified, high-performance, Unsafe wrapper\n+ * The RenderBuffer class is a simplified, high-performance class\n@@ -34,1 +37,1 @@\n- * environment.  It's functionality is similar to the ByteBuffer and related\n+ * environment.  Its functionality is similar to the ByteBuffer and related\n@@ -41,0 +44,1 @@\n+ * Failure to do so will result in exceptions from the FFM API, or worse.\n@@ -46,1 +50,1 @@\n-public class RenderBuffer {\n+public final class RenderBuffer {\n@@ -51,6 +55,6 @@\n-    protected static final long SIZEOF_BYTE   = 1L;\n-    protected static final long SIZEOF_SHORT  = 2L;\n-    protected static final long SIZEOF_INT    = 4L;\n-    protected static final long SIZEOF_FLOAT  = 4L;\n-    protected static final long SIZEOF_LONG   = 8L;\n-    protected static final long SIZEOF_DOUBLE = 8L;\n+    private static final int SIZEOF_BYTE   = Byte.BYTES;\n+    private static final int SIZEOF_SHORT  = Short.BYTES;\n+    private static final int SIZEOF_INT    = Integer.BYTES;\n+    private static final int SIZEOF_FLOAT  = Float.BYTES;\n+    private static final int SIZEOF_LONG   = Long.BYTES;\n+    private static final int SIZEOF_DOUBLE = Double.BYTES;\n@@ -59,7 +63,4 @@\n-     * Represents the number of elements at which we have empirically\n-     * determined that the average cost of a JNI call exceeds the expense\n-     * of an element by element copy.  In other words, if the number of\n-     * elements in an array to be copied exceeds this value, then we should\n-     * use the copyFromArray() method to complete the bulk put operation.\n-     * (This value can be adjusted if the cost of JNI downcalls is reduced\n-     * in a future release.)\n+     * Measurements show that using the copy API from a segment backed by a heap\n+     * array gets reliably faster than individual puts around a length of 10.\n+     * However the time is miniscule in the context of what it is used for\n+     * and much more than adequate, so no problem expected if this changes over time.\n@@ -67,13 +68,8 @@\n-    private static final int COPY_FROM_ARRAY_THRESHOLD = 6;\n-\n-    protected final Unsafe unsafe;\n-    protected final long baseAddress;\n-    protected final long endAddress;\n-    protected long curAddress;\n-    protected final int capacity;\n-\n-    protected RenderBuffer(int numBytes) {\n-        unsafe = Unsafe.getUnsafe();\n-        curAddress = baseAddress = unsafe.allocateMemory(numBytes);\n-        endAddress = baseAddress + numBytes;\n-        capacity = numBytes;\n+    private static final int COPY_FROM_ARRAY_THRESHOLD = 10;\n+\n+    private final MemorySegment segment;\n+    private int curOffset;\n+\n+    private RenderBuffer(int numBytes) {\n+        segment = Arena.global().allocate(numBytes, SIZEOF_DOUBLE);\n+        curOffset = 0;\n@@ -93,1 +89,1 @@\n-        return baseAddress;\n+        return segment.address();\n@@ -102,1 +98,1 @@\n-        return capacity;\n+        return (int)segment.byteSize();\n@@ -106,1 +102,1 @@\n-        return (int)(endAddress - curAddress);\n+        return (capacity() - curOffset);\n@@ -110,1 +106,1 @@\n-        return (int)(curAddress - baseAddress);\n+        return curOffset;\n@@ -113,2 +109,2 @@\n-    public final void position(long numBytes) {\n-        curAddress = baseAddress + numBytes;\n+    public final void position(int bytePos) {\n+        curOffset = bytePos;\n@@ -118,1 +114,1 @@\n-        curAddress = baseAddress;\n+        curOffset = 0;\n@@ -121,2 +117,2 @@\n-    public final RenderBuffer skip(long numBytes) {\n-        curAddress += numBytes;\n+    public final RenderBuffer skip(int numBytes) {\n+        curOffset += numBytes;\n@@ -131,2 +127,2 @@\n-        unsafe.putByte(curAddress, x);\n-        curAddress += SIZEOF_BYTE;\n+        segment.set(JAVA_BYTE, curOffset, x);\n+        curOffset += SIZEOF_BYTE;\n@@ -142,4 +138,2 @@\n-            long offsetInBytes = offset * SIZEOF_BYTE + Unsafe.ARRAY_BYTE_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_BYTE;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_BYTE, curOffset, length);\n+            position(position() + length * SIZEOF_BYTE);\n@@ -161,2 +155,2 @@\n-        unsafe.putShort(curAddress, x);\n-        curAddress += SIZEOF_SHORT;\n+        segment.set(JAVA_SHORT, curOffset, x);\n+        curOffset += SIZEOF_SHORT;\n@@ -173,4 +167,2 @@\n-            long offsetInBytes = offset * SIZEOF_SHORT + Unsafe.ARRAY_SHORT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_SHORT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_SHORT, curOffset, length);\n+            position(position() + length * SIZEOF_SHORT);\n@@ -191,2 +183,2 @@\n-        \/\/ assert (baseAddress + pos % SIZEOF_INT == 0);\n-        unsafe.putInt(baseAddress + pos, x);\n+        \/\/ assert (getAddress() + pos % SIZEOF_INT == 0);\n+        segment.set(JAVA_INT, pos, x);\n@@ -198,2 +190,2 @@\n-        unsafe.putInt(curAddress, x);\n-        curAddress += SIZEOF_INT;\n+        segment.set(JAVA_INT, curOffset, x);\n+        curOffset += SIZEOF_INT;\n@@ -210,4 +202,2 @@\n-            long offsetInBytes = offset * SIZEOF_INT + Unsafe.ARRAY_INT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_INT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_INT, curOffset, length);\n+            position(position() + length * SIZEOF_INT);\n@@ -229,2 +219,2 @@\n-        unsafe.putFloat(curAddress, x);\n-        curAddress += SIZEOF_FLOAT;\n+        segment.set(JAVA_FLOAT, curOffset, x);\n+        curOffset += SIZEOF_FLOAT;\n@@ -241,4 +231,2 @@\n-            long offsetInBytes = offset * SIZEOF_FLOAT + Unsafe.ARRAY_FLOAT_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_FLOAT;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_FLOAT, curOffset, length);\n+            position(position() + length * SIZEOF_FLOAT);\n@@ -260,2 +248,2 @@\n-        unsafe.putLong(curAddress, x);\n-        curAddress += SIZEOF_LONG;\n+        segment.set(JAVA_LONG, curOffset, x);\n+        curOffset += SIZEOF_LONG;\n@@ -272,4 +260,2 @@\n-            long offsetInBytes = offset * SIZEOF_LONG + Unsafe.ARRAY_LONG_BASE_OFFSET;\n-            long lengthInBytes = length * SIZEOF_LONG;\n-            unsafe.copyMemory(x, offsetInBytes, null, curAddress, lengthInBytes);\n-            position(position() + lengthInBytes);\n+            MemorySegment.copy(x, offset, segment, JAVA_LONG, curOffset, length);\n+            position(position() + length * SIZEOF_LONG);\n@@ -291,2 +277,2 @@\n-        unsafe.putDouble(curAddress, x);\n-        curAddress += SIZEOF_DOUBLE;\n+        segment.set(JAVA_DOUBLE, curOffset, x);\n+        curOffset += SIZEOF_DOUBLE;\n","filename":"src\/java.desktop\/share\/classes\/sun\/java2d\/pipe\/RenderBuffer.java","additions":60,"deletions":74,"binary":false,"changes":134,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,5 +29,0 @@\n-#ifdef _MSC_VER\n-# ifndef snprintf\n-#       define snprintf _snprintf\n-# endif\n-#endif\n","filename":"src\/java.desktop\/share\/native\/libsplashscreen\/splashscreen_impl.c","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -73,5 +73,0 @@\n-    private static final String GTK2_DEPRECATION_MESSAGE =\n-            \"WARNING: the GTK 2 library is deprecated and \" +\n-                    \"its support will be removed in a future release\";\n-    private static volatile boolean gtk2WarningIssued = false;\n-\n@@ -81,1 +76,0 @@\n-        GTK2(Constants.GTK2_MAJOR_NUMBER),\n@@ -85,1 +79,0 @@\n-            static final int GTK2_MAJOR_NUMBER = 2;\n@@ -97,2 +90,0 @@\n-                case Constants.GTK2_MAJOR_NUMBER:\n-                    return GTK2;\n@@ -501,9 +492,1 @@\n-        if (version == null) {\n-            return GtkVersions.ANY;\n-        } else if (version.startsWith(\"2\")) {\n-            if (!gtk2WarningIssued) {\n-                System.err.println(GTK2_DEPRECATION_MESSAGE);\n-                gtk2WarningIssued = true;\n-            }\n-            return GtkVersions.GTK2;\n-        } else if(\"3\".equals(version) ){\n+        if (\"3\".equals(version)) {\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/UNIXToolkit.java","additions":1,"deletions":18,"binary":false,"changes":19,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -365,0 +365,3 @@\n+                AffineTransform af = g2.getTransform();\n+                double scaleX = af.getScaleX();\n+                double scaleY = af.getScaleY();\n@@ -369,2 +372,2 @@\n-                AffineTransform af = g2.getTransform();\n-                g2.setTransform(AffineTransform.getTranslateInstance(rx,ry));\n+                g2.setTransform(AffineTransform.getTranslateInstance(rx * scaleX, ry * scaleY));\n+                g2.scale(scaleX, scaleY);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11\/XCheckboxPeer.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -62,1 +62,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/X11GraphicsEnvironment.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -63,1 +63,0 @@\n-@SuppressWarnings(\"removal\")\n@@ -69,0 +68,2 @@\n+            \".java\/robot\/screencast-tokens.properties\";\n+    private static final String REL_NAME_SECONDARY =\n@@ -75,0 +76,1 @@\n+    @SuppressWarnings(\"removal\")\n@@ -76,6 +78,3 @@\n-        AccessController.doPrivileged(new PrivilegedAction<Void>() {\n-            @Override\n-            public Void run() {\n-                runnable.run();\n-                return null;\n-            }\n+        AccessController.doPrivileged((PrivilegedAction<Void>) () -> {\n+            runnable.run();\n+            return null;\n@@ -86,6 +85,5 @@\n-        PROPS_PATH = AccessController.doPrivileged(new PrivilegedAction<Path>() {\n-            @Override\n-            public Path run() {\n-                return setupPath();\n-            }\n-        });\n+        @SuppressWarnings(\"removal\")\n+        Path propsPath = AccessController\n+                .doPrivileged((PrivilegedAction<Path>) () -> setupPath());\n+\n+        PROPS_PATH = propsPath;\n@@ -113,0 +111,5 @@\n+        Path secondaryPath = Path.of(userHome, REL_NAME_SECONDARY);\n+\n+        boolean copyFromSecondary = !Files.isWritable(path)\n+                && Files.isWritable(secondaryPath);\n+\n@@ -115,7 +118,10 @@\n-        if (!Files.exists(workdir)) {\n-            try {\n-                Files.createDirectories(workdir);\n-            } catch (Exception e) {\n-                if (SCREENCAST_DEBUG) {\n-                    System.err.printf(\"Token storage: cannot create\" +\n-                                    \" directory %s %s\\n\", workdir, e);\n+        if (!Files.isWritable(path)) {\n+            if (!Files.exists(workdir)) {\n+                try {\n+                    Files.createDirectories(workdir);\n+                } catch (Exception e) {\n+                    if (SCREENCAST_DEBUG) {\n+                        System.err.printf(\"Token storage: cannot create\" +\n+                                \" directory %s %s\\n\", workdir, e);\n+                    }\n+                    return null;\n@@ -123,1 +129,0 @@\n-                return null;\n@@ -125,1 +130,0 @@\n-        }\n@@ -127,3 +131,5 @@\n-        if (!Files.isWritable(workdir)) {\n-            if (SCREENCAST_DEBUG) {\n-                System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+            if (!Files.isWritable(workdir)) {\n+                if (SCREENCAST_DEBUG) {\n+                    System.err.printf(\"Token storage: %s is not writable\\n\", workdir);\n+                }\n+                return null;\n@@ -131,1 +137,0 @@\n-            return null;\n@@ -148,1 +153,11 @@\n-        if (Files.exists(path)) {\n+        if (copyFromSecondary) {\n+            if (SCREENCAST_DEBUG) {\n+                System.out.println(\"Token storage: copying from the secondary location \"\n+                                        + secondaryPath);\n+            }\n+            synchronized (PROPS) {\n+                if (readTokens(secondaryPath)) {\n+                    store(path, \"copy from the secondary location\");\n+                }\n+            }\n+        } else if (Files.exists(path)) {\n@@ -305,1 +320,1 @@\n-                doPrivilegedRunnable(() -> store(\"save tokens\"));\n+                doPrivilegedRunnable(() -> store(PROPS_PATH, \"save tokens\"));\n@@ -318,1 +333,1 @@\n-        } catch (IOException e) {\n+        } catch (IOException | IllegalArgumentException e) {\n@@ -413,1 +428,1 @@\n-        if (!isWritable()\n+        if (!isWritable(PROPS_PATH)\n@@ -427,1 +442,1 @@\n-            store(\"remove malformed records\");\n+            store(PROPS_PATH, \"remove malformed records\");\n@@ -431,2 +446,2 @@\n-    private static void store(String failMsg) {\n-        if (!isWritable()) {\n+    private static void store(Path path, String failMsg) {\n+        if (!isWritable(path)) {\n@@ -437,1 +452,1 @@\n-            try (BufferedWriter writer = Files.newBufferedWriter(PROPS_PATH)) {\n+            try (BufferedWriter writer = Files.newBufferedWriter(path)) {\n@@ -448,3 +463,3 @@\n-    private static boolean isWritable() {\n-        if (PROPS_PATH == null\n-            || (Files.exists(PROPS_PATH) && !Files.isWritable(PROPS_PATH))) {\n+    private static boolean isWritable(Path path) {\n+        if (path == null\n+            || (Files.exists(path) && !Files.isWritable(path))) {\n@@ -454,1 +469,1 @@\n-                        \"Token storage: %s is not writable\\n\", PROPS_PATH);\n+                        \"Token storage: %s is not writable\\n\", path);\n","filename":"src\/java.desktop\/unix\/classes\/sun\/awt\/screencast\/TokenStorage.java","additions":53,"deletions":38,"binary":false,"changes":91,"status":"modified"},{"patch":"@@ -93,1 +93,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/unix\/classes\/sun\/print\/CUPSPrinter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -205,1 +205,0 @@\n-    int i = 0;\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/CUPSfuncs.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -341,1 +341,1 @@\n-    int i, j, k, cmapsize, nfree, depth, bpp;\n+    int i, k, cmapsize, nfree, depth, bpp;\n@@ -881,1 +881,0 @@\n-    jobject cspaceL;\n@@ -1036,1 +1035,0 @@\n-        jlong pData;\n@@ -1236,5 +1234,4 @@\n-    int i, pixel;\n-    for (i = 0; i < num_colors; i++)\n-        pixel = alloc_col (awt_display, awtData->awt_cmap, red (rgbColors [i]),\n-                           green (rgbColors [i]), blue (rgbColors [i]), -1,\n-                           awtData);\n+    for (int i = 0; i < num_colors; i++)\n+        alloc_col (awt_display, awtData->awt_cmap, red (rgbColors [i]),\n+                   green (rgbColors [i]), blue (rgbColors [i]), -1,\n+                   awtData);\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/X11Color.c","additions":5,"deletions":8,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -103,1 +103,0 @@\n-    jboolean ret;\n@@ -137,1 +136,1 @@\n-    int i, pos, slen, nPaths, numDirs;\n+    int i, pos, slen, nPaths;\n@@ -536,1 +535,0 @@\n-    FcInitLoadConfigFuncType FcInitLoadConfig;\n@@ -546,1 +544,0 @@\n-    FcConfig *fontconfig;\n@@ -550,4 +547,1 @@\n-    FcStrList *strList;\n-    FcChar8 *str;\n-    int i, f, found, len=0;\n-    char **fontPath;\n+    int i, f, found;\n","filename":"src\/java.desktop\/unix\/native\/common\/awt\/fontpath.c","additions":2,"deletions":8,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,2 +46,0 @@\n-static Atom psAtom = 0;\n-static Atom fullNameAtom = 0;\n@@ -130,1 +128,0 @@\n-    JNIEnv *env;\n@@ -133,0 +130,1 @@\n+    JNIEnv *env;\n@@ -271,1 +269,1 @@\n-    unsigned char *srcRow, *dstRow, *dstByte;\n+    unsigned char *srcRow, *dstRow;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11FontScaler_md.c","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -574,1 +574,0 @@\n-    jobject pointArray;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11Renderer.c","additions":0,"deletions":1,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -885,1 +885,1 @@\n-        int x, y, w, h;\n+        int x, y;\n@@ -888,2 +888,0 @@\n-        w = pRasInfo->bounds.x2 - x;\n-        h = pRasInfo->bounds.y2 - y;\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11SurfaceData.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -216,1 +216,1 @@\n-    int scan, screen;\n+    int screen;\n@@ -239,2 +239,0 @@\n-    scan = theImage->bytes_per_line;\n-\n","filename":"src\/java.desktop\/unix\/native\/common\/java2d\/x11\/X11TextRenderer_md.c","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -119,7 +119,1 @@\n-#ifndef STATIC_BUILD\n-    \/* Get address of this library and the directory containing it. *\/\n-    dladdr((void *)AWT_OnLoad, &dlinfo);\n-    realpath((char *)dlinfo.dli_fname, buf);\n-    len = strlen(buf);\n-    p = strrchr(buf, '\/');\n-#endif\n+\n@@ -132,1 +126,1 @@\n-        tk = LWAWT_PATH;\n+    tk = LWAWT_PATH;\n@@ -134,2 +128,1 @@\n-        tk = XAWT_PATH;\n-#endif\n+    tk = XAWT_PATH;\n@@ -137,1 +130,0 @@\n-#ifndef MACOSX\n@@ -143,4 +135,6 @@\n-#ifndef STATIC_BUILD\n-    \/* Calculate library name to load *\/\n-    strncpy(p, tk, MAXPATHLEN-len-1);\n-#endif\n+    if (!JVM_IsStaticallyLinked()) {\n+        \/* Get address of this library and the directory containing it. *\/\n+        dladdr((void *)AWT_OnLoad, &dlinfo);\n+        realpath((char *)dlinfo.dli_fname, buf);\n+        len = strlen(buf);\n+        p = strrchr(buf, '\/');\n@@ -148,6 +142,11 @@\n-#ifndef STATIC_BUILD\n-    jstring jbuf = JNU_NewStringPlatform(env, buf);\n-    CHECK_EXCEPTION_FATAL(env, \"Could not allocate library name\");\n-    JNU_CallStaticMethodByName(env, NULL, \"java\/lang\/System\", \"load\",\n-                               \"(Ljava\/lang\/String;)V\",\n-                               jbuf);\n+        \/* Calculate library name to load *\/\n+        strncpy(p, tk, MAXPATHLEN-len-1);\n+\n+        jstring jbuf = JNU_NewStringPlatform(env, buf);\n+        CHECK_EXCEPTION_FATAL(env, \"Could not allocate library name\");\n+        JNU_CallStaticMethodByName(env, NULL, \"java\/lang\/System\", \"load\",\n+                                   \"(Ljava\/lang\/String;)V\",\n+                                   jbuf);\n+\n+        awtHandle = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n+    }\n@@ -155,2 +154,0 @@\n-    awtHandle = dlopen(buf, RTLD_LAZY | RTLD_GLOBAL);\n-#endif\n","filename":"src\/java.desktop\/unix\/native\/libawt\/awt\/awt_LoadLibrary.c","additions":21,"deletions":24,"binary":false,"changes":45,"status":"modified"},{"patch":"@@ -307,1 +307,0 @@\n-    char errmsg[128];\n@@ -725,1 +724,0 @@\n-    int i;\n@@ -875,1 +873,0 @@\n-    int a, b, c;\n@@ -1157,1 +1154,1 @@\n-    int i, n;\n+    int i;\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/awt_GraphicsEnv.c","additions":1,"deletions":4,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -1,2603 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef HEADLESS\n-    #error This file should not be included in headless library\n-#endif\n-\n-#include <dlfcn.h>\n-#include <setjmp.h>\n-#include <X11\/Xlib.h>\n-#include <limits.h>\n-#include <stdio.h>\n-#include <string.h>\n-#include \"gtk2_interface.h\"\n-#include \"java_awt_Transparency.h\"\n-#include \"jvm_md.h\"\n-#include \"sizecalc.h\"\n-#include <jni_util.h>\n-#include \"awt.h\"\n-\n-#define GTK_TYPE_BORDER                 ((*fp_gtk_border_get_type)())\n-\n-#define G_TYPE_FUNDAMENTAL_SHIFT        (2)\n-#define G_TYPE_MAKE_FUNDAMENTAL(x)      ((GType) ((x) << G_TYPE_FUNDAMENTAL_SHIFT))\n-\n-#define CONV_BUFFER_SIZE 128\n-\n-#define NO_SYMBOL_EXCEPTION 1\n-\n-static void *gtk2_libhandle = NULL;\n-static void *gthread_libhandle = NULL;\n-\n-static jmp_buf j;\n-\n-\/* Widgets *\/\n-static GtkWidget *gtk2_widget = NULL;\n-static GtkWidget *gtk2_window = NULL;\n-static GtkFixed  *gtk2_fixed  = NULL;\n-\n-\/* Paint system *\/\n-static GdkPixmap *gtk2_white_pixmap = NULL;\n-static GdkPixmap *gtk2_black_pixmap = NULL;\n-static GdkPixbuf *gtk2_white_pixbuf = NULL;\n-static GdkPixbuf *gtk2_black_pixbuf = NULL;\n-static int gtk2_pixbuf_width = 0;\n-static int gtk2_pixbuf_height = 0;\n-\n-\/* Static buffer for conversion from java.lang.String to UTF-8 *\/\n-static char convertionBuffer[CONV_BUFFER_SIZE];\n-\n-static gboolean new_combo = TRUE;\n-const char ENV_PREFIX[] = \"GTK_MODULES=\";\n-\n-\n-static GtkWidget *gtk2_widgets[_GTK_WIDGET_TYPE_SIZE];\n-\n-\/*************************\n- * Glib function pointers\n- *************************\/\n-\n-static gboolean (*fp_g_main_context_iteration)(GMainContext *context,\n-                                             gboolean may_block);\n-\n-static GValue*      (*fp_g_value_init)(GValue *value, GType g_type);\n-static gboolean     (*fp_g_type_is_a)(GType type, GType is_a_type);\n-static gboolean     (*fp_g_value_get_boolean)(const GValue *value);\n-static gchar        (*fp_g_value_get_char)(const GValue *value);\n-static guchar       (*fp_g_value_get_uchar)(const GValue *value);\n-static gint         (*fp_g_value_get_int)(const GValue *value);\n-static guint        (*fp_g_value_get_uint)(const GValue *value);\n-static glong        (*fp_g_value_get_long)(const GValue *value);\n-static gulong       (*fp_g_value_get_ulong)(const GValue *value);\n-static gint64       (*fp_g_value_get_int64)(const GValue *value);\n-static guint64      (*fp_g_value_get_uint64)(const GValue *value);\n-static gfloat       (*fp_g_value_get_float)(const GValue *value);\n-static gdouble      (*fp_g_value_get_double)(const GValue *value);\n-static const gchar* (*fp_g_value_get_string)(const GValue *value);\n-static gint         (*fp_g_value_get_enum)(const GValue *value);\n-static guint        (*fp_g_value_get_flags)(const GValue *value);\n-static GParamSpec*  (*fp_g_value_get_param)(const GValue *value);\n-static gpointer*    (*fp_g_value_get_boxed)(const GValue *value);\n-static gpointer*    (*fp_g_value_get_pointer)(const GValue *value);\n-static GObject*     (*fp_g_value_get_object)(const GValue *value);\n-static GParamSpec*  (*fp_g_param_spec_int)(const gchar *name,\n-        const gchar *nick, const gchar *blurb,\n-        gint minimum, gint maximum, gint default_value,\n-        GParamFlags flags);\n-static void         (*fp_g_object_get)(gpointer object,\n-                                       const gchar* fpn, ...);\n-static void         (*fp_g_object_set)(gpointer object,\n-                                       const gchar *first_property_name,\n-                                       ...);\n-\/************************\n- * GDK function pointers\n- ************************\/\n-static GdkPixmap *(*fp_gdk_pixmap_new)(GdkDrawable *drawable,\n-        gint width, gint height, gint depth);\n-static GdkGC *(*fp_gdk_gc_new)(GdkDrawable*);\n-static void (*fp_gdk_rgb_gc_set_foreground)(GdkGC*, guint32);\n-static void (*fp_gdk_draw_rectangle)(GdkDrawable*, GdkGC*, gboolean,\n-        gint, gint, gint, gint);\n-static GdkPixbuf *(*fp_gdk_pixbuf_new)(GdkColorspace colorspace,\n-        gboolean has_alpha, int bits_per_sample, int width, int height);\n-static void (*fp_gdk_drawable_get_size)(GdkDrawable *drawable,\n-        gint* width, gint* height);\n-\n-\/************************\n- * Gtk function pointers\n- ************************\/\n-static gboolean (*fp_gtk_init_check)(int* argc, char** argv);\n-\n-\/* Painting *\/\n-static void (*fp_gtk_paint_hline)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint x1, gint x2, gint y);\n-static void (*fp_gtk_paint_vline)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint y1, gint y2, gint x);\n-static void (*fp_gtk_paint_shadow)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_arrow)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        GtkArrowType arrow_type, gboolean fill, gint x, gint y,\n-        gint width, gint height);\n-static void (*fp_gtk_paint_box)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_flat_box)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_check)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_option)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_box_gap)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height,\n-        GtkPositionType gap_side, gint gap_x, gint gap_width);\n-static void (*fp_gtk_paint_extension)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height, GtkPositionType gap_side);\n-static void (*fp_gtk_paint_focus)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint x, gint y, gint width, gint height);\n-static void (*fp_gtk_paint_slider)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation);\n-static void (*fp_gtk_paint_handle)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GtkShadowType shadow_type,\n-        GdkRectangle* area, GtkWidget* widget, const gchar* detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation);\n-static void (*fp_gtk_paint_expander)(GtkStyle* style, GdkWindow* window,\n-        GtkStateType state_type, GdkRectangle* area, GtkWidget* widget,\n-        const gchar* detail, gint x, gint y, GtkExpanderStyle expander_style);\n-static void (*fp_gtk_style_apply_default_background)(GtkStyle* style,\n-        GdkWindow* window, gboolean set_bg, GtkStateType state_type,\n-        GdkRectangle* area, gint x, gint y, gint width, gint height);\n-\n-\/* Widget creation *\/\n-static GtkWidget* (*fp_gtk_arrow_new)(GtkArrowType arrow_type,\n-                                      GtkShadowType shadow_type);\n-static GtkWidget* (*fp_gtk_button_new)();\n-static GtkWidget* (*fp_gtk_check_button_new)();\n-static GtkWidget* (*fp_gtk_check_menu_item_new)();\n-static GtkWidget* (*fp_gtk_color_selection_dialog_new)(const gchar* title);\n-static GtkWidget* (*fp_gtk_combo_box_new)();\n-static GtkWidget* (*fp_gtk_combo_box_entry_new)();\n-static GtkWidget* (*fp_gtk_entry_new)();\n-static GtkWidget* (*fp_gtk_fixed_new)();\n-static GtkWidget* (*fp_gtk_handle_box_new)();\n-static GtkWidget* (*fp_gtk_hpaned_new)();\n-static GtkWidget* (*fp_gtk_vpaned_new)();\n-static GtkWidget* (*fp_gtk_hscale_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_vscale_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_hscrollbar_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_vscrollbar_new)(GtkAdjustment* adjustment);\n-static GtkWidget* (*fp_gtk_hseparator_new)();\n-static GtkWidget* (*fp_gtk_vseparator_new)();\n-static GtkWidget* (*fp_gtk_image_new)();\n-static GtkWidget* (*fp_gtk_label_new)(const gchar* str);\n-static GtkWidget* (*fp_gtk_menu_new)();\n-static GtkWidget* (*fp_gtk_menu_bar_new)();\n-static GtkWidget* (*fp_gtk_menu_item_new)();\n-static GtkWidget* (*fp_gtk_notebook_new)();\n-static GtkWidget* (*fp_gtk_progress_bar_new)();\n-static GtkWidget* (*fp_gtk_progress_bar_set_orientation)(\n-        GtkProgressBar *pbar,\n-        GtkProgressBarOrientation orientation);\n-static GtkWidget* (*fp_gtk_radio_button_new)(GSList *group);\n-static GtkWidget* (*fp_gtk_radio_menu_item_new)(GSList *group);\n-static GtkWidget* (*fp_gtk_scrolled_window_new)(GtkAdjustment *hadjustment,\n-        GtkAdjustment *vadjustment);\n-static GtkWidget* (*fp_gtk_separator_menu_item_new)();\n-static GtkWidget* (*fp_gtk_separator_tool_item_new)();\n-static GtkWidget* (*fp_gtk_text_view_new)();\n-static GtkWidget* (*fp_gtk_toggle_button_new)();\n-static GtkWidget* (*fp_gtk_toolbar_new)();\n-static GtkWidget* (*fp_gtk_tree_view_new)();\n-static GtkWidget* (*fp_gtk_viewport_new)(GtkAdjustment *hadjustment,\n-        GtkAdjustment *vadjustment);\n-static GtkWidget* (*fp_gtk_window_new)(GtkWindowType type);\n-static GtkWidget* (*fp_gtk_dialog_new)();\n-static GtkWidget* (*fp_gtk_spin_button_new)(GtkAdjustment *adjustment,\n-        gdouble climb_rate, guint digits);\n-static GtkWidget* (*fp_gtk_frame_new)(const gchar *label);\n-\n-\/* Other widget operations *\/\n-static GtkObject* (*fp_gtk_adjustment_new)(gdouble value,\n-        gdouble lower, gdouble upper, gdouble step_increment,\n-        gdouble page_increment, gdouble page_size);\n-static void (*fp_gtk_container_add)(GtkContainer *window, GtkWidget *widget);\n-static void (*fp_gtk_menu_shell_append)(GtkMenuShell *menu_shell,\n-        GtkWidget *child);\n-static void (*fp_gtk_menu_item_set_submenu)(GtkMenuItem *menu_item,\n-        GtkWidget *submenu);\n-static void (*fp_gtk_widget_realize)(GtkWidget *widget);\n-static GdkPixbuf* (*fp_gtk_widget_render_icon)(GtkWidget *widget,\n-        const gchar *stock_id, GtkIconSize size, const gchar *detail);\n-static void (*fp_gtk_widget_set_name)(GtkWidget *widget, const gchar *name);\n-static void (*fp_gtk_widget_set_parent)(GtkWidget *widget, GtkWidget *parent);\n-static void (*fp_gtk_widget_set_direction)(GtkWidget *widget,\n-        GtkTextDirection direction);\n-static void (*fp_gtk_widget_style_get)(GtkWidget *widget,\n-        const gchar *first_property_name, ...);\n-static void (*fp_gtk_widget_class_install_style_property)(\n-        GtkWidgetClass* class, GParamSpec *pspec);\n-static GParamSpec* (*fp_gtk_widget_class_find_style_property)(\n-        GtkWidgetClass* class, const gchar* property_name);\n-static void (*fp_gtk_widget_style_get_property)(GtkWidget* widget,\n-        const gchar* property_name, GValue* value);\n-static char* (*fp_pango_font_description_to_string)(\n-        const PangoFontDescription* fd);\n-static GtkSettings* (*fp_gtk_settings_get_default)();\n-static GtkSettings* (*fp_gtk_widget_get_settings)(GtkWidget *widget);\n-static GType        (*fp_gtk_border_get_type)();\n-static void (*fp_gtk_arrow_set)(GtkWidget* arrow,\n-                                GtkArrowType arrow_type,\n-                                GtkShadowType shadow_type);\n-static void (*fp_gtk_widget_size_request)(GtkWidget *widget,\n-                                          GtkRequisition *requisition);\n-static GtkAdjustment* (*fp_gtk_range_get_adjustment)(GtkRange* range);\n-\n-\/* Method bodies *\/\n-\n-static void throw_exception(JNIEnv *env, const char* name, const char* message)\n-{\n-    jclass class = (*env)->FindClass(env, name);\n-\n-    if (class != NULL)\n-        (*env)->ThrowNew(env, class, message);\n-\n-    (*env)->DeleteLocalRef(env, class);\n-}\n-\n-\/* This is a workaround for the bug:\n- * http:\/\/sourceware.org\/bugzilla\/show_bug.cgi?id=1814\n- * (dlsym\/dlopen clears dlerror state)\n- * This bug is specific to Linux, but there is no harm in\n- * applying this workaround on Solaris as well.\n- *\/\n-static void* dl_symbol(const char* name)\n-{\n-    void* result = dlsym(gtk2_libhandle, name);\n-    if (!result)\n-        longjmp(j, NO_SYMBOL_EXCEPTION);\n-\n-    return result;\n-}\n-\n-static void* dl_symbol_gthread(const char* name)\n-{\n-    void* result = dlsym(gthread_libhandle, name);\n-    if (!result)\n-        longjmp(j, NO_SYMBOL_EXCEPTION);\n-\n-    return result;\n-}\n-\n-gboolean gtk2_check(const char* lib_name, gboolean load)\n-{\n-    if (gtk2_libhandle != NULL) {\n-        \/* We've already successfully opened the GTK libs, so return true. *\/\n-        return TRUE;\n-    } else {\n-        void *lib = NULL;\n-\n-#ifdef RTLD_NOLOAD\n-        \/* Just check if gtk libs are already in the process space *\/\n-        lib = dlopen(lib_name, RTLD_LAZY | RTLD_NOLOAD);\n-        if (!load || lib != NULL) {\n-            return lib != NULL;\n-        }\n-#else\n-#ifdef _AIX\n-        \/* On AIX we could implement this with the help of loadquery(L_GETINFO, ..)  *\/\n-        \/* (see reload_table() in hotspot\/src\/os\/aix\/vm\/loadlib_aix.cpp) but it is   *\/\n-        \/* probably not worth it because most AIX servers don't have GTK libs anyway *\/\n-#endif\n-#endif\n-\n-        lib = dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL);\n-        if (lib == NULL) {\n-            return FALSE;\n-        }\n-\n-        fp_gtk_check_version = dlsym(lib, \"gtk_check_version\");\n-        \/* Check for GTK 2.2+ *\/\n-        if (!fp_gtk_check_version(2, 2, 0)) {\n-            return TRUE;\n-        }\n-\n-        \/\/ 8048289: workaround for https:\/\/bugzilla.gnome.org\/show_bug.cgi?id=733065\n-        \/\/ dlclose(lib);\n-\n-        return FALSE;\n-    }\n-}\n-\n-#define ADD_SUPPORTED_ACTION(actionStr) \\\n-do { \\\n-    jfieldID fld_action = (*env)->GetStaticFieldID(env, cls_action, actionStr, \"Ljava\/awt\/Desktop$Action;\"); \\\n-    if (!(*env)->ExceptionCheck(env)) { \\\n-        jobject action = (*env)->GetStaticObjectField(env, cls_action, fld_action); \\\n-        (*env)->CallBooleanMethod(env, supportedActions, mid_arrayListAdd, action); \\\n-    } else { \\\n-        (*env)->ExceptionClear(env); \\\n-    } \\\n-} while(0);\n-\n-\n-static void update_supported_actions(JNIEnv *env) {\n-    GVfs * (*fp_g_vfs_get_default) (void);\n-    const gchar * const * (*fp_g_vfs_get_supported_uri_schemes) (GVfs * vfs);\n-    const gchar * const * schemes = NULL;\n-\n-    jclass cls_action = (*env)->FindClass(env, \"java\/awt\/Desktop$Action\");\n-    CHECK_NULL(cls_action);\n-    jclass cls_xDesktopPeer = (*env)->FindClass(env, \"sun\/awt\/X11\/XDesktopPeer\");\n-    CHECK_NULL(cls_xDesktopPeer);\n-    jfieldID fld_supportedActions = (*env)->GetStaticFieldID(env, cls_xDesktopPeer, \"supportedActions\", \"Ljava\/util\/List;\");\n-    CHECK_NULL(fld_supportedActions);\n-    jobject supportedActions = (*env)->GetStaticObjectField(env, cls_xDesktopPeer, fld_supportedActions);\n-\n-    jclass cls_arrayList = (*env)->FindClass(env, \"java\/util\/ArrayList\");\n-    CHECK_NULL(cls_arrayList);\n-    jmethodID mid_arrayListAdd = (*env)->GetMethodID(env, cls_arrayList, \"add\", \"(Ljava\/lang\/Object;)Z\");\n-    CHECK_NULL(mid_arrayListAdd);\n-    jmethodID mid_arrayListClear = (*env)->GetMethodID(env, cls_arrayList, \"clear\", \"()V\");\n-    CHECK_NULL(mid_arrayListClear);\n-\n-    (*env)->CallVoidMethod(env, supportedActions, mid_arrayListClear);\n-\n-    ADD_SUPPORTED_ACTION(\"OPEN\");\n-\n-    \/**\n-     * gtk_show_uri() documentation says:\n-     *\n-     * > you need to install gvfs to get support for uri schemes such as http:\/\/\n-     * > or ftp:\/\/, as only local files are handled by GIO itself.\n-     *\n-     * So OPEN action was safely added here.\n-     * However, it looks like Solaris 11 have gvfs support only for 32-bit\n-     * applications only by default.\n-     *\/\n-\n-    fp_g_vfs_get_default = dl_symbol(\"g_vfs_get_default\");\n-    fp_g_vfs_get_supported_uri_schemes = dl_symbol(\"g_vfs_get_supported_uri_schemes\");\n-    dlerror();\n-\n-    if (fp_g_vfs_get_default && fp_g_vfs_get_supported_uri_schemes) {\n-        GVfs * vfs = fp_g_vfs_get_default();\n-        schemes = vfs ? fp_g_vfs_get_supported_uri_schemes(vfs) : NULL;\n-        if (schemes) {\n-            int i = 0;\n-            while (schemes[i]) {\n-                if (strcmp(schemes[i], \"http\") == 0) {\n-                    ADD_SUPPORTED_ACTION(\"BROWSE\");\n-                    ADD_SUPPORTED_ACTION(\"MAIL\");\n-                    break;\n-                }\n-                i++;\n-            }\n-        }\n-    } else {\n-#ifdef DEBUG\n-        fprintf(stderr, \"Cannot load g_vfs_get_supported_uri_schemes\\n\");\n-#endif \/* DEBUG *\/\n-    }\n-\n-}\n-\/**\n- * Functions for awt_Desktop.c\n- *\/\n-static gboolean gtk2_show_uri_load(JNIEnv *env) {\n-     gboolean success = FALSE;\n-     dlerror();\n-     const char *gtk_version = fp_gtk_check_version(2, 14, 0);\n-     if (gtk_version != NULL) {\n-         \/\/ The gtk_show_uri is available from GTK+ 2.14\n-#ifdef DEBUG\n-         fprintf (stderr, \"The version of GTK is %s. \"\n-             \"The gtk_show_uri function is supported \"\n-             \"since GTK+ 2.14.\\n\", gtk_version);\n-#endif \/* DEBUG *\/\n-     } else {\n-         \/\/ Loading symbols only if the GTK version is 2.14 and higher\n-         fp_gtk_show_uri = dl_symbol(\"gtk_show_uri\");\n-         const char *dlsym_error = dlerror();\n-         if (dlsym_error) {\n-#ifdef DEBUG\n-             fprintf (stderr, \"Cannot load symbol: %s \\n\", dlsym_error);\n-#endif \/* DEBUG *\/\n-         } else if (fp_gtk_show_uri == NULL) {\n-#ifdef DEBUG\n-             fprintf(stderr, \"dlsym(gtk_show_uri) returned NULL\\n\");\n-#endif \/* DEBUG *\/\n-        } else {\n-            gtk->gtk_show_uri = fp_gtk_show_uri;\n-            update_supported_actions(env);\n-            success = TRUE;\n-        }\n-     }\n-     return success;\n-}\n-\n-\/**\n- * Functions for sun_awt_X11_GtkFileDialogPeer.c\n- *\/\n-static void gtk2_file_chooser_load()\n-{\n-    fp_gtk_file_chooser_get_filename = dl_symbol(\n-            \"gtk_file_chooser_get_filename\");\n-    fp_gtk_file_chooser_dialog_new = dl_symbol(\"gtk_file_chooser_dialog_new\");\n-    fp_gtk_file_chooser_set_current_folder = dl_symbol(\n-            \"gtk_file_chooser_set_current_folder\");\n-    fp_gtk_file_chooser_set_filename = dl_symbol(\n-            \"gtk_file_chooser_set_filename\");\n-    fp_gtk_file_chooser_set_current_name = dl_symbol(\n-            \"gtk_file_chooser_set_current_name\");\n-    fp_gtk_file_filter_add_custom = dl_symbol(\"gtk_file_filter_add_custom\");\n-    fp_gtk_file_chooser_set_filter = dl_symbol(\"gtk_file_chooser_set_filter\");\n-    fp_gtk_file_chooser_get_type = dl_symbol(\"gtk_file_chooser_get_type\");\n-    fp_gtk_file_filter_new = dl_symbol(\"gtk_file_filter_new\");\n-    if (fp_gtk_check_version(2, 8, 0) == NULL) {\n-        fp_gtk_file_chooser_set_do_overwrite_confirmation = dl_symbol(\n-                \"gtk_file_chooser_set_do_overwrite_confirmation\");\n-    }\n-    fp_gtk_file_chooser_set_select_multiple = dl_symbol(\n-            \"gtk_file_chooser_set_select_multiple\");\n-    fp_gtk_file_chooser_get_current_folder = dl_symbol(\n-            \"gtk_file_chooser_get_current_folder\");\n-    fp_gtk_file_chooser_get_filenames = dl_symbol(\n-            \"gtk_file_chooser_get_filenames\");\n-    fp_gtk_g_slist_length = dl_symbol(\"g_slist_length\");\n-    fp_gdk_x11_drawable_get_xid = dl_symbol(\"gdk_x11_drawable_get_xid\");\n-}\n-\n-GtkApi* gtk2_load(JNIEnv *env, const char* lib_name)\n-{\n-    gboolean result;\n-    int i;\n-    int (*handler)();\n-    int (*io_handler)();\n-    char *gtk_modules_env;\n-\n-    gtk2_libhandle = dlopen(lib_name, RTLD_LAZY | RTLD_LOCAL);\n-    if (gtk2_libhandle == NULL) {\n-        return FALSE;\n-    }\n-\n-    gthread_libhandle = dlopen(GTHREAD_LIB_VERSIONED, RTLD_LAZY | RTLD_LOCAL);\n-    if (gthread_libhandle == NULL) {\n-        gthread_libhandle = dlopen(GTHREAD_LIB, RTLD_LAZY | RTLD_LOCAL);\n-        if (gthread_libhandle == NULL)\n-            return FALSE;\n-    }\n-\n-    if (setjmp(j) == 0)\n-    {\n-        fp_gtk_check_version = dl_symbol(\"gtk_check_version\");\n-        \/* Check for GTK 2.2+ *\/\n-        if (fp_gtk_check_version(2, 2, 0)) {\n-            longjmp(j, NO_SYMBOL_EXCEPTION);\n-        }\n-\n-        \/* GLib *\/\n-        fp_glib_check_version = dlsym(gtk2_libhandle, \"glib_check_version\");\n-        if (!fp_glib_check_version) {\n-            dlerror();\n-        }\n-        fp_g_free = dl_symbol(\"g_free\");\n-        fp_g_object_unref = dl_symbol(\"g_object_unref\");\n-\n-        fp_g_main_context_iteration =\n-            dl_symbol(\"g_main_context_iteration\");\n-\n-        fp_g_value_init = dl_symbol(\"g_value_init\");\n-        fp_g_type_is_a = dl_symbol(\"g_type_is_a\");\n-\n-        fp_g_value_get_boolean = dl_symbol(\"g_value_get_boolean\");\n-        fp_g_value_get_char = dl_symbol(\"g_value_get_char\");\n-        fp_g_value_get_uchar = dl_symbol(\"g_value_get_uchar\");\n-        fp_g_value_get_int = dl_symbol(\"g_value_get_int\");\n-        fp_g_value_get_uint = dl_symbol(\"g_value_get_uint\");\n-        fp_g_value_get_long = dl_symbol(\"g_value_get_long\");\n-        fp_g_value_get_ulong = dl_symbol(\"g_value_get_ulong\");\n-        fp_g_value_get_int64 = dl_symbol(\"g_value_get_int64\");\n-        fp_g_value_get_uint64 = dl_symbol(\"g_value_get_uint64\");\n-        fp_g_value_get_float = dl_symbol(\"g_value_get_float\");\n-        fp_g_value_get_double = dl_symbol(\"g_value_get_double\");\n-        fp_g_value_get_string = dl_symbol(\"g_value_get_string\");\n-        fp_g_value_get_enum = dl_symbol(\"g_value_get_enum\");\n-        fp_g_value_get_flags = dl_symbol(\"g_value_get_flags\");\n-        fp_g_value_get_param = dl_symbol(\"g_value_get_param\");\n-        fp_g_value_get_boxed = dl_symbol(\"g_value_get_boxed\");\n-        fp_g_value_get_pointer = dl_symbol(\"g_value_get_pointer\");\n-        fp_g_value_get_object = dl_symbol(\"g_value_get_object\");\n-        fp_g_param_spec_int = dl_symbol(\"g_param_spec_int\");\n-        fp_g_object_get = dl_symbol(\"g_object_get\");\n-        fp_g_object_set = dl_symbol(\"g_object_set\");\n-\n-        \/* GDK *\/\n-        fp_gdk_get_default_root_window =\n-            dl_symbol(\"gdk_get_default_root_window\");\n-        fp_gdk_pixmap_new = dl_symbol(\"gdk_pixmap_new\");\n-        fp_gdk_pixbuf_get_from_drawable =\n-            dl_symbol(\"gdk_pixbuf_get_from_drawable\");\n-        fp_gdk_pixbuf_scale_simple =\n-            dl_symbol(\"gdk_pixbuf_scale_simple\");\n-        fp_gdk_gc_new = dl_symbol(\"gdk_gc_new\");\n-        fp_gdk_rgb_gc_set_foreground =\n-            dl_symbol(\"gdk_rgb_gc_set_foreground\");\n-        fp_gdk_draw_rectangle = dl_symbol(\"gdk_draw_rectangle\");\n-        fp_gdk_drawable_get_size = dl_symbol(\"gdk_drawable_get_size\");\n-\n-        \/* Pixbuf *\/\n-        fp_gdk_pixbuf_new = dl_symbol(\"gdk_pixbuf_new\");\n-        fp_gdk_pixbuf_new_from_file =\n-                dl_symbol(\"gdk_pixbuf_new_from_file\");\n-        fp_gdk_pixbuf_get_width = dl_symbol(\"gdk_pixbuf_get_width\");\n-        fp_gdk_pixbuf_get_height = dl_symbol(\"gdk_pixbuf_get_height\");\n-        fp_gdk_pixbuf_get_pixels = dl_symbol(\"gdk_pixbuf_get_pixels\");\n-        fp_gdk_pixbuf_get_rowstride =\n-                dl_symbol(\"gdk_pixbuf_get_rowstride\");\n-        fp_gdk_pixbuf_get_has_alpha =\n-                dl_symbol(\"gdk_pixbuf_get_has_alpha\");\n-        fp_gdk_pixbuf_get_bits_per_sample =\n-                dl_symbol(\"gdk_pixbuf_get_bits_per_sample\");\n-        fp_gdk_pixbuf_get_n_channels =\n-                dl_symbol(\"gdk_pixbuf_get_n_channels\");\n-        fp_gdk_pixbuf_get_colorspace =\n-                dl_symbol(\"gdk_pixbuf_get_colorspace\");\n-\n-        \/* GTK painting *\/\n-        fp_gtk_init_check = dl_symbol(\"gtk_init_check\");\n-        fp_gtk_paint_hline = dl_symbol(\"gtk_paint_hline\");\n-        fp_gtk_paint_vline = dl_symbol(\"gtk_paint_vline\");\n-        fp_gtk_paint_shadow = dl_symbol(\"gtk_paint_shadow\");\n-        fp_gtk_paint_arrow = dl_symbol(\"gtk_paint_arrow\");\n-        fp_gtk_paint_box = dl_symbol(\"gtk_paint_box\");\n-        fp_gtk_paint_flat_box = dl_symbol(\"gtk_paint_flat_box\");\n-        fp_gtk_paint_check = dl_symbol(\"gtk_paint_check\");\n-        fp_gtk_paint_option = dl_symbol(\"gtk_paint_option\");\n-        fp_gtk_paint_box_gap = dl_symbol(\"gtk_paint_box_gap\");\n-        fp_gtk_paint_extension = dl_symbol(\"gtk_paint_extension\");\n-        fp_gtk_paint_focus = dl_symbol(\"gtk_paint_focus\");\n-        fp_gtk_paint_slider = dl_symbol(\"gtk_paint_slider\");\n-        fp_gtk_paint_handle = dl_symbol(\"gtk_paint_handle\");\n-        fp_gtk_paint_expander = dl_symbol(\"gtk_paint_expander\");\n-        fp_gtk_style_apply_default_background =\n-                dl_symbol(\"gtk_style_apply_default_background\");\n-\n-        \/* GTK widgets *\/\n-        fp_gtk_arrow_new = dl_symbol(\"gtk_arrow_new\");\n-        fp_gtk_button_new = dl_symbol(\"gtk_button_new\");\n-        fp_gtk_spin_button_new = dl_symbol(\"gtk_spin_button_new\");\n-        fp_gtk_check_button_new = dl_symbol(\"gtk_check_button_new\");\n-        fp_gtk_check_menu_item_new =\n-                dl_symbol(\"gtk_check_menu_item_new\");\n-        fp_gtk_color_selection_dialog_new =\n-                dl_symbol(\"gtk_color_selection_dialog_new\");\n-        fp_gtk_entry_new = dl_symbol(\"gtk_entry_new\");\n-        fp_gtk_fixed_new = dl_symbol(\"gtk_fixed_new\");\n-        fp_gtk_handle_box_new = dl_symbol(\"gtk_handle_box_new\");\n-        fp_gtk_image_new = dl_symbol(\"gtk_image_new\");\n-        fp_gtk_hpaned_new = dl_symbol(\"gtk_hpaned_new\");\n-        fp_gtk_vpaned_new = dl_symbol(\"gtk_vpaned_new\");\n-        fp_gtk_hscale_new = dl_symbol(\"gtk_hscale_new\");\n-        fp_gtk_vscale_new = dl_symbol(\"gtk_vscale_new\");\n-        fp_gtk_hscrollbar_new = dl_symbol(\"gtk_hscrollbar_new\");\n-        fp_gtk_vscrollbar_new = dl_symbol(\"gtk_vscrollbar_new\");\n-        fp_gtk_hseparator_new = dl_symbol(\"gtk_hseparator_new\");\n-        fp_gtk_vseparator_new = dl_symbol(\"gtk_vseparator_new\");\n-        fp_gtk_label_new = dl_symbol(\"gtk_label_new\");\n-        fp_gtk_menu_new = dl_symbol(\"gtk_menu_new\");\n-        fp_gtk_menu_bar_new = dl_symbol(\"gtk_menu_bar_new\");\n-        fp_gtk_menu_item_new = dl_symbol(\"gtk_menu_item_new\");\n-        fp_gtk_menu_item_set_submenu =\n-                dl_symbol(\"gtk_menu_item_set_submenu\");\n-        fp_gtk_notebook_new = dl_symbol(\"gtk_notebook_new\");\n-        fp_gtk_progress_bar_new =\n-            dl_symbol(\"gtk_progress_bar_new\");\n-        fp_gtk_progress_bar_set_orientation =\n-            dl_symbol(\"gtk_progress_bar_set_orientation\");\n-        fp_gtk_radio_button_new =\n-            dl_symbol(\"gtk_radio_button_new\");\n-        fp_gtk_radio_menu_item_new =\n-            dl_symbol(\"gtk_radio_menu_item_new\");\n-        fp_gtk_scrolled_window_new =\n-            dl_symbol(\"gtk_scrolled_window_new\");\n-        fp_gtk_separator_menu_item_new =\n-            dl_symbol(\"gtk_separator_menu_item_new\");\n-        fp_gtk_text_view_new = dl_symbol(\"gtk_text_view_new\");\n-        fp_gtk_toggle_button_new =\n-            dl_symbol(\"gtk_toggle_button_new\");\n-        fp_gtk_toolbar_new = dl_symbol(\"gtk_toolbar_new\");\n-        fp_gtk_tree_view_new = dl_symbol(\"gtk_tree_view_new\");\n-        fp_gtk_viewport_new = dl_symbol(\"gtk_viewport_new\");\n-        fp_gtk_window_new = dl_symbol(\"gtk_window_new\");\n-        fp_gtk_window_present = dl_symbol(\"gtk_window_present\");\n-        fp_gtk_window_move = dl_symbol(\"gtk_window_move\");\n-        fp_gtk_window_resize = dl_symbol(\"gtk_window_resize\");\n-\n-          fp_gtk_dialog_new = dl_symbol(\"gtk_dialog_new\");\n-        fp_gtk_frame_new = dl_symbol(\"gtk_frame_new\");\n-\n-        fp_gtk_adjustment_new = dl_symbol(\"gtk_adjustment_new\");\n-        fp_gtk_container_add = dl_symbol(\"gtk_container_add\");\n-        fp_gtk_menu_shell_append =\n-            dl_symbol(\"gtk_menu_shell_append\");\n-        fp_gtk_widget_realize = dl_symbol(\"gtk_widget_realize\");\n-        fp_gtk_widget_destroy = dl_symbol(\"gtk_widget_destroy\");\n-        fp_gtk_widget_render_icon =\n-            dl_symbol(\"gtk_widget_render_icon\");\n-        fp_gtk_widget_set_name =\n-            dl_symbol(\"gtk_widget_set_name\");\n-        fp_gtk_widget_set_parent =\n-            dl_symbol(\"gtk_widget_set_parent\");\n-        fp_gtk_widget_set_direction =\n-            dl_symbol(\"gtk_widget_set_direction\");\n-        fp_gtk_widget_style_get =\n-            dl_symbol(\"gtk_widget_style_get\");\n-        fp_gtk_widget_class_install_style_property =\n-            dl_symbol(\"gtk_widget_class_install_style_property\");\n-        fp_gtk_widget_class_find_style_property =\n-            dl_symbol(\"gtk_widget_class_find_style_property\");\n-        fp_gtk_widget_style_get_property =\n-            dl_symbol(\"gtk_widget_style_get_property\");\n-        fp_pango_font_description_to_string =\n-            dl_symbol(\"pango_font_description_to_string\");\n-        fp_gtk_settings_get_default =\n-            dl_symbol(\"gtk_settings_get_default\");\n-        fp_gtk_widget_get_settings =\n-            dl_symbol(\"gtk_widget_get_settings\");\n-        fp_gtk_border_get_type =  dl_symbol(\"gtk_border_get_type\");\n-        fp_gtk_arrow_set = dl_symbol(\"gtk_arrow_set\");\n-        fp_gtk_widget_size_request =\n-            dl_symbol(\"gtk_widget_size_request\");\n-        fp_gtk_range_get_adjustment =\n-            dl_symbol(\"gtk_range_get_adjustment\");\n-\n-        fp_gtk_widget_hide = dl_symbol(\"gtk_widget_hide\");\n-        fp_gtk_main_quit = dl_symbol(\"gtk_main_quit\");\n-        fp_g_signal_connect_data = dl_symbol(\"g_signal_connect_data\");\n-        fp_gtk_widget_show = dl_symbol(\"gtk_widget_show\");\n-        fp_gtk_main = dl_symbol(\"gtk_main\");\n-\n-        fp_g_path_get_dirname = dl_symbol(\"g_path_get_dirname\");\n-\n-        \/**\n-         * GLib thread system\n-         *\/\n-        if (GLIB_CHECK_VERSION(2, 20, 0)) {\n-            fp_g_thread_get_initialized = dl_symbol_gthread(\"g_thread_get_initialized\");\n-        }\n-        fp_g_thread_init = dl_symbol_gthread(\"g_thread_init\");\n-        fp_gdk_threads_init = dl_symbol(\"gdk_threads_init\");\n-        fp_gdk_threads_enter = dl_symbol(\"gdk_threads_enter\");\n-        fp_gdk_threads_leave = dl_symbol(\"gdk_threads_leave\");\n-\n-        \/**\n-         * Functions for sun_awt_X11_GtkFileDialogPeer.c\n-         *\/\n-        if (fp_gtk_check_version(2, 4, 0) == NULL) {\n-            \/\/ The current GtkFileChooser is available from GTK+ 2.4\n-            gtk2_file_chooser_load();\n-        }\n-\n-        \/* Some functions may be missing in pre-2.4 GTK.\n-           We handle them specially here.\n-         *\/\n-        fp_gtk_combo_box_new = dlsym(gtk2_libhandle, \"gtk_combo_box_new\");\n-        if (fp_gtk_combo_box_new == NULL) {\n-            fp_gtk_combo_box_new = dl_symbol(\"gtk_combo_new\");\n-        }\n-\n-        fp_gtk_combo_box_entry_new =\n-            dlsym(gtk2_libhandle, \"gtk_combo_box_entry_new\");\n-        if (fp_gtk_combo_box_entry_new == NULL) {\n-            fp_gtk_combo_box_entry_new = dl_symbol(\"gtk_combo_new\");\n-            new_combo = FALSE;\n-        }\n-\n-        fp_gtk_separator_tool_item_new =\n-            dlsym(gtk2_libhandle, \"gtk_separator_tool_item_new\");\n-        if (fp_gtk_separator_tool_item_new == NULL) {\n-            fp_gtk_separator_tool_item_new =\n-                dl_symbol(\"gtk_vseparator_new\");\n-        }\n-\n-        fp_g_list_append = dl_symbol(\"g_list_append\");\n-        fp_g_list_free = dl_symbol(\"g_list_free\");\n-        fp_g_list_free_full = dl_symbol(\"g_list_free_full\");\n-    }\n-    \/* Now we have only one kind of exceptions: NO_SYMBOL_EXCEPTION\n-     * Otherwise we can check the return value of setjmp method.\n-     *\/\n-    else\n-    {\n-        dlclose(gtk2_libhandle);\n-        gtk2_libhandle = NULL;\n-\n-        dlclose(gthread_libhandle);\n-        gthread_libhandle = NULL;\n-\n-        return FALSE;\n-    }\n-\n-    \/*\n-     * Strip the AT-SPI GTK_MODULES if present\n-     *\/\n-    gtk_modules_env = getenv (\"GTK_MODULES\");\n-    if ((gtk_modules_env && strstr(gtk_modules_env, \"atk-bridge\")) ||\n-        (gtk_modules_env && strstr(gtk_modules_env, \"gail\"))) {\n-        \/* careful, strtok modifies its args *\/\n-        gchar *tmp_env = strdup(gtk_modules_env);\n-        if (tmp_env) {\n-            \/* the new env will be smaller than the old one *\/\n-            gchar *s, *new_env = SAFE_SIZE_STRUCT_ALLOC(malloc,\n-                    sizeof(ENV_PREFIX), 1, strlen (gtk_modules_env));\n-\n-            if (new_env) {\n-                strcpy(new_env, ENV_PREFIX);\n-\n-                \/* strip out 'atk-bridge' and 'gail' *\/\n-                size_t PREFIX_LENGTH = strlen(ENV_PREFIX);\n-                gchar *tmp_ptr = NULL;\n-                for (s = strtok_r(tmp_env, \":\", &tmp_ptr); s;\n-                     s = strtok_r(NULL, \":\", &tmp_ptr)) {\n-                    if ((!strstr(s, \"atk-bridge\")) && (!strstr(s, \"gail\"))) {\n-                        if (strlen(new_env) > PREFIX_LENGTH) {\n-                            new_env = strcat(new_env, \":\");\n-                        }\n-                        new_env = strcat(new_env, s);\n-                    }\n-                }\n-                if (putenv(new_env) != 0) {\n-                    \/* no free() on success, putenv() doesn't copy string *\/\n-                    free(new_env);\n-                }\n-            }\n-            free(tmp_env);\n-        }\n-    }\n-    \/*\n-     * GTK should be initialized with gtk_init_check() before use.\n-     *\n-     * gtk_init_check installs its own error handlers. It is critical that\n-     * we preserve error handler set from AWT. Otherwise we'll crash on\n-     * BadMatch errors which we would normally ignore. The IO error handler\n-     * is preserved here, too, just for consistency.\n-    *\/\n-    AWT_LOCK();\n-    handler = XSetErrorHandler(NULL);\n-    io_handler = XSetIOErrorHandler(NULL);\n-\n-    if (fp_gtk_check_version(2, 2, 0) == NULL) {\n-\n-        \/\/ Calling g_thread_init() multiple times leads to crash on GLib < 2.24\n-        \/\/ We can use g_thread_get_initialized () but it is available only for\n-        \/\/ GLib >= 2.20.\n-        gboolean is_g_thread_get_initialized = FALSE;\n-        if (GLIB_CHECK_VERSION(2, 20, 0)) {\n-            is_g_thread_get_initialized = fp_g_thread_get_initialized();\n-        }\n-\n-        if (!is_g_thread_get_initialized) {\n-            fp_g_thread_init(NULL);\n-        }\n-\n-        \/\/According the GTK documentation, gdk_threads_init() should be\n-        \/\/called before gtk_init() or gtk_init_check()\n-        fp_gdk_threads_init();\n-    }\n-    result = (*fp_gtk_init_check)(NULL, NULL);\n-\n-    XSetErrorHandler(handler);\n-    XSetIOErrorHandler(io_handler);\n-    AWT_UNLOCK();\n-\n-    \/* Initialize widget array. *\/\n-    for (i = 0; i < _GTK_WIDGET_TYPE_SIZE; i++)\n-    {\n-        gtk2_widgets[i] = NULL;\n-    }\n-    if (result) {\n-        GtkApi* gtk = (GtkApi*)malloc(sizeof(GtkApi));\n-        gtk2_init(gtk);\n-        return gtk;\n-    }\n-    return NULL;\n-}\n-\n-int gtk2_unload()\n-{\n-    int i;\n-    char *gtk2_error;\n-\n-    if (!gtk2_libhandle)\n-        return TRUE;\n-\n-    \/* Release painting objects *\/\n-    if (gtk2_white_pixmap != NULL) {\n-        (*fp_g_object_unref)(gtk2_white_pixmap);\n-        (*fp_g_object_unref)(gtk2_black_pixmap);\n-        (*fp_g_object_unref)(gtk2_white_pixbuf);\n-        (*fp_g_object_unref)(gtk2_black_pixbuf);\n-        gtk2_white_pixmap = gtk2_black_pixmap =\n-            gtk2_white_pixbuf = gtk2_black_pixbuf = NULL;\n-    }\n-    gtk2_pixbuf_width = 0;\n-    gtk2_pixbuf_height = 0;\n-\n-    if (gtk2_window != NULL) {\n-        \/* Destroying toplevel widget will destroy all contained widgets *\/\n-        (*fp_gtk_widget_destroy)(gtk2_window);\n-\n-        \/* Unset some static data so they get reinitialized on next load *\/\n-        gtk2_window = NULL;\n-    }\n-\n-    dlerror();\n-    dlclose(gtk2_libhandle);\n-    dlclose(gthread_libhandle);\n-    if ((gtk2_error = dlerror()) != NULL)\n-    {\n-        return FALSE;\n-    }\n-    return TRUE;\n-}\n-\n-\/* Dispatch all pending events from the GTK event loop.\n- * This is needed to catch theme change and update widgets' style.\n- *\/\n-static void flush_gtk_event_loop()\n-{\n-    while( (*fp_g_main_context_iteration)(NULL, FALSE));\n-}\n-\n-\/*\n- * Initialize components of containment hierarchy. This creates a GtkFixed\n- * inside a GtkWindow. All widgets get realized.\n- *\/\n-static void init_containers()\n-{\n-    if (gtk2_window == NULL)\n-    {\n-        gtk2_window = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n-        gtk2_fixed = (GtkFixed *)(*fp_gtk_fixed_new)();\n-        (*fp_gtk_container_add)((GtkContainer*)gtk2_window,\n-                                (GtkWidget *)gtk2_fixed);\n-        (*fp_gtk_widget_realize)(gtk2_window);\n-        (*fp_gtk_widget_realize)((GtkWidget *)gtk2_fixed);\n-    }\n-}\n-\n-\/*\n- * Ensure everything is ready for drawing an element of the specified width\n- * and height.\n- *\n- * We should somehow handle translucent images. GTK can draw to X Drawables\n- * only, which don't support alpha. When we retrieve the image back from\n- * the server, translucency information is lost. There're several ways to\n- * work around this:\n- * 1) Subclass GdkPixmap and cache translucent objects on client side. This\n- * requires us to implement parts of X server drawing logic on client side.\n- * Many X requests can potentially be \"translucent\"; e.g. XDrawLine with\n- * fill=tile and a translucent tile is a \"translucent\" operation, whereas\n- * XDrawLine with fill=solid is an \"opaque\" one. Moreover themes can (and some\n- * do) intermix transparent and opaque operations which makes caching even\n- * more problematic.\n- * 2) Use Xorg 32bit ARGB visual when available. GDK has no native support\n- * for it (as of version 2.6). Also even in JDS 3 Xorg does not support\n- * these visuals by default, which makes optimizing for them pointless.\n- * We can consider doing this at a later point when ARGB visuals become more\n- * popular.\n- * 3') GTK has plans to use Cairo as its graphical backend (presumably in\n- * 2.8), and Cairo supports alpha. With it we could also get rid of the\n- * unnecessary round trip to server and do all the drawing on client side.\n- * 4) For now we draw to two different pixmaps and restore alpha channel by\n- * comparing results. This can be optimized by using subclassed pixmap and\n- * doing the second drawing only if necessary.\n-*\/\n-static void gtk2_init_painting(JNIEnv *env, gint width, gint height)\n-{\n-    GdkGC *gc;\n-    GdkPixbuf *white, *black;\n-\n-    init_containers();\n-\n-    if (gtk2_pixbuf_width < width || gtk2_pixbuf_height < height)\n-    {\n-        white = (*fp_gdk_pixbuf_new)(GDK_COLORSPACE_RGB, TRUE, 8, width, height);\n-        black = (*fp_gdk_pixbuf_new)(GDK_COLORSPACE_RGB, TRUE, 8, width, height);\n-\n-        if (white == NULL || black == NULL)\n-        {\n-            snprintf(convertionBuffer, CONV_BUFFER_SIZE, \"Couldn't create pixbuf of size %dx%d\", width, height);\n-            throw_exception(env, \"java\/lang\/RuntimeException\", convertionBuffer);\n-            fp_gdk_threads_leave();\n-            return;\n-        }\n-\n-        if (gtk2_white_pixmap != NULL) {\n-            \/* free old stuff *\/\n-            (*fp_g_object_unref)(gtk2_white_pixmap);\n-            (*fp_g_object_unref)(gtk2_black_pixmap);\n-            (*fp_g_object_unref)(gtk2_white_pixbuf);\n-            (*fp_g_object_unref)(gtk2_black_pixbuf);\n-        }\n-\n-        gtk2_white_pixmap = (*fp_gdk_pixmap_new)(gtk2_window->window, width, height, -1);\n-        gtk2_black_pixmap = (*fp_gdk_pixmap_new)(gtk2_window->window, width, height, -1);\n-\n-        gtk2_white_pixbuf = white;\n-        gtk2_black_pixbuf = black;\n-\n-        gtk2_pixbuf_width = width;\n-        gtk2_pixbuf_height = height;\n-    }\n-\n-    \/* clear the pixmaps *\/\n-    gc = (*fp_gdk_gc_new)(gtk2_white_pixmap);\n-    (*fp_gdk_rgb_gc_set_foreground)(gc, 0xffffff);\n-    (*fp_gdk_draw_rectangle)(gtk2_white_pixmap, gc, TRUE, 0, 0, width, height);\n-    (*fp_g_object_unref)(gc);\n-\n-    gc = (*fp_gdk_gc_new)(gtk2_black_pixmap);\n-    (*fp_gdk_rgb_gc_set_foreground)(gc, 0x000000);\n-    (*fp_gdk_draw_rectangle)(gtk2_black_pixmap, gc, TRUE, 0, 0, width, height);\n-    (*fp_g_object_unref)(gc);\n-}\n-\n-\/*\n- * Restore image from white and black pixmaps and copy it into destination\n- * buffer. This method compares two pixbufs taken from white and black\n- * pixmaps and decodes color and alpha components. Pixbufs are RGB without\n- * alpha, destination buffer is ABGR.\n- *\n- * The return value is the transparency type of the resulting image, either\n- * one of java_awt_Transparency_OPAQUE, java_awt_Transparency_BITMASK, and\n- * java_awt_Transparency_TRANSLUCENT.\n- *\/\n-static gint gtk2_copy_image(gint *dst, gint width, gint height)\n-{\n-    gint i, j, r, g, b;\n-    guchar *white, *black;\n-    gint stride, padding;\n-    gboolean is_opaque = TRUE;\n-    gboolean is_bitmask = TRUE;\n-\n-    (*fp_gdk_pixbuf_get_from_drawable)(gtk2_white_pixbuf, gtk2_white_pixmap,\n-            NULL, 0, 0, 0, 0, width, height);\n-    (*fp_gdk_pixbuf_get_from_drawable)(gtk2_black_pixbuf, gtk2_black_pixmap,\n-            NULL, 0, 0, 0, 0, width, height);\n-\n-    white = (*fp_gdk_pixbuf_get_pixels)(gtk2_white_pixbuf);\n-    black = (*fp_gdk_pixbuf_get_pixels)(gtk2_black_pixbuf);\n-    stride = (*fp_gdk_pixbuf_get_rowstride)(gtk2_black_pixbuf);\n-    padding = stride - width * 4;\n-    if (padding >= 0 && stride > 0) {\n-        for (i = 0; i < height; i++) {\n-            for (j = 0; j < width; j++) {\n-                int r1 = *white++;\n-                int r2 = *black++;\n-                int alpha = 0xff + r2 - r1;\n-\n-                switch (alpha) {\n-                    case 0:       \/* transparent pixel *\/\n-                        r = g = b = 0;\n-                        black += 3;\n-                        white += 3;\n-                        is_opaque = FALSE;\n-                        break;\n-\n-                    case 0xff:    \/* opaque pixel *\/\n-                        r = r2;\n-                        g = *black++;\n-                        b = *black++;\n-                        black++;\n-                        white += 3;\n-                        break;\n-\n-                    default:      \/* translucent pixel *\/\n-                        r = 0xff * r2 \/ alpha;\n-                        g = 0xff * *black++ \/ alpha;\n-                        b = 0xff * *black++ \/ alpha;\n-                        black++;\n-                        white += 3;\n-                        is_opaque = FALSE;\n-                        is_bitmask = FALSE;\n-                        break;\n-                }\n-\n-                *dst++ = (alpha << 24 | r << 16 | g << 8 | b);\n-            }\n-\n-            white += padding;\n-            black += padding;\n-        }\n-    }\n-    return is_opaque ? java_awt_Transparency_OPAQUE :\n-                       (is_bitmask ? java_awt_Transparency_BITMASK :\n-                                     java_awt_Transparency_TRANSLUCENT);\n-}\n-\n-static void\n-gtk2_set_direction(GtkWidget *widget, GtkTextDirection dir)\n-{\n-    \/*\n-     * Some engines (inexplicably) look at the direction of the widget's\n-     * parent, so we need to set the direction of both the widget and its\n-     * parent.\n-     *\/\n-    (*fp_gtk_widget_set_direction)(widget, dir);\n-    if (widget->parent != NULL) {\n-        (*fp_gtk_widget_set_direction)(widget->parent, dir);\n-    }\n-}\n-\n-\/*\n- * Initializes the widget to correct state for some engines.\n- * This is a pure empirical method.\n- *\/\n-static void init_toggle_widget(WidgetType widget_type, gint synth_state)\n-{\n-    gboolean is_active = ((synth_state & SELECTED) != 0);\n-\n-    if (widget_type == RADIO_BUTTON ||\n-        widget_type == CHECK_BOX ||\n-        widget_type == TOGGLE_BUTTON) {\n-        ((GtkToggleButton*)gtk2_widget)->active = is_active;\n-    }\n-\n-    if ((synth_state & FOCUSED) != 0) {\n-        ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n-    } else {\n-        ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n-    }\n-\n-    if ((((synth_state & MOUSE_OVER) != 0) && ((synth_state & PRESSED) == 0)) ||\n-           (((synth_state & FOCUSED) != 0) && ((synth_state & PRESSED) != 0))) {\n-        gtk2_widget->state = GTK_STATE_PRELIGHT;\n-    } else if ((synth_state & DISABLED) != 0) {\n-        gtk2_widget->state = GTK_STATE_INSENSITIVE;\n-    } else {\n-        gtk2_widget->state = is_active ? GTK_STATE_ACTIVE : GTK_STATE_NORMAL;\n-    }\n-}\n-\n-\/* GTK state_type filter *\/\n-static GtkStateType get_gtk_state_type(WidgetType widget_type, gint synth_state)\n-{\n-    GtkStateType result = GTK_STATE_NORMAL;\n-\n-    if ((synth_state & DISABLED) != 0) {\n-        result = GTK_STATE_INSENSITIVE;\n-    } else if ((synth_state & PRESSED) != 0) {\n-        result = GTK_STATE_ACTIVE;\n-    } else if ((synth_state & MOUSE_OVER) != 0) {\n-        result = GTK_STATE_PRELIGHT;\n-    }\n-    return result;\n-}\n-\n-\/* GTK shadow_type filter *\/\n-static GtkShadowType get_gtk_shadow_type(WidgetType widget_type, gint synth_state)\n-{\n-    GtkShadowType result = GTK_SHADOW_OUT;\n-\n-    if ((synth_state & SELECTED) != 0) {\n-        result = GTK_SHADOW_IN;\n-    }\n-    return result;\n-}\n-\n-\n-static GtkWidget* gtk2_get_arrow(GtkArrowType arrow_type, GtkShadowType shadow_type)\n-{\n-    GtkWidget *arrow = NULL;\n-    if (NULL == gtk2_widgets[_GTK_ARROW_TYPE])\n-    {\n-        gtk2_widgets[_GTK_ARROW_TYPE] = (*fp_gtk_arrow_new)(arrow_type, shadow_type);\n-        (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, gtk2_widgets[_GTK_ARROW_TYPE]);\n-        (*fp_gtk_widget_realize)(gtk2_widgets[_GTK_ARROW_TYPE]);\n-    }\n-    arrow = gtk2_widgets[_GTK_ARROW_TYPE];\n-\n-    (*fp_gtk_arrow_set)(arrow, arrow_type, shadow_type);\n-    return arrow;\n-}\n-\n-static GtkAdjustment* create_adjustment()\n-{\n-    return (GtkAdjustment *)\n-            (*fp_gtk_adjustment_new)(50.0, 0.0, 100.0, 10.0, 20.0, 20.0);\n-}\n-\n-\/**\n- * Returns a pointer to the cached native widget for the specified widget\n- * type.\n- *\/\n-static GtkWidget *gtk2_get_widget(WidgetType widget_type)\n-{\n-    gboolean init_result = FALSE;\n-    GtkWidget *result = NULL;\n-    switch (widget_type)\n-    {\n-        case BUTTON:\n-        case TABLE_HEADER:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_BUTTON_TYPE] = (*fp_gtk_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_BUTTON_TYPE];\n-            break;\n-        case CHECK_BOX:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_CHECK_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_CHECK_BUTTON_TYPE] =\n-                    (*fp_gtk_check_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_CHECK_BUTTON_TYPE];\n-            break;\n-        case CHECK_BOX_MENU_ITEM:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_check_menu_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_CHECK_MENU_ITEM_TYPE];\n-            break;\n-        \/************************************************************\n-         *    Creation a dedicated color chooser is dangerous because\n-         * it deadlocks the EDT\n-         ************************************************************\/\n-\/*        case COLOR_CHOOSER:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE] =\n-                    (*fp_gtk_color_selection_dialog_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_COLOR_SELECTION_DIALOG_TYPE];\n-            break;*\/\n-        case COMBO_BOX:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_COMBO_BOX_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_COMBO_BOX_TYPE] =\n-                    (*fp_gtk_combo_box_new)();\n-            }\n-            result = gtk2_widgets[_GTK_COMBO_BOX_TYPE];\n-            break;\n-        case COMBO_BOX_ARROW_BUTTON:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE] =\n-                     (*fp_gtk_toggle_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_COMBO_BOX_ARROW_BUTTON_TYPE];\n-            break;\n-        case COMBO_BOX_TEXT_FIELD:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE]))\n-            {\n-                result = gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE] =\n-                     (*fp_gtk_entry_new)();\n-            }\n-            result = gtk2_widgets[_GTK_COMBO_BOX_TEXT_FIELD_TYPE];\n-            break;\n-        case DESKTOP_ICON:\n-        case INTERNAL_FRAME_TITLE_PANE:\n-        case LABEL:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_LABEL_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_LABEL_TYPE] =\n-                    (*fp_gtk_label_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_LABEL_TYPE];\n-            break;\n-        case DESKTOP_PANE:\n-        case PANEL:\n-        case ROOT_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_CONTAINER_TYPE]))\n-            {\n-                \/* There is no constructor for a container type.  I've\n-                 * chosen GtkFixed container since it has a default\n-                 * constructor.\n-                 *\/\n-                gtk2_widgets[_GTK_CONTAINER_TYPE] =\n-                    (*fp_gtk_fixed_new)();\n-            }\n-            result = gtk2_widgets[_GTK_CONTAINER_TYPE];\n-            break;\n-        case EDITOR_PANE:\n-        case TEXT_AREA:\n-        case TEXT_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TEXT_VIEW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TEXT_VIEW_TYPE] =\n-                    (*fp_gtk_text_view_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TEXT_VIEW_TYPE];\n-            break;\n-        case FORMATTED_TEXT_FIELD:\n-        case PASSWORD_FIELD:\n-        case TEXT_FIELD:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_ENTRY_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_ENTRY_TYPE] =\n-                    (*fp_gtk_entry_new)();\n-            }\n-            result = gtk2_widgets[_GTK_ENTRY_TYPE];\n-            break;\n-        case HANDLE_BOX:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HANDLE_BOX_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HANDLE_BOX_TYPE] =\n-                    (*fp_gtk_handle_box_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HANDLE_BOX_TYPE];\n-            break;\n-        case HSCROLL_BAR:\n-        case HSCROLL_BAR_BUTTON_LEFT:\n-        case HSCROLL_BAR_BUTTON_RIGHT:\n-        case HSCROLL_BAR_TRACK:\n-        case HSCROLL_BAR_THUMB:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HSCROLLBAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HSCROLLBAR_TYPE] =\n-                    (*fp_gtk_hscrollbar_new)(create_adjustment());\n-            }\n-            result = gtk2_widgets[_GTK_HSCROLLBAR_TYPE];\n-            break;\n-        case HSEPARATOR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HSEPARATOR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HSEPARATOR_TYPE] =\n-                    (*fp_gtk_hseparator_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HSEPARATOR_TYPE];\n-            break;\n-        case HSLIDER:\n-        case HSLIDER_THUMB:\n-        case HSLIDER_TRACK:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HSCALE_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HSCALE_TYPE] =\n-                    (*fp_gtk_hscale_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_HSCALE_TYPE];\n-            break;\n-        case HSPLIT_PANE_DIVIDER:\n-        case SPLIT_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HPANED_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HPANED_TYPE] = (*fp_gtk_hpaned_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HPANED_TYPE];\n-            break;\n-        case IMAGE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_IMAGE_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_IMAGE_TYPE] = (*fp_gtk_image_new)();\n-            }\n-            result = gtk2_widgets[_GTK_IMAGE_TYPE];\n-            break;\n-        case INTERNAL_FRAME:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_WINDOW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_WINDOW_TYPE] =\n-                    (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n-            }\n-            result = gtk2_widgets[_GTK_WINDOW_TYPE];\n-            break;\n-        case TOOL_TIP:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TOOLTIP_TYPE]))\n-            {\n-                result = (*fp_gtk_window_new)(GTK_WINDOW_TOPLEVEL);\n-                (*fp_gtk_widget_set_name)(result, \"gtk-tooltips\");\n-                gtk2_widgets[_GTK_TOOLTIP_TYPE] = result;\n-            }\n-            result = gtk2_widgets[_GTK_TOOLTIP_TYPE];\n-            break;\n-        case LIST:\n-        case TABLE:\n-        case TREE:\n-        case TREE_CELL:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TREE_VIEW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TREE_VIEW_TYPE] =\n-                    (*fp_gtk_tree_view_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TREE_VIEW_TYPE];\n-            break;\n-        case TITLED_BORDER:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_FRAME_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_FRAME_TYPE] = fp_gtk_frame_new(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_FRAME_TYPE];\n-            break;\n-        case POPUP_MENU:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_MENU_TYPE] =\n-                    (*fp_gtk_menu_new)();\n-            }\n-            result = gtk2_widgets[_GTK_MENU_TYPE];\n-            break;\n-        case MENU:\n-        case MENU_ITEM:\n-        case MENU_ITEM_ACCELERATOR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_menu_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_MENU_ITEM_TYPE];\n-            break;\n-        case MENU_BAR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_MENU_BAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_MENU_BAR_TYPE] =\n-                    (*fp_gtk_menu_bar_new)();\n-            }\n-            result = gtk2_widgets[_GTK_MENU_BAR_TYPE];\n-            break;\n-        case COLOR_CHOOSER:\n-        case OPTION_PANE:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_DIALOG_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_DIALOG_TYPE] =\n-                    (*fp_gtk_dialog_new)();\n-            }\n-            result = gtk2_widgets[_GTK_DIALOG_TYPE];\n-            break;\n-        case POPUP_MENU_SEPARATOR:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_separator_menu_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_SEPARATOR_MENU_ITEM_TYPE];\n-            break;\n-        case HPROGRESS_BAR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE] =\n-                    (*fp_gtk_progress_bar_new)();\n-            }\n-            result = gtk2_widgets[_GTK_HPROGRESS_BAR_TYPE];\n-            break;\n-        case VPROGRESS_BAR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE] =\n-                    (*fp_gtk_progress_bar_new)();\n-                \/*\n-                 * Vertical JProgressBars always go bottom-to-top,\n-                 * regardless of the ComponentOrientation.\n-                 *\/\n-                (*fp_gtk_progress_bar_set_orientation)(\n-                    (GtkProgressBar *)gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE],\n-                    GTK_PROGRESS_BOTTOM_TO_TOP);\n-            }\n-            result = gtk2_widgets[_GTK_VPROGRESS_BAR_TYPE];\n-            break;\n-        case RADIO_BUTTON:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_RADIO_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_RADIO_BUTTON_TYPE] =\n-                    (*fp_gtk_radio_button_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_RADIO_BUTTON_TYPE];\n-            break;\n-        case RADIO_BUTTON_MENU_ITEM:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE] =\n-                    (*fp_gtk_radio_menu_item_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_RADIO_MENU_ITEM_TYPE];\n-            break;\n-        case SCROLL_PANE:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE] =\n-                    (*fp_gtk_scrolled_window_new)(NULL, NULL);\n-            }\n-            result = gtk2_widgets[_GTK_SCROLLED_WINDOW_TYPE];\n-            break;\n-        case SPINNER:\n-        case SPINNER_ARROW_BUTTON:\n-        case SPINNER_TEXT_FIELD:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_SPIN_BUTTON_TYPE]))\n-            {\n-                result = gtk2_widgets[_GTK_SPIN_BUTTON_TYPE] =\n-                    (*fp_gtk_spin_button_new)(NULL, 0, 0);\n-            }\n-            result = gtk2_widgets[_GTK_SPIN_BUTTON_TYPE];\n-            break;\n-        case TABBED_PANE:\n-        case TABBED_PANE_TAB_AREA:\n-        case TABBED_PANE_CONTENT:\n-        case TABBED_PANE_TAB:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_NOTEBOOK_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_NOTEBOOK_TYPE] =\n-                    (*fp_gtk_notebook_new)();\n-            }\n-            result = gtk2_widgets[_GTK_NOTEBOOK_TYPE];\n-            break;\n-        case TOGGLE_BUTTON:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE] =\n-                    (*fp_gtk_toggle_button_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TOGGLE_BUTTON_TYPE];\n-            break;\n-        case TOOL_BAR:\n-        case TOOL_BAR_DRAG_WINDOW:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_TOOLBAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_TOOLBAR_TYPE] =\n-                    (*fp_gtk_toolbar_new)();\n-            }\n-            result = gtk2_widgets[_GTK_TOOLBAR_TYPE];\n-            break;\n-        case TOOL_BAR_SEPARATOR:\n-            if (init_result =\n-                    (NULL == gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE] =\n-                    (*fp_gtk_separator_tool_item_new)();\n-            }\n-            result = gtk2_widgets[_GTK_SEPARATOR_TOOL_ITEM_TYPE];\n-            break;\n-        case VIEWPORT:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VIEWPORT_TYPE]))\n-            {\n-                GtkAdjustment *adjustment = create_adjustment();\n-                gtk2_widgets[_GTK_VIEWPORT_TYPE] =\n-                    (*fp_gtk_viewport_new)(adjustment, adjustment);\n-            }\n-            result = gtk2_widgets[_GTK_VIEWPORT_TYPE];\n-            break;\n-        case VSCROLL_BAR:\n-        case VSCROLL_BAR_BUTTON_UP:\n-        case VSCROLL_BAR_BUTTON_DOWN:\n-        case VSCROLL_BAR_TRACK:\n-        case VSCROLL_BAR_THUMB:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VSCROLLBAR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VSCROLLBAR_TYPE] =\n-                    (*fp_gtk_vscrollbar_new)(create_adjustment());\n-            }\n-            result = gtk2_widgets[_GTK_VSCROLLBAR_TYPE];\n-            break;\n-        case VSEPARATOR:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VSEPARATOR_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VSEPARATOR_TYPE] =\n-                    (*fp_gtk_vseparator_new)();\n-            }\n-            result = gtk2_widgets[_GTK_VSEPARATOR_TYPE];\n-            break;\n-        case VSLIDER:\n-        case VSLIDER_THUMB:\n-        case VSLIDER_TRACK:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VSCALE_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VSCALE_TYPE] =\n-                    (*fp_gtk_vscale_new)(NULL);\n-            }\n-            result = gtk2_widgets[_GTK_VSCALE_TYPE];\n-            \/*\n-             * Vertical JSliders start at the bottom, while vertical\n-             * GtkVScale widgets start at the top (by default), so to fix\n-             * this we set the \"inverted\" flag to get the Swing behavior.\n-             *\/\n-            ((GtkRange*)result)->inverted = 1;\n-            break;\n-        case VSPLIT_PANE_DIVIDER:\n-            if (init_result = (NULL == gtk2_widgets[_GTK_VPANED_TYPE]))\n-            {\n-                gtk2_widgets[_GTK_VPANED_TYPE] = (*fp_gtk_vpaned_new)();\n-            }\n-            result = gtk2_widgets[_GTK_VPANED_TYPE];\n-            break;\n-        default:\n-            result = NULL;\n-            break;\n-    }\n-\n-    if (result != NULL && init_result)\n-    {\n-        if (widget_type == RADIO_BUTTON_MENU_ITEM ||\n-                widget_type == CHECK_BOX_MENU_ITEM ||\n-                widget_type == MENU_ITEM ||\n-                widget_type == MENU ||\n-                widget_type == POPUP_MENU_SEPARATOR)\n-        {\n-            GtkWidget *menu = gtk2_get_widget(POPUP_MENU);\n-            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu, result);\n-        }\n-        else if (widget_type == POPUP_MENU)\n-        {\n-            GtkWidget *menu_bar = gtk2_get_widget(MENU_BAR);\n-            GtkWidget *root_menu = (*fp_gtk_menu_item_new)();\n-            (*fp_gtk_menu_item_set_submenu)((GtkMenuItem*)root_menu, result);\n-            (*fp_gtk_menu_shell_append)((GtkMenuShell *)menu_bar, root_menu);\n-        }\n-        else if (widget_type == COMBO_BOX_ARROW_BUTTON ||\n-                 widget_type == COMBO_BOX_TEXT_FIELD)\n-        {\n-            \/*\n-            * We add a regular GtkButton\/GtkEntry to a GtkComboBoxEntry\n-            * in order to trick engines into thinking it's a real combobox\n-            * arrow button\/text field.\n-            *\/\n-            GtkWidget *combo = (*fp_gtk_combo_box_entry_new)();\n-\n-            if (new_combo && widget_type == COMBO_BOX_ARROW_BUTTON) {\n-                (*fp_gtk_widget_set_parent)(result, combo);\n-                ((GtkBin*)combo)->child = result;\n-            } else {\n-                (*fp_gtk_container_add)((GtkContainer *)combo, result);\n-            }\n-            (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, combo);\n-        }\n-        else if (widget_type != TOOL_TIP &&\n-                 widget_type != INTERNAL_FRAME &&\n-                 widget_type != OPTION_PANE)\n-        {\n-            (*fp_gtk_container_add)((GtkContainer *)gtk2_fixed, result);\n-        }\n-        (*fp_gtk_widget_realize)(result);\n-    }\n-    return result;\n-}\n-\n-void gtk2_paint_arrow(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height,\n-        GtkArrowType arrow_type, gboolean fill)\n-{\n-    static int w, h;\n-    static GtkRequisition size;\n-\n-    if (widget_type == COMBO_BOX_ARROW_BUTTON || widget_type == TABLE)\n-        gtk2_widget = gtk2_get_arrow(arrow_type, shadow_type);\n-    else\n-        gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    switch (widget_type)\n-    {\n-        case SPINNER_ARROW_BUTTON:\n-            x = 1;\n-            y = ((arrow_type == GTK_ARROW_UP) ? 2 : 0);\n-            height -= 2;\n-            width -= 3;\n-\n-            w = width \/ 2;\n-            w -= w % 2 - 1;\n-            h = (w + 1) \/ 2;\n-            break;\n-\n-        case HSCROLL_BAR_BUTTON_LEFT:\n-        case HSCROLL_BAR_BUTTON_RIGHT:\n-        case VSCROLL_BAR_BUTTON_UP:\n-        case VSCROLL_BAR_BUTTON_DOWN:\n-            w = width \/ 2;\n-            h = height \/ 2;\n-            break;\n-\n-        case COMBO_BOX_ARROW_BUTTON:\n-        case TABLE:\n-            x = 1;\n-            (*fp_gtk_widget_size_request)(gtk2_widget, &size);\n-            w = size.width - ((GtkMisc*)gtk2_widget)->xpad * 2;\n-            h = size.height - ((GtkMisc*)gtk2_widget)->ypad * 2;\n-            w = h = MIN(MIN(w, h), MIN(width,height)) * 0.7;\n-            break;\n-\n-        default:\n-            w = width;\n-            h = height;\n-            break;\n-    }\n-    x += (width - w) \/ 2;\n-    y += (height - h) \/ 2;\n-\n-    (*fp_gtk_paint_arrow)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, arrow_type, fill,\n-            x, y, w, h);\n-    (*fp_gtk_paint_arrow)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, arrow_type, fill,\n-            x, y, w, h);\n-}\n-\n-static void gtk2_paint_box(WidgetType widget_type, GtkStateType state_type,\n-                    GtkShadowType shadow_type, const gchar *detail,\n-                    gint x, gint y, gint width, gint height,\n-                    gint synth_state, GtkTextDirection dir)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    \/*\n-     * The clearlooks engine sometimes looks at the widget's state field\n-     * instead of just the state_type variable that we pass in, so to account\n-     * for those cases we set the widget's state field accordingly.  The\n-     * flags field is similarly important for things like focus\/default state.\n-     *\/\n-    gtk2_widget->state = state_type;\n-\n-    if (widget_type == HSLIDER_TRACK) {\n-        \/*\n-         * For horizontal JSliders with right-to-left orientation, we need\n-         * to set the \"inverted\" flag to match the native GTK behavior where\n-         * the foreground highlight is on the right side of the slider thumb.\n-         * This is needed especially for the ubuntulooks engine, which looks\n-         * exclusively at the \"inverted\" flag to determine on which side of\n-         * the thumb to paint the highlight...\n-         *\/\n-        ((GtkRange*)gtk2_widget)->inverted = (dir == GTK_TEXT_DIR_RTL);\n-\n-        \/*\n-         * Note however that other engines like clearlooks will look at both\n-         * the \"inverted\" field and the text direction to determine how\n-         * the foreground highlight is painted:\n-         *     !inverted && ltr --> paint highlight on left side\n-         *     !inverted && rtl --> paint highlight on right side\n-         *      inverted && ltr --> paint highlight on right side\n-         *      inverted && rtl --> paint highlight on left side\n-         * So the only way to reliably get the desired results for horizontal\n-         * JSlider (i.e., highlight on left side for LTR ComponentOrientation\n-         * and highlight on right side for RTL ComponentOrientation) is to\n-         * always override text direction as LTR, and then set the \"inverted\"\n-         * flag accordingly (as we have done above).\n-         *\/\n-        dir = GTK_TEXT_DIR_LTR;\n-    }\n-\n-    \/*\n-     * Some engines (e.g. clearlooks) will paint the shadow of certain\n-     * widgets (e.g. COMBO_BOX_ARROW_BUTTON) differently depending on the\n-     * the text direction.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, dir);\n-\n-    switch (widget_type) {\n-    case BUTTON:\n-        if (synth_state & DEFAULT) {\n-            ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_DEFAULT;\n-        } else {\n-            ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_DEFAULT;\n-        }\n-        break;\n-    case TOGGLE_BUTTON:\n-        init_toggle_widget(widget_type, synth_state);\n-        break;\n-    case HSCROLL_BAR_BUTTON_LEFT:\n-        \/*\n-         * The clearlooks engine will draw a \"left\" button when:\n-         *   x == w->allocation.x\n-         *\n-         * The ubuntulooks engine will draw a \"left\" button when:\n-         *   [x,y,width,height]\n-         *     intersects\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *\n-         * The values that are set below should ensure that a \"left\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x;\n-        gtk2_widget->allocation.y = y;\n-        gtk2_widget->allocation.width = width;\n-        gtk2_widget->allocation.height = height;\n-        break;\n-    case HSCROLL_BAR_BUTTON_RIGHT:\n-        \/*\n-         * The clearlooks engine will draw a \"right\" button when:\n-         *   x + width == w->allocation.x + w->allocation.width\n-         *\n-         * The ubuntulooks engine will draw a \"right\" button when:\n-         *   [x,y,width,height]\n-         *     does not intersect\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *     but does intersect\n-         *   [w->alloc.x+width,w->alloc.y,width,height]\n-         *\n-         * The values that are set below should ensure that a \"right\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x+width;\n-        gtk2_widget->allocation.y = 0;\n-        gtk2_widget->allocation.width = 0;\n-        gtk2_widget->allocation.height = height;\n-        break;\n-    case VSCROLL_BAR_BUTTON_UP:\n-        \/*\n-         * The clearlooks engine will draw an \"up\" button when:\n-         *   y == w->allocation.y\n-         *\n-         * The ubuntulooks engine will draw an \"up\" button when:\n-         *   [x,y,width,height]\n-         *     intersects\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *\n-         * The values that are set below should ensure that an \"up\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x;\n-        gtk2_widget->allocation.y = y;\n-        gtk2_widget->allocation.width = width;\n-        gtk2_widget->allocation.height = height;\n-        break;\n-    case VSCROLL_BAR_BUTTON_DOWN:\n-        \/*\n-         * The clearlooks engine will draw a \"down\" button when:\n-         *   y + height == w->allocation.y + w->allocation.height\n-         *\n-         * The ubuntulooks engine will draw a \"down\" button when:\n-         *   [x,y,width,height]\n-         *     does not intersect\n-         *   [w->alloc.x,w->alloc.y,width,height]\n-         *     but does intersect\n-         *   [w->alloc.x,w->alloc.y+height,width,height]\n-         *\n-         * The values that are set below should ensure that a \"down\"\n-         * button is rendered for both of these (and other) engines.\n-         *\/\n-        gtk2_widget->allocation.x = x;\n-        gtk2_widget->allocation.y = y+height;\n-        gtk2_widget->allocation.width = width;\n-        gtk2_widget->allocation.height = 0;\n-        break;\n-    default:\n-        break;\n-    }\n-\n-    (*fp_gtk_paint_box)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-    (*fp_gtk_paint_box)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-\n-    \/*\n-     * Reset the text direction to the default value so that we don't\n-     * accidentally affect other operations and widgets.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, GTK_TEXT_DIR_LTR);\n-}\n-\n-void gtk2_paint_box_gap(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height,\n-        GtkPositionType gap_side, gint gap_x, gint gap_width)\n-{\n-    \/* Clearlooks needs a real clip area to paint the gap properly *\/\n-    GdkRectangle area = { x, y, width, height };\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_box_gap)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, &area, gtk2_widget, detail,\n-            x, y, width, height, gap_side, gap_x, gap_width);\n-    (*fp_gtk_paint_box_gap)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, &area, gtk2_widget, detail,\n-            x, y, width, height, gap_side, gap_x, gap_width);\n-}\n-\n-static void gtk2_paint_check(WidgetType widget_type, gint synth_state,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    GtkStateType state_type = get_gtk_state_type(widget_type, synth_state);\n-    GtkShadowType shadow_type = get_gtk_shadow_type(widget_type, synth_state);\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    init_toggle_widget(widget_type, synth_state);\n-\n-    (*fp_gtk_paint_check)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-    (*fp_gtk_paint_check)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-}\n-\n-static void gtk2_paint_expander(WidgetType widget_type, GtkStateType state_type,\n-        const gchar *detail, gint x, gint y, gint width, gint height,\n-        GtkExpanderStyle expander_style)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_expander)(gtk2_widget->style, gtk2_white_pixmap,\n-            state_type, NULL, gtk2_widget, detail,\n-            x + width \/ 2, y + height \/ 2, expander_style);\n-    (*fp_gtk_paint_expander)(gtk2_widget->style, gtk2_black_pixmap,\n-            state_type, NULL, gtk2_widget, detail,\n-            x + width \/ 2, y + height \/ 2, expander_style);\n-}\n-\n-static void gtk2_paint_extension(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, GtkPositionType gap_side)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_extension)(gtk2_widget->style, gtk2_white_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, gap_side);\n-    (*fp_gtk_paint_extension)(gtk2_widget->style, gtk2_black_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, gap_side);\n-}\n-\n-static void gtk2_paint_flat_box(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, gboolean has_focus)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    if (has_focus)\n-        ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n-    else\n-        ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n-\n-    (*fp_gtk_paint_flat_box)(gtk2_widget->style, gtk2_white_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-    (*fp_gtk_paint_flat_box)(gtk2_widget->style, gtk2_black_pixmap,\n-            state_type, shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-}\n-\n-static void gtk2_paint_focus(WidgetType widget_type, GtkStateType state_type,\n-        const char *detail, gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_focus)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, y, width, height);\n-    (*fp_gtk_paint_focus)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, y, width, height);\n-}\n-\n-static void gtk2_paint_handle(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_handle)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-    (*fp_gtk_paint_handle)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-}\n-\n-static void gtk2_paint_hline(WidgetType widget_type, GtkStateType state_type,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_hline)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, x + width, y);\n-    (*fp_gtk_paint_hline)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            NULL, gtk2_widget, detail, x, x + width, y);\n-}\n-\n-static void gtk2_paint_option(WidgetType widget_type, gint synth_state,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    GtkStateType state_type = get_gtk_state_type(widget_type, synth_state);\n-    GtkShadowType shadow_type = get_gtk_shadow_type(widget_type, synth_state);\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    init_toggle_widget(widget_type, synth_state);\n-\n-    (*fp_gtk_paint_option)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-    (*fp_gtk_paint_option)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height);\n-}\n-\n-static void gtk2_paint_shadow(WidgetType widget_type, GtkStateType state_type,\n-                       GtkShadowType shadow_type, const gchar *detail,\n-                       gint x, gint y, gint width, gint height,\n-                       gint synth_state, GtkTextDirection dir)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    \/*\n-     * The clearlooks engine sometimes looks at the widget's state field\n-     * instead of just the state_type variable that we pass in, so to account\n-     * for those cases we set the widget's state field accordingly.  The\n-     * flags field is similarly important for things like focus state.\n-     *\/\n-    gtk2_widget->state = state_type;\n-\n-    \/*\n-     * Some engines (e.g. clearlooks) will paint the shadow of certain\n-     * widgets (e.g. COMBO_BOX_TEXT_FIELD) differently depending on the\n-     * the text direction.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, dir);\n-\n-    switch (widget_type) {\n-    case COMBO_BOX_TEXT_FIELD:\n-    case FORMATTED_TEXT_FIELD:\n-    case PASSWORD_FIELD:\n-    case SPINNER_TEXT_FIELD:\n-    case TEXT_FIELD:\n-        if (synth_state & FOCUSED) {\n-            ((GtkObject*)gtk2_widget)->flags |= GTK_HAS_FOCUS;\n-        } else {\n-            ((GtkObject*)gtk2_widget)->flags &= ~GTK_HAS_FOCUS;\n-        }\n-        break;\n-    default:\n-        break;\n-    }\n-\n-    (*fp_gtk_paint_shadow)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-    (*fp_gtk_paint_shadow)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail, x, y, width, height);\n-\n-    \/*\n-     * Reset the text direction to the default value so that we don't\n-     * accidentally affect other operations and widgets.\n-     *\/\n-    gtk2_set_direction(gtk2_widget, GTK_TEXT_DIR_LTR);\n-}\n-\n-static void gtk2_paint_slider(WidgetType widget_type, GtkStateType state_type,\n-        GtkShadowType shadow_type, const gchar *detail,\n-        gint x, gint y, gint width, gint height, GtkOrientation orientation,\n-        gboolean has_focus)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_slider)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-    (*fp_gtk_paint_slider)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            shadow_type, NULL, gtk2_widget, detail,\n-            x, y, width, height, orientation);\n-}\n-\n-static void gtk2_paint_vline(WidgetType widget_type, GtkStateType state_type,\n-        const gchar *detail, gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_paint_vline)(gtk2_widget->style, gtk2_white_pixmap, state_type,\n-            NULL, gtk2_widget, detail, y, y + height, x);\n-    (*fp_gtk_paint_vline)(gtk2_widget->style, gtk2_black_pixmap, state_type,\n-            NULL, gtk2_widget, detail, y, y + height, x);\n-}\n-\n-static void gtk_paint_background(WidgetType widget_type, GtkStateType state_type,\n-        gint x, gint y, gint width, gint height)\n-{\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    (*fp_gtk_style_apply_default_background)(gtk2_widget->style,\n-            gtk2_white_pixmap, TRUE, state_type, NULL, x, y, width, height);\n-    (*fp_gtk_style_apply_default_background)(gtk2_widget->style,\n-            gtk2_black_pixmap, TRUE, state_type, NULL, x, y, width, height);\n-}\n-\n-static GdkPixbuf *gtk2_get_stock_icon(gint widget_type, const gchar *stock_id,\n-        GtkIconSize size, GtkTextDirection direction, const char *detail)\n-{\n-    init_containers();\n-    gtk2_widget = gtk2_get_widget((widget_type < 0) ? IMAGE : widget_type);\n-    gtk2_widget->state = GTK_STATE_NORMAL;\n-    (*fp_gtk_widget_set_direction)(gtk2_widget, direction);\n-    return (*fp_gtk_widget_render_icon)(gtk2_widget, stock_id, size, detail);\n-}\n-\n-static jboolean gtk2_get_pixbuf_data(JNIEnv *env, GdkPixbuf* pixbuf,\n-                              jmethodID icon_upcall_method, jobject this) {\n-    if (!pixbuf) {\n-        return JNI_FALSE;\n-    }\n-    guchar *pixbuf_data = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n-    if (pixbuf_data) {\n-        int row_stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n-        int width = (*fp_gdk_pixbuf_get_width)(pixbuf);\n-        int height = (*fp_gdk_pixbuf_get_height)(pixbuf);\n-        int bps = (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf);\n-        int channels = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n-        gboolean alpha = (*fp_gdk_pixbuf_get_has_alpha)(pixbuf);\n-\n-        jbyteArray data = (*env)->NewByteArray(env, (row_stride * height));\n-        JNU_CHECK_EXCEPTION_RETURN(env, JNI_FALSE);\n-\n-        (*env)->SetByteArrayRegion(env, data, 0, (row_stride * height),\n-                                   (jbyte *)pixbuf_data);\n-        (*fp_g_object_unref)(pixbuf);\n-\n-        \/* Call the callback method to create the image on the Java side. *\/\n-        (*env)->CallVoidMethod(env, this, icon_upcall_method, data,\n-                width, height, row_stride, bps, channels, alpha);\n-        return JNI_TRUE;\n-    }\n-    return JNI_FALSE;\n-}\n-\n-static jboolean gtk2_get_file_icon_data(JNIEnv *env, const char *filename,\n-                 GError **error, jmethodID icon_upcall_method, jobject this) {\n-    GdkPixbuf* pixbuf = fp_gdk_pixbuf_new_from_file(filename, error);\n-    return gtk2_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n-}\n-\n-static jboolean gtk2_get_icon_data(JNIEnv *env, gint widget_type,\n-                              const gchar *stock_id, GtkIconSize size,\n-                              GtkTextDirection direction, const char *detail,\n-                              jmethodID icon_upcall_method, jobject this) {\n-    GdkPixbuf* pixbuf = gtk2_get_stock_icon(widget_type, stock_id, size,\n-                                       direction, detail);\n-    return gtk2_get_pixbuf_data(env, pixbuf, icon_upcall_method, this);\n-}\n-\n-\/*************************************************\/\n-static gint gtk2_get_xthickness(JNIEnv *env, WidgetType widget_type)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    GtkStyle* style = gtk2_widget->style;\n-    return style->xthickness;\n-}\n-\n-static gint gtk2_get_ythickness(JNIEnv *env, WidgetType widget_type)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    GtkStyle* style = gtk2_widget->style;\n-    return style->ythickness;\n-}\n-\n-\/*************************************************\/\n-static guint8 recode_color(guint16 channel)\n-{\n-    return (guint8)(channel>>8);\n-}\n-\n-static gint gtk2_get_color_for_state(JNIEnv *env, WidgetType widget_type,\n-                              GtkStateType state_type, ColorType color_type)\n-{\n-    gint result = 0;\n-    GdkColor *color = NULL;\n-\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    GtkStyle* style = gtk2_widget->style;\n-\n-    switch (color_type)\n-    {\n-        case FOREGROUND:\n-            color = &(style->fg[state_type]);\n-            break;\n-        case BACKGROUND:\n-            color = &(style->bg[state_type]);\n-            break;\n-        case TEXT_FOREGROUND:\n-            color = &(style->text[state_type]);\n-            break;\n-        case TEXT_BACKGROUND:\n-            color = &(style->base[state_type]);\n-            break;\n-        case LIGHT:\n-            color = &(style->light[state_type]);\n-            break;\n-        case DARK:\n-            color = &(style->dark[state_type]);\n-            break;\n-        case MID:\n-            color = &(style->mid[state_type]);\n-            break;\n-        case FOCUS:\n-        case BLACK:\n-            color = &(style->black);\n-            break;\n-        case WHITE:\n-            color = &(style->white);\n-            break;\n-    }\n-\n-    if (color)\n-        result = recode_color(color->red)   << 16 |\n-                 recode_color(color->green) << 8  |\n-                 recode_color(color->blue);\n-\n-    return result;\n-}\n-\n-\/*************************************************\/\n-static jobject create_Boolean(JNIEnv *env, jboolean boolean_value);\n-static jobject create_Integer(JNIEnv *env, jint int_value);\n-static jobject create_Long(JNIEnv *env, jlong long_value);\n-static jobject create_Float(JNIEnv *env, jfloat float_value);\n-static jobject create_Double(JNIEnv *env, jdouble double_value);\n-static jobject create_Character(JNIEnv *env, jchar char_value);\n-static jobject create_Insets(JNIEnv *env, GtkBorder *border);\n-\n-static jobject gtk2_get_class_value(JNIEnv *env, WidgetType widget_type,\n-                              const char* key)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    GValue value;\n-    value.g_type = 0;\n-\n-    GParamSpec* param = (*fp_gtk_widget_class_find_style_property)(\n-                                    ((GTypeInstance*)gtk2_widget)->g_class, key);\n-    if( param )\n-    {\n-        (*fp_g_value_init)( &value, param->value_type );\n-        (*fp_gtk_widget_style_get_property)(gtk2_widget, key, &value);\n-\n-        if( (*fp_g_type_is_a)( param->value_type, G_TYPE_BOOLEAN ))\n-        {\n-            gboolean val = (*fp_g_value_get_boolean)(&value);\n-            return create_Boolean(env, (jboolean)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_CHAR ))\n-        {\n-            gchar val = (*fp_g_value_get_char)(&value);\n-            return create_Character(env, (jchar)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UCHAR ))\n-        {\n-            guchar val = (*fp_g_value_get_uchar)(&value);\n-            return create_Character(env, (jchar)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_INT ))\n-        {\n-            gint val = (*fp_g_value_get_int)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UINT ))\n-        {\n-            guint val = (*fp_g_value_get_uint)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_LONG ))\n-        {\n-            glong val = (*fp_g_value_get_long)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_ULONG ))\n-        {\n-            gulong val = (*fp_g_value_get_ulong)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_INT64 ))\n-        {\n-            gint64 val = (*fp_g_value_get_int64)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_UINT64 ))\n-        {\n-            guint64 val = (*fp_g_value_get_uint64)(&value);\n-            return create_Long(env, (jlong)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_FLOAT ))\n-        {\n-            gfloat val = (*fp_g_value_get_float)(&value);\n-            return create_Float(env, (jfloat)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_DOUBLE ))\n-        {\n-            gdouble val = (*fp_g_value_get_double)(&value);\n-            return create_Double(env, (jdouble)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_ENUM ))\n-        {\n-            gint val = (*fp_g_value_get_enum)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_FLAGS ))\n-        {\n-            guint val = (*fp_g_value_get_flags)(&value);\n-            return create_Integer(env, (jint)val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_STRING ))\n-        {\n-            const gchar* val = (*fp_g_value_get_string)(&value);\n-\n-            \/* We suppose that all values come in C locale and\n-             * utf-8 representation of a string is the same as\n-             * the string itself. If this isn't so we should\n-             * use g_convert.\n-             *\/\n-            return (*env)->NewStringUTF(env, val);\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, GTK_TYPE_BORDER ))\n-        {\n-            GtkBorder *border = (GtkBorder*)(*fp_g_value_get_boxed)(&value);\n-            return border ? create_Insets(env, border) : NULL;\n-        }\n-\n-        \/*      TODO: Other types are not supported yet.*\/\n-\/*        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_PARAM ))\n-        {\n-            GParamSpec* val = (*fp_g_value_get_param)(&value);\n-            printf( \"Param: %p\\n\", val );\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_BOXED ))\n-        {\n-            gpointer* val = (*fp_g_value_get_boxed)(&value);\n-            printf( \"Boxed: %p\\n\", val );\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_POINTER ))\n-        {\n-            gpointer* val = (*fp_g_value_get_pointer)(&value);\n-            printf( \"Pointer: %p\\n\", val );\n-        }\n-        else if( (*fp_g_type_is_a)( param->value_type, G_TYPE_OBJECT ))\n-        {\n-            GObject* val = (GObject*)(*fp_g_value_get_object)(&value);\n-            printf( \"Object: %p\\n\", val );\n-        }*\/\n-    }\n-\n-    return NULL;\n-}\n-\n-static void gtk2_set_range_value(WidgetType widget_type, jdouble value,\n-                          jdouble min, jdouble max, jdouble visible)\n-{\n-    GtkAdjustment *adj;\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-\n-    adj = (*fp_gtk_range_get_adjustment)((GtkRange *)gtk2_widget);\n-    adj->value = (gdouble)value;\n-    adj->lower = (gdouble)min;\n-    adj->upper = (gdouble)max;\n-    adj->page_size = (gdouble)visible;\n-}\n-\n-\/*************************************************\/\n-static jobject create_Object(JNIEnv *env, jmethodID *cid,\n-                             const char* class_name,\n-                             const char* signature,\n-                             jvalue* value)\n-{\n-    jclass  class;\n-    jobject result;\n-\n-    class = (*env)->FindClass(env, class_name);\n-    if( class == NULL )\n-        return NULL; \/* can't find\/load the class, exception thrown *\/\n-\n-    if( *cid == NULL)\n-    {\n-        *cid = (*env)->GetMethodID(env, class, \"<init>\", signature);\n-        if( *cid == NULL )\n-        {\n-            (*env)->DeleteLocalRef(env, class);\n-            return NULL; \/* can't find\/get the method, exception thrown *\/\n-        }\n-    }\n-\n-    result = (*env)->NewObjectA(env, class, *cid, value);\n-\n-    (*env)->DeleteLocalRef(env, class);\n-    return result;\n-}\n-\n-jobject create_Boolean(JNIEnv *env, jboolean boolean_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.z = boolean_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Boolean\", \"(Z)V\", &value);\n-}\n-\n-jobject create_Integer(JNIEnv *env, jint int_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.i = int_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Integer\", \"(I)V\", &value);\n-}\n-\n-jobject create_Long(JNIEnv *env, jlong long_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.j = long_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Long\", \"(J)V\", &value);\n-}\n-\n-jobject create_Float(JNIEnv *env, jfloat float_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.f = float_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Float\", \"(F)V\", &value);\n-}\n-\n-jobject create_Double(JNIEnv *env, jdouble double_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.d = double_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Double\", \"(D)V\", &value);\n-}\n-\n-jobject create_Character(JNIEnv *env, jchar char_value)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue value;\n-\n-    value.c = char_value;\n-\n-    return create_Object(env, &cid, \"java\/lang\/Character\", \"(C)V\", &value);\n-}\n-\n-\n-jobject create_Insets(JNIEnv *env, GtkBorder *border)\n-{\n-    static jmethodID cid = NULL;\n-    jvalue values[4];\n-\n-    values[0].i = border->top;\n-    values[1].i = border->left;\n-    values[2].i = border->bottom;\n-    values[3].i = border->right;\n-\n-    return create_Object(env, &cid, \"java\/awt\/Insets\", \"(IIII)V\", values);\n-}\n-\n-\/*********************************************\/\n-static jstring gtk2_get_pango_font_name(JNIEnv *env, WidgetType widget_type)\n-{\n-    init_containers();\n-\n-    gtk2_widget = gtk2_get_widget(widget_type);\n-    jstring  result = NULL;\n-    GtkStyle* style = gtk2_widget->style;\n-\n-    if (style && style->font_desc)\n-    {\n-        gchar* val = (*fp_pango_font_description_to_string)(style->font_desc);\n-        result = (*env)->NewStringUTF(env, val);\n-        (*fp_g_free)( val );\n-    }\n-\n-    return result;\n-}\n-\n-\/***********************************************\/\n-static jobject get_string_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n-{\n-    jobject result = NULL;\n-    gchar*  strval = NULL;\n-\n-    (*fp_g_object_get)(settings, key, &strval, NULL);\n-    result = (*env)->NewStringUTF(env, strval);\n-    (*fp_g_free)(strval);\n-\n-    return result;\n-}\n-\n-static jobject get_integer_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n-{\n-    gint intval = 0;\n-    (*fp_g_object_get)(settings, key, &intval, NULL);\n-    return create_Integer(env, intval);\n-}\n-\n-static jobject get_boolean_property(JNIEnv *env, GtkSettings* settings, const gchar* key)\n-{\n-    gint intval = 0;\n-    (*fp_g_object_get)(settings, key, &intval, NULL);\n-    return create_Boolean(env, intval);\n-}\n-\n-static jobject gtk2_get_setting(JNIEnv *env, Setting property)\n-{\n-    GtkSettings* settings = (*fp_gtk_settings_get_default)();\n-\n-    switch (property)\n-    {\n-        case GTK_FONT_NAME:\n-            return get_string_property(env, settings, \"gtk-font-name\");\n-        case GTK_ICON_SIZES:\n-            return get_string_property(env, settings, \"gtk-icon-sizes\");\n-        case GTK_CURSOR_BLINK:\n-            return get_boolean_property(env, settings, \"gtk-cursor-blink\");\n-        case GTK_CURSOR_BLINK_TIME:\n-            return get_integer_property(env, settings, \"gtk-cursor-blink-time\");\n-    }\n-\n-    return NULL;\n-}\n-\n-static gboolean gtk2_get_drawable_data(JNIEnv *env, jintArray pixelArray, jint x,\n-     jint y, jint width, jint height, jint jwidth, int dx, int dy) {\n-    GdkPixbuf *pixbuf;\n-    jint *ary;\n-\n-    GdkWindow *root = (*fp_gdk_get_default_root_window)();\n-\n-    pixbuf = (*fp_gdk_pixbuf_get_from_drawable)(NULL, root, NULL, x, y,\n-                                                    0, 0, width, height);\n-\n-    if (pixbuf) {\n-        int nchan = (*fp_gdk_pixbuf_get_n_channels)(pixbuf);\n-        int stride = (*fp_gdk_pixbuf_get_rowstride)(pixbuf);\n-\n-        if ((*fp_gdk_pixbuf_get_width)(pixbuf) == width\n-                && (*fp_gdk_pixbuf_get_height)(pixbuf) == height\n-                && (*fp_gdk_pixbuf_get_bits_per_sample)(pixbuf) == 8\n-                && (*fp_gdk_pixbuf_get_colorspace)(pixbuf) == GDK_COLORSPACE_RGB\n-                && nchan >= 3\n-                ) {\n-            guchar *p, *pix = (*fp_gdk_pixbuf_get_pixels)(pixbuf);\n-\n-            ary = (*env)->GetPrimitiveArrayCritical(env, pixelArray, NULL);\n-            if (ary) {\n-                jint _x, _y;\n-                int index;\n-                for (_y = 0; _y < height; _y++) {\n-                    for (_x = 0; _x < width; _x++) {\n-                        p = pix + (intptr_t) _y * stride + _x * nchan;\n-\n-                        index = (_y + dy) * jwidth + (_x + dx);\n-                        ary[index] = 0xff000000\n-                                        | (p[0] << 16)\n-                                        | (p[1] << 8)\n-                                        | (p[2]);\n-\n-                    }\n-                }\n-                (*env)->ReleasePrimitiveArrayCritical(env, pixelArray, ary, 0);\n-            }\n-        }\n-        (*fp_g_object_unref)(pixbuf);\n-    }\n-    return JNI_FALSE;\n-}\n-\n-static GdkWindow* gtk2_get_window(void *widget) {\n-    return ((GtkWidget*)widget)->window;\n-}\n-\n-void gtk2_init(GtkApi* gtk) {\n-    gtk->version = GTK_2;\n-\n-    gtk->show_uri_load = &gtk2_show_uri_load;\n-    gtk->unload = &gtk2_unload;\n-    gtk->flush_event_loop = &flush_gtk_event_loop;\n-    gtk->gtk_check_version = fp_gtk_check_version;\n-    gtk->get_setting = &gtk2_get_setting;\n-\n-    gtk->paint_arrow = &gtk2_paint_arrow;\n-    gtk->paint_box = &gtk2_paint_box;\n-    gtk->paint_box_gap = &gtk2_paint_box_gap;\n-    gtk->paint_expander = &gtk2_paint_expander;\n-    gtk->paint_extension = &gtk2_paint_extension;\n-    gtk->paint_flat_box = &gtk2_paint_flat_box;\n-    gtk->paint_focus = &gtk2_paint_focus;\n-    gtk->paint_handle = &gtk2_paint_handle;\n-    gtk->paint_hline = &gtk2_paint_hline;\n-    gtk->paint_vline = &gtk2_paint_vline;\n-    gtk->paint_option = &gtk2_paint_option;\n-    gtk->paint_shadow = &gtk2_paint_shadow;\n-    gtk->paint_slider = &gtk2_paint_slider;\n-    gtk->paint_background = &gtk_paint_background;\n-    gtk->paint_check = &gtk2_paint_check;\n-    gtk->set_range_value = &gtk2_set_range_value;\n-\n-    gtk->init_painting = &gtk2_init_painting;\n-    gtk->copy_image = &gtk2_copy_image;\n-\n-    gtk->get_xthickness = &gtk2_get_xthickness;\n-    gtk->get_ythickness = &gtk2_get_ythickness;\n-    gtk->get_color_for_state = &gtk2_get_color_for_state;\n-    gtk->get_class_value = &gtk2_get_class_value;\n-\n-    gtk->get_pango_font_name = &gtk2_get_pango_font_name;\n-    gtk->get_icon_data = &gtk2_get_icon_data;\n-    gtk->get_file_icon_data = &gtk2_get_file_icon_data;\n-    gtk->gdk_threads_enter = fp_gdk_threads_enter;\n-    gtk->gdk_threads_leave = fp_gdk_threads_leave;\n-    gtk->gtk_show_uri = fp_gtk_show_uri;\n-    gtk->get_drawable_data = &gtk2_get_drawable_data;\n-    gtk->g_free = fp_g_free;\n-\n-    gtk->gtk_file_chooser_get_filename = fp_gtk_file_chooser_get_filename;\n-    gtk->gtk_widget_hide = fp_gtk_widget_hide;\n-    gtk->gtk_main_quit = fp_gtk_main_quit;\n-    gtk->gtk_file_chooser_dialog_new = fp_gtk_file_chooser_dialog_new;\n-    gtk->gtk_file_chooser_set_current_folder =\n-                          fp_gtk_file_chooser_set_current_folder;\n-    gtk->gtk_file_chooser_set_filename = fp_gtk_file_chooser_set_filename;\n-    gtk->gtk_file_chooser_set_current_name =\n-                          fp_gtk_file_chooser_set_current_name;\n-    gtk->gtk_file_filter_add_custom = fp_gtk_file_filter_add_custom;\n-    gtk->gtk_file_chooser_set_filter = fp_gtk_file_chooser_set_filter;\n-    gtk->gtk_file_chooser_get_type = fp_gtk_file_chooser_get_type;\n-    gtk->gtk_file_filter_new = fp_gtk_file_filter_new;\n-    gtk->gtk_file_chooser_set_do_overwrite_confirmation =\n-                          fp_gtk_file_chooser_set_do_overwrite_confirmation;\n-    gtk->gtk_file_chooser_set_select_multiple =\n-                          fp_gtk_file_chooser_set_select_multiple;\n-    gtk->gtk_file_chooser_get_current_folder =\n-                          fp_gtk_file_chooser_get_current_folder;\n-    gtk->gtk_file_chooser_get_filenames = fp_gtk_file_chooser_get_filenames;\n-    gtk->gtk_g_slist_length = fp_gtk_g_slist_length;\n-    gtk->g_signal_connect_data = fp_g_signal_connect_data;\n-    gtk->gtk_widget_show = fp_gtk_widget_show;\n-    gtk->gtk_main = fp_gtk_main;\n-    gtk->gtk_main_level = fp_gtk_main_level;\n-    gtk->g_path_get_dirname = fp_g_path_get_dirname;\n-    gtk->gdk_x11_drawable_get_xid = fp_gdk_x11_drawable_get_xid;\n-    gtk->gtk_widget_destroy = fp_gtk_widget_destroy;\n-    gtk->gtk_window_present = fp_gtk_window_present;\n-    gtk->gtk_window_move = fp_gtk_window_move;\n-    gtk->gtk_window_resize = fp_gtk_window_resize;\n-    gtk->get_window = &gtk2_get_window;\n-\n-    gtk->g_object_unref = fp_g_object_unref;\n-    gtk->g_list_append = fp_g_list_append;\n-    gtk->g_list_free = fp_g_list_free;\n-    gtk->g_list_free_full = fp_g_list_free_full;\n-}\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.c","additions":0,"deletions":2603,"binary":false,"changes":2603,"status":"deleted"},{"patch":"@@ -1,448 +0,0 @@\n-\/*\n- * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-#ifdef HEADLESS\n-    #error This file should not be included in headless library\n-#endif\n-\n-#ifndef _GTK2_INTERFACE_H\n-#define _GTK2_INTERFACE_H\n-\n-#include <stdlib.h>\n-#include <jni.h>\n-#include <X11\/X.h>\n-#include \"gtk_interface.h\"\n-\n-#define GTK_HAS_FOCUS   (1 << 12)\n-#define GTK_HAS_DEFAULT (1 << 14)\n-\n-typedef enum\n-{\n-  GTK_WINDOW_TOPLEVEL,\n-  GTK_WINDOW_POPUP\n-} GtkWindowType;\n-\n-typedef enum\n-{\n-  G_PARAM_READABLE            = 1 << 0,\n-  G_PARAM_WRITABLE            = 1 << 1,\n-  G_PARAM_CONSTRUCT           = 1 << 2,\n-  G_PARAM_CONSTRUCT_ONLY      = 1 << 3,\n-  G_PARAM_LAX_VALIDATION      = 1 << 4,\n-  G_PARAM_PRIVATE             = 1 << 5\n-} GParamFlags;\n-\n-\/* We define all structure pointers to be void* *\/\n-typedef void GVfs;\n-\n-typedef void GdkColormap;\n-typedef void GdkDrawable;\n-typedef void GdkGC;\n-typedef void GdkPixmap;\n-\n-typedef void GtkFixed;\n-typedef void GtkMenuItem;\n-typedef void GtkMenuShell;\n-typedef void GtkWidgetClass;\n-typedef void PangoFontDescription;\n-typedef void GtkSettings;\n-\n-\/* Some real structures *\/\n-typedef struct\n-{\n-  guint32 pixel;\n-  guint16 red;\n-  guint16 green;\n-  guint16 blue;\n-} GdkColor;\n-\n-typedef struct {\n-  gint      fd;\n-  gushort   events;\n-  gushort   revents;\n-} GPollFD;\n-\n-typedef struct {\n-  gint x;\n-  gint y;\n-  gint width;\n-  gint height;\n-} GtkAllocation;\n-\n-typedef struct {\n-  gint width;\n-  gint height;\n-} GtkRequisition;\n-\n-typedef struct {\n-  GtkWidgetClass *g_class;\n-} GTypeInstance;\n-\n-typedef struct {\n-  gint left;\n-  gint right;\n-  gint top;\n-  gint bottom;\n-} GtkBorder;\n-\n-\/******************************************************\n- * FIXME: it is more safe to include gtk headers for\n- * the precise type definition of GType and other\n- * structures. This is a place where getting rid of gtk\n- * headers may be dangerous.\n- ******************************************************\/\n-\n-typedef struct\n-{\n-  GType         g_type;\n-\n-  union {\n-    gint        v_int;\n-    guint       v_uint;\n-    glong       v_long;\n-    gulong      v_ulong;\n-    gint64      v_int64;\n-    guint64     v_uint64;\n-    gfloat      v_float;\n-    gdouble     v_double;\n-    gpointer    v_pointer;\n-  } data[2];\n-} GValue;\n-\n-typedef struct\n-{\n-  GTypeInstance  g_type_instance;\n-\n-  gchar         *name;\n-  GParamFlags    flags;\n-  GType          value_type;\n-  GType          owner_type;\n-} GParamSpec;\n-\n-typedef struct {\n-  GTypeInstance g_type_instance;\n-  guint         ref_count;\n-  void         *qdata;\n-} GObject;\n-\n-typedef struct {\n-  GObject parent_instance;\n-  guint32 flags;\n-} GtkObject;\n-\n-typedef struct\n-{\n-  GObject parent_instance;\n-\n-  GdkColor fg[5];\n-  GdkColor bg[5];\n-  GdkColor light[5];\n-  GdkColor dark[5];\n-  GdkColor mid[5];\n-  GdkColor text[5];\n-  GdkColor base[5];\n-  GdkColor text_aa[5];          \/* Halfway between text\/base *\/\n-\n-  GdkColor black;\n-  GdkColor white;\n-  PangoFontDescription *font_desc;\n-\n-  gint xthickness;\n-  gint ythickness;\n-\n-  GdkGC *fg_gc[5];\n-  GdkGC *bg_gc[5];\n-  GdkGC *light_gc[5];\n-  GdkGC *dark_gc[5];\n-  GdkGC *mid_gc[5];\n-  GdkGC *text_gc[5];\n-  GdkGC *base_gc[5];\n-  GdkGC *text_aa_gc[5];\n-  GdkGC *black_gc;\n-  GdkGC *white_gc;\n-\n-  GdkPixmap *bg_pixmap[5];\n-} GtkStyle;\n-\n-typedef struct _GtkWidget GtkWidget;\n-struct _GtkWidget\n-{\n-  GtkObject object;\n-  guint16 private_flags;\n-  guint8 state;\n-  guint8 saved_state;\n-  gchar *name;\n-  GtkStyle *style;\n-  GtkRequisition requisition;\n-  GtkAllocation allocation;\n-  GdkWindow *window;\n-  GtkWidget *parent;\n-};\n-\n-typedef struct\n-{\n-  GtkWidget widget;\n-\n-  gfloat xalign;\n-  gfloat yalign;\n-\n-  guint16 xpad;\n-  guint16 ypad;\n-} GtkMisc;\n-\n-typedef struct {\n-  GtkWidget widget;\n-  GtkWidget *focus_child;\n-  guint border_width : 16;\n-  guint need_resize : 1;\n-  guint resize_mode : 2;\n-  guint reallocate_redraws : 1;\n-  guint has_focus_chain : 1;\n-} GtkContainer;\n-\n-typedef struct {\n-  GtkContainer container;\n-  GtkWidget *child;\n-} GtkBin;\n-\n-typedef struct {\n-  GtkBin bin;\n-  GdkWindow *event_window;\n-  gchar *label_text;\n-  guint activate_timeout;\n-  guint constructed : 1;\n-  guint in_button : 1;\n-  guint button_down : 1;\n-  guint relief : 2;\n-  guint use_underline : 1;\n-  guint use_stock : 1;\n-  guint depressed : 1;\n-  guint depress_on_activate : 1;\n-  guint focus_on_click : 1;\n-} GtkButton;\n-\n-typedef struct {\n-  GtkButton button;\n-  guint active : 1;\n-  guint draw_indicator : 1;\n-  guint inconsistent : 1;\n-} GtkToggleButton;\n-\n-typedef struct _GtkAdjustment GtkAdjustment;\n-struct _GtkAdjustment\n-{\n-  GtkObject parent_instance;\n-\n-  gdouble lower;\n-  gdouble upper;\n-  gdouble value;\n-  gdouble step_increment;\n-  gdouble page_increment;\n-  gdouble page_size;\n-};\n-\n-typedef enum\n-{\n-  GTK_UPDATE_CONTINUOUS,\n-  GTK_UPDATE_DISCONTINUOUS,\n-  GTK_UPDATE_DELAYED\n-} GtkUpdateType;\n-\n-typedef struct _GtkRange GtkRange;\n-struct _GtkRange\n-{\n-  GtkWidget widget;\n-  GtkAdjustment *adjustment;\n-  GtkUpdateType update_policy;\n-  guint inverted : 1;\n-  \/*< protected >*\/\n-  guint flippable : 1;\n-  guint has_stepper_a : 1;\n-  guint has_stepper_b : 1;\n-  guint has_stepper_c : 1;\n-  guint has_stepper_d : 1;\n-  guint need_recalc : 1;\n-  guint slider_size_fixed : 1;\n-  gint min_slider_size;\n-  GtkOrientation orientation;\n-  GdkRectangle range_rect;\n-  gint slider_start, slider_end;\n-  gint round_digits;\n-  \/*< private >*\/\n-  guint trough_click_forward : 1;\n-  guint update_pending : 1;\n-  \/*GtkRangeLayout * *\/ void *layout;\n-  \/*GtkRangeStepTimer * *\/ void* timer;\n-  gint slide_initial_slider_position;\n-  gint slide_initial_coordinate;\n-  guint update_timeout_id;\n-  GdkWindow *event_window;\n-};\n-\n-typedef struct _GtkProgressBar       GtkProgressBar;\n-\n-typedef enum\n-{\n-  GTK_PROGRESS_CONTINUOUS,\n-  GTK_PROGRESS_DISCRETE\n-} GtkProgressBarStyle;\n-\n-typedef enum\n-{\n-  GTK_PROGRESS_LEFT_TO_RIGHT,\n-  GTK_PROGRESS_RIGHT_TO_LEFT,\n-  GTK_PROGRESS_BOTTOM_TO_TOP,\n-  GTK_PROGRESS_TOP_TO_BOTTOM\n-} GtkProgressBarOrientation;\n-\n-typedef struct _GtkProgress       GtkProgress;\n-\n-struct _GtkProgress\n-{\n-  GtkWidget widget;\n-  GtkAdjustment *adjustment;\n-  GdkPixmap     *offscreen_pixmap;\n-  gchar         *format;\n-  gfloat         x_align;\n-  gfloat         y_align;\n-  guint          show_text : 1;\n-  guint          activity_mode : 1;\n-  guint          use_text_format : 1;\n-};\n-\n-struct _GtkProgressBar\n-{\n-  GtkProgress progress;\n-  GtkProgressBarStyle bar_style;\n-  GtkProgressBarOrientation orientation;\n-  guint blocks;\n-  gint  in_block;\n-  gint  activity_pos;\n-  guint activity_step;\n-  guint activity_blocks;\n-  gdouble pulse_fraction;\n-  guint activity_dir : 1;\n-  guint ellipsize : 3;\n-};\n-\n-\/**\n- * Returns :\n- * NULL if the GLib library is compatible with the given version, or a string\n- * describing the version mismatch.\n- * Please note that the glib_check_version() is available since 2.6,\n- * so you should use GLIB_CHECK_VERSION macro instead.\n- *\/\n-static gchar* (*fp_glib_check_version)(guint required_major, guint required_minor,\n-                       guint required_micro);\n-\n-\/**\n- * Returns :\n- *  TRUE if the GLib library is compatible with the given version\n- *\/\n-#define GLIB_CHECK_VERSION(major, minor, micro) \\\n-    (fp_glib_check_version && fp_glib_check_version(major, minor, micro) == NULL)\n-\n-\/**\n- * Returns :\n- * NULL if the GTK+ library is compatible with the given version, or a string\n- * describing the version mismatch.\n- *\/\n-static gchar* (*fp_gtk_check_version)(guint required_major, guint required_minor,\n-                       guint required_micro);\n-\n-static void gtk2_init(GtkApi* gtk);\n-\n-static void (*fp_g_free)(gpointer mem);\n-static void (*fp_g_object_unref)(gpointer object);\n-static GdkWindow *(*fp_gdk_get_default_root_window) (void);\n-\n-static int (*fp_gdk_pixbuf_get_bits_per_sample)(const GdkPixbuf *pixbuf);\n-static guchar *(*fp_gdk_pixbuf_get_pixels)(const GdkPixbuf *pixbuf);\n-static gboolean (*fp_gdk_pixbuf_get_has_alpha)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_height)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_n_channels)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_rowstride)(const GdkPixbuf *pixbuf);\n-static int (*fp_gdk_pixbuf_get_width)(const GdkPixbuf *pixbuf);\n-static GdkPixbuf *(*fp_gdk_pixbuf_new_from_file)(const char *filename, GError **error);\n-static GdkColorspace (*fp_gdk_pixbuf_get_colorspace)(const GdkPixbuf *pixbuf);\n-\n-static GdkPixbuf *(*fp_gdk_pixbuf_get_from_drawable)(GdkPixbuf *dest,\n-        GdkDrawable *src, GdkColormap *cmap, int src_x, int src_y,\n-        int dest_x, int dest_y, int width, int height);\n-static GdkPixbuf *(*fp_gdk_pixbuf_scale_simple)(GdkPixbuf *src,\n-        int dest_width, int dest_heigh, GdkInterpType interp_type);\n-\n-\n-static void (*fp_gtk_widget_destroy)(void *widget);\n-static void (*fp_gtk_window_present)(GtkWindow *window);\n-static void (*fp_gtk_window_move)(GtkWindow *window, gint x, gint y);\n-static void (*fp_gtk_window_resize)(GtkWindow *window, gint width, gint height);\n-\n-\/**\n- * Function Pointers for GtkFileChooser\n- *\/\n-static gchar* (*fp_gtk_file_chooser_get_filename)(GtkFileChooser *chooser);\n-static void (*fp_gtk_widget_hide)(void *widget);\n-static void (*fp_gtk_main_quit)(void);\n-static void* (*fp_gtk_file_chooser_dialog_new)(const gchar *title,\n-    GtkWindow *parent, GtkFileChooserAction action,\n-    const gchar *first_button_text, ...);\n-static gboolean (*fp_gtk_file_chooser_set_current_folder)(GtkFileChooser *chooser,\n-    const gchar *filename);\n-static gboolean (*fp_gtk_file_chooser_set_filename)(GtkFileChooser *chooser,\n-    const char *filename);\n-static void (*fp_gtk_file_chooser_set_current_name)(GtkFileChooser *chooser,\n-    const gchar *name);\n-static void (*fp_gtk_file_filter_add_custom)(GtkFileFilter *filter,\n-    GtkFileFilterFlags needed, GtkFileFilterFunc func, gpointer data,\n-    GDestroyNotify notify);\n-static void (*fp_gtk_file_chooser_set_filter)(GtkFileChooser *chooser,\n-    GtkFileFilter *filter);\n-static GType (*fp_gtk_file_chooser_get_type)(void);\n-static GtkFileFilter* (*fp_gtk_file_filter_new)(void);\n-static void (*fp_gtk_file_chooser_set_do_overwrite_confirmation)(\n-    GtkFileChooser *chooser, gboolean do_overwrite_confirmation);\n-static void (*fp_gtk_file_chooser_set_select_multiple)(\n-    GtkFileChooser *chooser, gboolean select_multiple);\n-static gchar* (*fp_gtk_file_chooser_get_current_folder)(GtkFileChooser *chooser);\n-static GSList* (*fp_gtk_file_chooser_get_filenames)(GtkFileChooser *chooser);\n-static guint (*fp_gtk_g_slist_length)(GSList *list);\n-static gulong (*fp_g_signal_connect_data)(gpointer instance,\n-    const gchar *detailed_signal, GCallback c_handler, gpointer data,\n-    GClosureNotify destroy_data, GConnectFlags connect_flags);\n-static void (*fp_gtk_widget_show)(void *widget);\n-static void (*fp_gtk_main)(void);\n-static guint (*fp_gtk_main_level)(void);\n-static gchar* (*fp_g_path_get_dirname) (const gchar *file_name);\n-static XID (*fp_gdk_x11_drawable_get_xid) (GdkWindow *drawable);\n-\n-static GList* (*fp_g_list_append) (GList *list, gpointer data);\n-static void (*fp_g_list_free) (GList *list);\n-static void (*fp_g_list_free_full) (GList *list, GDestroyNotify free_func);\n-\n-static gboolean (*fp_gtk_show_uri)(GdkScreen *screen, const gchar *uri,\n-    guint32 timestamp, GError **error);\n-\n-#endif \/* !_GTK2_INTERFACE_H *\/\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk2_interface.h","additions":0,"deletions":448,"binary":false,"changes":448,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,1 +35,0 @@\n-GtkApi* gtk2_load(JNIEnv *env, const char* lib_name);\n@@ -38,1 +37,0 @@\n-gboolean gtk2_check(const char* lib_name, gboolean load);\n@@ -59,7 +57,0 @@\n-    {\n-        GTK_2,\n-        JNI_LIB_NAME(\"gtk-x11-2.0\"),\n-        VERSIONED_JNI_LIB_NAME(\"gtk-x11-2.0\", \"0\"),\n-        &gtk2_load,\n-        &gtk2_check\n-    }\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/gtk_interface.c","additions":1,"deletions":10,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -796,2 +796,0 @@\n-    int                 count=0 ;\n-\n@@ -826,2 +824,0 @@\n-                count++;\n-\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/multiVis.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -678,1 +678,0 @@\n-\/\/glib_version_2_68 false for gtk2, as it comes from gtk3_interface.c\n","filename":"src\/java.desktop\/unix\/native\/libawt_xawt\/awt\/screencast_pipewire.c","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -212,1 +212,1 @@\n-    Atom type, atom, actual_type;\n+    Atom atom, actual_type;\n@@ -254,2 +254,0 @@\n-    XSizeHints sizeHints;\n-\n@@ -743,1 +741,0 @@\n-    int rc;\n@@ -747,1 +744,1 @@\n-    rc = pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n+    pthread_create(&thr, &attr, SplashScreenThread, (void *) splash);\n","filename":"src\/java.desktop\/unix\/native\/libsplashscreen\/splashscreen_sys.c","additions":2,"deletions":5,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/PlatformGraphicsInfo.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -171,1 +171,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/awt\/windows\/WToolkit.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -57,1 +57,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.desktop\/windows\/classes\/sun\/print\/PrintServiceLookupProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-    _snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n+    snprintf(assertMsg, ASSERT_MSG_SIZE, AssertFmt, expr, file, line, lastError, msgBuffer);\n","filename":"src\/java.desktop\/windows\/native\/libawt\/windows\/awt_Debug.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -66,0 +66,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/java.instrument\/share\/classes\/sun\/instrument\/InstrumentationImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,0 @@\n- * <blockquote>\n@@ -133,1 +132,0 @@\n- * <\/blockquote>\n@@ -1023,1 +1021,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.management\/share\/classes\/java\/lang\/management\/ManagementFactory.java","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,0 +47,1 @@\n+import jdk.internal.net.http.common.Log;\n@@ -495,1 +496,1 @@\n-    private void removeFromPool(HttpConnection c) {\n+    private boolean removeFromPool(HttpConnection c) {\n@@ -498,1 +499,1 @@\n-            removeFromPool(c, plainPool);\n+            return removeFromPool(c, plainPool);\n@@ -501,1 +502,1 @@\n-            removeFromPool(c, sslPool);\n+            return removeFromPool(c, sslPool);\n@@ -527,1 +528,1 @@\n-    void cleanup(HttpConnection c, Throwable error) {\n+    void cleanup(HttpConnection c, long pendingData, Throwable error) {\n@@ -532,0 +533,1 @@\n+        boolean removed;\n@@ -533,1 +535,1 @@\n-            removeFromPool(c);\n+            removed = removeFromPool(c);\n@@ -538,1 +540,18 @@\n-        c.close();\n+        if (!removed && pendingData != 0) {\n+            \/\/ this should not happen; the cleanup may have consumed\n+            \/\/ some data that wasn't supposed to be consumed, so\n+            \/\/ the only thing we can do is log it and close the\n+            \/\/ connection.\n+            if (Log.errors()) {\n+                Log.logError(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing {0}\", c.dbgString());\n+            }\n+            if (debug.on()) {\n+                debug.log(\"WARNING: CleanupTrigger triggered for\" +\n+                        \" a connection not found in the pool: closing %s\", c.dbgString());\n+            }\n+            Throwable cause = new IOException(\"Unexpected cleanup triggered for non pooled connection\", error);\n+            c.close(cause);\n+        } else {\n+            c.close();\n+        }\n@@ -552,0 +571,1 @@\n+        private volatile boolean dropped;\n@@ -559,1 +579,1 @@\n-        private void triggerCleanup(Throwable error) {\n+        private void triggerCleanup(long pendingData, Throwable error) {\n@@ -561,1 +581,4 @@\n-            cleanup(connection, error);\n+            if (debug.on()) {\n+                debug.log(\"Cleanup triggered for %s: pendingData:%s error:%s\", this, pendingData, error);\n+            }\n+            cleanup(connection, pendingData, error);\n@@ -569,0 +592,1 @@\n+            if (dropped || done) return;\n@@ -572,1 +596,1 @@\n-        public void onError(Throwable error) { triggerCleanup(error); }\n+        public void onError(Throwable error) { triggerCleanup(0, error); }\n@@ -574,1 +598,1 @@\n-        public void onComplete() { triggerCleanup(null); }\n+        public void onComplete() { triggerCleanup(0, null); }\n@@ -577,1 +601,1 @@\n-            triggerCleanup(new IOException(\"Data received while in pool\"));\n+            triggerCleanup(Utils.remaining(item), new IOException(\"Data received while in pool\"));\n@@ -589,0 +613,5 @@\n+\n+        @Override\n+        public void dropSubscription() {\n+            dropped = true;\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ConnectionPool.java","additions":41,"deletions":12,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,0 +42,2 @@\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n@@ -456,0 +458,7 @@\n+\n+        long responseTimeoutMillis = 5000;\n+        if (request.timeout().isPresent()) {\n+            final long timeoutMillis = request.timeout().get().toMillis();\n+            responseTimeoutMillis = Math.min(responseTimeoutMillis, timeoutMillis);\n+        }\n+\n@@ -457,0 +466,1 @@\n+                .completeOnTimeout(null, responseTimeoutMillis, TimeUnit.MILLISECONDS)\n@@ -458,24 +468,39 @@\n-            Log.logResponse(r1::toString);\n-            int rcode = r1.statusCode();\n-            if (rcode == 100) {\n-                Log.logTrace(\"Received 100-Continue: sending body\");\n-                if (debug.on()) debug.log(\"Received 100-Continue for %s\", r1);\n-                CompletableFuture<Response> cf =\n-                        exchImpl.sendBodyAsync()\n-                                .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n-                cf = wrapForUpgrade(cf);\n-                cf = wrapForLog(cf);\n-                return cf;\n-            } else {\n-                Log.logTrace(\"Expectation failed: Received {0}\",\n-                        rcode);\n-                if (debug.on()) debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n-                if (upgrading && rcode == 101) {\n-                    IOException failed = new IOException(\n-                            \"Unable to handle 101 while waiting for 100\");\n-                    return MinimalFuture.failedFuture(failed);\n-                }\n-                exchImpl.expectContinueFailed(rcode);\n-                return MinimalFuture.completedFuture(r1);\n-            }\n-        });\n+                    \/\/ The response will only be null if there was a timeout\n+                    \/\/ send body regardless\n+                    if (r1 == null) {\n+                        if (debug.on())\n+                            debug.log(\"Setting ExpectTimeoutRaised and sending request body\");\n+                        exchImpl.setExpectTimeoutRaised();\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    }\n+\n+                    Log.logResponse(r1::toString);\n+                    int rcode = r1.statusCode();\n+                    if (rcode == 100) {\n+                        Log.logTrace(\"Received 100-Continue: sending body\");\n+                        if (debug.on())\n+                            debug.log(\"Received 100-Continue for %s\", r1);\n+                        CompletableFuture<Response> cf =\n+                                exchImpl.sendBodyAsync()\n+                                        .thenCompose(exIm -> exIm.getResponseAsync(parentExecutor));\n+                        cf = wrapForUpgrade(cf);\n+                        cf = wrapForLog(cf);\n+                        return cf;\n+                    } else {\n+                        Log.logTrace(\"Expectation failed: Received {0}\", rcode);\n+                        if (debug.on())\n+                            debug.log(\"Expect-Continue failed (%d) for: %s\", rcode, r1);\n+                        if (upgrading && rcode == 101) {\n+                            IOException failed = new IOException(\n+                                    \"Unable to handle 101 while waiting for 100\");\n+                            return MinimalFuture.failedFuture(failed);\n+                        }\n+                        exchImpl.expectContinueFailed(rcode);\n+                        return MinimalFuture.completedFuture(r1);\n+                    }\n+                });\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Exchange.java","additions":50,"deletions":25,"binary":false,"changes":75,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -61,0 +61,6 @@\n+    private volatile boolean expectTimeoutRaised;\n+\n+    \/\/ this will be set to true only when the peer explicitly states (through a GOAWAY frame or\n+    \/\/ a relevant error code in reset frame) that the corresponding stream (id) wasn't processed\n+    private volatile boolean unprocessedByPeer;\n+\n@@ -70,0 +76,8 @@\n+    final void setExpectTimeoutRaised() {\n+        expectTimeoutRaised = true;\n+    }\n+\n+    final boolean expectTimeoutRaised() {\n+        return expectTimeoutRaised;\n+    }\n+\n@@ -268,0 +282,9 @@\n+\n+    final boolean isUnprocessedByPeer() {\n+        return this.unprocessedByPeer;\n+    }\n+\n+    \/\/ Marks the exchange as unprocessed by the peer\n+    final void markUnprocessedByPeer() {\n+        this.unprocessedByPeer = true;\n+    }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/ExchangeImpl.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,0 +50,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n@@ -361,0 +363,1 @@\n+    private final AtomicLong lastProcessedStreamInGoAway = new AtomicLong(-1);\n@@ -728,1 +731,3 @@\n-            if (connection.channel().isOpen()) {\n+            \/\/ we send a GOAWAY frame only if the remote side hasn't already indicated\n+            \/\/ the intention to close the connection by previously sending a GOAWAY of its own\n+            if (connection.channel().isOpen() && !isMarked(closedState, HALF_CLOSED_REMOTE)) {\n@@ -1208,7 +1213,40 @@\n-    private void handleGoAway(GoAwayFrame frame)\n-        throws IOException\n-    {\n-        if (markHalfClosedLRemote()) {\n-            shutdown(new IOException(\n-                    connection.channel().getLocalAddress()\n-                            + \": GOAWAY received\"));\n+    private void handleGoAway(final GoAwayFrame frame) {\n+        final long lastProcessedStream = frame.getLastStream();\n+        assert lastProcessedStream >= 0 : \"unexpected last stream id: \"\n+                + lastProcessedStream + \" in GOAWAY frame\";\n+\n+        markHalfClosedRemote();\n+        setFinalStream(); \/\/ don't allow any new streams on this connection\n+        if (debug.on()) {\n+            debug.log(\"processing incoming GOAWAY with last processed stream id:%s in frame %s\",\n+                    lastProcessedStream, frame);\n+        }\n+        \/\/ see if this connection has previously received a GOAWAY from the peer and if yes\n+        \/\/ then check if this new last processed stream id is lesser than the previous\n+        \/\/ known last processed stream id. Only update the last processed stream id if the new\n+        \/\/ one is lesser than the previous one.\n+        long prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        while (prevLastProcessed == -1 || lastProcessedStream < prevLastProcessed) {\n+            if (lastProcessedStreamInGoAway.compareAndSet(prevLastProcessed,\n+                    lastProcessedStream)) {\n+                break;\n+            }\n+            prevLastProcessed = lastProcessedStreamInGoAway.get();\n+        }\n+        handlePeerUnprocessedStreams(lastProcessedStreamInGoAway.get());\n+    }\n+\n+    private void handlePeerUnprocessedStreams(final long lastProcessedStream) {\n+        final AtomicInteger numClosed = new AtomicInteger(); \/\/ atomic merely to allow usage within lambda\n+        streams.forEach((id, exchange) -> {\n+            if (id > lastProcessedStream) {\n+                \/\/ any streams with an stream id higher than the last processed stream\n+                \/\/ can be retried (on a new connection). we close the exchange as unprocessed\n+                \/\/ to facilitate the retrying.\n+                client2.client().theExecutor().ensureExecutedAsync(exchange::closeAsUnprocessed);\n+                numClosed.incrementAndGet();\n+            }\n+        });\n+        if (debug.on()) {\n+            debug.log(numClosed.get() + \" stream(s), with id greater than \" + lastProcessedStream\n+                    + \", will be closed as unprocessed\");\n@@ -1748,1 +1786,1 @@\n-    private boolean markHalfClosedLRemote() {\n+    private boolean markHalfClosedRemote() {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Http2Connection.java","additions":48,"deletions":10,"binary":false,"changes":58,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -93,1 +93,1 @@\n-    volatile boolean expiredOnce;\n+    volatile boolean retriedOnce;\n@@ -472,1 +472,1 @@\n-                                expiredOnce = false;\n+                                retriedOnce = false;\n@@ -485,1 +485,1 @@\n-                        CompletableFuture<Response> errorCF = getExceptionalCF(ex);\n+                        CompletableFuture<Response> errorCF = getExceptionalCF(ex, exch.exchImpl);\n@@ -557,1 +557,1 @@\n-    private CompletableFuture<Response> getExceptionalCF(Throwable t) {\n+    private CompletableFuture<Response> getExceptionalCF(Throwable t, ExchangeImpl<?> exchImpl) {\n@@ -563,0 +563,1 @@\n+        final boolean retryAsUnprocessed = exchImpl != null && exchImpl.isUnprocessedByPeer();\n@@ -567,1 +568,1 @@\n-        } else if (retryOnFailure(t)) {\n+        } else if (retryAsUnprocessed || retryOnFailure(t)) {\n@@ -574,2 +575,4 @@\n-                if (!canRetryRequest(currentreq)) {\n-                    return failedFuture(cause); \/\/ fails with original cause\n+                if (!retryAsUnprocessed && !canRetryRequest(currentreq)) {\n+                    \/\/ a (peer) processed request which cannot be retried, fail with\n+                    \/\/ the original cause\n+                    return failedFuture(cause);\n@@ -581,1 +584,1 @@\n-            if (!expiredOnce) {\n+            if (!retriedOnce) {\n@@ -584,1 +587,1 @@\n-                            + \" (async): retrying due to: \", t);\n+                            + \" (async): retrying \" + currentreq + \" due to: \", t);\n@@ -586,1 +589,1 @@\n-                expiredOnce = true;\n+                retriedOnce = true;\n@@ -597,1 +600,1 @@\n-                            + \" (async): already retried once.\", t);\n+                            + \" (async): already retried once \" + currentreq, t);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/MultiExchange.java","additions":15,"deletions":12,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -32,0 +32,1 @@\n+import java.util.concurrent.ConcurrentLinkedQueue;\n@@ -560,1 +561,1 @@\n-        AtomicReference<ReadSubscription> pendingSubscription = new AtomicReference<>();\n+        ConcurrentLinkedQueue<ReadSubscription> pendingSubscriptions = new ConcurrentLinkedQueue<>();\n@@ -568,4 +569,2 @@\n-            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n-            ReadSubscription previous = pendingSubscription.getAndSet(target);\n-\n-            if (previous != null && previous != target) {\n+            ReadSubscription previous;\n+            while ((previous = pendingSubscriptions.poll()) != null) {\n@@ -576,0 +575,2 @@\n+                \/\/ make sure no data will be routed to the old subscriber.\n+                previous.stopReading();\n@@ -583,0 +584,2 @@\n+            ReadSubscription target = new ReadSubscription(subscriptionImpl, sub);\n+            pendingSubscriptions.offer(target);\n@@ -584,1 +587,1 @@\n-            if (debug.on()) debug.log(\"read publisher got subscriber\");\n+            if (debug.on()) debug.log(\"read publisher got new subscriber: \" + s);\n@@ -609,0 +612,1 @@\n+            private volatile boolean stopped;\n@@ -626,1 +630,2 @@\n-                if (!cancelled) {\n+                if (!cancelled && !stopped) {\n+                    \/\/ should be safe to not synchronize here.\n@@ -630,1 +635,1 @@\n-                        debug.log(\"subscription cancelled, ignoring request %d\", n);\n+                        debug.log(\"subscription stopped or cancelled, ignoring request %d\", n);\n@@ -664,0 +669,26 @@\n+\n+            \/**\n+             * Called when switching subscriber on the {@link InternalReadSubscription}.\n+             * This subscriber is the old subscriber. Demand on the internal\n+             * subscription will be reset and reading will be paused until the\n+             * new subscriber is subscribed.\n+             * This should ensure that no data is routed to this subscriber\n+             * until the new subscriber is subscribed.\n+             *\/\n+            synchronized void stopReading() {\n+                stopped = true;\n+                impl.demand.reset();\n+            }\n+\n+            synchronized boolean tryDecrementDemand() {\n+                if (stopped) return false;\n+                return impl.demand.tryDecrement();\n+            }\n+\n+            synchronized boolean isStopped() {\n+                return stopped;\n+            }\n+\n+            synchronized void increaseDemand(long n) {\n+                if (!stopped) impl.demand.increase(n);\n+            }\n@@ -838,1 +869,1 @@\n-                        if (demand.tryDecrement()) {\n+                        if (current.tryDecrementDemand()) {\n@@ -884,2 +915,4 @@\n-                                    demand.increase(1);\n-                                    resumeReadEvent();\n+                                    if (!current.isStopped()) {\n+                                        current.increaseDemand(1);\n+                                        resumeReadEvent();\n+                                    }\n@@ -925,4 +958,6 @@\n-                ReadSubscription pending = pendingSubscription.getAndSet(null);\n-                if (pending == null) return false;\n-                if (debug.on())\n-                    debug.log(\"handling pending subscription for %s\",\n+                ReadSubscription pending;\n+                boolean subscribed = false;\n+                while ((pending = pendingSubscriptions.poll()) != null) {\n+                    subscribed = true;\n+                    if (debug.on())\n+                        debug.log(\"handling pending subscription for %s\",\n@@ -930,15 +965,8 @@\n-                ReadSubscription current = subscription;\n-                if (current != null && current != pending && !completed) {\n-                    current.subscriber.dropSubscription();\n-                }\n-                if (debug.on()) debug.log(\"read demand reset to 0\");\n-                subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n-                pending.errorRef.compareAndSet(null, errorRef.get());\n-                if (!readScheduler.isStopped()) {\n-                    subscription = pending;\n-                } else {\n-                    if (debug.on()) debug.log(\"socket tube is already stopped\");\n-                }\n-                if (debug.on()) debug.log(\"calling onSubscribe\");\n-                pending.signalOnSubscribe();\n-                if (completed) {\n+                    ReadSubscription current = subscription;\n+                    if (current != null && current != pending && !completed) {\n+                        debug.log(\"dropping pending subscription for current %s\",\n+                                current.subscriber);\n+                        current.subscriber.dropSubscription();\n+                    }\n+                    if (debug.on()) debug.log(\"read demand reset to 0\");\n+                    subscriptionImpl.demand.reset(); \/\/ subscriber will increase demand if it needs to.\n@@ -946,1 +974,11 @@\n-                    pending.signalCompletion();\n+                    if (!readScheduler.isStopped()) {\n+                        subscription = pending;\n+                    } else {\n+                        if (debug.on()) debug.log(\"socket tube is already stopped\");\n+                    }\n+                    if (debug.on()) debug.log(\"calling onSubscribe on \" + pending.subscriber);\n+                    pending.signalOnSubscribe();\n+                    if (completed) {\n+                        pending.errorRef.compareAndSet(null, errorRef.get());\n+                        pending.signalCompletion();\n+                    }\n@@ -948,1 +986,1 @@\n-                return true;\n+                return subscribed;\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/SocketTube.java","additions":71,"deletions":33,"binary":false,"changes":104,"status":"modified"},{"patch":"@@ -644,6 +644,24 @@\n-                int error = frame.getErrorCode();\n-                IOException e = new IOException(\"Received RST_STREAM: \"\n-                        + ErrorFrame.stringForCode(error));\n-                if (errorRef.compareAndSet(null, e)) {\n-                    if (subscriber != null) {\n-                        subscriber.onError(e);\n+                final int error = frame.getErrorCode();\n+                \/\/ A REFUSED_STREAM error code implies that the stream wasn't processed by the\n+                \/\/ peer and the client is free to retry the request afresh.\n+                if (error == ErrorFrame.REFUSED_STREAM) {\n+                    \/\/ Here we arrange for the request to be retried. Note that we don't call\n+                    \/\/ closeAsUnprocessed() method here because the \"closed\" state is already set\n+                    \/\/ to true a few lines above and calling close() from within\n+                    \/\/ closeAsUnprocessed() will end up being a no-op. We instead do the additional\n+                    \/\/ bookkeeping here.\n+                    markUnprocessedByPeer();\n+                    errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+                    if (debug.on()) {\n+                        debug.log(\"request unprocessed by peer (REFUSED_STREAM) \" + this.request);\n+                    }\n+                } else {\n+                    final String reason = ErrorFrame.stringForCode(error);\n+                    final IOException failureCause = new IOException(\"Received RST_STREAM: \" + reason);\n+                    if (debug.on()) {\n+                        debug.log(streamid + \" received RST_STREAM with code: \" + reason);\n+                    }\n+                    if (errorRef.compareAndSet(null, failureCause)) {\n+                        if (subscriber != null) {\n+                            subscriber.onError(failureCause);\n+                        }\n@@ -652,1 +670,2 @@\n-                completeResponseExceptionally(e);\n+                final Throwable failureCause = errorRef.get();\n+                completeResponseExceptionally(failureCause);\n@@ -654,1 +673,1 @@\n-                    requestBodyCF.completeExceptionally(errorRef.get()); \/\/ we may be sending the body..\n+                    requestBodyCF.completeExceptionally(failureCause); \/\/ we may be sending the body..\n@@ -657,1 +676,1 @@\n-                    responseBodyCF.completeExceptionally(errorRef.get());\n+                    responseBodyCF.completeExceptionally(failureCause);\n@@ -1184,2 +1203,7 @@\n-                \/\/ it will be already completed.\n-                cf = response_cfs.remove(0);\n+                \/\/ it will be already completed, unless the expect continue\n+                \/\/ timeout fired\n+                cf = response_cfs.get(0);\n+                if (cf.isDone()) {\n+                    cf = response_cfs.remove(0);\n+                }\n+\n@@ -1188,1 +1212,2 @@\n-                assert cf.isDone() : \"Removing uncompleted response: could cause code to hang!\";\n+                assert cf.isDone() || request.expectContinue && expectTimeoutRaised()\n+                        : \"Removing uncompleted response: could cause code to hang!\";\n@@ -1223,1 +1248,1 @@\n-                if (!cf.isDone()) {\n+                if (!cf.isDone() && !expectTimeoutRaised()) {\n@@ -1231,0 +1256,8 @@\n+                } else if (expectTimeoutRaised()) {\n+                    Log.logTrace(\"Completing response (streamid={0}): {1}\",\n+                            streamid, cf);\n+                    if (debug.on())\n+                        debug.log(\"Completing responseCF(%d) with response headers\", i);\n+                    \/\/ The Request will be removed in getResponseAsync()\n+                    cf.complete(resp);\n+                    return;\n@@ -1666,1 +1699,29 @@\n-        return connection.dbgString() + \"\/Stream(\"+streamid+\")\";\n+        final int id = streamid;\n+        final String sid = id == 0 ? \"?\" : String.valueOf(id);\n+        return connection.dbgString() + \"\/Stream(\" + sid + \")\";\n+    }\n+\n+    \/**\n+     * An unprocessed exchange is one that hasn't been processed by a peer. The local end of the\n+     * connection would be notified about such exchanges when it receives a GOAWAY frame with\n+     * a stream id that tells which exchanges have been unprocessed.\n+     * This method is called on such unprocessed exchanges and the implementation of this method\n+     * will arrange for the request, corresponding to this exchange, to be retried afresh on a\n+     * new connection.\n+     *\/\n+    void closeAsUnprocessed() {\n+        try {\n+            \/\/ We arrange for the request to be retried on a new connection as allowed by the RFC-9113\n+            markUnprocessedByPeer();\n+            this.errorRef.compareAndSet(null, new IOException(\"request not processed by peer\"));\n+            if (debug.on()) {\n+                debug.log(\"closing \" + this.request + \" as unprocessed by peer\");\n+            }\n+            \/\/ close the exchange and complete the response CF exceptionally\n+            close();\n+            completeResponseExceptionally(this.errorRef.get());\n+        } finally {\n+            \/\/ decrementStreamsCount isn't really needed but we do it to make sure\n+            \/\/ the log messages, where these counts\/states get reported, show the accurate state.\n+            connection.decrementStreamsCount(streamid);\n+        }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":75,"deletions":14,"binary":false,"changes":89,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -103,1 +103,6 @@\n-            \/\/ Odd stream numbers (client streams) should have been registered.\n+            \/\/ A client initiated stream might be closed (as unprocessed, due to a\n+            \/\/ GOAWAY received on the connection) even before the stream is\n+            \/\/ registered with this WindowController instance (when sending out request headers).\n+            \/\/ Thus, for client initiated streams, we don't enforce the presence of the\n+            \/\/ stream in the registered \"streams\" map.\n+\n@@ -107,3 +112,1 @@\n-            if (old == null && isClientStream) {\n-                throw new InternalError(\"Expected entry for streamid: \" + streamid);\n-            } else if (old != null && !isClientStream) {\n+            if (old != null && !isClientStream) {\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/WindowController.java","additions":8,"deletions":5,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -183,0 +183,4 @@\n+            @Override\n+            public String toString() {\n+                return \"TubeSubscriberWrapper(\"+delegate.toString()+\")\";\n+            }\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/common\/FlowTube.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -60,1 +60,3 @@\n-        return super.toString() + \" Debugdata: \" + new String(debugData, UTF_8);\n+        return super.toString()\n+                + \" lastStreamId=\" + lastStream\n+                + \", Debugdata: \" + new String(debugData, UTF_8);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/frame\/GoAwayFrame.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1,691 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package jdk.internal.net.http.hpack;\n-\n-import java.io.IOException;\n-import java.nio.ByteBuffer;\n-\n-import static java.lang.String.format;\n-\n-\/**\n- * Huffman coding table.\n- *\n- * <p> Instances of this class are safe for use by multiple threads.\n- *\n- * @since 9\n- *\/\n-public final class NaiveHuffman {\n-\n-    \/\/ TODO: check if reset is done in both reader and writer\n-\n-    static final class Reader implements Huffman.Reader {\n-\n-        private Node curr; \/\/ position in the trie\n-        private int len;   \/\/ length of the path from the root to 'curr'\n-        private int p;     \/\/ byte probe\n-\n-        {\n-            reset();\n-        }\n-\n-        @Override\n-        public void read(ByteBuffer source,\n-                         Appendable destination,\n-                         boolean isLast) throws IOException {\n-            read(source, destination, true, isLast);\n-        }\n-\n-        \/\/ Takes 'isLast' rather than returns whether the reading is done or\n-        \/\/ not, for more informative exceptions.\n-        void read(ByteBuffer source,\n-                  Appendable destination,\n-                  boolean reportEOS, \/* reportEOS is exposed for tests *\/\n-                  boolean isLast) throws IOException {\n-            Node c = curr;\n-            int l = len;\n-            \/*\n-               Since ByteBuffer is itself stateful, its position is\n-               remembered here NOT as a part of Reader's state,\n-               but to set it back in the case of a failure\n-             *\/\n-            int pos = source.position();\n-\n-            while (source.hasRemaining()) {\n-                int d = source.get();\n-                for (; p != 0; p >>= 1) {\n-                    c = c.getChild(p & d);\n-                    l++;\n-                    if (c.isLeaf()) {\n-                        if (reportEOS && c.isEOSPath) {\n-                            throw new IOException(\"Encountered EOS\");\n-                        }\n-                        char ch;\n-                        try {\n-                            ch = c.getChar();\n-                        } catch (IllegalStateException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw new IOException(e);\n-                        }\n-                        try {\n-                            destination.append(ch);\n-                        } catch (IOException e) {\n-                            source.position(pos); \/\/ do we need this?\n-                            throw e;\n-                        }\n-                        c = INSTANCE.root;\n-                        l = 0;\n-                    }\n-                    curr = c;\n-                    len = l;\n-                }\n-                resetProbe();\n-                pos++;\n-            }\n-            if (!isLast) {\n-                return; \/\/ it's too early to jump to any conclusions, let's wait\n-            }\n-            if (c.isLeaf()) {\n-                return; \/\/ it's perfectly ok, no extra padding bits\n-            }\n-            if (c.isEOSPath && len <= 7) {\n-                return; \/\/ it's ok, some extra padding bits\n-            }\n-            if (c.isEOSPath) {\n-                throw new IOException(\n-                        \"Padding is too long (len=\" + len + \") \" +\n-                                \"or unexpected end of data\");\n-            }\n-            throw new IOException(\n-                    \"Not a EOS prefix padding or unexpected end of data\");\n-        }\n-\n-        @Override\n-        public void reset() {\n-            curr = INSTANCE.root;\n-            len = 0;\n-            resetProbe();\n-        }\n-\n-        private void resetProbe() {\n-            p = 0x80;\n-        }\n-    }\n-\n-    static final class Writer implements Huffman.Writer {\n-\n-        private int pos;       \/\/ position in 'source'\n-        private int avail = 8; \/\/ number of least significant bits available in 'curr'\n-        private int curr;      \/\/ next byte to put to the destination\n-        private int rem;       \/\/ number of least significant bits in 'code' yet to be processed\n-        private int code;      \/\/ current code being written\n-\n-        private CharSequence source;\n-        private int end;\n-\n-        @Override\n-        public Writer from(CharSequence input, int start, int end) {\n-            if (start < 0 || end < 0 || end > input.length() || start > end) {\n-                throw new IndexOutOfBoundsException(\n-                        String.format(\"input.length()=%s, start=%s, end=%s\",\n-                                      input.length(), start, end));\n-            }\n-            pos = start;\n-            this.end = end;\n-            this.source = input;\n-            return this;\n-        }\n-\n-        @Override\n-        public boolean write(ByteBuffer destination) {\n-            for (; pos < end; pos++) {\n-                if (rem == 0) {\n-                    Code desc = INSTANCE.codeOf(source.charAt(pos));\n-                    rem = desc.length;\n-                    code = desc.code;\n-                }\n-                while (rem > 0) {\n-                    if (rem < avail) {\n-                        curr |= (code << (avail - rem));\n-                        avail -= rem;\n-                        rem = 0;\n-                    } else {\n-                        int c = (curr | (code >>> (rem - avail)));\n-                        if (destination.hasRemaining()) {\n-                            destination.put((byte) c);\n-                        } else {\n-                            return false;\n-                        }\n-                        curr = c;\n-                        code <<= (32 - rem + avail);  \/\/ throw written bits off the cliff (is this Sparta?)\n-                        code >>>= (32 - rem + avail); \/\/ return to the position\n-                        rem -= avail;\n-                        curr = 0;\n-                        avail = 8;\n-                    }\n-                }\n-            }\n-\n-            if (avail < 8) { \/\/ have to pad\n-                if (destination.hasRemaining()) {\n-                    destination.put((byte) (curr | (INSTANCE.EOS.code >>> (INSTANCE.EOS.length - avail))));\n-                    avail = 8;\n-                } else {\n-                    return false;\n-                }\n-            }\n-\n-            return true;\n-        }\n-\n-        @Override\n-        public Writer reset() {\n-            source = null;\n-            end = -1;\n-            pos = -1;\n-            avail = 8;\n-            curr = 0;\n-            code = 0;\n-            return this;\n-        }\n-\n-        @Override\n-        public int lengthOf(CharSequence value, int start, int end) {\n-            return INSTANCE.lengthOf(value, start, end);\n-        }\n-    }\n-\n-    \/**\n-     * Shared instance.\n-     *\/\n-    public static final NaiveHuffman INSTANCE = new NaiveHuffman();\n-\n-    private final Code EOS = new Code(0x3fffffff, 30);\n-    private final Code[] codes = new Code[257];\n-    private final Node root = new Node() {\n-        @Override\n-        public String toString() { return \"root\"; }\n-    };\n-\n-    \/\/ TODO: consider builder and immutable trie\n-    private NaiveHuffman() {\n-        \/\/ @formatter:off\n-        addChar(0,   0x1ff8,     13);\n-        addChar(1,   0x7fffd8,   23);\n-        addChar(2,   0xfffffe2,  28);\n-        addChar(3,   0xfffffe3,  28);\n-        addChar(4,   0xfffffe4,  28);\n-        addChar(5,   0xfffffe5,  28);\n-        addChar(6,   0xfffffe6,  28);\n-        addChar(7,   0xfffffe7,  28);\n-        addChar(8,   0xfffffe8,  28);\n-        addChar(9,   0xffffea,   24);\n-        addChar(10,  0x3ffffffc, 30);\n-        addChar(11,  0xfffffe9,  28);\n-        addChar(12,  0xfffffea,  28);\n-        addChar(13,  0x3ffffffd, 30);\n-        addChar(14,  0xfffffeb,  28);\n-        addChar(15,  0xfffffec,  28);\n-        addChar(16,  0xfffffed,  28);\n-        addChar(17,  0xfffffee,  28);\n-        addChar(18,  0xfffffef,  28);\n-        addChar(19,  0xffffff0,  28);\n-        addChar(20,  0xffffff1,  28);\n-        addChar(21,  0xffffff2,  28);\n-        addChar(22,  0x3ffffffe, 30);\n-        addChar(23,  0xffffff3,  28);\n-        addChar(24,  0xffffff4,  28);\n-        addChar(25,  0xffffff5,  28);\n-        addChar(26,  0xffffff6,  28);\n-        addChar(27,  0xffffff7,  28);\n-        addChar(28,  0xffffff8,  28);\n-        addChar(29,  0xffffff9,  28);\n-        addChar(30,  0xffffffa,  28);\n-        addChar(31,  0xffffffb,  28);\n-        addChar(32,  0x14,        6);\n-        addChar(33,  0x3f8,      10);\n-        addChar(34,  0x3f9,      10);\n-        addChar(35,  0xffa,      12);\n-        addChar(36,  0x1ff9,     13);\n-        addChar(37,  0x15,        6);\n-        addChar(38,  0xf8,        8);\n-        addChar(39,  0x7fa,      11);\n-        addChar(40,  0x3fa,      10);\n-        addChar(41,  0x3fb,      10);\n-        addChar(42,  0xf9,        8);\n-        addChar(43,  0x7fb,      11);\n-        addChar(44,  0xfa,        8);\n-        addChar(45,  0x16,        6);\n-        addChar(46,  0x17,        6);\n-        addChar(47,  0x18,        6);\n-        addChar(48,  0x0,         5);\n-        addChar(49,  0x1,         5);\n-        addChar(50,  0x2,         5);\n-        addChar(51,  0x19,        6);\n-        addChar(52,  0x1a,        6);\n-        addChar(53,  0x1b,        6);\n-        addChar(54,  0x1c,        6);\n-        addChar(55,  0x1d,        6);\n-        addChar(56,  0x1e,        6);\n-        addChar(57,  0x1f,        6);\n-        addChar(58,  0x5c,        7);\n-        addChar(59,  0xfb,        8);\n-        addChar(60,  0x7ffc,     15);\n-        addChar(61,  0x20,        6);\n-        addChar(62,  0xffb,      12);\n-        addChar(63,  0x3fc,      10);\n-        addChar(64,  0x1ffa,     13);\n-        addChar(65,  0x21,        6);\n-        addChar(66,  0x5d,        7);\n-        addChar(67,  0x5e,        7);\n-        addChar(68,  0x5f,        7);\n-        addChar(69,  0x60,        7);\n-        addChar(70,  0x61,        7);\n-        addChar(71,  0x62,        7);\n-        addChar(72,  0x63,        7);\n-        addChar(73,  0x64,        7);\n-        addChar(74,  0x65,        7);\n-        addChar(75,  0x66,        7);\n-        addChar(76,  0x67,        7);\n-        addChar(77,  0x68,        7);\n-        addChar(78,  0x69,        7);\n-        addChar(79,  0x6a,        7);\n-        addChar(80,  0x6b,        7);\n-        addChar(81,  0x6c,        7);\n-        addChar(82,  0x6d,        7);\n-        addChar(83,  0x6e,        7);\n-        addChar(84,  0x6f,        7);\n-        addChar(85,  0x70,        7);\n-        addChar(86,  0x71,        7);\n-        addChar(87,  0x72,        7);\n-        addChar(88,  0xfc,        8);\n-        addChar(89,  0x73,        7);\n-        addChar(90,  0xfd,        8);\n-        addChar(91,  0x1ffb,     13);\n-        addChar(92,  0x7fff0,    19);\n-        addChar(93,  0x1ffc,     13);\n-        addChar(94,  0x3ffc,     14);\n-        addChar(95,  0x22,        6);\n-        addChar(96,  0x7ffd,     15);\n-        addChar(97,  0x3,         5);\n-        addChar(98,  0x23,        6);\n-        addChar(99,  0x4,         5);\n-        addChar(100, 0x24,        6);\n-        addChar(101, 0x5,         5);\n-        addChar(102, 0x25,        6);\n-        addChar(103, 0x26,        6);\n-        addChar(104, 0x27,        6);\n-        addChar(105, 0x6,         5);\n-        addChar(106, 0x74,        7);\n-        addChar(107, 0x75,        7);\n-        addChar(108, 0x28,        6);\n-        addChar(109, 0x29,        6);\n-        addChar(110, 0x2a,        6);\n-        addChar(111, 0x7,         5);\n-        addChar(112, 0x2b,        6);\n-        addChar(113, 0x76,        7);\n-        addChar(114, 0x2c,        6);\n-        addChar(115, 0x8,         5);\n-        addChar(116, 0x9,         5);\n-        addChar(117, 0x2d,        6);\n-        addChar(118, 0x77,        7);\n-        addChar(119, 0x78,        7);\n-        addChar(120, 0x79,        7);\n-        addChar(121, 0x7a,        7);\n-        addChar(122, 0x7b,        7);\n-        addChar(123, 0x7ffe,     15);\n-        addChar(124, 0x7fc,      11);\n-        addChar(125, 0x3ffd,     14);\n-        addChar(126, 0x1ffd,     13);\n-        addChar(127, 0xffffffc,  28);\n-        addChar(128, 0xfffe6,    20);\n-        addChar(129, 0x3fffd2,   22);\n-        addChar(130, 0xfffe7,    20);\n-        addChar(131, 0xfffe8,    20);\n-        addChar(132, 0x3fffd3,   22);\n-        addChar(133, 0x3fffd4,   22);\n-        addChar(134, 0x3fffd5,   22);\n-        addChar(135, 0x7fffd9,   23);\n-        addChar(136, 0x3fffd6,   22);\n-        addChar(137, 0x7fffda,   23);\n-        addChar(138, 0x7fffdb,   23);\n-        addChar(139, 0x7fffdc,   23);\n-        addChar(140, 0x7fffdd,   23);\n-        addChar(141, 0x7fffde,   23);\n-        addChar(142, 0xffffeb,   24);\n-        addChar(143, 0x7fffdf,   23);\n-        addChar(144, 0xffffec,   24);\n-        addChar(145, 0xffffed,   24);\n-        addChar(146, 0x3fffd7,   22);\n-        addChar(147, 0x7fffe0,   23);\n-        addChar(148, 0xffffee,   24);\n-        addChar(149, 0x7fffe1,   23);\n-        addChar(150, 0x7fffe2,   23);\n-        addChar(151, 0x7fffe3,   23);\n-        addChar(152, 0x7fffe4,   23);\n-        addChar(153, 0x1fffdc,   21);\n-        addChar(154, 0x3fffd8,   22);\n-        addChar(155, 0x7fffe5,   23);\n-        addChar(156, 0x3fffd9,   22);\n-        addChar(157, 0x7fffe6,   23);\n-        addChar(158, 0x7fffe7,   23);\n-        addChar(159, 0xffffef,   24);\n-        addChar(160, 0x3fffda,   22);\n-        addChar(161, 0x1fffdd,   21);\n-        addChar(162, 0xfffe9,    20);\n-        addChar(163, 0x3fffdb,   22);\n-        addChar(164, 0x3fffdc,   22);\n-        addChar(165, 0x7fffe8,   23);\n-        addChar(166, 0x7fffe9,   23);\n-        addChar(167, 0x1fffde,   21);\n-        addChar(168, 0x7fffea,   23);\n-        addChar(169, 0x3fffdd,   22);\n-        addChar(170, 0x3fffde,   22);\n-        addChar(171, 0xfffff0,   24);\n-        addChar(172, 0x1fffdf,   21);\n-        addChar(173, 0x3fffdf,   22);\n-        addChar(174, 0x7fffeb,   23);\n-        addChar(175, 0x7fffec,   23);\n-        addChar(176, 0x1fffe0,   21);\n-        addChar(177, 0x1fffe1,   21);\n-        addChar(178, 0x3fffe0,   22);\n-        addChar(179, 0x1fffe2,   21);\n-        addChar(180, 0x7fffed,   23);\n-        addChar(181, 0x3fffe1,   22);\n-        addChar(182, 0x7fffee,   23);\n-        addChar(183, 0x7fffef,   23);\n-        addChar(184, 0xfffea,    20);\n-        addChar(185, 0x3fffe2,   22);\n-        addChar(186, 0x3fffe3,   22);\n-        addChar(187, 0x3fffe4,   22);\n-        addChar(188, 0x7ffff0,   23);\n-        addChar(189, 0x3fffe5,   22);\n-        addChar(190, 0x3fffe6,   22);\n-        addChar(191, 0x7ffff1,   23);\n-        addChar(192, 0x3ffffe0,  26);\n-        addChar(193, 0x3ffffe1,  26);\n-        addChar(194, 0xfffeb,    20);\n-        addChar(195, 0x7fff1,    19);\n-        addChar(196, 0x3fffe7,   22);\n-        addChar(197, 0x7ffff2,   23);\n-        addChar(198, 0x3fffe8,   22);\n-        addChar(199, 0x1ffffec,  25);\n-        addChar(200, 0x3ffffe2,  26);\n-        addChar(201, 0x3ffffe3,  26);\n-        addChar(202, 0x3ffffe4,  26);\n-        addChar(203, 0x7ffffde,  27);\n-        addChar(204, 0x7ffffdf,  27);\n-        addChar(205, 0x3ffffe5,  26);\n-        addChar(206, 0xfffff1,   24);\n-        addChar(207, 0x1ffffed,  25);\n-        addChar(208, 0x7fff2,    19);\n-        addChar(209, 0x1fffe3,   21);\n-        addChar(210, 0x3ffffe6,  26);\n-        addChar(211, 0x7ffffe0,  27);\n-        addChar(212, 0x7ffffe1,  27);\n-        addChar(213, 0x3ffffe7,  26);\n-        addChar(214, 0x7ffffe2,  27);\n-        addChar(215, 0xfffff2,   24);\n-        addChar(216, 0x1fffe4,   21);\n-        addChar(217, 0x1fffe5,   21);\n-        addChar(218, 0x3ffffe8,  26);\n-        addChar(219, 0x3ffffe9,  26);\n-        addChar(220, 0xffffffd,  28);\n-        addChar(221, 0x7ffffe3,  27);\n-        addChar(222, 0x7ffffe4,  27);\n-        addChar(223, 0x7ffffe5,  27);\n-        addChar(224, 0xfffec,    20);\n-        addChar(225, 0xfffff3,   24);\n-        addChar(226, 0xfffed,    20);\n-        addChar(227, 0x1fffe6,   21);\n-        addChar(228, 0x3fffe9,   22);\n-        addChar(229, 0x1fffe7,   21);\n-        addChar(230, 0x1fffe8,   21);\n-        addChar(231, 0x7ffff3,   23);\n-        addChar(232, 0x3fffea,   22);\n-        addChar(233, 0x3fffeb,   22);\n-        addChar(234, 0x1ffffee,  25);\n-        addChar(235, 0x1ffffef,  25);\n-        addChar(236, 0xfffff4,   24);\n-        addChar(237, 0xfffff5,   24);\n-        addChar(238, 0x3ffffea,  26);\n-        addChar(239, 0x7ffff4,   23);\n-        addChar(240, 0x3ffffeb,  26);\n-        addChar(241, 0x7ffffe6,  27);\n-        addChar(242, 0x3ffffec,  26);\n-        addChar(243, 0x3ffffed,  26);\n-        addChar(244, 0x7ffffe7,  27);\n-        addChar(245, 0x7ffffe8,  27);\n-        addChar(246, 0x7ffffe9,  27);\n-        addChar(247, 0x7ffffea,  27);\n-        addChar(248, 0x7ffffeb,  27);\n-        addChar(249, 0xffffffe,  28);\n-        addChar(250, 0x7ffffec,  27);\n-        addChar(251, 0x7ffffed,  27);\n-        addChar(252, 0x7ffffee,  27);\n-        addChar(253, 0x7ffffef,  27);\n-        addChar(254, 0x7fffff0,  27);\n-        addChar(255, 0x3ffffee,  26);\n-        addEOS (256, EOS.code,   EOS.length);\n-        \/\/ @formatter:on\n-    }\n-\n-\n-    \/**\n-     * Calculates the number of bytes required to represent the given {@code\n-     * CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     *\/\n-    public int lengthOf(CharSequence value) {\n-        return lengthOf(value, 0, value.length());\n-    }\n-\n-    \/**\n-     * Calculates the number of bytes required to represent a subsequence of the\n-     * given {@code CharSequence} with the Huffman coding.\n-     *\n-     * @param value\n-     *         characters\n-     * @param start\n-     *         the start index, inclusive\n-     * @param end\n-     *         the end index, exclusive\n-     *\n-     * @return number of bytes\n-     *\n-     * @throws NullPointerException\n-     *         if the value is null\n-     * @throws IndexOutOfBoundsException\n-     *         if any invocation of {@code value.charAt(i)}, where\n-     *         {@code start <= i < end} would throw an IndexOutOfBoundsException\n-     *\/\n-    public int lengthOf(CharSequence value, int start, int end) {\n-        int len = 0;\n-        for (int i = start; i < end; i++) {\n-            char c = value.charAt(i);\n-            len += INSTANCE.codeOf(c).length;\n-        }\n-        \/\/ Integer division with ceiling, assumption:\n-        assert (len \/ 8 + (len % 8 != 0 ? 1 : 0)) == (len + 7) \/ 8 : len;\n-        return (len + 7) \/ 8;\n-    }\n-\n-    private void addChar(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, false);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addEOS(int c, int code, int bitLength) {\n-        addLeaf(c, code, bitLength, true);\n-        codes[c] = new Code(code, bitLength);\n-    }\n-\n-    private void addLeaf(int c, int code, int bitLength, boolean isEOS) {\n-        if (bitLength < 1) {\n-            throw new IllegalArgumentException(\"bitLength < 1\");\n-        }\n-        Node curr = root;\n-        for (int p = 1 << bitLength - 1; p != 0 && !curr.isLeaf(); p = p >> 1) {\n-            curr.isEOSPath |= isEOS; \/\/ If it's already true, it can't become false\n-            curr = curr.addChildIfAbsent(p & code);\n-        }\n-        curr.isEOSPath |= isEOS; \/\/ The last one needs to have this property as well\n-        if (curr.isLeaf()) {\n-            throw new IllegalStateException(\"Specified code is already taken\");\n-        }\n-        curr.setChar((char) c);\n-    }\n-\n-    private Code codeOf(char c) {\n-        if (c > 255) {\n-            throw new IllegalArgumentException(\"char=\" + ((int) c));\n-        }\n-        return codes[c];\n-    }\n-\n-    \/\/\n-    \/\/ For debugging\/testing purposes\n-    \/\/\n-    Node getRoot() {\n-        return root;\n-    }\n-\n-    \/\/\n-    \/\/ Guarantees:\n-    \/\/\n-    \/\/  if (isLeaf() == true) => getChar() is a legal call\n-    \/\/  if (isLeaf() == false) => getChild(i) is a legal call (though it can\n-    \/\/                                                           return null)\n-    \/\/\n-    static class Node {\n-\n-        Node left;\n-        Node right;\n-        boolean isEOSPath;\n-\n-        boolean charIsSet;\n-        char c;\n-\n-        Node getChild(int selector) {\n-            if (isLeaf()) {\n-                throw new IllegalStateException(\"This is a leaf node\");\n-            }\n-            Node result = selector == 0 ? left : right;\n-            if (result == null) {\n-                throw new IllegalStateException(format(\n-                        \"Node doesn't have a child (selector=%s)\", selector));\n-            }\n-            return result;\n-        }\n-\n-        boolean isLeaf() {\n-            return charIsSet;\n-        }\n-\n-        char getChar() {\n-            if (!isLeaf()) {\n-                throw new IllegalStateException(\"This node is not a leaf node\");\n-            }\n-            return c;\n-        }\n-\n-        void setChar(char c) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\n-                        \"This node has been taken already\");\n-            }\n-            if (left != null || right != null) {\n-                throw new IllegalStateException(\"The node cannot be made \"\n-                                                        + \"a leaf as it's already has a child\");\n-            }\n-            this.c = c;\n-            charIsSet = true;\n-        }\n-\n-        Node addChildIfAbsent(int i) {\n-            if (charIsSet) {\n-                throw new IllegalStateException(\"The node cannot have a child \"\n-                                                        + \"as it's already a leaf node\");\n-            }\n-            Node child;\n-            if (i == 0) {\n-                if ((child = left) == null) {\n-                    child = left = new Node();\n-                }\n-            } else {\n-                if ((child = right) == null) {\n-                    child = right = new Node();\n-                }\n-            }\n-            return child;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            if (isLeaf()) {\n-                if (isEOSPath) {\n-                    return \"EOS\";\n-                } else {\n-                    return format(\"char: (%3s) '%s'\", (int) c, c);\n-                }\n-            }\n-            return \"\/\\\\\";\n-        }\n-    }\n-\n-    \/\/ TODO: value-based class?\n-    \/\/ FIXME: can we re-use Node instead of this class?\n-    private static final class Code {\n-\n-        final int code;\n-        final int length;\n-\n-        private Code(int code, int length) {\n-            this.code = code;\n-            this.length = length;\n-        }\n-\n-        public int getCode() {\n-            return code;\n-        }\n-\n-        public int getLength() {\n-            return length;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            long p = 1 << length;\n-            return Long.toBinaryString(code + p).substring(1)\n-                    + \", length=\" + length;\n-        }\n-    }\n-}\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/hpack\/NaiveHuffman.java","additions":0,"deletions":691,"binary":false,"changes":691,"status":"deleted"},{"patch":"@@ -85,1 +85,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/macosx\/classes\/java\/util\/prefs\/MacOSXPreferencesFile.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,1 +56,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/unix\/classes\/java\/util\/prefs\/FileSystemPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.prefs\/windows\/classes\/java\/util\/prefs\/WindowsPreferences.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -42,1 +42,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.rmi\/share\/classes\/sun\/rmi\/transport\/GC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -71,1 +71,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/jgss\/wrapper\/SunNativeProvider.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -527,1 +527,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/Credentials.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -48,1 +48,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.security.jgss\/share\/classes\/sun\/security\/krb5\/SCDynamicStoreConfig.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -64,1 +64,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/unix\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -44,1 +44,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/java.smartcardio\/windows\/classes\/sun\/security\/smartcardio\/PlatformPCSC.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -163,1 +163,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.accessibility\/windows\/classes\/com\/sun\/java\/accessibility\/internal\/AccessBridge.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1529,2 +1529,2 @@\n-        ::_snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n-                                                    (int) messageCount);\n+        ::snprintf(text, sizeof(text), \"%d of %d\", (int)messageNumber,\n+                                                   (int) messageCount);\n","filename":"src\/jdk.accessibility\/windows\/native\/jaccessinspector\/jaccessinspector.cpp","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -41,0 +41,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/aix\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -43,0 +43,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/linux\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/macosx\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -37,0 +37,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/AttachProviderImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -38,0 +38,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.attach\/windows\/classes\/sun\/tools\/attach\/VirtualMachineImpl.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2341,1 +2341,1 @@\n-        private ErrorType(Type originalType, TypeSymbol tsym,\n+        public ErrorType(Type originalType, TypeSymbol tsym,\n@@ -2396,4 +2396,0 @@\n-        public List<Type> allparams()            { return List.nil(); }\n-        @DefinedBy(Api.LANGUAGE_MODEL)\n-        public List<Type> getTypeArguments()     { return List.nil(); }\n-\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/code\/Type.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -5084,0 +5084,8 @@\n+        } else if (clazztype.hasTag(ERROR)) {\n+            ErrorType parameterizedErroneous =\n+                    new ErrorType(clazztype.getOriginalType(),\n+                                  clazztype.tsym,\n+                                  clazztype.getMetadata());\n+\n+            parameterizedErroneous.typarams_field = actuals;\n+            owntype = parameterizedErroneous;\n@@ -5254,1 +5262,12 @@\n-            Env<AttrContext> errEnv = env.dup(env.tree, env.info.dup());\n+            WriteableScope newScope = env.info.scope;\n+\n+            if (env.tree instanceof JCClassDecl) {\n+                Symbol fakeOwner =\n+                    new MethodSymbol(BLOCK, names.empty, null,\n+                        env.info.scope.owner);\n+                newScope = newScope.dupUnshared(fakeOwner);\n+            }\n+\n+            Env<AttrContext> errEnv =\n+                    env.dup(env.tree,\n+                            env.info.dup(newScope));\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Attr.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -1222,3 +1222,11 @@\n-                Type tDesc = types.findDescriptorType(types.capture(t));\n-                Type tDescNoCapture = types.findDescriptorType(t);\n-                Type sDesc = types.findDescriptorType(s);\n+                Type tDesc;\n+                Type tDescNoCapture;\n+                Type sDesc;\n+                try {\n+                    tDesc = types.findDescriptorType(types.capture(t));\n+                    tDescNoCapture = types.findDescriptorType(t);\n+                    sDesc = types.findDescriptorType(s);\n+                } catch (Types.FunctionDescriptorLookupError ex) {\n+                    \/\/ don't report, a more meaningful error should be reported upstream\n+                    return false;\n+                }\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/comp\/Resolve.java","additions":11,"deletions":3,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -39,1 +39,0 @@\n-import java.util.function.BiFunction;\n@@ -42,0 +41,1 @@\n+import java.util.stream.IntStream;\n@@ -65,0 +65,1 @@\n+import com.sun.tools.javac.resources.CompilerProperties.Errors;\n@@ -2314,3 +2315,11 @@\n-    private static void addTypeAnnotationsToSymbol(\n-            Symbol s, List<Attribute.TypeCompound> attributes) {\n-        new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+    private void addTypeAnnotationsToSymbol(Symbol s, List<Attribute.TypeCompound> attributes) {\n+        try {\n+            new TypeAnnotationSymbolVisitor(attributes).visit(s, null);\n+        } catch (CompletionFailure ex) {\n+            JavaFileObject prev = log.useSource(currentClassFile);\n+            try {\n+                log.error(Errors.CantAttachTypeAnnotations(attributes, s.owner, s.name, ex.getDetailValue()));\n+            } finally {\n+                log.useSource(prev);\n+            }\n+        }\n@@ -2464,4 +2473,0 @@\n-            \/\/ Search the structure of the type to find the contained types at each type path\n-            Map<Type, List<Attribute.TypeCompound>> attributesByType = new HashMap<>();\n-            new TypeAnnotationLocator(attributesByPath, attributesByType).visit(type, List.nil());\n-\n@@ -2469,2 +2474,1 @@\n-            type = new TypeAnnotationTypeMapping(attributesByType).visit(type, null);\n-            Assert.check(attributesByType.isEmpty(), \"Failed to apply annotations to types\");\n+            type = new TypeAnnotationStructuralTypeMapping(attributesByPath).visit(type, List.nil());\n@@ -2498,2 +2502,4 @@\n-     * Visit all contained types, assembling a type path to represent the current location, and\n-     * record the types at each type path that need to be annotated.\n+     * A type mapping that rewrites the type to include type annotations.\n+     *\n+     * <p>This logic is similar to {@link Type.StructuralTypeMapping}, but also tracks the path to\n+     * the contained types being rewritten, and so cannot easily share the existing logic.\n@@ -2501,2 +2507,3 @@\n-    private static class TypeAnnotationLocator\n-            extends Types.DefaultTypeVisitor<Void, List<TypeAnnotationPosition.TypePathEntry>> {\n+    private static final class TypeAnnotationStructuralTypeMapping\n+            extends Types.TypeMapping<List<TypeAnnotationPosition.TypePathEntry>> {\n+\n@@ -2504,2 +2511,1 @@\n-                          ListBuffer<Attribute.TypeCompound>> attributesByPath;\n-        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n+                ListBuffer<Attribute.TypeCompound>> attributesByPath;\n@@ -2507,1 +2513,1 @@\n-        private TypeAnnotationLocator(\n+        private TypeAnnotationStructuralTypeMapping(\n@@ -2509,2 +2515,1 @@\n-                        attributesByPath,\n-                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n+                    attributesByPath) {\n@@ -2512,1 +2517,0 @@\n-            this.attributesByType = attributesByType;\n@@ -2515,0 +2519,1 @@\n+\n@@ -2516,1 +2521,1 @@\n-        public Void visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+        public Type visitClassType(ClassType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n@@ -2522,3 +2527,4 @@\n-            List<ClassType> enclosing = List.nil();\n-            for (Type curr = t;\n-                    curr != null && curr != Type.noType;\n+            Type outer = t.getEnclosingType();\n+            Type outer1 = outer != Type.noType ? visit(outer, path) : outer;\n+            for (Type curr = t.getEnclosingType();\n+                    curr != Type.noType;\n@@ -2526,11 +2532,0 @@\n-                enclosing = enclosing.prepend((ClassType) curr);\n-            }\n-            for (ClassType te : enclosing) {\n-                if (te.typarams_field != null) {\n-                    int i = 0;\n-                    for (Type typaram : te.typarams_field) {\n-                        visit(typaram, path.append(new TypeAnnotationPosition.TypePathEntry(\n-                                TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i++)));\n-                    }\n-                }\n-                visitType(te, path);\n@@ -2539,1 +2534,6 @@\n-            return null;\n+            List<Type> typarams = t.getTypeArguments();\n+            List<Type> typarams1 = rewriteTypeParams(path, typarams);\n+            if (outer1 != outer || typarams != typarams1) {\n+                t = new ClassType(outer1, typarams1, t.tsym, t.getMetadata());\n+            }\n+            return reannotate(t, path);\n@@ -2542,5 +2542,6 @@\n-        @Override\n-        public Void visitWildcardType(\n-                WildcardType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n-            visit(t.type, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n-            return super.visitWildcardType(t, path);\n+        private List<Type> rewriteTypeParams(\n+                List<TypeAnnotationPosition.TypePathEntry> path, List<Type> typarams) {\n+            var i = IntStream.iterate(0, x -> x + 1).iterator();\n+            return typarams.map(typaram -> visit(typaram,\n+                    path.append(new TypeAnnotationPosition.TypePathEntry(\n+                            TypeAnnotationPosition.TypePathEntryKind.TYPE_ARGUMENT, i.nextInt()))));\n@@ -2550,3 +2551,10 @@\n-        public Void visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n-            visit(t.elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n-            return super.visitArrayType(t, path);\n+        public Type visitWildcardType(\n+                WildcardType wt, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            Type t = wt.type;\n+            if (t != null) {\n+                t = visit(t, path.append(TypeAnnotationPosition.TypePathEntry.WILDCARD));\n+            }\n+            if (t != wt.type) {\n+                wt = new WildcardType(t, wt.kind, wt.tsym, wt.bound, wt.getMetadata());\n+            }\n+            return reannotate(wt, path);\n@@ -2556,4 +2564,6 @@\n-        public Void visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n-            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n-            if (attributes != null) {\n-                attributesByType.put(t, attributes.toList());\n+        public Type visitArrayType(ArrayType t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            Type elemtype = t.elemtype;\n+            Type elemtype1 =\n+                    visit(elemtype, path.append(TypeAnnotationPosition.TypePathEntry.ARRAY));\n+            if (elemtype1 != elemtype)  {\n+                t = new ArrayType(elemtype1, t.tsym, t.getMetadata());\n@@ -2561,1 +2571,1 @@\n-            return null;\n+            return reannotate(t, path);\n@@ -2563,4 +2573,0 @@\n-    }\n-\n-    \/** A type mapping that rewrites the type to include type annotations. *\/\n-    private static class TypeAnnotationTypeMapping extends Type.StructuralTypeMapping<Void> {\n@@ -2568,5 +2574,3 @@\n-        private final Map<Type, List<Attribute.TypeCompound>> attributesByType;\n-\n-        private TypeAnnotationTypeMapping(\n-                Map<Type, List<Attribute.TypeCompound>> attributesByType) {\n-            this.attributesByType = attributesByType;\n+        @Override\n+        public Type visitType(Type t, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            return reannotate(t, path);\n@@ -2575,8 +2579,4 @@\n-        private <T extends Type> Type reannotate(T t, BiFunction<T, Void, Type> f) {\n-            \/\/ We're relying on object identify of Type instances to record where the annotations\n-            \/\/ need to be added, so we have to retrieve the annotations for each type before\n-            \/\/ rewriting it, and then add them after its contained types have been rewritten.\n-            List<Attribute.TypeCompound> attributes = attributesByType.remove(t);\n-            Type mapped = f.apply(t, null);\n-            if (attributes == null) {\n-                return mapped;\n+        Type reannotate(Type type, List<TypeAnnotationPosition.TypePathEntry> path) {\n+            List<Attribute.TypeCompound> attributes = attributesForPath(path);\n+            if (attributes.isEmpty()) {\n+                return type;\n@@ -2586,1 +2586,1 @@\n-            TypeMetadata.Annotations existing = mapped.getMetadata(TypeMetadata.Annotations.class);\n+            TypeMetadata.Annotations existing = type.getMetadata(TypeMetadata.Annotations.class);\n@@ -2589,1 +2589,1 @@\n-                return mapped;\n+                return type;\n@@ -2591,6 +2591,1 @@\n-            return mapped.annotatedType(attributes);\n-        }\n-\n-        @Override\n-        public Type visitClassType(ClassType t, Void unused) {\n-            return reannotate(t, super::visitClassType);\n+            return type.annotatedType(attributes);\n@@ -2599,13 +2594,4 @@\n-        @Override\n-        public Type visitWildcardType(WildcardType t, Void unused) {\n-            return reannotate(t, super::visitWildcardType);\n-        }\n-\n-        @Override\n-        public Type visitArrayType(ArrayType t, Void unused) {\n-            return reannotate(t, super::visitArrayType);\n-        }\n-\n-        @Override\n-        public Type visitType(Type t, Void unused) {\n-            return reannotate(t, (x, u) -> x);\n+        List<Attribute.TypeCompound> attributesForPath(\n+                List<TypeAnnotationPosition.TypePathEntry> path) {\n+            ListBuffer<Attribute.TypeCompound> attributes = attributesByPath.remove(path);\n+            return attributes != null ? attributes.toList() : List.nil();\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/jvm\/ClassReader.java","additions":73,"deletions":87,"binary":false,"changes":160,"status":"modified"},{"patch":"@@ -62,0 +62,1 @@\n+import com.sun.tools.javac.parser.VirtualParser.VirtualScanner;\n@@ -458,1 +459,5 @@\n-    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+    protected JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey) {\n+        return syntaxError(pos, errs, errorKey, false);\n+    }\n+\n+    private JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey, boolean noEofError) {\n@@ -461,1 +466,1 @@\n-        reportSyntaxError(err, errorKey);\n+        reportSyntaxError(err, errorKey, noEofError);\n@@ -488,0 +493,4 @@\n+        reportSyntaxError(diagPos, errorKey, false);\n+    }\n+\n+    private void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey, boolean noEofError) {\n@@ -490,1 +499,1 @@\n-            if (token.kind == EOF) {\n+            if (token.kind == EOF && !noEofError) {\n@@ -4095,0 +4104,7 @@\n+                } else if (isDefiniteStatementStartToken()) {\n+                    int startPos = token.pos;\n+                    List<JCStatement> statements = blockStatement();\n+                    defs.append(syntaxError(startPos,\n+                                            statements,\n+                                            Errors.StatementNotExpected,\n+                                            true));\n@@ -4327,0 +4343,3 @@\n+            } else if (Feature.IMPLICIT_CLASSES.allowedInSource(source) &&\n+                       (!preview.isPreview(Feature.IMPLICIT_CLASSES) || preview.isEnabled())) {\n+                error = Errors.ClassMethodOrFieldExpected;\n@@ -4736,0 +4755,6 @@\n+            } else if (isDefiniteStatementStartToken()) {\n+                int startPos = token.pos;\n+                List<JCStatement> statements = blockStatement();\n+                return List.of(syntaxError(startPos,\n+                                           statements,\n+                                           Errors.StatementNotExpected));\n@@ -4903,0 +4928,6 @@\n+        } else if (token.kind == LPAREN && type.hasTag(IDENT)) {\n+            log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);\n+\n+            return List.of(methodDeclaratorRest(\n+                    pos, mods, null, names.init, typarams,\n+                    false, true, false, dc));\n@@ -4913,1 +4944,13 @@\n-        }\n+    }\n+\n+    \/**\n+     * {@return true if and only if the current token is definitelly a token that\n+     *  starts a statement.}\n+     *\/\n+    private boolean isDefiniteStatementStartToken() {\n+        return switch (token.kind) {\n+            case IF, WHILE, DO, SWITCH, RETURN, TRY, FOR, ASSERT, BREAK,\n+                 CONTINUE, THROW -> true;\n+            default -> false;\n+        };\n+    }\n@@ -5004,0 +5047,1 @@\n+            boolean unclosedParameterList;\n@@ -5006,0 +5050,1 @@\n+                unclosedParameterList = token.pos == endPosTable.errorEndPos;\n@@ -5011,0 +5056,2 @@\n+            } else {\n+                unclosedParameterList = false;\n@@ -5024,0 +5071,1 @@\n+                    accept(SEMI);\n@@ -5026,0 +5074,1 @@\n+                    accept(SEMI, tk -> Errors.Expected2(LBRACE, SEMI));\n@@ -5027,1 +5076,0 @@\n-                accept(SEMI);\n@@ -5030,2 +5078,5 @@\n-                    skip(false, true, false, false);\n-                    if (token.kind == LBRACE) {\n+                    \/\/ look if there is a probable missing opening brace,\n+                    \/\/ and if yes, parse as a block\n+                    boolean parseAsBlock = openingBraceMissing(unclosedParameterList);\n+\n+                    if (parseAsBlock) {\n@@ -5048,0 +5099,78 @@\n+    \/**\n+     * After seeing a method header, and not seeing an opening left brace,\n+     * attempt to estimate if acting as if the left brace was present and\n+     * parsing the upcoming code will get better results than not parsing\n+     * the code as a block.\n+     *\n+     * The estimate is as follows:\n+     * - tokens are skipped until member, statement or identifier is found,\n+     * - then, if there is a left brace, parse as a block,\n+     * - otherwise, if the head was broken, do not parse as a block,\n+     * - otherwise, look at the next token and:\n+     *   - if it definitelly starts a statement, parse as a block,\n+     *   - otherwise, if it is a closing\/right brace, count opening and closing\n+     *     braces in the rest of the file, to see if imaginarily \"adding\" an opening\n+     *     brace would lead to a balanced count - if yes, parse as a block,\n+     *   - otherwise, speculatively parse the following code as a block, and if\n+     *     it contains statements that cannot be members, parse as a block,\n+     *   - otherwise, don't parse as a block.\n+     *\n+     * @param unclosedParameterList whether there was a serious problem in the\n+     *                              parameters list\n+     * @return true if and only if the following code should be parsed as a block.\n+     *\/\n+    private boolean openingBraceMissing(boolean unclosedParameterList) {\n+        skip(false, true, !unclosedParameterList, !unclosedParameterList);\n+\n+        if (token.kind == LBRACE) {\n+            return true;\n+        } else if (unclosedParameterList) {\n+            return false;\n+        } else {\n+            return switch (token.kind) {\n+                \/\/definitelly sees a statement:\n+                case CASE, DEFAULT, IF, FOR, WHILE, DO, TRY, SWITCH,\n+                    RETURN, THROW, BREAK, CONTINUE, ELSE, FINALLY,\n+                    CATCH, THIS, SUPER, NEW -> true;\n+                case RBRACE -> {\n+                    \/\/check if adding an opening brace would balance out\n+                    \/\/the opening and closing braces:\n+                    int braceBalance = 1;\n+                    VirtualScanner virtualScanner = new VirtualScanner(S);\n+\n+                    virtualScanner.nextToken();\n+\n+                    while (virtualScanner.token().kind != TokenKind.EOF) {\n+                        switch (virtualScanner.token().kind) {\n+                            case LBRACE -> braceBalance++;\n+                            case RBRACE -> braceBalance--;\n+                        }\n+                        virtualScanner.nextToken();\n+                    }\n+\n+                    yield braceBalance == 0;\n+                }\n+                default -> {\n+                    \/\/speculatively try to parse as a block, and check\n+                    \/\/if the result would suggest there is a block\n+                    \/\/e.g.: it contains a statement that is not\n+                    \/\/a member declaration\n+                    JavacParser speculative = new VirtualParser(this);\n+                    JCBlock speculativeResult =\n+                            speculative.block();\n+                    if (!speculativeResult.stats.isEmpty()) {\n+                        JCStatement last = speculativeResult.stats.last();\n+                        yield !speculativeResult.stats.stream().allMatch(s -> s.hasTag(VARDEF) ||\n+                                s.hasTag(CLASSDEF) ||\n+                                s.hasTag(BLOCK) ||\n+                                s == last) ||\n+                            !(last instanceof JCExpressionStatement exprStatement &&\n+                            exprStatement.expr.hasTag(ERRONEOUS));\n+                    } else {\n+                        yield false;\n+                    }\n+                }\n+            };\n+        }\n+    }\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/JavacParser.java","additions":136,"deletions":7,"binary":false,"changes":143,"status":"modified"},{"patch":"@@ -65,1 +65,1 @@\n-    protected JCErroneous syntaxError(int pos, List<JCTree> errs, Error errorKey) {\n+    protected JCErroneous syntaxError(int pos, List<? extends JCTree> errs, Error errorKey) {\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/parser\/VirtualParser.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1619,0 +1619,6 @@\n+compiler.err.statement.not.expected=\\\n+    statements not expected outside of methods and initializers\n+\n+compiler.err.class.method.or.field.expected=\\\n+    class, interface, annotation type, enum, record, method or field expected\n+\n@@ -2348,0 +2354,5 @@\n+# 0: list of annotation, 1: symbol, 2: name, 3: message segment\n+compiler.err.cant.attach.type.annotations=\\\n+    Cannot attach type annotations {0} to {1}.{2}:\\n\\\n+    {3}\n+\n","filename":"src\/jdk.compiler\/share\/classes\/com\/sun\/tools\/javac\/resources\/compiler.properties","additions":11,"deletions":0,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -465,12 +465,0 @@\n-class name java\/nio\/HeapByteBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapByteBufferR\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBuffer\n-method name hashCode descriptor ()I flags 1\n-\n-class name java\/nio\/HeapCharBufferR\n-method name hashCode descriptor ()I flags 1\n-\n","filename":"src\/jdk.compiler\/share\/data\/symbols\/java.base-N.sym.txt","additions":0,"deletions":12,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -86,1 +86,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.cryptoki\/share\/classes\/sun\/security\/pkcs11\/wrapper\/PKCS11.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n-        _snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n+        snprintf(errorMessage, sizeof(errorMessage), \"Symbol not found: %s\", functionName);\n","filename":"src\/jdk.crypto.cryptoki\/windows\/native\/libj2pkcs11\/j2secmod_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        @SuppressWarnings(\"removal\")\n+        @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.crypto.mscapi\/windows\/classes\/sun\/security\/mscapi\/SunMSCAPI.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -322,1 +322,1 @@\n-    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file\");\n+    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file. For more information, export LIBSAPROC_DEBUG=1 and try again.\");\n","filename":"src\/jdk.hotspot.agent\/linux\/native\/libsaproc\/LinuxDebuggerLocal.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1149,1 +1149,1 @@\n-    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file\");\n+    THROW_NEW_DEBUGGER_EXCEPTION(\"Can't attach to the core file. For more information, export LIBSAPROC_DEBUG=1 and try again.\");\n","filename":"src\/jdk.hotspot.agent\/macosx\/native\/libsaproc\/MacosxDebuggerLocal.m","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -65,0 +65,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/bsd\/BsdDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,0 +70,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/linux\/LinuxDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -57,0 +57,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/debugger\/windbg\/WindbgDebuggerLocal.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,4 +59,0 @@\n-  \/\/ Klass* flags\n-  public boolean hasFinalizer         () { return (flags & JVM_ACC_HAS_FINALIZER          ) != 0; }\n-  public boolean isCloneable          () { return (flags & JVM_ACC_IS_CLONEABLE           ) != 0; }\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/AccessFlags.java","additions":1,"deletions":5,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2000, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2000, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -233,2 +233,0 @@\n-  public boolean hasFinalizer()             { return getAccessFlagsObj().hasFinalizer(); }\n-  public boolean isCloneable()              { return getAccessFlagsObj().isCloneable(); }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Klass.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -159,0 +159,10 @@\n+    if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+      Iterator it = ObjectSynchronizer.objectMonitorIterator();\n+      while (it != null && it.hasNext()) {\n+        ObjectMonitor mon = (ObjectMonitor)it.next();\n+        if (getAddress().equals(mon.object())) {\n+          return mon;\n+        }\n+      }\n+      return null;\n+    }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/oops\/Mark.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -46,1 +46,1 @@\n-    displacedHeaderField = type.getCIntegerField(\"_displaced_header\");\n+    displacedHeaderField = type.getCIntegerField(\"_metadata\");\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/BasicLock.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -106,6 +106,0 @@\n-    \/\/ Klass* flags\n-    \/\/ True if klass has a non-empty finalize() method\n-    public static final long JVM_ACC_HAS_FINALIZER            = 0x40000000;\n-    \/\/ True if klass supports the Clonable interface\n-    public static final long JVM_ACC_IS_CLONEABLE             = 0x80000000;\n-\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ClassConstants.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -48,2 +48,2 @@\n-    sun.jvm.hotspot.types.Field f = type.getField(\"_header\");\n-    headerFieldOffset = f.getOffset();\n+    sun.jvm.hotspot.types.Field f = type.getField(\"_metadata\");\n+    metadataFieldOffset = f.getOffset();\n@@ -68,1 +68,1 @@\n-    return new Mark(addr.addOffsetTo(headerFieldOffset));\n+    return new Mark(addr.addOffsetTo(metadataFieldOffset));\n@@ -117,1 +117,1 @@\n-  private static long          headerFieldOffset;\n+  private static long          metadataFieldOffset;\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectMonitor.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -58,0 +58,3 @@\n+      if (VM.getVM().getCommandLineFlag(\"UseObjectMonitorTable\").getBool()) {\n+        return mark.hash();\n+      }\n","filename":"src\/jdk.hotspot.agent\/share\/classes\/sun\/jvm\/hotspot\/runtime\/ObjectSynchronizer.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,6 +36,0 @@\n-\/\/ Disable CRT security warning against _snprintf\n-#pragma warning (disable : 4996)\n-\n-#define snprintf  _snprintf\n-#define vsnprintf _vsnprintf\n-\n","filename":"src\/jdk.hotspot.agent\/share\/native\/libsaproc\/sadis.c","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -402,2 +402,5 @@\n-  ptrIDebugSymbols->SetImagePath(imagePath);\n-  ptrIDebugSymbols->SetSymbolPath(symbolPath);\n+  COM_VERIFY_OK_(ptrIDebugSymbols->SetImagePath(imagePath),\n+                 \"Windbg Error: SetImagePath failed!\", false);\n+  COM_VERIFY_OK_(ptrIDebugSymbols->SetSymbolPath(symbolPath),\n+                 \"Windbg Error: SetSymbolPath failed!\", false);\n+\n@@ -832,0 +835,2 @@\n+#define SYMBOL_BUFSIZE 512\n+\n@@ -855,0 +860,13 @@\n+\n+  \/\/ See JDK-8311993: WinDbg intermittently returns offset of \"module!class::`vftable'\" symbol\n+  \/\/ when requested for decorated \"class\" or \"class*\" (i.e. \"??_7class@@6B@\"\/\"??_7class*@@6B@\").\n+  \/\/ As a workaround check if returned symbol contains requested symbol.\n+  ULONG64 disp = 0L;\n+  char buf[SYMBOL_BUFSIZE];\n+  memset(buf, 0, sizeof(buf));\n+  if (ptrIDebugSymbols->GetNameByOffset(offset, buf, sizeof(buf), 0, &disp) == S_OK) {\n+    if (strstr(buf, name) == nullptr) {\n+      return (jlong)0;\n+    }\n+  }\n+\n@@ -858,1 +876,0 @@\n-#define SYMBOL_BUFSIZE 512\n","filename":"src\/jdk.hotspot.agent\/windows\/native\/libsaproc\/sawindbg.cpp","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -173,0 +173,5 @@\n+    public int getMiscFlags() {\n+        HotSpotVMConfig config = config();\n+        return UNSAFE.getInt(getKlassPointer() + config.klassMiscFlagsOffset);\n+    }\n+\n@@ -376,1 +381,1 @@\n-        return (getAccessFlags() & config().jvmAccHasFinalizer) != 0;\n+        return (getMiscFlags() & config().jvmAccHasFinalizer) != 0;\n@@ -1113,1 +1118,1 @@\n-        return (getAccessFlags() & config().jvmAccIsCloneableFast) != 0;\n+        return (getMiscFlags() & config().jvmAccIsCloneableFast) != 0;\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotResolvedObjectTypeImpl.java","additions":8,"deletions":3,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -101,0 +101,1 @@\n+    final int klassMiscFlagsOffset = getFieldOffset(\"Klass::_misc_flags._flags\", Integer.class, \"u1\");\n@@ -116,1 +117,1 @@\n-    final int jvmAccHasFinalizer = getConstant(\"JVM_ACC_HAS_FINALIZER\", Integer.class);\n+    final int jvmAccHasFinalizer = getConstant(\"KlassFlags::_misc_has_finalizer\", Integer.class);\n@@ -119,1 +120,1 @@\n-    final int jvmAccIsCloneableFast = getConstant(\"JVM_ACC_IS_CLONEABLE_FAST\", Integer.class);\n+    final int jvmAccIsCloneableFast = getConstant(\"KlassFlags::_misc_is_cloneable_fast\", Integer.class);\n","filename":"src\/jdk.internal.vm.ci\/share\/classes\/jdk\/vm\/ci\/hotspot\/HotSpotVMConfig.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -40,0 +40,1 @@\n+import javax.lang.model.element.TypeParameterElement;\n@@ -158,1 +159,1 @@\n-        Content c = HtmlTree.DIV(HtmlStyles.horizontalScroll);\n+        var c = new ContentBuilder();\n@@ -167,5 +168,7 @@\n-        buildClassSignature(c);\n-        buildDeprecationInfo(c);\n-        buildClassDescription(c);\n-        buildClassTagInfo(c);\n-\n+        c.add(new HtmlTree(HtmlTag.HR));\n+        var div = HtmlTree.DIV(HtmlStyles.horizontalScroll);\n+        buildClassSignature(div);\n+        buildDeprecationInfo(div);\n+        buildClassDescription(div);\n+        buildClassTagInfo(div);\n+        c.add(div);\n@@ -435,3 +438,0 @@\n-        HtmlLinkInfo linkInfo = new HtmlLinkInfo(configuration,\n-                HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n-                .linkToSelf(false);  \/\/ Let's not link to ourselves in the header\n@@ -440,1 +440,1 @@\n-        heading.add(getTypeParameterLinks(linkInfo));\n+        heading.add(getTypeParameters());\n@@ -448,0 +448,29 @@\n+    \/\/ Renders type parameters for the class heading, creating id attributes\n+    \/\/ if @param block tags are missing in doc comment.\n+    private Content getTypeParameters() {\n+        var content = new ContentBuilder();\n+        var typeParams = typeElement.getTypeParameters();\n+        if (!typeParams.isEmpty()) {\n+            \/\/ Generate id attributes if @param tags are missing for type parameters.\n+            \/\/ Note that this does not handle the case where some but not all @param tags are missing.\n+            var needsId = !utils.hasBlockTag(typeElement, DocTree.Kind.PARAM);\n+            var linkInfo = new HtmlLinkInfo(configuration,\n+                    HtmlLinkInfo.Kind.SHOW_TYPE_PARAMS_AND_BOUNDS, typeElement)\n+                    .linkToSelf(false);  \/\/ Let's not link to ourselves in the header\n+            content.add(\"<\");\n+            var first = true;\n+            for (TypeParameterElement t : typeParams) {\n+                if (!first) {\n+                    content.add(\",\").add(new HtmlTree(HtmlTag.WBR));\n+                }\n+                var typeParamLink = getLink(linkInfo.forType(t.asType()));\n+                content.add(needsId\n+                        ? HtmlTree.SPAN_ID(htmlIds.forTypeParam(t.getSimpleName().toString(), typeElement), typeParamLink)\n+                        : typeParamLink);\n+                first = false;\n+            }\n+            content.add(\">\");\n+        }\n+        return content;\n+    }\n+\n@@ -476,1 +505,0 @@\n-        classInfo.add(new HtmlTree(HtmlTag.HR));\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/ClassWriter.java","additions":39,"deletions":11,"binary":false,"changes":50,"status":"modified"},{"patch":"@@ -465,0 +465,16 @@\n+    \/**\n+     * Returns an id for text documenting a type parameter of a class or method.\n+     *\n+     * @param paramName the name of the type parameter\n+     * @param owner the enclosing element\n+     *\n+     * @return the id\n+     *\/\n+    public HtmlId forTypeParam(String paramName, Element owner) {\n+        if (utils.isExecutableElement(owner)) {\n+            return HtmlId.of(forMember((ExecutableElement) owner).getFirst().name()\n+                    + \"-type-param-\" + paramName);\n+        }\n+        return HtmlId.of(\"type-param-\" + paramName);\n+    }\n+\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlIds.java","additions":16,"deletions":0,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -55,0 +55,1 @@\n+import jdk.javadoc.internal.html.HtmlId;\n@@ -165,3 +166,5 @@\n-                        Content label = newContent();\n-                        label.add(utils.getTypeName(type, false));\n-                        linkInfo.label(label).skipPreview(true);\n+                        if (linkInfo.getLabel() == null || linkInfo.getLabel().isEmpty()) {\n+                            Content label = newContent();\n+                            label.add(utils.getTypeName(type, false));\n+                            linkInfo.label(label).skipPreview(true);\n+                        }\n@@ -245,0 +248,5 @@\n+            if (isTypeLink) {\n+                linkInfo.fragment(m_writer.configuration.htmlIds.forTypeParam(\n+                        utils.getTypeName(utils.getComponentType(linkInfo.getType()), false),\n+                        typeElement).name());\n+            }\n@@ -292,1 +300,1 @@\n-                DocPath filename = getPath(linkInfo);\n+                DocPath fileName = getPath(linkInfo);\n@@ -295,17 +303,3 @@\n-                                filename.fragment(linkInfo.getFragment()),\n-                                label,\n-                                linkInfo.getStyle(),\n-                                title));\n-                        Content spacer = Text.EMPTY;\n-                        if (flags.contains(ElementFlag.PREVIEW)) {\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forPreviewSection(previewTarget).name()),\n-                                    m_writer.contents.previewMark)));\n-                            spacer = Entity.NO_BREAK_SPACE;\n-                        }\n-                        if (flags.contains(ElementFlag.RESTRICTED)) {\n-                            link.add(spacer);\n-                            link.add(HtmlTree.SUP(m_writer.links.createLink(\n-                                    filename.fragment(m_writer.htmlIds.forRestrictedSection(restrictedTarget).name()),\n-                                    m_writer.contents.restrictedMark)));\n-                        }\n+                                fileName.fragment(linkInfo.getFragment()),\n+                                label, linkInfo.getStyle(), title));\n+                        addSuperscript(link, flags, fileName, null, previewTarget, restrictedTarget);\n@@ -321,17 +315,1 @@\n-                Content spacer = Text.EMPTY;\n-                if (flags.contains(ElementFlag.PREVIEW)) {\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                        typeElement,\n-                        m_writer.htmlIds.forPreviewSection(previewTarget).name(),\n-                        m_writer.contents.previewMark,\n-                        null, false)));\n-                    spacer = Entity.NO_BREAK_SPACE;\n-                }\n-                if (flags.contains(ElementFlag.RESTRICTED)) {\n-                    link.add(spacer);\n-                    link.add(HtmlTree.SUP(m_writer.getCrossClassLink(\n-                            typeElement,\n-                            m_writer.htmlIds.forRestrictedSection(restrictedTarget).name(),\n-                            m_writer.contents.restrictedMark,\n-                            null, false)));\n-                }\n+                addSuperscript(link, flags, null, typeElement, previewTarget, restrictedTarget);\n@@ -343,0 +321,17 @@\n+        addSuperscript(link, flags, null, null, previewTarget, restrictedTarget);\n+        return link;\n+    }\n+\n+    \/**\n+     * Adds PREVIEW and RESTRICTED superscript labels. Depending on the parameter values,\n+     * labels will be formatted as local or external links or plain text.\n+     *\n+     * @param content the content to add to\n+     * @param flags the flags\n+     * @param fileName file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param previewTarget preview link target element\n+     * @param restrictedTarget restricted link target element\n+     *\/\n+    private void addSuperscript(Content content, Set<ElementFlag> flags, DocPath fileName, TypeElement typeElement,\n+                                Element previewTarget, ExecutableElement restrictedTarget) {\n@@ -345,1 +340,3 @@\n-            link.add(HtmlTree.SUP(m_writer.contents.previewMark));\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forPreviewSection(previewTarget),\n+                    m_writer.contents.previewMark)));\n@@ -349,2 +346,23 @@\n-            link.add(spacer);\n-            link.add(HtmlTree.SUP(m_writer.contents.restrictedMark));\n+            content.add(spacer);\n+            content.add(HtmlTree.SUP(getSuperscript(fileName, typeElement,\n+                    m_writer.htmlIds.forRestrictedSection(restrictedTarget),\n+                    m_writer.contents.restrictedMark)));\n+        }\n+    }\n+\n+    \/**\n+     * Returns PREVIEW or RESTRICTED superscript as either local or external link or as plain text.\n+     *\n+     * @param fileName local file name to link to, or null if no local link target\n+     * @param typeElement external type to link to, or null if no external link\n+     * @param id the id fragment to link to\n+     * @param label the label content\n+     * @return superscript content\n+     *\/\n+    private Content getSuperscript(DocPath fileName, TypeElement typeElement, HtmlId id, Content label) {\n+        if (fileName != null) {\n+            return m_writer.links.createLink(fileName.fragment(id.name()), label);\n+        } else if (typeElement != null) {\n+            return (m_writer.getCrossClassLink(typeElement, id.name(), label, null, false));\n+        } else {\n+            return label;\n@@ -352,1 +370,0 @@\n-        return link;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/HtmlLinkFactory.java","additions":59,"deletions":42,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -235,0 +235,14 @@\n+    \/\/ Reset animation for type parameter target highlight\n+    document.querySelectorAll(\"a\").forEach((link) => {\n+        link.addEventListener(\"click\", (e) => {\n+            const href = e.currentTarget.getAttribute(\"href\");\n+            if (href && href.startsWith(\"#\") && href.indexOf(\"type-param-\") > -1) {\n+                const target = document.getElementById(decodeURI(href.substring(1)));\n+                if (target) {\n+                    target.style.animation = \"none\";\n+                    void target.offsetHeight;\n+                    target.style.removeProperty(\"animation\");\n+                }\n+            }\n+        })\n+    });\n@@ -289,1 +303,1 @@\n-    function collapse() {\n+    function collapse(e) {\n@@ -339,1 +353,1 @@\n-            var id = hdr.getAttribute(\"id\") || hdr.parentElement.getAttribute(\"id\")\n+            var id = hdr.parentElement.getAttribute(\"id\") || hdr.getAttribute(\"id\")\n@@ -450,1 +464,1 @@\n-    function handleResize(e) {\n+    new ResizeObserver((entries) => {\n@@ -464,3 +478,1 @@\n-    }\n-    window.addEventListener(\"orientationchange\", handleResize);\n-    window.addEventListener(\"resize\", handleResize);\n+    }).observe(document.body);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/script.js.template","additions":18,"deletions":6,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -481,1 +481,2 @@\n-    Recursively copy doc-file subdirectories\n+    Enables deep copying of 'doc-files' directories. Subdirectories and all\\n\\\n+    contents are recursively copied to the destination\n@@ -518,1 +519,1 @@\n-    Include footer text for each page\n+    This option is no longer supported and reports a warning\n@@ -556,1 +557,1 @@\n-    Exclude any doc-files subdirectories with given name.\\n\\\n+    Exclude any 'doc-files' subdirectories with given name.\\n\\\n@@ -617,1 +618,1 @@\n-    Generate warning about @serial tag\n+    Reports compile-time warnings for missing '@serial' tags\n@@ -632,1 +633,1 @@\n-    Specify single argument custom tags\n+    Specifies a custom tag with a single argument\n@@ -657,1 +658,2 @@\n-    Include file that help link links to\n+    Specifies a file containing the text that will be displayed when the\\n\\\n+    help link in the navigation bar is clicked\n@@ -694,1 +696,2 @@\n-    Allow JavaScript in options and comments\n+    Allow JavaScript in documentation comments, and options\\n\\\n+    whose value is html-code\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/standard.properties","additions":10,"deletions":7,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -66,1 +66,1 @@\n-    --search-tag-highlight-color: #ffff00;\n+    --search-tag-highlight-color: #ffff66;\n@@ -310,1 +310,1 @@\n-    margin:10px 0;\n+    margin:10px 0 12px 0;\n@@ -991,0 +991,16 @@\n+dd > span:target,\n+h1 > span:target {\n+    animation: 2.4s ease-out highlight;\n+}\n+section.class-description dd > span:target,\n+section.class-description h1 > span:target {\n+    scroll-margin-top: 20em;\n+}\n+@keyframes highlight {\n+    from {\n+        background-color: var(--search-tag-highlight-color);\n+    }\n+    60% {\n+        background-color: var(--search-tag-highlight-color);\n+    }\n+}\n@@ -1043,1 +1059,1 @@\n-    margin: 10px 0 10px 0;\n+    margin: 10px 0;\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/resources\/stylesheet.css","additions":19,"deletions":3,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -179,1 +179,1 @@\n-                String refModuleName =  ch.getReferencedModuleName(refSignature);\n+                String refModuleName = ch.getReferencedModuleName(refSignature);\n@@ -193,1 +193,1 @@\n-                                new Object[] { refSignature});\n+                                new Object[] {refSignature});\n@@ -196,1 +196,1 @@\n-                            Optional.of(labelContent.isEmpty() ? text: labelContent));\n+                            Optional.of(labelContent.isEmpty() ? text : labelContent));\n@@ -199,0 +199,16 @@\n+        } else if (utils.isTypeParameterElement(ref)) {\n+            \/\/ This is a type parameter of a generic class, method or constructor\n+            if (labelContent.isEmpty()) {\n+                labelContent = plainOrCode(isPlain, Text.of(utils.getSimpleName(ref)));\n+            }\n+            if (refMem == null) {\n+                return htmlWriter.getLink(\n+                        new HtmlLinkInfo(config, HtmlLinkInfo.Kind.LINK_TYPE_PARAMS, ref.asType())\n+                                .label(labelContent));\n+            } else {\n+                \/\/ HtmlLinkFactory does not render type parameters of generic methods as links, so instead of\n+                \/\/ teaching it how to do it (making the code even more complex) just create the link directly.\n+                return htmlWriter.getLink(new HtmlLinkInfo(config, HtmlLinkInfo.Kind.PLAIN, refClass)\n+                        .fragment(config.htmlIds.forTypeParam(ref.getSimpleName().toString(), refMem).name())\n+                        .label((labelContent)));\n+            }\n@@ -211,0 +227,1 @@\n+                    .skipPreview(isPlain)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/LinkTaglet.java","additions":21,"deletions":4,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -281,1 +281,3 @@\n-        return HtmlTree.DD(body);\n+        return HtmlTree.DD(paramTag.isTypeParameter()\n+                ? HtmlTree.SPAN_ID(config.htmlIds.forTypeParam(paramName, element), body)\n+                : body);\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/formats\/html\/taglets\/ParamTaglet.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -191,0 +191,6 @@\n+        } else if (utils.isTypeParameterElement(e)) {\n+            \/\/ Return the enclosing member for type parameters of generic methods or constructors.\n+            Element encl = e.getEnclosingElement();\n+            if (utils.isExecutableElement(encl)) {\n+                return encl;\n+            }\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/doclets\/toolkit\/util\/CommentHelper.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -681,1 +681,1 @@\n-         * the {@code --help-extended} option and its aliases.\n+         * the {@code --help-extra} option and its aliases.\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/ToolOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-    Specifies which members (fields, methods, etc.) will be\\n\\\n+    Specifies which members (fields, methods, or constructors) will be\\n\\\n@@ -90,1 +90,1 @@\n-    Specifies which module's packages will be documented. Possible\\n\\\n+    Specifies which module packages will be documented. Possible\\n\\\n@@ -100,1 +100,1 @@\n-    <value>\n+    (transitive|all)\n","filename":"src\/jdk.javadoc\/share\/classes\/jdk\/javadoc\/internal\/tool\/resources\/javadoc.properties","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2017, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -98,1 +98,1 @@\n-        write(annot, true);\n+        write(annot.annotation(), true);\n@@ -104,1 +104,1 @@\n-        write(annot, resolveIndices);\n+        write(annot.annotation(), resolveIndices);\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/AnnotationWriter.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -158,1 +158,1 @@\n-                    print(\" \" + instr.typeKind().typeName());\n+                    print(\" \" + instr.typeKind().upperBound().displayName());\n","filename":"src\/jdk.jdeps\/share\/classes\/com\/sun\/tools\/javap\/CodeWriter.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -68,0 +68,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jdi\/windows\/classes\/com\/sun\/tools\/jdi\/SharedMemoryTransportService.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -998,0 +998,2 @@\n+    gdata->jvmti_data_dump = JNI_FALSE;\n+\n@@ -1162,0 +1164,7 @@\n+        } else if (strcmp(buf, \"datadump\") == 0) {\n+          \/\/ Enable JVMTI DATA_DUMP_REQUEST support.\n+          \/\/ This is not a documented flag. This feature is experimental and is only intended\n+          \/\/ to be used by debug agent developers. See comment for cbDataDump() for more details.\n+          if ( !get_boolean(&str, &(gdata->jvmti_data_dump)) ) {\n+                goto syntax_error;\n+            }\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugInit.c","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,3 @@\n-    cmdQueueLock = debugMonitorCreate(\"JDWP Command Queue Lock\");\n+    if (cmdQueueLock == NULL) {\n+      cmdQueueLock = debugMonitorCreate(\"JDWP Command Queue Lock\");\n+    }\n@@ -193,1 +195,0 @@\n-    debugMonitorDestroy(cmdQueueLock);\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/debugLoop.c","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -1390,3 +1390,1 @@\n-\/***** debugging *****\/\n-\n-#ifdef DEBUG\n+\/***** APIs for debugging the debug agent *****\/\n@@ -1479,2 +1477,0 @@\n-\n-#endif \/* DEBUG *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventFilter.c","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -79,1 +79,1 @@\n-\/***** debugging *****\/\n+\/***** APIs for debugging the debug agent *****\/\n@@ -81,1 +81,0 @@\n-#ifdef DEBUG\n@@ -83,1 +82,0 @@\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventFilter.h","additions":2,"deletions":4,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -1333,0 +1333,38 @@\n+\/**\n+ * Event callback for JVMTI_EVENT_DATA_DUMP_REQUEST\n+ *\n+ * This callback is made when a JVMTI data dump is requested. The common way of doing\n+ * this is with \"jcmd <pid> JVMTI.data_dump\".\n+ *\n+ * Debug agent data dumps are experimental and only intended to be used by debug agent\n+ * developers. Data dumps are disabled by default.\n+ *\n+ * This callback is enabled by launching the debug agent with datadump=y. The easiest\n+ * way to enabled data dumps with debugger tests or when using jdb is to use the\n+ * _JAVA_JDWP_OPTIONS export. The following works well when running tests:\n+ *\n+ *  make test TEST=<test> \\\n+ *    JTREG='JAVA_OPTIONS=-XX:+StartAttachListener;OPTIONS=-e:_JAVA_JDWP_OPTIONS=datadump=y'\n+ *\n+ * Data dumps may fail to happen due to the debug agent suspending all threads.\n+ * This causes the Signal Dispatcher and Attach Listener threads to be suspended,\n+ * which can cause issues with jcmd attaching. Running with -XX:+StartAttachListener can\n+ * help, but in general it is best not to try a datadump when all threads are suspended.\n+ *\n+ * Data dumps are also risky when the debug agent is handling events or commands from\n+ * the debugger, due to dumping data that is not lock protected. This can cause a\n+ * crash.\n+ *\n+ * Data dumps are meant to aid with post mortem debugging (debugging after a\n+ * problem has been detected), not for ongoing periodic data gathering.\n+ *\/\n+static void JNICALL\n+cbDataDump(jvmtiEnv *jvmti_env)\n+{\n+    tty_message(\"Debug Agent Data Dump\");\n+    tty_message(\"=== START DUMP ===\");\n+    threadControl_dumpAllThreads();\n+    eventHandler_dumpAllHandlers(JNI_TRUE);\n+    tty_message(\"=== END DUMP ===\");\n+}\n+\n@@ -1521,0 +1559,13 @@\n+\n+    \/*\n+     * DATA_DUMP_REQUEST is special since it is not tied to any handlers or an EI,\n+     * so it cannot be setup using threadControl_setEventMode(). Use JVMTI API directly.\n+     *\/\n+    if (gdata->jvmti_data_dump) {\n+        error = JVMTI_FUNC_PTR(gdata->jvmti,SetEventNotificationMode)\n+                (gdata->jvmti, JVMTI_ENABLE, JVMTI_EVENT_DATA_DUMP_REQUEST, NULL);\n+        if (error != JVMTI_ERROR_NONE) {\n+            EXIT_ERROR(error,\"Can't enable data dump request events\");\n+        }\n+    }\n+\n@@ -1583,0 +1634,2 @@\n+    \/* Event callback for JVMTI_EVENT_DATA_DUMP_REQUEST *\/\n+    gdata->callbacks.DataDumpRequest = &cbDataDump;\n@@ -1854,3 +1907,1 @@\n-\/***** debugging *****\/\n-\n-#ifdef DEBUG\n+\/***** APIs for debugging the debug agent *****\/\n@@ -1895,2 +1946,0 @@\n-\n-#endif \/* DEBUG *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.c","additions":54,"deletions":5,"binary":false,"changes":59,"status":"modified"},{"patch":"@@ -88,1 +88,1 @@\n-\/***** debugging *****\/\n+\/***** APIs for debugging the debug agent *****\/\n@@ -90,1 +90,0 @@\n-#ifdef DEBUG\n@@ -94,1 +93,0 @@\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/eventHandler.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -140,5 +140,0 @@\n-#ifdef DEBUG\n-static void dumpThreadList(ThreadList *list);\n-static void dumpThread(ThreadNode *node);\n-#endif\n-\n@@ -2564,1 +2559,1 @@\n-\/***** debugging *****\/\n+\/***** APIs for debugging the debug agent *****\/\n@@ -2566,1 +2561,2 @@\n-#ifdef DEBUG\n+static void dumpThreadList(ThreadList *list);\n+static void dumpThread(ThreadNode *node);\n@@ -2571,0 +2567,1 @@\n+    tty_message(\"suspendAllCount: %d\", suspendAllCount);\n@@ -2655,2 +2652,0 @@\n-\n-#endif \/* DEBUG *\/\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.c","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -79,1 +79,1 @@\n-\/***** debugging *****\/\n+\/***** APIs for debugging the debug agent *****\/\n@@ -81,1 +81,0 @@\n-#ifdef DEBUG\n@@ -84,1 +83,0 @@\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/threadControl.h","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+#include \"jvm.h\"\n@@ -124,1 +125,5 @@\n-#ifndef STATIC_BUILD\n+\n+    if (JVM_IsStaticallyLinked()) {\n+        return (dbgsysLoadLibrary(NULL, buf, sizeof(buf)));\n+    }\n+\n@@ -148,3 +153,0 @@\n-#else\n-    return (dbgsysLoadLibrary(NULL, buf, sizeof(buf)));\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/transport.c","additions":7,"deletions":5,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1987,2 +1987,0 @@\n-#ifdef DEBUG\n-\n@@ -2043,2 +2041,0 @@\n-#endif\n-\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.c","additions":0,"deletions":4,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+    jboolean jvmti_data_dump; \/* If true, then support JVMTI DATA_DUMP_REQUEST events. *\/\n@@ -392,1 +393,0 @@\n-#ifdef DEBUG\n@@ -394,1 +394,0 @@\n-#endif\n","filename":"src\/jdk.jdwp.agent\/share\/native\/libjdwp\/util.h","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n-        size_t result_len = (size_t)_snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n+        size_t result_len = (size_t) snprintf(buffer, buflen, \"%s\\\\%s.dll\", path, fname);\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/linker_md.c","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2008, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,5 +37,0 @@\n-\/* Needed on Windows because names seem to be hidden in stdio.h. *\/\n-\n-#define snprintf        _snprintf\n-#define vsnprintf       _vsnprintf\n-\n","filename":"src\/jdk.jdwp.agent\/windows\/native\/libjdwp\/util_md.h","additions":1,"deletions":6,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.util.Objects;\n@@ -88,4 +89,1 @@\n-                stream.close();\n-                currentChunk.release();\n-                stream = null;\n-                currentChunk = null;\n+                closeStream();\n@@ -100,1 +98,30 @@\n-    public void close() throws IOException {\n+    public int read(byte[] buf, int off, int len) throws IOException {\n+        Objects.checkFromIndexSize(off, len, buf.length);\n+        if (len == 0) {\n+            return 0;\n+        }\n+\n+        int totalRead = 0;\n+        while (len > 0) {\n+            if (stream == null) {\n+                closeChunk();\n+                if (!nextStream()) {\n+                    return totalRead > 0 ? totalRead : -1;\n+                }\n+            }\n+            int read = stream.read(buf, off, len);\n+            if (read > -1) {\n+                totalRead += read;\n+                len -= read;\n+                if (len == 0) {\n+                    return totalRead;\n+                }\n+                off += read;\n+            } else {\n+                closeStream();\n+            }\n+        }\n+        return totalRead;\n+    }\n+\n+    private void closeStream() throws IOException {\n@@ -105,1 +132,5 @@\n-        while (currentChunk != null) {\n+        closeChunk();\n+    }\n+\n+    private void closeChunk() {\n+        if (currentChunk != null) {\n@@ -108,0 +139,8 @@\n+        }\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        closeStream();\n+        while (currentChunk != null) {\n+            closeChunk();\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/ChunkInputStream.java","additions":46,"deletions":7,"binary":false,"changes":53,"status":"modified"},{"patch":"@@ -144,1 +144,1 @@\n-                    delegate.combine(Collections.unmodifiableSet(values));\n+                    return delegate.combine(Collections.unmodifiableSet(values));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/Control.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -565,1 +565,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n@@ -679,1 +679,1 @@\n-        blockCodeBuilder.loadConstant(Opcode.LDC2_W, eventTypeId);\n+        blockCodeBuilder.loadConstant(eventTypeId);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/EventInstrumentation.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -660,1 +660,1 @@\n-        target.setInternalDuration(Duration.between(startTime, endTime));\n+        target.setInternalDuration(startTime.until(endTime));\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/PlatformRecorder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,1 @@\n+import jdk.internal.vm.Continuation;\n@@ -32,2 +33,2 @@\n-    public static final int MAX_LIMIT = 128; \/* 0 MAX means disabled *\/\n-\n+    public static final int MAX_LIMIT = 131072; \/* 0 MAX means disabled *\/\n+    private static final int PRECACHE_THRESHOLD = 128;\n@@ -74,9 +75,35 @@\n-    \/* synchronized because of writing the string to the JVM. *\/\n-    private static synchronized long storeString(String s) {\n-        Long lsid = cache.get(s);\n-        long internalSid;\n-        if (lsid != null) {\n-            internalSid = lsid.longValue();\n-            if (isCurrentGeneration(internalSid)) {\n-                \/\/ Someone already updated the cache.\n-                return externalSid(internalSid);\n+    \/* Explicitly pin a virtual thread before acquiring the string pool monitor\n+     * because migrating the EventWriter onto another carrier thread is impossible.\n+     *\/\n+    private static long storeString(String s, boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            \/* synchronized because of writing the string to the JVM. *\/\n+            synchronized (StringPool.class) {\n+                Long lsid = cache.get(s);\n+                long internalSid;\n+                if (lsid != null) {\n+                    internalSid = lsid.longValue();\n+                    if (isCurrentGeneration(internalSid)) {\n+                        \/\/ Someone already updated the cache.\n+                        return externalSid(internalSid);\n+                    }\n+                    internalSid = updateInternalSid(internalSid);\n+                } else {\n+                    \/\/ Not yet added or the cache was cleared.\n+                    internalSid = nextInternalSid();\n+                    currentSizeUTF16 += s.length();\n+                }\n+                long extSid = externalSid(internalSid);\n+                \/\/ Write the string to the JVM before publishing to the cache.\n+                JVM.addStringConstant(extSid, s);\n+                cache.put(s, internalSid);\n+                return extSid;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n@@ -84,5 +111,0 @@\n-            internalSid = updateInternalSid(internalSid);\n-        } else {\n-            \/\/ Not yet added or the cache was cleared.\n-            internalSid = nextInternalSid();\n-            currentSizeUTF16 += s.length();\n@@ -90,5 +112,0 @@\n-        long extSid = externalSid(internalSid);\n-        \/\/ Write the string to the JVM before publishing to the cache.\n-        JVM.addStringConstant(extSid, s);\n-        cache.put(s, internalSid);\n-        return extSid;\n@@ -98,1 +115,1 @@\n-    private static long ensureCurrentGeneration(String s, Long lsid) {\n+    private static long ensureCurrentGeneration(String s, Long lsid, boolean pinVirtualThread) {\n@@ -100,1 +117,1 @@\n-        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s);\n+        return isCurrentGeneration(internalSid) ? externalSid(internalSid) : storeString(s, pinVirtualThread);\n@@ -112,1 +129,1 @@\n-    public static long addString(String s) {\n+    public static long addString(String s, boolean pinVirtualThread) {\n@@ -115,1 +132,1 @@\n-            return ensureCurrentGeneration(s, lsid);\n+            return ensureCurrentGeneration(s, lsid, pinVirtualThread);\n@@ -117,1 +134,1 @@\n-        if (!preCache(s)) {\n+        if (s.length() <= PRECACHE_THRESHOLD && !preCache(s)) {\n@@ -123,1 +140,1 @@\n-            reset();\n+            reset(pinVirtualThread);\n@@ -125,1 +142,1 @@\n-        return storeString(s);\n+        return storeString(s, pinVirtualThread);\n@@ -146,3 +163,16 @@\n-    private static synchronized void reset() {\n-        cache.clear();\n-        currentSizeUTF16 = 0;\n+    private static void reset(boolean pinVirtualThread) {\n+        if (pinVirtualThread) {\n+            assert(Thread.currentThread().isVirtual());\n+            Continuation.pin();\n+        }\n+        try {\n+            synchronized (StringPool.class) {\n+                cache.clear();\n+                currentSizeUTF16 = 0;\n+            }\n+        } finally {\n+            if (pinVirtualThread) {\n+                assert(Thread.currentThread().isVirtual());\n+                Continuation.unpin();\n+            }\n+        }\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/StringPool.java","additions":62,"deletions":32,"binary":false,"changes":94,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -68,0 +68,1 @@\n+    private boolean pinVirtualThread;\n@@ -147,1 +148,1 @@\n-            long l = StringPool.addString(s);\n+            long l = StringPool.addString(s, pinVirtualThread);\n@@ -299,1 +300,1 @@\n-    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean excluded) {\n+    private EventWriter(long startPos, long maxPos, long threadID, boolean valid, boolean pinVirtualThread, boolean excluded) {\n@@ -304,0 +305,1 @@\n+        this.pinVirtualThread = pinVirtualThread;\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/event\/EventWriter.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -475,1 +475,1 @@\n-            return Duration.between(first, last);\n+            return first.until(last);\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/query\/Function.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -65,1 +65,1 @@\n-            Duration d = Duration.between(current.start(), next.start());\n+            Duration d = current.start().until(next.start());\n","filename":"src\/jdk.jfr\/share\/classes\/jdk\/jfr\/internal\/util\/StopWatch.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1565,1 +1565,1 @@\n-                   .newarray(TypeKind.ByteType);\n+                   .newarray(TypeKind.BYTE);\n","filename":"src\/jdk.jlink\/share\/classes\/jdk\/tools\/jlink\/internal\/plugins\/SystemModulesPlugin.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -51,1 +51,1 @@\n-\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/ExecutableRebrander.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,0 +34,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinExeBundler.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -31,0 +31,1 @@\n+@SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WindowsRegistry.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -180,1 +180,1 @@\n-                    return true;\n+                    return false;\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/ExecutionControlForwarder.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -73,0 +74,2 @@\n+    private static final int SHUTDOWN_TIMEOUT = 1; \/\/1 second\n+\n@@ -270,0 +273,14 @@\n+\n+        Process remoteProcess;\n+\n+        synchronized (this) {\n+            remoteProcess = this.process;\n+        }\n+\n+        if (remoteProcess != null) {\n+            try {\n+                remoteProcess.waitFor(SHUTDOWN_TIMEOUT, TimeUnit.SECONDS);\n+            } catch (InterruptedException ex) {\n+                debug(ex, \"waitFor remote\");\n+            }\n+        }\n","filename":"src\/jdk.jshell\/share\/classes\/jdk\/jshell\/execution\/JdiDefaultExecutionControl.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/unix\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -34,1 +34,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management.agent\/windows\/classes\/jdk\/internal\/agent\/FileSystemImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -50,0 +50,2 @@\n+ *\n+ * @since 1.6\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/HotSpotDiagnosticMXBean.java","additions":2,"deletions":0,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -39,1 +39,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/Flag.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -47,1 +47,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.management\/share\/classes\/com\/sun\/management\/internal\/PlatformMBeanProviderImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -439,7 +439,7 @@\n-        _snprintf(fullCounterPath,\n-                  fullCounterPathLen,\n-                  PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-                  objectName,\n-                  imageName,\n-                  instance,\n-                  counterName);\n+        snprintf(fullCounterPath,\n+                 fullCounterPathLen,\n+                 PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+                 objectName,\n+                 imageName,\n+                 instance,\n+                 counterName);\n@@ -475,6 +475,6 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_WITH_INSTANCES_COUNTER_FMT,\n-                      objectName,\n-                      instance,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_WITH_INSTANCES_COUNTER_FMT,\n+                     objectName,\n+                     instance,\n+                     counterName);\n@@ -482,5 +482,5 @@\n-            _snprintf(fullCounterPath,\n-                      fullCounterPathLen,\n-                      OBJECT_COUNTER_FMT,\n-                      objectName,\n-                      counterName);\n+            snprintf(fullCounterPath,\n+                     fullCounterPathLen,\n+                     OBJECT_COUNTER_FMT,\n+                     objectName,\n+                     counterName);\n@@ -722,4 +722,4 @@\n-            _snprintf(fullIDProcessCounterPath,\n-                      MAX_PATH,\n-                      pdhIDProcessCounterFmt,\n-                      index);\n+            snprintf(fullIDProcessCounterPath,\n+                     MAX_PATH,\n+                     pdhIDProcessCounterFmt,\n+                     index);\n@@ -1062,7 +1062,7 @@\n-    _snprintf(pdhIDProcessCounterFmt,\n-              pdhIDProcessCounterFmtLen,\n-              PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n-              pdhLocalizedProcessObject,\n-              pdhProcessImageName,\n-              \"%d\",\n-              pdhLocalizedIDProcessCounter);\n+    snprintf(pdhIDProcessCounterFmt,\n+             pdhIDProcessCounterFmtLen,\n+             PROCESS_OBJECT_INSTANCE_COUNTER_FMT,\n+             pdhLocalizedProcessObject,\n+             pdhProcessImageName,\n+             \"%d\",\n+             pdhLocalizedIDProcessCounter);\n","filename":"src\/jdk.management\/windows\/native\/libmanagement_ext\/OperatingSystemImpl.c","additions":30,"deletions":30,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/aix\/classes\/jdk\/net\/AIXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/linux\/classes\/jdk\/net\/LinuxSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/macosx\/classes\/jdk\/net\/MacOSXSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -33,1 +33,1 @@\n-@SuppressWarnings(\"removal\")\n+@SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.net\/windows\/classes\/jdk\/net\/WindowsSocketOptions.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -1097,1 +1097,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpChannelImpl.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -336,1 +336,1 @@\n-    @SuppressWarnings(\"removal\")\n+    @SuppressWarnings({\"removal\", \"restricted\"})\n","filename":"src\/jdk.sctp\/unix\/classes\/sun\/nio\/ch\/sctp\/SctpNet.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -132,1 +132,1 @@\n-\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/NTSystem.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+    @SuppressWarnings(\"restricted\")\n","filename":"src\/jdk.security.auth\/share\/classes\/com\/sun\/security\/auth\/module\/UnixSystem.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -70,1 +70,1 @@\n-      FLAG_SET_ERGO(MaxNewSize, 80 * M);\n+      FLAG_SET_ERGO(MaxNewSize, 50 * M);\n@@ -162,0 +162,3 @@\n+\/\/ Tests require at least 128M of MaxHeap\n+\/\/ otherwise ergonomic is different and generation sizes might be changed.\n+\n@@ -166,0 +169,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+      return;\n+  }\n@@ -178,0 +184,3 @@\n+  if (MaxHeapSize < 128 * M) {\n+    return;\n+  }\n@@ -190,2 +199,2 @@\n-  TestGenCollectorPolicy::SetNewSizeCmd setter_large(80 * M);\n-  TestGenCollectorPolicy::CheckYoungInitial checker_large(80 * M);\n+  TestGenCollectorPolicy::SetNewSizeCmd setter_large(50 * M);\n+  TestGenCollectorPolicy::CheckYoungInitial checker_large(50 * M);\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_collectorPolicy.cpp","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,7 +35,0 @@\n-  static Step start(const Stepper* stepper,\n-                    int length,\n-                    int* to_length_addr,\n-                    uint chunk_size) {\n-    return stepper->start_impl(length, to_length_addr, chunk_size);\n-  }\n-\n@@ -43,4 +36,3 @@\n-                   int length,\n-                   int* to_length_addr,\n-                   uint chunk_size) {\n-    return stepper->next_impl(length, to_length_addr, chunk_size);\n+                   size_t length,\n+                   size_t* to_length_addr) {\n+    return stepper->next_impl(length, to_length_addr);\n@@ -52,5 +44,5 @@\n-static int simulate(const Stepper* stepper,\n-                    int length,\n-                    int* to_length_addr,\n-                    uint chunk_size) {\n-  Step init = StepperSupport::start(stepper, length, to_length_addr, chunk_size);\n+static uint simulate(const Stepper* stepper,\n+                     size_t length,\n+                     size_t* to_length_addr) {\n+  Step init = stepper->start(length);\n+  *to_length_addr = init._index;\n@@ -58,1 +50,1 @@\n-  int task = 0;\n+  uint task = 0;\n@@ -61,1 +53,1 @@\n-    Step step = StepperSupport::next(stepper, length, to_length_addr, chunk_size);\n+    Step step = StepperSupport::next(stepper, length, to_length_addr);\n@@ -67,4 +59,4 @@\n-static void run_test(int length, int chunk_size, uint n_workers) {\n-  const PartialArrayTaskStepper stepper(n_workers);\n-  int to_length;\n-  int tasks = simulate(&stepper, length, &to_length, chunk_size);\n+static void run_test(size_t length, size_t chunk_size, uint n_workers) {\n+  const PartialArrayTaskStepper stepper(n_workers, chunk_size);\n+  size_t to_length;\n+  uint tasks = simulate(&stepper, length, &to_length);\n@@ -76,1 +68,1 @@\n-  for (int chunk_size = 50; chunk_size <= 500; chunk_size += 50) {\n+  for (size_t chunk_size = 50; chunk_size <= 500; chunk_size += 50) {\n@@ -78,1 +70,1 @@\n-      for (int length = 0; length <= 1000000; length = (length * 2 + 1)) {\n+      for (size_t length = 0; length <= 1000000; length = (length * 2 + 1)) {\n","filename":"test\/hotspot\/gtest\/gc\/shared\/test_partialArrayTaskStepper.cpp","additions":17,"deletions":25,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -339,1 +339,1 @@\n-  return 0;\n+  return nullptr;\n","filename":"test\/hotspot\/gtest\/gtestMain.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -70,1 +70,1 @@\n-    cld->metaspace_non_null()->deallocate(p, sz, in_class_space);\n+    cld->metaspace_non_null()->deallocate(p, sz);\n","filename":"test\/hotspot\/gtest\/metaspace\/test_metaspace_misc.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -38,1 +38,1 @@\n-  EXPECT_TRUE(si.is_invalid());\n+  EXPECT_TRUE(NCSS::is_invalid(si));\n@@ -60,1 +60,1 @@\n-      EXPECT_FALSE(NCSS::StackIndex::equals(si_arr[i],si_arr[j]));\n+      EXPECT_FALSE(NCSS::equals(si_arr[i],si_arr[j]));\n","filename":"test\/hotspot\/gtest\/nmt\/test_nmt_nativecallstackstorage.cpp","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n- uint cache_line_size = VM_Version::L1_data_cache_line_size();\n+  uint cache_line_size = VM_Version::L1_data_cache_line_size();\n@@ -32,9 +32,1 @@\n- if (cache_line_size != 0) {\n-   \/\/ We were able to determine the L1 data cache line size so\n-   \/\/ do some cache line specific sanity checks\n-   EXPECT_EQ((size_t) 0, sizeof (PaddedEnd<ObjectMonitor>) % cache_line_size)\n-        << \"PaddedEnd<ObjectMonitor> size is not a \"\n-        << \"multiple of a cache line which permits false sharing. \"\n-        << \"sizeof(PaddedEnd<ObjectMonitor>) = \"\n-        << sizeof (PaddedEnd<ObjectMonitor>)\n-        << \"; cache_line_size = \" << cache_line_size;\n+  if (cache_line_size != 0) {\n@@ -42,2 +34,10 @@\n-   EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n-        << \"the _header and _owner fields are closer \"\n+    EXPECT_EQ(in_bytes(ObjectMonitor::metadata_offset()), 0)\n+        << \"_metadata at a non 0 offset. metadata_offset = \"\n+        << in_bytes(ObjectMonitor::metadata_offset());\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _metadata and _owner fields are closer \"\n+        << \"than a cache line which permits false sharing.\";\n+\n+    EXPECT_GE((size_t) in_bytes(ObjectMonitor::recursions_offset() - ObjectMonitor::owner_offset()), cache_line_size)\n+        << \"the _owner and _recursions fields are closer \"\n","filename":"test\/hotspot\/gtest\/runtime\/test_objectMonitor.cpp","additions":12,"deletions":12,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -181,0 +181,10 @@\n+\/\/ version with a highlighted pc location\n+static void do_test_print_hex_dump_highlighted(const_address from, const_address to, int unitsize, int bytes_per_line,\n+                                   const_address logical_start, const char* expected, const_address highlight) {\n+  char buf[2048];\n+  buf[0] = '\\0';\n+  stringStream ss(buf, sizeof(buf));\n+  os::print_hex_dump(&ss, from, to, unitsize, \/* print_ascii=*\/true, bytes_per_line, logical_start, highlight);\n+  EXPECT_STREQ(buf, expected);\n+}\n+\n@@ -200,0 +210,18 @@\n+#define PAT_HL_1A \"=>\" ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              \"  \" ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#define PAT_HL_1B \"  \" ADDRESS1 \":   ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ?? ??\\n\" \\\n+              \"=>\" ADDRESS2 \":   ff ff e0 dc 23 00 6a 64 6b 2f 69 6e 74 65 72 6e 61 6c 2f 6c 6f 61 64 65 72 2f 4e 61 74 69 76 65   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c 69 62 72 61 72 69 65 73 00 00 00 00 00 00 00                                                   \" ASCII_2 \"\\n\"\n+\n+#ifdef VM_LITTLE_ENDIAN\n+#define PAT_HL_1C \"  \" ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              \"=>\" ADDRESS2 \":   ffff dce0 0023 646a 2f6b 6e69 6574 6e72 6c61 6c2f 616f 6564 2f72 614e 6974 6576   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   694c 7262 7261 6569 0073 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+#else\n+#define PAT_HL_1C \"  \" ADDRESS1 \":   ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ???? ????\\n\" \\\n+              \"=>\" ADDRESS2 \":   ffff e0dc 2300 6a64 6b2f 696e 7465 726e 616c 2f6c 6f61 6465 722f 4e61 7469 7665   \" ASCII_1 \"\\n\" \\\n+              \"  \" ADDRESS3 \":   4c69 6272 6172 6965 7300 0000 0000 0000                                           \" ASCII_2 \"\\n\"\n+#endif\n+\n@@ -255,0 +283,6 @@\n+  \/\/ print with highlighted address\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1A, from+5);\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1B, from+32);\n+  do_test_print_hex_dump_highlighted(from, to, 1, 32, logical_start, PAT_HL_1B, from+60);\n+  do_test_print_hex_dump_highlighted(from, to, 2, 32, logical_start, PAT_HL_1C, from+60);\n+\n","filename":"test\/hotspot\/gtest\/runtime\/test_os.cpp","additions":34,"deletions":0,"binary":false,"changes":34,"status":"modified"},{"patch":"@@ -32,5 +32,0 @@\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#id0            8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldAccessWatch\/setfldw001\/TestDescription.java#logging        8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#id0     8205957 generic-all\n-vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java#logging 8205957 generic-all\n-\n","filename":"test\/hotspot\/jtreg\/ProblemList-Xcomp.txt","additions":0,"deletions":5,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -56,0 +56,1 @@\n+compiler\/c2\/irTests\/TestIfMinMax.java 8339220 linux-s390x\n@@ -62,0 +63,2 @@\n+compiler\/vectorapi\/VectorRebracket128Test.java#ZSinglegen 8330538 generic-all\n+compiler\/vectorapi\/VectorRebracket128Test.java#ZGenerational 8330538 generic-all\n@@ -64,0 +67,6 @@\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/DataPatchTest.java 8331704 linux-riscv64\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/MaxOopMapStackOffsetTest.java 8331704 linux-riscv64\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/NativeCallTest.java 8331704 linux-riscv64\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleDebugInfoTest.java 8331704 linux-riscv64\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/SimpleCodeInstallationTest.java 8331704 linux-riscv64\n+compiler\/jvmci\/jdk.vm.ci.code.test\/src\/jdk\/vm\/ci\/code\/test\/VirtualObjectDebugInfoTest.java 8331704 linux-riscv64\n@@ -68,2 +77,0 @@\n-compiler\/startup\/StartupOutput.java 8326615 generic-x64\n-\n@@ -112,0 +119,1 @@\n+runtime\/Thread\/TestAlwaysPreTouchStacks.java 8335167 macosx-aarch64\n@@ -113,0 +121,2 @@\n+runtime\/exceptionMsgs\/NoClassDefFoundError\/NoClassDefFoundErrorTest.java 8339316 generic-all\n+\n","filename":"test\/hotspot\/jtreg\/ProblemList.txt","additions":12,"deletions":2,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -49,9 +49,0 @@\n-    public static long lseed = 1;\n-    public static int iseed = 2;\n-    public static short sseed = 3;\n-    public static byte bseed = 4;\n-    public static long lres = lseed;\n-    public static int ires = iseed;\n-    public static short sres = sseed;\n-    public static byte bres = bseed;\n-\n@@ -62,1 +53,1 @@\n-        private static final long data;\n+        private static final long lseed = 1;\n@@ -72,1 +63,0 @@\n-            lres += UNSAFE.getLongUnaligned(BYTES, 1030);\n@@ -74,2 +64,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 127, lres);\n-            lres += UNSAFE.getLongUnaligned(BYTES, 127);\n+            UNSAFE.putLongUnaligned(BYTES, 127, rawdata+lseed);\n@@ -77,2 +66,1 @@\n-            UNSAFE.putLongUnaligned(BYTES, 1096, lres);\n-            data = UNSAFE.getLongUnaligned(BYTES, 1096);\n+            UNSAFE.putLongUnaligned(BYTES, 1096, rawdata-lseed);\n@@ -87,1 +75,1 @@\n-        private static final int data;\n+        private static final int iseed = 2;\n@@ -96,1 +84,0 @@\n-            ires += UNSAFE.getIntUnaligned(BYTES, 274);\n@@ -98,2 +85,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 255, ires);\n-            ires += UNSAFE.getIntUnaligned(BYTES, 255);\n+            UNSAFE.putIntUnaligned(BYTES, 255, rawdata + iseed);\n@@ -101,2 +87,1 @@\n-            UNSAFE.putIntUnaligned(BYTES, 528, ires);\n-            data = UNSAFE.getIntUnaligned(BYTES, 528);\n+            UNSAFE.putIntUnaligned(BYTES, 528, rawdata - iseed);\n@@ -111,1 +96,1 @@\n-        private static final short data;\n+        private static final short sseed = 3;\n@@ -120,1 +105,0 @@\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 257));\n@@ -122,2 +106,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 253, sres);\n-            sres = (short) (sres + UNSAFE.getShortUnaligned(BYTES, 253));\n+            UNSAFE.putShortUnaligned(BYTES, 253, (short) (rawdata + sseed));\n@@ -125,2 +108,1 @@\n-            UNSAFE.putShortUnaligned(BYTES, 272, sres);\n-            data = UNSAFE.getShortUnaligned(BYTES, 272);\n+            UNSAFE.putShortUnaligned(BYTES, 272, (short) (rawdata - sseed));\n@@ -135,1 +117,1 @@\n-        private static final byte data;\n+        private static final byte bseed = 4;\n@@ -144,1 +126,0 @@\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 272));\n@@ -146,2 +127,1 @@\n-            UNSAFE.putByte(BYTES, 53, bres);\n-            bres = (byte) (bres + UNSAFE.getByte(BYTES, 53));\n+            UNSAFE.putByte(BYTES, 53, (byte) (rawdata + bseed));\n@@ -149,2 +129,1 @@\n-            UNSAFE.putByte(BYTES, 1027, bres);\n-            data = UNSAFE.getByte(BYTES, 1027);\n+            UNSAFE.putByte(BYTES, 1027, (byte) (rawdata - bseed));\n@@ -157,1 +136,3 @@\n-        Asserts.assertEquals(ta.data, (ta.rawdata + lseed) * 2, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1030), ta.rawdata, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 127), ta.rawdata + ta.lseed, \"putUnaligned long failed!\");\n+        Asserts.assertEquals(UNSAFE.getLongUnaligned(ta.BYTES, 1096), ta.rawdata - ta.lseed, \"putUnaligned long failed!\");\n@@ -160,1 +141,3 @@\n-        Asserts.assertEquals(tb.data, (tb.rawdata + iseed) * 2, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 274), tb.rawdata, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 255), tb.rawdata + tb.iseed, \"putUnaligned int failed!\");\n+        Asserts.assertEquals(UNSAFE.getIntUnaligned(tb.BYTES, 528), tb.rawdata - tb.iseed, \"putUnaligned int failed!\");\n@@ -163,1 +146,3 @@\n-        Asserts.assertEquals(tc.data, (short) (((short) (tc.rawdata + sseed)) * 2), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 257), tc.rawdata, \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 253), (short) (tc.rawdata + tc.sseed), \"putUnaligned short failed!\");\n+        Asserts.assertEquals(UNSAFE.getShortUnaligned(tc.BYTES, 272), (short) (tc.rawdata - tc.sseed), \"putUnaligned short failed!\");\n@@ -166,1 +151,3 @@\n-        Asserts.assertEquals(td.data, (byte) (((byte) (td.rawdata + bseed)) * 2), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 272), td.rawdata, \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 53), (byte) (td.rawdata + td.bseed), \"put byte failed!\");\n+        Asserts.assertEquals(UNSAFE.getByte(td.BYTES, 1027), (byte) (td.rawdata - td.bseed), \"put byte failed!\");\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/TestUnalignedAccess.java","additions":24,"deletions":37,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,135 @@\n+\/*\n+ * Copyright (c) 2024 Red Hat and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.gvn;\n+\n+import compiler.lib.ir_framework.*;\n+\n+import java.util.Random;\n+\n+\/**\n+ * @test\n+ * @bug 8327381\n+ * @summary Refactor boolean node tautology transformations\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.gvn.TestBoolNodeGVN\n+ *\/\n+public class TestBoolNodeGVN {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+        testCorrectness();\n+    }\n+\n+    \/**\n+     * Test changing ((x & m) u<= m) or ((m & x) u<= m) to always true, same with ((x & m) u< m+1) and ((m & x) u< m+1)\n+     * The test is only applicable to x64, aarch64 and riscv64 for having <code>Integer.compareUnsigned<\/code>\n+     * intrinsified.\n+     *\/\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m) > 0); \/\/ assert in inversions to generates the pattern looking for\n+    }\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(failOn = IRNode.CMP_U,\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldReplaceCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 1) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+        phase = CompilePhase.AFTER_PARSING,\n+        applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase1(int x, int m) {\n+        return !(Integer.compareUnsigned((x & m), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase2(int x, int m) {\n+        return !(Integer.compareUnsigned((m & x), m - 1) > 0);\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase3(int x, int m) {\n+        return Integer.compareUnsigned((x & m), m + 2) < 0;\n+    }\n+\n+    @Test\n+    @Arguments(values = {Argument.DEFAULT, Argument.DEFAULT})\n+    @IR(counts = {IRNode.CMP_U, \"1\"},\n+            phase = CompilePhase.AFTER_PARSING,\n+            applyIfPlatformOr = {\"x64\", \"true\", \"aarch64\", \"true\", \"riscv64\", \"true\"})\n+    public static boolean testShouldHaveCpmUCase4(int x, int m) {\n+        return Integer.compareUnsigned((m & x), m + 2) < 0;\n+    }\n+\n+    private static void testCorrectness() {\n+        int[] values = {\n+                0, 1, 5, 8, 16, 42, 100, new Random().nextInt(0, Integer.MAX_VALUE), Integer.MAX_VALUE\n+        };\n+\n+        for (int x : values) {\n+            for (int m : values) {\n+                if (!testShouldReplaceCpmUCase1(x, m) |\n+                    !testShouldReplaceCpmUCase2(x, m) |\n+                    !testShouldReplaceCpmUCase3(x, m) |\n+                    !testShouldReplaceCpmUCase4(x, m)) {\n+                    throw new RuntimeException(\"Bad result for x = \" + x + \" and m = \" + m + \", expected always true\");\n+                }\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestBoolNodeGVN.java","additions":135,"deletions":0,"binary":false,"changes":135,"status":"added"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests;\n+\n+import jdk.test.lib.Asserts;\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * bug 8336860\n+ * @summary Verify codegen for CMoveL with constants 0 and 1\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.CMoveLConstants\n+ *\/\n+public class CMoveLConstants {\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    public static long testSigned(int a, int b) {\n+        return a > b ? 1L : 0L;\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01U, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    public static long testUnsigned(int a, int b) {\n+        return Integer.compareUnsigned(a, b) > 0 ? 1L : 0L;\n+    }\n+\n+    @Test\n+    @IR(applyIfPlatform = {\"x64\", \"true\"}, counts = {IRNode.X86_CMOVEL_IMM01UCF, \"1\"}, phase = CompilePhase.FINAL_CODE)\n+    public static long testFloat(float a, float b) {\n+        return a > b ? 1L : 0L;\n+    }\n+\n+    @DontCompile\n+    public void assertResults(int a, int b) {\n+        Asserts.assertEQ(a > b ? 1L : 0L, testSigned(a, b));\n+        Asserts.assertEQ(Integer.compareUnsigned(a, b) > 0 ? 1L : 0L, testUnsigned(a, b));\n+        Asserts.assertEQ((float) a > (float) b ? 1L : 0L, testFloat(a, b));\n+    }\n+\n+    @Run(test = {\"testSigned\", \"testUnsigned\", \"testFloat\"})\n+    public void runMethod() {\n+        assertResults(10, 20);\n+        assertResults(20, 10);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/CMoveLConstants.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright (c) 2024 Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package compiler.c2.irTests.scalarReplacement;\n+\n+import compiler.lib.ir_framework.*;\n+\n+\/*\n+ * @test\n+ * @bug 8333334\n+ * @summary Tests that dead barrier control flows do not affect the scalar replacement.\n+ * @library \/test\/lib \/\n+ * @requires vm.compiler2.enabled\n+ * @requires vm.gc.G1\n+ * @run driver compiler.c2.irTests.scalarReplacement.ScalarReplacementWithGCBarrierTests\n+ *\/\n+public class ScalarReplacementWithGCBarrierTests {\n+    static class List {\n+        public Node head;\n+\n+        public void push(int value) {\n+            Node n = new Node();\n+            n.value = value;\n+            n.next = head;\n+            head = n;\n+        }\n+\n+        @ForceInline\n+        public Iter iter() {\n+            Iter iter = new Iter();\n+            iter.list = this;\n+            iter.n = head;\n+            iter.sum = 0;\n+            return iter;\n+        }\n+    }\n+\n+    static class Node {\n+        public int value;\n+        public Node next;\n+    }\n+\n+    static class Iter {\n+        public List list;\n+        public Node n;\n+        public Integer sum;\n+\n+        @ForceInline\n+        public boolean next() {\n+            int lastSum = sum;\n+            while (sum - lastSum < 1000) {\n+                while (n != null && n.value < 30) n = n.next;\n+                if (n == null) return false;\n+                sum += n.value;\n+                n = n.next;\n+            }\n+            return true;\n+        }\n+    }\n+\n+    private static final int SIZE = 1000;\n+\n+    public static void main(String[] args) {\n+        \/\/ Must use G1 GC to ensure there is a pre-barrier\n+        \/\/ before the first field write.\n+        TestFramework.runWithFlags(\"-XX:+UseG1GC\");\n+    }\n+\n+    @Run(test = \"testScalarReplacementWithGCBarrier\")\n+    private void runner() {\n+        List list = new List();\n+        for (int i = 0; i < SIZE; i++) {\n+            list.push(i);\n+        }\n+        testScalarReplacementWithGCBarrier(list);\n+    }\n+\n+    \/\/ Allocation of `Iter iter` should be eliminated by scalar replacement, and\n+    \/\/ the allocation of `Integer sum` can not be eliminated, so there should be\n+    \/\/ 1 allocation after allocations and locks elimination.\n+    \/\/\n+    \/\/ Before the patch of JDK-8333334, both allocations of `Iter` and `Integer`\n+    \/\/ could not be eliminated.\n+    @Test\n+    @IR(phase = { CompilePhase.AFTER_PARSING }, counts = { IRNode.ALLOC, \"1\" })\n+    @IR(phase = { CompilePhase.INCREMENTAL_BOXING_INLINE }, counts = { IRNode.ALLOC, \"2\" })\n+    @IR(phase = { CompilePhase.ITER_GVN_AFTER_ELIMINATION }, counts = { IRNode.ALLOC, \"1\" })\n+    private int testScalarReplacementWithGCBarrier(List list) {\n+        Iter iter = list.iter();\n+        while (true) {\n+            while (iter.next()) {}\n+            if (list.head == null) break;\n+            list.head = list.head.next;\n+            iter.n = list.head;\n+        }\n+        return iter.sum;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/scalarReplacement\/ScalarReplacementWithGCBarrierTests.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,170 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final int[] EMPTY_INTEGER = new int[] { 0 };\n+    static final int[] FULL_INTEGER = new int[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        int[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        int[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        int[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            return is[0];\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimArrayTest.java","additions":170,"deletions":0,"binary":false,"changes":170,"status":"added"},{"patch":"@@ -0,0 +1,100 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        final int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? 42 : 0;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for final fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Single header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimFinalTest.java","additions":100,"deletions":0,"binary":false,"changes":100,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Primitive inits have no membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimPlainTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,114 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StablePrimVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StablePrimVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static class Carrier {\n+        @Stable\n+        volatile int field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = 42;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = 42;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \"1\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers expected for volatile fields.\n+        return BLANK_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        return INIT_CARRIER.field;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Expect only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile barriers expected.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Volatile barriers expected.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StablePrimVolatileTest.java","additions":114,"deletions":0,"binary":false,"changes":114,"status":"added"},{"patch":"@@ -0,0 +1,179 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefArrayTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefArrayTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer[] EMPTY_INTEGER = new Integer[] { null };\n+    static final Integer[] FULL_INTEGER = new Integer[] { 42 };\n+\n+    static class Carrier {\n+        @Stable\n+        Integer[] field;\n+\n+        @ForceInline\n+        public Carrier(int initLevel) {\n+            switch (initLevel) {\n+                case 0:\n+                    \/\/ Do nothing.\n+                    break;\n+                case 1:\n+                    field = EMPTY_INTEGER;\n+                    break;\n+                case 2:\n+                    field = FULL_INTEGER;\n+                    break;\n+                default:\n+                    throw new IllegalStateException(\"Unknown level\");\n+            }\n+        }\n+\n+        @ForceInline\n+        public void initEmpty() {\n+            field = EMPTY_INTEGER;\n+        }\n+\n+        @ForceInline\n+        public void initFull() {\n+            field = FULL_INTEGER;\n+        }\n+\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(0);\n+    static final Carrier INIT_EMPTY_CARRIER = new Carrier(1);\n+    static final Carrier INIT_FULL_CARRIER = new Carrier(2);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = BLANK_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testPartialFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer[] is = INIT_EMPTY_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer[] is = INIT_FULL_CARRIER.field;\n+        if (is != null) {\n+            Integer i = is[0];\n+            if (i != null) {\n+                return i;\n+            }\n+        }\n+        return 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(0);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorEmptyInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(1);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(2);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodEmptyInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_EMPTY_CARRIER.initEmpty();\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodFullInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_FULL_CARRIER.initFull();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefArrayTest.java","additions":179,"deletions":0,"binary":false,"changes":179,"status":"added"},{"patch":"@@ -0,0 +1,97 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefFinalTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefFinalTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        final Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            field = init ? INTEGER : null;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorInit() {\n+        \/\/ Only the header+final barrier.\n+        return new Carrier(true);\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefFinalTest.java","additions":97,"deletions":0,"binary":false,"changes":97,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefPlainTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefPlainTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ No barriers expected for plain fields.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.MEMBAR })\n+    static void testMethodInit() {\n+        \/\/ Reference inits do not have membars.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefPlainTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -0,0 +1,118 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333791\n+ * @requires os.arch==\"aarch64\" | os.arch==\"riscv64\" | os.arch==\"x86_64\" | os.arch==\"amd64\"\n+ * @requires vm.gc.Parallel\n+ * @requires vm.compiler2.enabled\n+ * @summary Check stable field folding and barriers\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver compiler.c2.irTests.stable.StableRefVolatileTest\n+ *\/\n+\n+package compiler.c2.irTests.stable;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+import jdk.internal.vm.annotation.Stable;\n+\n+public class StableRefVolatileTest {\n+\n+    public static void main(String[] args) {\n+        TestFramework tf = new TestFramework();\n+        tf.addTestClassesToBootClassPath();\n+        tf.addFlags(\n+            \"-XX:+UnlockExperimentalVMOptions\",\n+            \"-XX:CompileThreshold=100\",\n+            \"-XX:-TieredCompilation\",\n+            \"-XX:+UseParallelGC\"\n+        );\n+        tf.start();\n+    }\n+\n+    static final Integer INTEGER = 42;\n+\n+    static class Carrier {\n+        @Stable\n+        volatile Integer field;\n+\n+        @ForceInline\n+        public Carrier(boolean init) {\n+            if (init) {\n+                field = INTEGER;\n+            }\n+        }\n+\n+        @ForceInline\n+        public void init() {\n+            field = INTEGER;\n+        }\n+    }\n+\n+    static final Carrier BLANK_CARRIER = new Carrier(false);\n+    static final Carrier INIT_CARRIER = new Carrier(true);\n+\n+    @Test\n+    @IR(counts = { IRNode.LOAD, \">0\" })\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static int testNoFold() {\n+        \/\/ Access should not be folded.\n+        \/\/ Barriers are expected for volatile field.\n+        Integer i = BLANK_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(failOn = { IRNode.LOAD, IRNode.MEMBAR })\n+    static int testFold() {\n+        \/\/ Access should be completely folded.\n+        Integer i = INIT_CARRIER.field;\n+        return i != null ? i : 0;\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR_STORESTORE, \"1\" })\n+    static Carrier testConstructorBlankInit() {\n+        \/\/ Only the header barrier.\n+        return new Carrier(false);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static Carrier testConstructorFullInit() {\n+        \/\/ Volatile writes, expect more barriers.\n+        return new Carrier(true);\n+    }\n+\n+    @Test\n+    @IR(counts = { IRNode.MEMBAR, \">0\" })\n+    static void testMethodInit() {\n+        \/\/ Barriers are expected for volatile fields.\n+        INIT_CARRIER.init();\n+    }\n+\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/irTests\/stable\/StableRefVolatileTest.java","additions":118,"deletions":0,"binary":false,"changes":118,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -190,2 +190,11 @@\n-        \/\/ minimum size: CodeCacheMinimumUseSpace DEBUG_ONLY(* 3)\n-        long minSize = (Platform.isDebugBuild() ? 3 : 1) * minUseSpace;\n+        long nMethodSizeLimit = WHITE_BOX.getIntxVMFlag(\"NMethodSizeLimit\");\n+        long codeEntryAlignment = WHITE_BOX.getIntxVMFlag(\"CodeEntryAlignment\");\n+        long c1MinCodeCacheSize = 11 * nMethodSizeLimit \/ 10;\n+        long c2MinCodeCacheSize = 2048 \/* PhaseOutput::MAX_inst_size *\/ +\n+                                  128 \/* PhaseOutput::MAX_stubs_size *\/ +\n+                                  4 * 1024 \/* initial_const_capacity *\/ +\n+                                  2 * Math.max(64, codeEntryAlignment) \/* 2 * CodeSection::end_slop() *\/ +\n+                                  2 * 128 \/* sizeof(relocInfo) * PhaseOutput::MAX_locs_size *\/;\n+        \/\/ minimum size: CompilerConfig::min_code_cache_size =\n+        \/\/ CodeCacheMinimumUseSpace DEBUG_ONLY(* 3) + Compiler::code_buffer_size() + C2Compiler::initial_code_buffer_size())\n+        long minSize = minUseSpace * (Platform.isDebugBuild() ? 3 : 1) + c1MinCodeCacheSize + c2MinCodeCacheSize;\n","filename":"test\/hotspot\/jtreg\/compiler\/codecache\/CheckSegmentedCodeCache.java","additions":12,"deletions":3,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -442,1 +442,1 @@\n-        beforeMatchingNameRegex(CMP_U, \"CmpU\");\n+        beforeMatchingNameRegex(CMP_U, \"CmpU\\\\b\");\n@@ -2236,0 +2236,15 @@\n+    public static final String X86_CMOVEL_IMM01 = PREFIX + \"X86_CMOVEL_IMM01\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01, \"cmovL_imm_01\");\n+    }\n+\n+    public static final String X86_CMOVEL_IMM01U = PREFIX + \"X86_CMOVEL_IMM01U\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01U, \"cmovL_imm_01U\");\n+    }\n+\n+    public static final String X86_CMOVEL_IMM01UCF = PREFIX + \"X86_CMOVEL_IMM01UCF\" + POSTFIX;\n+    static {\n+        machOnlyNameRegex(X86_CMOVEL_IMM01UCF, \"cmovL_imm_01UCF\");\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/IRNode.java","additions":16,"deletions":1,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -160,1 +160,10 @@\n-### 2.5 Framework Debug and Stress Flags\n+### 2.5 IR Tests with Privileged Classes\n+To run tests in a privileged mode (e.g. when using `@Stable`, `@Contended`, `@ReservedStackAccess` etc.), one need to add the test classes to the boot classpath. This can easily be achieved by calling `TestFramework.addTestClassesToBootClassPath()` on the test framework object:\n+```\n+TestFramework testFramework = new TestFramework();\n+testFramework\n+        .addTestClassesToBootClassPath()\n+        .start();\n+```\n+\n+### 2.6 Framework Debug and Stress Flags\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/README.md","additions":10,"deletions":1,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -175,0 +175,1 @@\n+    private boolean testClassesOnBootClassPath;\n@@ -326,0 +327,9 @@\n+    \/**\n+     * Add test classes to boot classpath. This adds all classes found on path {@link jdk.test.lib.Utils#TEST_CLASSES}\n+     * to the boot classpath with \"-Xbootclasspath\/a\". This is useful when trying to run tests in a privileged mode.\n+     *\/\n+    public TestFramework addTestClassesToBootClassPath() {\n+        this.testClassesOnBootClassPath = true;\n+        return this;\n+    }\n+\n@@ -747,1 +757,2 @@\n-        TestVMProcess testVMProcess = new TestVMProcess(additionalFlags, testClass, helperClasses, defaultWarmup);\n+        TestVMProcess testVMProcess = new TestVMProcess(additionalFlags, testClass, helperClasses, defaultWarmup,\n+                                                        testClassesOnBootClassPath);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/TestFramework.java","additions":12,"deletions":1,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,0 +37,1 @@\n+import java.io.File;\n@@ -66,1 +67,2 @@\n-    public TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup) {\n+    public TestVMProcess(List<String> additionalFlags, Class<?> testClass, Set<Class<?>> helperClasses, int defaultWarmup,\n+                         boolean testClassesOnBootClassPath) {\n@@ -70,1 +72,1 @@\n-            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup);\n+            prepareTestVMFlags(additionalFlags, socket, testClass, helperClasses, defaultWarmup, testClassesOnBootClassPath);\n@@ -94,1 +96,1 @@\n-                                    Set<Class<?>> helperClasses, int defaultWarmup) {\n+                                    Set<Class<?>> helperClasses, int defaultWarmup, boolean testClassesOnBootClassPath) {\n@@ -98,1 +100,6 @@\n-        cmds.add(\"-Xbootclasspath\/a:.\");\n+        String bootClassPath = \"-Xbootclasspath\/a:.\";\n+        if (testClassesOnBootClassPath) {\n+            \/\/ Add test classes themselves to boot classpath to make them privileged.\n+            bootClassPath += File.pathSeparator + Utils.TEST_CLASS_PATH;\n+        }\n+        cmds.add(bootClassPath);\n","filename":"test\/hotspot\/jtreg\/compiler\/lib\/ir_framework\/driver\/TestVMProcess.java","additions":12,"deletions":5,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,57 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8336830\n+ * @summary C2: assert(get_loop(lca)->_nest < n_loop->_nest || lca->in(0)->is_NeverBranch()) failed: must not be moved into inner loop\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:CompileCommand=compileonly,TestSunkNodeInInfiniteLoop::* -Xcomp TestSunkNodeInInfiniteLoop\n+ *\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+public class TestSunkNodeInInfiniteLoop {\n+    public static void main(String[] args) throws InterruptedException {\n+        byte[] a = new byte[1];\n+        Thread thread = new Thread(() -> test(a));\n+        thread.setDaemon(true);\n+        thread.start();\n+        Thread.sleep(Utils.adjustTimeout(4000));\n+    }\n+\n+    static void test(byte[] a) {\n+        \/\/ L0:\n+        while(true) {\n+            int i1 = a.length;\n+            \/\/ L3:\n+            while(true) {\n+                int i2 = 0;\n+                if ((i1--) <= 0) { break; \/* ifle L0 *\/}\n+                a[i2++] = -1;\n+                \/\/ goto L3\n+            }\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestSunkNodeInInfiniteLoop.java","additions":57,"deletions":0,"binary":false,"changes":57,"status":"added"},{"patch":"@@ -56,0 +56,1 @@\n+    static final int[] GOLDEN_M;\n@@ -74,0 +75,1 @@\n+        GOLDEN_M = testm(new int[ITER]);\n@@ -83,1 +85,1 @@\n-                 \"testi\", \"testj\", \"testk\", \"testl\"})\n+                 \"testi\", \"testj\", \"testk\", \"testl\", \"testm\"})\n@@ -98,0 +100,1 @@\n+        compare(testm(new int[ITER]), GOLDEN_M, \"testm\");\n@@ -302,0 +305,13 @@\n+    @Test\n+    @IR(counts = {IRNode.MUL_ADD_S2I, \"> 0\"},\n+        applyIfCPUFeatureOr = {\"sse2\", \"true\", \"asimd\", \"true\"})\n+    @IR(counts = {IRNode.MUL_ADD_VS2VI, \"= 0\"})\n+    public static int[] testm(int[] out) {\n+        for (int i = 0; i < ITER-4; i+=4) {\n+            \/\/ Unrolled, with some swaps that prevent vectorization.\n+            out[i+0] += ((sArr1[2*i+0] * sArr2[2*i+1]) + (sArr1[2*i+1] * sArr2[2*i+0])); \/\/ bad\n+            out[i+1] += ((sArr1[2*i+2] * sArr2[2*i+2]) + (sArr1[2*i+3] * sArr2[2*i+3])); \/\/ ok\n+            \/\/ 2-element gap\n+        }\n+        return out;\n+    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMulAddS2I.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -38,1 +38,1 @@\n-* @bug 8299259\n+* @bug 8299259 8336729\n@@ -46,0 +46,22 @@\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM -XX:StressSeed=3434\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n+\/**\n+ * @test\n+ * @key stress randomness\n+ * @bug 8336729\n+ * @requires vm.compiler2.enabled\n+ * @summary Test various cases of divisions\/modulo which should not be split through iv phis.\n+ * @run main\/othervm -Xcomp -XX:+UnlockDiagnosticVMOptions -XX:LoopUnrollLimit=0 -XX:+StressGCM\n+ *                   -XX:CompileCommand=compileonly,compiler.splitif.TestSplitDivisionThroughPhi::*\n+ *                   compiler.splitif.TestSplitDivisionThroughPhi\n+ *\/\n+\n@@ -64,0 +86,2 @@\n+            testPushDivLThruPhiForOuterLongLoop();\n+            testPushModLThruPhiForOuterLongLoop();\n@@ -81,0 +105,21 @@\n+    \/\/ Fixed with JDK-8336729.\n+    static void testPushDivLThruPhiForOuterLongLoop() {\n+        \/\/ This loop is first transformed into a LongCountedLoop in the first loop opts phase.\n+        \/\/ In the second loop opts phase, the LongCountedLoop is split into an inner and an outer loop. Both get the\n+        \/\/ same iv phi type which is [2..10]. Only the inner loop is transformed into a CountedLoopNode while the outer\n+        \/\/ loop is still a LoopNode. We run into the same problem as described in testPushDivIThruPhi() when splitting\n+        \/\/ the DivL node through the long iv phi of the outer LoopNode.\n+        \/\/ The fix for JDK-8299259 only prevents this splitting for CountedLoopNodes. We now extend it to LoopNodes\n+        \/\/ in general.\n+        for (long i = 10; i > 1; i -= 2) {\n+            lFld = 10 \/ i;\n+        }\n+    }\n+\n+    \/\/ Same as testPushDivLThruPhiForOuterLongLoop() but for ModL.\n+    static void testPushModLThruPhiForOuterLongLoop() {\n+        for (int i = 10; i > 1; i -= 2) {\n+            iFld = 10 % i;\n+        }\n+    }\n+\n","filename":"test\/hotspot\/jtreg\/compiler\/splitif\/TestSplitDivisionThroughPhi.java","additions":48,"deletions":3,"binary":false,"changes":51,"status":"modified"},{"patch":"@@ -1,131 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test id=default\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ShenandoahHumongousThreshold=90 -XX:ShenandoahGCHeuristics=aggressive\n- *                   TestHumongousThreshold\n- *\/\n-\n-\/*\n- * @test id=16b\n- * @key randomness\n- * @requires vm.gc.Shenandoah\n- * @requires vm.bits == \"64\"\n- * @library \/test\/lib\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=50\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=90\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=99\n- *                   TestHumongousThreshold\n- * @run main\/othervm -XX:+UnlockDiagnosticVMOptions -XX:+UnlockExperimentalVMOptions -XX:+UseShenandoahGC -Xmx1g\n- *                   -XX:-UseTLAB -XX:ObjectAlignmentInBytes=16 -XX:+ShenandoahVerify -XX:ShenandoahHumongousThreshold=100\n- *                   TestHumongousThreshold\n- *\/\n-\n-import java.util.Random;\n-import jdk.test.lib.Utils;\n-\n-public class TestHumongousThreshold {\n-\n-    static final long TARGET_MB = Long.getLong(\"target\", 20_000); \/\/ 20 Gb allocation\n-\n-    static volatile Object sink;\n-\n-    public static void main(String[] args) throws Exception {\n-        final int min = 0;\n-        final int max = 384 * 1024;\n-        long count = TARGET_MB * 1024 * 1024 \/ (16 + 4 * (min + (max - min) \/ 2));\n-\n-        Random r = Utils.getRandomInstance();\n-        for (long c = 0; c < count; c++) {\n-            sink = new int[min + r.nextInt(max - min)];\n-        }\n-    }\n-\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/TestHumongousThreshold.java","additions":0,"deletions":131,"binary":false,"changes":131,"status":"deleted"},{"patch":"@@ -1,72 +0,0 @@\n-\/*\n- * Copyright (c) 2017, 2018, Red Hat, Inc. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\n- *\/\n-\n-\/*\n- * @test\n- * @summary Test that Shenandoah humongous threshold args are checked\n- * @requires vm.gc.Shenandoah\n- * @library \/test\/lib\n- * @modules java.base\/jdk.internal.misc\n- *          java.management\n- * @run driver TestHumongousThresholdArgs\n- *\/\n-\n-import jdk.test.lib.process.ProcessTools;\n-import jdk.test.lib.process.OutputAnalyzer;\n-\n-public class TestHumongousThresholdArgs {\n-    public static void main(String[] args) throws Exception {\n-        {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        int[] valid = new int[] {1, 10, 50, 90, 100};\n-        int[] invalid = new int[] {-100, -1, 0, 101, 1000};\n-\n-        for (int v : valid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(0);\n-        }\n-\n-        for (int v : invalid) {\n-            OutputAnalyzer output = ProcessTools.executeLimitedTestJava(\n-                    \"-Xmx128m\",\n-                    \"-XX:+UnlockExperimentalVMOptions\",\n-                    \"-XX:+UseShenandoahGC\",\n-                    \"-XX:ShenandoahHumongousThreshold=\" + v,\n-                    \"-version\");\n-            output.shouldHaveExitValue(1);\n-        }\n-    }\n-}\n","filename":"test\/hotspot\/jtreg\/gc\/shenandoah\/options\/TestHumongousThresholdArgs.java","additions":0,"deletions":72,"binary":false,"changes":72,"status":"deleted"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,1 +30,1 @@\n-    public static final int JNI_VERSION_21 = 0x00150000;\n+    public static final int JNI_VERSION_24 = 0x00180000;\n@@ -35,1 +35,1 @@\n-        if (res != JNI_VERSION_21) {\n+        if (res != JNI_VERSION_24) {\n","filename":"test\/hotspot\/jtreg\/native_sanity\/JniVersion.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -73,0 +73,3 @@\n+        if (Platform.isLinux()) {\n+            deprecated.add(new String[] { \"UseLinuxPosixThreadCPUClocks\", \"true\" });\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/CommandLine\/VMDeprecatedOptions.java","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,244 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test id=NormalDeflation\n+ * @summary A collection of small tests using synchronized, wait, notify to try\n+ *          and achieve good cheap coverage of UseObjectMonitorTable.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+\/**\n+ * @test id=ExtremeDeflation\n+ * @summary Run the same tests but with deflation running constantly.\n+ * @library \/test\/lib\n+ * @run main\/othervm -XX:+UnlockDiagnosticVMOptions\n+ *                   -XX:GuaranteedAsyncDeflationInterval=1\n+ *                   -XX:+UseObjectMonitorTable\n+ *                   UseObjectMonitorTableTest\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+\n+import java.lang.Runnable;\n+import java.util.concurrent.BrokenBarrierException;\n+import java.util.concurrent.CyclicBarrier;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.Random;\n+import java.util.stream.Stream;\n+\n+public class UseObjectMonitorTableTest {\n+    static final ThreadFactory TF = Executors.defaultThreadFactory();\n+\n+    static class WaitNotifyTest implements Runnable {\n+        static final int ITERATIONS = 10_000;\n+        static final int THREADS = 10;\n+        final WaitNotifySyncChannel startLatchChannel = new WaitNotifySyncChannel();\n+        final WaitNotifySyncChannel endLatchChannel = new WaitNotifySyncChannel();\n+        int count = 0;\n+\n+        static class WaitNotifyCountDownLatch {\n+            int latch;\n+            WaitNotifyCountDownLatch(int count) {\n+                latch = count;\n+            }\n+            synchronized void await() {\n+                while (latch != 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+            }\n+            synchronized void countDown() {\n+                if (latch != 0) {\n+                    latch--;\n+                    if (latch == 0) {\n+                        notifyAll();\n+                    }\n+                }\n+            }\n+        }\n+        static class WaitNotifySyncChannel extends WaitNotifyCountDownLatch {\n+            WaitNotifyCountDownLatch object;\n+            WaitNotifySyncChannel() { super(0); }\n+            synchronized void send(WaitNotifyCountDownLatch object, int count) {\n+                await();\n+                latch = count;\n+                this.object = object;\n+                notifyAll();\n+            }\n+            synchronized WaitNotifyCountDownLatch receive() {\n+                while (latch == 0) {\n+                    try {\n+                        wait();\n+                    } catch (InterruptedException e) {\n+                        throw new RuntimeException(\"WaitNotifyTest: Unexpected interrupt\", e);\n+                    }\n+                }\n+                countDown();\n+                return object;\n+            }\n+        }\n+        synchronized int getCount() {\n+            return count;\n+        }\n+        synchronized void increment() {\n+            count++;\n+        }\n+        public void run() {\n+            System.out.println(\"WaitNotifyTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        startLatchChannel.receive().await();\n+                        increment();\n+                        endLatchChannel.receive().countDown();\n+                    }\n+                }).start();\n+            }\n+            for (int i = 0; i < ITERATIONS; i++) {\n+                WaitNotifyCountDownLatch startLatch = new WaitNotifyCountDownLatch(1);\n+                WaitNotifyCountDownLatch endLatch = new WaitNotifyCountDownLatch(THREADS);\n+                int count = getCount();\n+                if (count != i * THREADS) {\n+                    throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count +\n+                                               \" pre-iteration \" + i);\n+                }\n+                startLatchChannel.send(startLatch, 10);\n+                startLatch.countDown();\n+                endLatchChannel.send(endLatch, 10);\n+                endLatch.await();\n+            }\n+            int count = getCount();\n+            if (count != ITERATIONS * THREADS) {\n+                throw new RuntimeException(\"WaitNotifyTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"WaitNotifyTest passed.\");\n+        }\n+    }\n+\n+    static class RandomDepthTest implements Runnable {\n+        static final int THREADS = 10;\n+        static final int ITERATIONS = 10_000;\n+        static final int MAX_DEPTH = 20;\n+        static final int MAX_RECURSION_COUNT = 10;\n+        static final double RECURSION_CHANCE = .25;\n+        final Random random = Utils.getRandomInstance();\n+        final Locker lockers[] = new Locker[MAX_DEPTH];\n+        final CyclicBarrier syncBarrier = new CyclicBarrier(THREADS + 1);\n+        int count = 0;\n+\n+        class Locker {\n+            final int depth;\n+            Locker(int depth) {\n+                this.depth = depth;\n+            }\n+            synchronized int getCount() {\n+                if (depth == MAX_DEPTH) {\n+                    return count;\n+                }\n+                return lockers[depth].getCount();\n+            }\n+            synchronized void increment(int recursion_count) {\n+                if (recursion_count != MAX_RECURSION_COUNT &&\n+                    random.nextDouble() < RECURSION_CHANCE) {\n+                    this.increment(recursion_count + 1);\n+                    return;\n+                }\n+                if (depth == MAX_DEPTH) {\n+                    count++;\n+                    return;\n+                }\n+                lockers[depth + random.nextInt(MAX_DEPTH - depth)].increment(recursion_count);\n+            }\n+            synchronized Locker create() {\n+                if (depth != MAX_DEPTH) {\n+                    lockers[depth] = (new Locker(depth + 1)).create();\n+                }\n+                return this;\n+            }\n+        }\n+        int getCount() {\n+            return lockers[0].getCount();\n+        }\n+        void increment() {\n+            lockers[random.nextInt(MAX_DEPTH)].increment(0);\n+        }\n+        void create() {\n+            lockers[0] = (new Locker(1)).create();\n+        }\n+        void syncPoint() {\n+            try {\n+                syncBarrier.await();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected interrupt\", e);\n+            } catch (BrokenBarrierException e) {\n+                throw new RuntimeException(\"RandomDepthTest: Unexpected broken barrier\", e);\n+            }\n+        }\n+        public void run() {\n+            System.out.println(\"RandomDepthTest started.\");\n+            for (int t = 0; t < THREADS; t++) {\n+                TF.newThread(() -> {\n+                    syncPoint();\n+                    for (int i = 0; i < ITERATIONS; i++) {\n+                        increment();\n+                    }\n+                    syncPoint();\n+                }).start();\n+            }\n+            create();\n+            syncPoint();\n+            syncPoint();\n+            int count = getCount();\n+            if (count != THREADS * ITERATIONS) {\n+                throw new RuntimeException(\"RandomDepthTest: Invalid Count \" + count);\n+            }\n+            System.out.println(\"RandomDepthTest passed.\");\n+        }\n+    }\n+\n+    public static void main(String[] args) {\n+        Stream.of(\n+            TF.newThread(new WaitNotifyTest()),\n+            TF.newThread(new RandomDepthTest())\n+        ).map(t -> {\n+            t.start();\n+            return t;\n+        }).forEach(t -> {\n+            try {\n+                t.join();\n+            } catch (InterruptedException e) {\n+                throw new RuntimeException(\"UseObjectMonitorTableTest: Unexpected interrupt\", e);\n+            }\n+        });\n+\n+        System.out.println(\"UseObjectMonitorTableTest passed.\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/Monitor\/UseObjectMonitorTableTest.java","additions":244,"deletions":0,"binary":false,"changes":244,"status":"added"},{"patch":"@@ -119,2 +119,3 @@\n-                                     \"|(java.lang.OutOfMemoryError: Java heap space)\" +\n-                                     \"|(Initial heap size set to a larger value than the maximum heap size))\";\n+                                     \"|(Initial heap size set to a larger value than the maximum heap size)\" +\n+                                     \"|(java.lang.OutOfMemoryError)\" +\n+                                     \"|(Error: A JNI error has occurred, please check your installation and try again))\";\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestParallelGCWithCDS.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,89 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8293650\n+ * @requires vm.cds\n+ * @requires vm.bits == 64\n+ * @requires vm.gc.Shenandoah\n+ * @requires vm.gc.G1\n+ * @requires vm.gc == null\n+ * @library \/test\/lib \/test\/hotspot\/jtreg\/runtime\/cds\/appcds\n+ * @compile test-classes\/Hello.java\n+ * @run driver TestShenandoahWithCDS\n+ *\/\n+\n+import jdk.test.lib.Platform;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestShenandoahWithCDS {\n+    public final static String HELLO = \"Hello World\";\n+    static String helloJar;\n+\n+    public static void main(String... args) throws Exception {\n+        helloJar = JarBuilder.build(\"hello\", \"Hello\");\n+\n+        \/\/ Run with the variety of region sizes, and combinations\n+        \/\/ of G1\/Shenandoah at dump\/exec times. \"-1\" means to use G1.\n+        final int[] regionSizes = { -1, 256, 512, 1024, 2048 };\n+\n+        for (int dumpRegionSize : regionSizes) {\n+            for (int execRegionSize : regionSizes) {\n+                test(dumpRegionSize, execRegionSize);\n+            }\n+        }\n+    }\n+\n+    static void test(int dumpRegionSize, int execRegionSize) throws Exception {\n+        String exp = \"-XX:+UnlockExperimentalVMOptions\";\n+        String optDumpGC = (dumpRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optExecGC = (execRegionSize != -1) ? \"-XX:+UseShenandoahGC\" : \"-XX:+UseG1GC\";\n+        String optDumpRegionSize = (dumpRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + dumpRegionSize + \"K\" : exp;\n+        String optExecRegionSize = (execRegionSize != -1) ? \"-XX:ShenandoahRegionSize=\" + execRegionSize + \"K\" : exp;\n+        OutputAnalyzer out;\n+\n+        System.out.println(\"0. Dump with \" + optDumpGC + \" and \" + optDumpRegionSize);\n+        out = TestCommon.dump(helloJar,\n+                              new String[] {\"Hello\"},\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optDumpGC,\n+                              optDumpRegionSize,\n+                              \"-Xlog:cds\");\n+        out.shouldContain(\"Dumping shared data to file:\");\n+        out.shouldHaveExitValue(0);\n+\n+        System.out.println(\"1. Exec with \" + optExecGC + \" and \" + optExecRegionSize);\n+        out = TestCommon.exec(helloJar,\n+                              exp,\n+                              \"-Xmx1g\",\n+                              optExecGC,\n+                              optExecRegionSize,\n+                              \"-Xlog:cds\",\n+                              \"Hello\");\n+        out.shouldContain(HELLO);\n+        out.shouldHaveExitValue(0);\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/cds\/appcds\/TestShenandoahWithCDS.java","additions":89,"deletions":0,"binary":false,"changes":89,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8056900\n+ * @bug 8056900 8338888\n@@ -31,1 +31,1 @@\n- * @run main\/native NoClassDefFoundErrorTest\n+ * @run main\/native\/othervm -Xlog:exceptions=info NoClassDefFoundErrorTest\n@@ -39,0 +39,1 @@\n+    \/\/ Use the specified name\n@@ -41,0 +42,5 @@\n+    \/\/ Use a name longer than a Java string - returns false\n+    \/\/ if native allocation failed.\n+    static native boolean tryCallDefineClass();\n+    static native boolean tryCallFindClass();\n+\n@@ -57,1 +63,1 @@\n-        \/\/ Test JVM_DefineClass() with long name.\n+        System.out.println(\"Test JVM_DefineClass() with long name\");\n@@ -67,1 +73,1 @@\n-        \/\/ Test JNI_DefineClass() with long name.\n+        System.out.println(\"Test JNI_DefineClass() with long name\");\n@@ -77,1 +83,1 @@\n-        \/\/ Test JNI_FindClass() with long name.\n+        System.out.println(\"Test JNI_FindClass() with long name\");\n@@ -80,1 +86,1 @@\n-            throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n@@ -87,1 +93,1 @@\n-        \/\/ Test JNI_FindClass() with null name.\n+        System.out.println(\"Test JNI_FindClass() with null name\");\n@@ -96,0 +102,26 @@\n+\n+        System.out.println(\"Test JNI_DefineClass() with giant name\");\n+        try {\n+            if (tryCallDefineClass()) {\n+                throw new RuntimeException(\"DefineClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n+\n+        System.out.println(\"Test JNI_FindClass() with giant name\");\n+        try {\n+            if (tryCallFindClass()) {\n+                throw new RuntimeException(\"FindClass did not throw expected NoClassDefFoundError\");\n+            } else {\n+                System.out.println(\"Test skipped due to native allocation failure\");\n+            }\n+        } catch (NoClassDefFoundError e) {\n+            if (!e.getMessage().contains(\"Class name exceeds maximum length of \")) {\n+                throw new RuntimeException(\"Wrong NoClassDefFoundError: \" + e.getMessage());\n+            }\n+        }\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/NoClassDefFoundErrorTest.java","additions":40,"deletions":8,"binary":false,"changes":48,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,4 @@\n+#include <limits.h>\n+#include <stdlib.h>\n+#include <string.h>\n+\n@@ -45,0 +49,31 @@\n+static char* giant_string() {\n+    size_t len = ((size_t)INT_MAX) + 3;\n+    char* c_name = malloc(len * sizeof(char));\n+    if (c_name != NULL) {\n+        memset(c_name, 'Y', len - 1);\n+        c_name[len - 1] = '\\0';\n+    }\n+    return c_name;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallDefineClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        (*env)->DefineClass(env, c_name, NULL, NULL, 0);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n+\n+JNIEXPORT jboolean JNICALL\n+Java_NoClassDefFoundErrorTest_tryCallFindClass(JNIEnv *env, jclass klass) {\n+    char* c_name = giant_string();\n+    if (c_name != NULL) {\n+        jclass cls = (*env)->FindClass(env, c_name);\n+        free(c_name);\n+        return JNI_TRUE;\n+    }\n+    return JNI_FALSE;\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/exceptionMsgs\/NoClassDefFoundError\/libNoClassDefFoundErrorTest.c","additions":36,"deletions":1,"binary":false,"changes":37,"status":"modified"},{"patch":"@@ -0,0 +1,35 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsr\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        return;\n+    LABEL:\n+        nop;\n+        jsr LABEL; \/\/ bci=2. Compute bci + length(jsr) -> bci = 5 accessed, out of bounds.\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsr.jasm","additions":35,"deletions":0,"binary":false,"changes":35,"status":"added"},{"patch":"@@ -0,0 +1,37 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\n+ *\/\n+\n+super public class LastJsrReachable\n+{\n+    public static Method test:\"()V\"\n+    stack 100 locals 100\n+    {\n+        goto LB2;\n+    LABEL:\n+        return;\n+    LB2:\n+        nop;\n+        jsr LABEL;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrReachable.jasm","additions":37,"deletions":0,"binary":false,"changes":37,"status":"added"},{"patch":"@@ -0,0 +1,42 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8335664 8338924\n+ * @summary Ensure a program that ends with a JSR does not crash\n+ * @library \/test\/lib\n+ * @compile LastJsr.jasm\n+ * @compile LastJsrReachable.jasm\n+ * @run main\/othervm -Xbatch LastJsrTest\n+ *\/\n+\n+public class LastJsrTest {\n+    public static void main(String[] args) {\n+        for (int i = 0; i < 1000; ++i) {\n+            LastJsr.test();\n+            LastJsrReachable.test();\n+        }\n+        System.out.println(\"PASSED\");\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/interpreter\/LastJsrTest.java","additions":42,"deletions":0,"binary":false,"changes":42,"status":"added"},{"patch":"@@ -52,0 +52,1 @@\n+                                                                 \"--enable-native-access=ALL-UNNAMED\",\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestCheckedReleaseArrayElements.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/* @test\n+ * @bug 8328877\n+ * @summary Test warning for GetStringUTFLength and functionality of GetStringUTFLengthAsLong\n+ * @requires vm.bits == 64\n+ * @library \/test\/lib\n+ * @modules java.management\n+ * @run main\/native TestLargeUTF8Length launch\n+ *\/\n+\n+import java.util.Arrays;\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.ProcessTools;\n+import jdk.test.lib.process.OutputAnalyzer;\n+\n+public class TestLargeUTF8Length {\n+\n+    static {\n+        System.loadLibrary(\"TestLargeUTF8Length\");\n+    }\n+\n+    static native void checkUTF8Length(String s, long utf8Length);\n+\n+    static void test() {\n+        int length = Integer.MAX_VALUE\/2 + 1;\n+        char character = (char)0XD1; \/\/ N with tilde\n+        long utf8Length = 2L * length;\n+        char[] chrs = new char[length];\n+        Arrays.fill(chrs, character);\n+        String s = new String(chrs);\n+        checkUTF8Length(s, utf8Length);\n+    }\n+\n+    public static void main(String[] args) throws Throwable {\n+        if (args == null || args.length == 0) {\n+            test();\n+            return;\n+        }\n+\n+        OutputAnalyzer oa = ProcessTools.executeTestJava(\"-Xms9G\",\n+                                                         \"-Xmx9G\",\n+                                                         \"-Xcheck:jni\",\n+                                                         \"-Djava.library.path=\" + Utils.TEST_NATIVE_PATH,\n+                                                         \"TestLargeUTF8Length\");\n+        String warning = \"WARNING: large String with modified UTF-8 length .*\" +\n+                         \"is reporting a reduced length of .* - use GetStringUTFLengthAsLong instead\";\n+        oa.shouldHaveExitValue(0);\n+        oa.stdoutShouldMatch(warning);\n+        oa.reportDiagnosticSummary();\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/TestLargeUTF8Length.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -0,0 +1,54 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+#include <jni.h>\n+\n+#include <limits.h>\n+#include <stdio.h>\n+\n+JNIEXPORT void JNICALL\n+Java_TestLargeUTF8Length_checkUTF8Length(JNIEnv *env, jclass clz,\n+                                         jstring str, jlong expected_length) {\n+\n+  jlong utf8_length;\n+\n+  \/\/ First get truncated length to generate warning\n+  utf8_length = (*env)->GetStringUTFLength(env, str);\n+\n+  if (utf8_length != INT_MAX - 1) {\n+    printf(\"Error: expected length of %d, but got %lld\\n\", INT_MAX - 1,\n+           (long long) utf8_length);\n+    (*env)->FatalError(env, \"Unexpected truncated length\");\n+  }\n+\n+  \/\/ Now get true length\n+  utf8_length = (*env)->GetStringUTFLengthAsLong(env, str);\n+\n+  if (utf8_length != expected_length ) {\n+    printf(\"Error: expected length of %lld, but got %lld\\n\",\n+           (long long) expected_length, (long long) utf8_length);\n+    (*env)->FatalError(env, \"Unexpected true length\");\n+  }\n+\n+\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/jni\/checked\/libTestLargeUTF8Length.c","additions":54,"deletions":0,"binary":false,"changes":54,"status":"added"},{"patch":"@@ -73,0 +73,12 @@\n+\n+            \/\/ Intermittent deflation and inflation may occur due to running the test\n+            \/\/ with stress flags (like DeoptimizeALot) or with added instrumentation\n+            \/\/ which runs in the same VM.\n+            \/\/ An arbitrary fuzzy max difference of 10 (= 0.01% of COUNT) is chosen to\n+            \/\/ allow for these occurrences to be skipped while still catching regressions.\n+            final long fuzzy_max_difference = 10;\n+            if (Math.abs(monitor_count_change) < fuzzy_max_difference) {\n+                final String type = monitor_count_change < 0 ? \"deflation\" : \"inflation\";\n+                throw new SkippedException(\"Intermittent \" + type + \" detected. Invalid test.\");\n+            }\n+\n","filename":"test\/hotspot\/jtreg\/runtime\/locking\/TestRecursiveMonitorChurn.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -41,1 +41,1 @@\n-        output.shouldContain(\"inflate(has_locker):\");\n+        output.shouldContain(\"inflate:\");\n","filename":"test\/hotspot\/jtreg\/runtime\/logging\/MonitorInflationTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,50 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337622\n+ * @summary (reflect) java.lang.Class componentType field not found.\n+ * @library \/test\/lib\n+ * @modules java.base\/java.lang:open\n+ * @run main ComponentTypeFieldTest\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import static jdk.test.lib.Asserts.*;\n+\n+public class ComponentTypeFieldTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        Field f = Class.class.getDeclaredField(\"componentType\");\n+        f.setAccessible(true);\n+        Object val = f.get(Runnable.class);\n+        assertTrue(val == null);\n+        System.out.println(\"val is \" + val);\n+\n+        Object arrayVal = f.get(Integer[].class);\n+        System.out.println(\"val is \" + arrayVal);\n+        String arrayValString = arrayVal.toString();\n+        assertTrue(arrayValString.equals(\"class java.lang.Integer\"));\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/reflect\/ComponentTypeFieldTest.java","additions":50,"deletions":0,"binary":false,"changes":50,"status":"added"},{"patch":"@@ -0,0 +1,59 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8333356\n+ * @summary Verify new error message for corrupting string table contents.\n+ * @requires vm.flagless\n+ * @modules java.base\/java.lang:open\n+ * @library \/test\/lib\n+ * @modules java.base\/jdk.internal.misc\n+ * @run driver StringTableCorruptionTest test\n+ *\/\n+\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Modifier;\n+\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+public class StringTableCorruptionTest {\n+    public static void main(String[] args) throws Exception {\n+        if (args.length > 0) {\n+            ProcessBuilder pb = ProcessTools.createLimitedTestJavaProcessBuilder(\"--add-opens\", \"java.base\/java.lang=ALL-UNNAMED\",\n+                                                             \"-XX:-CreateCoredumpOnCrash\", \"StringTableCorruptionTest\");\n+            OutputAnalyzer output = new OutputAnalyzer(pb.start());\n+            output.shouldContain(\"Node hash code has changed possibly due to corruption of the contents.\");\n+            output.shouldNotHaveExitValue(0);\n+            return;\n+        }\n+\n+        Field f = String.class.getDeclaredField(\"value\");\n+        f.setAccessible(true);\n+        f.set(\"s1\".intern(), f.get(\"s2\"));\n+        for (int i = 0; i < 4_000_000; i++) {\n+            (\"s_\" + i).intern();\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/runtime\/stringtable\/StringTableCorruptionTest.java","additions":59,"deletions":0,"binary":false,"changes":59,"status":"added"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvmti_common.hpp\"\n@@ -38,0 +39,3 @@\n+\/\/ JVMTI_ERROR_WRONG_PHASE guard\n+static jrawMonitorID event_mon = nullptr;\n+static bool is_vm_dead = false;\n@@ -250,1 +254,1 @@\n-\/* Process a CLASS_LOAD or aClassPrepare event. *\/\n+\/* Process a CLASS_LOAD or a ClassPrepare event. *\/\n@@ -257,0 +261,5 @@\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+  if (is_vm_dead) {\n+    return;\n+  }\n+\n@@ -259,1 +268,1 @@\n-  CHECK_JVMTI_ERROR(jni, err, \"ClassLoad event: Error in JVMTI GetClassSignature\");\n+  CHECK_JVMTI_ERROR(jni, err, \"ClassLoad\/ClassPrepare event: Error in JVMTI GetClassSignature\");\n@@ -304,0 +313,8 @@\n+static void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+\n+  LOG0(\"VMDeath\\n\");\n+  is_vm_dead = true;\n+}\n+\n@@ -316,0 +333,7 @@\n+  err = jvmti->CreateRawMonitor(\"Event Monitor\", &event_mon);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG1(\"Agent_OnLoad: CreateRawMonitor failed: %d\\n\", err);\n+    failed = true;\n+    return JNI_ERR;\n+  }\n+\n@@ -321,0 +345,1 @@\n+  callbacks.VMDeath = &VMDeath;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/HiddenClass\/libHiddenClassSigTest.cpp","additions":27,"deletions":2,"binary":false,"changes":29,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+#include \"jvmti_common.hpp\"\n@@ -29,0 +30,5 @@\n+static jvmtiEnv *jvmti = nullptr;\n+\/\/ JVMTI_ERROR_WRONG_PHASE guard\n+static jrawMonitorID event_mon = nullptr;\n+static bool is_vm_dead = false;\n+\n@@ -38,0 +44,5 @@\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+  if (is_vm_dead) {\n+    return;\n+  }\n+\n@@ -44,1 +55,1 @@\n-  printf(\"VMObjectAlloc called for %s\\n\", signature);\n+  LOG(\"VMObjectAlloc called for %s\\n\", signature);\n@@ -51,0 +62,7 @@\n+static void JNICALL\n+VMDeath(jvmtiEnv *jvmti, JNIEnv* jni) {\n+  RawMonitorLocker locker(jvmti, jni, event_mon);\n+\n+  LOG(\"VMDeath\\n\");\n+  is_vm_dead = true;\n+}\n@@ -59,1 +77,0 @@\n-  jvmtiEnv *jvmti;\n@@ -68,0 +85,6 @@\n+  err = jvmti->CreateRawMonitor(\"Event Monitor\", &event_mon);\n+  if (err != JVMTI_ERROR_NONE) {\n+    LOG(\"Agent_OnLoad: CreateRawMonitor failed: %d\\n\", err);\n+    return JNI_ERR;\n+  }\n+\n@@ -70,0 +93,1 @@\n+  callbacks.VMDeath = &VMDeath;\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/VMObjectAlloc\/libVMObjectAlloc.cpp","additions":26,"deletions":2,"binary":false,"changes":28,"status":"modified"},{"patch":"@@ -0,0 +1,77 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+import java.lang.instrument.ClassFileTransformer;\n+import java.lang.instrument.IllegalClassFormatException;\n+import java.lang.instrument.Instrumentation;\n+import java.security.ProtectionDomain;\n+import jdk.test.lib.thread.VThreadPinner;\n+\n+\/*\n+ * @test\n+ * @summary javaagent + tracePinnedThreads will cause jvm crash\/ run into deadlock when the virtual thread is pinned\n+ * @library \/test\/lib\n+ * @requires vm.continuations\n+ * @requires vm.jvmti\n+ * @modules java.base\/java.lang:+open\n+ * @compile TestPinCaseWithCFLH.java\n+ * @build jdk.test.lib.Utils\n+ * @run driver jdk.test.lib.util.JavaAgentBuilder\n+ *             TestPinCaseWithCFLH TestPinCaseWithCFLH.jar\n+ * @run main\/othervm\/timeout=100  -Djdk.virtualThreadScheduler.maxPoolSize=1\n+ *       -Djdk.tracePinnedThreads=full --enable-native-access=ALL-UNNAMED\n+ *       -javaagent:TestPinCaseWithCFLH.jar TestPinCaseWithCFLH\n+ *\/\n+public class TestPinCaseWithCFLH {\n+\n+    public static class TestClassFileTransformer implements ClassFileTransformer {\n+        public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,\n+                                ProtectionDomain protectionDomain, byte[] classfileBuffer)\n+                                throws IllegalClassFormatException {\n+            return classfileBuffer;\n+        }\n+    }\n+\n+    \/\/ Called when agent is loaded at startup\n+    public static void premain(String agentArgs, Instrumentation instrumentation) throws Exception {\n+        instrumentation.addTransformer(new TestClassFileTransformer());\n+    }\n+\n+    private static int result = 0;\n+\n+    public static void main(String[] args) throws Exception{\n+        Thread t1 = Thread.ofVirtual().name(\"vthread-1\").start(() -> {\n+            VThreadPinner.runPinned(() -> {\n+                try {\n+                    \/\/ try yield, will pin,\n+                    \/\/ javaagent + tracePinnedThreads should not lead to crash\n+                    \/\/ (because of the class `PinnedThreadPrinter`)\n+                    Thread.sleep(500);\n+                } catch (Exception e) {\n+                    e.printStackTrace();\n+                }\n+            });\n+        });\n+        t1.join();\n+    }\n+\n+}\n\\ No newline at end of file\n","filename":"test\/hotspot\/jtreg\/serviceability\/jvmti\/vthread\/TestPinCaseWithCFLH\/TestPinCaseWithCFLH.java","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -11,1 +11,1 @@\n-disable-static=true\n+disable-static=false\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/conf\/default.properties","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -66,1 +66,1 @@\n-                    .setCanHaveBreaks(true)\n+                    .setCanHaveBreaks(false)\n","filename":"test\/hotspot\/jtreg\/testlibrary\/jittester\/src\/jdk\/test\/lib\/jittester\/factories\/StaticConstructorDefinitionFactory.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -69,1 +69,1 @@\n-        TestVMProcess testVMProcess = new TestVMProcess(testVMFlags, testClass, null, -1);\n+        TestVMProcess testVMProcess = new TestVMProcess(testVMFlags, testClass, null, -1, false);\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPhaseIRMatching.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package ir_framework.tests;\n+\n+import compiler.lib.ir_framework.*;\n+import compiler.lib.ir_framework.driver.irmatching.IRViolationException;\n+\n+import jdk.internal.vm.annotation.Stable;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @requires vm.debug == true & vm.compiler2.enabled & vm.flagless\n+ * @summary Test that IR framework successfully adds test class to boot classpath in order to run in privileged mode.\n+ * @modules java.base\/jdk.internal.vm.annotation\n+ * @library \/test\/lib \/\n+ * @run driver ir_framework.tests.TestPrivilegedMode\n+ *\/\n+\n+public class TestPrivilegedMode {\n+    static @Stable int iFld; \/\/ Treated as constant after first being set.\n+\n+    public static void main(String[] args) {\n+        try {\n+            TestFramework.run();\n+            Asserts.fail(\"should not reach\");\n+        } catch (IRViolationException e) {\n+            \/\/ Without adding test class to boot classpath, we fail to replace the field load by a constant.\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"Matched forbidden node\"));\n+            Asserts.assertTrue(e.getExceptionInfo().contains(\"LoadI\"));\n+        }\n+\n+        \/\/ When adding the test class to the boot classpath, we can replace the field load by a constant.\n+        new TestFramework().addTestClassesToBootClassPath().start();\n+    }\n+\n+    @Test\n+    @Arguments(setup = \"setup\")\n+    @IR(failOn = IRNode.LOAD_I)\n+    public int test() {\n+        return iFld;\n+    }\n+\n+    @Setup\n+    public void setup() {\n+        iFld = 34;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/testlibrary_tests\/ir_framework\/tests\/TestPrivilegedMode.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -72,4 +72,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -79,1 +75,1 @@\n-        return new caught_exception002().runTest(argv, out);\n+        new caught_exception002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/caught_exception\/caught_exception002\/caught_exception002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -63,4 +63,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -70,1 +66,1 @@\n-        return new classes001().runTest(argv, out);\n+        new classes001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/classes\/classes001\/classes001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,1 +39,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -62,4 +62,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -69,1 +65,1 @@\n-        return new classpath001().runTest(argv, out);\n+        new classpath001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/classpath\/classpath001\/classpath001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -64,4 +64,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -71,1 +67,1 @@\n-        return new clear002().runTest(argv, out);\n+        new clear002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/clear\/clear002\/clear002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -42,1 +42,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -65,4 +65,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -72,1 +68,1 @@\n-        return new clear003().runTest(argv, out);\n+        new clear003().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/clear\/clear003\/clear003.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -43,1 +43,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -66,4 +66,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -73,1 +69,1 @@\n-        return new clear004().runTest(argv, out);\n+        new clear004().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/clear\/clear004\/clear004.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -69,4 +69,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -76,1 +72,1 @@\n-        return new down002().runTest(argv, out);\n+        new down002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/down\/down002\/down002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -73,4 +73,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -81,1 +77,1 @@\n-        return new dump002().runTest(argv, out);\n+        new dump002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/dump\/dump002\/dump002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -78,4 +78,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -85,1 +81,1 @@\n-        return new eval001().runTest(argv, out);\n+        new eval001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/eval\/eval001\/eval001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -62,1 +62,1 @@\n- * @run main\/othervm\/timeout=600\n+ * @run driver\/timeout=600\n@@ -85,4 +85,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -92,1 +88,1 @@\n-        return new exclude001().runTest(argv, out);\n+        new exclude001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/exclude\/exclude001\/exclude001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -67,4 +67,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -74,1 +70,1 @@\n-        return new fields001().runTest(argv, out);\n+        new fields001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/fields\/fields001\/fields001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -63,4 +63,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -69,1 +65,1 @@\n-        return new hc001().runTest(argv, out);\n+        new hc001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/hidden_class\/hc001\/hc001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -66,4 +66,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -73,1 +69,1 @@\n-        return new ignore001().runTest(argv, out);\n+        new ignore001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/ignore\/ignore001\/ignore001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -76,4 +76,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -82,1 +78,1 @@\n-        return new interrupt001().runTest(argv, out);\n+        new interrupt001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/interrupt\/interrupt001\/interrupt001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -77,4 +77,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -83,1 +79,1 @@\n-        return new kill001().runTest(argv, out);\n+        new kill001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill001\/kill001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -69,4 +69,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -75,1 +71,1 @@\n-        return new kill002().runTest(argv, out);\n+        new kill002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/kill\/kill002\/kill002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -66,4 +66,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -73,1 +69,1 @@\n-        return new class001().runTest(argv, out);\n+        new class001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/klass\/class001\/class001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -71,4 +71,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -78,1 +74,1 @@\n-        return new list002().runTest(argv, out);\n+        new list002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/list\/list002\/list002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -50,0 +50,1 @@\n+ *      -jdb.option=\"-sourcepath ${test.src}\/..\/..\/..\/..\"\n@@ -101,4 +102,0 @@\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String[] args, PrintStream out) {\n@@ -107,1 +104,1 @@\n-        return new list003().runTest(args, out);\n+        new list003().runTest(args);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/list\/list003\/list003.java","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -78,4 +78,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -86,1 +82,1 @@\n-        return new locals002().runTest(argv, out);\n+        new locals002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/locals\/locals002\/locals002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -76,4 +76,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -83,1 +79,1 @@\n-        return new methods002().runTest(argv, out);\n+        new methods002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/methods\/methods002\/methods002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -72,4 +72,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -79,1 +75,1 @@\n-        return new monitor001().runTest(argv, out);\n+        new monitor001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/monitor\/monitor001\/monitor001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -68,4 +68,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -75,1 +71,1 @@\n-        return new monitor002().runTest(argv, out);\n+        new monitor002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/monitor\/monitor002\/monitor002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -72,4 +72,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -79,1 +75,1 @@\n-        return new next001().runTest(argv, out);\n+        new next001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/next\/next001\/next001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -74,4 +74,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -81,1 +77,1 @@\n-        return new connect001().runTest(argv, out);\n+        new connect001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/options\/connect\/connect001\/connect001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -74,4 +74,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -81,1 +77,1 @@\n-        return new connect002().runTest(argv, out);\n+        new connect002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/options\/connect\/connect002\/connect002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -74,4 +74,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -81,1 +77,1 @@\n-        return new connect003().runTest(argv, out);\n+        new connect003().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/options\/connect\/connect003\/connect003.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -74,4 +74,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -81,1 +77,1 @@\n-        return new connect004().runTest(argv, out);\n+        new connect004().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/options\/connect\/connect004\/connect004.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -73,6 +73,1 @@\n-    public static void main (String argv[]) {\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n-        debuggeeClass =  DEBUGGEE_CLASS;\n+    public static void main (String argv[]) {    debuggeeClass =  DEBUGGEE_CLASS;\n@@ -81,1 +76,1 @@\n-        return new connect005().runTest(argv, out);\n+        new connect005().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/options\/connect\/connect005\/connect005.java","additions":4,"deletions":9,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2004, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2004, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -78,4 +78,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -85,1 +81,1 @@\n-        return new listconnectors001().runTest(argv, out);\n+        new listconnectors001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/options\/listconnectors\/listconnectors001\/listconnectors001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -73,4 +73,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -80,1 +76,1 @@\n-        return new pop001().runTest(argv, out);\n+        new pop001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/pop\/pop001\/pop001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -37,1 +37,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -66,4 +66,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -73,1 +69,1 @@\n-        return new pop_exception001().runTest(argv, out);\n+        new pop_exception001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/pop_exception\/pop_exception001\/pop_exception001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -78,4 +78,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -85,1 +81,1 @@\n-        return new print002().runTest(argv, out);\n+        new print002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/print\/print002\/print002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -79,4 +79,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -86,1 +82,1 @@\n-        return new read001().runTest(argv, out);\n+        new read001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/read\/read001\/read001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -83,4 +83,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -90,1 +86,1 @@\n-        return new redefine001().runTest(argv, out);\n+        new redefine001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/redefine\/redefine001\/redefine001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -72,4 +72,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -79,1 +75,1 @@\n-        return new reenter001().runTest(argv, out);\n+        new reenter001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/reenter\/reenter001\/reenter001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -134,4 +134,0 @@\n-                System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-        }\n-\n-        public static int run(String argv[], PrintStream out) {\n@@ -140,1 +136,1 @@\n-                return new b4689395().runTest(argv, out);\n+                new b4689395().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/regression\/b4689395\/b4689395.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,1 +41,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -71,4 +71,0 @@\n-        System.exit(run(args, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String[] args, PrintStream out) {\n@@ -77,1 +73,1 @@\n-        return new repeat001().runTest(args, out);\n+        new repeat001().runTest(args);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/repeat\/repeat001\/repeat001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -76,4 +76,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -83,1 +79,1 @@\n-        return new resume002().runTest(argv, out);\n+        new resume002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/resume\/resume002\/resume002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -47,1 +47,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -70,4 +70,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -77,1 +73,1 @@\n-        return new run002().runTest(argv, out);\n+        new run002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/run\/run002\/run002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -79,4 +79,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -86,1 +82,1 @@\n-        return new set001().runTest(argv, out);\n+        new set001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/set\/set001\/set001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -79,4 +79,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -87,1 +83,1 @@\n-        return new set002().runTest(argv, out);\n+        new set002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/set\/set002\/set002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -82,4 +82,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -89,1 +85,1 @@\n-        return new step002().runTest(argv, out);\n+        new step002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/step\/step002\/step002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -71,4 +71,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -78,1 +74,1 @@\n-        return new step_up001().runTest(argv, out);\n+        new step_up001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/step_up\/step_up001\/step_up001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -40,1 +40,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -70,4 +70,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -77,1 +73,1 @@\n-        return new stop_at002().runTest(argv, out);\n+        new stop_at002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/stop_at\/stop_at002\/stop_at002.java","additions":2,"deletions":6,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,1 +52,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -82,4 +82,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -89,1 +85,1 @@\n-        return new stop_at003().runTest(argv, out);\n+        new stop_at003().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/stop_at\/stop_at003\/stop_at003.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -83,4 +83,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -90,1 +86,1 @@\n-        return new stop_in002().runTest(argv, out);\n+        new stop_in002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/stop_in\/stop_in002\/stop_in002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -49,1 +49,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -72,4 +72,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -79,1 +75,1 @@\n-        return new suspend001().runTest(argv, out);\n+        new suspend001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/suspend\/suspend001\/suspend001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -69,4 +69,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -76,1 +72,1 @@\n-        return new thread002().runTest(argv, out);\n+        new thread002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/thread\/thread002\/thread002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -72,4 +72,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -79,1 +75,1 @@\n-        return new threadgroup002().runTest(argv, out);\n+        new threadgroup002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threadgroup\/threadgroup002\/threadgroup002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -67,4 +67,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -74,1 +70,1 @@\n-        return new threadgroups002().runTest(argv, out);\n+        new threadgroups002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threadgroups\/threadgroups002\/threadgroups002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,1 +43,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -68,4 +68,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -75,1 +71,1 @@\n-        return new threads002().runTest(argv, out);\n+        new threads002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threads\/threads002\/threads002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -68,4 +68,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -75,1 +71,1 @@\n-        return new threads003().runTest(argv, out);\n+        new threads003().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/threads\/threads003\/threads003.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -74,4 +74,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -81,1 +77,1 @@\n-        return new trace001().runTest(argv, out);\n+        new trace001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/trace\/trace001\/trace001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -55,1 +55,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -78,4 +78,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -85,1 +81,1 @@\n-        return new uncaught_exception002(true).runTest(argv, out);\n+        new uncaught_exception002(true).runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/uncaught_exception\/uncaught_exception002\/uncaught_exception002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -59,1 +59,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -82,4 +82,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -89,1 +85,1 @@\n-        return new unmonitor001().runTest(argv, out);\n+        new unmonitor001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/unmonitor\/unmonitor001\/unmonitor001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -57,1 +57,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -80,4 +80,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -87,1 +83,1 @@\n-        return new untrace001().runTest(argv, out);\n+        new untrace001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/untrace\/untrace001\/untrace001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -76,4 +76,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -83,1 +79,1 @@\n-        return new unwatch001().runTest(argv, out);\n+        new unwatch001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/unwatch\/unwatch001\/unwatch001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -54,1 +54,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -77,4 +77,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -84,1 +80,1 @@\n-        return new unwatch002().runTest(argv, out);\n+        new unwatch002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/unwatch\/unwatch002\/unwatch002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -69,4 +69,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -76,1 +72,1 @@\n-        return new up002().runTest(argv, out);\n+        new up002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/up\/up002\/up002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n@@ -46,1 +46,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -70,4 +70,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -77,1 +73,1 @@\n-        return new use001().runTest(argv, out);\n+        new use001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/use\/use001\/use001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -74,4 +74,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -82,1 +78,1 @@\n-        return new watch001().runTest(argv, out);\n+        new watch001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/watch\/watch001\/watch001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,1 +51,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -74,4 +74,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -82,1 +78,1 @@\n-        return new watch002().runTest(argv, out);\n+        new watch002().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/watch\/watch002\/watch002.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -67,4 +67,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -74,1 +70,1 @@\n-        return new where004().runTest(argv, out);\n+        new where004().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/where\/where004\/where004.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -68,4 +68,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -75,1 +71,1 @@\n-        return new where005(true).runTest(argv, out);\n+        new where005(true).runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/where\/where005\/where005.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -45,1 +45,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -68,4 +68,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -75,1 +71,1 @@\n-        return new where006().runTest(argv, out);\n+        new where006().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/where\/where006\/where006.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,1 +40,1 @@\n- * @run main\/othervm\n+ * @run driver\n@@ -63,4 +63,0 @@\n-        System.exit(run(argv, System.out) + JCK_STATUS_BASE);\n-    }\n-\n-    public static int run(String argv[], PrintStream out) {\n@@ -70,1 +66,1 @@\n-        return new wherei001().runTest(argv, out);\n+        new wherei001().runTest(argv);\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jdb\/wherei\/wherei001\/wherei001.java","additions":3,"deletions":7,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -50,8 +50,0 @@\n-\n-\/*\n- * @test id=logging\n- *\n- * @library \/vmTestbase\n- *          \/test\/lib\n- * @run main\/othervm\/native -agentlib:setfmodw001 -XX:TraceJVMTI=ec+,+ioe,+s -Xlog:jvmti=trace:file=vm.%p.log nsk.jvmti.SetFieldModificationWatch.setfmodw001\n- *\/\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/jvmti\/SetFieldModificationWatch\/setfmodw001\/TestDescription.java","additions":0,"deletions":8,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -128,1 +128,2 @@\n-    protected int runTest(String argv[], PrintStream out) {\n+    protected void runTest(String argv[]) {\n+        PrintStream out = System.out;\n@@ -135,1 +136,1 @@\n-                return PASSED;\n+                return;\n@@ -229,1 +230,1 @@\n-                return FAILED;\n+                throw new RuntimeException(\"TEST FAILED\");\n@@ -235,2 +236,1 @@\n-            out.println(\"TEST FAILED\");\n-            return FAILED;\n+            throw new RuntimeException(\"TEST FAILED\", t);\n@@ -239,1 +239,0 @@\n-        return PASSED;\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/JdbTest.java","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -183,0 +183,4 @@\n+                connect.append(\",options=\");\n+                connect.append(\" \\\"-cp\\\"\");\n+                connect.append(\" \\\"\" + System.getProperty(\"test.class.path\") + \"\\\"\");\n+\n@@ -185,2 +189,0 @@\n-                    \/\/connect.append(\",options=\" + debuggeeOpts.trim());\n-                    connect.append(\",options=\");\n","filename":"test\/hotspot\/jtreg\/vmTestbase\/nsk\/share\/jdb\/Launcher.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -473,2 +473,4 @@\n-# This test fails on macOS 14\n-java\/awt\/Choice\/SelectNewItemTest\/SelectNewItemTest.java 8324782 macosx-all\n+# Wayland related\n+\n+java\/awt\/FullScreen\/FullscreenWindowProps\/FullscreenWindowProps.java 8280991 linux-x64\n+java\/awt\/FullScreen\/SetFullScreenTest.java 8332155 linux-x64\n@@ -609,1 +611,0 @@\n-com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java 8039280 generic-all\n@@ -742,1 +743,1 @@\n-jdk\/jfr\/event\/compiler\/TestCodeSweeper.java                     8225209 generic-all\n+jdk\/jfr\/event\/compiler\/TestCodeSweeper.java                     8338127 generic-all\n@@ -744,2 +745,0 @@\n-jdk\/jfr\/startupargs\/TestStartName.java                          8214685 windows-x64\n-jdk\/jfr\/startupargs\/TestStartDuration.java                      8214685 windows-x64\n","filename":"test\/jdk\/ProblemList.txt","additions":5,"deletions":6,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -626,1 +626,0 @@\n-    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java \\\n@@ -655,0 +654,1 @@\n+    com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java \\\n","filename":"test\/jdk\/TEST.groups","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,181 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+import jdk.test.lib.dcmd.PidJcmdExecutor;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import com.sun.jdi.Bootstrap;\n+import com.sun.jdi.ClassType;\n+import com.sun.jdi.VirtualMachine;\n+import com.sun.jdi.VMDisconnectedException;\n+import com.sun.jdi.connect.AttachingConnector;\n+import com.sun.jdi.connect.Connector;\n+import com.sun.jdi.connect.IllegalConnectorArgumentsException;\n+import com.sun.jdi.event.ClassPrepareEvent;\n+import com.sun.jdi.event.Event;\n+import com.sun.jdi.event.EventSet;\n+import com.sun.jdi.request.EventRequest;\n+import com.sun.jdi.request.ClassPrepareRequest;\n+\n+\/**\n+ * @test\n+ * @bug  8332488\n+ * @summary Unit test for testing debug agent support for JVMTI.data_dump jcmd.\n+ *\n+ * @library \/test\/lib\n+ * @modules jdk.jdi\n+ * @run driver DataDumpTest\n+ *\/\n+\n+class DataDumpTestTarg {\n+    public static void main(String args[]) throws Exception {\n+        \/\/ Write something that can be read by the driver\n+        System.out.println(\"Debuggee started\");\n+    }\n+}\n+\n+public class DataDumpTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Test 1: Debuggee start with datadump=y\");\n+        runTest(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,datadump=y\");\n+    }\n+\n+    private static void sleep(long ms) {\n+        try {\n+            Thread.sleep(ms);\n+        } catch (InterruptedException e) {\n+        }\n+    }\n+\n+    private static void runTest(String jdwpArg) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                jdwpArg,\n+                \/\/ Probably not required by this test, but best to include when using datadump\n+                \"-XX:+StartAttachListener\",\n+                \"DataDumpTestTarg\");\n+        Process p = null;\n+        OutputAnalyzer out = null;\n+        try {\n+            p = pb.start();\n+            InputStream is = p.getInputStream();\n+\n+            \/\/ Read the first character of output to make sure we've waited until the\n+            \/\/ debuggee is ready. This will be the debug agent's \"Listening...\" message.\n+            char firstChar = (char)is.read();\n+\n+            out = new OutputAnalyzer(p);\n+\n+            \/\/ Attach a debugger and do the data dump. The data dump output will appear\n+            \/\/ in the debuggee output.\n+            attachAndDump(p.pid());\n+\n+            out.waitFor(); \/\/ Wait for the debuggee to exit\n+\n+            System.out.println(\"Debuggee output:\");\n+            System.out.println(firstChar + out.getOutput());\n+\n+            \/\/ All these strings are part of the debug agent data dump output.\n+            out.shouldHaveExitValue(0);\n+            out.shouldContain(\"Debuggee started\");\n+            out.shouldContain(\"Debug Agent Data Dump\");\n+            out.shouldContain(\"suspendAllCount: 0\");\n+            out.shouldContain(\"ClassMatch: classPattern(DataDumpTestTarg)\");\n+            out.shouldContain(\"Handlers for EI_VM_DEATH\");\n+        } finally {\n+            if (p != null) {\n+                p.destroyForcibly();\n+            }\n+        }\n+    }\n+\n+    private static void attachAndDump(long pid) throws IOException,\n+            IllegalConnectorArgumentsException {\n+        \/\/ Get the ProcessAttachingConnector, which can attach using the pid of the debuggee.\n+        AttachingConnector ac = Bootstrap.virtualMachineManager().attachingConnectors()\n+                .stream()\n+                .filter(c -> c.name().equals(\"com.sun.jdi.ProcessAttach\"))\n+                .findFirst()\n+                .orElseThrow(() -> new RuntimeException(\"Unable to locate ProcessAttachingConnector\"));\n+\n+        \/\/ Set the connector's \"pid\" argument to the pid of the debuggee.\n+        Map<String, Connector.Argument> args = ac.defaultArguments();\n+        Connector.StringArgument arg = (Connector.StringArgument)args.get(\"pid\");\n+        arg.setValue(\"\" + pid);\n+\n+        \/\/ Attach to the debuggee.\n+        System.out.println(\"Debugger is attaching to: \" + pid + \" ...\");\n+        VirtualMachine vm = ac.attach(args);\n+\n+        \/\/ List all threads as a sanity check.\n+        System.out.println(\"Attached! Now listing threads ...\");\n+        vm.allThreads().stream().forEach(System.out::println);\n+\n+        \/\/ Request VM to trigger ClassPrepareRequest when DataDumpTestTarg class is prepared.\n+        ClassPrepareRequest classPrepareRequest = vm.eventRequestManager().createClassPrepareRequest();\n+        classPrepareRequest.addClassFilter(\"DataDumpTestTarg\");\n+        \/\/ Don't use SUSPEND_ALL here. That might prevent the data dump because the\n+        \/\/ Signal Dispatcher and Attach Listener threads will be suspended, and they\n+        \/\/ may be needed by the jcmd support.\n+        classPrepareRequest.setSuspendPolicy(EventRequest.SUSPEND_EVENT_THREAD);\n+        classPrepareRequest.enable();\n+\n+        try {\n+            while (true) { \/\/ Exit when we get VMDisconnectedException\n+                EventSet eventSet = vm.eventQueue().remove();\n+                if (eventSet == null) {\n+                    continue;\n+                }\n+                for (Event event : eventSet) {\n+                    System.out.println(\"Received event: \" + event);\n+                    if (event instanceof ClassPrepareEvent) {\n+                        ClassPrepareEvent evt = (ClassPrepareEvent) event;\n+                        ClassType classType = (ClassType) evt.referenceType();\n+\n+                        \/\/ Run JVMTI.data_dump jcmd.\n+                        OutputAnalyzer out = new PidJcmdExecutor(\"\" + pid).execute(\"JVMTI.data_dump\");\n+                        out.waitFor();\n+\n+                        \/\/ Verify the output of the jcmd. Note the actual dump is in the debuggee\n+                        \/\/ output, not in the jcmd output, so we don't check it here.\n+                        System.out.println(\"JVMTI.data_dump output:\");\n+                        System.out.println(out.getOutput());\n+                        out.shouldContain(\"Command executed successfully\");\n+                        out.shouldHaveExitValue(0);\n+                    }\n+                }\n+                eventSet.resume();\n+            }\n+        } catch (VMDisconnectedException e) {\n+            System.out.println(\"VM is now disconnected.\");\n+        } catch (Exception e) {\n+            e.printStackTrace();\n+            throw new RuntimeException(e);\n+        }\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/DataDumpTest.java","additions":181,"deletions":0,"binary":false,"changes":181,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020 SAP SE. All rights reserved.\n+ * Copyright (c) 2020, 2024 SAP SE. All rights reserved.\n@@ -291,0 +291,1 @@\n+        new EARelockingWithManyLightweightLocksTarget()                                     .run();\n@@ -416,0 +417,1 @@\n+        new EARelockingWithManyLightweightLocks()                                     .run(this);\n@@ -1800,0 +1802,79 @@\n+\/**\n+ * Like {@link EARelockingSimple}. The difference is that there are many\n+ * lightweight locked objects when the relocking is done. With\n+ * <code>-XX:LockingMode=2<\/code> the lock stack of the thread will be full\n+ * because of this.\n+ *\/\n+\n+class EARelockingWithManyLightweightLocks extends EATestCaseBaseDebugger {\n+\n+    public void runTestCase() throws Exception {\n+        BreakpointEvent bpe = resumeTo(TARGET_TESTCASE_BASE_NAME, \"dontinline_brkpt\", \"()V\");\n+        printStack(bpe.thread());\n+        @SuppressWarnings(\"unused\")\n+        ObjectReference o = getLocalRef(bpe.thread().frame(1), XYVAL_NAME, \"l1\");\n+    }\n+}\n+\n+class EARelockingWithManyLightweightLocksTarget extends EATestCaseBaseTarget {\n+\n+    static class Lock {\n+    }\n+\n+    public static Lock L0, L1, L2, L3, L4, L5, L6, L7, L8, L9;\n+\n+    void allocateLocks() {\n+        L0 = new Lock();\n+        L1 = new Lock();\n+        L2 = new Lock();\n+        L3 = new Lock();\n+        L4 = new Lock();\n+        L5 = new Lock();\n+        L6 = new Lock();\n+        L7 = new Lock();\n+        L8 = new Lock();\n+        L9 = new Lock();\n+    }\n+\n+    @Override\n+    public void setUp() {\n+        super.setUp();\n+        allocateLocks();\n+    }\n+\n+    @Override\n+    public void warmupDone() {\n+        super.warmupDone();\n+        allocateLocks();    \/\/ get rid of already inflated ones\n+    }\n+\n+    public void dontinline_testMethod() {\n+        XYVal l1 = new XYVal(4, 2);\n+        synchronized(L0) {\n+            synchronized(L1) {\n+                synchronized(L2) {\n+                    synchronized(L3) {\n+                        synchronized(L4) {\n+                            synchronized(L5) {\n+                                synchronized(L6) {\n+                                    synchronized(L7) {\n+                                        synchronized(L8) {\n+                                            synchronized(L9) {\n+                                                synchronized (l1) {\n+                                                    dontinline_brkpt();\n+                                                }\n+                                            }\n+                                        }\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n+\n","filename":"test\/jdk\/com\/sun\/jdi\/EATests.java","additions":82,"deletions":1,"binary":false,"changes":83,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,2 @@\n-    private static boolean allowNegativeTesting = false;\n+    private static boolean allowNegativeTesting =\n+        \"true\".equalsIgnoreCase(System.getProperty(\"jdk.jdi.allowNegativeTesting\"));\n","filename":"test\/jdk\/com\/sun\/jdi\/JdwpListenTest.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -52,0 +52,5 @@\n+    \/\/ Set to true to allow testing of attach from wrong address (expected to fail).\n+    \/\/ It's off by default as it causes test interference (see JDK-8311990).\n+    private static boolean allowNegativeAttachTesting =\n+        \"true\".equalsIgnoreCase(System.getProperty(\"jdk.jdi.allowNegativeTesting\"));\n+\n@@ -174,0 +179,8 @@\n+            log(\"\\nTest: listen at \" + listenAddress + \", attaching to \" + connectAddress\n+                + \", preferIPv4Stack = \" + preferIPv4Stack\n+                + \", preferIPv6Addresses = \" + preferIPv6Addresses\n+                + \", expectedResult = \" + expectedResult);\n+            if (expectedResult == TestResult.AttachFailed && !allowNegativeAttachTesting) {\n+                log(\"SKIPPED: negative attach testing is disabled\");\n+                return;\n+            }\n","filename":"test\/jdk\/com\/sun\/jdi\/JdwpNetProps.java","additions":14,"deletions":1,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -0,0 +1,126 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Map;\n+\n+import jdk.test.lib.process.ProcessTools;\n+\n+import com.sun.jdi.Bootstrap;\n+import com.sun.jdi.VirtualMachine;\n+import com.sun.jdi.connect.AttachingConnector;\n+import com.sun.jdi.connect.Connector;\n+import com.sun.jdi.connect.IllegalConnectorArgumentsException;\n+\n+\/**\n+ * @test\n+ * @bug 8338708\n+ * @summary Stress test for reattaching to a debuggee\n+ * @library \/test\/lib\n+ * @modules jdk.jdi\n+ * @run driver ProcessAttachTest\n+ *\/\n+\n+class ReattachStressTestTarg {\n+    public static void main(String args[]) throws Exception {\n+        System.out.println(\"Debuggee started\");\n+        while (true) {\n+            try {\n+                Thread.sleep(100);\n+            } catch (InterruptedException e) {\n+            }\n+        }\n+    }\n+}\n+\n+public class ReattachStressTest {\n+    public static void main(String[] args) throws Exception {\n+        System.out.println(\"Test 1: Debuggee start with suspend=n\");\n+        runTest(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=n\");\n+\n+        System.out.println(\"Test 2: Debuggee start with suspend=y\");\n+        runTest(\"-agentlib:jdwp=transport=dt_socket,server=y,suspend=y\");\n+    }\n+\n+    private static void runTest(String jdwpArg) throws Exception {\n+        ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                jdwpArg,\n+                \"ReattachStressTestTarg\");\n+        Process p = null;\n+        try {\n+            p = pb.start();\n+\n+            \/\/ Read the first character of output to make sure we've waited until the\n+            \/\/ debuggee is ready. This will be the debug agent's \"Listening...\" message.\n+            InputStream is = p.getInputStream();\n+            is.read();\n+\n+            \/\/ Attach a debugger\n+            tryDebug(p.pid(), is);\n+        } finally {\n+            p.destroyForcibly();\n+        }\n+    }\n+\n+    private static void tryDebug(long pid, InputStream is) throws IOException,\n+            IllegalConnectorArgumentsException {\n+        \/\/ Get the ProcessAttachingConnector, which can attach using the pid of the debuggee.\n+        AttachingConnector ac = Bootstrap.virtualMachineManager().attachingConnectors()\n+                .stream()\n+                .filter(c -> c.name().equals(\"com.sun.jdi.ProcessAttach\"))\n+                .findFirst()\n+                .orElseThrow(() -> new RuntimeException(\"Unable to locate ProcessAttachingConnector\"));\n+\n+        \/\/ Set the connector's \"pid\" argument to the pid of the debuggee.\n+        Map<String, Connector.Argument> args = ac.defaultArguments();\n+        Connector.StringArgument arg = (Connector.StringArgument)args.get(\"pid\");\n+        arg.setValue(\"\" + pid);\n+\n+        \/\/ Loop that will repeatedly attach and detach from the same debuggee.\n+        for (int i = 0; i < 500; i++) {\n+            System.out.println(i + \": Debugger is attaching to: \" + pid + \" ...\");\n+\n+            \/\/ Attach to the debuggee.\n+            VirtualMachine vm = ac.attach(args);\n+\n+            \/\/ Drain remaining \"Listening...\" output.  Otherwise too much\n+            \/\/ output will buffer up and the debuggee may block until it is cleared.\n+            while (is.available() > 0) {\n+                is.read();\n+            }\n+\n+            \/\/ We've attached. Do some things that will send JDWP commands.\n+            System.out.println(\"Attached!\");\n+            System.out.println(\"JVM name: \" + vm.name());\n+            System.out.println(\"Num threads: \" + vm.allThreads().size());\n+\n+            \/\/ We're all done with this debugger connection.\n+            vm.dispose();\n+\n+            \/\/ Wait for first char of next \"Listening...\" output.\n+            is.read();\n+        }\n+        System.out.println(\"Debugger done.\");\n+    }\n+}\n","filename":"test\/jdk\/com\/sun\/jdi\/ReattachStressTest.java","additions":126,"deletions":0,"binary":false,"changes":126,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,2 +29,3 @@\n- * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations\n- * @requires (vm.compMode == \"Xmixed\")\n+ * @comment Don't allow -Xcomp or -Xint as they impact memory useage and number of iterations.\n+ *          Require compressed oops because not doing so increases memory usage.\n+ * @requires (vm.compMode == \"Xmixed\") & vm.opt.final.UseCompressedOops\n","filename":"test\/jdk\/com\/sun\/jdi\/ThreadMemoryLeakTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 6825240\n+ * @bug 6825240 6829785\n@@ -31,0 +31,12 @@\n+\/*\n+ * This scenario cannot be automated because util\/Password.java verifies the given input stream is\n+ * equal to the initialSystemIn. This prevents the test from providing a custom input stream.\n+ *\n+ *  Steps to run the test:\n+ *  1) Compile the class using the JDK version being tested: '<JdkBin>\/javac Password.java'\n+ *  2) Run the test using the JDK version being tested: '<JdkBin>\/java -cp . Password'\n+ *  3) Type in the first password, it should not be visible in the console\n+ *  4) Type in the second password, it should be visible in the console\n+ *  5) The final output line displays the entered passwords, both should be visible\n+ *\/\n+\n","filename":"test\/jdk\/com\/sun\/security\/auth\/callback\/TextCallbackHandler\/Password.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,102 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Checkbox;\n+import java.awt.Color;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.image.BufferedImage;\n+import java.io.File;\n+import java.io.IOException;\n+\n+import javax.imageio.ImageIO;\n+\n+\/*\n+ * @test\n+ * @key headful\n+ * @bug 8233068\n+ * @summary Tests checkbox checker on scaling\n+ * @requires (os.family == \"linux\")\n+ * @run main CheckboxCheckerScalingTest\n+ *\/\n+\n+public class CheckboxCheckerScalingTest {\n+    private static Frame frame;\n+    private static Checkbox checkbox;\n+    private static BufferedImage imageAfterChecked;\n+    private static volatile boolean checkmarkFound = false;\n+\n+    public static void main(String[] args) throws Exception {\n+        System.setProperty(\"sun.java2d.uiScale\", \"2\");\n+        Robot robot = new Robot();\n+        try {\n+            EventQueue.invokeAndWait(() -> {\n+                frame = new Frame(\"ComboBox checker scaling test\");\n+                checkbox = new Checkbox(\"one\");\n+                checkbox.setState(true);\n+                frame.add(checkbox);\n+                frame.pack();\n+                frame.setVisible(true);\n+            });\n+\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            EventQueue.invokeAndWait(() -> {\n+                Point point = checkbox.getLocationOnScreen();\n+                Rectangle rect = new Rectangle(point.x + 5, point.y + 7, 8, 8);\n+                imageAfterChecked = robot.createScreenCapture(rect);\n+\n+                check: {\n+                    for (int i = 0; i < imageAfterChecked.getHeight(); i++) {\n+                        for (int j = 0; j < imageAfterChecked.getWidth(); j++) {\n+                            if (Color.black.getRGB() == imageAfterChecked.getRGB(i, j)) {\n+                                checkmarkFound = true;\n+                                break check;\n+                            }\n+                        }\n+                    }\n+                }\n+            });\n+\n+            if (!checkmarkFound) {\n+                try {\n+                    ImageIO.write(imageAfterChecked, \"png\",\n+                            new File(\"imageAfterChecked.png\"));\n+                } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                }\n+                throw new RuntimeException(\"Checkmark not scaled\");\n+            }\n+            System.out.println(\"Test Passed\");\n+        } finally {\n+            EventQueue.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/awt\/Checkbox\/CheckboxCheckerScalingTest.java","additions":102,"deletions":0,"binary":false,"changes":102,"status":"added"},{"patch":"@@ -1,134 +0,0 @@\n-\/*\n- * Copyright (c) 2002, 2018, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n-  @test\n-  @bug 4902933 8197810\n-  @summary Test that selecting the current item doesnot send an ItemEvent\n-  @key headful\n-  @run main SelectCurrentItemTest\n-*\/\n-\n-import java.awt.Choice;\n-import java.awt.Robot;\n-import java.awt.Frame;\n-import java.awt.BorderLayout;\n-import java.awt.AWTException;\n-import java.awt.Point;\n-import java.awt.Dimension;\n-import java.awt.event.InputEvent;\n-import java.awt.event.ItemListener;\n-import java.awt.event.WindowListener;\n-import java.awt.event.ItemEvent;\n-import java.awt.event.WindowEvent;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-public class SelectCurrentItemTest implements ItemListener, WindowListener {\n-    \/\/Declare things used in the test, like buttons and labels here\n-    private Frame frame;\n-    private Choice theChoice;\n-    private Robot robot;\n-\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    private volatile boolean passed = true;\n-\n-    private void init()\n-    {\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(500);\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"Unable to create Robot. Test fails.\");\n-        }\n-\n-        frame = new Frame(\"SelectCurrentItemTest\");\n-        frame.setLayout(new BorderLayout());\n-        theChoice = new Choice();\n-        for (int i = 0; i < 10; i++) {\n-            theChoice.add(new String(\"Choice Item \" + i));\n-        }\n-        theChoice.addItemListener(this);\n-        frame.add(theChoice);\n-        frame.addWindowListener(this);\n-\n-        frame.setLocation(1,20);\n-        robot.mouseMove(10, 30);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public static void main(String... args) {\n-        SelectCurrentItemTest test = new SelectCurrentItemTest();\n-        test.init();\n-        try {\n-            test.latch.await(12000, TimeUnit.MILLISECONDS);\n-        } catch (InterruptedException e) {}\n-        test.robot.waitForIdle();\n-\n-        try {\n-            if (!test.passed) {\n-                throw new RuntimeException(\"TEST FAILED.\");\n-            }\n-        } finally {\n-            test.frame.dispose();\n-        }\n-    }\n-\n-    private void run() {\n-        try {Thread.sleep(1000);} catch (InterruptedException e){}\n-        \/\/ get loc of Choice on screen\n-        Point loc = theChoice.getLocationOnScreen();\n-        \/\/ get bounds of Choice\n-        Dimension size = theChoice.getSize();\n-        robot.mouseMove(loc.x + size.width - 10, loc.y + size.height \/ 2);\n-\n-        robot.setAutoDelay(250);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-\n-        robot.delay(1000);\n-\n-        robot.mouseMove(loc.x + size.width \/ 2, loc.y + size.height);\n-        robot.mousePress(InputEvent.BUTTON1_MASK);\n-        robot.mouseRelease(InputEvent.BUTTON1_MASK);\n-        robot.waitForIdle();\n-        latch.countDown();\n-    }\n-\n-    @Override public void itemStateChanged(ItemEvent e) {\n-        System.out.println(\"ItemEvent received.  Test fails\");\n-        passed = false;\n-    }\n-\n-    @Override public void windowOpened(WindowEvent e) {\n-        System.out.println(\"windowActivated()\");\n-        (new Thread(this::run)).start();\n-    }\n-\n-    @Override public void windowActivated(WindowEvent e) {}\n-    @Override public void windowDeactivated(WindowEvent e) {}\n-    @Override public void windowClosed(WindowEvent e) {}\n-    @Override public void windowClosing(WindowEvent e) {}\n-    @Override public void windowIconified(WindowEvent e) {}\n-    @Override public void windowDeiconified(WindowEvent e) {}\n-}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectCurrentItemTest\/SelectCurrentItemTest.java","additions":0,"deletions":134,"binary":false,"changes":134,"status":"deleted"},{"patch":"@@ -0,0 +1,207 @@\n+\/*\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.BorderLayout;\n+import java.awt.Choice;\n+import java.awt.EventQueue;\n+import java.awt.Frame;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.ItemEvent;\n+import java.awt.event.ItemListener;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import java.awt.event.WindowAdapter;\n+import java.awt.event.WindowEvent;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+\/*\n+ * @test\n+ * @bug 4902933 8197810\n+ * @summary Test that selecting the current item does not send an ItemEvent\n+ * @key headful\n+ * @run main SelectCurrentItemTest\n+*\/\n+public class SelectCurrentItemTest\n+        extends WindowAdapter\n+        implements ItemListener {\n+    private static Frame frame;\n+    private static Choice choice;\n+\n+    private final Robot robot;\n+\n+    private final CountDownLatch windowOpened = new CountDownLatch(1);\n+    private final CountDownLatch mouseClicked = new CountDownLatch(1);\n+\n+    protected final CountDownLatch itemStateChanged = new CountDownLatch(1);\n+\n+    protected SelectCurrentItemTest() throws AWTException {\n+        robot = new Robot();\n+        robot.setAutoDelay(250);\n+    }\n+\n+    private void createUI() {\n+        frame = new Frame(getClass().getName());\n+        frame.setLayout(new BorderLayout());\n+\n+        choice = new Choice();\n+        for (int i = 0; i < 10; i++) {\n+            choice.add(\"Choice Item \" + i);\n+        }\n+        choice.addItemListener(this);\n+        choice.addMouseListener(new MouseAdapter() {\n+            @Override\n+            public void mouseClicked(MouseEvent e) {\n+                System.out.println(\"mouseClicked()\");\n+                mouseClicked.countDown();\n+            }\n+        });\n+\n+        frame.add(choice, BorderLayout.CENTER);\n+\n+        frame.addWindowListener(this);\n+\n+        frame.setLocationRelativeTo(null);\n+        frame.setResizable(false);\n+        frame.pack();\n+        frame.setVisible(true);\n+    }\n+\n+    protected final void runTest()\n+            throws InterruptedException, InvocationTargetException {\n+        try {\n+           doTest();\n+        } finally {\n+            EventQueue.invokeAndWait(this::dispose);\n+        }\n+    }\n+\n+    private void doTest()\n+            throws InterruptedException, InvocationTargetException {\n+        EventQueue.invokeAndWait(this::createUI);\n+\n+        if (!windowOpened.await(2, TimeUnit.SECONDS)) {\n+            throw new RuntimeException(\"Frame is not open in time\");\n+        }\n+        robot.waitForIdle();\n+\n+        final int initialIndex = getSelectedIndex();\n+\n+        final Rectangle choiceRect = getChoiceRect();\n+\n+        \/\/ Open the choice popup\n+        robot.mouseMove(choiceRect.x + choiceRect.width - 10,\n+                        choiceRect.y + choiceRect.height \/ 2);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        if (!mouseClicked.await(500, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"Mouse is not clicked in time\");\n+        }\n+        robot.waitForIdle();\n+\n+        \/\/ Click an item in the choice popup\n+        final Point pt = getClickLocation(choiceRect);\n+        robot.mouseMove(pt.x, pt.y);\n+        robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+        robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+        robot.waitForIdle();\n+\n+        checkItemStateChanged();\n+\n+        final int currentIndex = getSelectedIndex();\n+        System.out.println(\"initialIndex = \" + initialIndex);\n+        System.out.println(\"currentIndex = \" + currentIndex);\n+        checkSelectedIndex(initialIndex, currentIndex);\n+    }\n+\n+    protected void checkItemStateChanged() throws InterruptedException {\n+        if (itemStateChanged.await(500, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"ItemEvent is received but unexpected\");\n+        }\n+    }\n+\n+    protected void checkSelectedIndex(final int initialIndex,\n+                                      final int currentIndex) {\n+        if (initialIndex != currentIndex) {\n+            throw new RuntimeException(\"Selected index in Choice should not change\");\n+        }\n+    }\n+\n+    \/**\n+     * {@return the location for clicking choice popup to select an item}\n+     * @param choiceRect the bounds of the Choice component\n+     *\/\n+    protected Point getClickLocation(final Rectangle choiceRect) {\n+        \/\/ Click on the first item in the popup, it's the selected item\n+        return new Point(choiceRect.x + choiceRect.width \/ 2,\n+                         choiceRect.y + choiceRect.height + 3);\n+    }\n+\n+    private int getSelectedIndex()\n+            throws InterruptedException, InvocationTargetException {\n+        AtomicInteger index = new AtomicInteger();\n+        EventQueue.invokeAndWait(() -> index.set(choice.getSelectedIndex()));\n+        return index.get();\n+    }\n+\n+    private Rectangle getChoiceRect()\n+            throws InterruptedException, InvocationTargetException {\n+        AtomicReference<Rectangle> rect = new AtomicReference<>();\n+        EventQueue.invokeAndWait(\n+                () -> rect.set(new Rectangle(choice.getLocationOnScreen(),\n+                                             choice.getSize())));\n+        return rect.get();\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new SelectCurrentItemTest().runTest();\n+    }\n+\n+    private void dispose() {\n+        if (frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n+    @Override\n+    public final void itemStateChanged(ItemEvent e) {\n+        System.out.println(\"itemStateChanged: \" + e);\n+        itemStateChanged.countDown();\n+    }\n+\n+    @Override\n+    public final void windowOpened(WindowEvent e) {\n+        System.out.println(\"windowActivated()\");\n+        windowOpened.countDown();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectItem\/SelectCurrentItemTest.java","additions":207,"deletions":0,"binary":false,"changes":207,"status":"added"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.AWTException;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.util.concurrent.TimeUnit;\n+\n+\/*\n+ * @test\n+ * @bug 8215921\n+ * @summary Test that selecting a different item does send an ItemEvent\n+ * @key headful\n+ * @run main SelectNewItemTest\n+*\/\n+public final class SelectNewItemTest\n+        extends SelectCurrentItemTest {\n+\n+    private SelectNewItemTest() throws AWTException {\n+        super();\n+    }\n+\n+    @Override\n+    protected void checkItemStateChanged() throws InterruptedException {\n+        if (!itemStateChanged.await(500, TimeUnit.MILLISECONDS)) {\n+            throw new RuntimeException(\"ItemEvent is not received\");\n+        }\n+    }\n+\n+    @Override\n+    protected void checkSelectedIndex(final int initialIndex,\n+                                      final int currentIndex) {\n+        if (initialIndex == currentIndex) {\n+            throw new RuntimeException(\"Selected index in Choice should've changed\");\n+        }\n+    }\n+\n+    @Override\n+    protected Point getClickLocation(final Rectangle choiceRect) {\n+        \/\/ Click a different item the popup, not the first one\n+        return new Point(choiceRect.x + choiceRect.width \/ 2,\n+                         choiceRect.y + choiceRect.height * 3);\n+    }\n+\n+    public static void main(String... args) throws Exception {\n+        new SelectNewItemTest().runTest();\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectItem\/SelectNewItemTest.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -1,180 +0,0 @@\n-\/*\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\/*\n-  @test\n-  @bug 8215921\n-  @summary Test that selecting a different item does send an ItemEvent\n-  @key headful\n-  @run main SelectNewItemTest\n-*\/\n-\n-import java.awt.Choice;\n-import java.awt.Robot;\n-import java.awt.Frame;\n-import java.awt.BorderLayout;\n-import java.awt.AWTException;\n-import java.awt.Point;\n-import java.awt.Dimension;\n-import java.awt.event.InputEvent;\n-import java.awt.event.ItemListener;\n-import java.awt.event.WindowListener;\n-import java.awt.event.ItemEvent;\n-import java.awt.event.WindowEvent;\n-import java.util.concurrent.CountDownLatch;\n-import java.util.concurrent.TimeUnit;\n-\n-public class SelectNewItemTest implements ItemListener, WindowListener {\n-    \/\/Declare things used in the test, like buttons and labels here\n-    private Frame frame;\n-    private Choice theChoice;\n-    private Robot robot;\n-\n-    private CountDownLatch latch = new CountDownLatch(1);\n-    private volatile boolean passed = false;\n-\n-    private void init()\n-    {\n-        try {\n-            robot = new Robot();\n-            robot.setAutoDelay(500);\n-        } catch (AWTException e) {\n-            throw new RuntimeException(\"Unable to create Robot. Test fails.\");\n-        }\n-\n-        frame = new Frame(\"SelectNewItemTest\");\n-        frame.setLayout(new BorderLayout());\n-        theChoice = new Choice();\n-        for (int i = 0; i < 10; i++) {\n-            theChoice.add(new String(\"Choice Item \" + i));\n-        }\n-        theChoice.addItemListener(this);\n-        frame.add(theChoice);\n-        frame.addWindowListener(this);\n-\n-        frame.setLocation(1,20);\n-        frame.setSize(200, 50);\n-        robot.mouseMove(10, 30);\n-        frame.pack();\n-        frame.setVisible(true);\n-    }\n-\n-    public static void main(String... args) {\n-        SelectNewItemTest test = new SelectNewItemTest();\n-        test.init();\n-        try {\n-            test.latch.await(12000, TimeUnit.MILLISECONDS);\n-        } catch (InterruptedException e) {}\n-        test.robot.waitForIdle();\n-\n-        try {\n-            if (!test.passed) {\n-                throw new RuntimeException(\"TEST FAILED.\");\n-            }\n-        } finally {\n-            test.frame.dispose();\n-        }\n-    }\n-\n-    private void run() {\n-        try {\n-            Thread.sleep(1000);\n-\n-            Point loc = theChoice.getLocationOnScreen();\n-            int selectedIndex = theChoice.getSelectedIndex();\n-            Dimension size = theChoice.getSize();\n-\n-            robot.mouseMove(loc.x + size.width - 10, loc.y + size.height \/ 2);\n-\n-            robot.setAutoDelay(250);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            robot.delay(1000);\n-\n-            \/\/make sure that the mouse moves to a different item, so that\n-            \/\/itemStateChanged is called.\n-            robot.mouseMove(loc.x + size.width \/ 2, loc.y + 3 * size.height);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle();\n-\n-            if (selectedIndex == theChoice.getSelectedIndex())\n-                throw new RuntimeException(\"Test case failed - expected to select\" +\n-                \" a different item than \" + selectedIndex);\n-\n-            selectedIndex = theChoice.getSelectedIndex();\n-            \/\/now click on the same item and make sure that item event is\n-            \/\/not generated.\n-            robot.delay(1000);\n-            robot.mouseMove(loc.x + size.width - 10, loc.y + size.height \/ 2);\n-\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            \/\/Make sure that the popup menu scrolls back to show the index from\n-            \/\/beginning, so that the second mouse click happens on the previously\n-            \/\/selected item.\n-            \/\/For example, on windows, it automatically scrolls the list to show\n-            \/\/the currently selected item just below the choice, which can\n-            \/\/throw off the test.\n-            if (System.getProperty(\"os.name\").toLowerCase().startsWith(\"win\")) {\n-                robot.mouseWheel(-100);\n-            }\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-\n-            robot.delay(1000);\n-            robot.mouseMove(loc.x + size.width \/ 2, loc.y + 3 * size.height);\n-            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n-            robot.waitForIdle();\n-\n-            if (selectedIndex != theChoice.getSelectedIndex())\n-                throw new RuntimeException(\"Test failed. Expected to select the same item \" +\n-                \"located at: \" + selectedIndex + \" but got an item selected at: \" + theChoice.getSelectedIndex());\n-        } catch(InterruptedException e) {\n-            throw new RuntimeException(e.getCause());\n-        } finally {\n-            latch.countDown();\n-        }\n-    }\n-\n-    @Override public void itemStateChanged(ItemEvent e) {\n-        if (!passed) {\n-            System.out.println(\"ItemEvent received.  Test passes\");\n-            passed = true;\n-        } else {\n-            System.out.println(\"ItemEvent received for second click. Test fails\");\n-            passed = false;\n-        }\n-    }\n-\n-    @Override public void windowOpened(WindowEvent e) {\n-        System.out.println(\"windowActivated()\");\n-        (new Thread(this::run)).start();\n-    }\n-\n-    @Override public void windowActivated(WindowEvent e) {}\n-    @Override public void windowDeactivated(WindowEvent e) {}\n-    @Override public void windowClosed(WindowEvent e) {}\n-    @Override public void windowClosing(WindowEvent e) {}\n-    @Override public void windowIconified(WindowEvent e) {}\n-    @Override public void windowDeiconified(WindowEvent e) {}\n-}\n","filename":"test\/jdk\/java\/awt\/Choice\/SelectNewItemTest\/SelectNewItemTest.java","additions":0,"deletions":180,"binary":false,"changes":180,"status":"deleted"},{"patch":"@@ -53,1 +53,1 @@\n-    private static final int OFFSET = 2;\n+    private static final int OFFSET = 5;\n","filename":"test\/jdk\/java\/awt\/Frame\/MaximizeUndecoratedTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,2 +48,3 @@\n-        test(\"2\", \"2\");\n-        test(\"2.2\", \"2\");\n+\/\/        GTK 2 is removed, but the test can still be useful.\n+\/\/        test(\"2\", \"2\");\n+\/\/        test(\"2.2\", \"2\");\n","filename":"test\/jdk\/java\/awt\/Gtk\/GtkVersionTest\/GtkVersionTest.java","additions":4,"deletions":3,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2005, 2006, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2005, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,2 @@\n+ * @library \/test\/lib\n+ * @build   jdk.test.lib.Platform\n@@ -33,3 +35,8 @@\n-import java.awt.*;\n-import java.awt.event.*;\n-import javax.swing.*;\n+import java.awt.Frame;\n+import java.awt.Robot;\n+import java.awt.event.MouseAdapter;\n+import java.awt.event.MouseEvent;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+import jdk.test.lib.Platform;\n@@ -44,0 +51,3 @@\n+        if (Platform.isOnWayland()) {\n+            return;\n+        }\n","filename":"test\/jdk\/java\/awt\/Mouse\/EnterExitEvents\/ResizingFrameTest.java","additions":14,"deletions":4,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -44,1 +44,1 @@\n- * @summary  Verifies Robot screen capture capabilities with different\n+ * @summary  Verifies Robot screen capture capabilities with available\n@@ -47,1 +47,0 @@\n- * @run main\/othervm -Djdk.gtk.version=2 -Dsun.java2d.uiScale=1 ScreenCaptureGtkTest\n@@ -56,6 +55,0 @@\n-        if (\"2\".equals(System.getProperty(\"jdk.gtk.version\"))\n-                && System.getenv(\"WAYLAND_DISPLAY\") != null) {\n-            \/\/ screen capture is not supported with gtk2 on Wayland\n-            return;\n-        }\n-\n","filename":"test\/jdk\/java\/awt\/Robot\/HiDPIScreenCapture\/ScreenCaptureGtkTest.java","additions":2,"deletions":9,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -122,0 +122,24 @@\n+    static final MemoryLayout A_VALUE = MemoryLayout.structLayout(\n+            ValueLayout.ADDRESS.withName(\"b\")\n+                    .withTargetLayout(ValueLayout.JAVA_INT)\n+    );\n+\n+    static final VarHandle a_value = A_VALUE.varHandle(\n+            PathElement.groupElement(\"b\"), PathElement.dereferenceElement());\n+\n+    @Test\n+    public void testDerefValue() {\n+        try (Arena arena = Arena.ofConfined()) {\n+            \/\/ init structs\n+            MemorySegment a = arena.allocate(A);\n+            MemorySegment b = arena.allocate(ValueLayout.JAVA_INT);\n+            \/\/ init struct fields\n+            a.set(ValueLayout.ADDRESS, 0, b);\n+            b.set(ValueLayout.JAVA_INT, 0, 42);\n+            \/\/ dereference\n+            int val = (int) a_value.get(a, 0L);\n+            assertEquals(val, 42);\n+        }\n+    }\n+\n+\n","filename":"test\/jdk\/java\/foreign\/TestDereferencePath.java","additions":24,"deletions":0,"binary":false,"changes":24,"status":"modified"},{"patch":"@@ -0,0 +1,136 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @summary Test MemorySegment::fill\n+ * @run junit TestFill\n+ *\/\n+\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.ValueLayout;\n+import java.util.Arrays;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class TestFill {\n+\n+    \/\/ Make sure negative values are treated as expected\n+    private static final byte VALUE = -71;\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testFill(int len) {\n+        int offset = 16;\n+        int expandedLen = offset + MAX_SIZE + offset;\n+\n+        \/\/ Make sure fill only affects the intended region XXXXXX\n+        \/\/\n+        \/\/ ................XXXXXX................\n+        \/\/ |    offset     | len |    offset     |\n+\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(expandedLen);\n+            var slice = segment.asSlice(offset, len);\n+            slice.fill(VALUE);\n+\n+            var expected = new byte[expandedLen];\n+            Arrays.fill(expected, offset, offset + len, VALUE);\n+\n+            \/\/ This checks the actual fill region as well as potential under and overflows\n+            assertArrayEquals(expected, segment.toArray(ValueLayout.JAVA_BYTE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"values\")\n+    void testValues(int value) {\n+        int size = 0b1111;\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(size);\n+            segment.fill((byte) value);\n+            assertTrue(segment.elements(ValueLayout.JAVA_BYTE)\n+                    .map(s -> s.get(ValueLayout.JAVA_BYTE, 0))\n+                    .allMatch(v -> v == value), \"Failed to fill with value \" + value);\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testReadOnly(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10).asReadOnly();\n+            assertThrows(IllegalArgumentException.class, () -> segment.fill(VALUE));\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testConfinement(int len) {\n+        try (var arena = Arena.ofConfined()) {\n+            var segment = arena.allocate(10);\n+            AtomicReference<RuntimeException> ex = new AtomicReference<>();\n+            CompletableFuture<Void> future = CompletableFuture.runAsync(() -> {\n+                try {\n+                    segment.fill(VALUE);\n+                } catch (RuntimeException e) {\n+                    ex.set(e);\n+                }\n+            });\n+            future.join();\n+            assertInstanceOf(WrongThreadException.class, ex.get());\n+        }\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"sizes\")\n+    void testScope(int len) {\n+        var arena = Arena.ofConfined();\n+        var segment = arena.allocate(len);\n+        arena.close();\n+        assertThrows(IllegalStateException.class, () -> segment.fill(VALUE));\n+    }\n+\n+    private static final int MAX_SIZE = 1 << 10;\n+\n+    private static Stream<Arguments> sizes() {\n+        return IntStream.of(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 23, 32, 63, 128, 256, 511, MAX_SIZE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+    private static Stream<Arguments> values() {\n+        return IntStream.rangeClosed(Byte.MIN_VALUE, Byte.MAX_VALUE)\n+                .boxed()\n+                .map(Arguments::of);\n+    }\n+\n+}\n","filename":"test\/jdk\/java\/foreign\/TestFill.java","additions":136,"deletions":0,"binary":false,"changes":136,"status":"added"},{"patch":"@@ -335,0 +335,8 @@\n+    @Test(dataProvider = \"testLayouts\", expectedExceptions = ArithmeticException.class)\n+    public void testOffsetHandleOverflow(MemoryLayout layout, PathElement[] pathElements, long[] indexes,\n+                                         long expectedByteOffset) throws Throwable {\n+        MethodHandle byteOffsetHandle = layout.byteOffsetHandle(pathElements);\n+        byteOffsetHandle = byteOffsetHandle.asSpreader(long[].class, indexes.length);\n+        byteOffsetHandle.invoke(Long.MAX_VALUE, indexes);\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/TestLayoutPaths.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -91,1 +91,5 @@\n-            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class)\n+            RestrictedMethod.of(ModuleLayer.Controller.class, \"enableNativeAccess\", ModuleLayer.Controller.class, Module.class),\n+            RestrictedMethod.of(System.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(System.class, \"loadLibrary\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"load\", void.class, String.class),\n+            RestrictedMethod.of(Runtime.class, \"loadLibrary\", void.class, String.class)\n","filename":"test\/jdk\/java\/foreign\/TestRestricted.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -31,0 +31,4 @@\n+ *        panama_jni_load_module\/*\n+ *        panama_jni_def_module\/*\n+ *        panama_jni_use_module\/*\n+ *\n@@ -65,1 +69,0 @@\n-                { \"panama_enable_native_access_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=ALL-UNNAMED\"} },\n@@ -70,1 +73,1 @@\n-                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=java.base,ALL-UNNAMED\"} },\n+                { \"panama_comma_separated_enable_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--enable-native-access=panama_jni_load_module,panama_jni_def_module,ALL-UNNAMED\"} },\n@@ -75,1 +78,6 @@\n-                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarning(\"ALL-UNNAMED\"), new String[]{} },\n+                { \"panama_enable_native_access_warn_jni\", PANAMA_JNI, successWithWarnings(\"panama_jni_load_module\", \"panama_jni_def_module\", \"ALL-UNNAMED\"), new String[]{} },\n+\n+                { \"panama_enable_native_access_allow\", PANAMA_MAIN, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_reflection\", PANAMA_REFLECTION, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_invoke\", PANAMA_INVOKE, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n+                { \"panama_enable_native_access_allow_jni\", PANAMA_JNI, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -79,0 +87,1 @@\n+                { \"panama_allow_unnamed_module_native_access\", UNNAMED, successNoWarning(), new String[]{\"--illegal-native-access=allow\"} },\n@@ -134,1 +143,1 @@\n-        run(\"panama_enable_native_access_warn_unknown_module\", PANAMA_MAIN,\n+        run(\"panama_deny_bad_unknown_module\", PANAMA_MAIN,\n@@ -136,2 +145,2 @@\n-                \"--enable-native-access=BAD\");\n-        run(\"panama_no_all_module_path_blanket_native_access\", PANAMA_MAIN,\n+                \"--illegal-native-access=deny\", \"--enable-native-access=BAD\");\n+        run(\"panama_deny_bad_all_module_path_module\", PANAMA_MAIN,\n@@ -139,1 +148,27 @@\n-                \"--enable-native-access=ALL-MODULE-PATH\" );\n+                \"--illegal-native-access=deny\", \"--enable-native-access=ALL-MODULE-PATH\" );\n+        run(\"panama_deny_no_module_main\", PANAMA_MAIN,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_invoke\", PANAMA_INVOKE,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_reflection\", PANAMA_REFLECTION,\n+                failWithError(\"module panama_module\"),\n+                \"--illegal-native-access=deny\");\n+        run(\"panama_deny_no_module_jni\", PANAMA_JNI,\n+                failWithError(\"module panama_jni_load_module\"),\n+                \"--illegal-native-access=deny\");\n+    }\n+\n+    public void testDetailedWarningMessage() throws Exception {\n+        run(\"panama_enable_native_access_warn_jni\", PANAMA_JNI,\n+                success()\n+                        \/\/ call to System::loadLibrary from panama_jni_load_module\n+                        .expect(\"WARNING: A restricted method in java.lang.System has been called\")\n+                        .expect(\"WARNING: java.lang.System::loadLibrary has been called by org.openjdk.jni.PanamaMainJNI in module panama_jni_load_module\")\n+                        \/\/ JNI native method binding in panama_jni_def_module\n+                        .expect(\"WARNING: A native method in org.openjdk.jni.def.PanamaJNIDef has been bound\")\n+                        .expect(\"WARNING: org.openjdk.jni.def.PanamaJNIDef::nativeLinker0 is declared in module panama_jni_def_module\")\n+                        \/\/ upcall to Linker::downcallHandle from JNI code\n+                        .expect(\"WARNING: A restricted method in java.lang.foreign.Linker has been called\")\n+                        .expect(\"WARNING: java.lang.foreign.Linker::downcallHandle has been called by code in an unnamed module\"));\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccess.java","additions":42,"deletions":7,"binary":false,"changes":49,"status":"modified"},{"patch":"@@ -41,2 +41,2 @@\n-    static final String PANAMA_JNI_CLS = \"org.openjdk.foreigntest.PanamaMainJNI\";\n-    static final String PANAMA_JNI = \"panama_module\/\" + PANAMA_JNI_CLS;\n+    static final String PANAMA_JNI_CLS = \"org.openjdk.jni.PanamaMainJNI\";\n+    static final String PANAMA_JNI = \"panama_jni_load_module\/\" + PANAMA_JNI_CLS;\n@@ -102,0 +102,8 @@\n+    static Result successWithWarnings(String... moduleNames) {\n+        Result result = success();\n+        for (String moduleName : moduleNames) {\n+            result = result.expect(\"WARNING\").expect(\"--enable-native-access=\" + moduleName);\n+        }\n+        return result;\n+    }\n+\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessBase.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-        String errMsg = \"Illegal native access from: module panama_module\";\n+        String errMsg = \"Illegal native access from module panama_module\";\n@@ -76,0 +76,1 @@\n+        list.add(\"--illegal-native-access=deny\");\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/TestEnableNativeAccessDynamic.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -24,5 +24,2 @@\n-package pkg;\n-\n-public class CtorTypeParam {\n-    public <T extends Runnable> CtorTypeParam() {\n-    }\n+module panama_jni_def_module {\n+    exports org.openjdk.jni.def;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/module-info.java","additions":2,"deletions":5,"binary":false,"changes":7,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/pkg\/CtorTypeParam.java","status":"copied"},{"patch":"@@ -0,0 +1,32 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.def;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+public class PanamaJNIDef {\n+\n+    public static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/PanamaJNIDef.java","additions":32,"deletions":0,"binary":false,"changes":32,"status":"added"},{"patch":"@@ -50,1 +50,1 @@\n-    Java_org_openjdk_foreigntest_PanamaMainJNI_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n+    Java_org_openjdk_jni_def_PanamaJNIDef_nativeLinker0(JNIEnv *env, jclass cls, jobject linker, jobject desc, jobjectArray opts) {\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_def_module\/org\/openjdk\/jni\/def\/libLinkerInvokerModule.cpp","additions":1,"deletions":1,"binary":false,"changes":2,"previous_filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/libLinkerInvokerModule.cpp","status":"renamed"},{"patch":"@@ -24,5 +24,3 @@\n-package pkg;\n-\n-public class CtorTypeParam {\n-    public <T extends Runnable> CtorTypeParam() {\n-    }\n+module panama_jni_load_module {\n+    exports org.openjdk.jni;\n+    requires panama_jni_use_module;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/module-info.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/pkg\/CtorTypeParam.java","status":"copied"},{"patch":"@@ -0,0 +1,34 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni;\n+\n+import org.openjdk.jni.use.PanamaJNIUse;\n+\n+public class PanamaMainJNI {\n+\n+    public static void main(String[] args) {\n+        System.loadLibrary(\"LinkerInvokerModule\");\n+        PanamaJNIUse.run();\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_load_module\/org\/openjdk\/jni\/PanamaMainJNI.java","additions":34,"deletions":0,"binary":false,"changes":34,"status":"added"},{"patch":"@@ -24,5 +24,3 @@\n-package pkg;\n-\n-public class CtorTypeParam {\n-    public <T extends Runnable> CtorTypeParam() {\n-    }\n+module panama_jni_use_module {\n+    exports org.openjdk.jni.use;\n+    requires panama_jni_def_module;\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/module-info.java","additions":3,"deletions":5,"binary":false,"changes":8,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/pkg\/CtorTypeParam.java","status":"copied"},{"patch":"@@ -0,0 +1,41 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package org.openjdk.jni.use;\n+\n+import java.lang.foreign.FunctionDescriptor;\n+import java.lang.foreign.Linker;\n+\n+import org.openjdk.jni.def.PanamaJNIDef;\n+\n+public class PanamaJNIUse {\n+    public static void run() {\n+        testDirectAccessCLinker();\n+    }\n+\n+    public static void testDirectAccessCLinker() {\n+        System.out.println(\"Trying to get downcall handle\");\n+        PanamaJNIDef.nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n+        System.out.println(\"Got downcall handle\");\n+    }\n+}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_jni_use_module\/org\/openjdk\/jni\/use\/PanamaJNIUse.java","additions":41,"deletions":0,"binary":false,"changes":41,"status":"added"},{"patch":"@@ -1,23 +0,0 @@\n-package org.openjdk.foreigntest;\n-\n-import java.lang.foreign.FunctionDescriptor;\n-import java.lang.foreign.Linker;\n-\n-public class PanamaMainJNI {\n-\n-    static {\n-        System.loadLibrary(\"LinkerInvokerModule\");\n-    }\n-\n-    public static void main(String[] args) {\n-        testDirectAccessCLinker();\n-    }\n-\n-    public static void testDirectAccessCLinker() {\n-        System.out.println(\"Trying to get downcall handle\");\n-        nativeLinker0(Linker.nativeLinker(), FunctionDescriptor.ofVoid(), new Linker.Option[0]);\n-        System.out.println(\"Got downcall handle\");\n-    }\n-\n-    static native void nativeLinker0(Linker linker, FunctionDescriptor desc, Linker.Option[] options);\n-}\n","filename":"test\/jdk\/java\/foreign\/enablenativeaccess\/panama_module\/org\/openjdk\/foreigntest\/PanamaMainJNI.java","additions":0,"deletions":23,"binary":false,"changes":23,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @run testng\/othervm --enable-native-access=invoker_module\n+ * @run testng\/othervm --illegal-native-access=deny --enable-native-access=invoker_module\n","filename":"test\/jdk\/java\/foreign\/handles\/Driver.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -93,0 +93,1 @@\n+        addDefaultMapping(Runtime.class, Runtime.getRuntime());\n","filename":"test\/jdk\/java\/foreign\/handles\/invoker_module\/handle\/invoker\/MethodHandleInvoker.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -74,0 +74,12 @@\n+                    { MethodHandles.lookup().findStatic(System.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::load\" },\n+                    { MethodHandles.lookup().findStatic(System.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"System::loadLibrary\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"load\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::load\" },\n+                    { MethodHandles.lookup().findVirtual(Runtime.class, \"loadLibrary\",\n+                            MethodType.methodType(void.class, String.class)),\n+                            \"Runtime::loadLibrary\" }\n","filename":"test\/jdk\/java\/foreign\/handles\/lookup_module\/handle\/lookup\/MethodHandleLookup.java","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.lang.StringBuilder;\n+\n+import java.lang.invoke.*;\n+import java.lang.management.ManagementFactory;\n+\n+\/**\n+ * @test\n+ * @summary Test whether the hidden class unloading of StringConcatFactory works\n+ *\n+ * @requires vm.flagless\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all HiddenClassUnloading\n+ * @run main\/othervm -Xmx8M -Xms8M -Xverify:all -XX:-CompactStrings HiddenClassUnloading\n+ *\/\n+public class HiddenClassUnloading {\n+    public static void main(String[] args) throws Throwable {\n+        var lookup = MethodHandles.lookup();\n+        var types  = new Class<?>[] {\n+                int.class, long.class, double.class, float.class, char.class, boolean.class, String.class,\n+        };\n+\n+        long initUnloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+\n+        for (int i = 0; i < 12000; i++) {\n+            int radix = types.length;\n+            String str = Integer.toString(i, radix);\n+            int length = str.length();\n+            var ptypes = new Class[length];\n+            for (int j = 0; j < length; j++) {\n+                int index = Integer.parseInt(str.substring(j, j + 1), radix);\n+                ptypes[j] = types[index];\n+            }\n+            StringConcatFactory.makeConcatWithConstants(\n+                    lookup,\n+                    \"concat\",\n+                    MethodType.methodType(String.class, ptypes),\n+                    \"\\1\".repeat(length), \/\/ recipe\n+                    new Object[0]\n+            );\n+        }\n+\n+        long unloadedClassCount = ManagementFactory.getClassLoadingMXBean().getUnloadedClassCount();\n+        if (initUnloadedClassCount == unloadedClassCount) {\n+            throw new RuntimeException(\"unloadedClassCount is zero\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/String\/concat\/HiddenClassUnloading.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -72,1 +72,1 @@\n-       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4, false);\n+       int ret = ConstantUtils.skipOverFieldSignature(\"(V)V\", 1, 4);\n","filename":"test\/jdk\/java\/lang\/constant\/boottest\/java.base\/jdk\/internal\/constant\/ConstantUtilsTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -43,0 +43,1 @@\n+import java.nio.file.FileStore;\n@@ -50,0 +51,1 @@\n+import org.testng.SkipException;\n@@ -210,2 +212,7 @@\n-        if (!Files.getFileStore(Paths.get(\".\"))\n-                  .supportsFileAttributeView(PosixFileAttributeView.class)) {\n+        FileStore fs;\n+        try {\n+            fs = Files.getFileStore(Paths.get(\".\"));\n+        } catch (IOException e) {\n+            throw new SkipException(\"WARNING: IOException occurred: \" + e + \", Skipping testDumpDirNotWritable test.\");\n+        }\n+        if (!fs.supportsFileAttributeView(PosixFileAttributeView.class)) {\n@@ -213,6 +220,1 @@\n-            \/\/ We would like to skip the test with a cause with\n-            \/\/     throw new SkipException(\"Posix not supported\");\n-            \/\/ but jtreg will report failure so we just pass the test\n-            \/\/ which we can look at if jtreg changed its behavior\n-            System.out.println(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n-            return;\n+            throw new SkipException(\"WARNING: POSIX is not supported. Skipping testDumpDirNotWritable test.\");\n@@ -230,2 +232,1 @@\n-                System.out.println(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n-                return;\n+                throw new SkipException(\"WARNING: The dump directory is writeable. Skipping testDumpDirNotWritable test.\");\n","filename":"test\/jdk\/java\/lang\/invoke\/lambda\/LogGeneratedClassesTest.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -0,0 +1,84 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of ClassLoadingMXBean.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug:file=vm.log TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info:file=vm.log TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load=trace TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=debug TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=info TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=trace TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=debug TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=info TestVerboseClassLoading true\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=warning TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=error TestVerboseClassLoading false\n+ * @run main\/othervm -Xlog:class+load*=info,class+load+cause=off TestVerboseClassLoading false\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseClassLoading false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.ClassLoadingMXBean;\n+\n+public class TestVerboseClassLoading {\n+\n+    public static void main(String[] args) throws Exception {\n+        ClassLoadingMXBean mxBean = ManagementFactory.getClassLoadingMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/ClassLoadingMXBean\/TestVerboseClassLoading.java","additions":84,"deletions":0,"binary":false,"changes":84,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug     8338139\n+ * @summary Basic unit test of TestVerboseMemory.set\/isVerbose() when\n+ *          related unified logging is enabled.\n+ *\n+ * @run main\/othervm -Xlog:gc=trace:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=debug:file=vm.log TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=info:file=vm.log TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=off TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=error TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc=warning TestVerboseMemory false\n+ *\n+ * @run main\/othervm -Xlog:gc=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=trace TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=debug TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc*=info TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=debug TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc*=trace TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:gc=info,gc+init=off TestVerboseMemory true\n+ * @run main\/othervm -Xlog:gc=off,gc+init=info TestVerboseMemory false\n+ * @run main\/othervm -Xlog:gc,gc+init TestVerboseMemory true\n+ *\n+ * @run main\/othervm -Xlog:all=trace:file=vm.log TestVerboseMemory false\n+ *\/\n+\n+import java.lang.management.ManagementFactory;\n+import java.lang.management.MemoryMXBean;\n+\n+public class TestVerboseMemory {\n+\n+    public static void main(String[] args) throws Exception {\n+        MemoryMXBean mxBean = ManagementFactory.getMemoryMXBean();\n+        boolean expected = Boolean.parseBoolean(args[0]);\n+        boolean initial = mxBean.isVerbose();\n+        if (expected != initial) {\n+            throw new Error(\"Initial verbosity setting was unexpectedly \" + initial);\n+        }\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+        mxBean.setVerbose(true);\n+        if (!mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still disabled\");\n+        }\n+        \/\/ Turn off again as a double-check and also to avoid excessive logging\n+        mxBean.setVerbose(false);\n+        if (mxBean.isVerbose()) {\n+            throw new Error(\"Verbosity was still enabled\");\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/lang\/management\/MemoryMXBean\/TestVerboseMemory.java","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,148 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.InputStream;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.Arrays;\n+import java.util.jar.Attributes;\n+import java.util.jar.Manifest;\n+\n+import jdk.test.lib.util.JarUtils;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import static java.nio.charset.StandardCharsets.US_ASCII;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertNull;\n+\n+\/*\n+ * @test\n+ * @bug 8338445\n+ * @summary verify that the jdk.internal.loader.URLClassPath closes the JarFile\n+ *          instances that it no longer uses for loading\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.util.JarUtils\n+ * @comment This test expects MalformedURLException for some specific URLs.\n+ *          We use othervm to prevent interference from other tests which\n+ *          might have installed custom URLStreamHandler(s)\n+ * @run junit\/othervm JarLoaderCloseTest\n+ *\/\n+public class JarLoaderCloseTest {\n+\n+    private static final String RESOURCE_NAME = \"foo-bar.txt\";\n+    private static final String RESOURCE_CONTENT = \"Hello world\";\n+    private static final Path TEST_SCRATCH_DIR = Path.of(\".\");\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        \/\/ create a file which will be added to the JAR file that gets tested\n+        Files.writeString(TEST_SCRATCH_DIR.resolve(RESOURCE_NAME), RESOURCE_CONTENT);\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with malformed URLs.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"C:\\\\foo\\\\bar\\\\hello\/world.jar lib2.jar\",\n+            \"C:\/hello\/world\/foo.jar\",\n+            \"lib4.jar C:\\\\bar\\\\foo\\\\world\/hello.jar\"\n+    })\n+    public void testMalformedClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a non-existent resource just to\n+        \/\/ exercise the URLClassPath code of loading the jar and parsing the Class-Path entry.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(\"non-existent.txt\")) {\n+                assertNull(is, \"unexpectedly found a resource in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    \/*\n+     * Creates a JAR file with a manifest which has a Class-Path entry value with URLs\n+     * that are parsable but point to files that don't exist on the filesystem.\n+     * Then uses a URLClassLoader backed by the JAR file in its classpath, loads some resource,\n+     * closes the URLClassLoader and then expects that the underlying JAR file can be deleted\n+     * from the filesystem.\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = {\n+            \"\/home\/me\/hello\/world.jar lib9.jar\",\n+            \"lib10.jar\"\n+    })\n+    public void testParsableClassPathEntry(final String classPathValue) throws Exception {\n+        final Manifest manifest = createManifestWithClassPath(classPathValue);\n+        final Path jar = Files.createTempFile(TEST_SCRATCH_DIR, \"8338445\", \".jar\");\n+        \/\/ create the JAR file with the given manifest and an arbitrary file\n+        JarUtils.createJarFile(jar, manifest, TEST_SCRATCH_DIR, Path.of(RESOURCE_NAME));\n+        System.out.println(\"created jar at \" + jar + \" with manifest:\");\n+        manifest.write(System.out);\n+        final URL[] urlClassPath = new URL[]{jar.toUri().toURL()};\n+        \/\/ Create a URLClassLoader backed by the JAR file and load a resource\n+        \/\/ and verify the resource contents.\n+        \/\/ Then close the classloader. After the classloader is closed\n+        \/\/ issue a delete on the underlying JAR file on the filesystem. The delete is expected\n+        \/\/ to succeed.\n+        try (final URLClassLoader cl = new URLClassLoader(urlClassPath)) {\n+            try (final InputStream is = cl.getResourceAsStream(RESOURCE_NAME)) {\n+                assertNotNull(is, RESOURCE_NAME + \" not located by classloader in classpath \"\n+                        + Arrays.toString(urlClassPath));\n+                final String content = new String(is.readAllBytes(), US_ASCII);\n+                assertEquals(RESOURCE_CONTENT, content, \"unexpected content in \" + RESOURCE_NAME);\n+            }\n+        }\n+        \/\/ now delete the JAR file and verify the delete worked\n+        Files.delete(jar);\n+        assertFalse(Files.exists(jar), jar + \" exists even after being deleted\");\n+    }\n+\n+    private static Manifest createManifestWithClassPath(final String classPathValue) {\n+        final Manifest manifest = new Manifest();\n+        final Attributes mainAttributes = manifest.getMainAttributes();\n+        mainAttributes.putValue(\"Manifest-Version\", \"1.0\");\n+        mainAttributes.putValue(\"Class-Path\", classPathValue);\n+        return manifest;\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/URLClassLoader\/JarLoaderCloseTest.java","additions":148,"deletions":0,"binary":false,"changes":148,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -76,0 +76,1 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n@@ -115,0 +116,1 @@\n+    static final AtomicInteger requestCount = new AtomicInteger();\n@@ -247,1 +249,1 @@\n-    public void testNoStalls(String uri, boolean sameClient)\n+    public void testNoStalls(String rootUri, boolean sameClient)\n@@ -249,0 +251,1 @@\n+        if (!FAILURES.isEmpty()) return;\n@@ -250,1 +253,1 @@\n-        out.printf(\"%ntestNoStalls(%s, %b)%n\", uri, sameClient);\n+        out.printf(\"%ntestNoStalls(%s, %b)%n\", rootUri, sameClient);\n@@ -255,0 +258,2 @@\n+            String uri = rootUri + \"\/\" + requestCount.incrementAndGet();\n+            out.printf(\"\\tsending request %s%n\", uri);\n@@ -334,0 +339,4 @@\n+        if (!FAILURES.isEmpty()) {\n+            out.printf(\"%s: skipping test - previous failure detected%n\", name);\n+            return;\n+        }\n@@ -344,1 +353,1 @@\n-    private <T,U> void testDependent(String uri, boolean sameClient,\n+    private <T,U> void testDependent(String rootUri, boolean sameClient,\n@@ -357,0 +366,2 @@\n+            String uri = rootUri + \"\/\" + requestCount.incrementAndGet();\n+            out.printf(\"\\tsending request %s%n\", uri);\n@@ -366,1 +377,7 @@\n-            assert subscriberType == SubscriberType.LAZZY || !responseCF.isDone();\n+            \/\/ The body of the main response can be received before the body\n+            \/\/ of the push promise handlers are received.\n+            \/\/ The body of the main response doesn't stall, so the cf of\n+            \/\/ the main response may be done here even for EAGER subscribers.\n+            \/\/ We cannot make any assumption on the state of the main response\n+            \/\/ cf here, so the only thing we can do is to call the finisher\n+            \/\/ which will wait for them all.\n","filename":"test\/jdk\/java\/net\/httpclient\/DependentPromiseActionsTest.java","additions":22,"deletions":5,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -67,1 +67,1 @@\n- * @bug 8087112\n+ * @bug 8087112 8336655 8338569\n","filename":"test\/jdk\/java\/net\/httpclient\/DigestEchoClient.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -88,2 +88,2 @@\n-    URI getUri, postUri, hangUri;\n-    URI h2postUri, h2hangUri, h2endStreamUri, h2warmupURI;\n+    URI getUri, postUri, forcePostUri, hangUri;\n+    URI h2postUri, h2forcePostUri, h2hangUri, h2endStreamUri, h2warmupURI;\n@@ -100,0 +100,1 @@\n+                { forcePostUri, 200, false, HTTP_1_1 },\n@@ -102,0 +103,1 @@\n+                { h2forcePostUri, 200, false, HTTP_2 },\n@@ -130,1 +132,1 @@\n-            verifyRequest(expectedStatusCode, resp, exceptionally, testThrowable);\n+            verifyRequest(uri.getPath(), expectedStatusCode, resp, exceptionally, testThrowable);\n@@ -140,0 +142,1 @@\n+        http1TestServer.addHandler(new ForcePostHandler(), \"\/http1\/forcePost\");\n@@ -142,0 +145,1 @@\n+        forcePostUri = URI.create(\"http:\/\/\" + http1TestServer.serverAuthority() + \"\/http1\/forcePost\");\n@@ -152,0 +156,1 @@\n+        http2TestServer.addHandler(new ForcePostHandler().toHttp2Handler(), \"\/http2\/forcePost\");\n@@ -157,0 +162,1 @@\n+        h2forcePostUri = URI.create(\"http:\/\/\" + http2TestServer.serverAuthority() + \"\/http2\/forcePost\");\n@@ -160,3 +166,3 @@\n-        out.printf(\"HTTP\/1.1 server listening at: %s\", http1TestServer.serverAuthority());\n-        out.printf(\"HTTP\/1.1 hang server listening at: %s\", hangUri.getRawAuthority());\n-        out.printf(\"HTTP\/2 clear server listening at: %s\", http2TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 server listening at: %s %n\", http1TestServer.serverAuthority());\n+        out.printf(\"HTTP\/1.1 hang server listening at: %s %n\", hangUri.getRawAuthority());\n+        out.printf(\"HTTP\/2 clear server listening at: %s %n\", http2TestServer.serverAuthority());\n@@ -210,0 +216,12 @@\n+    static class ForcePostHandler implements HttpTestHandler {\n+        @Override\n+        public void handle(HttpTestExchange exchange) throws IOException {\n+            try (InputStream is = exchange.getRequestBody()) {\n+                err.println(\"Server reading body inside the force Post\");\n+                is.readAllBytes();\n+                err.println(\"Server send 200 (length=0) in the force post\");\n+                exchange.sendResponseHeaders(200, 0);\n+            }\n+        }\n+    }\n+\n@@ -340,1 +358,4 @@\n-    private void verifyRequest(int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+    private void verifyRequest(String path, int expectedStatusCode, HttpResponse<String> resp, boolean exceptionally, Throwable testThrowable) {\n+        if (!exceptionally) {\n+            err.printf(\"Response code %s received for path %s %n\", resp.statusCode(), path);\n+        }\n@@ -342,1 +363,1 @@\n-            err.println(testThrowable);\n+            err.println(\"Finished exceptionally Test throwable: \" + testThrowable);\n@@ -348,1 +369,1 @@\n-            err.println(\"Request completed successfully\");\n+            err.println(\"Request completed successfully for path \" + path);\n","filename":"test\/jdk\/java\/net\/httpclient\/ExpectContinueTest.java","additions":31,"deletions":10,"binary":false,"changes":41,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -198,0 +198,3 @@\n+        boolean proxyInClosed;  \/\/ only accessed from synchronized block\n+        boolean proxyOutClosed; \/\/ only accessed from synchronized block\n+\n@@ -597,3 +600,1 @@\n-                    closing = true;\n-                    serverSocket.close();\n-                    clientSocket.close();\n+                    closeClientIn();\n@@ -618,3 +619,1 @@\n-                    closing = true;\n-                    serverSocket.close();\n-                    clientSocket.close();\n+                    closeClientOut();\n@@ -644,0 +643,22 @@\n+        synchronized void closeClientIn() throws IOException {\n+            closing = true;\n+            proxyInClosed = true;\n+            clientSocket.shutdownInput();\n+            serverSocket.shutdownOutput();\n+            if (proxyOutClosed) {\n+                serverSocket.close();\n+                clientSocket.close();\n+            }\n+        }\n+\n+        synchronized void closeClientOut() throws IOException {\n+            closing = true;\n+            proxyOutClosed = true;\n+            serverSocket.shutdownInput();\n+            clientSocket.shutdownOutput();\n+            if (proxyInClosed) {\n+                serverSocket.close();\n+                clientSocket.close();\n+            }\n+        }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/ProxyServer.java","additions":28,"deletions":7,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -213,1 +213,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -215,0 +215,1 @@\n+                assertTrue(client.isTerminated());\n@@ -216,1 +217,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -218,1 +223,0 @@\n-            assertTrue(client.isTerminated());\n@@ -275,1 +279,1 @@\n-            if (client.awaitTermination(Duration.ofMillis(2000))) {\n+            if (client.awaitTermination(Duration.ofMillis(2500))) {\n@@ -277,0 +281,1 @@\n+                assertTrue(client.isTerminated());\n@@ -278,1 +283,5 @@\n-                throw new AssertionError(\"client still running\");\n+                client = null;\n+                var error = TRACKER.check(500);\n+                if (error != null) throw error;\n+                throw new AssertionError(\"client was still running, but exited after further delay: \"\n+                        + \"timeout should be adjusted\");\n@@ -280,1 +289,0 @@\n-            assertTrue(client.isTerminated());\n","filename":"test\/jdk\/java\/net\/httpclient\/ShutdownNow.java","additions":15,"deletions":7,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8087112 8178699\n+ * @bug 8087112 8178699 8338569\n@@ -57,0 +57,2 @@\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n@@ -575,2 +577,1 @@\n-        URI uri = new URI(target);\n-        HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n+        AtomicInteger count = new AtomicInteger();\n@@ -579,0 +580,3 @@\n+            URI uri = new URI(target+\"?get-sync;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder().uri(uri).GET().build();\n@@ -587,4 +591,1 @@\n-        request = HttpRequest.newBuilder()\n-                .uri(uri)\n-                .POST(BodyPublishers.ofFile(requestBody))\n-                .build();\n+\n@@ -593,0 +594,6 @@\n+            URI uri = new URI(target+\"?post-async;count=\"+count.incrementAndGet());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder()\n+                    .uri(uri)\n+                    .POST(BodyPublishers.ofFile(requestBody))\n+                    .build();\n@@ -613,1 +620,0 @@\n-        request = HttpRequest.newBuilder(uri).GET().build();\n@@ -615,0 +621,1 @@\n+        Set<String> inFlight = ConcurrentHashMap.newKeySet();\n@@ -616,0 +623,4 @@\n+            URI uri = new URI(target+\"?get-async;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -618,0 +629,2 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n@@ -633,0 +646,4 @@\n+            URI uri = new URI(target+\"?get-async-next;count=\"+count.incrementAndGet());\n+            inFlight.add(uri.getQuery());\n+            System.out.println(\"Sending \" + uri);\n+            HttpRequest request = HttpRequest.newBuilder(uri).GET().build();\n@@ -635,0 +652,3 @@\n+                      inFlight.remove(uri.getQuery());\n+                      System.out.println(\"Got response for: \" + uri);\n+                      System.out.println(\"In flight: \" + inFlight);\n@@ -642,0 +662,2 @@\n+        System.out.println(\"Waiting: In flight: \" + inFlight);\n+        System.out.println(\"Queue size: \" + q.size());\n@@ -645,0 +667,2 @@\n+            System.out.println(\"Waiting: In flight: \" + inFlight);\n+            System.out.println(\"Queue size: \" + q.size());\n","filename":"test\/jdk\/java\/net\/httpclient\/SmokeTest.java","additions":33,"deletions":9,"binary":false,"changes":42,"status":"modified"},{"patch":"@@ -0,0 +1,336 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.URI;\n+import java.net.http.HttpClient;\n+import java.net.http.HttpRequest;\n+import java.net.http.HttpResponse;\n+import java.net.http.HttpResponse.BodyHandlers;\n+import java.util.ArrayList;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+import javax.net.ssl.SSLContext;\n+\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestExchange;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestHandler;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpTestServer;\n+import jdk.test.lib.net.SimpleSSLContext;\n+import jdk.test.lib.net.URIBuilder;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+import static java.nio.charset.StandardCharsets.UTF_8;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.fail;\n+\n+\/*\n+ * @test\n+ * @bug 8335181\n+ * @summary verify that the HttpClient correctly handles incoming GOAWAY frames and\n+ *          retries any unprocessed requests on a new connection\n+ * @library \/test\/lib \/test\/jdk\/java\/net\/httpclient\/lib\n+ * @build jdk.httpclient.test.lib.common.HttpServerAdapters\n+ *        jdk.test.lib.net.SimpleSSLContext\n+ * @run junit H2GoAwayTest\n+ *\/\n+public class H2GoAwayTest {\n+    private static final String REQ_PATH = \"\/test\";\n+    private static HttpTestServer server;\n+    private static String REQ_URI_BASE;\n+    private static SSLContext sslCtx;\n+\n+    @BeforeAll\n+    static void beforeAll() throws Exception {\n+        sslCtx = new SimpleSSLContext().get();\n+        assertNotNull(sslCtx, \"SSLContext couldn't be created\");\n+        server = HttpTestServer.create(HTTP_2, sslCtx);\n+        server.addHandler(new Handler(), REQ_PATH);\n+        server.start();\n+        System.out.println(\"Server started at \" + server.getAddress());\n+        REQ_URI_BASE = URIBuilder.newBuilder().scheme(\"https\")\n+                .loopback()\n+                .port(server.getAddress().getPort())\n+                .path(REQ_PATH)\n+                .build().toString();\n+    }\n+\n+    @AfterAll\n+    static void afterAll() {\n+        if (server != null) {\n+            System.out.println(\"Stopping server at \" + server.getAddress());\n+            server.stop();\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when several requests are sent using send() and the server\n+     * connection is configured to send a GOAWAY after processing only a few requests, then\n+     * the remaining requests are retried on a different connection\n+     *\/\n+    @Test\n+    public void testSequential() throws Exception {\n+        final LimitedPerConnRequestApprover reqApprover = new LimitedPerConnRequestApprover();\n+        server.setRequestApprover(reqApprover::allowNewRequest);\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int numReqs = LimitedPerConnRequestApprover.MAX_REQS_PER_CONN + 3;\n+                final Set<String> connectionKeys = new LinkedHashSet<>();\n+                for (int i = 1; i <= numReqs; i++) {\n+                    final URI reqURI = new URI(REQ_URI_BASE + \"?seq&\" + reqMethod + \"=\" + i);\n+                    final HttpRequest req = HttpRequest.newBuilder()\n+                            .uri(reqURI)\n+                            .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                            .build();\n+                    System.out.println(\"initiating request \" + req);\n+                    final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                    final String respBody = resp.body();\n+                    System.out.println(\"received response: \" + respBody);\n+                    assertEquals(200, resp.statusCode(),\n+                            \"unexpected status code for request \" + resp.request());\n+                    \/\/ response body is the logical key of the connection on which the\n+                    \/\/ request was handled\n+                    connectionKeys.add(respBody);\n+                }\n+                System.out.println(\"connections involved in handling the requests: \"\n+                        + connectionKeys);\n+                \/\/ all requests have finished, we now just do a basic check that\n+                \/\/ more than one connection was involved in processing these requests\n+                assertEquals(2, connectionKeys.size(),\n+                        \"unexpected number of connections \" + connectionKeys);\n+            }\n+        } finally {\n+            server.setRequestApprover(null); \/\/ reset\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the send() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesException() throws Exception {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    int numSuccess = 0;\n+                    int numFailed = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?sync&\" + reqMethod + \"=\" + i;\n+                        final URI reqURI = new URI(REQ_URI_BASE + reqQueryPart);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        if (i <= maxAllowedReqs) {\n+                            \/\/ expected to successfully complete\n+                            numSuccess++;\n+                            final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                            final String respBody = resp.body();\n+                            System.out.println(\"received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } else {\n+                            \/\/ expected to fail as unprocessed\n+                            try {\n+                                final HttpResponse<String> resp = client.send(req, BodyHandlers.ofString());\n+                                fail(\"Request was expected to fail as unprocessed,\"\n+                                        + \" but got response: \" + resp.body() + \", status code: \"\n+                                        + resp.statusCode());\n+                            } catch (IOException ioe) {\n+                                \/\/ verify it failed for the right reason\n+                                if (ioe.getMessage() == null\n+                                        || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                    \/\/ propagate the original failure\n+                                    throw ioe;\n+                                }\n+                                numFailed++; \/\/ failed due to right reason\n+                                System.out.println(\"received expected failure: \" + ioe\n+                                        + \", for request \" + reqURI);\n+                            }\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * Verifies that when a server responds with a GOAWAY and then never processes the new retried\n+     * requests on a new connection too, then the application code receives the request failure.\n+     * This tests the sendAsync() API of the HttpClient.\n+     *\/\n+    @Test\n+    public void testUnprocessedRaisesExceptionAsync() throws Throwable {\n+        try (final HttpClient client = HttpClient.newBuilder().version(HTTP_2)\n+                .sslContext(sslCtx).build()) {\n+            final Random random = new Random();\n+            final String[] reqMethods = {\"HEAD\", \"GET\", \"POST\"};\n+            for (final String reqMethod : reqMethods) {\n+                final int maxAllowedReqs = 2;\n+                final int numReqs = maxAllowedReqs + 3; \/\/ 3 more requests than max allowed\n+                \/\/ configure the approver\n+                final LimitedRequestApprover reqApprover = new LimitedRequestApprover(maxAllowedReqs);\n+                server.setRequestApprover(reqApprover::allowNewRequest);\n+                try {\n+                    final List<Future<HttpResponse<String>>> futures = new ArrayList<>();\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final URI reqURI = new URI(REQ_URI_BASE + \"?async&\" + reqMethod + \"=\" + i);\n+                        final HttpRequest req = HttpRequest.newBuilder()\n+                                .uri(reqURI)\n+                                .method(reqMethod, HttpRequest.BodyPublishers.noBody())\n+                                .build();\n+                        System.out.println(\"initiating request \" + req);\n+                        final Future<HttpResponse<String>> f = client.sendAsync(req, BodyHandlers.ofString());\n+                        futures.add(f);\n+                    }\n+                    \/\/ wait for responses\n+                    int numFailed = 0;\n+                    int numSuccess = 0;\n+                    for (int i = 1; i <= numReqs; i++) {\n+                        final String reqQueryPart = \"?async&\" + reqMethod + \"=\" + i;\n+                        try {\n+                            System.out.println(\"waiting response of request \"\n+                                    + REQ_URI_BASE + reqQueryPart);\n+                            final HttpResponse<String> resp = futures.get(i - 1).get();\n+                            numSuccess++;\n+                            final String respBody = resp.body();\n+                            System.out.println(\"request: \" + resp.request()\n+                                    + \", received response: \" + respBody);\n+                            assertEquals(200, resp.statusCode(),\n+                                    \"unexpected status code for request \" + resp.request());\n+                        } catch (ExecutionException ee) {\n+                            final Throwable cause = ee.getCause();\n+                            if (!(cause instanceof IOException ioe)) {\n+                                throw cause;\n+                            }\n+                            \/\/ verify it failed for the right reason\n+                            if (ioe.getMessage() == null\n+                                    || !ioe.getMessage().contains(\"request not processed by peer\")) {\n+                                \/\/ propagate the original failure\n+                                throw ioe;\n+                            }\n+                            numFailed++; \/\/ failed due to the right reason\n+                            System.out.println(\"received expected failure: \" + ioe\n+                                    + \", for request \" + REQ_URI_BASE + reqQueryPart);\n+                        }\n+                    }\n+                    \/\/ verify the correct number of requests succeeded\/failed\n+                    assertEquals(maxAllowedReqs, numSuccess, \"unexpected number of requests succeeded\");\n+                    assertEquals((numReqs - maxAllowedReqs), numFailed, \"unexpected number of requests failed\");\n+                } finally {\n+                    server.setRequestApprover(null); \/\/ reset\n+                }\n+            }\n+        }\n+    }\n+\n+    \/\/ only allows fixed number of requests, irrespective of which server connection handles\n+    \/\/ it. requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedRequestApprover {\n+        private final int maxAllowedReqs;\n+        private final AtomicInteger numApproved = new AtomicInteger();\n+\n+        private LimitedRequestApprover(final int maxAllowedReqs) {\n+            this.maxAllowedReqs = maxAllowedReqs;\n+        }\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final int approved = numApproved.incrementAndGet();\n+            return approved <= maxAllowedReqs;\n+        }\n+    }\n+\n+    \/\/ allows a certain number of requests per server connection.\n+    \/\/ requests that are rejected will either be sent a GOAWAY on the connection\n+    \/\/ or a RST_FRAME with a REFUSED_STREAM on the stream\n+    private static final class LimitedPerConnRequestApprover {\n+        private static final int MAX_REQS_PER_CONN = 6;\n+        private final Map<String, AtomicInteger> numApproved =\n+                new ConcurrentHashMap<>();\n+        private final Map<String, AtomicInteger> numDisapproved =\n+                new ConcurrentHashMap<>();\n+\n+        public boolean allowNewRequest(final String serverConnKey) {\n+            final AtomicInteger approved = numApproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            int curr = approved.get();\n+            while (curr < MAX_REQS_PER_CONN) {\n+                if (approved.compareAndSet(curr, curr + 1)) {\n+                    return true; \/\/ new request allowed\n+                }\n+                curr = approved.get();\n+            }\n+            final AtomicInteger disapproved = numDisapproved.computeIfAbsent(serverConnKey,\n+                    (k) -> new AtomicInteger());\n+            final int numUnprocessed = disapproved.incrementAndGet();\n+            System.out.println(approved.get() + \" processed, \"\n+                    + numUnprocessed + \" unprocessed requests on connection \" + serverConnKey);\n+            return false;\n+        }\n+    }\n+\n+    private static final class Handler implements HttpTestHandler {\n+\n+        @Override\n+        public void handle(final HttpTestExchange exchange) throws IOException {\n+            final String connectionKey = exchange.getConnectionKey();\n+            System.out.println(\"responding to request: \" + exchange.getRequestURI()\n+                    + \" on connection \" + connectionKey);\n+            final byte[] response = connectionKey.getBytes(UTF_8);\n+            exchange.sendResponseHeaders(200, response.length);\n+            try (final OutputStream os = exchange.getResponseBody()) {\n+                os.write(response);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/H2GoAwayTest.java","additions":336,"deletions":0,"binary":false,"changes":336,"status":"added"},{"patch":"@@ -61,0 +61,1 @@\n+import java.util.function.Predicate;\n@@ -242,0 +243,1 @@\n+        public abstract String getConnectionKey();\n@@ -256,1 +258,1 @@\n-            return new Http2TestExchangeImpl(exchange);\n+            return new H2ExchangeImpl(exchange);\n@@ -309,0 +311,6 @@\n+\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getLocalAddress() + \"->\" + exchange.getRemoteAddress();\n+            }\n+\n@@ -315,1 +323,1 @@\n-        private static final class Http2TestExchangeImpl extends HttpTestExchange {\n+        private static final class H2ExchangeImpl extends HttpTestExchange {\n@@ -317,1 +325,1 @@\n-            Http2TestExchangeImpl(Http2TestExchange exch) {\n+            H2ExchangeImpl(Http2TestExchange exch) {\n@@ -366,0 +374,5 @@\n+            @Override\n+            public String getConnectionKey() {\n+                return exchange.getConnectionKey();\n+            }\n+\n@@ -711,0 +724,1 @@\n+        public abstract void setRequestApprover(final Predicate<String> approver);\n@@ -859,0 +873,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                throw new UnsupportedOperationException(\"not supported\");\n+            }\n@@ -910,0 +929,5 @@\n+\n+            @Override\n+            public void setRequestApprover(final Predicate<String> approver) {\n+                this.impl.setRequestApprover(approver);\n+            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":27,"deletions":3,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,0 +74,6 @@\n+\n+    \/**\n+     * {@return the identification of the connection on which this exchange is being\n+     * processed}\n+     *\/\n+    String getConnectionKey();\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchange.java","additions":7,"deletions":1,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -223,0 +223,5 @@\n+    @Override\n+    public String getConnectionKey() {\n+        return conn.connectionKey();\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestExchangeImpl.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -35,0 +35,2 @@\n+import java.util.function.Predicate;\n+\n@@ -62,0 +64,2 @@\n+    \/\/ request approver which takes the server connection key as the input\n+    private volatile Predicate<String> newRequestApprover;\n@@ -288,0 +292,8 @@\n+    public void setRequestApprover(final Predicate<String> approver) {\n+        this.newRequestApprover = approver;\n+    }\n+\n+    Predicate<String> getRequestApprover() {\n+        return this.newRequestApprover;\n+    }\n+\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,0 +78,1 @@\n+import java.util.Set;\n@@ -81,0 +82,2 @@\n+import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.function.BiPredicate;\n@@ -82,0 +85,1 @@\n+import java.util.function.Predicate;\n@@ -85,0 +89,1 @@\n+import static jdk.internal.net.http.frame.ErrorFrame.REFUSED_STREAM;\n@@ -113,0 +118,4 @@\n+    \/\/ the max stream id of a processed H2 request. -1 implies none were processed.\n+    private final AtomicInteger maxProcessedRequestStreamId = new AtomicInteger(-1);\n+    \/\/ the stream id that was sent in a GOAWAY frame. -1 implies no GOAWAY frame was sent.\n+    private final AtomicInteger goAwayRequestStreamId = new AtomicInteger(-1);\n@@ -237,5 +246,23 @@\n-    void goAway(int error) throws IOException {\n-        int laststream = nextstream >= 3 ? nextstream - 2 : 1;\n-\n-        GoAwayFrame go = new GoAwayFrame(laststream, error);\n-        outputQ.put(go);\n+    private void sendGoAway(final int error) throws IOException {\n+        int maxProcessedStreamId = maxProcessedRequestStreamId.get();\n+        if (maxProcessedStreamId == -1) {\n+            maxProcessedStreamId = 0;\n+        }\n+        boolean send = false;\n+        int currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        \/\/ update the last processed stream id and send a goaway frame if the new last processed\n+        \/\/ stream id is lesser than the last processed stream id sent in\n+        \/\/ a previous goaway frame (if any)\n+        while (currentGoAwayReqStrmId == -1 || maxProcessedStreamId < currentGoAwayReqStrmId) {\n+            if (goAwayRequestStreamId.compareAndSet(currentGoAwayReqStrmId, maxProcessedStreamId)) {\n+                send = true;\n+                break;\n+            }\n+            currentGoAwayReqStrmId = goAwayRequestStreamId.get();\n+        }\n+        if (!send) {\n+            return;\n+        }\n+        final GoAwayFrame frame = new GoAwayFrame(maxProcessedStreamId, error);\n+        outputQ.put(frame);\n+        System.err.println(\"Sending GOAWAY frame \" + frame + \" from server connection \" + this);\n@@ -334,2 +361,3 @@\n-            if (error != -1)\n-                goAway(error);\n+            if (error != -1) {\n+                sendGoAway(error);\n+            }\n@@ -615,0 +643,8 @@\n+        \/\/ skip processing the request if configured to do so\n+        final String connKey = connectionKey();\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting primordial stream 1 and sending GOAWAY\" +\n+                    \" on server connection \" + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -623,0 +659,1 @@\n+        maxProcessedRequestStreamId.set(1);\n@@ -628,0 +665,12 @@\n+    private boolean shouldProcessNewHTTPRequest(final String serverConnKey) {\n+        final Predicate<String> approver = this.server.getRequestApprover();\n+        if (approver == null) {\n+            return true; \/\/ process the request\n+        }\n+        return approver.test(serverConnKey);\n+    }\n+\n+    final String connectionKey() {\n+        return this.server.getAddress() + \"->\" + this.socket.getRemoteSocketAddress();\n+    }\n+\n@@ -635,1 +684,1 @@\n-            throw new IOException(\"unexpected stream id\");\n+            throw new IOException(\"unexpected stream id: \" + streamid);\n@@ -666,1 +715,1 @@\n-        if (disallowedHeader.isPresent())\n+        if (disallowedHeader.isPresent()) {\n@@ -668,0 +717,1 @@\n+        }\n@@ -669,1 +719,10 @@\n-\n+        \/\/ skip processing the request if the server is configured to do so\n+        final String connKey = connectionKey();\n+        final String path = headers.firstValue(\":path\").orElse(\"\");\n+        if (!shouldProcessNewHTTPRequest(connKey)) {\n+            System.err.println(\"Rejecting stream \" + streamid\n+                    + \" and sending GOAWAY on server connection \"\n+                    + connKey + \", for request: \" + path);\n+            sendGoAway(ErrorFrame.NO_ERROR);\n+            return;\n+        }\n@@ -672,0 +731,8 @@\n+        \/\/ keep track of the largest request id that we have processed\n+        int currentLargest = maxProcessedRequestStreamId.get();\n+        while (streamid > currentLargest) {\n+            if (maxProcessedRequestStreamId.compareAndSet(currentLargest, streamid)) {\n+                break;\n+            }\n+            currentLargest = maxProcessedRequestStreamId.get();\n+        }\n@@ -766,0 +833,2 @@\n+                    System.err.println(\"EOF reached on connection \" + connectionKey()\n+                            + \", will no longer accept incoming frames\");\n@@ -789,0 +858,11 @@\n+                            final int streamId = frame.streamid();\n+                            final int finalProcessedStreamId = goAwayRequestStreamId.get();\n+                            \/\/ if we already sent a goaway, then don't create new streams with\n+                            \/\/ higher stream ids.\n+                            if (finalProcessedStreamId != -1 && streamId > finalProcessedStreamId) {\n+                                System.err.println(connectionKey() + \" resetting stream \" + streamId\n+                                        + \" as REFUSED_STREAM\");\n+                                final ResetFrame rst = new ResetFrame(streamId, REFUSED_STREAM);\n+                                outputQ.put(rst);\n+                                continue;\n+                            }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":91,"deletions":11,"binary":false,"changes":102,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -51,0 +51,1 @@\n+import static jdk.test.lib.NetworkConfiguration.isSameInterface;\n@@ -298,2 +299,2 @@\n-        assertTrue(s.getNetworkInterface().equals(ni));\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n@@ -318,2 +319,2 @@\n-        assertTrue(s.getOption(IP_MULTICAST_IF).equals(ni));\n-        assertTrue(s.getNetworkInterface().equals(ni));\n+        assertTrue(isSameInterface(s.getOption(IP_MULTICAST_IF), ni));\n+        assertTrue(isSameInterface(s.getNetworkInterface(), ni));\n@@ -415,1 +416,2 @@\n-        byte[] message = \"hello\".getBytes(\"UTF-8\");\n+        String msg = \"AdaptorMulticasting:  \" + System.nanoTime();\n+        byte[] message = msg.getBytes(\"UTF-8\");\n@@ -424,2 +426,16 @@\n-        p = new DatagramPacket(new byte[1024], 100);\n-        s.receive(p);\n+        while (true) {\n+            p = new DatagramPacket(new byte[1024], 100);\n+            s.receive(p);\n+            if (p.getPort() == s.getLocalPort()) {\n+                String str = new String(p.getData(), p.getOffset(), p.getLength(), \"UTF-8\");\n+                if (Arrays.equals(p.getData(), p.getOffset(), p.getLength(), message, 0, message.length)) {\n+                    System.out.format(\"Got expected message \\\"%s\\\" from %s%n\", str, p.getSocketAddress());\n+                    break;\n+                }\n+                System.out.println(\"Unexpected message received. Expected: \" + msg);\n+                System.out.println(\"Received message doesn't match - skipping: \" + str);\n+            } else {\n+                System.out.println(\"Unexpected message received. Expected message from: \" + s.getLocalAddress());\n+                System.out.println(\"Received message sender doesn't match - skipping: \" + p.getSocketAddress());\n+            }\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AdaptorMulticasting.java","additions":24,"deletions":8,"binary":false,"changes":32,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,0 +34,1 @@\n+import java.net.BindException;\n@@ -49,0 +50,1 @@\n+import java.util.function.Predicate;\n@@ -57,0 +59,32 @@\n+    interface RetryableTest<T extends Exception> {\n+        public void runTest() throws T;\n+    }\n+\n+    \/\/ retry the given lambda (RetryableTest) if an exception\n+    \/\/ that satisfies the predicate (retryOn) is caught.\n+    <T extends Exception> void testWithRetry(RetryableTest<T> test,\n+                                             Predicate<Throwable> retryOn,\n+                                             int max) throws T {\n+        for (int i=0; i < max; i++) {\n+            try {\n+                test.runTest();\n+                break;\n+            } catch (Throwable t) {\n+                if (i < max -1 && retryOn.test(t)) {\n+                    System.out.println(\"Got \" + t + \"; will retry\");\n+                } else throw t;\n+            }\n+        }\n+    }\n+\n+    \/**\n+     * When calling {@link DatagramChannel#disconnect()} a {@link BindException}\n+     * may occur. In which case we want to retry the test.\n+     *\/\n+    class BindExceptionOnDisconnect extends BindException {\n+        BindExceptionOnDisconnect(BindException x) {\n+            super(x.getMessage());\n+            initCause(x);\n+        }\n+    }\n+\n@@ -64,11 +98,3 @@\n-        try (DatagramChannel dc = DatagramChannel.open()) {\n-            System.out.println(\"Test with default\");\n-            dc.bind(new InetSocketAddress(lb, 0));\n-            test(dc);\n-            test(dc);\n-        }\n-\n-        \/\/ test with IPv6 socket\n-        if (IPSupport.hasIPv6()) {\n-            System.out.println(\"Test with IPv6 socket\");\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+        System.out.println(\"Test with default\");\n+        testWithRetry(() -> {\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -79,0 +105,12 @@\n+        }, BindExceptionOnDisconnect.class::isInstance, 5);\n+\n+        \/\/ test with IPv6 socket\n+        if (IPSupport.hasIPv6()) {\n+            System.out.println(\"Test with IPv6 socket\");\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET6)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -84,5 +122,7 @@\n-            try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n-                dc.bind(new InetSocketAddress(lb, 0));\n-                test(dc);\n-                test(dc);\n-            }\n+            testWithRetry(() -> {\n+                try (DatagramChannel dc = DatagramChannel.open(StandardProtocolFamily.INET)) {\n+                    dc.bind(new InetSocketAddress(lb, 0));\n+                    test(dc);\n+                    test(dc);\n+                }\n+            }, BindExceptionOnDisconnect.class::isInstance, 5);\n@@ -92,0 +132,1 @@\n+\n@@ -114,1 +155,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -137,1 +182,5 @@\n-        dc.disconnect();\n+        try {\n+            dc.disconnect();\n+        } catch (BindException x) {\n+            throw new BindExceptionOnDisconnect(x);\n+        }\n@@ -171,1 +220,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n@@ -213,1 +266,5 @@\n-            dc.disconnect();\n+            try {\n+                dc.disconnect();\n+            } catch (BindException x) {\n+                throw new BindExceptionOnDisconnect(x);\n+            }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/AfterDisconnect.java","additions":78,"deletions":21,"binary":false,"changes":99,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,2 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Connect\n@@ -41,0 +43,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -117,0 +121,11 @@\n+                \/\/ When connecting an unbound datagram channel, the underlying\n+                \/\/ socket will first be bound to the wildcard address. On macOS,\n+                \/\/ the system may allocate the same port on which another socket\n+                \/\/ is already bound with a more specific address. This may prevent\n+                \/\/ datagrams directed at the connected socket to reach it.\n+                \/\/ To avoid this, when on macOS, we preemptively bind `dc` to the\n+                \/\/ specific address instead of letting it bind to the wildcard.\n+                if (Platform.isOSX()) {\n+                    dc.bind(new InetSocketAddress(((InetSocketAddress)connectSocketAddress).getAddress(), 0));\n+                    err.println(\"Initiator bound to: \" + connectSocketAddress);\n+                }\n@@ -120,0 +135,1 @@\n+                assert !connectSocketAddress.equals(dc.getLocalAddress());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Connect.java","additions":17,"deletions":1,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2019, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2019, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,1 @@\n- *     sender address\n+ *     sender address.\n@@ -66,0 +66,1 @@\n+            System.out.println(\"\\nReader bound to: \" + reader.getLocalAddress());\n@@ -78,0 +79,1 @@\n+            System.out.println(\"\\nSender bound to: \" + sender.getLocalAddress());\n@@ -100,0 +102,5 @@\n+            System.out.println(\"Sender bound to: \" + local);\n+            if (((InetSocketAddress)local).getPort() == remotePort) {\n+                System.out.println(\"testSend: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -108,0 +115,2 @@\n+                System.out.format(\"testSend: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -141,0 +150,5 @@\n+            System.out.println(\"Reader bound to: \" + remote);\n+            if (((InetSocketAddress)local).getPort() == ((InetSocketAddress)remote).getPort()) {\n+                System.out.println(\"testReceive: Sender and reader have same port: skipping\");\n+                return;\n+            }\n@@ -146,0 +160,2 @@\n+                System.out.format(\"testReceive: reader waiting to receive at: %s%n\",\n+                        reader.getLocalAddress());\n@@ -168,1 +184,6 @@\n-            return Optional.ofNullable(NetworkInterface.getByInetAddress(ia));\n+            NetworkInterface nif = NetworkInterface.getByInetAddress(ia);\n+            if (nif != null) {\n+                System.out.format(\"Selecting interface %s[%d]%n\\twith addresses:%n\\t%s%n\",\n+                    nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n+            }\n+            return Optional.ofNullable(nif);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ManySourcesAndTargets.java","additions":24,"deletions":3,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2007, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2007, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,0 +102,1 @@\n+            long elapsed = 0;\n@@ -104,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -105,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -110,1 +115,6 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            continue;\n+                        }\n@@ -126,2 +136,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -145,1 +155,0 @@\n-                buf.rewind();\n@@ -163,0 +172,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/MulticastSendReceiveTests.java","additions":16,"deletions":5,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,1 +27,2 @@\n- *     the channel's socket to be bound to a local address\n+ *     the channel's socket to be bound to a local address.\n+ * @run main\/othervm NotBound\n@@ -34,0 +35,3 @@\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n@@ -37,0 +41,2 @@\n+    static final CountDownLatch received = new CountDownLatch(1);\n+\n@@ -40,0 +46,1 @@\n+        System.out.println(\"Bound to: \" + dc.getLocalAddress());\n@@ -54,0 +61,1 @@\n+                    System.out.format(\"receiver bound to: %s%n\", local);\n@@ -55,10 +63,35 @@\n-                    \/\/ send message to channel to wakeup receiver\n-                    DatagramChannel sender = DatagramChannel.open();\n-                    try {\n-                        ByteBuffer bb = ByteBuffer.wrap(\"hello\".getBytes());\n-                        InetAddress lh = InetAddress.getLocalHost();\n-                        SocketAddress target =\n-                            new InetSocketAddress(lh, local.getPort());\n-                        sender.send(bb, target);\n-                    } finally {\n-                        sender.close();\n+                    boolean isAnyLocal = local.getAddress().isAnyLocalAddress();\n+                    int maxAttempts = 5;\n+                    int localPort = 0;\n+                    List<InetAddress> llh = isAnyLocal\n+                            ? List.of(InetAddress.getLocalHost(), InetAddress.getLoopbackAddress())\n+                            : List.of(local.getAddress());\n+                    SocketAddress target = null;\n+                    for (int i = 0 ; i < maxAttempts ; i++) {\n+                        InetAddress lh = llh.get(i % llh.size());\n+                        target = new InetSocketAddress(lh, local.getPort());\n+                        \/\/ send message to channel to wakeup receiver\n+                        try (DatagramChannel sender = DatagramChannel.open()) {\n+                            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: hello\".getBytes());\n+                            sender.send(bb, target);\n+                            System.out.format(\"Woke up receiver: sent datagram to %s from %s%n\",\n+                                    target, sender.getLocalAddress());\n+                            localPort = ((InetSocketAddress)sender.getLocalAddress()).getPort();\n+                        }\n+                        if (received.await(250, TimeUnit.MILLISECONDS)) {\n+                            \/\/ The datagram has been received: no need to continue\n+                            \/\/ sending\n+                            break;\n+                        }\n+                        \/\/ if sender port and destination port were identical, which\n+                        \/\/ could happen on some systems, the receiver might not receive\n+                        \/\/ the datagram. So in that case we try again, bailing out if\n+                        \/\/ we had to retry too many times\n+                        if (localPort == local.getPort()) {\n+                            System.out.println(\"Local port and peer port are identical. Retrying...\");\n+                        } else {\n+                            System.out.println(\"Datagram not received after 250ms. Retrying...\");\n+                        }\n+                    }\n+                    if (localPort == local.getPort()) {\n+                        System.out.println(\"Couldn't find a port to send to \" + target);\n@@ -66,1 +99,0 @@\n-\n@@ -80,4 +112,4 @@\n-            DatagramChannel peer = DatagramChannel.open()\n-                .bind(new InetSocketAddress(0));\n-            int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n-            try {\n+            System.out.println(\"Check that connect() binds the socket\");\n+            try (DatagramChannel peer = DatagramChannel.open()) {\n+                peer.bind(new InetSocketAddress(0));\n+                int peerPort = ((InetSocketAddress)(peer.getLocalAddress())).getPort();\n@@ -86,2 +118,0 @@\n-            } finally {\n-                peer.close();\n@@ -96,1 +126,2 @@\n-            ByteBuffer bb = ByteBuffer.wrap(\"ignore this\".getBytes());\n+            System.out.println(\"Check that send() binds the socket\");\n+            ByteBuffer bb = ByteBuffer.wrap(\"NotBound: ignore this\".getBytes());\n@@ -108,0 +139,1 @@\n+            System.out.println(\"Check that blocking receive() binds the socket\");\n@@ -111,0 +143,1 @@\n+            received.countDown();\n@@ -121,0 +154,1 @@\n+            System.out.println(\"Check that non-blocking receive() binds the socket\");\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/NotBound.java","additions":54,"deletions":20,"binary":false,"changes":74,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2013, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2013, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -74,2 +74,3 @@\n-            System.out.format(\"Send message -> group %s (id=0x%x)\\n\",\n-                    group.getHostAddress(), id);\n+            System.out.format(\"Send message -> group [%s]:%d (id=0x%x) nif:%s[%s]%n\",\n+                    group.getHostAddress(), port, id, nif.getDisplayName(), nif.getIndex());\n+            System.out.format(\"bound address before send: %s%n\", dc.getLocalAddress());\n@@ -77,0 +78,1 @@\n+            System.out.format(\"bound address after send: %s%n\", dc.getLocalAddress());\n@@ -100,0 +102,1 @@\n+            long elapsed = 0;\n@@ -102,0 +105,1 @@\n+                long start = System.nanoTime();\n@@ -103,0 +107,3 @@\n+                long waited = (System.nanoTime() - start) \/ 1000_000;\n+                elapsed += waited;\n+                buf.clear();\n@@ -108,1 +115,7 @@\n-                        throw new RuntimeException(\"Expected message not received\");\n+                        if (elapsed > 4800) {\n+                            throw new RuntimeException(\"Expected message not received\");\n+                        } else {\n+                            sel.selectedKeys().clear();\n+                            \/\/ We haven't waited long enough,\n+                            continue;\n+                        }\n@@ -124,2 +137,2 @@\n-                    System.out.format(\"Received message from %s (id=0x%x)\\n\",\n-                            sender, receivedId);\n+                    System.out.format(\"Received message from %s (id=0x%x, length=%s)\\n\",\n+                            sender, receivedId, bytes.length);\n@@ -143,1 +156,0 @@\n-                buf.rewind();\n@@ -158,0 +170,2 @@\n+        System.out.format(\"With interface=%s[%s]%n\\twith bound addresses:%n\\t%s%n\",\n+                nif.getDisplayName(), nif.getIndex(), nif.inetAddresses().toList());\n@@ -159,4 +173,4 @@\n-        DatagramChannel dc1 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n-        DatagramChannel dc2 = (family == UNSPEC) ?\n-            DatagramChannel.open() : DatagramChannel.open(family);\n+        try (DatagramChannel dc1 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family);\n+            DatagramChannel dc2 = (family == UNSPEC) ?\n+                DatagramChannel.open() : DatagramChannel.open(family)) {\n@@ -164,1 +178,0 @@\n-        try {\n@@ -187,1 +200,0 @@\n-            receiveDatagram(dc1, \"dc1\", false, id);\n@@ -189,4 +201,1 @@\n-\n-        } finally {\n-            dc1.close();\n-            dc2.close();\n+            receiveDatagram(dc1, \"dc1\", false, id);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Promiscuous.java","additions":26,"deletions":17,"binary":false,"changes":43,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -30,0 +30,6 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.NetworkConfiguration\n+ *        jdk.test.lib.Platform\n+ *        ReceiveISA\n+ * @run main\/othervm ReceiveISA\n+ *\n@@ -34,0 +40,3 @@\n+\n+import jdk.test.lib.Platform;\n+\n@@ -47,1 +56,5 @@\n-            dc3.socket().bind((SocketAddress) null); \/\/ bind server to any port\n+            InetAddress lh = InetAddress.getLocalHost();\n+            InetSocketAddress dest = Platform.isOSX()\n+                    ? new InetSocketAddress(lh, 0)\n+                    : null;\n+            dc3.socket().bind(dest); \/\/ bind server to any port\n@@ -50,1 +63,0 @@\n-            InetAddress lh = InetAddress.getLocalHost();\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/ReceiveISA.java","additions":15,"deletions":3,"binary":false,"changes":18,"status":"modified"},{"patch":"@@ -42,2 +42,2 @@\n-    static final int MAX_TRIES = 3;\n-    static final String GREETINGS_MESSAGE = \"Greetings from SelectWhenRefused!\";\n+    static final int MAX_TRIES = 10;\n+    static final String GREETINGS_MESSAGE = System.nanoTime() + \": Greetings from SelectWhenRefused!\";\n@@ -52,0 +52,1 @@\n+        System.err.println(\"Refuser is: \" + refuser);\n@@ -53,1 +54,29 @@\n-        DatagramChannel dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+        DatagramChannel dc = null;\n+        for (int i=0; i < MAX_TRIES; i++) {\n+            dc = DatagramChannel.open();\n+            try {\n+                dc.bind(new InetSocketAddress(0));\n+            } catch (Throwable t) {\n+                dc.close();\n+                throw t;\n+            }\n+\n+            \/\/ check the port assigned to dc\n+            if (((InetSocketAddress)dc.getLocalAddress()).getPort() != port) {\n+                \/\/ We got a good port. Do not retry\n+                break;\n+            }\n+\n+            \/\/ We bound to the same port that the refuser is using, This will not\n+            \/\/ work. Retry binding if possible.\n+            if (i < MAX_TRIES - 1) {\n+                \/\/ we will retry...\n+                System.err.format(\"Refuser port has been reused by dc: %s, retrying...%n\",\n+                        dc.getLocalAddress());\n+            } else {\n+                \/\/ that was the last attempt... Skip the test\n+                System.err.format(\"Skipping test: refuser port has been reused by dc: %s%n\",\n+                        dc.getLocalAddress());\n+                return;\n+            }\n+        }\n@@ -55,0 +84,1 @@\n+        assert dc != null;\n@@ -91,1 +121,1 @@\n-            System.out.println(\"Skipping test: refuser port has been reused: \" + e);\n+            System.err.println(\"Skipping test: refuser port has been reused: \" + e);\n@@ -122,1 +152,3 @@\n-            DatagramChannel.open().bind(refuser).close();\n+            try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                dc2.bind(refuser);\n+            }\n@@ -154,1 +186,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, dc.getLocalAddress(), sa);\n@@ -169,1 +201,3 @@\n-                DatagramChannel.open().bind(refuser).close();\n+                try (DatagramChannel dc2 = DatagramChannel.open()) {\n+                    dc2.bind(refuser);\n+                }\n@@ -172,1 +206,1 @@\n-                System.out.println(\"Got expected PortUnreachableException \" + pue);\n+                System.err.println(\"Got expected PortUnreachableException \" + pue);\n@@ -218,1 +252,1 @@\n-        System.out.format(\"Received %d keys%n\", selectedKeys.size());\n+        System.err.format(\"Received %d keys%n\", selectedKeys.size());\n@@ -222,1 +256,1 @@\n-                System.out.println(\"Invalid or unreadable key: \" + key);\n+                System.err.println(\"Invalid or unreadable key: \" + key);\n@@ -227,1 +261,1 @@\n-                System.out.println(\"Attempting to read datagram from key: \" + key);\n+                System.err.println(\"Attempting to read datagram from key: \" + key);\n@@ -237,1 +271,1 @@\n-                    System.out.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n+                    System.err.format(\"received %s at %s from %s%n\", message, datagramChannel.getLocalAddress(), sa);\n@@ -246,1 +280,1 @@\n-                System.out.println(\"Unable to read from datagram \" + io);\n+                System.err.println(\"Unable to read from datagram \" + io);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SelectWhenRefused.java","additions":47,"deletions":13,"binary":false,"changes":60,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -40,0 +40,1 @@\n+import org.testng.Assert;\n@@ -49,0 +50,1 @@\n+import java.net.SocketAddress;\n@@ -142,1 +144,3 @@\n-                sender.bind(null);\n+                sender.bind(new InetSocketAddress(host, 0));\n+                System.out.format(\"testSendReceiveMaxSize: sender: %s -> receiver: %s%n\",\n+                        sender.getLocalAddress(), receiver.getLocalAddress());\n@@ -153,1 +157,12 @@\n-                receiver.receive(receiveBuf);\n+                SocketAddress src;\n+                int count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n@@ -170,1 +185,11 @@\n-                receiver.receive(receiveBuf);\n+                count = 0;\n+                do {\n+                    receiveBuf.clear();\n+                    src = receiver.receive(receiveBuf);\n+                    if (sender.getLocalAddress().equals(src)) break;\n+                    System.out.println(\"step1: received unexpected datagram from: \" + src);\n+                    System.out.println(\"\\texpected: \" + sender.getLocalAddress());\n+                    if (++count > 10) {\n+                        throw new AssertionError(\"too many unexpected messages\");\n+                    }\n+                } while (true);\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/SendReceiveMaxSize.java","additions":29,"deletions":4,"binary":false,"changes":33,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -27,0 +27,3 @@\n+ * @library \/test\/lib\n+ * @build jdk.test.lib.Platform Sender\n+ * @run main Sender\n@@ -39,0 +42,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -49,2 +54,2 @@\n-        Server server = new Server();\n-        Client client = new Client(server.port());\n+        try (Server server = new Server()) {\n+            Client client = new Client(server.port());\n@@ -52,2 +57,2 @@\n-        Thread serverThread = new Thread(server);\n-        serverThread.start();\n+            Thread serverThread = new Thread(server);\n+            serverThread.start();\n@@ -55,2 +60,2 @@\n-        Thread clientThread = new Thread(client);\n-        clientThread.start();\n+            Thread clientThread = new Thread(client);\n+            clientThread.start();\n@@ -58,2 +63,2 @@\n-        serverThread.join();\n-        clientThread.join();\n+            serverThread.join();\n+            clientThread.join();\n@@ -61,2 +66,3 @@\n-        server.throwException();\n-        client.throwException();\n+            server.throwException();\n+            client.throwException();\n+        }\n@@ -67,1 +73,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -79,2 +85,1 @@\n-            try {\n-                DatagramChannel dc = DatagramChannel.open();\n+            try (DatagramChannel dc = DatagramChannel.open()) {\n@@ -87,0 +92,4 @@\n+                if (Platform.isOSX()) {\n+                    \/\/ avoid binding on wildcard on macOS\n+                    dc.bind(new InetSocketAddress(address, 0));\n+                }\n@@ -96,1 +105,1 @@\n-    public static class Server implements Runnable {\n+    public static class Server implements Runnable, AutoCloseable {\n@@ -98,1 +107,1 @@\n-        Exception e = null;\n+        volatile Exception e = null;\n@@ -101,1 +110,5 @@\n-            dc = DatagramChannel.open().bind(new InetSocketAddress(0));\n+            \/\/ avoid binding to wildcard address on macOS\n+            InetSocketAddress lo = Platform.isOSX()\n+                    ? new InetSocketAddress(InetAddress.getLocalHost(), 0)\n+                    : new InetSocketAddress(0);\n+            dc = DatagramChannel.open().bind(lo);\n@@ -152,0 +165,5 @@\n+\n+        @Override\n+        public void close() throws IOException {\n+            dc.close();\n+        }\n","filename":"test\/jdk\/java\/nio\/channels\/DatagramChannel\/Sender.java","additions":35,"deletions":17,"binary":false,"changes":52,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -39,11 +39,11 @@\n- * @run main\/othervm OCSPTimeout 1000 true\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=5\n- *      OCSPTimeout 1000 true\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1\n- *      OCSPTimeout 5000 false\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1s\n- *      OCSPTimeout 5000 false\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=1500ms\n- *      OCSPTimeout 5000 false\n- * @run main\/othervm -Dcom.sun.security.ocsp.readtimeout=4500ms\n- *      OCSPTimeout 1000 true\n+ * @run main\/othervm -Djava.security.debug=certpath OCSPTimeout 1000 true\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=5 OCSPTimeout 1000 true\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=1 OCSPTimeout 5000 false\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=1s OCSPTimeout 5000 false\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=1500ms OCSPTimeout 5000 false\n+ * @run main\/othervm -Djava.security.debug=certpath\n+ *      -Dcom.sun.security.ocsp.readtimeout=4500ms OCSPTimeout 1000 true\n@@ -85,1 +85,1 @@\n-    public static void main(String args[]) throws Exception {\n+    public static void main(String[] args) throws Exception {\n@@ -91,26 +91,3 @@\n-        if (args[0] != null) {\n-            ocspTimeout = Integer.parseInt(args[0]);\n-        }\n-        rootOcsp.setDelay(ocspTimeout);\n-\n-        expected = (args[1] != null && Boolean.parseBoolean(args[1]));\n-        log(\"Test case expects to \" + (expected ? \"pass\" : \"fail\"));\n-\n-        \/\/ validate chain\n-        CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n-        PKIXRevocationChecker prc =\n-                (PKIXRevocationChecker) cpv.getRevocationChecker();\n-        prc.setOptions(EnumSet.of(NO_FALLBACK, SOFT_FAIL));\n-        PKIXParameters params =\n-                new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n-        params.addCertPathChecker(prc);\n-        CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n-        CertPath cp = cf.generateCertPath(List.of(eeCert));\n-        cpv.validate(cp, params);\n-\n-        \/\/ unwrap soft fail exceptions and check for SocketTimeoutException\n-        List<CertPathValidatorException> softExc = prc.getSoftFailExceptions();\n-        if (expected) {\n-            if (softExc.size() > 0) {\n-                throw new RuntimeException(\"Expected to pass, found \" +\n-                        softExc.size() + \" soft fail exceptions\");\n+        try {\n+            if (args[0] != null) {\n+                ocspTimeout = Integer.parseInt(args[0]);\n@@ -118,12 +95,25 @@\n-        } else {\n-            \/\/ If we expect to fail the validation then there should be a\n-            \/\/ SocketTimeoutException\n-            boolean found = false;\n-            for (CertPathValidatorException softFail : softExc) {\n-                log(\"CPVE: \" + softFail);\n-                Throwable cause = softFail.getCause();\n-                log(\"Cause: \" + cause);\n-                while (cause != null) {\n-                    if (cause instanceof SocketTimeoutException) {\n-                        found = true;\n-                        break;\n+            rootOcsp.setDelay(ocspTimeout);\n+\n+            expected = (args[1] != null && Boolean.parseBoolean(args[1]));\n+            log(\"Test case expects to \" + (expected ? \"pass\" : \"fail\"));\n+\n+            \/\/ validate chain\n+            CertPathValidator cpv = CertPathValidator.getInstance(\"PKIX\");\n+            PKIXRevocationChecker prc =\n+                    (PKIXRevocationChecker) cpv.getRevocationChecker();\n+            prc.setOptions(EnumSet.of(NO_FALLBACK, SOFT_FAIL));\n+            PKIXParameters params =\n+                    new PKIXParameters(Set.of(new TrustAnchor(rootCert, null)));\n+            params.addCertPathChecker(prc);\n+            CertificateFactory cf = CertificateFactory.getInstance(\"X.509\");\n+            CertPath cp = cf.generateCertPath(List.of(eeCert));\n+            cpv.validate(cp, params);\n+\n+            \/\/ unwrap soft fail exceptions and check for SocketTimeoutException\n+            List<CertPathValidatorException> softExc = prc.getSoftFailExceptions();\n+            if (expected) {\n+                if (!softExc.isEmpty()) {\n+                    log(\"Expected to pass, found \" + softExc.size() +\n+                            \" soft fail exceptions\");\n+                    for (CertPathValidatorException cpve : softExc) {\n+                        log(\"Exception: \" + cpve);\n@@ -131,1 +121,2 @@\n-                    cause = cause.getCause();\n+                    throw new RuntimeException(\"Expected to pass, found \" +\n+                            softExc.size() + \" soft fail exceptions\");\n@@ -133,2 +124,18 @@\n-                if (found) {\n-                    break;\n+            } else {\n+                \/\/ If we expect to fail the validation then there should be a\n+                \/\/ SocketTimeoutException\n+                boolean found = false;\n+                for (CertPathValidatorException softFail : softExc) {\n+                    log(\"CPVE: \" + softFail);\n+                    Throwable cause = softFail.getCause();\n+                    log(\"Cause: \" + cause);\n+                    while (cause != null) {\n+                        if (cause instanceof SocketTimeoutException) {\n+                            found = true;\n+                            break;\n+                        }\n+                        cause = cause.getCause();\n+                    }\n+                    if (found) {\n+                        break;\n+                    }\n@@ -136,1 +143,0 @@\n-            }\n@@ -138,2 +144,3 @@\n-            if (!found) {\n-                throw new RuntimeException(\"SocketTimeoutException not thrown\");\n+                if (!found) {\n+                    throw new RuntimeException(\"SocketTimeoutException not thrown\");\n+                }\n@@ -141,0 +148,3 @@\n+        } finally {\n+            rootOcsp.stop();\n+            rootOcsp.shutdownNow();\n","filename":"test\/jdk\/java\/security\/cert\/CertPathValidator\/OCSP\/OCSPTimeout.java","additions":67,"deletions":57,"binary":false,"changes":124,"status":"modified"},{"patch":"@@ -575,2 +575,2 @@\n-            System.out.println(\"[\" + Thread.currentThread().getName() + \"]: \" +\n-                    message);\n+            System.out.println(\"[\" + Thread.currentThread().getName() + \"][\" +\n+                    System.currentTimeMillis() + \"]: \" + message);\n@@ -730,0 +730,1 @@\n+                    log(\"Delaying response for \" + delayMsec + \" milliseconds.\");\n@@ -911,0 +912,7 @@\n+            \/\/ Display the whole request\n+            StringBuilder sb = new StringBuilder(\"OCSP GET REQUEST\\n\");\n+            for (String hTok : headerTokens) {\n+                sb.append(hTok).append(\"\\n\");\n+            }\n+            log(sb.toString());\n+\n@@ -1003,0 +1011,4 @@\n+            \/\/ Display the DER encoding before parsing\n+            log(\"Local OCSP Request Constructor, parsing bytes:\\n\" +\n+                    dumpHexBytes(requestBytes));\n+\n","filename":"test\/jdk\/java\/security\/testlibrary\/SimpleOCSPServer.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -25,1 +25,1 @@\n- * @bug 8177552 8217721 8222756 8295372 8306116 8319990\n+ * @bug 8177552 8217721 8222756 8295372 8306116 8319990 8338690\n@@ -63,0 +63,3 @@\n+    private static final NumberFormat FORMAT_IT_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.ITALIAN, NumberFormat.Style.LONG);\n+\n@@ -92,0 +95,7 @@\n+\n+    private static final NumberFormat FORMAT_PL_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.of(\"pl\"), NumberFormat.Style.LONG);\n+\n+    private static final NumberFormat FORMAT_FR_LONG = NumberFormat\n+            .getCompactNumberInstance(Locale.FRENCH, NumberFormat.Style.LONG);\n+\n@@ -362,0 +372,6 @@\n+\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, 5_000, \"5 tysi\\u0119cy\"},\n+            {FORMAT_PL_LONG, 4_949, \"5 tysi\\u0119cy\"},\n+            {FORMAT_FR_LONG, 1_949, \"2 mille\"},\n+            {FORMAT_IT_LONG, 1_949, \"2 mila\"},\n@@ -469,0 +485,4 @@\n+                \/\/ 8338690\n+                {FORMAT_PL_LONG, \"5 tysi\\u0119cy\", 5_000L, Long.class},\n+                {FORMAT_FR_LONG, \"2 mille\", 2_000L, Long.class},\n+                {FORMAT_IT_LONG, \"2 mila\", 2_000L, Long.class},\n@@ -517,0 +537,4 @@\n+            \/\/ 8338690\n+            {FORMAT_PL_LONG, \"5 tysice\", 5L},\n+            {FORMAT_FR_LONG, \"2 millier\", 2L},\n+            {FORMAT_IT_LONG, \"2 mille\", 2L},\n","filename":"test\/jdk\/java\/text\/Format\/CompactNumberFormat\/TestCompactNumber.java","additions":25,"deletions":1,"binary":false,"changes":26,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2014, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -53,1 +53,1 @@\n- * @bug 8023367 8037106\n+ * @bug 8023367 8037106 8325679\n","filename":"test\/jdk\/java\/util\/List\/ListDefaults.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -23,1 +23,1 @@\n-\/**\n+\/*\n@@ -29,0 +29,1 @@\n+ * 8337603\n@@ -87,0 +88,1 @@\n+import java.util.stream.Stream;\n@@ -89,1 +91,4 @@\n-\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n@@ -737,0 +742,26 @@\n+    \/**\n+     * @bug 8337603\n+     *\/\n+    static Stream<Arguments> changedISOCodes() {\n+        var hebrew = \"\\u05e2\\u05d1\\u05e8\\u05d9\\u05ea\";\n+        var yiddish = \"\\u05d9\\u05d9\\u05b4\\u05d3\\u05d9\\u05e9\";\n+        var indonesian = \"Indonesia\";\n+\n+        return Stream.of(\n+            Arguments.of(\"he\", hebrew),\n+            Arguments.of(\"iw\", hebrew),\n+            Arguments.of(\"yi\", yiddish),\n+            Arguments.of(\"ji\", yiddish),\n+            Arguments.of(\"id\", indonesian),\n+            Arguments.of(\"in\", indonesian)\n+        );\n+    }\n+    @ParameterizedTest\n+    @MethodSource(\"changedISOCodes\")\n+    public void TestOldISOCodeLanguageName(String code, String expected) {\n+        var loc = Locale.of(code);\n+        assertEquals(expected,\n+            loc.getDisplayName(loc),\n+            \"java.locale.useOldISOCodes=\" + System.getProperty(\"java.locale.useOldISOCodes\"));\n+    }\n+\n","filename":"test\/jdk\/java\/util\/Locale\/LocaleTest.java","additions":33,"deletions":2,"binary":false,"changes":35,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 1998, 2011, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 1998, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,4 +25,6 @@\n-   @bug 4028605 4109069 4234207 4401122\n-   @summary Make sure ZipInputStream\/InflaterInputStream.available() will\n-            return 0 after EOF has reached and 1 otherwise.\n-   *\/\n+ * @bug 4028605 4109069 4234207 4401122 8339154\n+ * @summary Verify that ZipInputStream, InflaterInputStream, ZipFileInputStream,\n+ *          ZipFileInflaterInputStream.available() return values according\n+ *          to their specification or long-standing behavior\n+ * @run junit Available\n+ *\/\n@@ -30,0 +32,5 @@\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n@@ -32,0 +39,3 @@\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n@@ -34,0 +44,3 @@\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertThrows;\n+\n@@ -36,6 +49,2 @@\n-    public static void main(String[] args) throws Exception {\n-        \/\/ 4028605 4109069 4234207\n-        test1();\n-        \/\/ test 4401122\n-        test2();\n-    }\n+    \/\/ ZIP file produced in this test\n+    private final Path zip = Path.of(\"available.jar\");\n@@ -43,2 +52,9 @@\n-    private static void test1() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n+    \/**\n+     * Create the ZIP file used in this test, containing\n+     * one deflated and one stored entry.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @BeforeEach\n+    public void setup() throws IOException {\n+        byte[] contents = \"contents\".repeat(10).getBytes(StandardCharsets.UTF_8);\n@@ -46,7 +62,4 @@\n-        \/\/ test ZipInputStream\n-        try (FileInputStream fis = new FileInputStream(f);\n-             ZipInputStream z = new ZipInputStream(fis))\n-        {\n-            z.getNextEntry();\n-            tryAvail(z);\n-        }\n+        try (ZipOutputStream zo = new ZipOutputStream(Files.newOutputStream(zip))) {\n+            \/\/ First entry uses DEFLATE method\n+            zo.putNextEntry(new ZipEntry(\"deflated.txt\"));\n+            zo.write(contents);\n@@ -54,3 +67,9 @@\n-        \/\/ test InflaterInputStream\n-        try (ZipFile zfile = new ZipFile(f)) {\n-            tryAvail(zfile.getInputStream(zfile.getEntry(\"Available.java\")));\n+            \/\/ Second entry uses STORED method\n+            ZipEntry stored = new ZipEntry(\"stored.txt\");\n+            stored.setMethod(ZipEntry.STORED);\n+            stored.setSize(contents.length);\n+            CRC32 crc32 = new CRC32();\n+            crc32.update(contents);\n+            stored.setCrc(crc32.getValue());\n+            zo.putNextEntry(stored);\n+            zo.write(contents);\n@@ -60,3 +79,32 @@\n-    static void tryAvail(InputStream in) throws Exception {\n-        byte[] buf = new byte[1024];\n-        int n;\n+    \/**\n+     * Delete the ZIP file created by this test\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @AfterEach\n+    public void cleanup() throws IOException {\n+        Files.deleteIfExists(zip);\n+    }\n+\n+    \/**\n+     * Verify that ZipInputStream.available() returns 0 after EOF or\n+     * closeEntry, otherwise 1, as specified in the API description.\n+     * This tests 4028605 4109069 4234207\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @Test\n+    public void testZipInputStream() throws IOException {\n+        try (InputStream in = Files.newInputStream(zip)) {\n+            ZipInputStream z = new ZipInputStream(in);\n+            z.getNextEntry();\n+            assertEquals(1, z.available());\n+            z.read();\n+            assertEquals(1, z.available());\n+            z.transferTo(OutputStream.nullOutputStream());\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after EOF\");\n+\n+            z.close();\n+            assertThrows(IOException.class, () -> z.available(),\n+                    \"Expected an IOException when calling available on a closed stream\");\n+        }\n@@ -64,3 +112,6 @@\n-        while ((n = in.read(buf)) != -1);\n-        if (in.available() != 0) {\n-            throw new Exception(\"available should return 0 after EOF\");\n+        try (InputStream in = Files.newInputStream(zip);\n+             ZipInputStream z = new ZipInputStream(in)) {\n+            z.getNextEntry();\n+            z.closeEntry();\n+            assertEquals(0, z.available(),\n+                    \"ZipInputStream.available() should return 0 after closeEntry\");\n@@ -70,5 +121,15 @@\n-    \/\/ To reproduce 4401122\n-    private static void test2() throws Exception {\n-        File f = new File(System.getProperty(\"test.src\", \".\"), \"input.jar\");\n-        try (ZipFile zf = new ZipFile(f)) {\n-            InputStream in = zf.getInputStream(zf.getEntry(\"Available.java\"));\n+    \/**\n+     * Verify that ZipFileInputStream|ZipFileInflaterInputStream.available()\n+     * return the number of remaining uncompressed bytes.\n+     *\n+     * This verifies unspecified, but long-standing behavior. See 4401122.\n+     *\n+     * @throws IOException if an unexpected error occurs\n+     *\/\n+    @ParameterizedTest\n+    @ValueSource(strings = { \"stored.txt\", \"deflated.txt\" })\n+    public void testZipFileStreamsRemainingBytes(String entryName) throws IOException {\n+        try (ZipFile zfile = new ZipFile(zip.toFile())) {\n+            ZipEntry entry = zfile.getEntry(entryName);\n+            \/\/ Could be ZipFileInputStream or ZipFileInflaterInputStream\n+            InputStream in = zfile.getInputStream(entry);\n@@ -77,4 +138,7 @@\n-            in.read();\n-            if (in.available() != initialAvailable - 1)\n-                throw new RuntimeException(\"Available not decremented.\");\n-            for(int j=0; j<initialAvailable-1; j++)\n+\n+            \/\/ Initally, the number of remaining uncompressed bytes is the entry size\n+            assertEquals(entry.getSize(), initialAvailable);\n+\n+            \/\/ Read all bytes one by one\n+            for (int i = initialAvailable; i > 0; i--) {\n+                \/\/ Reading a single byte should decrement available by 1\n@@ -82,2 +146,7 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+                assertEquals(i - 1, in.available(), \"Available not decremented\");\n+            }\n+\n+            \/\/ No remaining uncompressed bytes\n+            assertEquals(0, in.available());\n+\n+            \/\/ available() should still return 0 after close\n@@ -85,2 +154,1 @@\n-            if (in.available() != 0)\n-                throw new RuntimeException();\n+            assertEquals(0, in.available());\n@@ -89,1 +157,0 @@\n-\n","filename":"test\/jdk\/java\/util\/zip\/Available.java","additions":110,"deletions":43,"binary":false,"changes":153,"status":"modified"},{"patch":"@@ -1,116 +0,0 @@\n-\/*\n- * Copyright (c) 2006, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/**\n- * @test\n- * @bug 4615343\n- * @summary Check that ZipError is thrown instead of InternalError when\n- * iterating entries of an invalid zip file\n- *\/\n-\n-import java.io.*;\n-import java.util.*;\n-import java.util.zip.*;\n-\n-public class TestZipError {\n-    public static void realMain(String[] args) throws Throwable {\n-        \/\/ Causing a ZipError is hard, especially on non-Windows systems.  See\n-        \/\/ comments below.\n-        String osName = System.getProperty(\"os.name\");\n-        if (!System.getProperty(\"os.name\").startsWith(\"Windows\")) {\n-            return;\n-        }\n-\n-        String fileName = \"error4615343.zip\";\n-        File f = new File(fileName);\n-        f.delete();\n-        ZipOutputStream zos;\n-        ZipEntry ze;\n-\n-        \/\/ Create a zip file with two entries.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"one\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hello\".getBytes());\n-        zos.closeEntry();\n-        ze = new ZipEntry(\"two\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"world\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Open the ZipFile.  This will read the zip file's central\n-        \/\/ directory into in-memory data structures.\n-        ZipFile zf = new ZipFile(fileName);\n-\n-        \/\/ Delete the file; of course this does not change the in-memory data\n-        \/\/ structures that represent the central directory!\n-        f.delete();\n-\n-        \/\/ Re-create zip file, with different entries than earlier.  However,\n-        \/\/ recall that we have in-memory information about the central\n-        \/\/ directory of the file at its previous state.\n-        zos = new ZipOutputStream(new FileOutputStream(f));\n-        ze = new ZipEntry(\"uno\");\n-        zos.putNextEntry(ze);\n-        zos.write(\"hola\".getBytes());\n-        zos.closeEntry();\n-        zos.close();\n-\n-        \/\/ Iterate zip file's contents.  On Windows, this will result in a\n-        \/\/ ZipError, because the data in the file differs from the in-memory\n-        \/\/ central directory information we read earlier.\n-        Enumeration<? extends ZipEntry> entries = zf.entries();\n-        try {\n-            while (entries.hasMoreElements()) {\n-                ze = entries.nextElement();\n-                zf.getInputStream(ze).readAllBytes();\n-            }\n-            fail(\"Did not get expected exception\");\n-        } catch (ZipException e) {\n-            pass();\n-        } catch (InternalError e) {\n-            fail(\"Caught InternalError instead of expected ZipError\");\n-        } catch (Throwable t) {\n-            unexpected(t);\n-        } finally {\n-            zf.close();\n-            f.delete();\n-        }\n-    }\n-\n-    \/\/--------------------- Infrastructure ---------------------------\n-    static volatile int passed = 0, failed = 0;\n-    static void pass() {passed++;}\n-    static void fail() {failed++; Thread.dumpStack();}\n-    static void fail(String msg) {System.out.println(msg); fail();}\n-    static void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    static void check(boolean cond) {if (cond) pass(); else fail();}\n-    static void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        try {realMain(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.println(\"\\nPassed = \" + passed + \" failed = \" + failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n-}\n","filename":"test\/jdk\/java\/util\/zip\/TestZipError.java","additions":0,"deletions":116,"binary":false,"changes":116,"status":"deleted"},{"patch":"@@ -0,0 +1,182 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337681\n+ * @summary Test that raster use optimization does not cause any regressions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import java.awt.geom.AffineTransform;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.RenderedImage;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import javax.imageio.IIOImage;\n+import javax.imageio.ImageIO;\n+import javax.imageio.ImageReader;\n+import javax.imageio.ImageWriteParam;\n+import javax.imageio.ImageWriter;\n+import javax.imageio.stream.ImageInputStream;\n+import javax.imageio.stream.ImageOutputStream;\n+import javax.imageio.stream.MemoryCacheImageOutputStream;\n+\n+public class RasterReuseWriteTest {\n+\n+    public static void main(String[] args) throws Exception {\n+        test(BufferedImage.TYPE_INT_RGB);\n+        test(BufferedImage.TYPE_INT_ARGB);\n+        test(BufferedImage.TYPE_INT_ARGB_PRE);\n+        test(BufferedImage.TYPE_4BYTE_ABGR);\n+        test(BufferedImage.TYPE_4BYTE_ABGR_PRE);\n+    }\n+\n+    private static void test(int type) throws Exception {\n+\n+        \/\/ swaps blue and red\n+        int bands = (type == BufferedImage.TYPE_INT_RGB ? 3 : 4);\n+        int[] sourceBands = bands == 3 ? new int[] { 2, 1, 0 } :\n+                                         new int[] { 2, 1, 0, 3 };\n+\n+        \/\/ test writing a BufferedImage without source bands\n+        BufferedImage img1 = createImage(256, 256, type);\n+        byte[] bytes1 = writePng(img1, null);\n+        BufferedImage img2 = ImageIO.read(new ByteArrayInputStream(bytes1));\n+        compare(img1, img2, false);\n+\n+        \/\/ test writing a BufferedImage with source bands\n+        BufferedImage img3 = createImage(256, 256, type);\n+        byte[] bytes3 = writePng(img3, sourceBands);\n+        BufferedImage img4 = ImageIO.read(new ByteArrayInputStream(bytes3));\n+        compare(img3, img4, true);\n+\n+        \/\/ test writing a non-BufferedImage with source bands and one tile\n+        RenderedImage img5 = toTiledImage(img1, 256);\n+        byte[] bytes5 = writePng(img5, sourceBands);\n+        BufferedImage img6 = ImageIO.read(new ByteArrayInputStream(bytes5));\n+        compare(img5, img6, true);\n+\n+        \/\/ test writing a non-BufferedImage with source bands and multiple tiles\n+        RenderedImage img7 = toTiledImage(img1, 128);\n+        byte[] bytes7 = writePng(img7, sourceBands);\n+        BufferedImage img8 = ImageIO.read(new ByteArrayInputStream(bytes7));\n+        compare(img7, img8, true);\n+    }\n+\n+    private static BufferedImage createImage(int w, int h, int type) throws Exception {\n+        BufferedImage img = new BufferedImage(w, h, type);\n+        Graphics2D g2d = img.createGraphics();\n+        g2d.setColor(Color.WHITE);\n+        g2d.fillRect(0, 0, w, h);\n+        g2d.setColor(Color.GREEN);\n+        g2d.drawRect(20, 20, 100, 50);\n+        g2d.setColor(Color.RED);\n+        g2d.drawRect(80, 10, 100, 40);\n+        g2d.setColor(Color.BLUE);\n+        g2d.fillRect(40, 60, 120, 30);\n+        g2d.dispose();\n+        return img;\n+    }\n+\n+    private static byte[] writePng(RenderedImage img, int[] sourceBands) throws Exception {\n+        ImageWriter writer = ImageIO.getImageWritersByFormatName(\"png\").next();\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        param.setSourceBands(sourceBands);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ImageOutputStream stream = new MemoryCacheImageOutputStream(baos);\n+        writer.setOutput(stream);\n+        writer.write(null, new IIOImage(img, null, null), param);\n+        writer.dispose();\n+        stream.flush();\n+        return baos.toByteArray();\n+    }\n+\n+    private static void compare(RenderedImage img1, RenderedImage img2, boolean blueAndRedSwapped) {\n+        int[] pixels1 = getRgbPixels(img1);\n+        int[] pixels2 = getRgbPixels(img2);\n+        for (int i = 0; i < pixels1.length; i++) {\n+            int expected;\n+            if (blueAndRedSwapped && pixels1[i] == 0xFFFF0000) {\n+                expected = 0xFF0000FF; \/\/ red -> blue\n+            } else if (blueAndRedSwapped && pixels1[i] == 0xFF0000FF) {\n+                expected = 0xFFFF0000; \/\/ blue -> red\n+            } else {\n+                expected = pixels1[i]; \/\/ no change\n+            }\n+            int actual = pixels2[i];\n+            if (actual != expected) {\n+                throw new RuntimeException(\"Pixel \" + i + \": expected \" +\n+                    Integer.toHexString(expected) + \", but got \" +\n+                    Integer.toHexString(actual));\n+            }\n+        }\n+    }\n+\n+    private static int[] getRgbPixels(RenderedImage img) {\n+        int w = img.getWidth();\n+        int h = img.getHeight();\n+        if (img instanceof BufferedImage bi) {\n+            return bi.getRGB(0, 0, w, h, null, 0, w);\n+        } else {\n+            BufferedImage bi = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);\n+            Graphics2D g2d = bi.createGraphics();\n+            g2d.drawRenderedImage(img, new AffineTransform());\n+            g2d.dispose();\n+            return bi.getRGB(0, 0, w, h, null, 0, w);\n+        }\n+    }\n+\n+    private static RenderedImage toTiledImage(BufferedImage img, int tileSize) throws Exception {\n+\n+        \/\/ write to TIFF\n+        ImageWriter writer = ImageIO.getImageWritersByFormatName(\"tiff\").next();\n+        ImageWriteParam param = writer.getDefaultWriteParam();\n+        param.setTilingMode(ImageWriteParam.MODE_EXPLICIT);\n+        param.setTiling(tileSize, tileSize, 0, 0);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        ImageOutputStream stream = new MemoryCacheImageOutputStream(baos);\n+        writer.setOutput(stream);\n+        writer.write(null, new IIOImage(img, null, null), param);\n+        writer.dispose();\n+        stream.flush();\n+        byte[] bytes = baos.toByteArray();\n+\n+        \/\/ read from TIFF\n+        ImageReader reader = ImageIO.getImageReadersByFormatName(\"tiff\").next();\n+        ImageInputStream input = ImageIO.createImageInputStream(new ByteArrayInputStream(bytes));\n+        reader.setInput(input);\n+        RenderedImage ri = reader.readAsRenderedImage(0, null);\n+        if (ri instanceof BufferedImage) {\n+            throw new RuntimeException(\"Unexpected BufferedImage\");\n+        }\n+        int tw = ri.getTileWidth();\n+        int th = ri.getTileHeight();\n+        if (tw != tileSize || th != tileSize) {\n+            throw new RuntimeException(\"Expected tile size \" + tileSize +\n+                \", but found \" + tw + \"x\" + th);\n+        }\n+        return ri;\n+    }\n+}\n","filename":"test\/jdk\/javax\/imageio\/plugins\/png\/RasterReuseWriteTest.java","additions":182,"deletions":0,"binary":false,"changes":182,"status":"added"},{"patch":"@@ -42,1 +42,2 @@\n-        TLSBase.Client client1 = new TLSBase.Client(true, false);\n+        TLSBase.Client client = new TLSBase.Client(true, false);\n+        client.connect();\n@@ -44,2 +45,3 @@\n-        server.getSession(client1).getSessionContext();\n-        server.done();\n+        \/\/ Close must be called to gather all the exceptions thrown\n+        client.close();\n+        server.close();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CertMsgCheck.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+        client1.connect();\n@@ -69,0 +70,1 @@\n+        client2.connect();\n@@ -76,1 +78,0 @@\n-        server.done();\n","filename":"test\/jdk\/javax\/net\/ssl\/SSLSession\/CheckSessionContext.java","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,2 @@\n+import java.net.InetAddress;\n+import java.nio.file.Files;\n@@ -55,0 +57,1 @@\n+        private InetAddress listenInterface = InetAddress.getLoopbackAddress();\n@@ -60,0 +63,9 @@\n+        public InetAddress getListenInterface() {\n+            return listenInterface;\n+        }\n+\n+        public Builder setListenInterface(InetAddress listenInterface) {\n+            this.listenInterface = listenInterface;\n+            return this;\n+        }\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/AbstractServer.java","additions":13,"deletions":1,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -25,0 +25,1 @@\n+import java.net.InetAddress;\n@@ -56,1 +57,2 @@\n-                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort());\n+                = (SSLServerSocket) serverFactory.createServerSocket(builder.getPort(),\n+                    0, builder.getListenInterface());\n","filename":"test\/jdk\/javax\/net\/ssl\/TLSCommon\/interop\/JdkServer.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -28,0 +28,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -32,1 +33,0 @@\n-import java.util.Arrays;\n@@ -35,0 +35,3 @@\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n@@ -42,1 +45,1 @@\n- * Server.done() must be called or the server will never exit and hang the test.\n+ * Server.close() must be called so the server will exit and end threading.\n@@ -55,1 +58,1 @@\n-    static String pathToStores = \"..\/etc\";\n+    static String pathToStores = \"javax\/net\/ssl\/etc\";\n@@ -60,0 +63,3 @@\n+    static final String TESTROOT =\n+        System.getProperty(\"test.root\", \"..\/..\/..\/..\");\n+\n@@ -64,1 +70,1 @@\n-    String name;\n+    public String name;\n@@ -67,6 +73,4 @@\n-        String keyFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + keyStoreFile;\n-        String trustFilename =\n-            System.getProperty(\"test.src\", \".\/\") + \"\/\" + pathToStores +\n-                \"\/\" + trustStoreFile;\n+\n+        String keyFilename = TESTROOT +  \"\/\" + pathToStores + \"\/\" + keyStoreFile;\n+        String trustFilename = TESTROOT + \"\/\" + pathToStores + \"\/\" +\n+            trustStoreFile;\n@@ -81,5 +85,4 @@\n-        BufferedReader reader = new BufferedReader(\n-            new InputStreamReader(sock.getInputStream()));\n-        String s = reader.readLine();\n-        System.err.println(\"(read) \" + name + \": \" + s);\n-        return s.getBytes();\n+        BufferedInputStream is = new BufferedInputStream(sock.getInputStream());\n+        byte[] b = is.readNBytes(5);\n+        System.err.println(\"(read) \" + Thread.currentThread().getName() + \": \" + new String(b));\n+        return b;\n@@ -90,5 +93,2 @@\n-        PrintWriter out = new PrintWriter(\n-            new OutputStreamWriter(sock.getOutputStream()));\n-        out.println(new String(data));\n-        out.flush();\n-        System.err.println(\"(write)\" + name + \": \" + new String(data));\n+        sock.getOutputStream().write(data);\n+        System.err.println(\"(write)\" + Thread.currentThread().getName() + \": \" + new String(data));\n@@ -100,1 +100,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -116,1 +116,1 @@\n-            fis = new FileInputStream(System.getProperty(\"test.src\", \".\/\") +\n+            fis = new FileInputStream(System.getProperty(\"test.root\", \".\/\") +\n@@ -153,0 +153,5 @@\n+        ExecutorService threadPool = Executors.newFixedThreadPool(1,\n+            r -> {\n+                Thread t = Executors.defaultThreadFactory().newThread(r);\n+                return t;\n+            });\n@@ -163,0 +168,1 @@\n+                ssock.setReuseAddress(true);\n@@ -165,0 +171,1 @@\n+                System.out.println(\"Server Port: \" + serverPort);\n@@ -174,11 +181,2 @@\n-                        System.err.println(\"Server ready on port \" +\n-                            serverPort);\n-                        SSLSocket c = (SSLSocket)ssock.accept();\n-                        clientMap.put(c.getPort(), c);\n-                        try {\n-                            write(c, read(c));\n-                        } catch (Exception e) {\n-                            System.out.println(\"Caught \" + e.getMessage());\n-                            e.printStackTrace();\n-                            exceptionList.add(e);\n-                        }\n+                        SSLSocket sock = (SSLSocket)ssock.accept();\n+                        threadPool.submit(new ServerThread(sock));\n@@ -189,0 +187,2 @@\n+                } finally {\n+                    threadPool.close();\n@@ -194,3 +194,2 @@\n-        Server() {\n-            this(new ServerBuilder());\n-        }\n+        class ServerThread extends Thread {\n+            SSLSocket sock;\n@@ -198,42 +197,4 @@\n-        \/**\n-         * @param km - true for an empty key manager\n-         * @param tm - true for an empty trust manager\n-         *\/\n-        Server(boolean km, boolean tm) {\n-            super();\n-            name = \"server\";\n-            try {\n-                sslContext = SSLContext.getInstance(\"TLS\");\n-                sslContext.init(TLSBase.getKeyManager(km),\n-                    TLSBase.getTrustManager(tm), null);\n-                fac = sslContext.getServerSocketFactory();\n-                ssock = (SSLServerSocket) fac.createServerSocket(0);\n-                ssock.setNeedClientAuth(true);\n-                serverPort = ssock.getLocalPort();\n-            } catch (Exception e) {\n-                System.err.println(\"Failure during server initialization\");\n-                e.printStackTrace();\n-            }\n-\n-                \/\/ Thread to allow multiple clients to connect\n-                t = new Thread(() -> {\n-                    try {\n-                        while (true) {\n-                            System.err.println(\"Server ready on port \" +\n-                                serverPort);\n-                            SSLSocket c = (SSLSocket)ssock.accept();\n-                            clientMap.put(c.getPort(), c);\n-                            try {\n-                                write(c, read(c));\n-                            } catch (Exception e) {\n-                                System.out.println(\"Caught \" + e.getMessage());\n-                                e.printStackTrace();\n-                                exceptionList.add(e);\n-                            }\n-                        }\n-                    } catch (Exception ex) {\n-                        System.err.println(\"Server Down\");\n-                        ex.printStackTrace();\n-                    }\n-                });\n-                t.start();\n+            ServerThread(SSLSocket s) {\n+                this.sock = s;\n+                System.err.println(\"ServerThread(\"+sock.getPort()+\")\");\n+                clientMap.put(sock.getPort(), sock);\n@@ -242,17 +203,8 @@\n-        \/\/ Exit test to quit the test.  This must be called at the end of the\n-        \/\/ test or the test will never end.\n-        void done() {\n-            try {\n-                t.join(5000);\n-                ssock.close();\n-            } catch (Exception e) {\n-                System.err.println(e.getMessage());\n-                e.printStackTrace();\n-            }\n-        }\n-\n-        \/\/ Read from the client\n-        byte[] read(Client client) throws Exception {\n-            SSLSocket s = clientMap.get(Integer.valueOf(client.getPort()));\n-            if (s == null) {\n-                System.err.println(\"No socket found, port \" + client.getPort());\n+            public void run() {\n+                try {\n+                    write(sock, read(sock));\n+                } catch (Exception e) {\n+                    System.out.println(\"Caught \" + e.getMessage());\n+                    e.printStackTrace();\n+                    exceptionList.add(e);\n+                }\n@@ -260,1 +212,0 @@\n-            return read(s);\n@@ -263,3 +214,2 @@\n-        \/\/ Write to the client\n-        void write(Client client, byte[] data) throws Exception {\n-            write(clientMap.get(client.getPort()), data);\n+        Server() {\n+            this(new ServerBuilder());\n@@ -268,5 +218,7 @@\n-        \/\/ Server writes to the client, then reads from the client.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Client client, String s) throws Exception{\n-            write(client, s.getBytes());\n-            return (Arrays.compare(s.getBytes(), client.read()) == 0);\n+        public SSLSession getSession(Client client) throws Exception {\n+            System.err.println(\"getSession(\"+client.getPort()+\")\");\n+            SSLSocket clientSocket = clientMap.get(client.getPort());\n+            if (clientSocket == null) {\n+                throw new Exception(\"Server can't find client socket\");\n+            }\n+            return clientSocket.getSession();\n@@ -275,4 +227,7 @@\n-        \/\/ Get the SSLSession from the server side socket\n-        SSLSession getSession(Client c) {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            return s.getSession();\n+        void close(Client client) {\n+            try {\n+                System.err.println(\"close(\"+client.getPort()+\")\");\n+                clientMap.remove(client.getPort()).close();\n+            } catch (Exception e) {\n+                ;\n+            }\n@@ -280,5 +235,7 @@\n-\n-        \/\/ Close client socket\n-        void close(Client c) throws IOException {\n-            SSLSocket s = clientMap.get(Integer.valueOf(c.getPort()));\n-            s.close();\n+        void close() throws InterruptedException {\n+            clientMap.values().stream().forEach(s -> {\n+                try {\n+                    s.close();\n+                } catch (IOException e) {}\n+            });\n+            threadPool.awaitTermination(500, TimeUnit.MILLISECONDS);\n@@ -315,1 +272,1 @@\n-     * Client side will establish a connection from the constructor and wait.\n+     * Client side will establish a SSLContext instance.\n@@ -319,1 +276,1 @@\n-        SSLSocket sock;\n+        public SSLSocket socket;\n@@ -333,5 +290,0 @@\n-            connect();\n-        }\n-\n-        \/\/ Connect to server.  Maybe runnable in the future\n-        public SSLSocket connect() {\n@@ -341,7 +293,1 @@\n-                sock = (SSLSocket)sslContext.getSocketFactory().createSocket();\n-                sock.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n-                System.err.println(\"Client connected using port \" +\n-                        sock.getLocalPort());\n-                name = \"client(\" + sock.toString() + \")\";\n-                write(\"Hello\");\n-                read();\n+                socket = createSocket();\n@@ -351,1 +297,0 @@\n-            return sock;\n@@ -354,3 +299,3 @@\n-        \/\/ Read from the client socket\n-        byte[] read() throws Exception {\n-            return read(sock);\n+        Client(Client cl) {\n+            sslContext = cl.sslContext;\n+            socket = createSocket();\n@@ -359,3 +304,7 @@\n-        \/\/ Write to the client socket\n-        void write(byte[] data) throws Exception {\n-            write(sock, data);\n+        public SSLSocket createSocket() {\n+            try {\n+                return (SSLSocket) sslContext.getSocketFactory().createSocket();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return null;\n@@ -363,2 +312,12 @@\n-        void write(String s) throws Exception {\n-            write(sock, s.getBytes());\n+\n+        public SSLSocket connect() {\n+            try {\n+                socket.connect(new InetSocketAddress(InetAddress.getLoopbackAddress(), serverPort));\n+                System.err.println(\"Client (\" + Thread.currentThread().getName() + \") connected using port \" +\n+                    socket.getLocalPort() + \" to \" + socket.getPort());\n+                writeRead();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+                return null;\n+            }\n+            return socket;\n@@ -367,5 +326,9 @@\n-        \/\/ Client writes to the server, then reads from the server.\n-        \/\/ Return true if the read & write data match, false if not.\n-        boolean writeRead(Server server, String s) throws Exception {\n-            write(s.getBytes());\n-            return (Arrays.compare(s.getBytes(), server.read(this)) == 0);\n+        public SSLSession getSession() {\n+            return socket.getSession();\n+        }\n+        public void close() {\n+            try {\n+                socket.close();\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n@@ -374,3 +337,2 @@\n-        \/\/ Get port from the socket\n-        int getPort() {\n-            return sock.getLocalPort();\n+        public int getPort() {\n+            return socket.getLocalPort();\n@@ -379,3 +341,8 @@\n-        \/\/ Close socket\n-        void close() throws IOException {\n-            sock.close();\n+        private SSLSocket writeRead() {\n+            try {\n+                write(socket, \"Hello\".getBytes(StandardCharsets.ISO_8859_1));\n+                read(socket);\n+            } catch (Exception ex) {\n+                ex.printStackTrace();\n+            }\n+            return socket;\n@@ -383,0 +350,1 @@\n+\n","filename":"test\/jdk\/javax\/net\/ssl\/templates\/TLSBase.java","additions":115,"deletions":147,"binary":false,"changes":262,"status":"modified"},{"patch":"@@ -0,0 +1,352 @@\n+\/*\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Color;\n+import java.awt.Dimension;\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.FocusAdapter;\n+import java.awt.event.FocusEvent;\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.Raster;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+import javax.imageio.ImageIO;\n+import javax.swing.JButton;\n+import javax.swing.JFrame;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8338103\n+ * @key headful\n+ * @summary Verifies that the OpenGL pipeline does not create artifacts\n+ * with swing components after window is zoomed to maximum size and then\n+ * resized back to normal. The test case simulates this operation using\n+ * a JButton. A file image of the component will be saved before and after\n+ * the window resize if the test fails. The test passes if both the button\n+ * images are the same.\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=true -Dsun.java2d.opengl.fbobject=true SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.opengl=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"windows\")\n+ * @run main\/othervm -Dsun.java2d.d3d=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.d3d=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"linux\")\n+ * @run main\/othervm -Dsun.java2d.xrender=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.xrender=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+\/*\n+ * @test\n+ * @key headful\n+ * @requires (os.family == \"mac\")\n+ * @run main\/othervm -Dsun.java2d.metal=false SwingButtonResizeTestWithOpenGL\n+ * @run main\/othervm -Dsun.java2d.metal=true SwingButtonResizeTestWithOpenGL\n+ *\/\n+public class SwingButtonResizeTestWithOpenGL {\n+    private static Robot robot;\n+    private static CountDownLatch focusGainedLatch;\n+    private JFrame frame;\n+    private JButton button;\n+\n+    public SwingButtonResizeTestWithOpenGL() {\n+\n+        try {\n+            SwingUtilities.invokeAndWait(() -> createGUI());\n+        } catch (Exception e) {\n+            throw new RuntimeException(\"Problems creating GUI\");\n+        }\n+    }\n+\n+    private void createGUI() {\n+        frame = new JFrame(\"SwingButtonResizeTestWithOpenGL\");\n+        button = new JButton(\"Button A\");\n+        frame.setLocation(200, 200);\n+        frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);\n+        button.setPreferredSize(new Dimension(300, 300));\n+        button.setFocusPainted(false);\n+        button.addFocusListener(new FocusAdapter() {\n+            public void focusGained(FocusEvent fe) {\n+                focusGainedLatch.countDown();\n+            }\n+        });\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.getContentPane().add(button);\n+        frame.pack();\n+        frame.setVisible(true);\n+        frame.toFront();\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        focusGainedLatch = new CountDownLatch(1);\n+        SwingButtonResizeTestWithOpenGL test =\n+                new SwingButtonResizeTestWithOpenGL();\n+        test.runTest();\n+    }\n+\n+    public void runTest() throws Exception {\n+        BufferedImage bimage1;\n+        BufferedImage bimage2;\n+\n+        try {\n+            robot = new Robot();\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+            if (focusGainedLatch.await(3, TimeUnit.SECONDS)) {\n+                System.out.println(\"Button focus gained...\");\n+            } else {\n+                System.out.println(\"Button focus not gained...\");\n+                throw new RuntimeException(\n+                        \"Can't gain focus on button even after waiting \" +\n+                        \"too long..\");\n+            }\n+\n+            System.out.println(\"Getting initial button image..image1\");\n+            bimage1 = getButtonImage();\n+\n+            \/\/ some platforms may not support maximize frame\n+            if (frame.getToolkit().isFrameStateSupported(\n+                    JFrame.MAXIMIZED_BOTH)) {\n+                \/\/ maximize frame from normal size\n+                frame.setExtendedState(JFrame.MAXIMIZED_BOTH);\n+                System.out.println(\"Frame is maximized\");\n+                robot.waitForIdle();\n+                robot.delay(100);\n+\n+                if (frame.getToolkit().isFrameStateSupported(JFrame.NORMAL)) {\n+                    System.out.println(\"Frame is back to normal\");\n+                    \/\/ resize from maximum size to normal\n+                    frame.setExtendedState(JFrame.NORMAL);\n+                    robot.waitForIdle();\n+                    robot.delay(100);\n+                    \/\/ capture image of JButton after resize\n+                    System.out.println(\n+                            \"Getting image of JButton after resize..image2\");\n+                    bimage2 = getButtonImage();\n+\n+                    \/\/ compare button images from before and after frame resize\n+                    DiffImage di = new DiffImage(bimage1.getWidth(),\n+                                                 bimage1.getHeight());\n+                    System.out.println(\n+                            \"Taking the diff of two images, image1 and image2\");\n+                    if (!di.compare(bimage1, bimage2)) {\n+                        throw new RuntimeException(\n+                                \"Button renderings are different after window \"\n+                                + \"resize, num of Diff Pixels=\"\n+                                + di.getNumDiffPixels());\n+                    } else {\n+                        System.out.println(\"Test passed...\");\n+                    }\n+\n+                } else {\n+                    System.out.println(\n+                            \"Test skipped: JFrame.NORMAL resize is \" +\n+                            \"not supported\");\n+                }\n+\n+            } else {\n+                System.out.println(\n+                        \"Test skipped: JFrame.MAXIMIZED_BOTH resize is \" +\n+                        \"not supported\");\n+            }\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> disposeFrame());\n+        }\n+    }\n+\n+    \/\/ Capture button rendering as a BufferedImage\n+    private BufferedImage getButtonImage() {\n+        try {\n+            robot.waitForIdle();\n+            robot.delay(500);\n+\n+            AtomicReference<Point> buttonLocRef = new AtomicReference<>();\n+            SwingUtilities.invokeAndWait(\n+                    () -> buttonLocRef.set(button.getLocationOnScreen()));\n+            Point buttonLoc = buttonLocRef.get();\n+            System.out.println(\"Button loc: \" + buttonLoc);\n+            return robot.createScreenCapture(\n+                    new Rectangle(buttonLoc.x, buttonLoc.y, button.getWidth(),\n+                                  button.getHeight()));\n+        } catch (Exception e) {\n+            throw new RuntimeException(\n+                    \"Problems capturing button image from Robot\", e);\n+        }\n+    }\n+\n+    private void disposeFrame() {\n+        if(frame != null) {\n+            frame.dispose();\n+        }\n+    }\n+\n+    \/\/ Save BufferedImage to PNG file\n+    private void saveButtonImage(BufferedImage image, File file) {\n+        if (image != null) {\n+            try {\n+                System.out.println(\n+                        \"Saving button image to \" + file.getAbsolutePath());\n+                ImageIO.write(image, \"PNG\", file);\n+            } catch (Exception e) {\n+                throw new RuntimeException(\"Could not write image file\");\n+            }\n+        } else {\n+            throw new RuntimeException(\"BufferedImage was set to null\");\n+        }\n+    }\n+\n+    private class DiffImage extends BufferedImage {\n+\n+        public boolean diff = false;\n+        public int nDiff = -1;\n+\n+        Color bgColor;\n+\n+        int threshold = 0;\n+\n+        public DiffImage(int w, int h) {\n+            super(w, h, BufferedImage.TYPE_INT_ARGB);\n+            bgColor = Color.LIGHT_GRAY;\n+        }\n+\n+        public int getNumDiffPixels() {\n+            return nDiff;\n+        }\n+\n+        public boolean compare(BufferedImage img1, BufferedImage img2)\n+                throws IOException {\n+\n+            int minx1 = img1.getMinX();\n+            int minx2 = img2.getMinX();\n+            int miny1 = img1.getMinY();\n+            int miny2 = img2.getMinY();\n+\n+            int w1 = img1.getWidth();\n+            int w2 = img2.getWidth();\n+            int h1 = img1.getHeight();\n+            int h2 = img2.getHeight();\n+\n+            if ((minx1 != minx2) || (miny1 != miny2) || (w1 != w2)\n+                || (h1 != h2)) {\n+                \/\/ image sizes are different\n+                throw new RuntimeException(\n+                        \"img1: <\" + minx1 + \",\" + miny1 + \",\" + w1 + \"x\" + h1\n+                        + \">\" + \" img2: \" + minx2 + \",\" + miny2 + \",\" + w2 + \"x\"\n+                        + h2 + \">\" + \" are different sizes\");\n+            }\n+            \/\/ Get the actual data behind the images\n+            Raster ras1 = img1.getData();\n+            Raster ras2 = img2.getData();\n+\n+            ColorModel cm1 = img1.getColorModel();\n+            ColorModel cm2 = img2.getColorModel();\n+\n+            int r1, r2;  \/\/ red\n+            int g1, g2;  \/\/ green\n+            int b1, b2;  \/\/ blue\n+\n+            Object o1 = null;\n+            Object o2 = null;\n+            nDiff = 0;\n+            for (int x = minx1; x < (minx1 + w1); x++) {\n+                for (int y = miny1; y < (miny1 + h1); y++) {\n+                    \/\/ Causes rasters to allocate data\n+                    o1 = ras1.getDataElements(x, y, o1);\n+                    \/\/ and we reuse the data on every loop\n+                    o2 = ras2.getDataElements(x, y, o2);\n+\n+                    r1 = cm1.getRed(o1);\n+                    r2 = cm2.getRed(o2);\n+                    g1 = cm1.getGreen(o1);\n+                    g2 = cm2.getGreen(o2);\n+                    b1 = cm1.getBlue(o1);\n+                    b2 = cm2.getBlue(o2);\n+\n+                    int redAbs = Math.abs(r1 - r2);\n+                    int greenAbs = Math.abs(g1 - g2);\n+                    int blueAbs = Math.abs(b1 - b2);\n+                    if ((redAbs > threshold)\n+                        || (greenAbs > threshold)\n+                        || (blueAbs > threshold)) {\n+                        \/\/ pixel is different\n+                        setDiffPixel(x, y, redAbs, greenAbs, blueAbs);\n+                        nDiff++;\n+                    } else {\n+                        setSamePixel(x, y);\n+                    }\n+\n+                }\n+            }\n+            if (nDiff != 0) {\n+                ImageIO.write(this, \"png\",\n+                              new File(\"diffImage.png\"));\n+                saveButtonImage(img1, new File(\"image1.png\"));\n+                saveButtonImage(img2, new File(\"image2.png\"));\n+            }\n+            return nDiff == 0;\n+        }\n+\n+        void setDiffPixel(int x, int y, int r, int g, int b) {\n+            diff = true;\n+            setPixelValue(x, y, 255, r, g, b);\n+        }\n+\n+        void setSamePixel(int x, int y) {\n+            if (bgColor != null) {\n+                setPixelValue(x, y, 255, bgColor.getRed(),\n+                              bgColor.getGreen(),\n+                              bgColor.getBlue());\n+            } else {\n+                setPixelValue(x, y, 255, Color.black.getRed(),\n+                              Color.black.getGreen(), Color.black.getBlue());\n+            }\n+        }\n+\n+        void setPixelValue(int x, int y, int a, int r, int g, int b) {\n+            \/\/ setRGB uses BufferedImage.TYPE_INT_ARGB format\n+            int pixel =\n+                    ((a & 0xff) << 24) + ((r & 0xff) << 16) + ((g & 0xff) << 8)\n+                    + ((b & 0xff));\n+            setRGB(x, y, pixel);\n+        }\n+\n+    }\n+\n+}\n+\n+\n","filename":"test\/jdk\/javax\/swing\/JButton\/SwingButtonResizeTestWithOpenGL.java","additions":352,"deletions":0,"binary":false,"changes":352,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -36,1 +36,11 @@\n- * @author Alexey Ivanov\n+ * @requires os.family != \"linux\"\n+ * @modules java.desktop\/sun.swing\n+ * @run main bug8080628\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8080628\n+ * @key headful\n+ * @summary No mnemonics on Open and Save buttons in JFileChooser.\n+ * @requires os.family == \"linux\"\n@@ -84,0 +94,1 @@\n+                    System.out.println(\"Unsupported L&F: \" + info.getClassName());\n@@ -86,0 +97,1 @@\n+                System.out.println(\"Testing L&F: \" + info.getClassName());\n","filename":"test\/jdk\/javax\/swing\/JFileChooser\/8080628\/bug8080628.java","additions":14,"deletions":2,"binary":false,"changes":16,"status":"modified"},{"patch":"@@ -0,0 +1,80 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Canvas;\n+import java.awt.Color;\n+import java.awt.Graphics2D;\n+import javax.swing.JFrame;\n+import javax.swing.JOptionPane;\n+import javax.swing.JTextField;\n+import javax.swing.SwingUtilities;\n+\n+\/*\n+ * @test\n+ * @bug 8235404\n+ * @summary Checks that JOptionPane doesn't block drawing strings on another component\n+ * @library \/java\/awt\/regtesthelpers\n+ * @build PassFailJFrame\n+ * @run main\/manual OptionPaneInput\n+ *\/\n+public class OptionPaneInput {\n+    private static JFrame f;\n+    private static Canvas c;\n+    private static JTextField t;\n+    private static final String instructions = \"\"\"\n+            1. Type \"test\" into the message dialog.\n+            2. Press enter key.\n+            3. Press OK button.\n+            4. If the OptionPaneInput frame has test drawn on it, pass. Otherwise fail.\n+            \"\"\";\n+\n+    public static void main(String[] args) throws Exception {\n+        PassFailJFrame testFrame = new PassFailJFrame(instructions);\n+\n+        SwingUtilities.invokeAndWait(() -> createGUI());\n+        testFrame.awaitAndCheck();\n+    }\n+\n+    public static void createGUI() {\n+        f = new JFrame(\"OptionPaneInput\");\n+        c = new Canvas();\n+        t = new JTextField();\n+        f.add(c);\n+\n+        t.addActionListener(e -> {\n+            String text = t.getText();\n+            Graphics2D g2 = (Graphics2D)(c.getGraphics());\n+            g2.setColor(Color.BLACK);\n+            g2.drawString(text, 10, 10);\n+            System.out.println(\"drawing \"+text);\n+            g2.dispose();\n+        });\n+\n+        f.setSize(300, 100);\n+        PassFailJFrame.addTestWindow(f);\n+        PassFailJFrame.positionTestWindow(f, PassFailJFrame.Position.HORIZONTAL);\n+        f.setVisible(true);\n+\n+        JOptionPane.showMessageDialog(f, t);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/JOptionPane\/OptionPaneInput.java","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,185 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 6318027\n+ * @key headful\n+ * @summary  Verifies BasicScrollBarUI disables timer when enclosing frame is disabled\n+ * @run main DisableFrameFromScrollBar\n+ *\/\n+\n+import java.awt.FlowLayout;\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.AdjustmentEvent;\n+import java.awt.event.AdjustmentListener;\n+import java.awt.event.InputEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JScrollBar;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+import javax.swing.UnsupportedLookAndFeelException;\n+import javax.swing.event.ChangeEvent;\n+import javax.swing.event.ChangeListener;\n+\n+public class DisableFrameFromScrollBar {\n+\n+    private static JFrame frame;\n+    private static JScrollBar bar;\n+    private static int oldValue;\n+    private static volatile boolean doCheck;\n+    private static volatile boolean isAdjusting;\n+\n+    private static void setLookAndFeel(UIManager.LookAndFeelInfo laf) {\n+        try {\n+            UIManager.setLookAndFeel(laf.getClassName());\n+        } catch (UnsupportedLookAndFeelException ignored) {\n+            System.out.println(\"Unsupported LAF: \" + laf.getClassName());\n+        } catch (ClassNotFoundException | InstantiationException\n+                 | IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static void createUI() {\n+        frame = new JFrame(DisableFrameFromScrollBar.class.getName());\n+        bar = new JScrollBar();\n+        bar.getModel().addChangeListener(new DisableChangeListener(frame));\n+        frame.getContentPane().setLayout(new FlowLayout());\n+        frame.add(bar);\n+\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setSize(150, 150);\n+        frame.setLocationRelativeTo(null);\n+        frame.setVisible(true);\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        for (UIManager.LookAndFeelInfo laf : UIManager.getInstalledLookAndFeels()) {\n+            System.out.println(\"Testing LAF : \" + laf.getClassName());\n+            Robot robot = new Robot();\n+            robot.setAutoDelay(100);\n+            try {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    setLookAndFeel(laf);\n+                    createUI();\n+                });\n+\n+                robot.waitForIdle();\n+                robot.delay(1000);\n+                Point point = getClickPoint();\n+                robot.mouseMove(point.x, point.y);\n+                robot.waitForIdle();\n+                robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+                robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+\n+                SwingUtilities.invokeAndWait(() -> {\n+                    oldValue = bar.getValue();\n+                    bar.addAdjustmentListener(new AdjustmentListener() {\n+                        public void adjustmentValueChanged(AdjustmentEvent e) {\n+                            int curValue = e.getValue();\n+                            int extent = bar.getMaximum() - bar.getVisibleAmount();\n+                            if (curValue < extent && curValue != oldValue) {\n+                                oldValue = curValue;\n+                                isAdjusting = true;\n+                            } else {\n+                                doCheck = true;\n+                                isAdjusting = false;\n+                            }\n+                        }\n+                    });\n+                });\n+                do {\n+                    Thread.sleep(200);\n+                } while (isAdjusting && !doCheck);\n+                if (bar.getValue() == (bar.getMaximum() - bar.getVisibleAmount())) {\n+                    throw new RuntimeException(\"ScrollBar didn't disable timer\");\n+                }\n+            } finally {\n+                SwingUtilities.invokeAndWait(() -> {\n+                    if (frame != null) {\n+                       frame.dispose();\n+                    }\n+               });\n+            }\n+        }\n+    }\n+\n+    private static Point getClickPoint() throws Exception {\n+        final Point[] result = new Point[1];\n+\n+        SwingUtilities.invokeAndWait(new Runnable() {\n+\n+            @Override\n+            public void run() {\n+                Point p = bar.getLocationOnScreen();\n+                Rectangle rect = bar.getBounds();\n+                result[0] = new Point((int) (p.x + rect.width \/ 2),\n+                        (int) (p.y + rect.height - 10));\n+            }\n+        });\n+\n+        return result[0];\n+\n+    }\n+\n+    public static class DisableChangeListener implements ChangeListener {\n+        private final JFrame m_frame;\n+        private boolean m_done;\n+\n+        public DisableChangeListener(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void stateChanged(ChangeEvent p_e) {\n+            if (!m_done) {\n+                m_frame.setEnabled(false);\n+                Thread t = new Thread(new Enabler(m_frame));\n+                t.start();\n+                m_done = true;\n+            }\n+        }\n+    }\n+\n+    public static class Enabler implements Runnable {\n+        private JFrame m_frame;\n+\n+        Enabler(JFrame p_frame) {\n+            m_frame = p_frame;\n+        }\n+\n+        public void run() {\n+            try {\n+                Thread.sleep(1000);\n+            }\n+            catch (InterruptedException e) {\n+                e.printStackTrace();\n+            }\n+            m_frame.setEnabled(true);\n+        }\n+    }\n+}\n+\n","filename":"test\/jdk\/javax\/swing\/JScrollBar\/DisableFrameFromScrollBar.java","additions":185,"deletions":0,"binary":false,"changes":185,"status":"added"},{"patch":"@@ -42,1 +42,1 @@\n- * @bug 4112270 8264102\n+ * @bug 4112270 8264102 8329756\n@@ -181,1 +181,1 @@\n-                 and verifying each key combinations against the spec defined.\n+                 and verify each key combination against the spec defined.\n@@ -273,1 +273,1 @@\n-                FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n+                fn+Up\/Down Arrow - Deselect current selection;\n@@ -276,4 +276,1 @@\n-                Control-FN+Up Arrow\/FN+Down Arrow - Deselect current selection;\n-                                                    move focus and view to\n-                                                    first\/last cell in current row\n-                F2 - Allows editing in a cell containing information without\n+                fn - Allows editing in a cell containing information without\n@@ -283,2 +280,1 @@\n-                Ctrl+A, Ctrl+\/ - Select All\n-                Ctrl+\\\\ - Deselect all\n+                Cmd+A - Select All\n@@ -287,4 +283,3 @@\n-                FN-Shift Up\/Down Arrow -  Extend selection to top\/bottom of column\n-                Shift-PageUp\/PageDown - Extend selection up\/down one view and scroll\n-                                        table\n-                                \"\"\";\n+                Ctrl-Shift Up\/Down Arrow -  Extend selection to top\/bottom of row\n+                Ctrl-Shift Left\/Right Arrow -  Extend selection to first\/last of column\n+                \"\"\";\n","filename":"test\/jdk\/javax\/swing\/JTable\/KeyBoardNavigation.java","additions":8,"deletions":13,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -31,1 +31,0 @@\n-  @run main\/othervm -Djdk.gtk.version=2 DemandGTK\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -1,91 +0,0 @@\n-#!\/bin\/ksh -p\n-\n-#\n-# Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n-# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n-#\n-# This code is free software; you can redistribute it and\/or modify it\n-# under the terms of the GNU General Public License version 2 only, as\n-# published by the Free Software Foundation.\n-#\n-# This code is distributed in the hope that it will be useful, but WITHOUT\n-# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-# version 2 for more details (a copy is included in the LICENSE file that\n-# accompanied this code).\n-#\n-# You should have received a copy of the GNU General Public License version\n-# 2 along with this work; if not, write to the Free Software Foundation,\n-# Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n-#\n-# Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n-# or visit www.oracle.com if you need additional information or have any\n-# questions.\n-#\n-\n-#   @test\n-#   @summary  Try to force GTK2. We must bail out to GTK3 (if any) if no 2 available.\n-#\n-#   @key headful\n-#   @bug 8156128 8212903\n-#   @compile ProvokeGTK.java\n-#   @requires os.family == \"linux\"\n-#   @run shell\/timeout=400 DemandGTK2.sh\n-\n-#\n-# Note that we depend on\n-# strace in the PATH\n-# \/sbin\/ldconfig (which may be not in PATH)\n-# It is true for OEL 7 and Ubuntu 14, 16\n-# but may fail in future. Save tomorrow for tomorrow.\n-#\n-# Read DemandGTK2.txt how to prepare GTK2-less machine.\n-#\n-\n-which strace\n-if [ $?  -ne 0 ]\n-then\n-    echo \"Please provide strace: \\\"which strace\\\" failed.\"\n-    exit 1\n-fi\n-\n-HAVE_2=`\/sbin\/ldconfig -v 2>\/dev\/null | grep libgtk-x11-2 | wc -l`\n-HAVE_3=`\/sbin\/ldconfig -v 2>\/dev\/null | grep libgtk-3.so | wc -l`\n-\n-\n-if [ \"${HAVE_2}\" = \"0\" ]\n-then\n-    \n-    if [ \"${HAVE_3}\" = \"0\" ]\n-    then\n-        echo \"Neither GTK2 nor GTK3 found: system misconfiguration. Exit.\"\n-        exit 1\n-    fi\n-    echo \"No GTK 2 library found: we should bail out to 3\"\n-    strace -o strace.log -fe open,openat ${TESTJAVA}\/bin\/java  -cp ${TESTCLASSPATH}  -Djdk.gtk.version=2 ProvokeGTK\n-    EXECRES=$?\n-    grep  'libgtk-3.*=\\ *[0-9]*$' strace.log > logg\n-else\n-    echo \"There is GTK 2 library: we should use it\"\n-    strace -o strace.log -fe open,openat ${TESTJAVA}\/bin\/java  -cp ${TESTCLASSPATH}  -Djdk.gtk.version=2 ProvokeGTK\n-    EXECRES=$?\n-    grep  'libgtk-x11.*=\\ *[0-9]*$' strace.log > logg\n-fi\n-\n-if [ ${EXECRES}  -ne 0 ]\n-then\n-    echo \"java execution failed for unknown reason, see logs\"\n-    exit 2\n-fi\n-\n-cat logg\n-if [ -s logg ]\n-then\n-    echo \"Success.\"\n-    exit 0\n-else\n-    echo \"Failed. Examine logs.\"\n-    exit 3\n-fi\n-\n-\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK2.sh","additions":0,"deletions":91,"binary":false,"changes":91,"status":"deleted"},{"patch":"@@ -1,36 +0,0 @@\n-How to prepare an Ubuntu machine for GTK-2-less test run.\n-\n-The test DemandGTK2.sh should work well without GTK-2 switching to version 3\n-if there's no GTK-2 library available. \n-At the moment, it's not easy to find a system with GTK-3 and without GTK-2:\n-many programs still depend on version 2.\n-We can, however, rename GTK-2 library for a single test run and then restore\n-it back.\n-\n-(1) Find GTK2 library: run\n-  \/sbin\/ldconfig -v 2>\/dev\/null |  grep libgtk-x11-2\n-\n-It will output one or two lines like \n-libgtk-x11-2.0.so.0 -> libgtk-x11-2.0.so.0.2400.23\n-Search for the target of that symlink for instance with locate:\n-locate libgtk-x11-2.0.so.0.2400.23\n-Finally, you'll find the libraries. On my current machine they are\n-\/usr\/lib\/i386-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\n-I'm running 64-bit JDK and need to tamper with x86_64 copy only.\n-\n-(2) Find running programs depending on this library. They probably would crash\n-if you rename it. Stop them for this test run.\n-That said, I'm afraid it would be impossible to do on a system older than Ubuntu 16.04.\n-On my Ubuntu 16.04 I have only hud-service using this library, and that's OK, it will restart\n-after a crash, if any.\n-To find these programs, run\n-lsof \/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\n-(3) Now,\n-sudo mv  \/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23  \/usr\/lib\/x86_64-linux-gnu\/bak.libgtk-x11-2.0.so.0.2400.23\n-jtreg DemandGTK2.sh \n-sudo mv  \/usr\/lib\/x86_64-linux-gnu\/bak.libgtk-x11-2.0.so.0.2400.23  \/usr\/lib\/x86_64-linux-gnu\/libgtk-x11-2.0.so.0.2400.23\n-\n-Needless to say, you should substitute your own library path and however you run jtreg.\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK2.txt","additions":0,"deletions":36,"binary":false,"changes":36,"status":"deleted"},{"patch":"@@ -4,1 +4,1 @@\n-# Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+# Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,1 +28,1 @@\n-#   @summary  Try to force GTK3. We must bail out to GTK2 if no 3 available.\n+#   @summary  Try to force GTK3.\n@@ -56,5 +56,2 @@\n-    \n-    echo \"No GTK 3 library found: we should bail out to 2\"\n-    strace -o strace.log -fe open,openat ${TESTJAVA}\/bin\/java  -cp ${TESTCLASSPATH}  -Djdk.gtk.version=3 ProvokeGTK\n-    EXECRES=$?\n-    grep  'libgtk-x11.*=\\ *[0-9]*$' strace.log > logg\n+    echo \"No GTK 3 library found, do nothing\"\n+    exit 0\n","filename":"test\/jdk\/javax\/swing\/LookAndFeel\/8145547\/DemandGTK3.sh","additions":4,"deletions":7,"binary":false,"changes":11,"status":"modified"},{"patch":"@@ -0,0 +1,139 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.awt.Point;\n+import java.awt.Rectangle;\n+import java.awt.Robot;\n+import java.awt.event.InputEvent;\n+import java.awt.event.KeyEvent;\n+\n+import javax.swing.JFrame;\n+import javax.swing.JTable;\n+import javax.swing.SwingUtilities;\n+import javax.swing.UIManager;\n+\n+\/*\n+ * @test\n+ * @bug 8338041\n+ * @key headful\n+ * @summary Verify that Ctrl Shift RIGHT\/LEFT key extends columns till\n+ * Last\/First Columns in JTable\n+ * @requires (os.family == \"linux\")\n+ * @run main JTableCtrlShiftRightLeftKeyTest\n+ *\/\n+\n+public class JTableCtrlShiftRightLeftKeyTest {\n+    private static JFrame frame;\n+    private static JTable table;\n+    private static volatile Point tableLoc;\n+    private static volatile Rectangle cellRect;\n+    private static volatile int[] selectedColumnAfterKeyPress;\n+    private static Robot robot;\n+    private static final int SELECTED_COLUMN = 2;\n+\n+    public static void main(String[] args) throws Exception {\n+        UIManager.setLookAndFeel(\"com.sun.java.swing.plaf.gtk.GTKLookAndFeel\");\n+        robot = new Robot();\n+        robot.setAutoDelay(50);\n+        try {\n+            SwingUtilities.invokeAndWait(JTableCtrlShiftRightLeftKeyTest::createAndShowUI);\n+            robot.waitForIdle();\n+            robot.delay(1000);\n+\n+            SwingUtilities.invokeAndWait(() -> {\n+                tableLoc = table.getLocationOnScreen();\n+                cellRect = table.getCellRect(0, SELECTED_COLUMN, true);\n+            });\n+\n+            robot.mouseMove(tableLoc.x + cellRect.x + cellRect.width \/ 2,\n+                    tableLoc.y + cellRect.y + cellRect.height \/ 2);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_RIGHT, SELECTED_COLUMN,\n+                    table.getColumnCount() - 1, \"RIGHT\");\n+\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            robot.mousePress(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.mouseRelease(InputEvent.BUTTON1_DOWN_MASK);\n+            robot.waitForIdle();\n+            robot.delay(100);\n+\n+            testCtrlShift(KeyEvent.VK_LEFT, 0,\n+                    SELECTED_COLUMN, \"LEFT\");\n+            robot.waitForIdle();\n+            robot.delay(100);\n+            System.out.println(\"Test Passed!\");\n+\n+        } finally {\n+            SwingUtilities.invokeAndWait(() -> {\n+                if (frame != null) {\n+                    frame.dispose();\n+                }\n+            });\n+        }\n+    }\n+\n+    private static void testCtrlShift(int keySelected, int startCellCheck,\n+                                      int endCellCheck, String key) throws Exception {\n+        robot.keyPress(KeyEvent.VK_SHIFT);\n+        robot.keyPress(KeyEvent.VK_CONTROL);\n+        robot.keyPress(keySelected);\n+        robot.keyRelease(keySelected);\n+        robot.keyRelease(KeyEvent.VK_SHIFT);\n+        robot.keyRelease(KeyEvent.VK_CONTROL);\n+        robot.waitForIdle();\n+        robot.delay(100);\n+\n+        SwingUtilities.invokeAndWait(() -> {\n+            selectedColumnAfterKeyPress = table.getSelectedColumns();\n+        });\n+\n+        if (selectedColumnAfterKeyPress[0] != startCellCheck ||\n+                selectedColumnAfterKeyPress[selectedColumnAfterKeyPress.length - 1] !=\n+                        endCellCheck) {\n+            System.out.println(\"Selected Columns: \");\n+            for (int columnsSelected : selectedColumnAfterKeyPress) {\n+                System.out.println(columnsSelected);\n+            }\n+            String failureMsg = \"Test Failure. Failed to select cells for Ctrl\" +\n+                    \" Shift \" + key + \" selection\";\n+            throw new RuntimeException(failureMsg);\n+        }\n+    }\n+\n+    private static void createAndShowUI() {\n+        frame = new JFrame(\"Test Ctrl Shift RIGHT\/LEFT Key Press\");\n+        table = new JTable(2, 5);\n+        table.setColumnSelectionAllowed(true);\n+        frame.getContentPane().add(table);\n+\n+        frame.setSize(200, 200);\n+        frame.setLocationRelativeTo(null);\n+        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n+        frame.setVisible(true);\n+    }\n+}\n","filename":"test\/jdk\/javax\/swing\/plaf\/gtk\/JTableCtrlShiftRightLeftKeyTest.java","additions":139,"deletions":0,"binary":false,"changes":139,"status":"added"},{"patch":"@@ -98,1 +98,1 @@\n-                    codeB.loadConstant(i.opcode(), val);\n+                    codeB.loadConstant(val);\n","filename":"test\/jdk\/jdk\/classfile\/AdaptCodeTest.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -88,4 +88,4 @@\n-                                    builder.allocateLocal(TypeKind.ReferenceType);\n-                                    builder.allocateLocal(TypeKind.LongType);\n-                                    builder.allocateLocal(TypeKind.IntType);\n-                                    builder.allocateLocal(TypeKind.DoubleType);\n+                                    builder.allocateLocal(TypeKind.REFERENCE);\n+                                    builder.allocateLocal(TypeKind.LONG);\n+                                    builder.allocateLocal(TypeKind.INT);\n+                                    builder.allocateLocal(TypeKind.DOUBLE);\n@@ -327,1 +327,1 @@\n-                                                    storeStack.push(StoreInstruction.of(TypeKind.ReferenceType, slot++));\n+                                                    storeStack.push(StoreInstruction.of(TypeKind.REFERENCE, slot++));\n","filename":"test\/jdk\/jdk\/classfile\/AdvancedTransformationsTest.java","additions":5,"deletions":5,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -31,0 +31,2 @@\n+\n+import java.lang.constant.ConstantDesc;\n@@ -42,0 +44,2 @@\n+import java.util.stream.Stream;\n+\n@@ -56,1 +60,2 @@\n-    private static Map<String, Object> constants\n+    \/\/ name -> (value, poolValue)\n+    private static final Map<String, Map.Entry<Object, ConstantDesc>> constants\n@@ -58,12 +63,9 @@\n-            new AbstractMap.SimpleImmutableEntry<>(\"i\", 1),\n-            new AbstractMap.SimpleImmutableEntry<>(\"j\", 1L),\n-            new AbstractMap.SimpleImmutableEntry<>(\"s\", 1),\n-            new AbstractMap.SimpleImmutableEntry<>(\"b\", 1),\n-            new AbstractMap.SimpleImmutableEntry<>(\"f\", 1.0f),\n-            new AbstractMap.SimpleImmutableEntry<>(\"d\", 1.0d),\n-            new AbstractMap.SimpleImmutableEntry<>(\"z\", 1),\n-            new AbstractMap.SimpleImmutableEntry<>(\"c\", (int) '1'),\n-            new AbstractMap.SimpleImmutableEntry<>(\"st\", \"1\"),\n-            new AbstractMap.SimpleImmutableEntry<>(\"cl\", ClassDesc.of(\"foo.Bar\")),\n-            new AbstractMap.SimpleImmutableEntry<>(\"en\", E.C),\n-            new AbstractMap.SimpleImmutableEntry<>(\"arr\", new Object[] {1, \"1\", 1.0f})\n+            Map.entry(\"i\", Map.entry(1, 1)),\n+            Map.entry(\"j\", Map.entry(1L, 1L)),\n+            Map.entry(\"s\", Map.entry((short) 1, 1)),\n+            Map.entry(\"b\", Map.entry((byte) 1, 1)),\n+            Map.entry(\"f\", Map.entry(1.0f, 1.0f)),\n+            Map.entry(\"d\", Map.entry(1.0d, 1.0d)),\n+            Map.entry(\"z\", Map.entry(true, 1)),\n+            Map.entry(\"c\", Map.entry('1', (int) '1')),\n+            Map.entry(\"st\", Map.entry(\"1\", \"1\"))\n@@ -72,1 +74,1 @@\n-    private static final List<AnnotationElement> constantElements =\n+    private static final List<AnnotationElement> constantElements = Stream.concat(\n@@ -74,2 +76,8 @@\n-                    .map(e -> AnnotationElement.of(e.getKey(), AnnotationValue.of(e.getValue())))\n-                    .toList();\n+                    .map(e -> Map.entry(e.getKey(), e.getValue().getKey())),\n+            Stream.of(\n+                    Map.entry(\"cl\", ClassDesc.of(\"foo.Bar\")),\n+                    Map.entry(\"en\", E.C),\n+                    Map.entry(\"arr\", new Object[] {1, \"1\", 1.0f})\n+            ))\n+            .map(e -> AnnotationElement.of(e.getKey(), AnnotationValue.of(e.getValue())))\n+            .toList();\n@@ -91,3 +99,6 @@\n-                    assertTrue (evp.value() instanceof AnnotationValue.OfConstant c);\n-                    assertEquals(((AnnotationValue.OfConstant) evp.value()).constantValue(),\n-                                 constants.get(evp.name().stringValue()));\n+                    if (!(evp.value() instanceof AnnotationValue.OfConstant c))\n+                        return fail();\n+                    assertEquals(c.resolvedValue(),\n+                                 constants.get(evp.name().stringValue()).getKey());\n+                    assertEquals(c.constant().constantValue(),\n+                                 constants.get(evp.name().stringValue()).getValue());\n@@ -108,2 +119,3 @@\n-                    assertTrue (evp.value() instanceof AnnotationValue.OfArray);\n-                    List<AnnotationValue> values = ((AnnotationValue.OfArray) evp.value()).values();\n+                    if (!(evp.value() instanceof AnnotationValue.OfArray arr))\n+                        return fail();\n+                    List<AnnotationValue> values = arr.values();\n","filename":"test\/jdk\/jdk\/classfile\/AnnotationTest.java","additions":33,"deletions":21,"binary":false,"changes":54,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-                                assertEquals(nai.typeKind(), TypeKind.DoubleType);\n+                                assertEquals(nai.typeKind(), TypeKind.DOUBLE);\n","filename":"test\/jdk\/jdk\/classfile\/ArrayTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -262,3 +262,3 @@\n-                              int slot1 = xb.allocateLocal(TypeKind.IntType);\n-                              int slot2 = xb.allocateLocal(TypeKind.LongType);\n-                              int slot3 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot1 = xb.allocateLocal(TypeKind.INT);\n+                              int slot2 = xb.allocateLocal(TypeKind.LONG);\n+                              int slot3 = xb.allocateLocal(TypeKind.INT);\n@@ -280,3 +280,3 @@\n-                                  int slot1 = bb.allocateLocal(TypeKind.IntType);\n-                                  int slot2 = bb.allocateLocal(TypeKind.LongType);\n-                                  int slot3 = bb.allocateLocal(TypeKind.IntType);\n+                                  int slot1 = bb.allocateLocal(TypeKind.INT);\n+                                  int slot2 = bb.allocateLocal(TypeKind.LONG);\n+                                  int slot3 = bb.allocateLocal(TypeKind.INT);\n@@ -288,1 +288,1 @@\n-                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot4 = xb.allocateLocal(TypeKind.INT);\n@@ -302,3 +302,3 @@\n-                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n-                                                int slot2 = bb.allocateLocal(TypeKind.LongType);\n-                                                int slot3 = bb.allocateLocal(TypeKind.IntType);\n+                                                int slot1 = bb.allocateLocal(TypeKind.INT);\n+                                                int slot2 = bb.allocateLocal(TypeKind.LONG);\n+                                                int slot3 = bb.allocateLocal(TypeKind.INT);\n@@ -311,1 +311,1 @@\n-                                                int slot1 = bb.allocateLocal(TypeKind.IntType);\n+                                                int slot1 = bb.allocateLocal(TypeKind.INT);\n@@ -315,1 +315,1 @@\n-                              int slot4 = xb.allocateLocal(TypeKind.IntType);\n+                              int slot4 = xb.allocateLocal(TypeKind.INT);\n@@ -338,1 +338,1 @@\n-                var i = cob.allocateLocal(TypeKind.IntType);\n+                var i = cob.allocateLocal(TypeKind.INT);\n@@ -376,2 +376,2 @@\n-                    int d = cob.allocateLocal(TypeKind.IntType);\n-                    int e = cob.allocateLocal(TypeKind.IntType);\n+                    int d = cob.allocateLocal(TypeKind.INT);\n+                    int e = cob.allocateLocal(TypeKind.INT);\n","filename":"test\/jdk\/jdk\/classfile\/BuilderBlockTest.java","additions":15,"deletions":15,"binary":false,"changes":30,"status":"modified"},{"patch":"@@ -190,1 +190,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n@@ -221,1 +221,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n@@ -226,1 +226,1 @@\n-                                int intSlot = tb.allocateLocal(TypeKind.IntType);\n+                                int intSlot = tb.allocateLocal(TypeKind.INT);\n@@ -243,1 +243,1 @@\n-                                    int doubleSlot = tb.allocateLocal(TypeKind.DoubleType);\n+                                    int doubleSlot = tb.allocateLocal(TypeKind.DOUBLE);\n@@ -253,1 +253,1 @@\n-                                    int refSlot = tb.allocateLocal(TypeKind.ReferenceType);\n+                                    int refSlot = tb.allocateLocal(TypeKind.REFERENCE);\n@@ -284,1 +284,1 @@\n-                            int stringSlot = xb.allocateLocal(TypeKind.ReferenceType);\n+                            int stringSlot = xb.allocateLocal(TypeKind.REFERENCE);\n","filename":"test\/jdk\/jdk\/classfile\/BuilderTryCatchTest.java","additions":6,"deletions":6,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,0 +26,1 @@\n+ * @bug 8335927\n@@ -68,1 +69,1 @@\n-                                                  ClassDesc.of(\"Boo\"), List.of()))))))\n+                                                  Annotation.of(ClassDesc.of(\"Boo\"), List.of())))))))\n@@ -103,1 +104,1 @@\n-                                                ClassDesc.of(\"Boo\"), List.of())));\n+                                                Annotation.of(ClassDesc.of(\"Boo\"), List.of()))));\n@@ -118,1 +119,1 @@\n-                                          ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false)))))\n+                                          Annotation.of(ClassDesc.of(\"Fee\"), List.of(AnnotationElement.ofBoolean(\"yes\", false))))))\n@@ -252,1 +253,1 @@\n-                        annotation default: {array: [{boolean: true}, {byte: 12}, {char: 99}, {class: LPhee;}, {double: 1.3}, {enum class: LBoo;, constant name: BOO}, {float: 3.7}, {int: 33}, {long: 3333}, {short: 25}, {string: BOO}, {annotation class: LPhoo;}]}\n+                        annotation default: {array: [{boolean: true}, {byte: 12}, {char: c}, {class: LPhee;}, {double: 1.3}, {enum class: LBoo;, constant name: BOO}, {float: 3.7}, {int: 33}, {long: 3333}, {short: 25}, {string: BOO}, {annotation class: LPhoo;}]}\n@@ -503,1 +504,1 @@\n-                            \"annotation default\": {\"array\": [{\"boolean\": \"true\"}, {\"byte\": \"12\"}, {\"char\": \"99\"}, {\"class\": \"LPhee;\"}, {\"double\": \"1.3\"}, {\"enum class\": \"LBoo;\", \"constant name\": \"BOO\"}, {\"float\": \"3.7\"}, {\"int\": \"33\"}, {\"long\": \"3333\"}, {\"short\": \"25\"}, {\"string\": \"BOO\"}, {\"annotation class\": \"LPhoo;\"}]},\n+                            \"annotation default\": {\"array\": [{\"boolean\": \"true\"}, {\"byte\": \"12\"}, {\"char\": \"c\"}, {\"class\": \"LPhee;\"}, {\"double\": \"1.3\"}, {\"enum class\": \"LBoo;\", \"constant name\": \"BOO\"}, {\"float\": \"3.7\"}, {\"int\": \"33\"}, {\"long\": \"3333\"}, {\"short\": \"25\"}, {\"string\": \"BOO\"}, {\"annotation class\": \"LPhoo;\"}]},\n@@ -759,1 +760,1 @@\n-                            <annotation_default><array><value><boolean>true<\/boolean><\/value><value><byte>12<\/byte><\/value><value><char>99<\/char><\/value><value><class>LPhee;<\/class><\/value><value><double>1.3<\/double><\/value><value><enum_class>LBoo;<\/enum_class><constant_name>BOO<\/constant_name><\/value><value><float>3.7<\/float><\/value><value><int>33<\/int><\/value><value><long>3333<\/long><\/value><value><short>25<\/short><\/value><value><string>BOO<\/string><\/value><value><annotation_class>LPhoo;<\/annotation_class><\/value><\/array><\/annotation_default>\n+                            <annotation_default><array><value><boolean>true<\/boolean><\/value><value><byte>12<\/byte><\/value><value><char>c<\/char><\/value><value><class>LPhee;<\/class><\/value><value><double>1.3<\/double><\/value><value><enum_class>LBoo;<\/enum_class><constant_name>BOO<\/constant_name><\/value><value><float>3.7<\/float><\/value><value><int>33<\/int><\/value><value><long>3333<\/long><\/value><value><short>25<\/short><\/value><value><string>BOO<\/string><\/value><value><annotation_class>LPhoo;<\/annotation_class><\/value><\/array><\/annotation_default>\n@@ -910,1 +911,1 @@\n-        assertArrayEquals(out.toString().trim().split(\" *\\r?\\n\"), expected.trim().split(\"\\n\"));\n+        assertArrayEquals(expected.trim().split(\"\\n\"), out.toString().trim().split(\" *\\r?\\n\"));\n","filename":"test\/jdk\/jdk\/classfile\/ClassPrinterTest.java","additions":9,"deletions":8,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -0,0 +1,105 @@\n+\/*\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8304031 8338406\n+ * @summary Testing handling of various constant descriptors in ClassFile API.\n+ * @run junit ConstantDescSymbolsTest\n+ *\/\n+\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.DynamicConstantDesc;\n+import java.lang.constant.MethodHandleDesc;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.invoke.MethodHandles;\n+import java.lang.invoke.MethodType;\n+import java.util.function.Supplier;\n+import java.lang.classfile.ClassFile;\n+import org.junit.jupiter.api.Assertions;\n+import org.junit.jupiter.api.Test;\n+\n+import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n+import static java.lang.constant.ConstantDescs.*;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+\n+final class ConstantDescSymbolsTest {\n+\n+    \/\/ Testing that primitive class descs are encoded properly as loadable constants.\n+    @Test\n+    void testPrimitiveClassDesc() throws Throwable {\n+        ClassDesc ape = ClassDesc.of(\"Ape\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n+            clb.withSuperclass(CD_Object);\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n+            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n+                cob.aload(0);\n+                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n+                cob.return_();\n+            });\n+            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n+                cob.loadConstant(CD_int);\n+                cob.areturn();\n+            });\n+            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n+                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n+                var t = cob.constantPool().loadableConstantEntry(CD_long);\n+                cob.ldc(t);\n+                cob.areturn();\n+            });\n+        }));\n+        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class))\n+                .invokeExact();\n+        assertSame(int.class, t.get());\n+    }\n+\n+    \/\/ Tests that condy symbols with non-static-method bootstraps are using the right lookup descriptor.\n+    @Test\n+    void testConstantDynamicNonStaticBootstrapMethod() throws Throwable {\n+        record CondyBoot(MethodHandles.Lookup lookup, String name, Class<?> type) {}\n+        var bootClass = CondyBoot.class.describeConstable().orElseThrow();\n+        var bootMhDesc = MethodHandleDesc.ofConstructor(bootClass, CD_MethodHandles_Lookup, CD_String, CD_Class);\n+        var condyDesc = DynamicConstantDesc.of(bootMhDesc);\n+\n+        var targetCd = ClassDesc.of(\"Bat\");\n+        var lookup = MethodHandles.lookup();\n+        Class<?> a = lookup.defineClass(ClassFile.of().build(targetCd, clb -> {\n+            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow())\n+                    .withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> cob\n+                            .aload(0).invokespecial(CD_Object, INIT_NAME, MTD_void).return_())\n+                    .withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> cob\n+                            .loadConstant(condyDesc).areturn());\n+        }));\n+        @SuppressWarnings(\"unchecked\")\n+        Supplier<CondyBoot> t = (Supplier<CondyBoot>) lookup.findConstructor(a, MethodType.methodType(void.class))\n+                .asType(MethodType.methodType(Supplier.class)).invokeExact();\n+        var cb = t.get();\n+        assertEquals(MethodHandles.Lookup.ORIGINAL, cb.lookup.lookupModes() & MethodHandles.Lookup.ORIGINAL);\n+        assertSame(a, cb.lookup.lookupClass());\n+        assertEquals(DEFAULT_NAME, cb.name);\n+        assertEquals(CondyBoot.class, cb.type);\n+    }\n+}\n","filename":"test\/jdk\/jdk\/classfile\/ConstantDescSymbolsTest.java","additions":105,"deletions":0,"binary":false,"changes":105,"status":"added"},{"patch":"@@ -67,3 +67,3 @@\n-                                  c0.loadConstant(LDC, \"string0\")\n-                                    .loadConstant(LDC, \"string131\")\n-                                    .loadConstant(LDC, \"string50\")\n+                                  c0.ldc(\"string0\")\n+                                    .ldc(\"string131\")\n+                                    .ldc(\"string50\")\n","filename":"test\/jdk\/jdk\/classfile\/LDCTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @summary Testing ClassFile constant instruction opcodes.\n+ * @summary Testing ClassFile constant instruction argument validation.\n@@ -29,4 +29,2 @@\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDesc;\n-import static java.lang.constant.ConstantDescs.CD_void;\n-import java.lang.constant.MethodTypeDesc;\n+import java.lang.classfile.instruction.ConstantInstruction;\n+import org.junit.jupiter.api.Test;\n@@ -34,5 +32,0 @@\n-import java.lang.reflect.AccessFlag;\n-import java.lang.classfile.ClassFile;\n-import java.lang.classfile.Opcode;\n-import org.junit.jupiter.api.*;\n-import static org.junit.jupiter.api.DynamicTest.dynamicTest;\n@@ -41,1 +34,0 @@\n-import java.util.stream.Stream;\n@@ -43,85 +35,15 @@\n-public class OpcodesValidationTest {\n-\n-    record Case(Opcode opcode, Object constant) {}\n-\n-    static Stream<Case> positiveCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, null),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE),\n-            new Case(ICONST_M1, -1),\n-            new Case(ICONST_0, 0),\n-            new Case(ICONST_1, 1),\n-            new Case(ICONST_2, 2),\n-            new Case(ICONST_3, 3),\n-            new Case(ICONST_4, 4),\n-            new Case(ICONST_5, 5),\n-            new Case(LCONST_0, 0l),\n-            new Case(LCONST_0, 0),\n-            new Case(LCONST_1, 1l),\n-            new Case(LCONST_1, 1),\n-            new Case(FCONST_0, 0.0f),\n-            new Case(FCONST_1, 1.0f),\n-            new Case(FCONST_2, 2.0f),\n-            new Case(DCONST_0, 0.0d),\n-            new Case(DCONST_1, 1.0d)\n-        );\n-    }\n-\n-    static Stream<Case> negativeCases() {\n-        return Stream.of(\n-            new Case(ACONST_NULL, 0),\n-            new Case(SIPUSH, (int)Short.MIN_VALUE - 1),\n-            new Case(SIPUSH, (int)Short.MAX_VALUE + 1),\n-            new Case(BIPUSH, (int)Byte.MIN_VALUE - 1),\n-            new Case(BIPUSH, (int)Byte.MAX_VALUE + 1),\n-            new Case(ICONST_M1, -1l),\n-            new Case(ICONST_0, 0l),\n-            new Case(ICONST_1, 1l),\n-            new Case(ICONST_2, 2l),\n-            new Case(ICONST_3, 3l),\n-            new Case(ICONST_4, 4l),\n-            new Case(ICONST_5, 5l),\n-            new Case(LCONST_0, null),\n-            new Case(LCONST_0, 1l),\n-            new Case(LCONST_1, 1.0d),\n-            new Case(LCONST_1, 0),\n-            new Case(FCONST_0, 0.0d),\n-            new Case(FCONST_1, 1.01f),\n-            new Case(FCONST_2, 2),\n-            new Case(DCONST_0, 0.0f),\n-            new Case(DCONST_1, 1.0f),\n-            new Case(DCONST_1, 1)\n-        );\n-    }\n-\n-    @TestFactory\n-    Stream<DynamicTest> testPositiveCases() {\n-        return positiveCases().map(c -> dynamicTest(c.toString(), () -> testPositiveCase(c.opcode, c.constant)));\n-    }\n-\n-    private void testPositiveCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                                      mb -> mb.withCode(\n-                                              codeb -> codeb.loadConstant(opcode, (ConstantDesc) constant))));\n-    }\n-\n-\n-    @TestFactory\n-    Stream<DynamicTest> testNegativeCases() {\n-        return negativeCases().map(c -> dynamicTest(\n-            c.toString(),\n-            () -> assertThrows(IllegalArgumentException.class, () -> testNegativeCase(c.opcode, c.constant))\n-        ));\n-    }\n-\n-    private void testNegativeCase(Opcode opcode, Object constant) {\n-        ClassFile.of().build(ClassDesc.of(\"MyClass\"),\n-                        cb -> cb.withFlags(AccessFlag.PUBLIC)\n-                                .withMethod(\"<init>\", MethodTypeDesc.of(CD_void), 0,\n-                        mb -> mb .withCode(\n-                                codeb -> codeb.loadConstant(opcode, (ConstantDesc)constant))));\n+class OpcodesValidationTest {\n+\n+    @Test\n+    void testArgumentConstant() {\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(SIPUSH, Short.MAX_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, 0));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MIN_VALUE));\n+        assertDoesNotThrow(() -> ConstantInstruction.ofArgument(BIPUSH, Byte.MAX_VALUE));\n+\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(SIPUSH, (int)Short.MAX_VALUE + 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MIN_VALUE - 1));\n+        assertThrows(IllegalArgumentException.class, () -> ConstantInstruction.ofArgument(BIPUSH, (int)Byte.MAX_VALUE + 1));\n","filename":"test\/jdk\/jdk\/classfile\/OpcodesValidationTest.java","additions":19,"deletions":97,"binary":false,"changes":116,"status":"modified"},{"patch":"@@ -1,79 +0,0 @@\n-\/*\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-\n-\/*\n- * @test\n- * @bug 8304031\n- * @summary Testing that primitive class descs are encoded properly as loadable constants.\n- * @run junit PrimitiveClassConstantTest\n- *\/\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.invoke.MethodHandles;\n-import java.lang.invoke.MethodType;\n-import java.util.function.Supplier;\n-import java.lang.classfile.ClassFile;\n-import org.junit.jupiter.api.Assertions;\n-import org.junit.jupiter.api.Test;\n-\n-import static java.lang.constant.ConstantDescs.CD_Class;\n-import static java.lang.constant.ConstantDescs.CD_Object;\n-import static java.lang.constant.ConstantDescs.CD_int;\n-import static java.lang.constant.ConstantDescs.CD_long;\n-import static java.lang.constant.ConstantDescs.INIT_NAME;\n-import static java.lang.constant.ConstantDescs.MTD_void;\n-import static java.lang.classfile.ClassFile.ACC_PUBLIC;\n-\n-public final class PrimitiveClassConstantTest {\n-\n-    @Test\n-    public void test() throws Throwable {\n-        ClassDesc ape = ClassDesc.of(\"Ape\");\n-        var lookup = MethodHandles.lookup();\n-        Class<?> a = lookup.defineClass(ClassFile.of().build(ape, clb -> {\n-            clb.withSuperclass(CD_Object);\n-            clb.withInterfaceSymbols(Supplier.class.describeConstable().orElseThrow());\n-            clb.withMethodBody(INIT_NAME, MTD_void, ACC_PUBLIC, cob -> {\n-                cob.aload(0);\n-                cob.invokespecial(CD_Object, INIT_NAME, MTD_void);\n-                cob.return_();\n-            });\n-            clb.withMethodBody(\"get\", MethodTypeDesc.of(CD_Object), ACC_PUBLIC, cob -> {\n-                cob.loadConstant(CD_int);\n-                cob.areturn();\n-            });\n-            clb.withMethodBody(\"get2\", MethodTypeDesc.of(CD_Class), ACC_PUBLIC, cob -> {\n-                Assertions.assertThrows(IllegalArgumentException.class, () -> cob.constantPool().classEntry(CD_long));\n-                var t = cob.constantPool().loadableConstantEntry(CD_long);\n-                cob.ldc(t);\n-                cob.areturn();\n-            });\n-        }));\n-        Supplier<?> t = (Supplier<?>) lookup.findConstructor(a, MethodType.methodType(void.class))\n-                .asType(MethodType.methodType(Supplier.class))\n-                .invokeExact();\n-        Assertions.assertSame(int.class, t.get());\n-    }\n-\n-}\n","filename":"test\/jdk\/jdk\/classfile\/PrimitiveClassConstantTest.java","additions":0,"deletions":79,"binary":false,"changes":79,"status":"deleted"},{"patch":"@@ -27,1 +27,1 @@\n- * @bug 8305990 8320222 8320618 8335475\n+ * @bug 8305990 8320222 8320618 8335475 8338623 8338661\n@@ -34,0 +34,2 @@\n+import java.lang.classfile.attribute.StackMapFrameInfo;\n+import java.lang.classfile.attribute.StackMapTableAttribute;\n@@ -35,0 +37,4 @@\n+import java.lang.constant.ClassDesc;\n+import java.lang.constant.ConstantDescs;\n+import java.lang.constant.MethodTypeDesc;\n+import java.lang.reflect.AccessFlag;\n@@ -39,0 +45,1 @@\n+import java.util.List;\n@@ -43,1 +50,0 @@\n-import static java.lang.constant.ConstantDescs.MTD_void;\n@@ -47,5 +53,1 @@\n-\n-import java.lang.constant.ClassDesc;\n-import java.lang.constant.ConstantDescs;\n-import java.lang.constant.MethodTypeDesc;\n-import java.lang.reflect.AccessFlag;\n+import static java.lang.constant.ConstantDescs.*;\n@@ -344,0 +346,53 @@\n+\n+    private static final MethodTypeDesc MTD_int = MethodTypeDesc.of(CD_int);\n+    private static final MethodTypeDesc MTD_int_String = MethodTypeDesc.of(CD_int, CD_String);\n+\n+    @ParameterizedTest\n+    @EnumSource(ClassFile.StackMapsOption.class)\n+    void testInvocationCounters(ClassFile.StackMapsOption option) {\n+        var cf = ClassFile.of(option);\n+        var cd = ClassDesc.of(\"Test\");\n+        var bytes = cf.build(cd, clb -> clb\n+            .withMethodBody(\"a\", MTD_int_String, ACC_STATIC, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(CD_String, \"hashCode\", MTD_int)\n+                    .ireturn())\n+            .withMethodBody(\"b\", MTD_int, 0, cob -> cob\n+                    .aload(0)\n+                    .invokevirtual(cd, \"hashCode\", MTD_int)\n+                    .ireturn())\n+        );\n+\n+        var cm = ClassFile.of().parse(bytes);\n+        for (var method : cm.methods()) {\n+            var code = method.findAttribute(Attributes.code()).orElseThrow();\n+            assertEquals(1, code.maxLocals());\n+            assertEquals(1, code.maxStack());\n+        }\n+    }\n+\n+    @Test\n+    void testDeadCodeCountersWithCustomSMTA() {\n+        ClassDesc bar = ClassDesc.of(\"Bar\");\n+        byte[] bytes = ClassFile.of(ClassFile.StackMapsOption.DROP_STACK_MAPS).build(bar, clb -> clb\n+                .withMethodBody(\n+                        \"foo\", MethodTypeDesc.of(ConstantDescs.CD_long), ACC_STATIC, cob -> {\n+                            cob.lconst_0().lreturn();\n+                            Label f2 = cob.newBoundLabel();\n+                            cob.lstore(0);\n+                            Label f3 = cob.newBoundLabel();\n+                            cob.lload(0).lreturn().with(\n+                                    StackMapTableAttribute.of(List.of(\n+                                    StackMapFrameInfo.of(f2,\n+                                            List.of(),\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG)),\n+                                    StackMapFrameInfo.of(f3,\n+                                            List.of(StackMapFrameInfo.SimpleVerificationTypeInfo.ITEM_LONG),\n+                                            List.of()))));\n+                        }\n+                ));\n+        assertEmpty(ClassFile.of().verify(bytes));\n+        var code = (CodeAttribute) ClassFile.of().parse(bytes).methods().getFirst().code().orElseThrow();\n+        assertEquals(2, code.maxLocals());\n+        assertEquals(2, code.maxStack());\n+    }\n","filename":"test\/jdk\/jdk\/classfile\/StackMapsTest.java","additions":62,"deletions":7,"binary":false,"changes":69,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -48,1 +48,1 @@\n-                var stackTracker = CodeStackTracker.of(DoubleType, FloatType); \/\/initial stack tracker pre-set\n+                var stackTracker = CodeStackTracker.of(DOUBLE, FLOAT); \/\/initial stack tracker pre-set\n@@ -50,1 +50,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(DOUBLE, FLOAT));\n@@ -52,1 +52,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE, DOUBLE, FLOAT));\n@@ -54,1 +54,1 @@\n-                    assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                    assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -56,1 +56,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -58,1 +58,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(IntType, LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(INT, LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -60,1 +60,1 @@\n-                            assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -62,1 +62,1 @@\n-                            assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType, LongType, ReferenceType, DoubleType, FloatType));\n+                            assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE, LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -66,1 +66,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(LongType, ReferenceType, DoubleType, FloatType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(LONG, REFERENCE, DOUBLE, FLOAT));\n@@ -70,1 +70,1 @@\n-                        assertIterableEquals(stackTracker.stack().get(), List.of(ReferenceType));\n+                        assertIterableEquals(stackTracker.stack().get(), List.of(REFERENCE));\n","filename":"test\/jdk\/jdk\/classfile\/StackTrackerTest.java","additions":11,"deletions":11,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -41,2 +41,0 @@\n-import static java.lang.classfile.Opcode.INVOKESPECIAL;\n-import static java.lang.classfile.TypeKind.VoidType;\n","filename":"test\/jdk\/jdk\/classfile\/TempConstantPoolBuilderTest.java","additions":1,"deletions":3,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8336010 8336588\n+ * @bug 8335935 8336588\n","filename":"test\/jdk\/jdk\/classfile\/TransformTests.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -50,1 +50,0 @@\n-import static java.lang.classfile.TypeKind.VoidType;\n","filename":"test\/jdk\/jdk\/classfile\/Utf8EntryTest.java","additions":1,"deletions":2,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -523,1 +523,1 @@\n-                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().descriptor()).hashCode() + 1;\n+                        new ConstantPoolEntryRecord.CpClassRecord(\"[\" + cins.typeKind().upperBound().descriptorString()).hashCode() + 1;\n@@ -831,1 +831,1 @@\n-                    AnnotationRecord.ofAnnotation(ann));\n+                    AnnotationRecord.ofAnnotation(ann.annotation()));\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/ClassRecord.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -80,1 +80,1 @@\n-                cb.loadConstant(im.opcode(), im.constantValue());\n+                cb.loadConstant(im.constantValue());\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/InstructionModelToCodeBuilder.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -168,1 +168,1 @@\n-            case AnnotationValue.OfInteger v -> AnnotationValue.of(v.intValue());\n+            case AnnotationValue.OfInt v -> AnnotationValue.of(v.intValue());\n@@ -170,1 +170,1 @@\n-            case AnnotationValue.OfCharacter v -> AnnotationValue.of(v.charValue());\n+            case AnnotationValue.OfChar v -> AnnotationValue.of(v.charValue());\n@@ -182,2 +182,1 @@\n-                        ta.classSymbol(),\n-                        ta.elements().stream().map(ae -> AnnotationElement.of(ae.name().stringValue(), transformAnnotationValue(ae.value()))).toList())).toArray(TypeAnnotation[]::new);\n+                        transformAnnotation(ta.annotation()))).toArray(TypeAnnotation[]::new);\n@@ -223,8 +222,8 @@\n-                        case ByteType -> cob.baload();\n-                        case ShortType -> cob.saload();\n-                        case IntType -> cob.iaload();\n-                        case FloatType -> cob.faload();\n-                        case LongType -> cob.laload();\n-                        case DoubleType -> cob.daload();\n-                        case ReferenceType -> cob.aaload();\n-                        case CharType -> cob.caload();\n+                        case BYTE -> cob.baload();\n+                        case SHORT -> cob.saload();\n+                        case INT -> cob.iaload();\n+                        case FLOAT -> cob.faload();\n+                        case LONG -> cob.laload();\n+                        case DOUBLE -> cob.daload();\n+                        case REFERENCE -> cob.aaload();\n+                        case CHAR -> cob.caload();\n@@ -236,8 +235,8 @@\n-                        case ByteType -> cob.bastore();\n-                        case ShortType -> cob.sastore();\n-                        case IntType -> cob.iastore();\n-                        case FloatType -> cob.fastore();\n-                        case LongType -> cob.lastore();\n-                        case DoubleType -> cob.dastore();\n-                        case ReferenceType -> cob.aastore();\n-                        case CharType -> cob.castore();\n+                        case BYTE -> cob.bastore();\n+                        case SHORT -> cob.sastore();\n+                        case INT -> cob.iastore();\n+                        case FLOAT -> cob.fastore();\n+                        case LONG -> cob.lastore();\n+                        case DOUBLE -> cob.dastore();\n+                        case REFERENCE -> cob.aastore();\n+                        case CHAR -> cob.castore();\n@@ -308,1 +307,1 @@\n-                        case DoubleType -> {\n+                        case DOUBLE -> {\n@@ -310,3 +309,3 @@\n-                                case FloatType -> cob.d2f();\n-                                case IntType -> cob.d2i();\n-                                case LongType -> cob.d2l();\n+                                case FLOAT -> cob.d2f();\n+                                case INT -> cob.d2i();\n+                                case LONG -> cob.d2l();\n@@ -316,1 +315,1 @@\n-                        case FloatType -> {\n+                        case FLOAT -> {\n@@ -318,3 +317,3 @@\n-                                case DoubleType -> cob.f2d();\n-                                case IntType -> cob.f2i();\n-                                case LongType -> cob.f2l();\n+                                case DOUBLE -> cob.f2d();\n+                                case INT -> cob.f2i();\n+                                case LONG -> cob.f2l();\n@@ -324,1 +323,1 @@\n-                        case IntType -> {\n+                        case INT -> {\n@@ -326,6 +325,6 @@\n-                                case ByteType -> cob.i2b();\n-                                case CharType -> cob.i2c();\n-                                case DoubleType -> cob.i2d();\n-                                case FloatType -> cob.i2f();\n-                                case LongType -> cob.i2l();\n-                                case ShortType -> cob.i2s();\n+                                case BYTE -> cob.i2b();\n+                                case CHAR -> cob.i2c();\n+                                case DOUBLE -> cob.i2d();\n+                                case FLOAT -> cob.i2f();\n+                                case LONG -> cob.i2l();\n+                                case SHORT -> cob.i2s();\n@@ -335,1 +334,1 @@\n-                        case LongType -> {\n+                        case LONG -> {\n@@ -337,3 +336,3 @@\n-                                case DoubleType -> cob.l2d();\n-                                case FloatType -> cob.l2f();\n-                                case IntType -> cob.l2i();\n+                                case DOUBLE -> cob.l2d();\n+                                case FLOAT -> cob.l2f();\n+                                case INT -> cob.l2i();\n@@ -414,5 +413,5 @@\n-                        case IntType -> cob.iload(i.slot());\n-                        case FloatType -> cob.fload(i.slot());\n-                        case LongType -> cob.lload(i.slot());\n-                        case DoubleType -> cob.dload(i.slot());\n-                        case ReferenceType -> cob.aload(i.slot());\n+                        case INT -> cob.iload(i.slot());\n+                        case FLOAT -> cob.fload(i.slot());\n+                        case LONG -> cob.lload(i.slot());\n+                        case DOUBLE -> cob.dload(i.slot());\n+                        case REFERENCE -> cob.aload(i.slot());\n@@ -424,5 +423,5 @@\n-                        case IntType -> cob.istore(i.slot());\n-                        case FloatType -> cob.fstore(i.slot());\n-                        case LongType -> cob.lstore(i.slot());\n-                        case DoubleType -> cob.dstore(i.slot());\n-                        case ReferenceType -> cob.astore(i.slot());\n+                        case INT -> cob.istore(i.slot());\n+                        case FLOAT -> cob.fstore(i.slot());\n+                        case LONG -> cob.lstore(i.slot());\n+                        case DOUBLE -> cob.dstore(i.slot());\n+                        case REFERENCE -> cob.astore(i.slot());\n@@ -519,6 +518,6 @@\n-                        case IntType -> cob.ireturn();\n-                        case FloatType -> cob.freturn();\n-                        case LongType -> cob.lreturn();\n-                        case DoubleType -> cob.dreturn();\n-                        case ReferenceType -> cob.areturn();\n-                        case VoidType -> cob.return_();\n+                        case INT -> cob.ireturn();\n+                        case FLOAT -> cob.freturn();\n+                        case LONG -> cob.lreturn();\n+                        case DOUBLE -> cob.dreturn();\n+                        case REFERENCE -> cob.areturn();\n+                        case VOID -> cob.return_();\n","filename":"test\/jdk\/jdk\/classfile\/helpers\/RebuildingTransformation.java","additions":54,"deletions":55,"binary":false,"changes":109,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2023, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 8285932 8310913\n+ * @bug 8285932 8310913 8336390 8338060\n@@ -39,0 +39,1 @@\n+import java.util.List;\n@@ -43,0 +44,1 @@\n+import java.util.function.Function;\n@@ -44,0 +46,1 @@\n+import java.util.stream.IntStream;\n@@ -46,1 +49,11 @@\n-    static long BASE_KEY = 10_000_000L;\n+    private static String BASE_KEY = \"BASEKEY-\";\n+\n+    \/\/ Return a String (identity object) that can be a key in WeakHashMap.\n+    private static String genKey(int i) {\n+        return BASE_KEY + i;\n+    }\n+\n+    \/\/ Return a String of the letter 'a' plus the integer (0..0xffff)\n+    private static String genValue(int i) {\n+        return String.valueOf((char) ('a' + i));\n+    }\n@@ -66,3 +79,7 @@\n-    static void mapTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, String>> supplier) {\n-        Map<Long, String> map = ReferencedKeyMap.create(isSoft, supplier);\n-        populate(map);\n+    static void mapTest(boolean isSoft, Supplier<Map<ReferenceKey<String>, String>> supplier) {\n+        Map<String, String> map = ReferencedKeyMap.create(isSoft, supplier);\n+        var strongKeys = populate(map);      \/\/ Retain references to the keys\n+        methods(map);\n+        Reference.reachabilityFence(strongKeys);\n+\n+        strongKeys = null;      \/\/ drop strong key references\n@@ -74,2 +91,0 @@\n-        populate(map);\n-        methods(map);\n@@ -78,3 +93,7 @@\n-    static void setTest(boolean isSoft, Supplier<Map<ReferenceKey<Long>, ReferenceKey<Long>>> supplier) {\n-        ReferencedKeySet<Long> set = ReferencedKeySet.create(isSoft, supplier);\n-        populate(set);\n+    static void setTest(boolean isSoft, Supplier<Map<ReferenceKey<String>, ReferenceKey<String>>> supplier) {\n+        ReferencedKeySet<String> set = ReferencedKeySet.create(isSoft, supplier);\n+        var strongKeys = populate(set);      \/\/ Retain references to the keys\n+        methods(set);\n+        Reference.reachabilityFence(strongKeys);\n+\n+        strongKeys = null;          \/\/ drop strong key references\n@@ -86,2 +105,0 @@\n-        populate(set);\n-        methods(set);\n@@ -90,1 +107,1 @@\n-    static void methods(Map<Long, String> map) {\n+    static void methods(Map<String, String> map) {\n@@ -92,2 +109,2 @@\n-        assertTrue(map.containsKey(BASE_KEY + 'a' -'a'), \"missing key\");\n-        assertTrue(map.get(BASE_KEY + 'b' -'a').equals(\"b\"), \"wrong key\");\n+        assertTrue(map.containsKey(genKey('a' -'a')), \"missing key\");\n+        assertTrue(map.get(genKey('b' -'a')).equals(\"b\"), \"wrong key\");\n@@ -95,5 +112,5 @@\n-        map.remove(BASE_KEY + 'd' -'a');\n-        assertTrue(map.get(BASE_KEY + 'd' -'a') == null, \"not removed\");\n-        map.putAll(Map.of(1L, \"A\", 2L, \"B\"));\n-        assertTrue(map.get(2L).equals(\"B\"), \"collection not added\");\n-        assertTrue(map.containsKey(1L), \"key missing\");\n+        map.remove(genKey('d' -'a'));\n+        assertTrue(map.get(genKey('d' -'a')) == null, \"not removed\");\n+        map.putAll(Map.of(genKey(1), \"A\", genKey(2), \"B\"));\n+        assertTrue(map.get(genKey(2)).equals(\"B\"), \"collection not added\");\n+        assertTrue(map.containsKey(genKey(1)), \"key missing\");\n@@ -101,11 +118,11 @@\n-        assertTrue(map.entrySet().contains(Map.entry(1L, \"A\")), \"key missing\");\n-        map.putIfAbsent(3L, \"C\");\n-        assertTrue(map.get(3L).equals(\"C\"), \"key missing\");\n-        map.putIfAbsent(2L, \"D\");\n-        assertTrue(map.get(2L).equals(\"B\"), \"key replaced\");\n-        map.remove(3L);\n-        assertTrue(map.get(3L) == null, \"key not removed\");\n-        map.replace(2L, \"D\");\n-        assertTrue(map.get(2L).equals(\"D\"), \"key not replaced\");\n-        map.replace(2L, \"B\", \"E\");\n-        assertTrue(map.get(2L).equals(\"D\"), \"key replaced\");\n+        assertTrue(map.entrySet().contains(Map.entry(genKey(1), \"A\")), \"key missing\");\n+        map.putIfAbsent(genKey(3), \"C\");\n+        assertTrue(map.get(genKey(3)).equals(\"C\"), \"key missing\");\n+        map.putIfAbsent(genKey(2), \"D\");\n+        assertTrue(map.get(genKey(2)).equals(\"B\"), \"key replaced\");\n+        map.remove(genKey(3));\n+        assertTrue(map.get(genKey(3)) == null, \"key not removed\");\n+        map.replace(genKey(2), \"D\");\n+        assertTrue(map.get(genKey(2)).equals(\"D\"), \"key not replaced\");\n+        map.replace(genKey(2), \"B\", \"E\");\n+        assertTrue(map.get(genKey(2)).equals(\"D\"), \"key replaced\");\n@@ -114,1 +131,1 @@\n-    static void methods(ReferencedKeySet<Long> set) {\n+    static void methods(ReferencedKeySet<String> set) {\n@@ -116,9 +133,9 @@\n-        assertTrue(set.contains(BASE_KEY + 3), \"missing key\");\n-        set.remove(BASE_KEY + 3);\n-        assertTrue(!set.contains(BASE_KEY + 3), \"not removed\");\n-        Long element1 = set.get(BASE_KEY + 2);\n-        Long element2 = set.get(BASE_KEY + 3);\n-        Long element3 = set.get(BASE_KEY + 4);\n-        Long intern1 = set.intern(BASE_KEY + 2);\n-        Long intern2 = set.intern(BASE_KEY + 3);\n-        Long intern3 = set.intern(BASE_KEY + 4, e -> e);\n+        assertTrue(set.contains(genKey(3)), \"missing key\");\n+        set.remove(genKey(3));\n+        assertTrue(!set.contains(genKey(3)), \"not removed\");\n+        String element1 = set.get(genKey(2));\n+        String element2 = set.get(genKey(3));\n+        String element3 = set.get(genKey(4));\n+        String intern1 = set.intern(genKey(2));\n+        String intern2 = set.intern(genKey(3));\n+        String intern3 = set.intern(genKey(4), e -> e);\n@@ -131,2 +148,2 @@\n-        Long value1 = Long.valueOf(BASE_KEY + 999);\n-        Long value2 = Long.valueOf(BASE_KEY + 999);\n+        String value1 = genKey(999);\n+        String value2 = genKey(999);\n@@ -167,5 +184,5 @@\n-    static void populate(Map<Long, String> map) {\n-        for (int i = 0; i < 26; i++) {\n-            Long key = BASE_KEY + i;\n-            String value = String.valueOf((char) ('a' + i));\n-            map.put(key, value);\n+    static List<String> populate(Map<String, String> map) {\n+        var keyRefs = genStrings(0, 26, ReferencedKeyTest::genKey);\n+        var valueRefs = genStrings(0, 26, ReferencedKeyTest::genValue);\n+        for (int i = 0; i < keyRefs.size(); i++) {\n+            map.put(keyRefs.get(i), valueRefs.get(i));\n@@ -173,0 +190,1 @@\n+        return keyRefs;\n@@ -175,5 +193,9 @@\n-    static void populate(Set<Long> set) {\n-        for (int i = 0; i < 26; i++) {\n-            Long value = BASE_KEY + i;\n-            set.add(value);\n-        }\n+    static List<String> populate(Set<String> set) {\n+        var keyRefs = genStrings(0, 26, ReferencedKeyTest::genKey);\n+        set.addAll(keyRefs);\n+        return keyRefs;\n+    }\n+\n+    \/\/ Generate a List of consecutive strings using a function int -> String\n+    static List<String> genStrings(int min, int maxExclusive, Function<Integer, String> genString) {\n+        return IntStream.range(min, maxExclusive).mapToObj(i -> genString.apply(i)).toList();\n","filename":"test\/jdk\/jdk\/internal\/util\/ReferencedKeyTest.java","additions":76,"deletions":54,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -0,0 +1,69 @@\n+\/*\n+ * Copyright (c) 2024, Palantir Technologies, Inc. and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test TestChunkInputStreamBulkRead\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.api.consumer.TestChunkInputStreamBulkRead\n+ *\/\n+package jdk.jfr.api.consumer;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Recording;\n+import jdk.test.lib.Asserts;\n+\n+public class TestChunkInputStreamBulkRead {\n+\n+    public static void main(String[] args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+            try (Recording s = new Recording()) {\n+                s.start();\n+                s.stop();\n+            }\n+            r.stop();\n+            try (InputStream stream = r.getStream(null, null);\n+                 ByteArrayOutputStream output = new ByteArrayOutputStream()) {\n+                long read = stream.transferTo(output);\n+                System.out.printf(\"Read %d bytes from JFR stream%n\", read);\n+                Asserts.assertEquals(r.getSize(), read);\n+\n+                byte[] actual = output.toByteArray();\n+                Asserts.assertEqualsByteArray(r.getStream(null, null).readAllBytes(), actual);\n+\n+                Path dumpFile = Paths.get(\"recording.jfr\").toAbsolutePath().normalize();\n+                r.dump(dumpFile);\n+                System.out.printf(\"Dumped recording to %s (%d bytes)%n\", dumpFile, Files.size(dumpFile));\n+                Asserts.assertEqualsByteArray(Files.readAllBytes(dumpFile), actual);\n+            }\n+        }\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/api\/consumer\/TestChunkInputStreamBulkRead.java","additions":69,"deletions":0,"binary":false,"changes":69,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -90,1 +90,1 @@\n-            Asserts.assertEquals(re.getDuration(), Duration.between(re.getStartTime(), re.getEndTime()));\n+            Asserts.assertEquals(re.getDuration(), re.getStartTime().until(re.getEndTime()));\n@@ -114,1 +114,1 @@\n-            Asserts.assertEquals(re.getDuration(), Duration.between(re.getStartTime(), re.getEndTime()));\n+            Asserts.assertEquals(re.getDuration(), re.getStartTime().until(re.getEndTime()));\n","filename":"test\/jdk\/jdk\/jfr\/api\/event\/TestGetDuration.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2016, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2016, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -91,1 +91,1 @@\n-        Duration s = Duration.between(offset, t);\n+        Duration s = offset.until(t);\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/misc\/TestGetStream.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -56,1 +56,1 @@\n-        long durationMillis = Duration.between(afterStart, r.getStopTime()).toMillis();\n+        long durationMillis = afterStart.until(r.getStopTime()).toMillis();\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/options\/TestDuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        Duration measuredDuration = Duration.between(start, stop);\n+        Duration measuredDuration = start.until(stop);\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/state\/TestStateDuration.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -58,1 +58,1 @@\n-        long millis = Duration.between(start, started).toMillis();\n+        long millis = start.until(started).toMillis();\n","filename":"test\/jdk\/jdk\/jfr\/api\/recording\/state\/TestStateScheduleStart.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -73,0 +73,1 @@\n+        assertEquals(2, makeCombineControl());\n@@ -97,0 +98,28 @@\n+    private static int makeCombineControl() throws Exception {\n+        try (Recording r1 = new Recording()) {\n+            r1.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/list\");\n+            r1.start();\n+\n+            try (Recording r2 = new Recording()) {\n+                r2.enable(HTTPPostEvent.class).with(\"uriFilter\", \"https:\/\/www.example.com\/get\");\n+                r2.start();\n+\n+                HTTPPostEvent e1 = new HTTPPostEvent();\n+                e1.uri = \"https:\/\/www.example.com\/list\";\n+                e1.commit();\n+\n+                HTTPPostEvent e2 = new HTTPPostEvent();\n+                e2.uri = \"https:\/\/www.example.com\/get\";\n+                e2.commit();\n+\n+                HTTPPostEvent e3 = new HTTPPostEvent();\n+                e3.uri = \"https:\/\/www.example.com\/put\";\n+                e3.commit();\n+            }\n+\n+            r1.stop();\n+\n+            return Events.fromRecording(r1).size();\n+        }\n+    }\n+\n","filename":"test\/jdk\/jdk\/jfr\/api\/settings\/TestFilterEvents.java","additions":30,"deletions":1,"binary":false,"changes":31,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2014, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2014, 2024, Oracle and\/or its affiliates. All rights reserved.\n","filename":"test\/jdk\/jdk\/jfr\/event\/compiler\/TestCodeSweeper.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -96,1 +96,1 @@\n-                    while ((Duration.between(start, Instant.now()).compareTo(runTime) < 0) ||\n+                    while ((start.until(Instant.now()).compareTo(runTime) < 0) ||\n","filename":"test\/jdk\/jdk\/jfr\/event\/runtime\/TestThreadCpuTimeEvent.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -0,0 +1,116 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package jdk.jfr.jvm;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.jfr.EventNames;\n+\n+\/**\n+ * @test\n+ * @summary Verify that duplicate longer strings doesn't take up unneccessary space\n+ * @key jfr\n+ * @requires vm.hasJFR\n+ * @library \/test\/lib\n+ * @run main\/othervm jdk.jfr.jvm.TestLongStringsInPool\n+ *\/\n+public class TestLongStringsInPool {\n+    private static class StringEvent extends Event {\n+        String message;\n+    }\n+\n+    public static void main(String[] args) throws Exception {\n+        \/\/ Create two recordings; first has only one large\n+        \/\/ string, second has several occurences of the same\n+        \/\/ string. With long strings (>128 chars) being pooled,\n+        \/\/ the two recording should be roughly the same size.\n+        final int numEvents = 10;\n+        final String longString = generateString();\n+        final int strLen = longString.length();\n+        final StringEvent event = new StringEvent();\n+        event.message = longString;\n+\n+        Recording firstRec = new Recording();\n+        firstRec.start();\n+        \/\/ commit events with empty message (both recordings\n+        \/\/ will have the same number of events)\n+        for (int i = 0; i < numEvents - 1; i++) {\n+            event.message = \"\";\n+            event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        firstRec.stop();\n+        Path rec1 = Paths.get(\".\", \"rec1.jfr\");\n+        firstRec.dump(rec1);\n+        firstRec.close();\n+\n+\n+        Recording secondRec = new Recording();\n+        secondRec.start();\n+        \/\/ commit events with the same long string\n+        for (int i = 0; i < numEvents - 1; i++) {\n+          event.message = longString;\n+          event.commit();\n+        }\n+        \/\/ commit 1 event with a long string\n+        event.message = longString;\n+        event.commit();\n+\n+        secondRec.stop();\n+        Path rec2 = Paths.get(\".\", \"rec2.jfr\");\n+        secondRec.dump(rec2);\n+        secondRec.close();\n+\n+        \/\/ the files aren't exactly the same size, but rec2 should\n+        \/\/ not take up space for all strings if they're pooled correctly\n+        long maxAllowedDiff = (numEvents - 1) * strLen;\n+        long diff = Math.abs(Files.size(rec2) - Files.size(rec1));\n+\n+        Asserts.assertTrue(diff <= maxAllowedDiff, \"Size difference between recordings is too large: \"+ diff +\" > \" + maxAllowedDiff);\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec1).isEmpty(), \"No events found in recording 1\");\n+        Asserts.assertFalse(RecordingFile.readAllEvents(rec2).isEmpty(), \"No events found in recording 2\");\n+        Asserts.assertEquals(RecordingFile.readAllEvents(rec1).size(), RecordingFile.readAllEvents(rec2).size(), \"The recordings don't have the same number of events\");\n+    }\n+\n+    \/**\n+     * Generate a string of 256 chars length.\n+     * @return\n+     *\/\n+    private static String generateString() {\n+        final StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < 32; i++) {\n+            builder.append(\"abcdefgh\");\n+        }\n+        return builder.toString();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/jvm\/TestLongStringsInPool.java","additions":116,"deletions":0,"binary":false,"changes":116,"status":"added"},{"patch":"@@ -0,0 +1,110 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jfr.threading;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadFactory;\n+\n+import jdk.jfr.Event;\n+import jdk.jfr.Name;\n+import jdk.jfr.Recording;\n+import jdk.jfr.consumer.RecordedEvent;\n+import jdk.jfr.consumer.RecordedThread;\n+import jdk.jfr.consumer.RecordingFile;\n+import jdk.test.lib.Asserts;\n+import jdk.test.lib.Utils;\n+\n+\/**\n+ * @test\n+ * @bug 8338417\n+ * @summary Tests pinning of virtual threads when the JFR string pool monitor is contended.\n+ * @key jfr\n+ * @requires vm.hasJFR & vm.continuations\n+ * @library \/test\/lib \/test\/jdk\n+ * @run main\/othervm jdk.jfr.threading.TestStringPoolVirtualThreadPinning\n+ *\/\n+public class TestStringPoolVirtualThreadPinning {\n+\n+    private static final int VIRTUAL_THREAD_COUNT = 100_000;\n+    private static final int STARTER_THREADS = 10;\n+\n+    @Name(\"test.Tester\")\n+    private static class TestEvent extends Event {\n+        private String eventString = Thread.currentThread().getName();\n+    }\n+\n+    \/*\n+     * During event commit, the thread is in a critical section because it has loaded a carrier thread local event writer object.\n+     * For virtual threads, a contended monitor, such as a synchronized block, is a point where a thread could become unmounted.\n+     * A monitor guards the JFR string pool, but because of the event writer, remounting a virtual thread onto another carrier is impossible.\n+     *\n+     * The test provokes JFR string pool monitor contention to exercise explicit pin constructs to ensure the pinning of virtual threads.\n+    *\/\n+    public static void main(String... args) throws Exception {\n+        try (Recording r = new Recording()) {\n+            r.start();\n+\n+            ThreadFactory factory = Thread.ofVirtual().factory();\n+            CompletableFuture<?>[] c = new CompletableFuture[STARTER_THREADS];\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j] = CompletableFuture.runAsync(() -> {\n+                    for (int i = 0; i < VIRTUAL_THREAD_COUNT \/ STARTER_THREADS; i++) {\n+                        try {\n+                            Thread vt = factory.newThread(TestStringPoolVirtualThreadPinning::emitEvent);\n+                            \/\/ For an event field string to be placed in the JFR string pool, it must exceed 16 characters.\n+                            \/\/ We use the virtual thread name as the event field string so we can verify the result as a 1-1 mapping.\n+                            vt.setName(\"VirtualTestThread-\" + i);\n+                            vt.start();\n+                            vt.join();\n+                        } catch (InterruptedException ie) {\n+                            ie.printStackTrace();\n+                        }\n+                    }\n+                });\n+            }\n+            for (int j = 0; j < STARTER_THREADS; j++) {\n+                c[j].get();\n+            }\n+\n+            r.stop();\n+            Path p = Utils.createTempFile(\"test\", \".jfr\");\n+            r.dump(p);\n+            List<RecordedEvent> events = RecordingFile.readAllEvents(p);\n+            Asserts.assertEquals(events.size(), VIRTUAL_THREAD_COUNT, \"Expected \" + VIRTUAL_THREAD_COUNT + \" events\");\n+            for (RecordedEvent e : events) {\n+                RecordedThread t = e.getThread();\n+                Asserts.assertNotNull(t);\n+                Asserts.assertTrue(t.isVirtual());\n+                Asserts.assertEquals(e.getString(\"eventString\"), t.getJavaName());\n+            }\n+        }\n+    }\n+\n+    private static void emitEvent() {\n+        TestEvent t = new TestEvent();\n+        t.commit();\n+    }\n+}\n","filename":"test\/jdk\/jdk\/jfr\/threading\/TestStringPoolVirtualThreadPinning.java","additions":110,"deletions":0,"binary":false,"changes":110,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -34,1 +34,0 @@\n-import javax.swing.JApplet;\n@@ -45,2 +44,0 @@\n- *\n- * @author Jeff Dinkins\n@@ -48,1 +45,1 @@\n-public class DemoModule extends JApplet {\n+public class DemoModule extends JPanel {\n@@ -217,5 +214,0 @@\n-    public void init() {\n-        getContentPane().setLayout(new BorderLayout());\n-        getContentPane().add(getDemoPanel(), BorderLayout.CENTER);\n-    }\n-\n@@ -223,1 +215,2 @@\n-}\n\\ No newline at end of file\n+}\n+\n","filename":"test\/jdk\/sanity\/client\/lib\/SwingSet2\/src\/DemoModule.java","additions":4,"deletions":11,"binary":false,"changes":15,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+ * Before this test set to manual, the original timeout\n+ * value if 180\n@@ -32,1 +34,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n@@ -35,1 +37,1 @@\n- * @run main\/othervm\/manual\/timeout=180 -Djava.security.debug=certpath,ocsp\n+ * @run main\/othervm\/manual -Djava.security.debug=certpath,ocsp\n","filename":"test\/jdk\/security\/infra\/java\/security\/cert\/CertPathValidator\/certification\/CAInterop.java","additions":4,"deletions":2,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,0 +26,1 @@\n+import java.util.function.Supplier;\n@@ -42,0 +43,3 @@\n+    private static final String KO_OVERFLOW = \"Some records have not been disposed!\";\n+    private static final String KO_UNDERFLOW = \"Disposed more records than were added!\";\n+\n@@ -43,2 +47,1 @@\n-        TestDisposerRace test = new TestDisposerRace();\n-        test.run();\n+        new TestDisposerRace().run();\n@@ -48,0 +51,1 @@\n+            System.err.println(KO_OVERFLOW); \/\/ In case the next line fails to allocate due to OOME\n@@ -52,0 +56,4 @@\n+    interface ThrowingRunnable<E extends Exception> {\n+        void run() throws E;\n+    }\n+\n@@ -59,3 +67,4 @@\n-            SwingUtilities.invokeAndWait(Disposer::pollRemove);\n-            if (i % 10 == 0) {\n-                \/\/ Adding records will race with the diposer trying to remove them\n+            retryOnOOME(() -> SwingUtilities.invokeAndWait(Disposer::pollRemove));\n+\n+            \/\/ Adding records will race with the diposer trying to remove them\n+            if (i % 10 == 0)\n@@ -63,1 +72,0 @@\n-            }\n@@ -66,1 +74,1 @@\n-        Disposer.addObjectRecord(new Object(), new FinalDisposerRecord());\n+        retryOnOOME(() -> Disposer.addObjectRecord(new Object(), new FinalDisposerRecord()));\n@@ -75,1 +83,26 @@\n-            throw new RuntimeException(\"Disposed more records than were added\");\n+            throw new RuntimeException(KO_UNDERFLOW);\n+        }\n+    }\n+\n+    private static <T> T retryOnOOME(Supplier<T> allocator) {\n+        for(;;) {\n+            try {\n+                return allocator.get();\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n+        }\n+    }\n+\n+    private static <E extends Exception> void retryOnOOME(ThrowingRunnable<E> tr) throws E {\n+        for(;;) {\n+            try {\n+                tr.run();\n+                break;\n+            } catch (OutOfMemoryError ignored1) {\n+                try {\n+                    Thread.sleep(1); \/\/ Give GC a little chance to run\n+                } catch (InterruptedException ignored2) {}\n+            }\n@@ -82,1 +115,1 @@\n-        recordsCount.addAndGet(count);\n+        MyDisposerRecord disposerRecord = retryOnOOME(MyDisposerRecord::new);\n@@ -84,3 +117,5 @@\n-        MyDisposerRecord disposerRecord = new MyDisposerRecord();\n-        for (int i = 0; i < count; i++) {\n-            Disposer.addObjectRecord(new Object(), disposerRecord);\n+        while(count > 0) {\n+            recordsCount.incrementAndGet(); \/\/ pre-add to make sure it doesn't go negative\n+            var o = retryOnOOME(Object::new);\n+            retryOnOOME(() -> Disposer.addObjectRecord(o, disposerRecord));\n+            --count;\n@@ -109,1 +144,0 @@\n-        final List<Object> leak = new LinkedList<>();\n@@ -111,0 +145,1 @@\n+            final List<Object> leak = new LinkedList<>();\n","filename":"test\/jdk\/sun\/java2d\/Disposer\/TestDisposerRace.java","additions":48,"deletions":13,"binary":false,"changes":61,"status":"modified"},{"patch":"@@ -0,0 +1,173 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by JSSE\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=1\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=3\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=10\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=true\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.enableSessionTicketExtension=false -Djdk.tls.client.enableSessionTicketExtension=false\n+ * @run main\/othervm MultiNSTClient -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.enableSessionTicketExtension=true -Djdk.tls.client.enableSessionTicketExtension=true\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs and PSKs are sent by a JSSE server.\n+ * Then JSSE client is able to store them all and resume the connection.  It\n+ * requires specific text in the TLS debugging to verify the success.\n+ *\/\n+\n+public class MultiNSTClient {\n+\n+    static HexFormat hex = HexFormat.of();\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> {\n+                sb.append(a);\n+                sb.append(\" \");\n+            });\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                );\n+\n+            boolean TLS13 = args[0].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTClient\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            System.out.println(\"I'm here\");\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                for (int i = 0; i < 2; i++) {\n+                    String svr = serverPSK.getFirst();\n+                    String cli = clientPSK.getFirst();\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"No MultiNST PSK found.\");\n+                pass = false;\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        SSLSession resumption = resumClient.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  Second getNewSession from original client\");\n+        TLSBase.Client resumClient2 = new TLSBase.Client(initial);\n+        resumption = resumClient2.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(resumption.getId()));\n+        System.out.println(\"session = \" + resumption);\n+        if (!initialSession.toString().equalsIgnoreCase(resumption.toString())) {\n+            throw new Exception(\"Resumed session did not match\");\n+        }\n+\n+        System.out.println(\"------  New client connection\");\n+        TLSBase.Client newConnection = new TLSBase.Client();\n+        SSLSession newSession = newConnection.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(newSession.getId()));\n+        System.out.println(\"session = \" + newSession);\n+        if (initialSession.toString().equalsIgnoreCase(newSession.toString())) {\n+            throw new Exception(\"new session is the same as the initial.\");\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        resumClient2.close();\n+        newConnection.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTClient.java","additions":173,"deletions":0,"binary":false,"changes":173,"status":"added"},{"patch":"@@ -0,0 +1,96 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies resumption fails with 0 NSTs and session creation off\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.3 -Djdk.tls.server.newSessionTicketCount=0\n+ * @run main\/othervm MultiNSTNoSessionCreation -Djdk.tls.client.protocols=TLSv1.2 -Djdk.tls.server.newSessionTicketCount=0\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import java.util.Arrays;\n+\n+\/**\n+ * With no NSTs sent by the server, try to resume the session with\n+ * setEnabledSessionCreation(false).  The test should get an exception and\n+ * fail to connect.\n+ *\/\n+\n+public class MultiNSTNoSessionCreation {\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params);\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTNoSessionCreation\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                if (output.stderrContains(\n+                    \"(PROTOCOL_VERSION): New session creation is disabled\")) {\n+                    return;\n+                }\n+            } catch (RuntimeException e) {\n+                throw new Exception(\"Error collecting data\", e);\n+            }\n+            throw new Exception(\"Disabled creation msg not found\");\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        initial.connect();\n+        System.out.println(\n+            \"------  Resume client w\/ setEnableSessionCreation set to false\");\n+        TLSBase.Client resumClient = new TLSBase.Client(initial);\n+        resumClient.socket.setEnableSessionCreation(false);\n+        resumClient.connect();\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        resumClient.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTNoSessionCreation.java","additions":96,"deletions":0,"binary":false,"changes":96,"status":"added"},{"patch":"@@ -0,0 +1,205 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies multiple PSKs are used by TLSv1.3\n+ * @run main\/othervm MultiNSTParallel 10 -Djdk.tls.client.protocols=TLSv1.3\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.ArrayList;\n+import java.util.HexFormat;\n+import java.util.List;\n+import java.util.concurrent.CountDownLatch;\n+\n+\/**\n+ * This test verifies that parallel resumption connections successfully get\n+ * a PSK entry and not initiate a full handshake.\n+ *\n+ * Note:  THe first argument after 'MultiNSTParallel' is the ticket count\n+ * The test will set 'jdk.tls.server.NewSessionTicketCount` to that number and\n+ * will start the same number of resumption client attempts. The ticket count\n+ * must be the same or larger than resumption attempts otherwise the queue runs\n+ * empty and the test will fail.\n+ *\n+ * Because this test runs parallel connections, the thread order finish is not\n+ * guaranteed.  Each client NST id is checked with all server NSTs ids until\n+ * a match is found.  When a match is found, it is removed from the list to\n+ * verify no NST was used more than once.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTParallel {\n+\n+    static HexFormat hex = HexFormat.of();\n+    final static CountDownLatch wait = new CountDownLatch(1);\n+\n+    static class ClientThread extends Thread {\n+        TLSBase.Client client;\n+\n+        ClientThread(TLSBase.Client c) {\n+            client = c;\n+        }\n+\n+        public void run() {\n+            String name = Thread.currentThread().getName();\n+            SSLSession r;\n+            System.err.println(\"waiting \" + Thread.currentThread().getName());\n+            try {\n+                wait.await();\n+                r = new TLSBase.Client(client).connect().getSession();\n+            } catch (Exception e) {\n+                throw new RuntimeException(name + \": \" +e);\n+            }\n+            StringBuffer sb = new StringBuffer(100);\n+            sb.append(\"(\").append(name).append(\") id = \");\n+            sb.append(hex.formatHex(r.getId()));\n+            sb.append(\"\\n(\").append(name).append(\") session = \").append(r);\n+            if (!client.getSession().toString().equalsIgnoreCase(r.toString())) {\n+                throw new RuntimeException(\"(\" + name +\n+                    \") Resumed session did not match\");\n+            }\n+        }\n+    }\n+\n+    static boolean pass = true;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            int ticketCount = Integer.parseInt(args[0]);\n+            StringBuilder sb = new StringBuilder();\n+            for (int i = 1; i < args.length; i++) {\n+                sb.append(\" \").append(args[i]);\n+            }\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" +\n+                    \" -Djdk.tls.server.newSessionTicketCount=\" + ticketCount +\n+                    params);\n+\n+            boolean TLS13 = args[1].contains(\"1.3\");\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTParallel\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> sp = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> serverPSK = new ArrayList<>(sp.stream().toList());\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+\n+                \/\/ Must search all results as order is not guaranteed.\n+                clientPSK.stream().forEach(cli -> {\n+                    for (int i = 0; i < serverPSK.size(); i++) {\n+                        String svr = serverPSK.get(i);\n+                        if (svr.regionMatches(svr.length() - 16, cli,\n+                            cli.length() - 16, 16)) {\n+                            System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                            serverPSK.remove(i);\n+                            return;\n+                        }\n+                    }\n+                    System.out.println(\"client entry (\" + cli.substring(0, 16) +\n+                        \") not found in server list\");\n+                    pass = false;\n+                });\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Error looking at PSK results.\");\n+                throw new Exception(e);\n+            }\n+\n+            if (TLS13) {\n+                if (!pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            } else {\n+                if (pass) {\n+                    throw new Exception(\"Test failed: \" + params);\n+                }\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        int ticketCount = Integer.parseInt(\n+            System.getProperty(\"jdk.tls.server.newSessionTicketCount\"));\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Start connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+        SSLSession initialSession = initial.getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  getNewSession from original client\");\n+\n+        ArrayList<Thread> slist = new ArrayList<>(ticketCount);\n+\n+        System.out.println(\"tx \" + ticketCount);\n+        for (int i = 0; ticketCount > i; i++) {\n+            Thread t = new ClientThread(initial);\n+            t.setName(\"Iteration \" + i);\n+            slist.add(t);\n+            t.start();\n+        }\n+\n+        wait.countDown();\n+        for (Thread t : slist) {\n+            t.join(1000);\n+            System.err.println(\"released: \" + t.getName());\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTParallel.java","additions":205,"deletions":0,"binary":false,"changes":205,"status":"added"},{"patch":"@@ -0,0 +1,145 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @library \/test\/lib\n+ * @library \/javax\/net\/ssl\/templates\n+ * @bug 8242008\n+ * @summary Verifies sequence of used NST entries from the cache queue.\n+ * @run main\/othervm MultiNSTSequence -Djdk.tls.server.newSessionTicketCount=2\n+ *\/\n+\n+import jdk.test.lib.Utils;\n+import jdk.test.lib.process.OutputAnalyzer;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import javax.net.ssl.SSLSession;\n+import java.util.Arrays;\n+import java.util.HexFormat;\n+import java.util.List;\n+\n+\/**\n+ * This test verifies that multiple NSTs take the oldest PSK from the\n+ * QueueCacheEntry stored in the TLS Session Cache.\n+ *\n+ * Note: Beyond 9 iterations the PSK id verification code becomes complicated\n+ * with a QueueCacheEntry limit set to retain only the 10 newest entries.\n+ *\n+ * TLS 1.2 spec does not specify multiple NST behavior.\n+ *\/\n+\n+public class MultiNSTSequence {\n+\n+    static HexFormat hex = HexFormat.of();\n+    static final int ITERATIONS = 9;\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        if (!args[0].equalsIgnoreCase(\"p\")) {\n+            StringBuilder sb = new StringBuilder();\n+            Arrays.stream(args).forEach(a -> sb.append(a).append(\" \"));\n+            String params = sb.toString();\n+            System.setProperty(\"test.java.opts\",\n+                \"-Dtest.src=\" + System.getProperty(\"test.src\") +\n+                    \" -Dtest.jdk=\" + System.getProperty(\"test.jdk\") +\n+                    \" -Dtest.root=\" + System.getProperty(\"test.root\") +\n+                    \" -Djavax.net.debug=ssl,handshake \" + params\n+                              );\n+\n+            System.out.println(\"test.java.opts: \" +\n+                System.getProperty(\"test.java.opts\"));\n+\n+            ProcessBuilder pb = ProcessTools.createTestJavaProcessBuilder(\n+                Utils.addTestJavaOpts(\"MultiNSTSequence\", \"p\"));\n+\n+            OutputAnalyzer output = ProcessTools.executeProcess(pb);\n+            boolean pass = true;\n+            try {\n+                List<String> list = output.stderrShouldContain(\"MultiNST PSK\").\n+                    asLines().stream().filter(s ->\n+                        s.contains(\"MultiNST PSK\")).toList();\n+                List<String> serverPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Server)\")).toList();\n+                List<String> clientPSK = list.stream().filter(s ->\n+                    s.contains(\"MultiNST PSK (Client)\")).toList();\n+                System.out.println(\"found list: \" + list.size());\n+                System.out.println(\"found server: \" + serverPSK.size());\n+                serverPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                System.out.println(\"found client: \" + clientPSK.size());\n+                clientPSK.stream().forEach(s -> System.out.println(\"\\t\" + s));\n+                int i;\n+                for (i = 0; i < ITERATIONS; i++) {\n+                    String svr = serverPSK.get(i);\n+                    String cli = clientPSK.get(i);\n+                    if (svr.regionMatches(svr.length() - 16, cli, cli.length() - 16, 16)) {\n+                        System.out.println(\"entry \" + (i + 1) + \" match.\");\n+                    } else {\n+                        System.out.println(\"entry \" + (i + 1) + \" server and client PSK didn't match:\");\n+                        System.out.println(\"  server: \" + svr);\n+                        System.out.println(\"  client: \" + cli);\n+                        pass = false;\n+                    }\n+                }\n+            } catch (RuntimeException e) {\n+                System.out.println(\"Server and Client PSK usage order is not\" +\n+                    \" the same.\");\n+                pass = false;\n+            }\n+\n+            if (!pass) {\n+                throw new Exception(\"Test failed: \" + params);\n+            }\n+            System.out.println(\"Test Passed\");\n+            return;\n+        }\n+\n+        TLSBase.Server server = new TLSBase.Server();\n+\n+        System.out.println(\"------  Initial connection\");\n+        TLSBase.Client initial = new TLSBase.Client();\n+\n+        SSLSession initialSession = initial.connect().getSession();\n+        System.out.println(\"id = \" + hex.formatHex(initialSession.getId()));\n+        System.out.println(\"session = \" + initialSession);\n+\n+        System.out.println(\"------  Resume client\");\n+        for (int i = 0; i < ITERATIONS; i++) {\n+            SSLSession r = new TLSBase.Client(initial).connect().getSession();\n+            StringBuilder sb = new StringBuilder(100);\n+            sb.append(\"Iteration: \").append(i);\n+            sb.append(\"\\tid = \").append(hex.formatHex(r.getId()));\n+            sb.append(\"\\tsession = \").append(r);\n+            System.out.println(sb);\n+            if (!initialSession.toString().equalsIgnoreCase(r.toString())) {\n+                throw new Exception(\"Resumed session did not match\");\n+            }\n+        }\n+\n+        System.out.println(\"------  Closing connections\");\n+        initial.close();\n+        server.close();\n+        System.out.println(\"------  End\");\n+        System.exit(0);\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/SSLSessionImpl\/MultiNSTSequence.java","additions":145,"deletions":0,"binary":false,"changes":145,"status":"added"},{"patch":"@@ -0,0 +1,249 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+import java.io.*;\n+import java.math.BigInteger;\n+import java.security.*;\n+import java.security.cert.*;\n+import java.time.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+import sun.security.validator.Validator;\n+import sun.security.validator.ValidatorException;\n+\n+import jdk.test.lib.security.SecurityUtils;\n+\n+\/**\n+ * @test\n+ * @bug 8337664\n+ * @summary Check that TLS Server certificates chaining back to distrusted\n+ *          Entrust roots are invalid\n+ * @library \/test\/lib\n+ * @modules java.base\/sun.security.validator\n+ * @run main\/othervm Distrust after policyOn invalid\n+ * @run main\/othervm Distrust after policyOff valid\n+ * @run main\/othervm Distrust before policyOn valid\n+ * @run main\/othervm Distrust before policyOff valid\n+ *\/\n+\n+public class Distrust {\n+\n+    private static final String TEST_SRC = System.getProperty(\"test.src\", \".\");\n+    private static CertificateFactory cf;\n+\n+    \/\/ Each of the roots have a test certificate chain stored in a file\n+    \/\/ named \"<root>-chain.pem\".\n+    private static String[] rootsToTest = new String[] {\n+        \"entrustevca\", \"entrustrootcaec1\", \"entrustrootcag2\", \"entrustrootcag4\",\n+        \"entrust2048ca\", \"affirmtrustcommercialca\", \"affirmtrustnetworkingca\",\n+        \"affirmtrustpremiumca\", \"affirmtrustpremiumeccca\" };\n+\n+    \/\/ A date that is after the restrictions take effect\n+    private static final Date NOVEMBER_1_2024 =\n+        Date.from(LocalDate.of(2024, 11, 1)\n+                           .atStartOfDay(ZoneOffset.UTC)\n+                           .toInstant());\n+\n+    \/\/ A date that is a second before the restrictions take effect\n+    private static final Date BEFORE_NOVEMBER_1_2024 =\n+        Date.from(LocalDate.of(2024, 11, 1)\n+                           .atStartOfDay(ZoneOffset.UTC)\n+                           .minusSeconds(1)\n+                           .toInstant());\n+\n+    public static void main(String[] args) throws Exception {\n+\n+        cf = CertificateFactory.getInstance(\"X.509\");\n+\n+        boolean before = args[0].equals(\"before\");\n+        boolean policyOn = args[1].equals(\"policyOn\");\n+        boolean isValid = args[2].equals(\"valid\");\n+\n+        if (!policyOn) {\n+            \/\/ disable policy (default is on)\n+            Security.setProperty(\"jdk.security.caDistrustPolicies\", \"\");\n+        }\n+\n+        Date notBefore = before ? BEFORE_NOVEMBER_1_2024 : NOVEMBER_1_2024;\n+\n+        X509TrustManager pkixTM = getTMF(\"PKIX\", null);\n+        X509TrustManager sunX509TM = getTMF(\"SunX509\", null);\n+        for (String test : rootsToTest) {\n+            System.err.println(\"Testing \" + test);\n+            X509Certificate[] chain = loadCertificateChain(test);\n+\n+            testTM(sunX509TM, chain, notBefore, isValid);\n+            testTM(pkixTM, chain, notBefore, isValid);\n+        }\n+    }\n+\n+    private static X509TrustManager getTMF(String type,\n+            PKIXBuilderParameters params) throws Exception {\n+        TrustManagerFactory tmf = TrustManagerFactory.getInstance(type);\n+        if (params == null) {\n+            tmf.init((KeyStore)null);\n+        } else {\n+            tmf.init(new CertPathTrustManagerParameters(params));\n+        }\n+        TrustManager[] tms = tmf.getTrustManagers();\n+        for (TrustManager tm : tms) {\n+            X509TrustManager xtm = (X509TrustManager)tm;\n+            return xtm;\n+        }\n+        throw new Exception(\"No TrustManager for \" + type);\n+    }\n+\n+    private static PKIXBuilderParameters getParams() throws Exception {\n+        PKIXBuilderParameters pbp =\n+            new PKIXBuilderParameters(SecurityUtils.getCacertsKeyStore(),\n+                                      new X509CertSelector());\n+        pbp.setRevocationEnabled(false);\n+        return pbp;\n+    }\n+\n+    private static void testTM(X509TrustManager xtm, X509Certificate[] chain,\n+                               Date notBefore, boolean valid) throws Exception {\n+        \/\/ Check if TLS Server certificate (the first element of the chain)\n+        \/\/ is issued after the specified notBefore date (should be rejected\n+        \/\/ unless distrust property is false). To do this, we need to\n+        \/\/ fake the notBefore date since none of the test certs are issued\n+        \/\/ after then.\n+        chain[0] = new DistrustedTLSServerCert(chain[0], notBefore);\n+\n+        try {\n+            xtm.checkServerTrusted(chain, \"ECDHE_RSA\");\n+            if (!valid) {\n+                throw new Exception(\"chain should be invalid\");\n+            }\n+        } catch (CertificateException ce) {\n+            \/\/ expired TLS certificates should not be treated as failure\n+            if (expired(ce)) {\n+                System.err.println(\"Test is N\/A, chain is expired\");\n+                return;\n+            }\n+            if (valid) {\n+                throw new Exception(\"Unexpected exception, chain \" +\n+                                    \"should be valid\", ce);\n+            }\n+            if (ce instanceof ValidatorException) {\n+                ValidatorException ve = (ValidatorException)ce;\n+                if (ve.getErrorType() != ValidatorException.T_UNTRUSTED_CERT) {\n+                    ce.printStackTrace(System.err);\n+                    throw new Exception(\"Unexpected exception: \" + ce);\n+                }\n+            } else {\n+                throw new Exception(\"Unexpected exception: \" + ce);\n+            }\n+        }\n+    }\n+\n+    \/\/ check if a cause of exception is an expired cert\n+    private static boolean expired(CertificateException ce) {\n+        if (ce instanceof CertificateExpiredException) {\n+            return true;\n+        }\n+        Throwable t = ce.getCause();\n+        while (t != null) {\n+            if (t instanceof CertificateExpiredException) {\n+                return true;\n+            }\n+            t = t.getCause();\n+        }\n+        return false;\n+    }\n+\n+    private static X509Certificate[] loadCertificateChain(String name)\n+            throws Exception {\n+        try (InputStream in = new FileInputStream(TEST_SRC + File.separator +\n+                                                  name + \"-chain.pem\")) {\n+            Collection<X509Certificate> certs =\n+                (Collection<X509Certificate>)cf.generateCertificates(in);\n+            return certs.toArray(new X509Certificate[0]);\n+        }\n+    }\n+\n+    private static class DistrustedTLSServerCert extends X509Certificate {\n+        private final X509Certificate cert;\n+        private final Date notBefore;\n+        DistrustedTLSServerCert(X509Certificate cert, Date notBefore) {\n+            this.cert = cert;\n+            this.notBefore = notBefore;\n+        }\n+        public Set<String> getCriticalExtensionOIDs() {\n+           return cert.getCriticalExtensionOIDs();\n+        }\n+        public byte[] getExtensionValue(String oid) {\n+            return cert.getExtensionValue(oid);\n+        }\n+        public Set<String> getNonCriticalExtensionOIDs() {\n+            return cert.getNonCriticalExtensionOIDs();\n+        }\n+        public boolean hasUnsupportedCriticalExtension() {\n+            return cert.hasUnsupportedCriticalExtension();\n+        }\n+        public void checkValidity() throws CertificateExpiredException,\n+            CertificateNotYetValidException {\n+            \/\/ always pass\n+        }\n+        public void checkValidity(Date date) throws CertificateExpiredException,\n+            CertificateNotYetValidException {\n+            \/\/ always pass\n+        }\n+        public int getVersion() { return cert.getVersion(); }\n+        public BigInteger getSerialNumber() { return cert.getSerialNumber(); }\n+        public Principal getIssuerDN() { return cert.getIssuerDN(); }\n+        public Principal getSubjectDN() { return cert.getSubjectDN(); }\n+        public Date getNotBefore() { return notBefore; }\n+        public Date getNotAfter() { return cert.getNotAfter(); }\n+        public byte[] getTBSCertificate() throws CertificateEncodingException {\n+            return cert.getTBSCertificate();\n+        }\n+        public byte[] getSignature() { return cert.getSignature(); }\n+        public String getSigAlgName() { return cert.getSigAlgName(); }\n+        public String getSigAlgOID() { return cert.getSigAlgOID(); }\n+        public byte[] getSigAlgParams() { return cert.getSigAlgParams(); }\n+        public boolean[] getIssuerUniqueID() {\n+            return cert.getIssuerUniqueID();\n+        }\n+        public boolean[] getSubjectUniqueID() {\n+            return cert.getSubjectUniqueID();\n+        }\n+        public boolean[] getKeyUsage() { return cert.getKeyUsage(); }\n+        public int getBasicConstraints() { return cert.getBasicConstraints(); }\n+        public byte[] getEncoded() throws CertificateEncodingException {\n+            return cert.getEncoded();\n+        }\n+        public void verify(PublicKey key) throws CertificateException,\n+            InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key);\n+        }\n+        public void verify(PublicKey key, String sigProvider) throws\n+            CertificateException, InvalidKeyException, NoSuchAlgorithmException,\n+            NoSuchProviderException, SignatureException {\n+            cert.verify(key, sigProvider);\n+        }\n+        public PublicKey getPublicKey() { return cert.getPublicKey(); }\n+        public String toString() { return cert.toString(); }\n+    }\n+}\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/Distrust.java","additions":249,"deletions":0,"binary":false,"changes":249,"status":"added"},{"patch":"@@ -0,0 +1,77 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 8608355977964138876 (0x7777062726a9b17c)\n+        Signature Algorithm: sha256WithRSAEncryption\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Commercial\n+        Validity\n+            Not Before: Jan 29 14:06:06 2010 GMT\n+            Not After : Dec 31 14:06:06 2030 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHHjCCBgagAwIBAgIQAWZjFOyCvT00u\/gtkCvS2TANBgkqhkiG9w0BAQsFADCB\n+gzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJT\n+ZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhBZmZp\n+cm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYxMB4XDTI0MDYyODIx\n+MzgwNVoXDTI1MDcyODIxMzgwNFowgdgxCzAJBgNVBAYTAkNBMRAwDgYDVQQIEwdP\n+bnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExEzARBgsrBgEEAYI3PAIBAxMCQ0ExGDAW\n+BgsrBgEEAYI3PAIBAhMHT250YXJpbzEcMBoGA1UEChMTQWZmaXJtdHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzI1\n+NDA1NDcxKDAmBgNVBAMTH3ZhbGlkY29tbWVyY2lhbC5hZmZpcm10cnVzdC5jb20w\n+ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQDeIT2XO0hJ5wDSbIiIcMvs\n+P3NpQc7O7v5DqldpME6+Qn2sF5b9hc6j72hgTXREa77uUcP5u1JcMWCSWwYQHMpJ\n+kFzmIzijhS60wW1epb5QyTgM3ZYh1WKvttFCbHUcrTtd+LoPFYsjw9ZK\/\/K9tPp+\n+ddn06\/ivWvUO5y5vn0wrCaB9tuLdDn4RCQzK2XoZdDuqhPlBBogJX0vM6lsXjgLy\n+EbvE+\/sKYps\/In6VtRvCoYavg3OqaIMeaA7gTiYTb1ZGFOAiltnq7fcp6SZUohK3\n+QNihv1DadVc+n8LnEUKKDkgG2YgWEFczaE3qwG3ef6L3MzLGrkgVY+qGHyyv2IE7\n+AgMBAAGjggM1MIIDMTAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBT4ARNL47hAsOpa\n+96VMgKEY3sLIAjAfBgNVHSMEGDAWgBTb72U3C+VHyzXRkB8DwbyIx6fqgDBsBggr\n+BgEFBQcBAQRgMF4wJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3NwLmFmZmlybXRydXN0\n+LmNvbTAzBggrBgEFBQcwAoYnaHR0cDovL2FpYS5hZmZpcm10cnVzdC5jb20vYWZ0\n+ZXYxY2EuY3J0MDwGA1UdHwQ1MDMwMaAvoC2GK2h0dHA6Ly9jcmwuYWZmaXJtdHJ1\n+c3QuY29tL2NybC9hZnRldjFjYS5jcmwwKgYDVR0RBCMwIYIfdmFsaWRjb21tZXJj\n+aWFsLmFmZmlybXRydXN0LmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYI\n+KwYBBQUHAwEGCCsGAQUFBwMCMFYGA1UdIARPME0wBwYFZ4EMAQEwQgYKKwYBBAGC\n+jwkCATA0MDIGCCsGAQUFBwIBFiZodHRwczovL3d3dy5hZmZpcm10cnVzdC5jb20v\n+cmVwb3NpdG9yeTCCAYAGCisGAQQB1nkCBAIEggFwBIIBbAFqAHcAEvFONL1TckyE\n+BhnDjz96E\/jntWKHiJxtMAWE6+WGJjoAAAGQYMi3wQAABAMASDBGAiEAjvdsU4G2\n+o4BZSOOjaH6gOp7zhKtXQByQUvfHfsi2ePcCIQDnnIO2qlHBm+sskUDlXfR0lCUW\n+yFPVr9nFZ0L9YPpozgB2AA3h8jAr0w3BQGISCepVLvxHdHyx1+kw7w5CHrR+Tqo0\n+AAABkGDIt9MAAAQDAEcwRQIhANh1zS3Qeo9yKF+j3G52JhmDRYBS+1TM0wykoXCY\n+llpxAiAG+LAlKSbwwgrboUSTDDXWNeoRYZ7fKbU72kKfHrpZvwB3ABoE\/0nQVB1A\n+r\/agw7\/x2MRnL07s7iNAaJhrF0Au3Il9AAABkGDIt9sAAAQDAEgwRgIhAN8OoC4I\n+zw8bFJy8ACgK40c9ZfsIfFhePTc9CyrL5uDsAiEA4Jn\/IqBB9L5DeTgqw9hBaYag\n+FmY\/2gWDip36ga0WUsAwDQYJKoZIhvcNAQELBQADggEBABywPLJP097Emz6LNeFU\n+\/HvfhaUKv2pgIHf\/Kvjs5x78RK9G605THPEHr\/TeUjNZ4PBd48WBNVWzyd\/8FuOt\n+r+FsYkRJb9CnrOhZHuCwlcdWXvuY8PiuBmT+xB16BWR5yhYbbiGe4hea0Pf6CfHh\n+jJoGJw4dQKfgneZOV7IcaWnNTKYawlcZOgxvEwFvj+iZM31WphEPKRAV+N+Tp+ZR\n+nxlEdjmdbOjqBydlYIEzuFIgxgtnPdK5wqCOWb+z2cARUAO\/AkiWrOLTPDc7ydQK\n+GcfDrSqffHOlwaee08C6STFaJWIcpqxZdXE6Jc+8\/85bfPEAG1UepgfnBTqW9RGT\n+Q3s=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIEqDCCA5CgAwIBAgIQFylVHtaOf7Ht9XMA811\/1TANBgkqhkiG9w0BAQsFADBE\n+MQswCQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxHzAdBgNVBAMMFkFm\n+ZmlybVRydXN0IENvbW1lcmNpYWwwHhcNMTkwMzIxMjAyNzU0WhcNMzAxMjAyMDQw\n+MDAwWjCBgzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYD\n+VQQLEyJTZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQD\n+EyhBZmZpcm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYxMIIBIjAN\n+BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAuPBMIa9VuXJGAw0MHvieGciPFA11\n+b9T49YJ7T+zVpoMMQO+ueUKVHb2l26oeCiwIhXMQ5LquOVcx+rofouzcKXY3wKDZ\n+zHIOnAkU+23Ucn\/3dRH7aHJULsBufZq+NvwgYSgJJEDKfqvIV\/c5HiRyZ2H+nAI5\n+10Q2xC0UxgSBsufccQ+Fwkg6BAGDlTXrvi8wi75UaGue6jv\/qcKLybeVUrgqKE64\n+d9oa9PG5\/g89QwSdsIQEdVSFzFvFpOG9YhJbJ177Zg6DGCxU0lWwFrVpyH\/2vnXl\n+jhMQScn8UxzCJdDg3EDqjgaV0JH2yoLug+QVYgURPu5BEb5ut9vAdP7cLwIDAQAB\n+o4IBVDCCAVAwNwYIKwYBBQUHAQEEKzApMCcGCCsGAQUFBzABhhtodHRwOi8vb2Nz\n+cC5hZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFNvvZTcL5UfLNdGQHwPBvIjHp+qA\n+MBIGA1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUnZPGU4teyq8\/nx4P5ZmV\n+vCT2lI8wRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYIKwYBBQUHAgEWJmh0dHBzOi8v\n+d3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MEkGA1UdHwRCMEAwPqA8oDqG\n+OGh0dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2NybC9BZmZpcm1UcnVzdENvbW1l\n+cmNpYWwuY3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYI\n+KwYBBQUHAwIwDQYJKoZIhvcNAQELBQADggEBAATH11fMrINGmQGQqQW0ATteVnUG\n+LrmRSN2OlmRm+dkUwKXhcQQEfYYlEggPqgvxSUpw13fXSOqVHqAcj3BIqF957kh+\n+m3DmC0RX9KaEKD165pf77P5nZcRmZpBl9cctvzIxN19uzcminchusYwLyeWhBtTZ\n+xpER9LbrfMNaQ7GnrgalMx54QvdjOhw\/GJs9\/SqEzYmPshL+DzgZX\/oAzY63rQIh\n+rBblf6\/2talZqci96oFzNst8rGfPy\/xQ7lgkki1hwIYbORMfloBhP+vAZJo0mxdM\n+ipu3Z0ToK+KU2iqnBxXVr2\/kod+CpkHnjUHa1wnQuSaefng3XwZ\/vqtSL9c=\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustcommercialca-chain.pem","additions":77,"deletions":0,"binary":false,"changes":77,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 8957382827206547757 (0x7c4f04391cd4992d)\n+        Signature Algorithm: sha1WithRSAEncryption\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Networking\n+        Validity\n+            Not Before: Jan 29 14:08:24 2010 GMT\n+            Not After : Dec 31 14:08:24 2030 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHGjCCBgKgAwIBAgIQX2vGPaCJ1tS0ncp2OlBMFjANBgkqhkiG9w0BAQsFADCB\n+gzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJT\n+ZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhBZmZp\n+cm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYzMB4XDTI0MDYyODIx\n+NDU0OVoXDTI1MDcyODIxNDU0OFowgdgxCzAJBgNVBAYTAkNBMRAwDgYDVQQIEwdP\n+bnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExEzARBgsrBgEEAYI3PAIBAxMCQ0ExGDAW\n+BgsrBgEEAYI3PAIBAhMHT250YXJpbzEcMBoGA1UEChMTQWZmaXJtdHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzI1\n+NDA1NDcxKDAmBgNVBAMTH3ZhbGlkbmV0d29ya2luZy5hZmZpcm10cnVzdC5jb20w\n+ggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCkGknE8kFr+CaIybQrDPRw\n+z9OKXq77p4CnrkF1\/g9w\/HiIs6Ps8YqTjsiTKM3wYLbvPA+TbO9DpCSyCP2bVyLf\n+AjUE617KZSpfy9RqzvGjn\/1qH\/cBKohhEliMfDj4ZHfY4x+1WYTZPVK\/g0Ny5RAP\n+wz9lJHR2SsVGLvpqXzWaVoxifJ8HZWD7n5z\/75WeYko+Hubx3WvzJZcN2Xjn+q6a\n+7wkDaXPayrvn5uWGPlOLQHqJ5z7wts21jASMTfJAToFyzH6dGwvqxkP3bVJGJ8AF\n+vtMfqVjcOcjWgmmOEHMPAAqs5QKrYuSLccH6hFTwFEUCdMwVqfloznt2sNUSBoKj\n+AgMBAAGjggMxMIIDLTAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBTrE0z4fRyx9P9M\n+0FfA6VgGkJiYVDAfBgNVHSMEGDAWgBR5HrHJF8cerLHHFNfD6H+8uVCbFTBsBggr\n+BgEFBQcBAQRgMF4wJwYIKwYBBQUHMAGGG2h0dHA6Ly9vY3NwLmFmZmlybXRydXN0\n+LmNvbTAzBggrBgEFBQcwAoYnaHR0cDovL2FpYS5hZmZpcm10cnVzdC5jb20vYWZ0\n+ZXYzY2EuY3J0MDwGA1UdHwQ1MDMwMaAvoC2GK2h0dHA6Ly9jcmwuYWZmaXJtdHJ1\n+c3QuY29tL2NybC9hZnRldjNjYS5jcmwwKgYDVR0RBCMwIYIfdmFsaWRuZXR3b3Jr\n+aW5nLmFmZmlybXRydXN0LmNvbTAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYI\n+KwYBBQUHAwEGCCsGAQUFBwMCMFYGA1UdIARPME0wBwYFZ4EMAQEwQgYKKwYBBAGC\n+jwkCAjA0MDIGCCsGAQUFBwIBFiZodHRwczovL3d3dy5hZmZpcm10cnVzdC5jb20v\n+cmVwb3NpdG9yeTCCAXwGCisGAQQB1nkCBAIEggFsBIIBaAFmAHYADeHyMCvTDcFA\n+YhIJ6lUu\/Ed0fLHX6TDvDkIetH5OqjQAAAGQYM\/MjQAABAMARzBFAiBjnehs1mvh\n+5Xm3uXZ7Bq8gijwiXThwnLSYROQxnWrnbAIhALbgJG+PRZQfzTBbgM\/zAwNsBjhe\n+F5iENnaajJCxzOhaAHUAEvFONL1TckyEBhnDjz96E\/jntWKHiJxtMAWE6+WGJjoA\n+AAGQYM\/MgQAABAMARjBEAiAsWOm1IIjaxQP9uaPI9tQmkiJPUOTrBTsTDO+jkgiG\n++QIgVNhND82rsFGjrtAAHzzgCVzLDUM3zaHxnP\/z3BNuO4QAdQAaBP9J0FQdQK\/2\n+oMO\/8djEZy9O7O4jQGiYaxdALtyJfQAAAZBgz8zLAAAEAwBGMEQCIBIGxtjk7Lw8\n+i+oggK7VrPMNTB632t321cwhEm517BbZAiBws3+uytwh59N6qGJUuSFQnOZNPOPj\n+eQnH2fSdT1J2sDANBgkqhkiG9w0BAQsFAAOCAQEAcSzitESRKlbcUvxvUB7FjK0I\n+CaBU1Nyu0xDFCoG2pmp7GASJz34wtPYfsiX5+j4hDh\/noMcgk7WlD8pzgWYw15Rk\n++5kTv2v4U85y\/JFjzMOHbz64KjQdGebqhjvC\/E\/EXxK+AZf4H574\/w7rbyJ30vFL\n+gNvPF9AxS1MuYIO55jXrHMByKnFoQZgPsmAY\/x+n+OzMxWOdR18PupypCB5TyJZ8\n+pQzwoxmX7qeZHiXyJ8jQUwe1qoQc2SbwfQxfwSPUPSJuQo90N+5nyQMe7vvPBM0Y\n+\/CXaFpfPqh71D4C0Ey+0hYxSt99gYs4P9twUByjIlP0wTyhaoEpt3zw9DdZypQ==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIEqDCCA5CgAwIBAgIQNCSh7Pjwo1\/nRrcBHEPoRDANBgkqhkiG9w0BAQsFADBE\n+MQswCQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxHzAdBgNVBAMMFkFm\n+ZmlybVRydXN0IE5ldHdvcmtpbmcwHhcNMTkwMzIxMjAzODU5WhcNMzAxMjAyMDQw\n+MDAwWjCBgzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYD\n+VQQLEyJTZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQD\n+EyhBZmZpcm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYzMIIBIjAN\n+BgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmHDl\/3xr1qiHoe0Rzb3AGLw56e9J\n+l2a3X59+PAfI5wGBHuK9Dl7XsyoH65X6QIC\/rXyVpuNgKbbwIGHB+rCSplyHzGyC\n+WeM3LXa2q1US7VteeFDS959nxJVRFfwATR9xAK6YTUWQ\/yWdw0dZSm0lQNmEMBwS\n+qi0ufWokiWXZUzWHOu7A6driCohu9sFDwe1INJUPH6uIlovmzGvG3UYbUSymJcjs\n+Ka0fXXX9zukco8exlOIKWRJSNLxKtSSPDVASrGLQ1xi3qkiLTKci3+jKMNDFf1vw\n+foZN99HhUcWKXfr2KlWfANdjTMlsTKCfuhfWl1OBVNHGRrACAQCXI\/ji0wIDAQAB\n+o4IBVDCCAVAwNwYIKwYBBQUHAQEEKzApMCcGCCsGAQUFBzABhhtodHRwOi8vb2Nz\n+cC5hZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFHkesckXxx6ssccU18Pof7y5UJsV\n+MBIGA1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUBx\/S55zawm6iQLSwelAQ\n+UHTEyL0wRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYIKwYBBQUHAgEWJmh0dHBzOi8v\n+d3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MEkGA1UdHwRCMEAwPqA8oDqG\n+OGh0dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2NybC9BZmZpcm1UcnVzdE5ldHdv\n+cmtpbmcuY3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYI\n+KwYBBQUHAwIwDQYJKoZIhvcNAQELBQADggEBAAhmE4I56hNpnWXQ2Si8a\/TgQUZr\n+X5Jlv1LDvl3rkDyfEIHNZ8dth17SakJYJBWHExph\/iIYjCJ9YmeyhghV5rPqT+wF\n+4yyE2ngenIusfnWT2bTpT9u2VZbCNeACE5XnN2UHSA0J9idPjfLuthViWEvSZZUh\n+DJ53bX+exO366nDY4AI7owIyhz8hdsWyhZ\/0ST+eD+kbgd8osd+GdxzRmyKcfl84\n+D1K1uff01T9w2dyUaZglQsFljkaO6xmeXZJsPnhwCp\/HlMHWzhAneUQ7I9FZSOW+\n+WiYbt4RitmBpysadBReikWM4knECzJQ\/fMT9vC0k9BLlqUYRwCH9vr0UnZo=\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustnetworkingca-chain.pem","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,88 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 7893706540734352110 (0x6d8c1446b1a60aee)\n+        Signature Algorithm: sha384WithRSAEncryption\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Premium\n+        Validity\n+            Not Before: Jan 29 14:10:36 2010 GMT\n+            Not After : Dec 31 14:10:36 2040 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIIFjCCBv6gAwIBAgIQQVOTWr7tEAJXmRDkCSxkajANBgkqhkiG9w0BAQsFADCB\n+gzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJT\n+ZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhBZmZp\n+cm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYyMB4XDTI0MDYyODIx\n+NDgyN1oXDTI1MDcyODIxNDgyNlowgdUxCzAJBgNVBAYTAkNBMRAwDgYDVQQIEwdP\n+bnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExEzARBgsrBgEEAYI3PAIBAxMCQ0ExGDAW\n+BgsrBgEEAYI3PAIBAhMHT250YXJpbzEcMBoGA1UEChMTQWZmaXJtdHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzI1\n+NDA1NDcxJTAjBgNVBAMTHHZhbGlkcHJlbWl1bS5hZmZpcm10cnVzdC5jb20wggIi\n+MA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDVRMzwbDq47ivHOKqJdiEJNL2+\n+g9Snj\/BRctqcQTrIV99RP0pmAh5fHg7vnhVsHqc9sRLVcQWTJk9NuRJ2VnDKWsBa\n+Xrp5UWaNjS0vaFA4jzCi1gWzTTZgPTQn3VRG3JP1F5CZb405\/mtWDaw\/CfWkcUqQ\n+VSilqFlJRsjcPCzQh7ZaXAo+FmzJxNSwjxdP6JSYMeTDRCUpSb3T8PypVI1CEmLZ\n+jsxrg5oIZn25591g\/pzgLE56N0stNY4d3q4YD1t5x46RsqYAJYSkk8rcTN+kHzsY\n+VSqaRDyPkGbmuCeJUvW24wJ30yQtXQWA+U0dMYLe7LyglJ7dkOzvWNbqrIcvM8My\n+hxH\/wwVH7e4dL\/1E58yr1BHENUk7Mp9rzIXj496eLkF5G1lMkNnuVRQqCAOW0rPY\n+V0rI8yrCMTK52s4mNjQo2J7JOYdTUvAWZ92MKvEjjhQlMH8eK72Km\/+mkxpsgGmr\n+3c6u+Gom7oI5VaLZ+3p2uWaOsutk1tkzWjhzY4L27hwmIdWujfrWMRx8uxcfoJxX\n+gQ40d1QiSN51BtCPE5UnpLU\/YUxMdzWmtUoGUfYIGVqDVToBnunIFMdmFjC0IrNl\n+hquDQi\/OGMpzuOvxX1FoXb+rRwOhhdrcR0BQqUVRTV0U5LlcsDeNMqmqPE9mzGtJ\n+W69Fsh7crntng\/L72wIDAQABo4IDMDCCAywwDAYDVR0TAQH\/BAIwADAdBgNVHQ4E\n+FgQU3PWyi\/4usZghgahc\/Tj+Q60QLOcwHwYDVR0jBBgwFoAUc3yaOGg8UXxBCP6h\n+HyoetGHbzTwwbAYIKwYBBQUHAQEEYDBeMCcGCCsGAQUFBzABhhtodHRwOi8vb2Nz\n+cC5hZmZpcm10cnVzdC5jb20wMwYIKwYBBQUHMAKGJ2h0dHA6Ly9haWEuYWZmaXJt\n+dHJ1c3QuY29tL2FmdGV2MmNhLmNydDA8BgNVHR8ENTAzMDGgL6AthitodHRwOi8v\n+Y3JsLmFmZmlybXRydXN0LmNvbS9jcmwvYWZ0ZXYyY2EuY3JsMCcGA1UdEQQgMB6C\n+HHZhbGlkcHJlbWl1bS5hZmZpcm10cnVzdC5jb20wDgYDVR0PAQH\/BAQDAgWgMB0G\n+A1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjBWBgNVHSAETzBNMAcGBWeBDAEB\n+MEIGCisGAQQBgo8JAgMwNDAyBggrBgEFBQcCARYmaHR0cHM6Ly93d3cuYWZmaXJt\n+dHJ1c3QuY29tL3JlcG9zaXRvcnkwggF+BgorBgEEAdZ5AgQCBIIBbgSCAWoBaAB2\n+ABoE\/0nQVB1Ar\/agw7\/x2MRnL07s7iNAaJhrF0Au3Il9AAABkGDSN7EAAAQDAEcw\n+RQIgVDWwhv7yG6RNnkMZnVq1YYA7ypn\/GSH0ibUKnESHRpYCIQCY8gyCX7VFONUI\n+QuR8daz7ra2FCUI9TwylrR3eFfIgGgB3AN3cyjSV1+EWBeeVMvrHn\/g9HFDf2wA6\n+FBJ2Ciysu8gqAAABkGDSN5cAAAQDAEgwRgIhAM1edsSyFUKU0Dj1WxTGwziE6fCW\n+g2ByfL8kDrP260YXAiEA6YQOpJf04N13Nn263BxAl+laH9Ar0eo03fArlv743TQA\n+dQAN4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAAAZBg0je+AAAEAwBG\n+MEQCIExqK4katETAQo+H0+ImuNJCSeFEI9C+9wrjhl6ZnWb9AiBwkC1vpLYOIm\/1\n+YCLCQIOmTdg2wf8LITlrQNJA8vbBljANBgkqhkiG9w0BAQsFAAOCAQEASOmPu7ot\n+yl6MoMns19uI6H2KSUjMFh3\/fKMcY\/ettmEYalgrytexFMrLnD2UniBlD+nJEshp\n+5\/z7o0YDiRoiLhMAs7VqIdX3erNu\/ghNh7P2bDnoMWShSoAKxez1XOGL3rRE0NAi\n+DsWCaNRHH9rnC97275sbGnua7ZYg+8BiF62vpJlqjrxDHjGiej8qAWSjztbB43Af\n+bwRscpXTxNkMvOBuRFMH+rSxB8CrOV68W+yxmzPuPxVjM7oJH8Qk5BC53NRqFsVz\n+JhbNfot0+\/drj7JT3jlacUVQcD\/BzDuC3+qczQlLjLdHgQM2\/e4fXsD6C5S6B11d\n+BDx6ipGpaASofA==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFojCCA4qgAwIBAgIQU3HI6weE\/VEI5dTz4yPsRjANBgkqhkiG9w0BAQsFADBB\n+MQswCQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxHDAaBgNVBAMME0Fm\n+ZmlybVRydXN0IFByZW1pdW0wHhcNMTkwMzIxMjA0NjM1WhcNMzAxMjAyMDQwMDAw\n+WjCBgzELMAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQL\n+EyJTZWUgd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTEwLwYDVQQDEyhB\n+ZmZpcm1UcnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVYyMIIBIjANBgkq\n+hkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAvDDZHfxkB1nAGFKdw0VCgV+B\/eBtW1o+\n+bXzwRcpeFh5saDI+tv1RAMrYFq+AJkXCCJopgMF2Wqfv5myE3JMgxEHuuKUpJz7H\n+FprrFckVOGCtJKH8Iy9AWPjBwt8lKmxGJF7EZst+QoVt4hMe0qhL0WEKbATFPe41\n+DcM7UsyQv6Bvpn424uePy3\/1ATIsVL3YmvAbUNR0aqVxYAJzTefvyIet\/761bKGc\n+NyqdOVWFFeTDtr8iL1TBXToAgl0GJ39bFQZsP19VcCpfk9Zj3YHTPRPq5wZOZuUN\n+F7jiBUEi6DaVOi3Wy4vdySHtWPeBHRYif1I6fcUfdCNORMc4ee6KewIDAQABo4IB\n+UTCCAU0wNwYIKwYBBQUHAQEEKzApMCcGCCsGAQUFBzABhhtodHRwOi8vb2NzcC5h\n+ZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFHN8mjhoPFF8QQj+oR8qHrRh2808MBIG\n+A1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgwFoAUncBnpgwi2Sb1RaumZVIRJ9hF\n+rGMwRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYIKwYBBQUHAgEWJmh0dHBzOi8vd3d3\n+LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MEYGA1UdHwQ\/MD0wO6A5oDeGNWh0\n+dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2NybC9BZmZpcm1UcnVzdFByZW1pdW0u\n+Y3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNVHSUEFjAUBggrBgEFBQcDAQYIKwYBBQUH\n+AwIwDQYJKoZIhvcNAQELBQADggIBABi64UEwl3l0yIiuSACyVQQIBI60BUmhseac\n+4BzCAsJrR5tE\/2U9QAa2y6JpR1nqm76DJvw1QQgvFcNe+fkwpvoViCaSTbZkGGwD\n+mQe2xRSYJcDSMQUc\/GgzLcX2c1CrexQXE1vwV\/q33af1en5s1GzLl915aNS\/k1ch\n+G7EMruJ\/D4cuH9j4j2i+b+llmVBzavBwelN5rc693o+Ot9id\/1sTWNugwAu3uXGb\n+VlhETMnjXGIciegOLdWYhWBln0izYlt9IwlDEpjMVaZ0HZlj2JBGaSe4PfEFpJPO\n+beuPcQpLQGw2XpW2ZMG5JcRYaoKWjixXAGktRA3H9nvVW92jvzx\/RX484w2ZM5Rt\n+E+I1ikAuQLAyWG7clht387e2RuC3NZTtefSyjE3L9gQDOPC+Z9ycwr0WJHRsxFvh\n+FJQi3JnxgFZf5mc5n2mh3qAgALTNOUHuDiHrerjTOWbpF\/1\/NJmo\/c\/YZ63vZIhc\n+EaER4HuhbBqlpf6z3WOIQdZm1ChwXYHrEcLDgfwm9cXoaVK2HZapkMwQbPffPlT1\n+E+AxRFB4YmT1y2WzdaHfhFA9nH6ByUdL5+FfrDoIIUO2e8OLOAcrJsf5+unhAhc0\n+v7N48JWdmpstjkXCaCIaidrZLJxS+pikNgHB1dXF\/TxokLTiPB9jcYKdGaYs3XHb\n+YKLdwubu\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumca-chain.pem","additions":88,"deletions":0,"binary":false,"changes":88,"status":"added"},{"patch":"@@ -0,0 +1,63 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 8401224907861490260 (0x7497258ac73f7a54)\n+        Signature Algorithm: ecdsa-with-SHA384\n+        Issuer: C=US, O=AffirmTrust, CN=AffirmTrust Premium ECC\n+        Validity\n+            Not Before: Jan 29 14:20:24 2010 GMT\n+            Not After : Dec 31 14:20:24 2040 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIF0zCCBVmgAwIBAgIQFVwk9nYUM5SYOnBd+IoGtzAKBggqhkjOPQQDAzCBhTEL\n+MAkGA1UEBhMCQ0ExFDASBgNVBAoTC0FmZmlybVRydXN0MSswKQYDVQQLEyJTZWUg\n+d3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5MTMwMQYDVQQDEypBZmZpcm1U\n+cnVzdCBFeHRlbmRlZCBWYWxpZGF0aW9uIENBIC0gRVZFQzEwHhcNMjQwNjI4MjE0\n+OTUwWhcNMjUwNzI4MjE0OTQ4WjCB2DELMAkGA1UEBhMCQ0ExEDAOBgNVBAgTB09u\n+dGFyaW8xDzANBgNVBAcTBk90dGF3YTETMBEGCysGAQQBgjc8AgEDEwJDQTEYMBYG\n+CysGAQQBgjc8AgECEwdPbnRhcmlvMRwwGgYDVQQKExNBZmZpcm10cnVzdCBMaW1p\n+dGVkMR0wGwYDVQQPExRQcml2YXRlIE9yZ2FuaXphdGlvbjEQMA4GA1UEBRMHMjU0\n+MDU0NzEoMCYGA1UEAxMfdmFsaWRwcmVtaXVtZWNjLmFmZmlybXRydXN0LmNvbTB2\n+MBAGByqGSM49AgEGBSuBBAAiA2IABEkLBzBYSJPRENKDaA1iBPQz+jZUV+OoM9nJ\n+sr9sMfmHaqr3nlWxAMM99b9\/usVfYyUxqyi+YL2Z3ZSxjX2dpyhwMtPpIQkL1pMW\n+Iv55XBIcYRyl2NjcADS9B06G+nnix6OCAzcwggMzMAwGA1UdEwEB\/wQCMAAwHQYD\n+VR0OBBYEFP+37ywf2YJJ\/4CEVy1GY4ioGm1yMB8GA1UdIwQYMBaAFMaQjAKD113j\n+vjucLtVlfSoQYO7lMG4GCCsGAQUFBwEBBGIwYDAnBggrBgEFBQcwAYYbaHR0cDov\n+L29jc3AuYWZmaXJtdHJ1c3QuY29tMDUGCCsGAQUFBzAChilodHRwOi8vYWlhLmFm\n+ZmlybXRydXN0LmNvbS9hZnRldmVjMWNhLmNydDA+BgNVHR8ENzA1MDOgMaAvhi1o\n+dHRwOi8vY3JsLmFmZmlybXRydXN0LmNvbS9jcmwvYWZ0ZXZlYzFjYS5jcmwwKgYD\n+VR0RBCMwIYIfdmFsaWRwcmVtaXVtZWNjLmFmZmlybXRydXN0LmNvbTAOBgNVHQ8B\n+Af8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMFYGA1UdIARP\n+ME0wBwYFZ4EMAQEwQgYKKwYBBAGCjwkCBDA0MDIGCCsGAQUFBwIBFiZodHRwczov\n+L3d3dy5hZmZpcm10cnVzdC5jb20vcmVwb3NpdG9yeTCCAX4GCisGAQQB1nkCBAIE\n+ggFuBIIBagFoAHUA5tIxY0B3jMEQQQbXcbnOwdJA9paEhvu6hzId\/R43jlAAAAGQ\n+YNN5tQAABAMARjBEAiAnainEoBGI9czVh+c9QLPL30S3Rtov8zrnhlXfeKLzZQIg\n+UGkntBMux0MqHt9Aj60qMsS\/C4ZWF7AihVVaUKcrEVgAdgAN4fIwK9MNwUBiEgnq\n+VS78R3R8sdfpMO8OQh60fk6qNAAAAZBg03m1AAAEAwBHMEUCIGI9kBByoozH4cfS\n+ECW\/O2N\/ElkdATkt7EwQ52kcc4ICAiEA9QTh8JlJTb\/ytYC1ECX0vQbrYVexg+fu\n+dw7dfToF9nAAdwAS8U40vVNyTIQGGcOPP3oT+Oe1YoeInG0wBYTr5YYmOgAAAZBg\n+03ndAAAEAwBIMEYCIQCox5nSCcVB2AfNYXco77zsJnYP7KAU2I4VA2GNL7I4wQIh\n+AP6WEzyfBoGpYYqFmNnJUavyhKBmeNiR7eNtaFwpSc+UMAoGCCqGSM49BAMDA2gA\n+MGUCMAGSNMXAAKDRk0ZOtydN95Rkja97+70TatCIIxEAsJD8Hu7lfj2LHCYFQjVY\n+oaWTrQIxAKUudx7E\/JnjsthuL6sNqKVHfD3iLUJyQNK9wE0SVt1xAm7Cu1JXZORE\n+M64KMKoQFQ==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIDXDCCAuKgAwIBAgIQAgKlhME0Bk3J8y0gfqNymDAKBggqhkjOPQQDAzBFMQsw\n+CQYDVQQGEwJVUzEUMBIGA1UECgwLQWZmaXJtVHJ1c3QxIDAeBgNVBAMMF0FmZmly\n+bVRydXN0IFByZW1pdW0gRUNDMB4XDTE5MDMyMTIwNTUwN1oXDTMwMTIwMjA0MDAw\n+MFowgYUxCzAJBgNVBAYTAkNBMRQwEgYDVQQKEwtBZmZpcm1UcnVzdDErMCkGA1UE\n+CxMiU2VlIHd3dy5hZmZpcm10cnVzdC5jb20vcmVwb3NpdG9yeTEzMDEGA1UEAxMq\n+QWZmaXJtVHJ1c3QgRXh0ZW5kZWQgVmFsaWRhdGlvbiBDQSAtIEVWRUMxMHYwEAYH\n+KoZIzj0CAQYFK4EEACIDYgAEu9f5NkumdaVlmaNaxpDB+rBk\/S6lhqcUU1zTLcRz\n+4G0dr4290hezjrvZJxGJ\/X15aexpdD2V9cwaPD\/yuEJcaaz+rg\/qDoqQF3+AFqVc\n+41jw1E0S59+57XVKLtXI7Xh6o4IBVDCCAVAwNwYIKwYBBQUHAQEEKzApMCcGCCsG\n+AQUFBzABhhtodHRwOi8vb2NzcC5hZmZpcm10cnVzdC5jb20wHQYDVR0OBBYEFMaQ\n+jAKD113jvjucLtVlfSoQYO7lMBIGA1UdEwEB\/wQIMAYBAf8CAQAwHwYDVR0jBBgw\n+FoAUmq8pesARNTUmUTAAw2r+QNWu1jwwRwYDVR0gBEAwPjA8BgRVHSAAMDQwMgYI\n+KwYBBQUHAgEWJmh0dHBzOi8vd3d3LmFmZmlybXRydXN0LmNvbS9yZXBvc2l0b3J5\n+MEkGA1UdHwRCMEAwPqA8oDqGOGh0dHA6Ly9jcmwuYWZmaXJtdHJ1c3QuY29tL2Ny\n+bC9BZmZpcm1UcnVzdFByZW1pdW1FQ0MuY3JsMA4GA1UdDwEB\/wQEAwIBhjAdBgNV\n+HSUEFjAUBggrBgEFBQcDAQYIKwYBBQUHAwIwCgYIKoZIzj0EAwMDaAAwZQIwHJ5g\n+a6sHvQ51DGr0bWq34awuwlWbybC2grHoNp5uYapcXr\/qTJusb\/6n+dczqFdaAjEA\n+7VQY06fE9ifMnTgT9824jc3+H6kfhMk4PoIj9ouWdYfc1DyTBS\/low9Hb8liQyFr\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/affirmtrustpremiumeccca-chain.pem","additions":63,"deletions":0,"binary":false,"changes":63,"status":"added"},{"patch":"@@ -0,0 +1,76 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 946069240 (0x3863def8)\n+        Signature Algorithm: sha1WithRSAEncryption\n+        Issuer: O=Entrust.net, OU=www.entrust.net\/CPS_2048 incorp. by ref. (limits liab.), OU=(c) 1999 Entrust.net Limited, CN=Entrust.net Certification Authority (2048)\n+        Validity\n+            Not Before: Dec 24 17:50:51 1999 GMT\n+            Not After : Jul 24 14:15:12 2029 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIGiDCCBXCgAwIBAgIQS5P8oVcgTBT74PnIwDQivjANBgkqhkiG9w0BAQsFADCB\n+ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\n+H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\n+MDEyIEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\n+A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxSzAeFw0y\n+MzEwMDIxOTE4MTBaFw0yNDExMDIxOTE4MDlaMGkxCzAJBgNVBAYTAkNBMRAwDgYD\n+VQQIEwdPbnRhcmlvMQ8wDQYDVQQHEwZPdHRhd2ExGDAWBgNVBAoTD0VudHJ1c3Qg\n+TGltaXRlZDEdMBsGA1UEAxMUMjA0OHRlc3QuZW50cnVzdC5uZXQwggEiMA0GCSqG\n+SIb3DQEBAQUAA4IBDwAwggEKAoIBAQCgkrsKoDEHyJjll\/fu7mjvtbookb50rzTI\n+i+jQzvtL8AJOcCfxJL1cVriufc\/zRYdSQeRJxkbUb+SqIJkec+27onPpY3xOjJAK\n+bWdmac1Iv9JPXYMpKJXnOGrooeXEtCcKSKphx4VhHnLA67BGfSNfHLm4JwghX4jY\n+VpZ8P89gmh8l1eLRP+b3y7OzEkFliwmErALSD8i\/bkzE+GxYMnpg\/HI2Iw1lakxE\n+wZOg0ydgl7jHWZUDdnxhAvLS\/hfzPVhi9ZwgoXQJiUXUp0JJo6QgVOIC5IztpdZa\n+3HW1VK7a0eTLhmdFRx39ARn\/GbbIyoIqUzLOhAa2cbsGIJjtXjhrAgMBAAGjggLY\n+MIIC1DAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBRHn0CebGnHRqTZTeTYCbPHhiVB\n+MzAfBgNVHSMEGDAWgBSConB03bxTP8971PfNf6dgxgpMvzBoBggrBgEFBQcBAQRc\n+MFowIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3QubmV0MDMGCCsGAQUF\n+BzAChidodHRwOi8vYWlhLmVudHJ1c3QubmV0L2wxay1jaGFpbjI1Ni5jZXIwMwYD\n+VR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9sZXZlbDFrLmNy\n+bDAfBgNVHREEGDAWghQyMDQ4dGVzdC5lbnRydXN0Lm5ldDAOBgNVHQ8BAf8EBAMC\n+BaAwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMBMGA1UdIAQMMAowCAYG\n+Z4EMAQICMIIBfgYKKwYBBAHWeQIEAgSCAW4EggFqAWgAdwA\/F0tP1yJHWJQdZRyE\n+vg0S7ZA3fx+FauvBvyiF7PhkbgAAAYrx05lbAAAEAwBIMEYCIQDbMXKdzSr90jM+\n+TekjpqVTEBDDvub7+AEx\/kQYzf9gugIhAKPCjJmIh1NZrKkwK8MsOEL4jkN6FJ\/h\n+4kiiJoze3fB\/AHYAdv+IPwq2+5VRwmHM9Ye6NLSkzbsp3GhCCp\/mZ0xaOnQAAAGK\n+8dOZVAAABAMARzBFAiAW11p7sV2byjrpk6AMQrMGwV2CuT3AKNuQVyxva7XQPAIh\n+AP1P7DfYsZ1aR12Tkg2x2BYjFrlsJCl36n5I\/565xQk4AHUA2ra\/az+1tiKfm8K7\n+XGvocJFxbLtRhIU0vaQ9MEjX+6sAAAGK8dOZnwAABAMARjBEAiA43NURCcnHNpkH\n+XggwpVY9QYNIEAjpHEcPmyXJuQ9y8QIgPqx0MnlKXLuJVReuI5Hzc3iFtcYo070d\n+UYWH2AuVaFwwDQYJKoZIhvcNAQELBQADggEBAIZoSHApNF6DNYvGKHZJX411QkA0\n+5zkq3dcm95BFomaqroEp1QeUeQ8e6xofUs84CURzopE9P81JBHX2Qzb\/VeBzZOKy\n+dekaoz4NGW5ZvpMh7HXXaUpHKU\/xZ5uUHVSatBU+cnidPhgn1czntqOwjzsgEZNW\n+\/wbPEjqvIrZvAW4DPak\/MSwlENys4ty5gX4453S5gwd18b+NFBq44O\/FofR8bvWU\n+3lJ3VcVeONDzTcXPv+Yd1SlyO1\/eXdWlFqloYFjkpcQ4wSLbOEeiWWITkZ0xCAxQ\n+j8uWuDOSyFQLpaPJvEuG1dlho7RZdor0flUIxYfqg2Nr4Svq1ezskwrdQm0=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFKjCCBBKgAwIBAgIQLgRRzl0kJMcrXWV2cWUG2DANBgkqhkiG9w0BAQsFADCB\n+tDEUMBIGA1UEChMLRW50cnVzdC5uZXQxQDA+BgNVBAsUN3d3dy5lbnRydXN0Lm5l\n+dC9DUFNfMjA0OCBpbmNvcnAuIGJ5IHJlZi4gKGxpbWl0cyBsaWFiLikxJTAjBgNV\n+BAsTHChjKSAxOTk5IEVudHJ1c3QubmV0IExpbWl0ZWQxMzAxBgNVBAMTKkVudHJ1\n+c3QubmV0IENlcnRpZmljYXRpb24gQXV0aG9yaXR5ICgyMDQ4KTAeFw0yMjExMjUy\n+MTE5NDNaFw0yOTA3MjMwMDAwMDBaMIG6MQswCQYDVQQGEwJVUzEWMBQGA1UEChMN\n+RW50cnVzdCwgSW5jLjEoMCYGA1UECxMfU2VlIHd3dy5lbnRydXN0Lm5ldC9sZWdh\n+bC10ZXJtczE5MDcGA1UECxMwKGMpIDIwMTIgRW50cnVzdCwgSW5jLiAtIGZvciBh\n+dXRob3JpemVkIHVzZSBvbmx5MS4wLAYDVQQDEyVFbnRydXN0IENlcnRpZmljYXRp\n+b24gQXV0aG9yaXR5IC0gTDFLMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKC\n+AQEA2j+W0E25L0Tn2zlem1DuXKVh2kFnUwmqAJqOV38pa9vH4SEkqjrQjUcj0u1y\n+FvCRIdJdt7hLqIOPt5EyaM\/OJZMssn2XyP7BtBe6CZ4DkJN7fEmDImiKm95HwzGY\n+ei59QAvS7z7Tsoyqj0ip\/wDoKVgG97aTWpRzJiatWA7lQrjV6nN5ZGhTJbiEz5R6\n+rgZFDKNrTdDGvuoYpDbwkrK6HIiPOlJ\/915tgxyd8B\/lw9bdpXiSPbBtLOrJz5RB\n+GXFEaLpHPATpXbo+8DX3Fbae8i4VHj9HyMg4p3NFXU2wO7GOFyk36t0FASK7lDYq\n+jVs1\/lMZLwhGwSqzGmIdTivZGwIDAQABo4IBLjCCASowEgYDVR0TAQH\/BAgwBgEB\n+\/wIBADAdBgNVHQ4EFgQUgqJwdN28Uz\/Pe9T3zX+nYMYKTL8wHwYDVR0jBBgwFoAU\n+VeSB0RGAvtiJuQijMfmhJAkWuXAwMwYIKwYBBQUHAQEEJzAlMCMGCCsGAQUFBzAB\n+hhdodHRwOi8vb2NzcC5lbnRydXN0Lm5ldDAyBgNVHR8EKzApMCegJaAjhiFodHRw\n+Oi8vY3JsLmVudHJ1c3QubmV0LzIwNDhjYS5jcmwwDgYDVR0PAQH\/BAQDAgEGMB0G\n+A1UdJQQWMBQGCCsGAQUFBwMBBggrBgEFBQcDAjA8BgNVHSAENTAzMDEGBFUdIAAw\n+KTAnBggrBgEFBQcCARYbaHR0cHM6Ly93d3cuZW50cnVzdC5uZXQvcnBhMA0GCSqG\n+SIb3DQEBCwUAA4IBAQAuAlHLO8CoKt2a4I23UDkKc7kQI3nUkWqq2RxRh8a\/4TEF\n+C9WSF03EHVBW9JZZcrZ3ZdTDRsNF8vSqmCABz1FLu6vw3D3bEXELonAYlkmeFFV7\n+1hiW9AdyMJD92XsXiU0Yr9J76Tk4iknMTTHiZXdZOcPMOXlMwPy++HS5tTIyqO0d\n+zl1PS8tlCcZrKaNNKbmiIWPhmBUSog9IQt2VKpoAIP8tlvRt5tHf5qW5m7vp7qmG\n+HF2ou54+qQIXO6jIP8CQ4xWvj0aiLklTNMkvXesaVq0xzNgRkx9ZzhREfbuM6eWc\n+GQHwG7m+JmfL+u1dCAZhh4Uyn5oLU9gogFM6v4jX\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrust2048ca-chain.pem","additions":76,"deletions":0,"binary":false,"changes":76,"status":"added"},{"patch":"@@ -0,0 +1,79 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 1164660820 (0x456b5054)\n+        Signature Algorithm: sha1WithRSAEncryption\n+        Issuer: C=US, O=Entrust, Inc., OU=www.entrust.net\/CPS is incorporated by reference, OU=(c) 2006 Entrust, Inc., CN=Entrust Root Certification Authority\n+        Validity\n+            Not Before: Nov 27 20:23:42 2006 GMT\n+            Not After : Nov 27 20:53:42 2026 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHEjCCBfqgAwIBAgIQFhH4VGskTR+tQK3JbN63kTANBgkqhkiG9w0BAQsFADCB\n+sTELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xOTA3BgNVBAsT\n+MHd3dy5lbnRydXN0Lm5ldC9ycGEgaXMgaW5jb3Jwb3JhdGVkIGJ5IHJlZmVyZW5j\n+ZTEfMB0GA1UECxMWKGMpIDIwMDkgRW50cnVzdCwgSW5jLjEuMCwGA1UEAxMlRW50\n+cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxRTAeFw0yNDA2MjgyMTQw\n+NDVaFw0yNTA3MjgyMTQwNDRaMIHIMQswCQYDVQQGEwJDQTEQMA4GA1UECBMHT250\n+YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMTAkNBMRgwFgYL\n+KwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3QgTGltaXRlZDEd\n+MBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEDAOBgNVBAUTBzE5MTM2MDUx\n+HDAaBgNVBAMTE3ZhbGlkZXYuZW50cnVzdC5uZXQwggEiMA0GCSqGSIb3DQEBAQUA\n+A4IBDwAwggEKAoIBAQDL2vkrBEZ5qeVdac1C01bcNnoeCU3AVU3Fh1Ifldic9\/Gw\n+xqNVOFYQNzTk8M62FnPUvas4MnXmeBkPhhym+dnjsM22EeS2p6gTlvOGtJFVr+Ix\n+vq1UAKtqK0gYGriW6SexroSYiG1O0aeqEnKSLlEBHYhmacj2jlbx0ToxMfdBMRRq\n+4UjnIrh\/CBochxt7aKv525tChnZGMT06QKAjx71w2cou0C05v83KJ75EI4EAmTfE\n+z9sKJeST5pH5MI3WKcP6ZmXynKYSIpIGb4Z8B9Ftp8HdzdR9EafOSlRlbIkEn3lm\n+nq4UCph48\/PsUcJoViBCoY6zDLcPGt3gGQVIjq3vAgMBAAGjggMLMIIDBzAMBgNV\n+HRMBAf8EAjAAMB0GA1UdDgQWBBRF6MZkqXf3sICXuvbrBH1R9I8bAjAfBgNVHSME\n+GDAWgBRbQYqyxEPBvb\/IVEFVneCWrf+5oTBlBggrBgEFBQcBAQRZMFcwIwYIKwYB\n+BQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3QubmV0MDAGCCsGAQUFBzAChiRodHRw\n+Oi8vYWlhLmVudHJ1c3QubmV0L2wxZS1jaGFpbi5jZXIwMwYDVR0fBCwwKjAooCag\n+JIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9sZXZlbDFlLmNybDAeBgNVHREEFzAV\n+ghN2YWxpZGV2LmVudHJ1c3QubmV0MA4GA1UdDwEB\/wQEAwIFoDAdBgNVHSUEFjAU\n+BggrBgEFBQcDAQYIKwYBBQUHAwIwSwYDVR0gBEQwQjAHBgVngQwBATA3BgpghkgB\n+hvpsCgECMCkwJwYIKwYBBQUHAgEWG2h0dHBzOi8vd3d3LmVudHJ1c3QubmV0L3Jw\n+YTCCAX0GCisGAQQB1nkCBAIEggFtBIIBaQFnAHUAEvFONL1TckyEBhnDjz96E\/jn\n+tWKHiJxtMAWE6+WGJjoAAAGQYMsp8gAABAMARjBEAiAL794Fw7wyzricvRl+2AON\n+FbGf2hwDB3wh8RkGLBRQ7AIgTCarii0atho7ZeUO3h66Ug7s7WxnF9onDZrtoMrH\n+U9MAdQAN4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAAAZBgyyoMAAAE\n+AwBGMEQCIFaXc4M9C9mNukrV68Sc2E5lw9srQ80nMBCGseY99nFxAiAppQmR9FKC\n+TE\/ROlgZRfimx61W4k+SaQ52eek4JNWXXwB3ABoE\/0nQVB1Ar\/agw7\/x2MRnL07s\n+7iNAaJhrF0Au3Il9AAABkGDLKi0AAAQDAEgwRgIhAPFUevU47H5uJqYL5y1ClFS7\n+mEve7E8350JKnR1VykGLAiEArn7VAJcmRNNCDAegsHCCLlpasz9PLHFd9XHQAwvL\n+IFwwDQYJKoZIhvcNAQELBQADggEBAHfMCQP5Y+7IYzqOh5D\/81WqHagmWOqkJYsN\n+33uux44fhVGqiG1O5ImTQsxJpt\/HmDuK1qLEjG31Y9q89U91KAqLQauCQ5iMXrBg\n+TlwK8kzO1XYC5KkpO5ZWanqfjOahM9mkEKHPV9srwj6xTbInCq9DabRwuWyohj3b\n+EKrmB016TOT0hJ94jCb8PWl15oQJdsGlEfrG7amtDSRuoDHVA3nXJIJqx5LVnErB\n+glfsAmP8TPkWYY8kuNE2Rjr2M6P5LRLEvtRELCQF3lPuY0+xxGksGVM207YqhYKv\n+GzMmA8c7tF3ZclbE0rUA2T8FuBuweAV8tnWq2TaeAHWIJ4nY17s=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFHjCCBAagAwIBAgIRAIZmsCrBy1RAAAAAAFHTWJwwDQYJKoZIhvcNAQELBQAw\n+gbAxCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMTkwNwYDVQQL\n+EzB3d3cuZW50cnVzdC5uZXQvQ1BTIGlzIGluY29ycG9yYXRlZCBieSByZWZlcmVu\n+Y2UxHzAdBgNVBAsTFihjKSAyMDA2IEVudHJ1c3QsIEluYy4xLTArBgNVBAMTJEVu\n+dHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0xOTA2MTkxNjUy\n+MDhaFw0yNjExMTkxNzIyMDhaMIGxMQswCQYDVQQGEwJVUzEWMBQGA1UEChMNRW50\n+cnVzdCwgSW5jLjE5MDcGA1UECxMwd3d3LmVudHJ1c3QubmV0L3JwYSBpcyBpbmNv\n+cnBvcmF0ZWQgYnkgcmVmZXJlbmNlMR8wHQYDVQQLExYoYykgMjAwOSBFbnRydXN0\n+LCBJbmMuMS4wLAYDVQQDEyVFbnRydXN0IENlcnRpZmljYXRpb24gQXV0aG9yaXR5\n+IC0gTDFFMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAtlsEVHfdDiRm\n+3Cqh24DMXcdf\/VIWWNpflAapuLa5YwxHIILsx5VOi7h3Umo9tYep1uHMdOWmyMDU\n+Vk+NLtYIPgxMQz7wQZNeRu8559llKgx2UCe9Ww0zMwfg96KpnOERM61m\/NIseqqj\n+cxa+k4V1D9c3jPojt2T440xu7bMFveI223zedkTagnJ2tm7\/lKHQhvcQzUpai7B1\n+jGZSgE5ITEmDpkDXd4ETTV5yfkhGIqoP4j5llDjhcnH+SnEJujV\/VYk9gdW4KAEQ\n+dzZaEIXSvWCEK0lhlAzeTEBqKsR5YIQkgjJpSphL4lYQugNFUSDTz9qOVBtFtnq6\n+l5pa2MbRXwIDAQABo4IBLjCCASowDgYDVR0PAQH\/BAQDAgGGMB0GA1UdJQQWMBQG\n+CCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH\/AgEAMDMGCCsGAQUF\n+BwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuZW50cnVzdC5uZXQwMwYD\n+VR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9yb290Y2ExLmNy\n+bDA7BgNVHSAENDAyMDAGBFUdIAAwKDAmBggrBgEFBQcCARYaaHR0cDovL3d3dy5l\n+bnRydXN0Lm5ldC9ycGEwHQYDVR0OBBYEFFtBirLEQ8G9v8hUQVWd4Jat\/7mhMB8G\n+A1UdIwQYMBaAFGiQ5GekplOAx4ZmpPH3S0P7hL1tMA0GCSqGSIb3DQEBCwUAA4IB\n+AQAPUNBX97sqIXZl\/zLu53iv7a0HK7prvD0cVaZM0yRfVptvARgjIZZzTtv32v6X\n+wSr4fDeRmpLaTWtipBGSqh3fNkTSVT8GGBq6+h1lrPEYv6jnStDf7VLQxVliKt2w\n+h34JjgRUx9rdia30tk\/EpPavkxxPks8vjoLN3f4dbkIY\/sfljyZbseqVLx9kl\/we\n+OvqL6jZgaQOapFQLZJze7VwLiPVuUnW8ddK3JIE1a5YCZs0irIW5+96ttznIgPK2\n+aUOmHQp\/zasi7SFl49HrKGKWtZuyDB9U56e01H6PDTpSSSTPyLsSVg3JALHBPDzS\n+bBraAU3wuAyc3BQ4OIOmwwnT\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustevca-chain.pem","additions":79,"deletions":0,"binary":false,"changes":79,"status":"added"},{"patch":"@@ -0,0 +1,66 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number:\n+            a6:8b:79:29:00:00:00:00:50:d0:91:f9\n+        Signature Algorithm: ecdsa-with-SHA384\n+        Issuer: C=US, O=Entrust, Inc., OU=See www.entrust.net\/legal-terms, OU=(c) 2012 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - EC1\n+        Validity\n+            Not Before: Dec 18 15:25:36 2012 GMT\n+            Not After : Dec 18 15:55:36 2037 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIFzDCCBVOgAwIBAgIQcbNJ8XJLeT3fV8DU3QNYSDAKBggqhkjOPQQDAzCBujEL\n+MAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1Nl\n+ZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDE2\n+IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwGA1UE\n+AxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxSjAeFw0yNDA2\n+MjgyMTM5MzVaFw0yNTA3MjgyMTM5MzRaMIHLMQswCQYDVQQGEwJDQTEQMA4GA1UE\n+CBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMTAkNB\n+MRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3QgTGlt\n+aXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEzARBgNVBAUTCjEw\n+MDA0OTI4NzkxHDAaBgNVBAMTE3ZhbGlkZWMuZW50cnVzdC5uZXQwdjAQBgcqhkjO\n+PQIBBgUrgQQAIgNiAAS90ZyZ86Gl5Fh1qJ\/70UwyQWATu3igiQLeVVvZ4G79SBEG\n+Xc4TcAn0LzBhfJonAzWFkAS860ARjvFHgUj0otyT+Q2\/zC9c8CjOsL3bYp3SNUbC\n+FWBhIV0vhGGY8NafeXCjggMJMIIDBTAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBTP\n+DXJE\/iZfi5wUSAo4GN4thBCCHDAfBgNVHSMEGDAWgBTD+UUDvsj5CzxFNfPrcuzn\n+6OuUmzBjBggrBgEFBQcBAQRXMFUwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVu\n+dHJ1c3QubmV0MC4GCCsGAQUFBzAChiJodHRwOi8vYWlhLmVudHJ1c3QubmV0L2wx\n+ai1lYzEuY2VyMDMGA1UdHwQsMCowKKAmoCSGImh0dHA6Ly9jcmwuZW50cnVzdC5u\n+ZXQvbGV2ZWwxai5jcmwwHgYDVR0RBBcwFYITdmFsaWRlYy5lbnRydXN0Lm5ldDAO\n+BgNVHQ8BAf8EBAMCB4AwHQYDVR0lBBYwFAYIKwYBBQUHAwEGCCsGAQUFBwMCMEsG\n+A1UdIAREMEIwBwYFZ4EMAQEwNwYKYIZIAYb6bAoBAjApMCcGCCsGAQUFBwIBFhto\n+dHRwczovL3d3dy5lbnRydXN0Lm5ldC9ycGEwggF9BgorBgEEAdZ5AgQCBIIBbQSC\n+AWkBZwB1AA3h8jAr0w3BQGISCepVLvxHdHyx1+kw7w5CHrR+Tqo0AAABkGDKGokA\n+AAQDAEYwRAIgZwtzml8YzKjqeP86zX+88q8sHOt\/\/2Qmahr2tk97ozUCIFCOM2nF\n+s1GJVBjKQZEH8QqkivVp+Cai9pC\/57TiOmCOAHUAzPsPaoVxCWX+lZtTzumyfCLp\n+hVwNl422qX5UwP5MDbAAAAGQYMoamAAABAMARjBEAiEA37X8EgQAUzLxn\/Ny1Yx3\n+uszQF5D85m8vZ0otf8nHzuwCH168zpAxzKS71Fz6CgmDS0QZOfBSYFBD+Pdcm6e1\n+ilkAdwAS8U40vVNyTIQGGcOPP3oT+Oe1YoeInG0wBYTr5YYmOgAAAZBgyhq6AAAE\n+AwBIMEYCIQCljVuYzRe6oQTZPdx0tGhIQSOwM1JbxoMJu2cW+gEGLAIhAMSSJoni\n+0KT3KavwtsSWuuHsWjt8atv6TpJtLmVxCIdlMAoGCCqGSM49BAMDA2cAMGQCMBPY\n+1dn1Js8F9b08aVCZ3vqDGFTKuzTXaxArf\/y\/WhLtcHdZPLaYVifQcAKzp1WCFQIw\n+MvpE6RDccmnZi5TX88p16s8ev\/qkegpbf7Xuw1JQEfy2NRwrXc+NwA422EjXBTti\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIID5zCCA2ygAwIBAgIQCoPUgD5+n1EAAAAAUdTB9zAKBggqhkjOPQQDAzCBvzEL\n+MAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsTH1Nl\n+ZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAyMDEy\n+IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEzMDEGA1UE\n+AxMqRW50cnVzdCBSb290IENlcnRpZmljYXRpb24gQXV0aG9yaXR5IC0gRUMxMB4X\n+DTE2MDQwNTIwMTk1NFoXDTM3MTAwNTIwNDk1NFowgboxCzAJBgNVBAYTAlVTMRYw\n+FAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1c3Qu\n+bmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNiBFbnRydXN0LCBJbmMu\n+IC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxLjAsBgNVBAMTJUVudHJ1c3QgQ2Vy\n+dGlmaWNhdGlvbiBBdXRob3JpdHkgLSBMMUowdjAQBgcqhkjOPQIBBgUrgQQAIgNi\n+AAT14eFXmpQX\/dEf7NAxrMH13n0btz1KKvH2S1rROGPAKex2CY8yxznbffK\/MbCk\n+F7ByYXGs1+8kL5xmTysU\/c+YmjOZx2mMSAk2DPw30fijJ3tRrwChZ+TBpgtB6+A5\n+MsCjggEuMIIBKjAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAz\n+BggrBgEFBQcBAQQnMCUwIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3Qu\n+bmV0MDMGA1UdHwQsMCowKKAmoCSGImh0dHA6Ly9jcmwuZW50cnVzdC5uZXQvZWMx\n+cm9vdC5jcmwwOwYDVR0gBDQwMjAwBgRVHSAAMCgwJgYIKwYBBQUHAgEWGmh0dHA6\n+Ly93d3cuZW50cnVzdC5uZXQvcnBhMB0GA1UdJQQWMBQGCCsGAQUFBwMBBggrBgEF\n+BQcDAjAdBgNVHQ4EFgQUw\/lFA77I+Qs8RTXz63Ls5+jrlJswHwYDVR0jBBgwFoAU\n+t2PnGt2N6QimVYOk4GpQQWURQkkwCgYIKoZIzj0EAwMDaQAwZgIxAPnVAOqxKDd7\n+v37EBmpPqWCCWBFPKW6HpRx3GUWc9caeQIw8rO2HXYgf92pb\/TsJYAIxAJhI0MpR\n+z5L42xF1R9UIPfQxCMwgsnWBqIqcfMrMO+2DxQy6GIP3cFFj9gRyxguKWw==\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcaec1-chain.pem","additions":66,"deletions":0,"binary":false,"changes":66,"status":"added"},{"patch":"@@ -0,0 +1,80 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number: 1246989352 (0x4a538c28)\n+        Signature Algorithm: sha256WithRSAEncryption\n+        Issuer: C=US, O=Entrust, Inc., OU=See www.entrust.net\/legal-terms, OU=(c) 2009 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - G2\n+        Validity\n+            Not Before: Jul  7 17:25:54 2009 GMT\n+            Not After : Dec  7 17:55:54 2030 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIHOzCCBiOgAwIBAgIQWFfRPoYcAxEc+S0tOlD+ljANBgkqhkiG9w0BAQsFADCB\n+ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\n+H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\n+MDE0IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\n+A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxTTAeFw0y\n+NDA2MjgyMTQyMTRaFw0yNTA3MjgyMTQyMTNaMIHLMQswCQYDVQQGEwJDQTEQMA4G\n+A1UECBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMT\n+AkNBMRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3Qg\n+TGltaXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEzARBgNVBAUT\n+CjEwMDA0OTI4NzkxHDAaBgNVBAMTE3ZhbGlkZzIuZW50cnVzdC5uZXQwggEiMA0G\n+CSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCZ66eWZS5ytmbHJeHcA9WfnpbGFC04\n+Tov7L0NWiStVRPEFrXrGSn6RPriGci6RwrCz5yn47EWjk2AjSD4e5lySDKHwTg+0\n+S9pl3lcSd8tQOTbTwVM0EfOxdUlO4IY0jCOSM8rnZUc1JvEIIrXWXWF9AWoDb4BQ\n+erTefRm\/YykFC558PEzn84vU9KoEmDwIP4upWKVutuzBpHWhZW3q9wagg62KifHN\n+1yaagv4PUGgdkrVkyA1ZO3D7b2RpQjBreOTk+tsTnWtbAkFGtRBOA\/2QrEvyqMU7\n+eCnpFZMIaj2tKeSLqhIWxzOnrAGUJNp5wLYmVnnhPhHEv1g79pNsZLR3AgMBAAGj\n+ggMoMIIDJDAMBgNVHRMBAf8EAjAAMB0GA1UdDgQWBBRt85gfkWUjfTKgrLytMp8o\n+VvOe3zAfBgNVHSMEGDAWgBTD99C1KjCtrw2RIXA5VN28iXDHOjBoBggrBgEFBQcB\n+AQRcMFowIwYIKwYBBQUHMAGGF2h0dHA6Ly9vY3NwLmVudHJ1c3QubmV0MDMGCCsG\n+AQUFBzAChidodHRwOi8vYWlhLmVudHJ1c3QubmV0L2wxbS1jaGFpbjI1Ni5jZXIw\n+MwYDVR0fBCwwKjAooCagJIYiaHR0cDovL2NybC5lbnRydXN0Lm5ldC9sZXZlbDFt\n+LmNybDA3BgNVHREEMDAughN2YWxpZGcyLmVudHJ1c3QubmV0ghd3d3cudmFsaWRn\n+Mi5lbnRydXN0Lm5ldDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUH\n+AwEGCCsGAQUFBwMCMEsGA1UdIAREMEIwBwYFZ4EMAQEwNwYKYIZIAYb6bAoBAjAp\n+MCcGCCsGAQUFBwIBFhtodHRwczovL3d3dy5lbnRydXN0Lm5ldC9ycGEwggF+Bgor\n+BgEEAdZ5AgQCBIIBbgSCAWoBaAB3ABLxTjS9U3JMhAYZw48\/ehP457Vih4icbTAF\n+hOvlhiY6AAABkGDMhQQAAAQDAEgwRgIhAMzddgbnWlodtosz6EMh2Y89n0JR4eMO\n+v+W6tUp2gVwYAiEA6UKa2eFlX0KdzuZCvTlPgi8DeK3ZI2wffyV2bYMXtsIAdgAN\n+4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAAAZBgzIURAAAEAwBHMEUC\n+IQDmVH2NlaV2\/Y3OaPMXhH+BT63zA+Bh\/5aCfPiYrJ7K2AIgRADPHzpwS7bfvVZI\n+k8QxUBSCDXFmZQOrpamBaEko6YIAdQDM+w9qhXEJZf6Vm1PO6bJ8IumFXA2Xjbap\n+flTA\/kwNsAAAAZBgzIUGAAAEAwBGMEQCIA1CHfNw7cCcJSb3s7ik9Wflf3irqE9G\n+QKxZ+Y9BOIx0AiA6CMvw7OHjG519E1tZgr\/HFRXzxKchBp80dfsaEKxY9zANBgkq\n+hkiG9w0BAQsFAAOCAQEAqvn1CTObiV5zKVY6NWjGK49Wqsr9t1ok\/h\/yfKRmr36O\n+UZkMTPANj0uhwM4gtieTze9hnNzEkx1ec6G40JyABRiSX+0dtq3n8wiW3d8G1Qj5\n+\/s8yZ13\/ATrdjjr1mlGOvh0sgWTTPaQpl8ijXTy40GYpZIUXXBK09Rm6W0siq+7m\n+OHNpJR4APWOBBU4QwiWrHHsFq4KvwxiTjNWWizCOnZwVi3awNBoDD\/Iwszn+trOA\n+8U\/1SsHGuPBWKajcGorwi2zQ99JxAwJJ8XNBCekynjbPZYx52KkqfR07Fd2Occbl\n+3lh3wXrepzzU1a6vdyiQpagX8btyIqQpAzytypzaLQ==\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIFLTCCBBWgAwIBAgIMYaHn0gAAAABR02amMA0GCSqGSIb3DQEBCwUAMIG+MQsw\n+CQYDVQQGEwJVUzEWMBQGA1UEChMNRW50cnVzdCwgSW5jLjEoMCYGA1UECxMfU2Vl\n+IHd3dy5lbnRydXN0Lm5ldC9sZWdhbC10ZXJtczE5MDcGA1UECxMwKGMpIDIwMDkg\n+RW50cnVzdCwgSW5jLiAtIGZvciBhdXRob3JpemVkIHVzZSBvbmx5MTIwMAYDVQQD\n+EylFbnRydXN0IFJvb3QgQ2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBHMjAeFw0x\n+NDEyMTUxNTI1MDNaFw0zMDEwMTUxNTU1MDNaMIG6MQswCQYDVQQGEwJVUzEWMBQG\n+A1UEChMNRW50cnVzdCwgSW5jLjEoMCYGA1UECxMfU2VlIHd3dy5lbnRydXN0Lm5l\n+dC9sZWdhbC10ZXJtczE5MDcGA1UECxMwKGMpIDIwMTQgRW50cnVzdCwgSW5jLiAt\n+IGZvciBhdXRob3JpemVkIHVzZSBvbmx5MS4wLAYDVQQDEyVFbnRydXN0IENlcnRp\n+ZmljYXRpb24gQXV0aG9yaXR5IC0gTDFNMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A\n+MIIBCgKCAQEA0IHBOSPCsdHs91fdVSQ2kSAiSPf8ylIKsKs\/M7WwhAf23056sPuY\n+Ij0BrFb7cW2y7rmgD1J3q5iTvjOK64dex6qwymmPQwhqPyK\/MzlG1ZTy4kwFItln\n+gJHxBEoOm3yiydJs\/TwJhL39axSagR3nioPvYRZ1R5gTOw2QFpi\/iuInMlOZmcP7\n+lhw192LtjL1JcdJDQ6Gh4yEqI3CodT2ybEYGYW8YZ+QpfrI8wcVfCR5uRE7sIZlY\n+FUj0VUgqtzS0BeN8SYwAWN46lsw53GEzVc4qLj\/RmWLoquY0djGqr3kplnjLgRSv\n+adr7BLlZg0SqCU+01CwBnZuUMWstoc\/B5QIDAQABo4IBKzCCAScwDgYDVR0PAQH\/\n+BAQDAgEGMB0GA1UdJQQWMBQGCCsGAQUFBwMCBggrBgEFBQcDATASBgNVHRMBAf8E\n+CDAGAQH\/AgEAMDMGCCsGAQUFBwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29j\n+c3AuZW50cnVzdC5uZXQwMAYDVR0fBCkwJzAloCOgIYYfaHR0cDovL2NybC5lbnRy\n+dXN0Lm5ldC9nMmNhLmNybDA7BgNVHSAENDAyMDAGBFUdIAAwKDAmBggrBgEFBQcC\n+ARYaaHR0cDovL3d3dy5lbnRydXN0Lm5ldC9ycGEwHQYDVR0OBBYEFMP30LUqMK2v\n+DZEhcDlU3byJcMc6MB8GA1UdIwQYMBaAFGpyJnrQHu995ztpUdRsjZ+QEmarMA0G\n+CSqGSIb3DQEBCwUAA4IBAQC0h8eEIhopwKR47PVPG7SEl2937tTPWa+oQ5YvHVje\n+pvMVWy7ZQ5xMQrkXFxGttLFBx2YMIoYFp7Qi+8VoaIqIMthx1hGOjlJ+Qgld2dnA\n+DizvRGsf2yS89byxqsGK5Wbb0CTz34mmi\/5e0FC6m3UAyQhKS3Q\/WFOv9rihbISY\n+Jnz8\/DVRZZgeO2x28JkPxLkJ1YXYJKd\/KsLak0tkuHB8VCnTglTVz6WUwzOeTTRn\n+4Dh2ZgCN0C\/GqwmqcvrOLzWJ\/MDtBgO334wlV\/H77yiI2YIowAQPlIFpI+CRKMVe\n+1QzX1CA778n4wI+nQc1XRG5sZ2L+hN\/nYNjvv9QiHg3n\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag2-chain.pem","additions":80,"deletions":0,"binary":false,"changes":80,"status":"added"},{"patch":"@@ -0,0 +1,92 @@\n+Root Certificate:\n+        Version: 3 (0x2)\n+        Serial Number:\n+            d9:b5:43:7f:af:a9:39:0f:00:00:00:00:55:65:ad:58\n+        Signature Algorithm: sha256WithRSAEncryption\n+        Issuer: C=US, O=Entrust, Inc., OU=See www.entrust.net\/legal-terms, OU=(c) 2015 Entrust, Inc. - for authorized use only, CN=Entrust Root Certification Authority - G4\n+        Validity\n+            Not Before: May 27 11:11:16 2015 GMT\n+            Not After : Dec 27 11:41:16 2037 GMT\n+\n+-----BEGIN CERTIFICATE-----\n+MIIIIzCCBwugAwIBAgIQDD4I8FgD7+DVcBLMBwa39jANBgkqhkiG9w0BAQsFADCB\r\n+ujELMAkGA1UEBhMCVVMxFjAUBgNVBAoTDUVudHJ1c3QsIEluYy4xKDAmBgNVBAsT\r\n+H1NlZSB3d3cuZW50cnVzdC5uZXQvbGVnYWwtdGVybXMxOTA3BgNVBAsTMChjKSAy\r\n+MDE0IEVudHJ1c3QsIEluYy4gLSBmb3IgYXV0aG9yaXplZCB1c2Ugb25seTEuMCwG\r\n+A1UEAxMlRW50cnVzdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEwxTjAeFw0y\r\n+NDA2MjgyMTQzNTRaFw0yNTA3MjgyMTQzNTNaMIHLMQswCQYDVQQGEwJDQTEQMA4G\r\n+A1UECBMHT250YXJpbzEPMA0GA1UEBxMGT3R0YXdhMRMwEQYLKwYBBAGCNzwCAQMT\r\n+AkNBMRgwFgYLKwYBBAGCNzwCAQITB09udGFyaW8xGDAWBgNVBAoTD0VudHJ1c3Qg\r\n+TGltaXRlZDEdMBsGA1UEDxMUUHJpdmF0ZSBPcmdhbml6YXRpb24xEzARBgNVBAUT\r\n+CjEwMDA0OTI4NzkxHDAaBgNVBAMTE3ZhbGlkZzQuZW50cnVzdC5uZXQwggIiMA0G\r\n+CSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQCfUHGdeme0jraIiUzPYtuX1G9rlCU1\r\n+eKDqDbsgp7VIS7rI\/VgbsS7oKnE6KHP+qGrXRhYdvFLFDa+REY6fVOWkLuTXhVLb\r\n+5C7ym2pi0OUMKvrGtDLUxlHiEAmkmjPDl6TLMTDrLgWOLFMRzyeTcxnZtMrxUnAf\r\n+yzSPlqm1bkN\/oRp2EOiXvuSbci8UA0QswV6g8EUbRB0qyv6OophoaQYo\/+KRwTJT\r\n+k6S8YDsEJnlDb8tjEhfIUjp2Md5ThBxf5Ib29aXebZ5HFh2x5VPrzOwDUPk0fVNM\r\n+pWFfiX79RW6w5Vei5qtretLohbw6b5aJmaJ1LweAEkIlhy5eUuuG6v8Efm8JSAle\r\n+eKMtflTigmayaWMVCd2GeB6LajcflAw7BUU2brRMJwMpaeXXhL\/mVpjbev\/5TtVD\r\n++H9IlW3PMyQnUJc0YuUVmdi1eOM5qoQaQE4BDPHz2G41eDgT8J9Gb1FX5mT+9l2I\r\n+iJD47pwcBIw5tHCn2nuz1+8CDuYpfH2+t2LPFHVI15h1scGotZvzUJ5TzPdQqZI7\r\n+K2LTL49Zs2HsObrGr07Vj28WyzkjIfTrVSV\/29hgz1zVjUa0uyTeOzrc3VIg7NTv\r\n+RoMTTYuUeUoMSmFQ8z9CSGh7cxFlrhGjFO+66++JFNwakAEp7kS5c2qTLaapY9dM\r\n+8UMIr5951z994QIDAQABo4IDEDCCAwwwDAYDVR0TAQH\/BAIwADAdBgNVHQ4EFgQU\r\n+\/EjjpmMa\/SepMqPlglXS5AbGcScwHwYDVR0jBBgwFoAU7kfRhXHx\/S23P7s+Y1h3\r\n+F0lADpUwaAYIKwYBBQUHAQEEXDBaMCMGCCsGAQUFBzABhhdodHRwOi8vb2NzcC5l\r\n+bnRydXN0Lm5ldDAzBggrBgEFBQcwAoYnaHR0cDovL2FpYS5lbnRydXN0Lm5ldC9s\r\n+MW4tY2hhaW4yNTYuY2VyMDMGA1UdHwQsMCowKKAmoCSGImh0dHA6Ly9jcmwuZW50\r\n+cnVzdC5uZXQvbGV2ZWwxbi5jcmwwHgYDVR0RBBcwFYITdmFsaWRnNC5lbnRydXN0\r\n+Lm5ldDAOBgNVHQ8BAf8EBAMCBaAwHQYDVR0lBBYwFAYIKwYBBQUHAwIGCCsGAQUF\r\n+BwMBMEsGA1UdIAREMEIwBwYFZ4EMAQEwNwYKYIZIAYb6bAoBAjApMCcGCCsGAQUF\r\n+BwIBFhtodHRwczovL3d3dy5lbnRydXN0Lm5ldC9ycGEwggF\/BgorBgEEAdZ5AgQC\r\n+BIIBbwSCAWsBaQB2ABLxTjS9U3JMhAYZw48\/ehP457Vih4icbTAFhOvlhiY6AAAB\r\n+kGDOC9YAAAQDAEcwRQIgWhFWhf2sBQ3ufMH0yubwLDt+3f\/b5rScs09o1YEjg6MC\r\n+IQDpkgEMWBAM+NV2aCnC8QH+RH6xBqhPPt6JZTm3W+vHkwB3ABoE\/0nQVB1Ar\/ag\r\n+w7\/x2MRnL07s7iNAaJhrF0Au3Il9AAABkGDODBQAAAQDAEgwRgIhAOgp+oas+jBr\r\n+9wOBo0QDdVQGmP8KJupfRf\/MDKO+kSRjAiEA9JnEHTbFHre2TS9habVJA\/3jM\/t5\r\n+CKtixwQqdpLXQUAAdgAN4fIwK9MNwUBiEgnqVS78R3R8sdfpMO8OQh60fk6qNAAA\r\n+AZBgzgwVAAAEAwBHMEUCIBOYI8rl87VepcPQlaGh6AbKhKw1UlbxIf7etR\/d2M47\r\n+AiEAkFXOVvzkP6kX\/z1yRneYn0mlPbDvAFLsSDghl\/gkdtYwDQYJKoZIhvcNAQEL\r\n+BQADggEBAJovgoheNHFBUpnodfOiKtpRo8AE6dLuOX1H2uRHiDg0Gza0\/w95KkEE\r\n+BqjKmJIbJrs2TQJnkM0LjaubHn1TP4XC40qieMXB4ylJzC5FWDZBqMHZmLTvVY01\r\n+irBMyub0On8d1BlEquD2r3KHQFnyUvi\/uxzbNJOVbNJYglKhTI+UfcXk7zpHmNG+\r\n++SbBkpJkuqQ9ujG1K25FRa\/01j1p4ZlDrJ3KCT7fDEf10TN0u5VX6moVT9cRVR2U\r\n+gX16BV8m\/hoJVTD0fBCKIKjtklS\/\/b+Jr49uxWFulrDwlRKyDWmBXLnqsZvpCobi\r\n+deDsWiUkcvd+DjNgpDTEHCTrXXjd8tU=\n+-----END CERTIFICATE-----\n+-----BEGIN CERTIFICATE-----\n+MIIGMjCCBBqgAwIBAgIRAKvsd\/8bQQwHAAAAAFVl2AUwDQYJKoZIhvcNAQELBQAw\r\n+gb4xCzAJBgNVBAYTAlVTMRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQL\r\n+Ex9TZWUgd3d3LmVudHJ1c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykg\r\n+MjAxNSBFbnRydXN0LCBJbmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxMjAw\r\n+BgNVBAMTKUVudHJ1c3QgUm9vdCBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eSAtIEc0\r\n+MB4XDTE3MTEyMjIwMDQyMFoXDTMwMTIyMjIwMzQyMFowgboxCzAJBgNVBAYTAlVT\r\n+MRYwFAYDVQQKEw1FbnRydXN0LCBJbmMuMSgwJgYDVQQLEx9TZWUgd3d3LmVudHJ1\r\n+c3QubmV0L2xlZ2FsLXRlcm1zMTkwNwYDVQQLEzAoYykgMjAxNCBFbnRydXN0LCBJ\r\n+bmMuIC0gZm9yIGF1dGhvcml6ZWQgdXNlIG9ubHkxLjAsBgNVBAMTJUVudHJ1c3Qg\r\n+Q2VydGlmaWNhdGlvbiBBdXRob3JpdHkgLSBMMU4wggEiMA0GCSqGSIb3DQEBAQUA\r\n+A4IBDwAwggEKAoIBAQDcSG+caYQ4xcvf+dt8bgCEHorO0g5j0H1NOtQzRXgUoG8y\r\n+QuRbJX9swyKqQZbsc18YvTV8OKA\/uSNE46Jvq47TFPojWWTVLbNDqpM07e4EFYKs\r\n+A9NFzAUngijnf3ivnXA6iNPAMXaEhXmhY\/YFjk8NoM7Y1PFsA0oj5hamKQ06iO\/j\r\n+gvBScLmnQ1ju9Qj9IGIg18UL5AJNw0frspLUQBYVrLGaqAy5Nl2BUJKaZ4vnSLvP\r\n+nk6YrB15mo1phHae10Ba4fx7R3z8IZ\/hby4OXTy\/KZpu107VEQPAwTuDK8ZXxB5y\r\n+0DSzi4vaw27aLrUsq4aFqUo03gEfC31vWW76TNkFAgMBAAGjggErMIIBJzAOBgNV\r\n+HQ8BAf8EBAMCAQYwEgYDVR0TAQH\/BAgwBgEB\/wIBADAdBgNVHSUEFjAUBggrBgEF\r\n+BQcDAQYIKwYBBQUHAwIwOwYDVR0gBDQwMjAwBgRVHSAAMCgwJgYIKwYBBQUHAgEW\r\n+Gmh0dHA6Ly93d3cuZW50cnVzdC5uZXQvcnBhMDMGCCsGAQUFBwEBBCcwJTAjBggr\r\n+BgEFBQcwAYYXaHR0cDovL29jc3AuZW50cnVzdC5uZXQwMAYDVR0fBCkwJzAloCOg\r\n+IYYfaHR0cDovL2NybC5lbnRydXN0Lm5ldC9nNGNhLmNybDAdBgNVHQ4EFgQU7kfR\r\n+hXHx\/S23P7s+Y1h3F0lADpUwHwYDVR0jBBgwFoAUnzjEViPDOeigcWzoVEzk6Dqx\r\n+v2cwDQYJKoZIhvcNAQELBQADggIBACMeFFgsWmC7h6D1v8DJUkOpm\/m5UhVhO0hb\r\n+pQMQKMhKkl744Y9SWG4WNmpQy743TTciEJPZFhc7ke2R6VmK8ZJUqro2awOw1RWZ\r\n+OtHla59Btf1NQd41vOVdU+qFhs8lFfXg9sK7YHTrfxHtMXLoGnkkamK3xJgn7sXa\r\n+\/zUvUDBTpDCXcpO9SyHoKIQswmkIPpRyIdPF4biRdR3N+9MYmlfqN\/Nk3OEZ73xZ\r\n+AUZP6Gu+f9cEiHTA8NdYHCPLJWyFnIHWK+QuTFEnKYnOYxCeroLBNOO64e8JWZ39\r\n+kZ22BBXhHzqOCCczS7JOJTRF+JgvWuxbFwRstj8qf3fE+JndWmq2FC4hTHtpuK5K\r\n+ENuiRm5gdkXfsXmB+qB6y5gaajiTIMscGIcZIKTe2YdKrLoicvEz8k+loM7favik\r\n+vzFioTNTDHYGx3mkfElBE7ycY8n+jZE3QBBv33k28MeQi7XNgEaMc4tYwoZIdE9A\r\n+xVccXTzEQzka82dOkRB1dU0XZId9XAWv+CtNc2TjF6Wgx2seA\/c6H8S0IfgQBIV2\r\n+8iN2wZns2QFdawkdy3hMUqPnA++kuGhLW3GemsIY5dP\/WxY8rd+OfLb\/Ks9T1pCd\r\n+28t7PQRcQsgkYmouzrOW9ASBvYqLLdhl4y+fFXff8RkPIKMNoYP06WJvRKmky9R\/\r\n+41\/nXRas\n+-----END CERTIFICATE-----\n","filename":"test\/jdk\/sun\/security\/ssl\/X509TrustManagerImpl\/Entrust\/entrustrootcag4-chain.pem","additions":92,"deletions":0,"binary":false,"changes":92,"status":"added"},{"patch":"@@ -43,0 +43,2 @@\n+import jdk.test.lib.Platform;\n+\n@@ -50,2 +52,4 @@\n-        verifyOutputFilenames(\"Compiler.perfmap\", FILENAME);\n-        verifyOutputFilenames(\"System.dump_map\", \"-F=%s\".formatted(FILENAME));\n+        if (Platform.isLinux()) {\n+            verifyOutputFilenames(\"Compiler.perfmap\", FILENAME);\n+            verifyOutputFilenames(\"System.dump_map\", \"-F=%s\".formatted(FILENAME));\n+        }\n","filename":"test\/jdk\/sun\/tools\/jcmd\/TestJcmdPIDSubstitution.java","additions":6,"deletions":2,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -0,0 +1,83 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337506\n+ * @summary Verify Command Line arguments are not mapped with\n+ *     \"best-fit\" mappings on Windows\n+ * @requires (os.family == \"windows\")\n+ * @library \/test\/lib\n+ * @run junit DisableBestFitMappingTest\n+ *\/\n+import java.nio.ByteBuffer;\n+import java.nio.charset.Charset;\n+import java.nio.charset.CharsetEncoder;\n+import java.util.stream.Stream;\n+import jdk.test.lib.process.ProcessTools;\n+\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.junit.jupiter.api.Assumptions.*;\n+\n+public class DisableBestFitMappingTest {\n+    private static final CharsetEncoder NATIVE_ENC =\n+            Charset.forName(System.getProperty(\"native.encoding\")).newEncoder();\n+    private static final String REPLACEMENT =\n+            NATIVE_ENC.charset().decode(ByteBuffer.wrap(NATIVE_ENC.replacement())).toString();\n+    private static final int EXIT_SUCCESS = 0;\n+    private static final int EXIT_FAILURE = -1;\n+\n+    static Stream<Arguments> CMD_ARGS() {\n+        return Stream.of(\n+                Arguments.of(\"aa\\uff02 \\uff02bb\", \"aa\" + REPLACEMENT + \" \" + REPLACEMENT + \"bb\"),\n+                Arguments.of(\"aa\\uff01bb\", \"aa\" + REPLACEMENT + \"bb\"),\n+                Arguments.of(\"aa\\u221ebb\", \"aa\" + REPLACEMENT + \"bb\")\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @MethodSource(\"CMD_ARGS\")\n+    void testDisableBestFitMapping(String arg, String expected) throws Exception {\n+        \/\/ Only execute if the arg cannot be encoded\n+        assumeFalse(NATIVE_ENC.canEncode(arg),\n+                \"native.encoding (%s) can encode the argument '%s'. Test ignored.\"\n+                        .formatted(NATIVE_ENC.charset(), arg));\n+\n+        var result= ProcessTools.executeTestJava(\n+                DisableBestFitMappingTest.class.getSimpleName(), arg, expected);\n+        result.asLines().forEach(System.out::println);\n+        assertEquals(EXIT_SUCCESS, result.getExitValue(),\n+                \"Disabling best-fit mapping failed\");\n+    }\n+\n+    public static void main(String... args) {\n+        System.out.println(args[0]);\n+        System.out.println(args[1]);\n+        System.exit(args[0].equals(args[1]) ? EXIT_SUCCESS : EXIT_FAILURE);\n+    }\n+}\n","filename":"test\/jdk\/tools\/launcher\/DisableBestFitMappingTest.java","additions":83,"deletions":0,"binary":false,"changes":83,"status":"added"},{"patch":"@@ -45,1 +45,2 @@\n-    vm.continuations\n+    vm.continuations \\\n+    vm.debug\n","filename":"test\/langtools\/TEST.ROOT","additions":2,"deletions":1,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -105,1 +105,0 @@\n-                    <hr>\n@@ -138,1 +137,0 @@\n-                    <hr>\n@@ -215,1 +213,0 @@\n-                    <hr>\n@@ -236,1 +233,0 @@\n-                    <hr>\n@@ -247,1 +243,0 @@\n-                    <hr>\n@@ -258,1 +253,0 @@\n-                    <hr>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDeprecatedDocs\/TestDeprecatedDocs.java","additions":1,"deletions":7,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -157,2 +157,2 @@\n-                <dd><code>E<\/code> - I2: first type parameter<\/dd>\n-                <dd><code>F<\/code> - I2: second type parameter<\/dd>\n+                <dd><span id=\"m(E)-type-param-E\"><code>E<\/code> - I2: first type parameter<\/span><\/dd>\n+                <dd><span id=\"m(E)-type-param-F\"><code>F<\/code> - I2: second type parameter<\/span><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testDirectedInheritance\/TestDirectedInheritance.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -202,1 +202,1 @@\n-                <wbr>(<a href=\"Foo.html\" title=\"type parameter in Foo\">T<\/a>&nbsp;arg)<\/code><\/div>\n+                <wbr>(<a href=\"#type-param-T\" title=\"type parameter in Foo\">T<\/a>&nbsp;arg)<\/code><\/div>\n@@ -230,1 +230,1 @@\n-                method-summary-table-tab3\"><code>abstract <a href=\"Foo.html\" title=\"type parameter in Foo\">T<\/a><\/code><\/div>\n+                method-summary-table-tab3\"><code>abstract <a href=\"#type-param-T\" title=\"type parameter in Foo\">T<\/a><\/code><\/div>\n@@ -233,1 +233,1 @@\n-                <wbr>(<a href=\"Foo.html\" title=\"type parameter in Foo\">T<\/a>&nbsp;arg)<\/code><\/div>\n+                <wbr>(<a href=\"#type-param-T\" title=\"type parameter in Foo\">T<\/a>&nbsp;arg)<\/code><\/div>\n@@ -388,1 +388,1 @@\n-}\n\\ No newline at end of file\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testErasure\/TestErasure.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      8188248\n+ * @bug      8188248 8313931\n@@ -70,1 +70,1 @@\n-                    <a href=\"A.html\" title=\"class in pkg\"><code>A<\/code><\/a>\"\"\");\n+                    param <a href=\"#m1(T)-type-param-T\"><code>T<\/code><\/a>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testGenericMethodLinkTaglet\/TestGenericMethodLinkTaglet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -78,1 +78,2 @@\n-                \"Class C4&lt;E extends C4&lt;E&gt;&gt;<\/h1>\",\n+                \"\"\"\n+                    Class C4&lt;<span id=\"type-param-E\">E extends C4&lt;E&gt;<\/span>&gt;<\/h1>\"\"\",\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testHref\/TestHref.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -102,1 +102,1 @@\n-                     href=\"Child.html\" title=\"type parameter in Child\">CE<\/a>&gt;<\/code><\/dd>\"\"\",\n+                     href=\"#type-param-CE\" title=\"type parameter in Child\">CE<\/a>&gt;<\/code><\/dd>\"\"\",\n@@ -107,1 +107,1 @@\n-                    ode><a href=\"Parent.html\" title=\"class in pkg\">Parent<\/a>&lt;<a href=\"Child.html\\\n+                    ode><a href=\"Parent.html\" title=\"class in pkg\">Parent<\/a>&lt;<a href=\"#type-param-CE\\\n@@ -193,1 +193,1 @@\n-                a href=\"Child.html\" title=\"type parameter in Child\">CE<\/a>&gt;<\/code>\"\"\");\n+                a href=\"#type-param-CE\" title=\"type parameter in Child\">CE<\/a>&gt;<\/code>\"\"\");\n@@ -212,1 +212,1 @@\n-                ator.OfInt<\/a>&lt;<a href=\"Spliterator.OfInt.html\" title=\"type parameter in Spli\\\n+                ator.OfInt<\/a>&lt;<a href=\"Spliterator.OfInt.html#type-param-Integer\" title=\"type parameter in Spli\\\n@@ -215,3 +215,3 @@\n-                .html\" title=\"type parameter in Spliterator.OfPrimitive\">T<\/a>,<wbr><a href=\"Spl\\\n-                iterator.OfPrimitive.html\" title=\"type parameter in Spliterator.OfPrimitive\">T_C\\\n-                ONS<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html\" title=\"type parameter in Spl\\\n+                .html#type-param-T\" title=\"type parameter in Spliterator.OfPrimitive\">T<\/a>,<wbr><a href=\"Spl\\\n+                iterator.OfPrimitive.html#type-param-T_CONS\" title=\"type parameter in Spliterator.OfPrimitive\">T_C\\\n+                ONS<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html#type-param-T_SPLITR\" title=\"type parameter in Spl\\\n@@ -220,3 +220,3 @@\n-                OfPrimitive.html\" title=\"type parameter in Spliterator.OfPrimitive\">T<\/a>,<wbr><\\\n-                a href=\"Spliterator.OfPrimitive.html\" title=\"type parameter in Spliterator.OfPri\\\n-                mitive\">T_CONS<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html\" title=\"type param\\\n+                OfPrimitive.html#type-param-T\" title=\"type parameter in Spliterator.OfPrimitive\">T<\/a>,<wbr><\\\n+                a href=\"Spliterator.OfPrimitive.html#type-param-T_CONS\" title=\"type parameter in Spliterator.OfPri\\\n+                mitive\">T_CONS<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html#type-param-T_SPLITR\" title=\"type param\\\n@@ -239,1 +239,1 @@\n-                Spliterator.OfInt.html\" title=\"type parameter in Spliterator.OfInt\">Integer<\/a>&\\\n+                Spliterator.OfInt.html#type-param-Integer\" title=\"type parameter in Spliterator.OfInt\">Integer<\/a>&\\\n@@ -245,2 +245,2 @@\n-                &lt;<a href=\"Spliterator.OfPrimitive.html\" title=\"type parameter in Spliterator.\\\n-                OfPrimitive\">T<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html\" title=\"type param\\\n+                &lt;<a href=\"Spliterator.OfPrimitive.html#type-param-T\" title=\"type parameter in Spliterator.\\\n+                OfPrimitive\">T<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html#type-param-T_CONS\" title=\"type param\\\n@@ -248,1 +248,1 @@\n-                e.html\" title=\"type parameter in Spliterator.OfPrimitive\">T_SPLITR<\/a> extends <\\\n+                e.html#type-param-T_SPLITR\" title=\"type parameter in Spliterator.OfPrimitive\">T_SPLITR<\/a> extends <\\\n@@ -250,2 +250,2 @@\n-                imitive<\/a>&lt;<a href=\"Spliterator.OfPrimitive.html\" title=\"type parameter in S\\\n-                pliterator.OfPrimitive\">T<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html\" title=\\\n+                imitive<\/a>&lt;<a href=\"Spliterator.OfPrimitive.html#type-param-T\" title=\"type parameter in S\\\n+                pliterator.OfPrimitive\">T<\/a>,<wbr><a href=\"Spliterator.OfPrimitive.html#type-param-T_CONS\" title=\\\n@@ -253,1 +253,1 @@\n-                .OfPrimitive.html\" title=\"type parameter in Spliterator.OfPrimitive\">T_SPLITR<\/a\\\n+                .OfPrimitive.html#type-param-T_SPLITR\" title=\"type parameter in Spliterator.OfPrimitive\">T_SPLITR<\/a\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testInterface\/TestInterface.java","additions":18,"deletions":18,"binary":false,"changes":36,"status":"modified"},{"patch":"@@ -0,0 +1,124 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug      8313931\n+ * @summary  Javadoc: links to type parameters actually generate links to classes\n+ * @library  \/tools\/lib ..\/..\/lib\n+ * @modules  jdk.javadoc\/jdk.javadoc.internal.tool\n+ * @build    toolbox.ToolBox javadoc.tester.*\n+ * @run main TestLinkTagletTypeParam\n+ *\/\n+\n+import javadoc.tester.JavadocTester;\n+import toolbox.ToolBox;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+\n+public class TestLinkTagletTypeParam extends JavadocTester {\n+\n+    public static void main(String... args) throws Exception {\n+        var tester = new TestLinkTagletTypeParam();\n+        tester.runTests();\n+    }\n+\n+    ToolBox tb = new ToolBox();\n+\n+    @JavadocTester.Test\n+    public void testClassTypeParameterLink(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+                \"\"\"\n+                    \/**\n+                     * Link to {@link F}.\n+                     *\n+                     * @param <F> the first type param\n+                     * @param <APND> an Appendable\n+                     *\n+                     * @see APND the second type parameter\n+                     *\/\n+                    public class Test<F, APND extends Appendable> {\n+                        private Test() {}\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-Xdoclint:none\",\n+                \"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"Test.java\").toString());\n+        checkExit(JavadocTester.Exit.OK);\n+\n+        checkOrder(\"Test.html\",\n+                \"\"\"\n+                    <dt>Type Parameters:<\/dt>\n+                    <dd><span id=\"type-param-F\"><code>F<\/code> - the first type param<\/span><\/dd>\n+                    <dd><span id=\"type-param-APND\"><code>APND<\/code> - an Appendable<\/span><\/dd>\"\"\",\n+                \"\"\"\n+                    Link to <a href=\"#type-param-F\" title=\"type parameter in Test\"><code>F<\/code><\/a>.\"\"\",\n+                \"\"\"\n+                    <dt>See Also:<\/dt>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"#type-param-APND\" title=\"type parameter in Test\">the second type parameter<\/a><\/li>\n+                    <\/ul>\"\"\");\n+    }\n+\n+    @JavadocTester.Test\n+    public void testMethodTypeParameterLink(Path base) throws IOException {\n+        Path src = base.resolve(\"src\");\n+\n+        tb.writeJavaFiles(src,\n+               \"\"\"\n+                    \/**\n+                     * Class comment.\n+                     *\/\n+                    public class Test {\n+                        \/**\n+                         * Link to {@link T} and {@linkplain T link with label}.\n+                         *\n+                         * @param <T> the T\n+                         * @param appendable the appendable\n+                         *\/\n+                        public <T extends Appendable> T append(final T appendable) {\n+                            return appendable;\n+                        }\n+                    }\n+                    \"\"\");\n+\n+        javadoc(\"-Xdoclint:reference\",\n+                \"-d\", base.resolve(\"api\").toString(),\n+                \"-sourcepath\", src.toString(),\n+                src.resolve(\"Test.java\").toString());\n+\n+        checkOutput(JavadocTester.Output.OUT, true,\n+                \"\");\n+\n+        checkOutput(\"Test.html\", true,\n+                \"\"\"\n+                    Link to <a href=\"#append(T)-type-param-T\"><code>T<\/code><\/a> and <a href=\"#appe\\\n+                    nd(T)-type-param-T\">link with label<\/a>.\"\"\");\n+    }\n+}\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testLinkTaglet\/TestLinkTagletTypeParam.java","additions":124,"deletions":0,"binary":false,"changes":124,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -123,1 +123,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -125,0 +124,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testMemberInheritance\/TestMemberInheritance.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1363,1 +1363,0 @@\n-                    <div class=\"horizontal-scroll\">\n@@ -1365,0 +1364,1 @@\n+                    <div class=\"horizontal-scroll\">\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testModules\/TestModules.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -120,1 +120,1 @@\n-                    <dd><code>E<\/code> - the type parameter for this class.\"\"\",\n+                    <dd><span id=\"type-param-E\"><code>E<\/code> - the type parameter for this class.<\/span><\/dd>\"\"\",\n@@ -133,1 +133,1 @@\n-                    (<a href=\"TypeParameters.html\" title=\"type parameter in TypeParameters\">E<\/a>&nbsp;param)\"\"\",\n+                    (<a href=\"#type-param-E\" title=\"type parameter in TypeParameters\">E<\/a>&nbsp;param)\"\"\",\n@@ -137,2 +137,4 @@\n-                    <dd><code>T<\/code> - This is the first type parameter.<\/dd>\n-                    <dd><code>V<\/code> - This is the second type parameter.\"\"\",\n+                    <dd><span id=\"methodThatHasTypeParameters(T,V)-type-param-T\"><code>T<\/code> - Th\\\n+                    is is the first type parameter.<\/span><\/dd>\n+                    <dd><span id=\"methodThatHasTypeParameters(T,V)-type-param-V\"><code>V<\/code> - Th\\\n+                    is is the second type parameter.<\/span><\/dd>\"\"\",\n@@ -150,1 +152,1 @@\n-                    ab2 method-summary-table-tab4\"><code><a href=\"TypeParameters.html\" title=\"type p\\\n+                    ab2 method-summary-table-tab4\"><code><a href=\"#type-param-E\" title=\"type p\\\n@@ -155,1 +157,1 @@\n-                    ref=\"TypeParameters.html\" title=\"type parameter in TypeParameters\">E<\/a>[]&nbsp;\\\n+                    ref=\"#type-param-E\" title=\"type parameter in TypeParameters\">E<\/a>[]&nbsp;\\\n@@ -159,1 +161,1 @@\n-                    lass=\"return-type\"><a href=\"TypeParameters.html\" title=\"type parameter in TypePa\\\n+                    lass=\"return-type\"><a href=\"#type-param-E\" title=\"type parameter in TypePa\\\n@@ -161,1 +163,1 @@\n-                    rameterA<\/span><wbr><span class=\"parameters\">(<a href=\"TypeParameters.html\" titl\\\n+                    rameterA<\/span><wbr><span class=\"parameters\">(<a href=\"#type-param-E\" titl\\\n@@ -179,1 +181,1 @@\n-                    href=\"TypeParameters.html\" title=\"type parameter in TypeParameters\">E<\/a><\/code>\\\n+                    href=\"#type-param-E\" title=\"type parameter in TypeParameters\">E<\/a><\/code>\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testNewLanguageFeatures\/TestNewLanguageFeatures.java","additions":12,"deletions":10,"binary":false,"changes":22,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -82,1 +82,1 @@\n-                    <dd><code>T2<\/code> - type 2<\/dd>\n+                    <dd><span id=\"genericMethod(T1,T2,T3)-type-param-T2\"><code>T2<\/code> - type 2<\/span><\/dd>\n@@ -95,1 +95,1 @@\n-                    <dd><code>T1<\/code> - type 1<\/dd>\n+                    <dd><span id=\"type-param-T1\"><code>T1<\/code> - type 1<\/span><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testParamTaglet\/TestParamTaglet.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -27,1 +27,1 @@\n- *           8331947\n+ *           8331947 8281533\n@@ -159,1 +159,14 @@\n-                    <\/ol>\"\"\");\n+                    <\/ol>\"\"\",\n+                \"\"\"\n+                    <div class=\"block\">Preview feature. Links: <a href=\"CoreRecord.html\" title=\"cla\\\n+                    ss in preview\"><code>CoreRecord<\/code><\/a><sup><a href=\"CoreRecord.html#preview\\\n+                    -preview.CoreRecord\">PREVIEW<\/a><\/sup>, <a href=\"CoreRecord.html\" title=\"class \\\n+                    in preview\"><code>core record<\/code><\/a><sup><a href=\"CoreRecord.html#preview-p\\\n+                    review.CoreRecord\">PREVIEW<\/a><\/sup>,\n+                     <a href=\"CoreRecord.html\" title=\"class in preview\">CoreRecord<\/a>, <a href=\"Co\\\n+                    reRecord.html\" title=\"class in preview\">core record<\/a>.<\/div>\"\"\",\n+                \"\"\"\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\"><code>CoreRecord<\/code><\\\n+                    \/a><sup><a href=\"CoreRecord.html#preview-preview.CoreRecord\">PREVIEW<\/a><\/sup><\\\n+                    \/li>\n+                    <li><a href=\"CoreRecord.html\" title=\"class in preview\">core record<\/a><\/li>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/TestPreview.java","additions":15,"deletions":2,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2021, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2021, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -28,0 +28,7 @@\n+\/**\n+ * Preview feature. Links: {@link CoreRecord}, {@link CoreRecord core record},\n+ * {@linkplain CoreRecord}, {@linkplain CoreRecord core record}.\n+ *\n+ * @see CoreRecord\n+ * @see CoreRecord core record\n+ *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testPreview\/api\/preview\/Core.java","additions":8,"deletions":1,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -113,1 +113,1 @@\n-                    ctProperty<\/a>&lt;java.util.List&lt;<a href=\"MyClassT.html\" title=\"type paramete\\\n+                    ctProperty<\/a>&lt;java.util.List&lt;<a href=\"#type-param-T\" title=\"type paramete\\\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testProperty\/TestProperty.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -178,1 +178,1 @@\n-                    <dd><code>T<\/code> - This is a type parameter.<\/dd>\n+                    <dd><span id=\"type-param-T\"><code>T<\/code> - This is a type parameter.<\/span><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testRecordTypes\/TestRecordTypes.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2001, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2001, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -222,1 +222,2 @@\n-                    java.lang.Class&lt;<a href=\"pkg2\/Fields.html\" title=\"type parameter in Fields\">E<\/a>&gt; someClass\"\"\");\n+                    java.lang.Class&lt;<a href=\"pkg2\/Fields.html#type-param-E\" title=\"type paramete\\\n+                    r in Fields\">E<\/a>&gt; someClass\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testSerializedForm\/TestSerializedForm.java","additions":3,"deletions":2,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2002, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2002, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -86,1 +86,1 @@\n-                     <dd><code>T<\/code> - the throwable<\/dd>\n+                     <dd><span id=\"m()-type-param-T\"><code>T<\/code> - the throwable<\/span><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testThrows\/TestThrows.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2003, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2003, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug      4927167 4974929 6381729 7010344 8025633 8081854 8182765 8187288 8261976\n+ * @bug      4927167 4974929 6381729 7010344 8025633 8081854 8182765 8187288 8261976 8313931\n@@ -113,1 +113,2 @@\n-                    <div class=\"col-last even-row-color\">&nbsp;<\/div>\"\"\",\n+                    <div class=\"col-last even-row-color\">\n+                    <div class=\"block\">Generic constructor.<\/div>\"\"\",\n@@ -117,1 +118,12 @@\n-                    &nbsp;<span class=\"element-name\">CtorTypeParam<\/span>()<\/div>\"\"\");\n+                    &nbsp;<span class=\"element-name\">CtorTypeParam<\/span>()<\/div>\"\"\",\n+                \"\"\"\n+                    <a href=\"#%3Cinit%3E()-type-param-T\"><code>T<\/code><\/a>\"\"\",\n+                \"\"\"\n+                    <dt>Type Parameters:<\/dt>\n+                    <dd><span id=\"&lt;init&gt;()-type-param-T\"><code>T<\/code> - the type parameter<\/span><\/dd>\"\"\",\n+                \"\"\"\n+                    <dt>See Also:<\/dt>\n+                    <dd>\n+                    <ul class=\"tag-list\">\n+                    <li><a href=\"#%3Cinit%3E()-type-param-T\">link to type parameter<\/a><\/li>\n+                    <\/ul>\"\"\");\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/TestTypeParameters.java","additions":16,"deletions":4,"binary":false,"changes":20,"status":"modified"},{"patch":"@@ -27,0 +27,6 @@\n+    \/**\n+     * Generic constructor. {@link T}\n+     *\n+     * @param <T> the type parameter\n+     * @see T link to type parameter\n+     *\/\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/pkg\/CtorTypeParam.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2018, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -104,1 +104,1 @@\n-                    <dd><code>##<\/code> - the ##<\/dd>\n+                    <dd><span id=\"type-param-##\"><code>##<\/code> - the ##<\/span><\/dd>\n","filename":"test\/langtools\/jdk\/javadoc\/doclet\/testUnicode\/TestUnicode.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -31,0 +31,5 @@\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n@@ -38,0 +43,2 @@\n+import static org.testng.Assert.assertFalse;\n+import org.testng.annotations.BeforeMethod;\n@@ -39,1 +46,0 @@\n-@Test\n@@ -56,0 +62,1 @@\n+    @Test\n@@ -63,0 +70,1 @@\n+    @Test\n@@ -71,0 +79,1 @@\n+    @Test\n@@ -121,0 +130,45 @@\n+    @Test\n+    public void testRunShutdownHooks() throws IOException {\n+        Path temporary = Paths.get(\"temp\");\n+        Files.newOutputStream(temporary).close();\n+        assertEval(\"import java.io.*;\");\n+        assertEval(\"import java.nio.file.*;\");\n+        assertEval(\"\"\"\n+                        Runtime.getRuntime().addShutdownHook(new Thread(() -> {\n+                            try {\n+                                Files.delete(Paths.get(\"$TEMPORARY\"));\n+                            } catch (IOException ex) {\n+                                \/\/ignored\n+                            }\n+                        }))\n+                        \"\"\".replace(\"$TEMPORARY\", temporary.toAbsolutePath()\n+                                                           .toString()\n+                                                           .replace(\"\\\\\", \"\\\\\\\\\")));\n+        getState().close();\n+        assertFalse(Files.exists(temporary));\n+    }\n+\n+    private Method currentTestMethod;\n+\n+    @BeforeMethod\n+    public void setUp(Method testMethod) {\n+        currentTestMethod = testMethod;\n+        super.setUp();\n+    }\n+\n+    @BeforeMethod\n+    public void setUp() {\n+    }\n+\n+    @Override\n+    public void setUp(Consumer<JShell.Builder> bc) {\n+        Consumer<JShell.Builder> augmentedBuilder = switch (currentTestMethod.getName()) {\n+            case \"testRunShutdownHooks\" -> builder -> {\n+                builder.executionEngine(Presets.TEST_STANDARD_EXECUTION);\n+                bc.accept(builder);\n+            };\n+            default -> bc;\n+        };\n+        super.setUp(augmentedBuilder);\n+    }\n+\n","filename":"test\/langtools\/jdk\/jshell\/ShutdownTest.java","additions":55,"deletions":1,"binary":false,"changes":56,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2020, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -606,1 +606,1 @@\n-            boolean matches = checkMatch((Annotation) anno);\n+            boolean matches = checkMatch(anno.annotation());\n@@ -1200,2 +1200,2 @@\n-                    for(Annotation anno : rvattr.annotations()) {\n-                        expected.matchAnnotation(anno);\n+                    for(var anno : rvattr.annotations()) {\n+                        expected.matchAnnotation(anno.annotation());\n","filename":"test\/langtools\/lib\/annotations\/annotations\/classfile\/ClassfileInspector.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2012, 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2012, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,2 @@\n- * @bug 7142086\n+ * @bug 7142086 8337334\n+ * @requires vm.debug == false\n@@ -32,0 +33,7 @@\n+\/*\n+ * @test\n+ * @requires vm.debug == true\n+ * @modules jdk.compiler\n+ * @run main\/timeout=20 T7142086\n+ *\/\n+\n","filename":"test\/langtools\/tools\/javac\/7142086\/T7142086.java","additions":10,"deletions":2,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -0,0 +1,222 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/**\n+ * @test\n+ * @bug 8338301\n+ * @summary Verify error recovery and reporting related to implicitly declared classes\n+ * @library \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *          jdk.compiler\/com.sun.tools.javac.util\n+ * @build toolbox.ToolBox toolbox.JavacTask\n+ * @run main ErrorRecovery\n+*\/\n+\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import toolbox.TestRunner;\n+import toolbox.JavacTask;\n+import toolbox.JavaTask;\n+import toolbox.Task;\n+import toolbox.Task.OutputKind;\n+import toolbox.ToolBox;\n+\n+public class ErrorRecovery extends TestRunner {\n+\n+    private static final String SOURCE_VERSION = System.getProperty(\"java.specification.version\");\n+    private ToolBox tb;\n+\n+    public static void main(String... args) throws Exception {\n+        new ErrorRecovery().runTests();\n+    }\n+\n+    ErrorRecovery() {\n+        super(System.err);\n+        tb = new ToolBox();\n+    }\n+\n+    public void runTests() throws Exception {\n+        runTests(m -> new Object[] { Paths.get(m.getName()) });\n+    }\n+\n+    @Test\n+    public void testMethodNoReturnType(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     main() {}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.invalid.meth.decl.ret.type.req\",\n+            \"- compiler.note.preview.filename: Test.java, DEFAULT\",\n+            \"- compiler.note.preview.recompile\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testStatement(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     if (true) {int var = 0;}\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log = new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"-XDshould-stop.at=FLOW\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.FAIL)\n+            .writeAll()\n+            .getOutputLines(OutputKind.DIRECT);\n+        List<String> expected = List.of(\n+            \"Test.java:1:1: compiler.err.statement.not.expected\",\n+            \"1 error\"\n+        );\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+    @Test\n+    public void testExtraSemi(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     class C {};\n+                     void main() {};\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        new JavacTask(tb)\n+            .options(\"-XDrawDiagnostics\",\n+                     \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+            .outdir(classes)\n+            .files(tb.findJavaFiles(src))\n+            .run(Task.Expect.SUCCESS)\n+            .writeAll();\n+    }\n+\n+    @Test\n+    public void testVeryBroken(Path base) throws Exception {\n+        Path current = base.resolve(\".\");\n+        Path src = current.resolve(\"src\");\n+        Path classes = current.resolve(\"classes\");\n+        tb.writeFile(src.resolve(\"Test.java\"),\n+                     \"\"\"\n+                     \"neither-of-class-method-file-statement\"\n+                     \"\"\");\n+\n+        Files.createDirectories(classes);\n+\n+        List<String> log;\n+        List<String> expected;\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                        \"--enable-preview\", \"--release\", SOURCE_VERSION)\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.class.method.or.field.expected\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+\n+        log = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\",\n+                         \"--release\", \"17\")\n+                .outdir(classes)\n+                .files(tb.findJavaFiles(src))\n+                .run(Task.Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+        expected = List.of(\n+                \"Test.java:1:1: compiler.err.expected4: class, interface, enum, record\",\n+                \"1 error\"\n+        );\n+\n+        if (!Objects.equals(expected, log)) {\n+            throw new AssertionError(\"Unexpected output: \" + log +\n+                                     \", while expecting: \" + expected);\n+        }\n+    }\n+\n+}\n","filename":"test\/langtools\/tools\/javac\/ImplicitClass\/ErrorRecovery.java","additions":222,"deletions":0,"binary":false,"changes":222,"status":"added"},{"patch":"@@ -0,0 +1,98 @@\n+\/*\n+ * Copyright (c) 2024, Alphabet LLC. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8337998\n+ * @summary CompletionFailure in getEnclosingType attaching type annotations\n+ * @library \/tools\/javac\/lib \/tools\/lib\n+ * @modules jdk.compiler\/com.sun.tools.javac.api\n+ *          jdk.compiler\/com.sun.tools.javac.main\n+ *\/\n+\n+import toolbox.*;\n+import toolbox.Task.*;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+public class CompletionErrorOnEnclosingType {\n+    ToolBox tb = new ToolBox();\n+\n+    public static void main(String... args) throws Exception {\n+        CompletionErrorOnEnclosingType t = new CompletionErrorOnEnclosingType();\n+        t.testMissingEnclosingType();\n+    }\n+\n+    void testMissingEnclosingType() throws Exception {\n+        String annoSrc =\n+                \"\"\"\n+                import static java.lang.annotation.ElementType.TYPE_USE;\n+                import java.lang.annotation.Target;\n+                @Target(TYPE_USE)\n+                @interface Anno {}\n+\n+                class A<E> {}\n+\n+                class B {\n+                  private @Anno A<String> a;\n+                }\n+                \"\"\";\n+        String cSrc =\n+                \"\"\"\n+                class C {\n+                  B b;\n+                }\n+                \"\"\";\n+\n+        Path base = Paths.get(\".\");\n+        Path src = base.resolve(\"src\");\n+        tb.createDirectories(src);\n+        tb.writeJavaFiles(src, annoSrc, cSrc);\n+        Path out = base.resolve(\"out\");\n+        tb.createDirectories(out);\n+        new JavacTask(tb).outdir(out).files(tb.findJavaFiles(src)).run();\n+\n+        \/\/ now if we remove A.class there will be an error but javac should not crash\n+        tb.deleteFiles(out.resolve(\"A.class\"));\n+        List<String> log =\n+                new JavacTask(tb)\n+                        .outdir(out)\n+                        .classpath(out)\n+                        .options(\"-XDrawDiagnostics\")\n+                        .files(src.resolve(\"C.java\"))\n+                        .run(Expect.FAIL)\n+                        .writeAll()\n+                        .getOutputLines(Task.OutputKind.DIRECT);\n+\n+        var expectedOutput =\n+                List.of(\n+                        \"B.class:-:-: compiler.err.cant.attach.type.annotations: @Anno, B, a,\"\n+                            + \" (compiler.misc.class.file.not.found: A)\",\n+                        \"1 error\");\n+        if (!expectedOutput.equals(log)) {\n+            throw new Exception(\"expected output not found: \" + log);\n+        }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/CompletionErrorOnEnclosingType.java","additions":98,"deletions":0,"binary":false,"changes":98,"status":"added"},{"patch":"@@ -218,1 +218,1 @@\n-            name = annotation.classSymbol().descriptorString();\n+            name = annotation.annotation().classSymbol().descriptorString();\n@@ -230,1 +230,1 @@\n-                annotationValueDebugString(cm, annotation),\n+                annotationValueDebugString(cm, annotation.annotation()),\n@@ -249,1 +249,1 @@\n-            return Integer.toString(((AnnotationValue.OfInteger) value).intValue());\n+            return Integer.toString(((AnnotationValue.OfInt) value).intValue());\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/classfile\/AnonymousClassTest.java","additions":3,"deletions":3,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2009, 2013, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2009, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -100,1 +100,1 @@\n-            tad.annotation = anno.className().stringValue();\n+            tad.annotation = anno.annotation().className().stringValue();\n","filename":"test\/langtools\/tools\/javac\/annotations\/typeAnnotations\/referenceinfos\/ReferenceInfoUtil.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -106,1 +106,1 @@\n-                case AnnotationValue.OfCharacter ev -> {\n+                case AnnotationValue.OfChar ev -> {\n@@ -116,1 +116,1 @@\n-                    testCase.checkEquals(((AnnotationValue.OfInteger) element_value).intValue(), Integer.parseInt(values[0]), \"const_value_index\");\n+                    testCase.checkEquals(((AnnotationValue.OfInt) element_value).intValue(), Integer.parseInt(values[0]), \"const_value_index\");\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/AnnotationDefault\/AnnotationDefaultVerifier.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2015, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2015, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -126,1 +126,1 @@\n-                    testResult.checkEquals(((AnnotationValue.OfInteger) element_value).intValue(), value, \"const_value_index : \" + value);\n+                    testResult.checkEquals(((AnnotationValue.OfInt) element_value).intValue(), value, \"const_value_index : \" + value);\n@@ -172,2 +172,2 @@\n-            AnnotationValue.OfCharacter ev =\n-                    (AnnotationValue.OfCharacter) element_value;\n+            AnnotationValue.OfChar ev =\n+                    (AnnotationValue.OfChar) element_value;\n","filename":"test\/langtools\/tools\/javac\/classfiles\/attributes\/annotations\/TestAnnotationInfo.java","additions":4,"deletions":4,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+compiler.err.cant.attach.type.annotations               # bad class file\n","filename":"test\/langtools\/tools\/javac\/diags\/examples.not-yet.txt","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -0,0 +1,27 @@\n+\/*\n+ * Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/\/ key: compiler.err.class.method.or.field.expected\n+\/\/ options: --enable-preview --source ${jdk.version}\n+\n+\"neither-of-class-method-file-statement\"\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/ClassMethodOrFieldExpected.java","additions":27,"deletions":0,"binary":false,"changes":27,"status":"added"},{"patch":"@@ -24,1 +24,1 @@\n-package pkg;\n+\/\/ key: compiler.err.statement.not.expected\n@@ -26,3 +26,2 @@\n-public class CtorTypeParam {\n-    public <T extends Runnable> CtorTypeParam() {\n-    }\n+class StatementNotExpected {\n+    return null;\n","filename":"test\/langtools\/tools\/javac\/diags\/examples\/StatementNotExpected.java","additions":3,"deletions":4,"binary":false,"changes":7,"previous_filename":"test\/langtools\/jdk\/javadoc\/doclet\/testTypeParams\/pkg\/CtorTypeParam.java","status":"copied"},{"patch":"@@ -0,0 +1,25 @@\n+\/*\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8334466\n+ * @summary Ambiguous method call with generics may cause FunctionDescriptorLookupError\n+ * @compile\/fail\/ref=CrashWithFunctionDescriptorLookupErrorTest.out -XDrawDiagnostics CrashWithFunctionDescriptorLookupErrorTest.java\n+ *\/\n+\n+import java.util.List;\n+\n+class CrashWithFunctionDescriptorLookupErrorTest {\n+    void m() {\n+        List<X> list = List.of(new X());\n+        test(list.get(0));\n+    }\n+\n+    void test(A<?> a) { }\n+    void test(B<?> b) { }\n+\n+    interface A<T extends A<T>> { T a(); }\n+    interface B<T extends B<T>> { T b(); }\n+    class X implements A<X>, B<X> {\n+        public X a() { return null; }\n+        public X b() { return null; }\n+    }\n+}\n","filename":"test\/langtools\/tools\/javac\/lambda\/CrashWithFunctionDescriptorLookupErrorTest.java","additions":25,"deletions":0,"binary":false,"changes":25,"status":"added"},{"patch":"@@ -0,0 +1,2 @@\n+CrashWithFunctionDescriptorLookupErrorTest.java:13:9: compiler.err.ref.ambiguous: test, kindname.method, test(CrashWithFunctionDescriptorLookupErrorTest.A<?>), CrashWithFunctionDescriptorLookupErrorTest, kindname.method, test(CrashWithFunctionDescriptorLookupErrorTest.B<?>), CrashWithFunctionDescriptorLookupErrorTest\n+1 error\n","filename":"test\/langtools\/tools\/javac\/lambda\/CrashWithFunctionDescriptorLookupErrorTest.out","additions":2,"deletions":0,"binary":false,"changes":2,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2011, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2011, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -26,1 +26,1 @@\n- * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452\n+ * @bug 7073631 7159445 7156633 8028235 8065753 8205418 8205913 8228451 8237041 8253584 8246774 8256411 8256149 8259050 8266436 8267221 8271928 8275097 8293897 8295401 8304671 8310326 8312093 8312204 8315452 8337976 8324859\n@@ -2412,0 +2412,605 @@\n+    @Test \/\/JDK-8337976\n+    void testStatementsInClass() throws IOException {\n+        String code = \"\"\"\n+                      package test;\n+                      public class Test {\n+                          if (true);\n+                          while (true);\n+                          do {} while (true);\n+                          for ( ; ; );\n+                          switch (0) { default: }\n+                          assert true;\n+                          break;\n+                          continue;\n+                          return ;\n+                          throw new RuntimeException();\n+                          try {\n+                          } catch (RuntimeException ex) {}\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package test;\n+                     \\n\\\n+                     public class Test {\n+                         (ERROR: if (true) ;)\n+                         (ERROR: while (true) ;)\n+                         (ERROR: do {\n+                     } while (true);)\n+                         (ERROR: for (; ; ) ;)\n+                         (ERROR: switch (0) {\n+                     default:\n+\n+                     })\n+                         (ERROR: assert true;)\n+                         (ERROR: break;)\n+                         (ERROR: continue;)\n+                         (ERROR: return;)\n+                         (ERROR: throw new RuntimeException();)\n+                         (ERROR: try {\n+                     } catch (RuntimeException ex) {\n+                     })\n+                     }\"\"\");\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testStatementsInClass: \" + codes,\n+                     List.of(\"3:5:compiler.err.statement.not.expected\",\n+                             \"4:5:compiler.err.statement.not.expected\",\n+                             \"5:5:compiler.err.statement.not.expected\",\n+                             \"6:5:compiler.err.statement.not.expected\",\n+                             \"7:5:compiler.err.statement.not.expected\",\n+                             \"8:5:compiler.err.statement.not.expected\",\n+                             \"9:5:compiler.err.statement.not.expected\",\n+                             \"10:5:compiler.err.statement.not.expected\",\n+                             \"11:5:compiler.err.statement.not.expected\",\n+                             \"12:5:compiler.err.statement.not.expected\",\n+                             \"13:5:compiler.err.statement.not.expected\"),\n+                     codes);\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion1() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              return true;\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             return true;\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion2() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }                       \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion2: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion3() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion3: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion4() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion4: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion5() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test(String,\n+                      }\n+                      class T {}\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:38:compiler.err.expected\",\n+                             \"4:1:compiler.err.illegal.start.of.type\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test(String <error>, (ERROR: ) <error>);\n+                     }\n+                     class T {\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion6() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          private Object testMethod(final String arg1 final String arg2) {\n+                              return null;\n+                          }\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:48:compiler.err.expected3\",\n+                             \"3:66:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         private Object testMethod(final String arg1);\n+                         final String arg2;\n+                         {\n+                             return null;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion7() throws IOException {\n+        \/\/after 'default' attribute value, only semicolon (';') is expected,\n+        \/\/not left brace ('{'):\n+        String code = \"\"\"\n+                      package tests;\n+                      public @interface A {\n+                          public String value() default \"\"\n+                      }\n+                      \"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion5: \" + codes,\n+                     List.of(\"3:37:compiler.err.expected\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public @interface A {\n+                         \\n\\\n+                         public String value() default \"\";\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion10() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion11() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          String s = \"\"; \/\/field declaration\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion12() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              final String s = \"\";\n+                              return s.isEmpty();\n+                          }\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             final String s = \"\";\n+                             return s.isEmpty();\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion13() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                          final String s = \"\"; \/\/field declaration?\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test();\n+                         final String s = \"\";\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n+    @Test \/\/JDK-8324859\n+    void testImplicitlyDeclaredClassesConfusion14() throws IOException {\n+        String code = \"\"\"\n+                      package tests;\n+                      public class TestB {\n+                          public static boolean test() \/\/ missing open brace\n+                              String s = \"\";\n+                              s.length();\n+                              if (true); \/\/force parse as block\n+                          public static boolean test2() {\n+                              return true;\n+                          }\n+                      }\"\"\";\n+        DiagnosticCollector<JavaFileObject> coll =\n+                new DiagnosticCollector<>();\n+        JavacTaskImpl ct = (JavacTaskImpl) tool.getTask(null, fm, coll,\n+                List.of(\"--enable-preview\", \"--source\", SOURCE_VERSION),\n+                null, Arrays.asList(new MyFileObject(code)));\n+        CompilationUnitTree cut = ct.parse().iterator().next();\n+\n+        List<String> codes = new LinkedList<>();\n+\n+        for (Diagnostic<? extends JavaFileObject> d : coll.getDiagnostics()) {\n+            codes.add(d.getLineNumber() + \":\" + d.getColumnNumber() + \":\" + d.getCode());\n+        }\n+\n+        assertEquals(\"testImplicitlyDeclaredClassesConfusion1: \" + codes,\n+                     List.of(\"3:33:compiler.err.expected2\",\n+                             \"7:5:compiler.err.illegal.start.of.expr\"),\n+                     codes);\n+        String result = toStringWithErrors(cut).replaceAll(\"\\\\R\", \"\\n\");\n+        System.out.println(\"RESULT\\n\" + result);\n+        assertEquals(\"incorrect AST\",\n+                     result,\n+                     \"\"\"\n+                     package tests;\n+                     \\n\\\n+                     public class TestB {\n+                         \\n\\\n+                         public static boolean test() {\n+                             String s = \"\";\n+                             s.length();\n+                             if (true) ;\n+                             (ERROR: );\n+                         }\n+                         \\n\\\n+                         public static boolean test2() {\n+                             return true;\n+                         }\n+                     }\"\"\");\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/parser\/JavacParserTest.java","additions":607,"deletions":2,"binary":false,"changes":609,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2020, 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -77,1 +77,1 @@\n-                    actual.append(ta.className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n+                    actual.append(ta.annotation().className().stringValue() + \" pos: [\" + ta.targetInfo().targetType());\n","filename":"test\/langtools\/tools\/javac\/patterns\/Annotations.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -720,0 +720,4 @@\n+\n+    @Test(posn=1, annoType=TA.class, expect=\"130\")\n+    @Test(posn=23, annoType=TA.class, expect=\"131\")\n+    public Map<@TA(130) String, @TA(131) String> f130;\n","filename":"test\/langtools\/tools\/javac\/processing\/model\/type\/BasicAnnoTests.java","additions":4,"deletions":0,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -1361,1 +1361,1 @@\n-            assertFail(\"compiler.err.illegal.start.of.type\",\n+            assertFail(\"compiler.err.statement.not.expected\",\n@@ -1618,1 +1618,1 @@\n-        String annotationName = tAnno.classSymbol().displayName();\n+        String annotationName = tAnno.annotation().classSymbol().displayName();\n","filename":"test\/langtools\/tools\/javac\/records\/RecordCompilationTests.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8301580 8322159 8333107 8332230\n+ * @bug 8301580 8322159 8333107 8332230 8338678\n@@ -37,0 +37,5 @@\n+import com.sun.source.tree.VariableTree;\n+import com.sun.source.util.TaskEvent;\n+import com.sun.source.util.TaskListener;\n+import com.sun.source.util.TreePathScanner;\n+import com.sun.source.util.Trees;\n@@ -38,0 +43,1 @@\n+import java.util.IdentityHashMap;\n@@ -39,0 +45,1 @@\n+import java.util.Map;\n@@ -40,0 +47,7 @@\n+import java.util.stream.Collectors;\n+import javax.lang.model.element.Element;\n+import javax.lang.model.element.VariableElement;\n+import javax.lang.model.type.DeclaredType;\n+import javax.lang.model.type.TypeKind;\n+import javax.lang.model.type.TypeMirror;\n+import javax.tools.Diagnostic;\n@@ -237,0 +251,76 @@\n+    @Test\n+    public void testParameterizedErroneousType() throws Exception {\n+        String code = \"\"\"\n+                      public class C {\n+                          Undefined1<Undefined2, Undefined3> variable1;\n+                      }\n+                      \"\"\";\n+        Path curPath = Path.of(\".\");\n+        List<String> actual = new JavacTask(tb)\n+                .options(\"-XDrawDiagnostics\")\n+                .sources(code)\n+                .outdir(curPath)\n+                .callback(task -> {\n+                    task.addTaskListener(new TaskListener() {\n+                        @Override\n+                        public void finished(TaskEvent e) {\n+                            Trees trees = Trees.instance(task);\n+\n+                            if (e.getKind() == TaskEvent.Kind.ANALYZE) {\n+                                new TreePathScanner<Void, Void>() {\n+                                    @Override\n+                                    public Void visitVariable(VariableTree tree, Void p) {\n+                                        VariableElement var = (VariableElement) trees.getElement(getCurrentPath());\n+\n+                                        trees.printMessage(Diagnostic.Kind.NOTE, type2String(var.asType()), tree, e.getCompilationUnit());\n+\n+                                        return super.visitVariable(tree, p);\n+                                    }\n+                                }.scan(e.getCompilationUnit(), null);\n+                            }\n+                        }\n+                        Map<Element, Integer> identityRename = new IdentityHashMap<>();\n+                        String type2String(TypeMirror type) {\n+                            StringBuilder result = new StringBuilder();\n+\n+                            result.append(type.getKind());\n+                            result.append(\":\");\n+                            result.append(type.toString());\n+\n+                            if (type.getKind() == TypeKind.DECLARED ||\n+                                type.getKind() == TypeKind.ERROR) {\n+                                DeclaredType dt = (DeclaredType) type;\n+                                Element el = task.getTypes().asElement(dt);\n+                                result.append(\":\");\n+                                result.append(el.toString());\n+                                if (!dt.getTypeArguments().isEmpty()) {\n+                                    result.append(dt.getTypeArguments()\n+                                                    .stream()\n+                                                    .map(tm -> type2String(tm))\n+                                                    .collect(Collectors.joining(\", \", \"<\", \">\")));\n+                                }\n+                            } else {\n+                                throw new AssertionError(type.getKind().name());\n+                            }\n+\n+                            return result.toString();\n+                        }\n+                    });\n+                })\n+                .run(Expect.FAIL)\n+                .writeAll()\n+                .getOutputLines(OutputKind.DIRECT);\n+\n+        List<String> expected = List.of(\n+                \"C.java:2:5: compiler.err.cant.resolve.location: kindname.class, Undefined1, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:16: compiler.err.cant.resolve.location: kindname.class, Undefined2, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:28: compiler.err.cant.resolve.location: kindname.class, Undefined3, , , (compiler.misc.location: kindname.class, C, null)\",\n+                \"C.java:2:40: compiler.note.proc.messager: ERROR:Undefined1<Undefined2,Undefined3>:Undefined1<ERROR:Undefined2:Undefined2, ERROR:Undefined3:Undefined3>\",\n+                \"3 errors\"\n+        );\n+\n+        if (!Objects.equals(actual, expected)) {\n+            error(\"Expected: \" + expected + \", but got: \" + actual);\n+        }\n+    }\n+\n","filename":"test\/langtools\/tools\/javac\/recovery\/AttrRecovery.java","additions":91,"deletions":1,"binary":false,"changes":92,"status":"modified"},{"patch":"@@ -0,0 +1,10 @@\n+\/**\n+ * @test \/nodynamiccopyright\/\n+ * @bug 8337976\n+ * @summary Verify javac does not crash and produces nice errors for certain erroneous code.\n+ * @compile\/fail\/ref=T8337976.out -XDrawDiagnostics -XDshould-stop.at=FLOW -XDdev T8337976.java\n+ *\/\n+public class T8337976 {\n+    switch (0) { default: undefined u;}\n+    if (true) { undefined u; }\n+}\n","filename":"test\/langtools\/tools\/javac\/recovery\/T8337976.java","additions":10,"deletions":0,"binary":false,"changes":10,"status":"added"},{"patch":"@@ -0,0 +1,5 @@\n+T8337976.java:8:5: compiler.err.statement.not.expected\n+T8337976.java:9:5: compiler.err.statement.not.expected\n+T8337976.java:8:27: compiler.err.cant.resolve.location: kindname.class, undefined, , , (compiler.misc.location: kindname.class, T8337976, null)\n+T8337976.java:9:17: compiler.err.cant.resolve.location: kindname.class, undefined, , , (compiler.misc.location: kindname.class, T8337976, null)\n+4 errors\n","filename":"test\/langtools\/tools\/javac\/recovery\/T8337976.out","additions":5,"deletions":0,"binary":false,"changes":5,"status":"added"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2017, 2023, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2017, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -130,2 +130,2 @@\n-            if (nif.getName().contains(\"awdl\")) {\n-                return false; \/\/ exclude awdl\n+            if (nif.getName().contains(\"awdl\") || nif.getName().contains(\"docker\")) {\n+                return false; \/\/ exclude awdl or docker\n@@ -148,0 +148,7 @@\n+\n+        if (Platform.isLinux()) {\n+            String dName = nif.getDisplayName();\n+            if (dName != null && dName.contains(\"docker\")) {\n+                return false;\n+            }\n+        }\n","filename":"test\/lib\/jdk\/test\/lib\/NetworkConfiguration.java","additions":10,"deletions":3,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -324,4 +324,5 @@\n-        String template =\n-            \"FROM %s:%s\\n\" +\n-            \"RUN apt-get install libubsan1\\n\" +\n-            \"COPY \/jdk \/jdk\\n\" +\n+        String template = \"FROM %s:%s\\n\";\n+        if (baseImage.contains(\"ubuntu\") && DockerfileConfig.isUbsan()) {\n+            template += \"RUN apt-get update && apt-get install -y libubsan1\\n\";\n+        }\n+        template = template + \"COPY \/jdk \/jdk\\n\" +\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerTestUtils.java","additions":5,"deletions":4,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -40,0 +40,5 @@\n+\n+    public static boolean isUbsan() {\n+        return Boolean.getBoolean(\"jdk.test.docker.image.isUbsan\");\n+    }\n+\n","filename":"test\/lib\/jdk\/test\/lib\/containers\/docker\/DockerfileConfig.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -51,1 +52,2 @@\n-\n+    public Integer integerValue = intValue;\n+    public float floatValue = 156456.36435637F + intValue;\n@@ -53,1 +55,0 @@\n-\n@@ -55,1 +56,0 @@\n-\n@@ -57,1 +57,1 @@\n-\n+    public Boolean booleanValue = Boolean.TRUE;\n@@ -59,1 +59,0 @@\n-\n@@ -62,0 +61,10 @@\n+    @Benchmark\n+    public String concatConstBool() {\n+        return \"string\" + boolValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBoolean() {\n+        return \"string\" + booleanValue;\n+    }\n+\n@@ -67,0 +76,10 @@\n+    @Benchmark\n+    public String concatConstInteger() {\n+        return \"string\" + integerValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloat() {\n+        return \"string\" + floatValue;\n+    }\n+\n@@ -97,0 +116,25 @@\n+    @Benchmark\n+    public String concatConstBoolString() {\n+        return \"string\" + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanString() {\n+        return \"string\" + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntString() {\n+        return \"string\" + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerString() {\n+        return \"string\" + integerValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatString() {\n+        return \"string\" + floatValue + stringValue;\n+    }\n+\n@@ -107,0 +151,30 @@\n+    @Benchmark\n+    public String concatConstStringConst() {\n+        return \"string\" + stringValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntConst() {\n+        return \"string\" + intValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstIntegerConst() {\n+        return \"string\" + integerValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstFloatConst() {\n+        return \"string\" + floatValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstObjectConst() {\n+        return \"string\" + objectValue + \"string\";\n+    }\n+\n+    @Benchmark\n+    public String concatConstBooleanConst() {\n+        return \"string\" + booleanValue + \"string\";\n+    }\n+\n@@ -117,0 +191,25 @@\n+    @Benchmark\n+    public String concat3String() {\n+        return stringValue + stringValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBoolString() {\n+        return stringValue + boolValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringBooleanString() {\n+        return stringValue + booleanValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntString() {\n+        return stringValue + intValue + stringValue;\n+    }\n+\n+    @Benchmark\n+    public String concatStringIntegerString() {\n+        return stringValue + integerValue + stringValue;\n+    }\n+\n@@ -179,0 +278,9 @@\n+\n+    @Benchmark\n+    public String concat30Mix() {\n+        return f0 + \",\" + f1 + \",\"+ f2 + \",\"+  f3 + \",\"+  f4 + \",\"+  f5 + \",\"+  f6 + \",\"+  f7 + \",\"+  f8 + \",\"+  f9 + \",\"\n+              +f10 + \",\"+f11 + \",\"+f12 + \",\"+ f13 + \",\"+ f14 + \",\"+ f15 + \",\"+ f16 + \",\"+ f17 + \",\"+ f18 + \",\"+ f19 + \",\"\n+              +f20 + \",\"+f21 + \",\"+f22 + \",\" + boolValue + \",\" + booleanValue + \",\" + intValue + \",\" + integerValue\n+              + \",\" + floatValue + \",\" + byteValue + \",\" + objectValue;\n+    }\n+\n@@ -196,0 +304,29 @@\n+    @Benchmark\n+    public String concat13StringConst() {\n+        return f0  + f1  + f2  + f3 + f4\n+             + f5  + f6  + f7  + f8 + f9\n+             +f10 + f11 + f12 + \"\"\"\n+                A really long constant string. Such as a copyright header:\n+                 * Copyright (c) 2018, 2024, Oracle and\/or its affiliates. All rights reserved.\n+                 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+                 *\n+                 * This code is free software; you can redistribute it and\/or modify it\n+                 * under the terms of the GNU General Public License version 2 only, as\n+                 * published by the Free Software Foundation.\n+                 *\n+                 * This code is distributed in the hope that it will be useful, but WITHOUT\n+                 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+                 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+                 * version 2 for more details (a copy is included in the LICENSE file that\n+                 * accompanied this code).\n+                 *\n+                 * You should have received a copy of the GNU General Public License version\n+                 * 2 along with this work; if not, write to the Free Software Foundation,\n+                 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+                 *\n+                 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+                 * or visit www.oracle.com if you need additional information or have any\n+                 * questions.\n+                \"\"\";\n+    }\n+\n@@ -198,1 +335,1 @@\n-        return f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + f0 + \"\"\"\n+        return f0 + f1 + f2 + f3 + f4 + f5 + f6 + f7 + f8 + f9 + f10 + f11 + f12 + f13 + f14 + f15 + f16 + f17 + f18 + f19 + f20 + f21 + f22 + \"\"\"\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcat.java","additions":143,"deletions":6,"binary":false,"changes":149,"status":"modified"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All Rights Reserved.\n@@ -30,0 +31,1 @@\n+import org.openjdk.jmh.annotations.Param;\n@@ -47,1 +49,7 @@\n-        String[] selection = new String[] { \"StringLarge\", \"MixedSmall\", \"StringSingle\", \"MixedLarge\" };\n+        String[] selection = {\n+                \"StringLarge\",\n+                \"MixedSmall\",\n+                \"StringSingle\",\n+                \"StringThree\",\n+                \"MixedLarge\"\n+        };\n@@ -53,1 +61,13 @@\n-                case \"StringSingle\" -> new StringSingle().run();\n+                case \"StringSingle\" -> {\n+                    new StringSingle().constInt();\n+                    new StringSingle().constFloat();\n+                    new StringSingle().constString();\n+                    new StringSingle().const2String();\n+                    new StringSingle().constIntString();\n+                    new StringSingle().constFloatString();\n+                    new StringSingle().constBooleanString();\n+                }\n+                case \"StringThree\" -> {\n+                    new StringThree().stringIntString();\n+                    new StringThree().stringIntegerString();\n+                }\n@@ -67,1 +87,7 @@\n-        public String s = \"foo\";\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public float floatValue = 156456.36435637F + intValue;\n+        public String stringValue = String.valueOf(intValue);\n+        public boolean boolValue = true;\n+        public Boolean booleanValue = Boolean.TRUE;\n@@ -70,2 +96,56 @@\n-        public String run() {\n-            return \"\" + s;\n+        public String constBool() {\n+            return \"string\" + boolValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolean() {\n+            return \"string\" + booleanValue;\n+        }\n+\n+        @Benchmark\n+        public String constInt() {\n+            return \"string\" + intValue;\n+        }\n+\n+        @Benchmark\n+        public String constInteger() {\n+            return \"string\" + integerValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloat() {\n+            return \"string\" + floatValue;\n+        }\n+\n+        @Benchmark\n+        public String constString() {\n+            return \"string\" + stringValue;\n+        }\n+\n+        public String const2String() {\n+            return \"string\" + stringValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntString() {\n+            return \"string\" + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constIntegerString() {\n+            return \"string\" + integerValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constFloatString() {\n+            return \"string\" + floatValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBoolString() {\n+            return \"string\" + boolValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String constBooleanString() {\n+            return \"string\" + booleanValue + stringValue;\n@@ -75,0 +155,21 @@\n+    @BenchmarkMode(Mode.SingleShotTime)\n+    @OutputTimeUnit(TimeUnit.MILLISECONDS)\n+    @State(Scope.Thread)\n+    @Fork(value = 40, warmups = 2)\n+    public static class StringThree {\n+\n+        @Param(\"4711\")\n+        public int intValue;\n+        public Integer integerValue = intValue;\n+        public String stringValue = String.valueOf(intValue);\n+\n+        @Benchmark\n+        public String stringIntString() {\n+            return stringValue + intValue + stringValue;\n+        }\n+\n+        @Benchmark\n+        public String stringIntegerString() {\n+            return stringValue + integerValue + stringValue;\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/StringConcatStartup.java","additions":106,"deletions":5,"binary":false,"changes":111,"status":"modified"},{"patch":"@@ -61,0 +61,4 @@\n+            \"(Ljava\/lang\/Object;Ljava\/lang\/Object;)Ljava\/lang\/Object;\",\n+            \"(Ljava\/lang\/String;Ljava\/lang\/String;)Ljava\/lang\/String;\",\n+            \"(Ljava\/lang\/Integer;Ljava\/lang\/Integer;)Ljava\/lang\/Integer;\",\n+            \"()Ljava\/lang\/Object;\",\n@@ -64,0 +68,1 @@\n+            \"([III.Z[B..[.[B).\",\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/constant\/MethodTypeDescFactories.java","additions":5,"deletions":0,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -0,0 +1,95 @@\n+\/*\n+ *  Copyright (c) 2024, Oracle and\/or its affiliates. All rights reserved.\n+ *  DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ *  This code is free software; you can redistribute it and\/or modify it\n+ *  under the terms of the GNU General Public License version 2 only, as\n+ *  published by the Free Software Foundation.\n+ *\n+ *  This code is distributed in the hope that it will be useful, but WITHOUT\n+ *  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ *  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ *  version 2 for more details (a copy is included in the LICENSE file that\n+ *  accompanied this code).\n+ *\n+ *  You should have received a copy of the GNU General Public License version\n+ *  2 along with this work; if not, write to the Free Software Foundation,\n+ *  Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ *   Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ *  or visit www.oracle.com if you need additional information or have any\n+ *  questions.\n+ *\n+ *\/\n+\n+package org.openjdk.bench.java.lang.foreign;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+import java.lang.foreign.Arena;\n+import java.lang.foreign.MemorySegment;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.concurrent.TimeUnit;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@Warmup(iterations = 5, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 10, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(value = 3)\n+public class TestFill {\n+\n+    @Param({\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\",\n+            \"8\", \"9\", \"10\", \"11\", \"12\", \"13\", \"14\", \"15\",\n+            \"16\", \"17\", \"18\", \"19\", \"20\", \"21\", \"22\", \"23\",\n+            \"24\", \"25\", \"26\", \"27\", \"28\", \"29\", \"30\", \"31\",\n+            \"32\", \"128\", \"256\", \"384\", \"511\", \"512\"})\n+    public int ELEM_SIZE;\n+\n+    byte[] array;\n+    MemorySegment heapSegment;\n+    MemorySegment nativeSegment;\n+    MemorySegment unalignedSegment;\n+    ByteBuffer buffer;\n+\n+    @Setup\n+    public void setup() {\n+        array = new byte[ELEM_SIZE];\n+        heapSegment = MemorySegment.ofArray(array);\n+        nativeSegment = Arena.ofAuto().allocate(ELEM_SIZE, 8);\n+        unalignedSegment = Arena.ofAuto().allocate(ELEM_SIZE + 1, 8).asSlice(1);\n+        buffer = ByteBuffer.wrap(array);\n+    }\n+\n+    @Benchmark\n+    public void arrays_fill() {\n+        Arrays.fill(array, (byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void heap_segment_fill() {\n+        heapSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void native_segment_fill() {\n+        nativeSegment.fill((byte) 0);\n+    }\n+\n+    @Benchmark\n+    public void unaligned_segment_fill() {\n+        unalignedSegment.fill((byte) 0);\n+    }\n+\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/foreign\/TestFill.java","additions":95,"deletions":0,"binary":false,"changes":95,"status":"added"},{"patch":"@@ -115,7 +115,0 @@\n-\n-    @Benchmark\n-    public void forPrimitiveType(Blackhole bh) throws Throwable {\n-        for (char c : PRIM_TYPES) {\n-            bh.consume(Wrapper.forPrimitiveType(c));\n-        }\n-    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/lang\/invoke\/Wrappers.java","additions":0,"deletions":7,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-    @Param({\"4\"})\n+    @Param({\"4\", \"32\", \"76\", \"128\"})\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/Base64Decode.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,166 @@\n+\/*\n+ * Copyright Amazon.com Inc. or its affiliates. All Rights Reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package org.openjdk.bench.java.util.concurrent;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.BenchmarkMode;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.Mode;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.Warmup;\n+\n+@BenchmarkMode(Mode.AverageTime)\n+@State(Scope.Benchmark)\n+@OutputTimeUnit(TimeUnit.NANOSECONDS)\n+@Fork(1)\n+@Warmup(iterations = 3, time = 1, timeUnit = TimeUnit.SECONDS)\n+@Measurement(iterations = 5, time = 1, timeUnit = TimeUnit.SECONDS)\n+public class CopyOnWriteArrayListBenchmark {\n+\n+    private static byte[] getSerializedBytes(CopyOnWriteArrayList<?> list) throws IOException {\n+        ByteArrayOutputStream bytesOut = new ByteArrayOutputStream();\n+        ObjectOutputStream objectOut = new ObjectOutputStream(bytesOut);\n+        objectOut.writeObject(list);\n+\n+        objectOut.close();\n+        return bytesOut.toByteArray();\n+    }\n+\n+    private Collection<Object> emptyCollection = new ArrayList<>();\n+    private Object[] emptyArray = new Object[0];\n+\n+    private Collection<Object> oneItemCollection = Arrays.asList(\"\");\n+    private Object[] oneItemArray = new Object[] { \"\" };\n+\n+    private CopyOnWriteArrayList<?> emptyInstance = new CopyOnWriteArrayList<>();\n+    private CopyOnWriteArrayList<?> oneItemInstance = new CopyOnWriteArrayList<>(oneItemArray);\n+\n+    private byte[] emptyInstanceBytes;\n+    private byte[] oneInstanceBytes;\n+\n+    public CopyOnWriteArrayListBenchmark() {\n+        try {\n+            emptyInstanceBytes = getSerializedBytes(emptyInstance);\n+            oneInstanceBytes = getSerializedBytes(oneItemInstance);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Benchmark\n+    public void clear() {\n+        \/\/ have to create a new instance on each execution\n+        ((CopyOnWriteArrayList<?>) oneItemInstance.clone()).clear();\n+    }\n+\n+    @Benchmark\n+    public void clearEmpty() {\n+        emptyInstance.clear();\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> createInstanceArray() {\n+        return new CopyOnWriteArrayList<>(oneItemArray);\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> createInstanceArrayEmpty() {\n+        return new CopyOnWriteArrayList<>(emptyArray);\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> createInstanceCollection() {\n+        return new CopyOnWriteArrayList<>(oneItemCollection);\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> createInstanceCollectionEmpty() {\n+        return new CopyOnWriteArrayList<>(emptyCollection);\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> createInstanceDefault() {\n+        return new CopyOnWriteArrayList<Object>();\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> readInstance() throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(oneInstanceBytes))) {\n+            return (CopyOnWriteArrayList<?>) objIn.readObject();\n+        }\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> readInstanceEmpty() throws IOException, ClassNotFoundException {\n+        try (ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(emptyInstanceBytes))) {\n+            return (CopyOnWriteArrayList<?>) objIn.readObject();\n+        }\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> removeObjectLastRemaining() {\n+        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n+        list.add(\"\");\n+        list.remove(\"\");\n+        return list;\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> removeIndexLastRemaining() {\n+        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n+        list.add(\"\");\n+        list.remove(0);\n+        return list;\n+    }\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> removeObject() {\n+        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n+        list.add(\"\");\n+        list.add(\"a\");\n+        list.remove(\"\");\n+        return list;\n+    }\n+\n+    @Benchmark\n+    public CopyOnWriteArrayList<?> remove() {\n+        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>();\n+        list.add(\"\");\n+        list.add(\"a\");\n+        list.remove(0);\n+        return list;\n+    }\n+}\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/CopyOnWriteArrayListBenchmark.java","additions":166,"deletions":0,"binary":false,"changes":166,"status":"added"},{"patch":"@@ -3,0 +3,1 @@\n+ * Copyright (c) 2024, Alibaba Group Holding Limited. All rights reserved.\n@@ -38,0 +39,1 @@\n+import java.util.Enumeration;\n@@ -130,0 +132,15 @@\n+    @Benchmark\n+    public int testConcurrentHashMapIterators() {\n+        ConcurrentHashMap<Integer, Integer> map = (ConcurrentHashMap<Integer, Integer>) staticMap;\n+        int sum = 0;\n+        Enumeration it = map.elements();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        it = map.keys();\n+        while (it.hasMoreElements()) {\n+            sum += (int) it.nextElement();\n+        }\n+        return sum;\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/concurrent\/Maps.java","additions":17,"deletions":0,"binary":false,"changes":17,"status":"modified"},{"patch":"@@ -63,0 +63,6 @@\n+    public static void main(String... args) {\n+        FindAny findAny = new FindAny();\n+        findAny.size = 100000;\n+        findAny.seq_invoke();\n+        findAny.par_invoke();\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/java\/util\/stream\/ops\/ref\/FindAny.java","additions":6,"deletions":0,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -125,0 +125,1 @@\n+                null,\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/CodeAttributeTools.java","additions":1,"deletions":0,"binary":false,"changes":1,"status":"modified"},{"patch":"@@ -27,1 +27,0 @@\n-import java.lang.classfile.TypeKind;\n@@ -145,1 +144,1 @@\n-                      .withCode(codeb -> codeb.loadLocal(TypeKind.ReferenceType, 0)\n+                      .withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n@@ -147,1 +146,1 @@\n-                                              .return_(VoidType)\n+                                              .return_(VOID)\n@@ -193,1 +192,1 @@\n-                          mb -> mb.withCode(codeb -> codeb.loadLocal(ReferenceType, 0)\n+                          mb -> mb.withCode(codeb -> codeb.loadLocal(REFERENCE, 0)\n","filename":"test\/micro\/org\/openjdk\/bench\/jdk\/classfile\/Write.java","additions":3,"deletions":4,"binary":false,"changes":7,"status":"modified"},{"patch":"@@ -2,1 +2,1 @@\n- * Copyright (c) 2022, Oracle and\/or its affiliates. All rights reserved.\n+ * Copyright (c) 2022, 2024, Oracle and\/or its affiliates. All rights reserved.\n@@ -29,0 +29,2 @@\n+import java.util.Random;\n+\n@@ -41,0 +43,10 @@\n+    @Setup(Level.Iteration)\n+    public void setup() {\n+        Random random = new Random(1000);\n+\n+        for (int i = 0; i < 1024; i++) {\n+            INT_ARRAY[i] = random.nextInt();\n+            LONG_ARRAY[i] = random.nextLong();\n+        }\n+    }\n+\n@@ -128,0 +140,7 @@\n+\n+    @Benchmark\n+    public void cmovL_imm_01(Blackhole bh) {\n+        for (int i = 0; i < INT_ARRAY.length; i++) {\n+            bh.consume(INT_ARRAY[i] > 0 ? 1L : 0L);\n+        }\n+    }\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/compiler\/x86\/BasicRules.java","additions":20,"deletions":1,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -57,0 +57,2 @@\n+    public volatile Object lockObject3Inflated;\n+    public volatile Object lockObject4Inflated;\n@@ -65,0 +67,15 @@\n+        lockObject3Inflated = new Object();\n+        lockObject4Inflated = new Object();\n+\n+        \/\/ Inflate the lock to use an ObjectMonitor\n+        try {\n+          synchronized (lockObject3Inflated) {\n+            lockObject3Inflated.wait(1);\n+          }\n+          synchronized (lockObject4Inflated) {\n+            lockObject4Inflated.wait(1);\n+          }\n+        } catch (InterruptedException e) {\n+          throw new RuntimeException(e);\n+        }\n+\n@@ -71,1 +88,1 @@\n-    public void testSimpleLockUnlock() {\n+    public void testBasicSimpleLockUnlockLocal() {\n@@ -81,0 +98,34 @@\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform a synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedSimpleLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n@@ -83,1 +134,1 @@\n-    public void testRecursiveLockUnlock() {\n+    public void testBasicRecursiveLockUnlockLocal() {\n@@ -95,0 +146,13 @@\n+    \/** Perform a recursive synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testBasicRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                synchronized (lockObject1) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n@@ -97,1 +161,1 @@\n-    public void testSerialLockUnlock() {\n+    public void testBasicSerialLockUnlockLocal() {\n@@ -109,0 +173,120 @@\n+  \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testBasicSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject1) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject1) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same local object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                dummyInt1++;\n+            }\n+            synchronized (localObject) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject3Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleSerialLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+            }\n+            synchronized (lockObject4Inflated) {\n+                dummyInt2++;\n+            }\n+        }\n+    }\n+\n+    \/** Perform two synchronized after each other on the same object. *\/\n+    @Benchmark\n+    public void testInflatedMultipleRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                dummyInt1++;\n+                synchronized (lockObject4Inflated) {\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+      \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        synchronized (localObject) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveOnlyLockUnlock() {\n+        synchronized (lockObject3Inflated) {\n+            for (int i = 0; i < innerCount; i++) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on a local object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlockLocal() {\n+        Object localObject = lockObject3Inflated;\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (localObject) {\n+                synchronized (localObject) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n+    \/** Perform a recursive-only synchronized on an object within a loop. *\/\n+    @Benchmark\n+    public void testInflatedRecursiveLockUnlock() {\n+        for (int i = 0; i < innerCount; i++) {\n+            synchronized (lockObject3Inflated) {\n+                synchronized (lockObject3Inflated) {\n+                    dummyInt1++;\n+                    dummyInt2++;\n+                }\n+            }\n+        }\n+    }\n+\n","filename":"test\/micro\/org\/openjdk\/bench\/vm\/lang\/LockUnlock.java","additions":187,"deletions":3,"binary":false,"changes":190,"status":"modified"}]}