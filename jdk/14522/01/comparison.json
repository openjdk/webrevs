{"files":[{"patch":"@@ -3534,2 +3534,2 @@\n-\/\/ Allpaths backwards scan from loop tail, terminating each path at first safepoint\n-\/\/ encountered.  Helper for check_safepts.\n+\/\/ Allpaths backwards scan. Starting at the head, traversing all backedges, and the body. Terminating each path at first\n+\/\/ safepoint encountered.  Helper for check_safepts.\n@@ -3538,1 +3538,1 @@\n-  stack.push(_tail);\n+  stack.push(_head);\n@@ -3540,1 +3540,1 @@\n-  visited.set(_tail->_idx);\n+  visited.set(_head->_idx);\n@@ -3548,1 +3548,2 @@\n-        _required_safept->push(n);  \/\/ save the one closest to the tail\n+        \/\/ save the first we run into on that path: closest to the tail if the head has a single backedge\n+        _required_safept->push(n);\n@@ -3553,1 +3554,1 @@\n-      uint end   = n->is_Region() && !n->is_Loop() ? n->req() : start + 1;\n+      uint end   = n->is_Region() && (!n->is_Loop() || n == _head) ? n->req() : start + 1;\n@@ -3625,1 +3626,1 @@\n-  if (!_head->is_CountedLoop() && !_has_sfpt && _parent != nullptr && !_irreducible) {\n+  if (!_head->is_CountedLoop() && !_has_sfpt && _parent != nullptr) {\n@@ -3629,9 +3630,6 @@\n-    \/\/ Scan the dom-path nodes from tail to head\n-    for (Node* n = tail(); n != _head; n = _phase->idom(n)) {\n-      if (n->is_Call() && n->as_Call()->guaranteed_safepoint()) {\n-        has_call = true;\n-        _has_sfpt = 1;          \/\/ Then no need for a safept!\n-        break;\n-      } else if (n->Opcode() == Op_SafePoint) {\n-        if (_phase->get_loop(n) == this) {\n-          has_local_ncsfpt = true;\n+    if (!_irreducible) {\n+      \/\/ Scan the dom-path nodes from tail to head\n+      for (Node* n = tail(); n != _head; n = _phase->idom(n)) {\n+        if (n->is_Call() && n->as_Call()->guaranteed_safepoint()) {\n+          has_call = true;\n+          _has_sfpt = 1;          \/\/ Then no need for a safept!\n@@ -3639,33 +3637,38 @@\n-        }\n-        if (nonlocal_ncsfpt == nullptr) {\n-          nonlocal_ncsfpt = n; \/\/ save the one closest to the tail\n-        }\n-      } else {\n-        IdealLoopTree* nlpt = _phase->get_loop(n);\n-        if (this != nlpt) {\n-          \/\/ If at an inner loop tail, see if the inner loop has already\n-          \/\/ recorded seeing a call on the dom-path (and stop.)  If not,\n-          \/\/ jump to the head of the inner loop.\n-          assert(is_member(nlpt), \"nested loop\");\n-          Node* tail = nlpt->_tail;\n-          if (tail->in(0)->is_If()) tail = tail->in(0);\n-          if (n == tail) {\n-            \/\/ If inner loop has call on dom-path, so does outer loop\n-            if (nlpt->_has_sfpt) {\n-              has_call = true;\n-              _has_sfpt = 1;\n-              break;\n-            }\n-            \/\/ Skip to head of inner loop\n-            assert(_phase->is_dominator(_head, nlpt->_head), \"inner head dominated by outer head\");\n-            n = nlpt->_head;\n-            if (_head == n) {\n-              \/\/ this and nlpt (inner loop) have the same loop head. This should not happen because\n-              \/\/ during beautify_loops we call merge_many_backedges. However, infinite loops may not\n-              \/\/ have been attached to the loop-tree during build_loop_tree before beautify_loops,\n-              \/\/ but then attached in the build_loop_tree afterwards, and so still have unmerged\n-              \/\/ backedges. Check if we are indeed in an infinite subgraph, and terminate the scan,\n-              \/\/ since we have reached the loop head of this.\n-              assert(_head->as_Region()->is_in_infinite_subgraph(),\n-                     \"only expect unmerged backedges in infinite loops\");\n-              break;\n+        } else if (n->Opcode() == Op_SafePoint) {\n+          if (_phase->get_loop(n) == this) {\n+            has_local_ncsfpt = true;\n+            break;\n+          }\n+          if (nonlocal_ncsfpt == nullptr) {\n+            nonlocal_ncsfpt = n; \/\/ save the one closest to the tail\n+          }\n+        } else {\n+          IdealLoopTree* nlpt = _phase->get_loop(n);\n+          if (this != nlpt) {\n+            \/\/ If at an inner loop tail, see if the inner loop has already\n+            \/\/ recorded seeing a call on the dom-path (and stop.)  If not,\n+            \/\/ jump to the head of the inner loop.\n+            assert(is_member(nlpt), \"nested loop\");\n+            Node* tail = nlpt->_tail;\n+            if (tail->in(0)->is_If()) tail = tail->in(0);\n+            if (n == tail) {\n+              \/\/ If inner loop has call on dom-path, so does outer loop\n+              if (nlpt->_has_sfpt) {\n+                has_call = true;\n+                _has_sfpt = 1;\n+                break;\n+              }\n+              \/\/ Skip to head of inner loop\n+              assert(_phase->is_dominator(_head, nlpt->_head), \"inner head dominated by outer head\");\n+              n = nlpt->_head;\n+              if (_head == n) {\n+                \/\/ this and nlpt (inner loop) have the same loop head. This should not happen because\n+                \/\/ during beautify_loops we call merge_many_backedges. However, infinite loops may not\n+                \/\/ have been attached to the loop-tree during build_loop_tree before beautify_loops,\n+                \/\/ but then attached in the build_loop_tree afterwards, and so still have unmerged\n+                \/\/ backedges. Check if we are indeed in an infinite subgraph, and terminate the scan,\n+                \/\/ since we have reached the loop head of this.\n+                assert(_head->as_Region()->is_in_infinite_subgraph(),\n+                       \"only expect unmerged backedges in infinite loops\");\n+                break;\n+              }\n","filename":"src\/hotspot\/share\/opto\/loopnode.cpp","additions":52,"deletions":49,"binary":false,"changes":101,"status":"modified"},{"patch":"@@ -0,0 +1,91 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+super public class MalformedControlIrreducibleLoop\n+\tversion 52:0\n+{\n+  public Method \"<init>\":\"()V\"\n+\tstack 1 locals 1\n+  {\n+\t\taload_0;\n+\t\tinvokespecial\tMethod java\/lang\/Object.\"<init>\":\"()V\";\n+\t\treturn;\n+  }\n+  \/* same as:\n+      public static void actualTest(int flag) {\n+        int i = 1;\n+        int j = 1;\n+        if (flag == 2) {\n+            \/\/ goto second_entry;\n+        }\n+        loop:\n+        for (;;) {\n+            i = 1;\n+            \/\/ second_entry:\n+            do {\n+                if (i == 1) {\n+                    continue loop; \/\/ goto loop\n+                }\n+                i *= 2;\n+                j *= 2;\n+            } while (j < 2);\n+            break;\n+        }\n+    }\n+  *\/\n+  public static Method actualTest:\"(I)V\"\n+\tstack 2 locals 3\n+  {\n+\t\ticonst_1;\n+\t\tistore_1;\n+\t\ticonst_1;\n+\t\tistore_2;\n+\t\tiload_0;\n+\t\ticonst_2;\n+\t\tif_icmpne\tL11;\n+\tL9:\tstack_frame_type append;\n+\t\tlocals_map int, int;\n+\t\ticonst_1;\n+\t\tistore_1;\n+\tL11:\tstack_frame_type same;\n+\t\tiload_1;\n+\t\ticonst_1;\n+\t\tif_icmpeq\tL9;\n+\tL19:\tstack_frame_type same;\n+\t\tiload_1;\n+\t\ticonst_2;\n+\t\timul;\n+\t\tistore_1;\n+\t\tiload_2;\n+\t\ticonst_2;\n+\t\timul;\n+\t\tistore_2;\n+\t\tiload_2;\n+\t\ticonst_2;\n+\t\tif_icmplt\tL11;\n+\t\tgoto\tL35;\n+\tL35:\tstack_frame_type same;\n+\t\treturn;\n+  }\n+\n+} \/\/ end Class TestMalformedControlIrreducibleLoop\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/MalformedControlIrreducibleLoop.jasm","additions":91,"deletions":0,"binary":false,"changes":91,"status":"added"},{"patch":"@@ -0,0 +1,46 @@\n+\/*\n+ * Copyright (c) 2023, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+\/*\n+ * @test\n+ * @bug 8307927\n+ * @summary C2: \"malformed control flow\" with irreducible loop\n+ * @compile MalformedControlIrreducibleLoop.jasm\n+ * @run main\/othervm -Xcomp -XX:-TieredCompilation -XX:CompileOnly=TestMalformedControlIrreducibleLoop::test TestMalformedControlIrreducibleLoop\n+ *\/\n+\n+public class TestMalformedControlIrreducibleLoop {\n+    public static void main(String[] args) {\n+        new MalformedControlIrreducibleLoop();\n+        test(false);\n+    }\n+\n+    private static void test(boolean flag) {\n+        int i;\n+        for (i = 1; i < 2; i *= 2) {\n+        }\n+        if (flag) {\n+            MalformedControlIrreducibleLoop.actualTest(i);\n+        }\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/TestMalformedControlIrreducibleLoop.java","additions":46,"deletions":0,"binary":false,"changes":46,"status":"added"}]}