{"files":[{"patch":"@@ -133,0 +133,3 @@\n+TOOL_VARHANDLEGUARDMETHODGENERATOR = $(JAVA_SMALL) -cp $(BUILDTOOLS_OUTPUTDIR)\/jdk_tools_classes \\\n+    build.tools.methodhandle.VarHandleGuardMethodGenerator\n+\n","filename":"make\/ToolsJdk.gmk","additions":3,"deletions":0,"binary":false,"changes":3,"status":"modified"},{"patch":"@@ -0,0 +1,325 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+\n+package build.tools.methodhandle;\n+\n+import java.io.PrintWriter;\n+import java.lang.classfile.TypeKind;\n+import java.lang.invoke.MethodType;\n+import java.lang.invoke.VarHandle;\n+import java.lang.reflect.Method;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\/**\n+ * A helper program to generate the VarHandleGuards class with a set of\n+ * static guard methods each of which corresponds to a particular shape and\n+ * performs a type check of the symbolic type descriptor with the VarHandle\n+ * type descriptor before linking\/invoking to the underlying operation as\n+ * characterized by the operation member name on the VarForm of the\n+ * VarHandle.\n+ * <p>\n+ * The generated class essentially encapsulates pre-compiled LambdaForms,\n+ * one for each method, for the most common set of method signatures.\n+ * This reduces static initialization costs, footprint costs, and circular\n+ * dependencies that may arise if a class is generated per LambdaForm.\n+ * <p>\n+ * A maximum of L*T*S methods will be generated where L is the number of\n+ * access modes kinds (or unique operation signatures) and T is the number\n+ * of variable types and S is the number of shapes (such as instance field,\n+ * static field, or array access).\n+ * If there are 4 unique operation signatures, 5 basic types (Object, int,\n+ * long, float, double), and 3 shapes then a maximum of 60 methods will be\n+ * generated.  However, the number is likely to be less since there may\n+ * be duplicate signatures.\n+ * <p>\n+ * Each method is annotated with @LambdaForm.Compiled to inform the runtime\n+ * that such methods should be treated as if a method of a class that is the\n+ * result of compiling a LambdaForm.  Annotation of such methods is\n+ * important for correct evaluation of certain assertions and method return\n+ * type profiling in HotSpot.\n+ *\n+ * @see java.lang.invoke.GenerateJLIClassesHelper\n+ *\/\n+public final class VarHandleGuardMethodGenerator {\n+\n+    static final String CLASS_HEADER = \"\"\"\n+            \/*\n+             * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n+             * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+             *\n+             * This code is free software; you can redistribute it and\/or modify it\n+             * under the terms of the GNU General Public License version 2 only, as\n+             * published by the Free Software Foundation.  Oracle designates this\n+             * particular file as subject to the \"Classpath\" exception as provided\n+             * by Oracle in the LICENSE file that accompanied this code.\n+             *\n+             * This code is distributed in the hope that it will be useful, but WITHOUT\n+             * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+             * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+             * version 2 for more details (a copy is included in the LICENSE file that\n+             * accompanied this code).\n+             *\n+             * You should have received a copy of the GNU General Public License version\n+             * 2 along with this work; if not, write to the Free Software Foundation,\n+             * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+             *\n+             * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+             * or visit www.oracle.com if you need additional information or have any\n+             * questions.\n+             *\/\n+            package java.lang.invoke;\n+\n+            import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n+            import jdk.internal.vm.annotation.ForceInline;\n+            import jdk.internal.vm.annotation.Hidden;\n+\n+            \/\/ This file is generated by build.tools.methodhandle.VarHandleGuardMethodGenerator.\n+            \/\/ Do not edit!\n+            @AOTSafeClassInitializer\n+            final class VarHandleGuards {\n+            \"\"\";\n+\n+    static final String GUARD_METHOD_SIG_TEMPLATE = \"<RETURN> <NAME>_<SIGNATURE>(<PARAMS>)\";\n+\n+    static final String GUARD_METHOD_TEMPLATE =\n+            \"\"\"\n+                    @ForceInline\n+                    @LambdaForm.Compiled\n+                    @Hidden\n+                    static final <METHOD> throws Throwable {\n+                        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+                        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+                            <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\n+                        } else {\n+                            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+                            <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+                        }\n+                    }\"\"\";\n+\n+    static final String GUARD_METHOD_TEMPLATE_V =\n+            \"\"\"\n+                    @ForceInline\n+                    @LambdaForm.Compiled\n+                    @Hidden\n+                    static final <METHOD> throws Throwable {\n+                        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n+                        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n+                            MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+                        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n+                            MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n+                        } else {\n+                            MethodHandle mh = handle.getMethodHandle(ad.mode);\n+                            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n+                        }\n+                    }\"\"\";\n+\n+    \/\/ A template for deriving the operations\n+    \/\/ could be supported by annotating VarHandle directly with the\n+    \/\/ operation kind and shape\n+    interface VarHandleTemplate {\n+        Object get();\n+\n+        void set(Object value);\n+\n+        boolean compareAndSet(Object actualValue, Object expectedValue);\n+\n+        Object compareAndExchange(Object actualValue, Object expectedValue);\n+\n+        Object getAndUpdate(Object value);\n+    }\n+\n+    record HandleType(Class<?> receiver, Class<?>... intermediates) {\n+    }\n+\n+    public static void main(String... args) throws Throwable {\n+        if (args.length != 1) {\n+            System.err.println(\"Usage: java VarHandleGuardMethodGenerator VarHandleGuards.java\");\n+            System.exit(1);\n+        }\n+\n+        Path outputFile = Path.of(args[0]);\n+\n+        try (PrintWriter pw = new PrintWriter(Files.newBufferedWriter(\n+                outputFile,\n+                StandardCharsets.UTF_8,\n+                StandardOpenOption.CREATE,\n+                StandardOpenOption.TRUNCATE_EXISTING))) {\n+            print(pw);\n+        }\n+    }\n+\n+    public static void print(PrintWriter pw) {\n+        pw.println(CLASS_HEADER);\n+\n+        \/\/ Declare the stream of shapes\n+        List<HandleType> hts = List.of(\n+                \/\/ Object->T\n+                new HandleType(Object.class),\n+\n+                \/\/ <static>->T\n+                new HandleType(null),\n+\n+                \/\/ Array[index]->T\n+                new HandleType(Object.class, int.class),\n+\n+                \/\/ MS[base]->T\n+                new HandleType(Object.class, long.class),\n+\n+                \/\/ MS[base][offset]->T\n+                new HandleType(Object.class, long.class, long.class)\n+        );\n+\n+        \/\/ The 5 JVM calling convention types\n+        List<Class<?>> basicTypes = List.of(Object.class, int.class, long.class, float.class, double.class);\n+\n+        Stream.of(VarHandleTemplate.class.getMethods()).<MethodType>\n+                        mapMulti((m, sink) -> {\n+                    for (var ht : hts) {\n+                        for (var bt : basicTypes) {\n+                            sink.accept(generateMethodType(m, ht.receiver, bt, ht.intermediates));\n+                        }\n+                    }\n+                }).\n+                distinct().\n+                map(VarHandleGuardMethodGenerator::generateMethod).\n+                forEach(pw::println);\n+\n+        pw.println(\"}\");\n+    }\n+\n+    static MethodType generateMethodType(Method m, Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n+        Class<?> returnType = m.getReturnType() == Object.class\n+                ? value : m.getReturnType();\n+\n+        List<Class<?>> params = new ArrayList<>();\n+        if (receiver != null)\n+            params.add(receiver);\n+        Collections.addAll(params, intermediates);\n+        for (var p : m.getParameters()) {\n+            params.add(value);\n+        }\n+        return MethodType.methodType(returnType, params);\n+    }\n+\n+    static String generateMethod(MethodType mt) {\n+        Class<?> returnType = mt.returnType();\n+\n+        var params = new LinkedHashMap<String, String>();\n+        params.put(\"handle\", className(VarHandle.class));\n+        for (int i = 0; i < mt.parameterCount(); i++) {\n+            params.put(\"arg\" + i, className(mt.parameterType(i)));\n+        }\n+        params.put(\"ad\", \"VarHandle.AccessDescriptor\");\n+\n+        \/\/ Generate method signature line\n+        String RETURN = className(returnType);\n+        String NAME = \"guard\";\n+        String SIGNATURE = getSignature(mt);\n+        String PARAMS = params.entrySet().stream().\n+                map(e -> e.getValue() + \" \" + e.getKey()).\n+                collect(Collectors.joining(\", \"));\n+        String METHOD = GUARD_METHOD_SIG_TEMPLATE.\n+                replace(\"<RETURN>\", RETURN).\n+                replace(\"<NAME>\", NAME).\n+                replace(\"<SIGNATURE>\", SIGNATURE).\n+                replace(\"<PARAMS>\", PARAMS);\n+\n+        \/\/ Generate method\n+        params.remove(\"ad\");\n+\n+        List<String> LINK_TO_STATIC_ARGS = new ArrayList<>(params.keySet());\n+        LINK_TO_STATIC_ARGS.add(\"handle.vform.getMemberName(ad.mode)\");\n+\n+        List<String> LINK_TO_INVOKER_ARGS = new ArrayList<>(params.keySet());\n+        LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".asDirect()\");\n+\n+        RETURN = returnType == void.class\n+                ? \"\"\n+                : returnType == Object.class\n+                ? \"return \"\n+                : \"return (\" + returnType.getName() + \") \";\n+\n+        String RESULT_ERASED = returnType == void.class\n+                ? \"\"\n+                : returnType != Object.class\n+                ? \"return (\" + returnType.getName() + \") \"\n+                : \"Object r = \";\n+\n+        String RETURN_ERASED = returnType != Object.class\n+                ? \"\"\n+                : \"\\n        return ad.returnType.cast(r);\";\n+\n+        String template = returnType == void.class\n+                ? GUARD_METHOD_TEMPLATE_V\n+                : GUARD_METHOD_TEMPLATE;\n+        return template.\n+                replace(\"<METHOD>\", METHOD).\n+                replace(\"<NAME>\", NAME).\n+                replaceAll(\"<RETURN>\", RETURN).\n+                replace(\"<RESULT_ERASED>\", RESULT_ERASED).\n+                replace(\"<RETURN_ERASED>\", RETURN_ERASED).\n+                replaceAll(\"<LINK_TO_STATIC_ARGS>\", String.join(\", \", LINK_TO_STATIC_ARGS)).\n+                replace(\"<LINK_TO_INVOKER_ARGS>\", String.join(\", \", LINK_TO_INVOKER_ARGS))\n+                .indent(4);\n+    }\n+\n+    static String className(Class<?> c) {\n+        String n = c.getCanonicalName();\n+        if (n == null)\n+            throw new IllegalArgumentException(\"Not representable in source code: \" + c);\n+        if (!c.isPrimitive() && c.getPackageName().equals(\"java.lang\")) {\n+            n = n.substring(\"java.lang.\".length());\n+        } else if (c.getPackageName().equals(\"java.lang.invoke\")) {\n+            n = n.substring(\"java.lang.invoke.\".length());\n+        }\n+        return n;\n+    }\n+\n+    static String getSignature(MethodType m) {\n+        StringBuilder sb = new StringBuilder(m.parameterCount() + 1);\n+\n+        for (int i = 0; i < m.parameterCount(); i++) {\n+            Class<?> pt = m.parameterType(i);\n+            sb.append(getCharType(pt));\n+        }\n+\n+        sb.append('_').append(getCharType(m.returnType()));\n+\n+        return sb.toString();\n+    }\n+\n+    static char getCharType(Class<?> pt) {\n+        return TypeKind.from(pt).upperBound().descriptorString().charAt(0);\n+    }\n+}\n","filename":"make\/jdk\/src\/classes\/build\/tools\/methodhandle\/VarHandleGuardMethodGenerator.java","additions":325,"deletions":0,"binary":false,"changes":325,"status":"added"},{"patch":"@@ -305,0 +305,12 @@\n+GENSRC_VARHANDLEGUARDS := $(VARHANDLES_GENSRC_DIR)\/VarHandleGuards.java\n+\n+$(GENSRC_VARHANDLEGUARDS): $(BUILD_TOOLS_JDK)\n+\t$(call LogInfo, Generating $@)\n+\t$(call MakeTargetDir)\n+\t$(TOOL_VARHANDLEGUARDMETHODGENERATOR) \\\n+\t    $(GENSRC_VARHANDLEGUARDS)\n+\n+TARGETS += $(GENSRC_VARHANDLEGUARDS)\n+\n+################################################################################\n+\n","filename":"make\/modules\/java.base\/gensrc\/GensrcVarHandles.gmk","additions":12,"deletions":0,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -1,1619 +0,0 @@\n-\/*\n- * Copyright (c) 2014, 2025, Oracle and\/or its affiliates. All rights reserved.\n- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n- *\n- * This code is free software; you can redistribute it and\/or modify it\n- * under the terms of the GNU General Public License version 2 only, as\n- * published by the Free Software Foundation.  Oracle designates this\n- * particular file as subject to the \"Classpath\" exception as provided\n- * by Oracle in the LICENSE file that accompanied this code.\n- *\n- * This code is distributed in the hope that it will be useful, but WITHOUT\n- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n- * version 2 for more details (a copy is included in the LICENSE file that\n- * accompanied this code).\n- *\n- * You should have received a copy of the GNU General Public License version\n- * 2 along with this work; if not, write to the Free Software Foundation,\n- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n- *\n- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n- * or visit www.oracle.com if you need additional information or have any\n- * questions.\n- *\/\n-package java.lang.invoke;\n-\n-import jdk.internal.vm.annotation.AOTSafeClassInitializer;\n-import jdk.internal.vm.annotation.ForceInline;\n-import jdk.internal.vm.annotation.Hidden;\n-\n-\/\/ This class is auto-generated by java.lang.invoke.VarHandles$GuardMethodGenerator. Do not edit.\n-@AOTSafeClassInitializer\n-final class VarHandleGuards {\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_L_L(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_L_I(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_L_J(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_L_F(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_L_D(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard__L(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard__I(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard__J(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard__F(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard__D(VarHandle handle, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect());\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LI_L(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LI_I(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LI_J(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LI_F(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LI_D(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJ_L(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJ_I(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJ_J(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJ_F(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJ_D(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJJ_L(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJJ_I(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJJ_F(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJJ_D(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LL_V(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LI_V(VarHandle handle, Object arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJ_V(VarHandle handle, Object arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LF_V(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LD_V(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_L_V(VarHandle handle, Object arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_I_V(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_J_V(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_F_V(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_D_V(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LIL_V(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LII_V(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LIJ_V(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LIF_V(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LID_V(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJL_V(VarHandle handle, Object arg0, long arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJI_V(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJF_V(VarHandle handle, Object arg0, long arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJD_V(VarHandle handle, Object arg0, long arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJL_V(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJI_V(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJJ_V(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJF_V(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final void guard_LJJD_V(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-            MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LLL_Z(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LII_Z(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LFF_Z(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LDD_Z(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LL_Z(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_II_Z(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_JJ_Z(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_FF_Z(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_DD_Z(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LILL_Z(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIII_Z(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIJJ_Z(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIFF_Z(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LIDD_Z(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJLL_Z(VarHandle handle, Object arg0, long arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJII_Z(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJFF_Z(VarHandle handle, Object arg0, long arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJDD_Z(VarHandle handle, Object arg0, long arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJLL_Z(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, Object arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJII_Z(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, int arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJJJ_Z(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, long arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJFF_Z(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, float arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final boolean guard_LJJDD_Z(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, double arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (boolean) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (boolean) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LLL_L(VarHandle handle, Object arg0, Object arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LII_I(VarHandle handle, Object arg0, int arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LFF_F(VarHandle handle, Object arg0, float arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LDD_D(VarHandle handle, Object arg0, double arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LL_L(VarHandle handle, Object arg0, Object arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_II_I(VarHandle handle, int arg0, int arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_JJ_J(VarHandle handle, long arg0, long arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_FF_F(VarHandle handle, float arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_DD_D(VarHandle handle, double arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LILL_L(VarHandle handle, Object arg0, int arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LIII_I(VarHandle handle, Object arg0, int arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LIJJ_J(VarHandle handle, Object arg0, int arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LIFF_F(VarHandle handle, Object arg0, int arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LIDD_D(VarHandle handle, Object arg0, int arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJLL_L(VarHandle handle, Object arg0, long arg1, Object arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJII_I(VarHandle handle, Object arg0, long arg1, int arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJFF_F(VarHandle handle, Object arg0, long arg1, float arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJDD_D(VarHandle handle, Object arg0, long arg1, double arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJJLL_L(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, Object arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJJII_I(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, int arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LJJJJ_J(VarHandle handle, Object arg0, long arg1, long arg2, long arg3, long arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJJFF_F(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, float arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJJDD_D(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, double arg4, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, arg4, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3, arg4);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LF_F(VarHandle handle, Object arg0, float arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LD_D(VarHandle handle, Object arg0, double arg1, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_I_I(VarHandle handle, int arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_J_J(VarHandle handle, long arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_F_F(VarHandle handle, float arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_D_D(VarHandle handle, double arg0, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LIL_L(VarHandle handle, Object arg0, int arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final long guard_LIJ_J(VarHandle handle, Object arg0, int arg1, long arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (long) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (long) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LIF_F(VarHandle handle, Object arg0, int arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LID_D(VarHandle handle, Object arg0, int arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJL_L(VarHandle handle, Object arg0, long arg1, Object arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJI_I(VarHandle handle, Object arg0, long arg1, int arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJF_F(VarHandle handle, Object arg0, long arg1, float arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJD_D(VarHandle handle, Object arg0, long arg1, double arg2, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final Object guard_LJJL_L(VarHandle handle, Object arg0, long arg1, long arg2, Object arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            Object r = MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-            return ad.returnType.cast(r);\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final int guard_LJJI_I(VarHandle handle, Object arg0, long arg1, long arg2, int arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (int) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (int) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final float guard_LJJF_F(VarHandle handle, Object arg0, long arg1, long arg2, float arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (float) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (float) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-    @ForceInline\n-    @LambdaForm.Compiled\n-    @Hidden\n-    static final double guard_LJJD_D(VarHandle handle, Object arg0, long arg1, long arg2, double arg3, VarHandle.AccessDescriptor ad) throws Throwable {\n-        boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-        if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-            return (double) MethodHandle.linkToStatic(handle, arg0, arg1, arg2, arg3, handle.vform.getMemberName(ad.mode));\n-        } else {\n-            MethodHandle mh = handle.getMethodHandle(ad.mode);\n-            return (double) mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(handle.asDirect(), arg0, arg1, arg2, arg3);\n-        }\n-    }\n-\n-}\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandleGuards.java","additions":0,"deletions":1619,"binary":false,"changes":1619,"status":"deleted"},{"patch":"@@ -660,238 +660,0 @@\n-\n-\/\/    \/**\n-\/\/     * A helper program to generate the VarHandleGuards class with a set of\n-\/\/     * static guard methods each of which corresponds to a particular shape and\n-\/\/     * performs a type check of the symbolic type descriptor with the VarHandle\n-\/\/     * type descriptor before linking\/invoking to the underlying operation as\n-\/\/     * characterized by the operation member name on the VarForm of the\n-\/\/     * VarHandle.\n-\/\/     * <p>\n-\/\/     * The generated class essentially encapsulates pre-compiled LambdaForms,\n-\/\/     * one for each method, for the most set of common method signatures.\n-\/\/     * This reduces static initialization costs, footprint costs, and circular\n-\/\/     * dependencies that may arise if a class is generated per LambdaForm.\n-\/\/     * <p>\n-\/\/     * A maximum of L*T*S methods will be generated where L is the number of\n-\/\/     * access modes kinds (or unique operation signatures) and T is the number\n-\/\/     * of variable types and S is the number of shapes (such as instance field,\n-\/\/     * static field, or array access).\n-\/\/     * If there are 4 unique operation signatures, 5 basic types (Object, int,\n-\/\/     * long, float, double), and 3 shapes then a maximum of 60 methods will be\n-\/\/     * generated.  However, the number is likely to be less since there\n-\/\/     * be duplicate signatures.\n-\/\/     * <p>\n-\/\/     * Each method is annotated with @LambdaForm.Compiled to inform the runtime\n-\/\/     * that such methods should be treated as if a method of a class that is the\n-\/\/     * result of compiling a LambdaForm.  Annotation of such methods is\n-\/\/     * important for correct evaluation of certain assertions and method return\n-\/\/     * type profiling in HotSpot.\n-\/\/     *\/\n-\/\/    public static class GuardMethodGenerator {\n-\/\/\n-\/\/        static final String GUARD_METHOD_SIG_TEMPLATE = \"<RETURN> <NAME>_<SIGNATURE>(<PARAMS>)\";\n-\/\/\n-\/\/        static final String GUARD_METHOD_TEMPLATE =\n-\/\/                \"\"\"\n-\/\/                @ForceInline\n-\/\/                @LambdaForm.Compiled\n-\/\/                @Hidden\n-\/\/                static final <METHOD> throws Throwable {\n-\/\/                    boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-\/\/                    if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-\/\/                        <RESULT_ERASED>MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);<RETURN_ERASED>\n-\/\/                    } else {\n-\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n-\/\/                        <RETURN>mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n-\/\/                    }\n-\/\/                }\"\"\";\n-\/\/\n-\/\/        static final String GUARD_METHOD_TEMPLATE_V =\n-\/\/                \"\"\"\n-\/\/                @ForceInline\n-\/\/                @LambdaForm.Compiled\n-\/\/                @Hidden\n-\/\/                static final <METHOD> throws Throwable {\n-\/\/                    boolean direct = handle.checkAccessModeThenIsDirect(ad);\n-\/\/                    if (direct && handle.vform.methodType_table[ad.type] == ad.symbolicMethodTypeErased) {\n-\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n-\/\/                    } else if (direct && handle.vform.getMethodType_V(ad.type) == ad.symbolicMethodTypeErased) {\n-\/\/                        MethodHandle.linkToStatic(<LINK_TO_STATIC_ARGS>);\n-\/\/                    } else {\n-\/\/                        MethodHandle mh = handle.getMethodHandle(ad.mode);\n-\/\/                        mh.asType(ad.symbolicMethodTypeInvoker).invokeBasic(<LINK_TO_INVOKER_ARGS>);\n-\/\/                    }\n-\/\/                }\"\"\";\n-\/\/\n-\/\/        \/\/ A template for deriving the operations\n-\/\/        \/\/ could be supported by annotating VarHandle directly with the\n-\/\/        \/\/ operation kind and shape\n-\/\/        interface VarHandleTemplate {\n-\/\/            Object get();\n-\/\/\n-\/\/            void set(Object value);\n-\/\/\n-\/\/            boolean compareAndSet(Object actualValue, Object expectedValue);\n-\/\/\n-\/\/            Object compareAndExchange(Object actualValue, Object expectedValue);\n-\/\/\n-\/\/            Object getAndUpdate(Object value);\n-\/\/        }\n-\/\/\n-\/\/        record HandleType(Class<?> receiver, Class<?>... intermediates) {\n-\/\/        }\n-\/\/\n-\/\/        \/**\n-\/\/         * @param args parameters\n-\/\/         *\/\n-\/\/        public static void main(String[] args) {\n-\/\/            System.out.println(\"package java.lang.invoke;\");\n-\/\/            System.out.println();\n-\/\/            System.out.println(\"import jdk.internal.vm.annotation.AOTSafeClassInitializer;\");\n-\/\/            System.out.println(\"import jdk.internal.vm.annotation.ForceInline;\");\n-\/\/            System.out.println(\"import jdk.internal.vm.annotation.Hidden;\");\n-\/\/            System.out.println();\n-\/\/            System.out.println(\"\/\/ This class is auto-generated by \" +\n-\/\/                               GuardMethodGenerator.class.getName() +\n-\/\/                               \". Do not edit.\");\n-\/\/            System.out.println(\"@AOTSafeClassInitializer\");\n-\/\/            System.out.println(\"final class VarHandleGuards {\");\n-\/\/\n-\/\/            System.out.println();\n-\/\/\n-\/\/            \/\/ Declare the stream of shapes\n-\/\/            List<HandleType> hts = List.of(\n-\/\/                    \/\/ Object->T\n-\/\/                    new HandleType(Object.class),\n-\/\/\n-\/\/                    \/\/ <static>->T\n-\/\/                    new HandleType(null),\n-\/\/\n-\/\/                    \/\/ Array[index]->T\n-\/\/                    new HandleType(Object.class, int.class),\n-\/\/\n-\/\/                    \/\/ MS[base]->T\n-\/\/                    new HandleType(Object.class, long.class),\n-\/\/\n-\/\/                    \/\/ MS[base][offset]->T\n-\/\/                    new HandleType(Object.class, long.class, long.class)\n-\/\/            );\n-\/\/\n-\/\/            Stream.of(VarHandleTemplate.class.getMethods()).<MethodType>\n-\/\/                    mapMulti((m, sink) -> {\n-\/\/                        for (var ht : hts) {\n-\/\/                            for (var bt : LambdaForm.BasicType.ARG_TYPES) {\n-\/\/                                sink.accept(generateMethodType(m, ht.receiver, bt.btClass, ht.intermediates));\n-\/\/                            }\n-\/\/                        }\n-\/\/                    }).\n-\/\/                    distinct().\n-\/\/                    map(GuardMethodGenerator::generateMethod).\n-\/\/                    forEach(System.out::println);\n-\/\/\n-\/\/            System.out.println(\"}\");\n-\/\/        }\n-\/\/\n-\/\/        static MethodType generateMethodType(Method m, Class<?> receiver, Class<?> value, Class<?>... intermediates) {\n-\/\/            Class<?> returnType = m.getReturnType() == Object.class\n-\/\/                                  ? value : m.getReturnType();\n-\/\/\n-\/\/            List<Class<?>> params = new ArrayList<>();\n-\/\/            if (receiver != null)\n-\/\/                params.add(receiver);\n-\/\/            java.util.Collections.addAll(params, intermediates);\n-\/\/            for (var p : m.getParameters()) {\n-\/\/                params.add(value);\n-\/\/            }\n-\/\/            return MethodType.methodType(returnType, params);\n-\/\/        }\n-\/\/\n-\/\/        static String generateMethod(MethodType mt) {\n-\/\/            Class<?> returnType = mt.returnType();\n-\/\/\n-\/\/            var params = new java.util.LinkedHashMap<String, Class<?>>();\n-\/\/            params.put(\"handle\", VarHandle.class);\n-\/\/            for (int i = 0; i < mt.parameterCount(); i++) {\n-\/\/                params.put(\"arg\" + i, mt.parameterType(i));\n-\/\/            }\n-\/\/            params.put(\"ad\", VarHandle.AccessDescriptor.class);\n-\/\/\n-\/\/            \/\/ Generate method signature line\n-\/\/            String RETURN = className(returnType);\n-\/\/            String NAME = \"guard\";\n-\/\/            String SIGNATURE = getSignature(mt);\n-\/\/            String PARAMS = params.entrySet().stream().\n-\/\/                    map(e -> className(e.getValue()) + \" \" + e.getKey()).\n-\/\/                    collect(java.util.stream.Collectors.joining(\", \"));\n-\/\/            String METHOD = GUARD_METHOD_SIG_TEMPLATE.\n-\/\/                    replace(\"<RETURN>\", RETURN).\n-\/\/                    replace(\"<NAME>\", NAME).\n-\/\/                    replace(\"<SIGNATURE>\", SIGNATURE).\n-\/\/                    replace(\"<PARAMS>\", PARAMS);\n-\/\/\n-\/\/            \/\/ Generate method\n-\/\/            params.remove(\"ad\");\n-\/\/\n-\/\/            List<String> LINK_TO_STATIC_ARGS = new ArrayList<>(params.keySet());\n-\/\/            LINK_TO_STATIC_ARGS.add(\"handle.vform.getMemberName(ad.mode)\");\n-\/\/\n-\/\/            List<String> LINK_TO_INVOKER_ARGS = new ArrayList<>(params.keySet());\n-\/\/            LINK_TO_INVOKER_ARGS.set(0, LINK_TO_INVOKER_ARGS.get(0) + \".asDirect()\");\n-\/\/\n-\/\/            RETURN = returnType == void.class\n-\/\/                     ? \"\"\n-\/\/                     : returnType == Object.class\n-\/\/                       ? \"return \"\n-\/\/                       : \"return (\" + returnType.getName() + \") \";\n-\/\/\n-\/\/            String RESULT_ERASED = returnType == void.class\n-\/\/                                   ? \"\"\n-\/\/                                   : returnType != Object.class\n-\/\/                                     ? \"return (\" + returnType.getName() + \") \"\n-\/\/                                     : \"Object r = \";\n-\/\/\n-\/\/            String RETURN_ERASED = returnType != Object.class\n-\/\/                                   ? \"\"\n-\/\/                                   : \"\\n        return ad.returnType.cast(r);\";\n-\/\/\n-\/\/            String template = returnType == void.class\n-\/\/                              ? GUARD_METHOD_TEMPLATE_V\n-\/\/                              : GUARD_METHOD_TEMPLATE;\n-\/\/            return template.\n-\/\/                    replace(\"<METHOD>\", METHOD).\n-\/\/                    replace(\"<NAME>\", NAME).\n-\/\/                    replaceAll(\"<RETURN>\", RETURN).\n-\/\/                    replace(\"<RESULT_ERASED>\", RESULT_ERASED).\n-\/\/                    replace(\"<RETURN_ERASED>\", RETURN_ERASED).\n-\/\/                    replaceAll(\"<LINK_TO_STATIC_ARGS>\", String.join(\", \", LINK_TO_STATIC_ARGS)).\n-\/\/                    replace(\"<LINK_TO_INVOKER_ARGS>\", String.join(\", \", LINK_TO_INVOKER_ARGS))\n-\/\/                    .indent(4);\n-\/\/        }\n-\/\/\n-\/\/        static String className(Class<?> c) {\n-\/\/            String n = c.getName();\n-\/\/            if (n.startsWith(\"java.lang.\")) {\n-\/\/                n = n.replace(\"java.lang.\", \"\");\n-\/\/                if (n.startsWith(\"invoke.\")) {\n-\/\/                    n = n.replace(\"invoke.\", \"\");\n-\/\/                }\n-\/\/            }\n-\/\/            return n.replace('$', '.');\n-\/\/        }\n-\/\/\n-\/\/        static String getSignature(MethodType m) {\n-\/\/            StringBuilder sb = new StringBuilder(m.parameterCount() + 1);\n-\/\/\n-\/\/            for (int i = 0; i < m.parameterCount(); i++) {\n-\/\/                Class<?> pt = m.parameterType(i);\n-\/\/                sb.append(getCharType(pt));\n-\/\/            }\n-\/\/\n-\/\/            sb.append('_').append(getCharType(m.returnType()));\n-\/\/\n-\/\/            return sb.toString();\n-\/\/        }\n-\/\/\n-\/\/        static char getCharType(Class<?> pt) {\n-\/\/            return Wrapper.forBasicType(pt).basicTypeChar();\n-\/\/        }\n-\/\/    }\n","filename":"src\/java.base\/share\/classes\/java\/lang\/invoke\/VarHandles.java","additions":0,"deletions":238,"binary":false,"changes":238,"status":"modified"}]}