{"files":[{"patch":"@@ -1118,0 +1118,77 @@\n+oop ShenandoahHeap::evacuate_object(oop p, Thread* thread) {\n+  if (ShenandoahThreadLocalData::is_oom_during_evac(Thread::current())) {\n+    \/\/ This thread went through the OOM during evac protocol and it is safe to return\n+    \/\/ the forward pointer. It must not attempt to evacuate any more.\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  assert(ShenandoahThreadLocalData::is_evac_allowed(thread), \"must be enclosed in oom-evac scope\");\n+\n+  size_t size = p->size();\n+\n+  assert(!heap_region_containing(p)->is_humongous(), \"never evacuate humongous objects\");\n+\n+  bool alloc_from_gclab = true;\n+  HeapWord* copy = nullptr;\n+\n+#ifdef ASSERT\n+  if (ShenandoahOOMDuringEvacALot &&\n+      (os::random() & 1) == 0) { \/\/ Simulate OOM every ~2nd slow-path call\n+    copy = nullptr;\n+  } else {\n+#endif\n+    if (UseTLAB) {\n+      copy = allocate_from_gclab(thread, size);\n+    }\n+    if (copy == nullptr) {\n+      ShenandoahAllocRequest req = ShenandoahAllocRequest::for_shared_gc(size);\n+      copy = allocate_memory(req);\n+      alloc_from_gclab = false;\n+    }\n+#ifdef ASSERT\n+  }\n+#endif\n+\n+  if (copy == nullptr) {\n+    control_thread()->handle_alloc_failure_evac(size);\n+\n+    _oom_evac_handler.handle_out_of_memory_during_evacuation();\n+\n+    return ShenandoahBarrierSet::resolve_forwarded(p);\n+  }\n+\n+  \/\/ Copy the object:\n+  Copy::aligned_disjoint_words(cast_from_oop<HeapWord*>(p), copy, size);\n+\n+  \/\/ Try to install the new forwarding pointer.\n+  oop copy_val = cast_to_oop(copy);\n+  ContinuationGCSupport::relativize_stack_chunk(copy_val);\n+\n+  oop result = ShenandoahForwarding::try_update_forwardee(p, copy_val);\n+  if (result == copy_val) {\n+    \/\/ Successfully evacuated. Our copy is now the public one!\n+    shenandoah_assert_correct(nullptr, copy_val);\n+    return copy_val;\n+  }  else {\n+    \/\/ Failed to evacuate. We need to deal with the object that is left behind. Since this\n+    \/\/ new allocation is certainly after TAMS, it will be considered live in the next cycle.\n+    \/\/ But if it happens to contain references to evacuated regions, those references would\n+    \/\/ not get updated for this stale copy during this cycle, and we will crash while scanning\n+    \/\/ it the next cycle.\n+    \/\/\n+    \/\/ For GCLAB allocations, it is enough to rollback the allocation ptr. Either the next\n+    \/\/ object will overwrite this stale copy, or the filler object on LAB retirement will\n+    \/\/ do this. For non-GCLAB allocations, we have no way to retract the allocation, and\n+    \/\/ have to explicitly overwrite the copy with the filler object. With that overwrite,\n+    \/\/ we have to keep the fwdptr initialized and pointing to our (stale) copy.\n+    if (alloc_from_gclab) {\n+      ShenandoahThreadLocalData::gclab(thread)->undo_allocation(copy, size);\n+    } else {\n+      fill_with_object(copy, size);\n+      shenandoah_assert_correct(nullptr, copy_val);\n+    }\n+    shenandoah_assert_correct(nullptr, result);\n+    return result;\n+  }\n+}\n+\n@@ -1290,1 +1367,8 @@\n-  tcl->do_thread(_control_thread);\n+  if (_shenandoah_policy->is_at_shutdown()) {\n+    return;\n+  }\n+\n+  if (_control_thread != nullptr) {\n+    tcl->do_thread(_control_thread);\n+  }\n+\n@@ -1636,23 +1720,0 @@\n-class ShenandoahInitMarkUpdateRegionStateClosure : public ShenandoahHeapRegionClosure {\n-private:\n-  ShenandoahMarkingContext* const _ctx;\n-public:\n-  ShenandoahInitMarkUpdateRegionStateClosure() : _ctx(ShenandoahHeap::heap()->marking_context()) {}\n-\n-  void heap_region_do(ShenandoahHeapRegion* r) {\n-    assert(!r->has_live(), \"Region \" SIZE_FORMAT \" should have no live data\", r->index());\n-    if (r->is_active()) {\n-      \/\/ Check if region needs updating its TAMS. We have updated it already during concurrent\n-      \/\/ reset, so it is very likely we don't need to do another write here.\n-      if (_ctx->top_at_mark_start(r) != r->top()) {\n-        _ctx->capture_top_at_mark_start(r);\n-      }\n-    } else {\n-      assert(_ctx->top_at_mark_start(r) == r->top(),\n-             \"Region \" SIZE_FORMAT \" should already have correct TAMS\", r->index());\n-    }\n-  }\n-\n-  bool is_thread_safe() { return true; }\n-};\n-\n@@ -1870,1 +1931,1 @@\n-  \/\/ Step 0. Notify policy to disable event recording.\n+  \/\/ Step 0. Notify policy to disable event recording and prevent visiting gc threads during shutdown\n@@ -2118,1 +2179,1 @@\n-      do_work<ShenandoahConcUpdateRefsClosure>();\n+      do_work<ShenandoahConcUpdateRefsClosure>(worker_id);\n@@ -2121,1 +2182,1 @@\n-      do_work<ShenandoahSTWUpdateRefsClosure>();\n+      do_work<ShenandoahSTWUpdateRefsClosure>(worker_id);\n@@ -2127,1 +2188,1 @@\n-  void do_work() {\n+  void do_work(uint worker_id) {\n@@ -2129,0 +2190,10 @@\n+    if (CONCURRENT && (worker_id == 0)) {\n+      \/\/ We ask the first worker to replenish the Mutator free set by moving regions previously reserved to hold the\n+      \/\/ results of evacuation.  These reserves are no longer necessary because evacuation has completed.\n+      size_t cset_regions = _heap->collection_set()->count();\n+      \/\/ We cannot transfer any more regions than will be reclaimed when the existing collection set is recycled because\n+      \/\/ we need the reclaimed collection set regions to replenish the collector reserves\n+      _heap->free_set()->move_regions_from_collector_to_mutator(cset_regions);\n+    }\n+    \/\/ If !CONCURRENT, there's no value in expanding Mutator free set\n+\n","filename":"src\/hotspot\/share\/gc\/shenandoah\/shenandoahHeap.cpp","additions":99,"deletions":28,"binary":false,"changes":127,"status":"modified"}]}