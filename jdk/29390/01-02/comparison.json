{"files":[{"patch":"@@ -47,0 +47,1 @@\n+#include \"opto\/opcodes.hpp\"\n@@ -1235,2 +1236,7 @@\n-        const TypeVect*  in_vt = st->as_StoreVector()->vect_type();\n-        const TypeVect* out_vt = as_LoadVector()->vect_type();\n+        \/\/ Some kind of masked access or gather\/scatter\n+        if ((Opcode() != Op_LoadVector && Opcode() != Op_StoreVector) || st->Opcode() != Op_StoreVector) {\n+          return nullptr;\n+        }\n+\n+        const TypeVect* in_vt = st->as_StoreVector()->vect_type();\n+        const TypeVect* out_vt = is_Load() ? as_LoadVector()->vect_type() : as_StoreVector()->vect_type();\n@@ -3559,2 +3565,5 @@\n-    \/\/ Ensure vector type is the same\n-    if (!is_StoreVector() || (mem->is_LoadVector() && as_StoreVector()->vect_type() == mem->as_LoadVector()->vect_type())) {\n+    if (!is_StoreVector()) {\n+      result = mem;\n+    } else if (Opcode() == Op_StoreVector && val->Opcode() == Op_LoadVector &&\n+               as_StoreVector()->vect_type() == val->as_LoadVector()->vect_type()) {\n+      \/\/ Ensure vector type is the same\n@@ -3600,1 +3609,0 @@\n-  }\n@@ -3602,11 +3610,15 @@\n-  \/\/ Store the same value that is in the memory, we can elide the store\n-  if (result == this && is_unordered()) {\n-    Node* prev_mem = find_previous_store(phase);\n-    if (prev_mem != nullptr) {\n-      if (prev_mem->is_top()) {\n-        \/\/ find_previous_store returns top when the access is dead\n-        return prev_mem;\n-      }\n-      Node* prev_val = can_see_stored_value(prev_mem, phase);\n-      if (prev_val == val) {\n-        result = mem;\n+    if (result == this) {\n+      \/\/ the store may also apply to zero-bits in an earlier object\n+      Node* prev_mem = find_previous_store(phase);\n+      \/\/ Steps (a), (b):  Walk past independent stores to find an exact match.\n+      if (prev_mem != nullptr) {\n+        if (prev_mem->is_top()) {\n+          \/\/ find_previous_store returns top when the access is dead\n+          return prev_mem;\n+        }\n+        Node* prev_val = can_see_stored_value(prev_mem, phase);\n+        if (prev_val != nullptr && prev_val == val) {\n+          \/\/ prev_val and val might differ by a cast; it would be good\n+          \/\/ to keep the more informative of the two.\n+          result = mem;\n+        }\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":28,"deletions":16,"binary":false,"changes":44,"status":"modified"},{"patch":"@@ -53,1 +53,1 @@\n-        testStore(c1, c2, 1, 0);\n+        Asserts.assertEQ(0, testStore(c2, 0).v);\n@@ -65,3 +65,3 @@\n-    @IR(counts = {IRNode.STORE, \"2\"})\n-    static void testStore(C1 c1, C2 c2, int v1, int v2) {\n-        c1.v = v1;\n+    @IR(counts = {IRNode.STORE, \"1\"}, phase = CompilePhase.BEFORE_MACRO_EXPANSION)\n+    static C1 testStore(C2 c2, int v2) {\n+        C1 c1 = new C1();\n@@ -69,1 +69,2 @@\n-        c1.v = v1;\n+        c1.v = 0;\n+        return c1;\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestFindStore.java","additions":6,"deletions":5,"binary":false,"changes":11,"status":"modified"}]}