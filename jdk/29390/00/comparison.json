{"files":[{"patch":"@@ -555,0 +555,9 @@\n+  \/\/ Trivial case: Non-overlapping values, be careful, we can cast a raw pointer to an oop so\n+  \/\/ joining the types only works if both are oops\n+  const Type* p1_type = p1->bottom_type();\n+  const Type* p2_type = p2->bottom_type();\n+  const Type* join = p1_type->join(p2_type);\n+  if (p1_type->isa_oopptr() && p2_type->isa_oopptr() && join->empty()) {\n+    return true;\n+  }\n+\n@@ -693,0 +702,19 @@\n+  const TypePtr* adr_type = this->adr_type();\n+  if (adr_type == nullptr) {\n+    \/\/ This means the access is dead\n+    return phase->C->top();\n+  } else if (adr_type->base() == TypePtr::AnyPtr) {\n+    \/\/ Compile::get_alias_index will complain with these accesses\n+    if (adr_type->ptr() == TypePtr::Null) {\n+      \/\/ Access to null cannot happen, this means the access must be in a dead path\n+      return phase->C->top();\n+    } else {\n+      \/\/ Give up on a very wide access\n+      return nullptr;\n+    }\n+  }\n+\n+  int alias_idx = phase->C->get_alias_index(adr_type);\n+  assert(alias_idx != Compile::AliasIdxTop, \"must not be a dead node\");\n+  assert(alias_idx != Compile::AliasIdxBot || !phase->C->do_aliasing(), \"must not be a very wide access\");\n+\n@@ -712,2 +740,4 @@\n-      if (st_base == nullptr)\n-        break;              \/\/ inscrutable pointer\n+      if (st_base == nullptr) {\n+        \/\/ inscrutable pointer\n+        break;\n+      }\n@@ -715,2 +745,12 @@\n-      \/\/ For raw accesses it's not enough to prove that constant offsets don't intersect.\n-      \/\/ We need the bases to be the equal in order for the offset check to make sense.\n+      \/\/ If the bases are the same and the offsets are the same, it seems that this is the exact\n+      \/\/ store we are looking for, the caller will check if the type of the store matches\n+      if (st_base == base && st_offset == offset) {\n+        return mem;\n+      }\n+\n+      \/\/ If it is provable that the memory accessed by mem does not overlap the memory accessed by\n+      \/\/ this, we may walk past mem.\n+      \/\/ For raw accesses, 2 accesses are independent if they have the same base and the offsets\n+      \/\/ say that they do not overlap.\n+      \/\/ For heap accesses, 2 accesses are independent if either the bases are provably different\n+      \/\/ at runtime or the offsets say that the accesses do not overlap.\n@@ -718,0 +758,1 @@\n+        \/\/ Raw accesses can only be provably independent if they have the same base\n@@ -721,0 +762,3 @@\n+      \/\/ If the offsets say that the accesses do not overlap, then it is provable that mem and this\n+      \/\/ do not overlap. For example, a LoadI from Object+8 is independent from a StoreL into\n+      \/\/ Object+12, no matter what the bases are.\n@@ -733,1 +777,1 @@\n-          continue;           \/\/ (a) advance through independent store memory\n+          continue;\n@@ -736,8 +780,4 @@\n-      if (st_base != base &&\n-          detect_ptr_independence(base, alloc,\n-                                  st_base,\n-                                  AllocateNode::Ideal_allocation(st_base),\n-                                  phase)) {\n-        \/\/ Success:  The bases are provably independent.\n-        mem = mem->in(MemNode::Memory);\n-        continue;           \/\/ (a) advance through independent store memory\n+\n+      \/\/ Same base and overlapping offsets, it seems provable that the accesses overlap, give up\n+      if (st_base == base) {\n+        break;\n@@ -746,4 +786,6 @@\n-      \/\/ (b) At this point, if the bases or offsets do not agree, we lose,\n-      \/\/ since we have not managed to prove 'this' and 'mem' independent.\n-      if (st_base == base && st_offset == offset) {\n-        return mem;         \/\/ let caller handle steps (c), (d)\n+      \/\/ Try to prove that 2 different base nodes at compile time are different values at runtime\n+      bool known_independent = false;\n+      if (detect_ptr_independence(base, alloc, st_base, AllocateNode::Ideal_allocation(st_base), phase)) {\n+        \/\/ detect_ptr_independence == true means that it can prove that base and st_base cannot\n+        \/\/ have the same runtime value\n+        known_independent = true;\n@@ -752,0 +794,4 @@\n+      if (known_independent) {\n+        mem = mem->in(MemNode::Memory);\n+        continue;\n+      }\n@@ -772,1 +818,0 @@\n-        int alias_idx = phase->C->get_alias_index(adr_type());\n@@ -795,0 +840,3 @@\n+    } else if (mem->is_MergeMem()) {\n+      mem = mem->as_MergeMem()->memory_at(alias_idx);\n+      continue;\n@@ -820,4 +868,0 @@\n-      } else if (mem->is_MergeMem()) {\n-        int alias_idx = phase->C->get_alias_index(adr_type());\n-        mem = mem->as_MergeMem()->memory_at(alias_idx);\n-        continue;           \/\/ (a) advance through independent MergeMem memory\n@@ -1854,1 +1898,0 @@\n-  bool progress = false;\n@@ -1867,1 +1910,1 @@\n-    progress = true;\n+    return this;\n@@ -1881,1 +1924,1 @@\n-      progress = true;\n+      return this;\n@@ -1954,0 +1997,4 @@\n+  if (prev_mem != nullptr && prev_mem->is_top()) {\n+    \/\/ find_previous_store returns top when the access is dead\n+    return prev_mem;\n+  }\n@@ -1972,1 +2019,5 @@\n-  return progress ? this : nullptr;\n+  if (!can_reshape) {\n+    phase->record_for_igvn(this);\n+  }\n+\n+  return nullptr;\n@@ -3555,0 +3606,1 @@\n+  }\n@@ -3556,11 +3608,11 @@\n-    if (result == this) {\n-      \/\/ the store may also apply to zero-bits in an earlier object\n-      Node* prev_mem = find_previous_store(phase);\n-      \/\/ Steps (a), (b):  Walk past independent stores to find an exact match.\n-      if (prev_mem != nullptr) {\n-        Node* prev_val = can_see_stored_value(prev_mem, phase);\n-        if (prev_val != nullptr && prev_val == val) {\n-          \/\/ prev_val and val might differ by a cast; it would be good\n-          \/\/ to keep the more informative of the two.\n-          result = mem;\n-        }\n+  \/\/ Store the same value that is in the memory, we can elide the store\n+  if (result == this && is_unordered()) {\n+    Node* prev_mem = find_previous_store(phase);\n+    if (prev_mem != nullptr) {\n+      if (prev_mem->is_top()) {\n+        \/\/ find_previous_store returns top when the access is dead\n+        return prev_mem;\n+      }\n+      Node* prev_val = can_see_stored_value(prev_mem, phase);\n+      if (prev_val == val) {\n+        result = mem;\n","filename":"src\/hotspot\/share\/opto\/memnode.cpp","additions":89,"deletions":37,"binary":false,"changes":126,"status":"modified"},{"patch":"@@ -0,0 +1,71 @@\n+\/*\n+ * Copyright (c) 2026, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package compiler.c2.gvn;\n+\n+import compiler.lib.ir_framework.*;\n+import jdk.test.lib.Asserts;\n+\n+\/*\n+ * @test\n+ * @bug 8360192\n+ * @summary Tests that count bits nodes are handled correctly.\n+ * @library \/test\/lib \/\n+ * @run driver ${test.main.class}\n+ *\/\n+public class TestFindStore {\n+    static class P {\n+        int v;\n+    }\n+\n+    static class C1 extends P {}\n+    static class C2 extends P {}\n+\n+    public static void main(String[] args) {\n+        TestFramework.run();\n+    }\n+\n+    @Run(test = {\"testLoad\", \"testStore\"})\n+    public void run() {\n+        C1 c1 = new C1();\n+        C2 c2 = new C2();\n+\n+        Asserts.assertEQ(1, testLoad(c1, c2, 1, 0));\n+        testStore(c1, c2, 1, 0);\n+    }\n+\n+    @Test\n+    @IR(failOn = IRNode.LOAD)\n+    static int testLoad(C1 c1, C2 c2, int v1, int v2) {\n+        c1.v = v1;\n+        c2.v = v2;\n+        return c1.v;\n+    }\n+\n+    @Test\n+    @IR(counts = {IRNode.STORE, \"2\"})\n+    static void testStore(C1 c1, C2 c2, int v1, int v2) {\n+        c1.v = v1;\n+        c2.v = v2;\n+        c1.v = v1;\n+    }\n+}\n","filename":"test\/hotspot\/jtreg\/compiler\/c2\/gvn\/TestFindStore.java","additions":71,"deletions":0,"binary":false,"changes":71,"status":"added"}]}