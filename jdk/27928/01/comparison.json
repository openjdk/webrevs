{"files":[{"patch":"@@ -29,1 +29,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingFunction.toFunction;\n@@ -34,1 +33,0 @@\n-import java.io.UncheckedIOException;\n@@ -85,4 +83,1 @@\n-        var curIconResource = createLauncherIconResource(pkg.app(), launcher,\n-                env::createResource);\n-\n-        if (curIconResource.isEmpty()) {\n+        if (!launcher.hasIcon()) {\n@@ -91,10 +86,3 @@\n-        } else {\n-            try {\n-                if (curIconResource.get().saveToFile((Path)null) != OverridableResource.Source.DefaultResource) {\n-                    \/\/ This launcher has custom icon configured.\n-                    withDesktopFile = true;\n-                }\n-            } catch (IOException ex) {\n-                \/\/ Should never happen as `saveToFile((Path)null)` should not perform any actual I\/O operations.\n-                throw new UncheckedIOException(ex);\n-            }\n+        } else if (launcher.hasCustomIcon()) {\n+            \/\/ This launcher has custom icon configured.\n+            withDesktopFile = true;\n@@ -122,5 +110,0 @@\n-\n-            if (curIconResource.isEmpty()) {\n-                \/\/ Create default icon.\n-                curIconResource = createLauncherIconResource(pkg.app(), pkg.app().mainLauncher().orElseThrow(), env::createResource);\n-            }\n@@ -132,1 +115,1 @@\n-        iconResource = curIconResource;\n+        iconResource = createLauncherIconResource(launcher, env::createResource);\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/DesktopIntegration.java","additions":5,"deletions":22,"binary":false,"changes":27,"status":"modified"},{"patch":"@@ -28,0 +28,2 @@\n+import java.util.Optional;\n+\n@@ -34,1 +36,1 @@\n-            LinuxPackagingPipeline.build()\n+            LinuxPackagingPipeline.build(Optional.empty())\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxAppBundler.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -54,0 +55,2 @@\n+        var pkg = LinuxFromParams.DEB_PACKAGE.fetchFrom(params);\n+\n@@ -55,1 +58,1 @@\n-                .pkg(LinuxFromParams.DEB_PACKAGE.fetchFrom(params))\n+                .pkg(pkg)\n@@ -57,1 +60,1 @@\n-                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n@@ -59,1 +62,1 @@\n-                }).execute(LinuxPackagingPipeline.build());\n+                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxDebBundler.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -46,0 +46,1 @@\n+import jdk.jpackage.internal.model.Launcher;\n@@ -58,1 +59,3 @@\n-        }), APPLICATION_LAYOUT).create();\n+        }), (LinuxLauncher linuxLauncher, Launcher launcher) -> {\n+            return LinuxLauncher.create(launcher, linuxLauncher);\n+        }, APPLICATION_LAYOUT).create();\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxFromParams.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -28,1 +28,0 @@\n-import jdk.jpackage.internal.PackagingPipeline.AppImageBuildEnv;\n@@ -34,0 +33,2 @@\n+import java.util.Optional;\n+import jdk.jpackage.internal.PackagingPipeline.AppImageBuildEnv;\n@@ -39,0 +40,2 @@\n+import jdk.jpackage.internal.model.Launcher;\n+import jdk.jpackage.internal.model.LinuxPackage;\n@@ -48,2 +51,2 @@\n-    static PackagingPipeline.Builder build() {\n-        return PackagingPipeline.buildStandard()\n+    static PackagingPipeline.Builder build(Optional<LinuxPackage> pkg) {\n+        var builder = PackagingPipeline.buildStandard()\n@@ -56,0 +59,6 @@\n+\n+        pkg.ifPresent(_ -> {\n+            builder.task(LinuxAppImageTaskID.LAUNCHER_ICONS).noaction().add();\n+        });\n+\n+        return builder;\n@@ -71,2 +80,2 @@\n-        for (var launcher : env.app().launchers()) {\n-            createLauncherIconResource(env.app(), launcher, env.env()::createResource).ifPresent(iconResource -> {\n+        env.app().launchers().stream().filter(Launcher::hasCustomIcon).forEach(launcher -> {\n+            createLauncherIconResource(launcher, env.env()::createResource).ifPresent(iconResource -> {\n@@ -81,1 +90,1 @@\n-        }\n+        });\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxPackagingPipeline.java","additions":15,"deletions":6,"binary":false,"changes":21,"status":"modified"},{"patch":"@@ -30,0 +30,1 @@\n+import java.util.Optional;\n@@ -55,0 +56,2 @@\n+        var pkg = LinuxFromParams.RPM_PACKAGE.fetchFrom(params);\n+\n@@ -56,1 +59,1 @@\n-                .pkg(LinuxFromParams.RPM_PACKAGE.fetchFrom(params))\n+                .pkg(pkg)\n@@ -58,1 +61,1 @@\n-                .pipelineBuilderMutatorFactory((env, pkg, outputDir) -> {\n+                .pipelineBuilderMutatorFactory((env, _, outputDir) -> {\n@@ -60,1 +63,1 @@\n-                }).execute(LinuxPackagingPipeline.build());\n+                }).execute(LinuxPackagingPipeline.build(Optional.of(pkg)));\n","filename":"src\/jdk.jpackage\/linux\/classes\/jdk\/jpackage\/internal\/LinuxRpmBundler.java","additions":6,"deletions":3,"binary":false,"changes":9,"status":"modified"},{"patch":"@@ -95,1 +95,3 @@\n-        }), APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout.map(RuntimeLayout::unresolve));\n+        }), (MacLauncher _, Launcher launcher) -> {\n+            return MacLauncher.create(launcher);\n+        }, APPLICATION_LAYOUT, RUNTIME_BUNDLE_LAYOUT, predefinedRuntimeLayout.map(RuntimeLayout::unresolve));\n","filename":"src\/jdk.jpackage\/macosx\/classes\/jdk\/jpackage\/internal\/MacFromParams.java","additions":3,"deletions":1,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.BiFunction;\n@@ -36,0 +37,1 @@\n+import java.util.function.Predicate;\n@@ -43,0 +45,1 @@\n+import jdk.jpackage.internal.model.LauncherIcon;\n@@ -44,0 +47,1 @@\n+import jdk.jpackage.internal.model.ResourceDirLauncherIcon;\n@@ -171,0 +175,91 @@\n+    static <T extends Launcher> ApplicationLaunchers normalizeIcons(\n+            ApplicationLaunchers appLaunchers, Optional<Path> resourceDir, BiFunction<T, Launcher, T> launcherOverrideCtor) {\n+\n+        Objects.requireNonNull(resourceDir);\n+\n+        return normalizeLauncherProperty(appLaunchers, Launcher::hasDefaultIcon, (T launcher) -> {\n+            return resourceDir.<LauncherIcon>flatMap(dir -> {\n+                var resource = LauncherBuilder.createLauncherIconResource(launcher, _ -> {\n+                    return new OverridableResource()\n+                            .setResourceDir(dir)\n+                            .setSourceOrder(OverridableResource.Source.ResourceDir);\n+                });\n+                if (resource.probe() == OverridableResource.Source.ResourceDir) {\n+                    return Optional.of(ResourceDirLauncherIcon.create(resource.getPublicName().toString()));\n+                } else {\n+                    return Optional.empty();\n+                }\n+            });\n+        }, launcher -> {\n+            return launcher.icon().orElseThrow();\n+        }, (launcher, icon) -> {\n+            return launcherOverrideCtor.apply(launcher, overrideIcon(launcher, icon));\n+        });\n+    }\n+\n+    static <T, U extends Launcher> ApplicationLaunchers normalizeLauncherProperty(\n+            ApplicationLaunchers appLaunchers,\n+            Predicate<U> needsNormalization,\n+            Function<U, Optional<T>> normalizedPropertyValueFinder,\n+            BiFunction<U, T, U> propertyOverrider) {\n+\n+        return normalizeLauncherProperty(\n+                appLaunchers,\n+                needsNormalization,\n+                normalizedPropertyValueFinder,\n+                launcher -> {\n+                    return normalizedPropertyValueFinder.apply(launcher).orElseThrow();\n+                },\n+                propertyOverrider);\n+    }\n+\n+    static <T, U extends Launcher> ApplicationLaunchers normalizeLauncherProperty(\n+            ApplicationLaunchers appLaunchers,\n+            Predicate<U> needsNormalization,\n+            Function<U, Optional<T>> normalizedPropertyValueFinder,\n+            Function<U, T> normalizedPropertyValueGetter,\n+            BiFunction<U, T, U> propertyOverrider) {\n+\n+        Objects.requireNonNull(appLaunchers);\n+        Objects.requireNonNull(needsNormalization);\n+        Objects.requireNonNull(normalizedPropertyValueFinder);\n+        Objects.requireNonNull(normalizedPropertyValueGetter);\n+        Objects.requireNonNull(propertyOverrider);\n+\n+        boolean[] modified = new boolean[1];\n+\n+        @SuppressWarnings(\"unchecked\")\n+        var newLaunchers = appLaunchers.asList().stream().map(launcher -> {\n+            return (U)launcher;\n+        }).map(launcher -> {\n+            if (needsNormalization.test(launcher)) {\n+                return normalizedPropertyValueFinder.apply(launcher).map(normalizedPropertyValue -> {\n+                    modified[0] = true;\n+                    return propertyOverrider.apply(launcher, normalizedPropertyValue);\n+                }).orElse(launcher);\n+            } else {\n+                return launcher;\n+            }\n+        }).toList();\n+\n+        var newMainLauncher = newLaunchers.getFirst();\n+        if (!needsNormalization.test(newMainLauncher)) {\n+            \/\/ The main launcher doesn't require normalization.\n+            newLaunchers = newLaunchers.stream().map(launcher -> {\n+                if (needsNormalization.test(launcher)) {\n+                    var normalizedPropertyValue = normalizedPropertyValueGetter.apply(newMainLauncher);\n+                    modified[0] = true;\n+                    return propertyOverrider.apply(launcher, normalizedPropertyValue);\n+                } else {\n+                    return launcher;\n+                }\n+            }).toList();\n+        }\n+\n+        if (modified[0]) {\n+            return ApplicationLaunchers.fromList(newLaunchers).orElseThrow();\n+        } else {\n+            return appLaunchers;\n+        }\n+    }\n+\n@@ -198,0 +293,12 @@\n+    private static Launcher overrideIcon(Launcher launcher, LauncherIcon icon) {\n+        return new Launcher.Stub(\n+                launcher.name(),\n+                launcher.startupInfo(),\n+                launcher.fileAssociations(),\n+                launcher.isService(),\n+                launcher.description(),\n+                Optional.of(icon),\n+                launcher.defaultIconResourceName(),\n+                launcher.extraAppImageFileData());\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationBuilder.java","additions":107,"deletions":0,"binary":false,"changes":107,"status":"modified"},{"patch":"@@ -29,1 +29,0 @@\n-import static jdk.jpackage.internal.util.function.ThrowingSupplier.toSupplier;\n@@ -46,0 +45,1 @@\n+import jdk.jpackage.internal.model.DefaultLauncherIcon;\n@@ -47,0 +47,1 @@\n+import jdk.jpackage.internal.model.ResourceDirLauncherIcon;\n@@ -48,1 +49,0 @@\n-import jdk.jpackage.internal.util.PathUtils;\n@@ -53,2 +53,1 @@\n-    static Optional<OverridableResource> createLauncherIconResource(Application app,\n-            Launcher launcher,\n+    static Optional<OverridableResource> createLauncherIconResource(Launcher launcher,\n@@ -56,2 +55,0 @@\n-        final String defaultIconName = launcher.defaultIconResourceName();\n-        final String resourcePublicName = launcher.executableName() + PathUtils.getSuffix(Path.of(defaultIconName));\n@@ -59,3 +56,2 @@\n-        if (!launcher.hasIcon()) {\n-            return Optional.empty();\n-        }\n+        return launcher.icon().map(icon -> {\n+            var resource = LauncherBuilder.createLauncherIconResource(launcher, resourceSupplier);\n@@ -63,17 +59,12 @@\n-        OverridableResource resource = resourceSupplier.apply(defaultIconName)\n-                .setCategory(\"icon\")\n-                .setPublicName(resourcePublicName);\n-\n-        launcher.icon().flatMap(CustomLauncherIcon::fromLauncherIcon).map(CustomLauncherIcon::path).ifPresent(resource::setExternal);\n-\n-        if (launcher.hasDefaultIcon() && app.mainLauncher().orElseThrow() != launcher) {\n-            \/\/ No icon explicitly configured for this launcher.\n-            \/\/ Dry-run resource creation to figure out its source.\n-            final Path nullPath = null;\n-            if (toSupplier(() -> resource.saveToFile(nullPath)).get() != OverridableResource.Source.ResourceDir) {\n-                \/\/ No icon in resource dir for this launcher, inherit icon\n-                \/\/ configured for the main launcher.\n-                return createLauncherIconResource(\n-                        app, app.mainLauncher().orElseThrow(),\n-                        resourceSupplier\n-                ).map(r -> r.setLogPublicName(resourcePublicName));\n+            switch (icon) {\n+                case DefaultLauncherIcon _ -> {\n+                    resource.setSourceOrder(OverridableResource.Source.DefaultResource);\n+                }\n+                case ResourceDirLauncherIcon v -> {\n+                    resource.setSourceOrder(OverridableResource.Source.ResourceDir);\n+                    resource.setPublicName(v.name());\n+                }\n+                case CustomLauncherIcon v -> {\n+                    resource.setSourceOrder(OverridableResource.Source.External);\n+                    resource.setExternal(v.path());\n+                }\n@@ -81,1 +72,0 @@\n-        }\n@@ -83,1 +73,2 @@\n-        return Optional.of(resource);\n+            return resource;\n+        });\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/ApplicationImageUtils.java","additions":19,"deletions":28,"binary":false,"changes":47,"status":"modified"},{"patch":"@@ -50,0 +50,1 @@\n+import static jdk.jpackage.internal.StandardBundlerParam.RESOURCE_DIR;\n@@ -63,0 +64,1 @@\n+import java.util.function.BiFunction;\n@@ -79,1 +81,1 @@\n-    static ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n+    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n@@ -81,0 +83,1 @@\n+            BiFunction<T, Launcher, T> launcherOverrideCtor,\n@@ -82,1 +85,1 @@\n-        return createApplicationBuilder(params, launcherMapper, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n+        return createApplicationBuilder(params, launcherMapper, launcherOverrideCtor, appLayout, RuntimeLayout.DEFAULT, Optional.of(RuntimeLayout.DEFAULT));\n@@ -85,1 +88,1 @@\n-    static ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n+    static <T extends Launcher> ApplicationBuilder createApplicationBuilder(Map<String, ? super Object> params,\n@@ -87,0 +90,1 @@\n+            BiFunction<T, Launcher, T> launcherOverrideCtor,\n@@ -136,1 +140,3 @@\n-                appBuilder.launchers(launchers).runtimeBuilder(runtimeBuilderBuilder.create());\n+                final var normalizedLaunchers = ApplicationBuilder.normalizeIcons(launchers, RESOURCE_DIR.findIn(params), launcherOverrideCtor);\n+\n+                appBuilder.launchers(normalizedLaunchers).runtimeBuilder(runtimeBuilderBuilder.create());\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/FromParams.java","additions":10,"deletions":4,"binary":false,"changes":14,"status":"modified"},{"patch":"@@ -35,0 +35,1 @@\n+import java.util.function.Function;\n@@ -38,0 +39,1 @@\n+import jdk.jpackage.internal.model.DefaultLauncherIcon;\n@@ -41,0 +43,1 @@\n+import jdk.jpackage.internal.util.PathUtils;\n@@ -43,0 +46,1 @@\n+import jdk.jpackage.internal.model.ResourceDirLauncherIcon;\n@@ -113,0 +117,9 @@\n+    static OverridableResource createLauncherIconResource(Launcher launcher,\n+            Function<String, OverridableResource> resourceSupplier) {\n+\n+        var defaultIconResourceName = launcher.defaultIconResourceName();\n+        return resourceSupplier.apply(defaultIconResourceName)\n+                    .setPublicName(launcher.executableName() + PathUtils.getSuffix(Path.of(defaultIconResourceName)))\n+                    .setCategory(\"icon\");\n+    }\n+\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/LauncherBuilder.java","additions":13,"deletions":0,"binary":false,"changes":13,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Custom application launcher icon.\n+ * Custom application launcher icon sourced from an external file.\n@@ -36,1 +36,1 @@\n-public interface CustomLauncherIcon extends LauncherIcon {\n+public sealed interface CustomLauncherIcon extends LauncherIcon {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/CustomLauncherIcon.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -32,1 +32,1 @@\n- * Default icon is either loaded from the resources of {@link jdk.jpackage} module or picked from the resource directory.\n+ * Default icon is loaded from the resources of {@link jdk.jpackage} module.\n@@ -36,1 +36,1 @@\n-public interface DefaultLauncherIcon extends LauncherIcon {\n+public sealed interface DefaultLauncherIcon extends LauncherIcon {\n@@ -56,1 +56,5 @@\n-    public static DefaultLauncherIcon INSTANCE = new DefaultLauncherIcon() {};\n+    public static DefaultLauncherIcon INSTANCE = new Details.Impl();\n+\n+    static final class Details {\n+        private static final class Impl implements DefaultLauncherIcon {}\n+    }\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/DefaultLauncherIcon.java","additions":7,"deletions":3,"binary":false,"changes":10,"status":"modified"},{"patch":"@@ -154,1 +154,3 @@\n-     * Returns <code>true<\/code> if this launcher has a custom icon.\n+     * Returns <code>true<\/code> if this launcher has non-default icon.\n+     * <p>\n+     * A custom icon can be sourced from an external file or from the resource directory.\n@@ -156,1 +158,1 @@\n-     * @return <code>true<\/code> if this launcher has a custom icon\n+     * @return <code>true<\/code> if this launcher has non-default icon\n@@ -163,1 +165,1 @@\n-        return icon().flatMap(CustomLauncherIcon::fromLauncherIcon).isPresent();\n+        return !hasDefaultIcon() && icon().isPresent();\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/Launcher.java","additions":5,"deletions":3,"binary":false,"changes":8,"status":"modified"},{"patch":"@@ -30,1 +30,1 @@\n-public interface LauncherIcon {\n+public sealed interface LauncherIcon permits DefaultLauncherIcon, ResourceDirLauncherIcon, CustomLauncherIcon {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/LauncherIcon.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -0,0 +1,73 @@\n+\/*\n+ * Copyright (c) 2025, Oracle and\/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and\/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ *\/\n+package jdk.jpackage.internal.model;\n+\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+\/**\n+ * Custom application launcher icon sourced from the resource directory.\n+ * <p>\n+ * Use {@link #create(String)} method to create an instance of this type.\n+ *\/\n+public sealed interface ResourceDirLauncherIcon extends LauncherIcon {\n+\n+    \/**\n+     * Returns name of the resource referencing an icon file in the resource directory.\n+     * @return name of the resource referencing an icon file in the resource directory\n+     *\/\n+    String name();\n+\n+    \/**\n+     * Returns the given icon as {@link ResourceDirLauncherIcon} type or an empty {@link Optional} instance\n+     * if the given icon object is not an instance of {@link ResourceDirLauncherIcon} type.\n+     *\n+     * @param icon application launcher icon object or <code>null<\/null>\n+     * @return the given icon as {@link ResourceDirLauncherIcon} type or an empty {@link Optional} instance\n+     *\/\n+    public static Optional<ResourceDirLauncherIcon> fromLauncherIcon(LauncherIcon icon) {\n+        if (icon instanceof ResourceDirLauncherIcon customIcon) {\n+            return Optional.of(customIcon);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    \/**\n+     * Creates object of type {@link ResourceDirLauncherIcon} from the name of the resource referencing an icon file in the resource directory.\n+     * @param name name of the resource referencing an icon file in the resource directory\n+     * @return {@link ResourceDirLauncherIcon} instance\n+     *\/\n+    public static ResourceDirLauncherIcon create(String name) {\n+        Objects.requireNonNull(name);\n+        return new Stub(name);\n+    }\n+\n+    \/**\n+     * Default implementation of {@link ResourceDirLauncherIcon} type.\n+     *\/\n+    record Stub(String name) implements ResourceDirLauncherIcon {\n+    }\n+}\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/model\/ResourceDirLauncherIcon.java","additions":73,"deletions":0,"binary":false,"changes":73,"status":"added"},{"patch":"@@ -28,0 +28,1 @@\n+import static java.util.stream.Collectors.toSet;\n@@ -33,1 +34,0 @@\n-import java.util.ArrayList;\n@@ -36,0 +36,3 @@\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n@@ -294,0 +297,74 @@\n+    private record InterfaceDispatchBuilder(Set<? extends Class<?>> interfaces, Collection<Object> slices) {\n+\n+        InterfaceDispatchBuilder {\n+            Objects.requireNonNull(interfaces);\n+            Objects.requireNonNull(slices);\n+\n+            if (interfaces.isEmpty()) {\n+                throw new IllegalArgumentException(\"No interfaces to dispatch\");\n+            }\n+\n+            if (slices.isEmpty()) {\n+                throw createInterfaceNotImplementedException(interfaces);\n+            }\n+        }\n+\n+        InterfaceDispatchBuilder(Result result) {\n+            this(result.unservedInterfaces(), result.unusedSlices());\n+        }\n+\n+        Map<? extends Class<?>, List<Object>> createDispatchGroups() {\n+            return interfaces.stream().collect(toMap(x -> x, iface -> {\n+                return slices.stream().filter(obj -> {\n+                    return Stream.of(obj.getClass().getInterfaces()).flatMap(sliceIface -> {\n+                        return unfoldInterface(sliceIface);\n+                    }).anyMatch(Predicate.isEqual(iface));\n+                }).toList();\n+            }));\n+        }\n+\n+        Result createDispatch() {\n+            var groups = createDispatchGroups();\n+\n+            var dispatch = groups.entrySet().stream().filter(e -> {\n+                return e.getValue().size() == 1;\n+            }).collect(toMap(Map.Entry::getKey, e -> {\n+                return e.getValue().getFirst();\n+            }));\n+\n+            var unservedInterfaces = groups.entrySet().stream().filter(e -> {\n+                return e.getValue().size() != 1;\n+            }).map(Map.Entry::getKey).collect(toSet());\n+\n+            var usedSliceIdentities = dispatch.values().stream()\n+                    .map(IdentityWrapper::new)\n+                    .collect(toSet());\n+\n+            var unusedSliceIdentities = new HashSet<>(toIdentitySet(slices));\n+            unusedSliceIdentities.removeAll(usedSliceIdentities);\n+\n+            return new Result(dispatch, unservedInterfaces, unusedSliceIdentities.stream().map(IdentityWrapper::value).toList());\n+        }\n+\n+        private record Result(Map<? extends Class<?>, Object> dispatch, Set<? extends Class<?>> unservedInterfaces, Collection<Object> unusedSlices) {\n+\n+            Result {\n+                Objects.requireNonNull(dispatch);\n+                Objects.requireNonNull(unservedInterfaces);\n+                Objects.requireNonNull(unusedSlices);\n+\n+                if (!Collections.disjoint(dispatch.keySet(), unservedInterfaces)) {\n+                    throw new IllegalArgumentException();\n+                }\n+\n+                if (!Collections.disjoint(toIdentitySet(dispatch.values()), toIdentitySet(unusedSlices))) {\n+                    throw new IllegalArgumentException();\n+                }\n+            }\n+        }\n+\n+        private static Collection<IdentityWrapper<Object>> toIdentitySet(Collection<Object> v) {\n+            return v.stream().map(IdentityWrapper::new).collect(toSet());\n+        }\n+    }\n+\n@@ -296,13 +373,32 @@\n-        final Map<Class<?>, Object> interfaceDispatch = Stream.of(interfaces).collect(toMap(x -> x, iface -> {\n-            return Stream.of(slices).filter(obj -> {\n-                return Set.of(obj.getClass().getInterfaces()).contains(iface);\n-            }).reduce((a, b) -> {\n-                throw new IllegalArgumentException(\n-                        String.format(\"both [%s] and [%s] slices implement %s\", a, b, iface));\n-            }).orElseThrow(() -> createInterfaceNotImplementedException(List.of(iface)));\n-        }));\n-\n-        if (interfaceDispatch.size() != interfaces.length) {\n-            final List<Class<?>> missingInterfaces = new ArrayList<>(Set.of(interfaces));\n-            missingInterfaces.removeAll(interfaceDispatch.keySet());\n-            throw createInterfaceNotImplementedException(missingInterfaces);\n+        if (interfaces.length == 0) {\n+            return Collections.emptyMap();\n+        }\n+\n+        Map<Class<?>, Object> dispatch = new HashMap<>();\n+\n+        var builder = new InterfaceDispatchBuilder(Set.of(interfaces), List.of(slices));\n+        for (;;) {\n+            var result = builder.createDispatch();\n+            if (result.dispatch().isEmpty()) {\n+                var unserved = builder.createDispatchGroups();\n+                for (var e : unserved.entrySet()) {\n+                    var iface = e.getKey();\n+                    var ifaceSlices = e.getValue();\n+                    if (ifaceSlices.size() > 1) {\n+                        throw new IllegalArgumentException(\n+                                String.format(\"multiple slices %s implement %s\", ifaceSlices, iface));\n+                    }\n+                }\n+\n+                var unservedInterfaces = unserved.entrySet().stream().filter(e -> {\n+                    return e.getValue().isEmpty();\n+                }).map(Map.Entry::getKey).toList();\n+                throw createInterfaceNotImplementedException(unservedInterfaces);\n+            } else {\n+                dispatch.putAll(result.dispatch());\n+                if (result.unservedInterfaces().isEmpty()) {\n+                    break;\n+                }\n+            }\n+\n+            builder = new InterfaceDispatchBuilder(result);\n@@ -311,1 +407,1 @@\n-        return Stream.of(interfaces).flatMap(iface -> {\n+        return dispatch.keySet().stream().flatMap(iface -> {\n@@ -313,1 +409,1 @@\n-                return Map.entry(unfoldedIface, interfaceDispatch.get(iface));\n+                return Map.entry(unfoldedIface, dispatch.get(iface));\n@@ -324,1 +420,1 @@\n-            Collection<Class<?>> missingInterfaces) {\n+            Collection<? extends Class<?>> missingInterfaces) {\n","filename":"src\/jdk.jpackage\/share\/classes\/jdk\/jpackage\/internal\/util\/CompositeProxy.java","additions":113,"deletions":17,"binary":false,"changes":130,"status":"modified"},{"patch":"@@ -44,0 +44,1 @@\n+import jdk.jpackage.internal.model.Launcher;\n@@ -69,1 +70,3 @@\n-        }), APPLICATION_LAYOUT).create();\n+        }), (WinLauncher winLauncher, Launcher launcher) -> {\n+            return WinLauncher.create(launcher, winLauncher);\n+        }, APPLICATION_LAYOUT).create();\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinFromParams.java","additions":4,"deletions":1,"binary":false,"changes":5,"status":"modified"},{"patch":"@@ -59,1 +59,1 @@\n-            final var iconTarget = createLauncherIconResource(env.app(), launcher, env.env()::createResource).map(iconResource -> {\n+            final var iconTarget = createLauncherIconResource(launcher, env.env()::createResource).map(iconResource -> {\n","filename":"src\/jdk.jpackage\/windows\/classes\/jdk\/jpackage\/internal\/WinPackagingPipeline.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"},{"patch":"@@ -35,1 +35,0 @@\n-import jdk.jpackage.internal.util.PathUtils;\n@@ -78,7 +77,0 @@\n-    Path getLinuxIconFileName() {\n-        if (icon == null) {\n-            return null;\n-        }\n-        return Path.of(getMime().replace('\/', '-') + PathUtils.getSuffix(icon));\n-    }\n-\n@@ -97,0 +89,4 @@\n+    boolean hasIcon() {\n+        return icon != null;\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/FileAssociations.java","additions":4,"deletions":8,"binary":false,"changes":12,"status":"modified"},{"patch":"@@ -69,9 +69,3 @@\n-        final String curLauncherName;\n-        final String label;\n-        if (launcherName == null) {\n-            curLauncherName = cmd.name();\n-            label = \"main\";\n-        } else {\n-            curLauncherName = launcherName;\n-            label = String.format(\"[%s]\", launcherName);\n-        }\n+        final String label = Optional.ofNullable(launcherName).map(v -> {\n+            return String.format(\"[%s]\", v);\n+        }).orElse(\"main\");\n@@ -79,2 +73,1 @@\n-        Path iconPath = cmd.appLayout().desktopIntegrationDirectory().resolve(\n-                curLauncherName + TKit.ICON_SUFFIX);\n+        Path iconPath = cmd.appLayout().desktopIntegrationDirectory().resolve(iconFileName(cmd));\n@@ -102,0 +95,8 @@\n+    private Path iconFileName(JPackageCommand cmd) {\n+        if (TKit.isLinux()) {\n+            return LinuxHelper.getLauncherIconFileName(cmd, launcherName);\n+        } else {\n+            return Path.of(Optional.ofNullable(launcherName).orElseGet(cmd::name) + TKit.ICON_SUFFIX);\n+        }\n+    }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherIconVerifier.java","additions":12,"deletions":11,"binary":false,"changes":23,"status":"modified"},{"patch":"@@ -207,1 +207,1 @@\n-                \/\/ No \"icon\" property in the property file\n+                \/\/ No \"icon\" property in the property file.\n@@ -215,0 +215,23 @@\n+        if (TKit.isLinux()) {\n+            \/\/ On Linux, a launcher may have an icon only if it has a corresponding .desktop file.\n+            \/\/ In case of \"app-image\" packaging there are no .desktop files, but jpackage will add icon files\n+            \/\/ in the app image anyways so that in two-step packaging jpackage can pick the icons for .desktop files.\n+            \/\/ jpackage should not add the default icon to the app image in case of \"app-image\" packaging.\n+            if (cmd.isImagePackageType()) {\n+                \/\/ This is \"app-image\" packaging. Let's see if, in two-step packaging,\n+                \/\/ jpackage creates a .desktop file for this launcher.\n+                if (!withLinuxDesktopFile(cmd.createMutableCopy().setPackageType(PackageType.LINUX_RPM))) {\n+                    \/\/ No .desktop file in the \"future\" package for this launcher,\n+                    \/\/ then don't expect an icon in the app image produced by the `cmd`.\n+                    verifier.setExpectedNoIcon();\n+                } else if (verifier.expectDefaultIcon()) {\n+                    \/\/ A .desktop file in the \"future\" package for this launcher,\n+                    \/\/ but it will use the default icon.\n+                    \/\/ Don't expect an icon in the app image produced by the `cmd`.\n+                    verifier.setExpectedNoIcon();\n+                }\n+            } else if (!withLinuxDesktopFile(cmd)) {\n+                verifier.setExpectedNoIcon();\n+            }\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LauncherVerifier.java","additions":24,"deletions":1,"binary":false,"changes":25,"status":"modified"},{"patch":"@@ -25,1 +25,0 @@\n-import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n@@ -30,0 +29,1 @@\n+import static jdk.jpackage.test.AdditionalLauncher.getAdditionalLauncherProperties;\n@@ -48,0 +48,1 @@\n+import java.util.function.Consumer;\n@@ -93,3 +94,1 @@\n-        String desktopFileName = String.format(\"%s-%s.desktop\", getPackageName(\n-                cmd), Optional.ofNullable(launcherName).orElseGet(\n-                        () -> cmd.name()).replaceAll(\"\\\\s+\", \"_\"));\n+        var desktopFileName = getLauncherDesktopFileName(cmd, launcherName);\n@@ -207,0 +206,14 @@\n+    private static Path getFaIconFileName(JPackageCommand cmd, String mimeType) {\n+        return Path.of(mimeType.replace('\/', '-') + \".png\");\n+    }\n+\n+    static Path getLauncherDesktopFileName(JPackageCommand cmd, String launcherName) {\n+        return Path.of(String.format(\"%s-%s.desktop\", getPackageName(cmd),\n+                Optional.ofNullable(launcherName).orElseGet(cmd::name).replaceAll(\"\\\\s+\", \"_\")));\n+    }\n+\n+    static Path getLauncherIconFileName(JPackageCommand cmd, String launcherName) {\n+        return Path.of(String.format(\"%s.png\",\n+                Optional.ofNullable(launcherName).orElseGet(cmd::name).replaceAll(\"\\\\s+\", \"_\")));\n+    }\n+\n@@ -426,1 +439,6 @@\n-    static void verifyDesktopFiles(JPackageCommand cmd, boolean installed) {\n+    static void verifyDesktopIntegrationFiles(JPackageCommand cmd, boolean installed) {\n+        verifyDesktopFiles(cmd, installed);\n+        verifyAllIconsReferenced(cmd);\n+    }\n+\n+    private static void verifyDesktopFiles(JPackageCommand cmd, boolean installed) {\n@@ -482,0 +500,33 @@\n+    private static void verifyAllIconsReferenced(JPackageCommand cmd) {\n+\n+        var installCmd = Optional.ofNullable(cmd.unpackedPackageDirectory()).map(_ -> {\n+            return cmd.createMutableCopy().setUnpackedPackageLocation(null);\n+        }).orElse(cmd);\n+\n+        var installedIconFiles = relativePackageFilesInSubdirectory(\n+                installCmd,\n+                ApplicationLayout::desktopIntegrationDirectory\n+        ).filter(path -> {\n+            return \".png\".equals(PathUtils.getSuffix(path));\n+        }).map(installCmd.appLayout().desktopIntegrationDirectory()::resolve).collect(toSet());\n+\n+        var referencedIcons = getDesktopFiles(cmd).stream().map(path -> {\n+            return new DesktopFile(path, false);\n+        }).<Path>mapMulti((desktopFile, sink) -> {\n+            desktopFile.findQuotedValue(\"Icon\").map(Path::of).ifPresent(sink);\n+            desktopFile.find(\"MimeType\").ifPresent(str -> {\n+                Stream.of(str.split(\";\"))\n+                        .map(mimeType -> {\n+                            return getFaIconFileName(cmd, mimeType);\n+                        })\n+                        .map(installCmd.appLayout().desktopIntegrationDirectory()::resolve)\n+                        .forEach(sink);\n+            });\n+        }).collect(toSet());\n+\n+        var unreferencedIconFiles = Comm.compare(installedIconFiles, referencedIcons).unique1().stream().sorted().toList();\n+\n+        \/\/ Verify that all package icon (.png) files are referenced from package .desktop files.\n+        TKit.assertEquals(List.of(), unreferencedIconFiles, \"Check there are no unreferenced icon files in the package\");\n+    }\n+\n@@ -664,10 +715,13 @@\n-            final Path mimeTypeIconFileName = fa.getLinuxIconFileName();\n-            if (mimeTypeIconFileName != null) {\n-                \/\/ Verify there are xdg registration commands for mime icon file.\n-                Path mimeTypeIcon = cmd.appLayout().desktopIntegrationDirectory().resolve(\n-                        mimeTypeIconFileName);\n-\n-                Map<Scriptlet, List<String>> scriptlets = getScriptlets(cmd);\n-                scriptlets.entrySet().stream().forEach(e -> verifyIconInScriptlet(\n-                        e.getKey(), e.getValue(), mimeTypeIcon));\n-            }\n+            Optional.of(fa).filter(FileAssociations::hasIcon)\n+                    .map(FileAssociations::getMime)\n+                    .map(mimeType -> {\n+                        return getFaIconFileName(cmd, mimeType);\n+                    }).ifPresent(mimeTypeIconFileName -> {\n+                        \/\/ Verify there are xdg registration commands for mime icon file.\n+                        Path mimeTypeIcon = cmd.appLayout().desktopIntegrationDirectory().resolve(\n+                                mimeTypeIconFileName);\n+\n+                        Map<Scriptlet, List<String>> scriptlets = getScriptlets(cmd);\n+                        scriptlets.entrySet().stream().forEach(e -> verifyIconInScriptlet(\n+                                e.getKey(), e.getValue(), mimeTypeIcon));\n+                    });\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/LinuxHelper.java","additions":69,"deletions":15,"binary":false,"changes":84,"status":"modified"},{"patch":"@@ -787,1 +787,1 @@\n-                    LinuxHelper.verifyDesktopFiles(cmd, true);\n+                    LinuxHelper.verifyDesktopIntegrationFiles(cmd, true);\n@@ -868,1 +868,1 @@\n-                    LinuxHelper.verifyDesktopFiles(cmd, false);\n+                    LinuxHelper.verifyDesktopIntegrationFiles(cmd, false);\n","filename":"test\/jdk\/tools\/jpackage\/helpers\/jdk\/jpackage\/test\/PackageTest.java","additions":2,"deletions":2,"binary":false,"changes":4,"status":"modified"},{"patch":"@@ -412,0 +412,8 @@\n+        if (TKit.isLinux()) {\n+            var noDefaultIcon = cmd.isImagePackageType() || !cmd.hasArgument(\"--linux-shortcut\");\n+\n+            if (noDefaultIcon && iconType == IconType.DefaultIcon) {\n+                iconType = IconType.NoIcon;\n+            }\n+        }\n+\n","filename":"test\/jdk\/tools\/jpackage\/share\/IconTest.java","additions":8,"deletions":0,"binary":false,"changes":8,"status":"modified"}]}