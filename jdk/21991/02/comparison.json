{"files":[{"patch":"@@ -163,0 +163,4 @@\n+    \/\/ inputQ lock: methods that take from the inputQ\n+    \/\/      must not run concurrently.\n+    private final Lock inputQLock = new ReentrantLock();\n+\n@@ -186,0 +190,2 @@\n+        \/\/ prevents drainInputQueue() from running concurrently\n+        inputQLock.lock();\n@@ -202,1 +208,1 @@\n-                    if (endStreamReceived() && rf.getErrorCode() ==  ResetFrame.NO_ERROR) {\n+                    if (endStreamReceived() && rf.getErrorCode() == ResetFrame.NO_ERROR) {\n@@ -211,1 +217,1 @@\n-                DataFrame df = (DataFrame)frame;\n+                DataFrame df = (DataFrame) frame;\n@@ -259,0 +265,1 @@\n+            inputQLock.unlock();\n@@ -283,2 +290,3 @@\n-    \/\/ must only be called from the scheduler schedule() loop.\n-    \/\/ ensure that all received data frames are accounted for\n+    \/\/ Called from the scheduler schedule() loop,\n+    \/\/ or after resetting the stream.\n+    \/\/ Ensures that all received data frames are accounted for\n@@ -287,0 +295,2 @@\n+    \/\/ The inputQLock is used to prevent concurrently taking\n+    \/\/ from the queue.\n@@ -289,7 +299,12 @@\n-        while ((frame = inputQ.poll()) != null) {\n-            if (frame instanceof DataFrame df) {\n-                \/\/ Data frames that have been added to the inputQ\n-                \/\/ must be released using releaseUnconsumed() to\n-                \/\/ account for the amount of unprocessed bytes\n-                \/\/ tracked by the connection.windowUpdater.\n-                connection.releaseUnconsumed(df);\n+        \/\/ will wait until schedule() has finished taking\n+        \/\/ from the queue, if needed.\n+        inputQLock.lock();\n+        try {\n+            while ((frame = inputQ.poll()) != null) {\n+                if (frame instanceof DataFrame df) {\n+                    \/\/ Data frames that have been added to the inputQ\n+                    \/\/ must be released using releaseUnconsumed() to\n+                    \/\/ account for the amount of unprocessed bytes\n+                    \/\/ tracked by the connection.windowUpdater.\n+                    connection.releaseUnconsumed(df);\n+                }\n@@ -297,0 +312,2 @@\n+        } finally {\n+            inputQLock.unlock();\n@@ -408,1 +425,1 @@\n-            inputQ.add(df);\n+           pushDataFrame(len, df);\n@@ -414,0 +431,26 @@\n+    \/\/ Ensures that no data frame is pushed on the inputQ\n+    \/\/ after the stream is closed.\n+    \/\/ Changes to the `closed` boolean are guarded by the\n+    \/\/ stateLock. Contention should be low as only one\n+    \/\/ thread at a time adds to the inputQ, and\n+    \/\/ we can only contend when closing the stream.\n+    \/\/ Note that this method can run concurrently with\n+    \/\/ methods holding the inputQLock: that is OK.\n+    \/\/ The inputQLock is there to ensure that methods\n+    \/\/ taking from the queue are not running concurrently\n+    \/\/ with each others, but concurrently adding at the\n+    \/\/ end of the queue while peeking\/polling at the head\n+    \/\/ is OK.\n+    private void pushDataFrame(int len, DataFrame df) {\n+        boolean closed = false;\n+        stateLock.lock();\n+        try {\n+            if (!(closed = this.closed)) {\n+                inputQ.add(df);\n+            }\n+        } finally {\n+            stateLock.unlock();\n+        }\n+        if (closed && len > 0) connection.releaseUnconsumed(df);\n+    }\n+\n@@ -1550,0 +1593,2 @@\n+        } finally {\n+            drainInputQueue();\n@@ -1773,1 +1818,1 @@\n-                            .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n+                        .formatted(streamid)), ResetFrame.FLOW_CONTROL_ERROR);\n","filename":"src\/java.net.http\/share\/classes\/jdk\/internal\/net\/http\/Stream.java","additions":58,"deletions":13,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -174,1 +174,5 @@\n-                        assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        if (i < max - 1) {\n+                            \/\/ the connection window might be exceeded at i == max - 2, which\n+                            \/\/ means that the last request could go on a new connection.\n+                            assertEquals(ckey, label, \"Unexpected key for \" + query);\n+                        }\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/ConnectionFlowControlTest.java","additions":5,"deletions":1,"binary":false,"changes":6,"status":"modified"},{"patch":"@@ -26,1 +26,1 @@\n- * @bug 8342075\n+ * @bug 8342075 8343855\n@@ -51,0 +51,1 @@\n+import java.util.concurrent.TimeUnit;\n@@ -56,0 +57,2 @@\n+import jdk.httpclient.test.lib.common.HttpServerAdapters;\n+import jdk.httpclient.test.lib.common.HttpServerAdapters.HttpHeadHandler;\n@@ -72,0 +75,1 @@\n+import static java.util.concurrent.TimeUnit.NANOSECONDS;\n@@ -95,0 +99,13 @@\n+    static void sleep(long wait) throws InterruptedException {\n+        if (wait <= 0) return;\n+        long remaining = Utils.adjustTimeout(wait);\n+        long start = System.nanoTime();\n+        while (remaining > 0) {\n+            Thread.sleep(remaining);\n+            long end = System.nanoTime();\n+            remaining = remaining - NANOSECONDS.toMillis(end - start);\n+        }\n+        System.out.printf(\"Waited %s ms%n\",\n+                NANOSECONDS.toMillis(System.nanoTime() - start));\n+    }\n+\n@@ -118,1 +135,1 @@\n-                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .GET()\n@@ -133,1 +150,1 @@\n-                    int wait = uri.startsWith(\"https:\/\/\") ? 500 : 350;\n+                    long wait = uri.startsWith(\"https:\/\/\") ? 800 : 350;\n@@ -135,1 +152,1 @@\n-                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        sleep(wait);\n@@ -177,1 +194,1 @@\n-                        .POST(BodyPublishers.ofString(\"Hello there!\"))\n+                        .GET()\n@@ -191,1 +208,1 @@\n-                    int wait = uri.startsWith(\"https:\/\/\") ? 600 : 300;\n+                    long wait = uri.startsWith(\"https:\/\/\") ? 800 : 350;\n@@ -193,1 +210,1 @@\n-                        Thread.sleep(Utils.adjustTimeout(wait));\n+                        sleep(wait);\n@@ -255,0 +272,1 @@\n+        this.https2TestServer.addHandler(new HttpHeadHandler(), \"\/https2\/head\/\");\n@@ -256,0 +274,1 @@\n+        String h2Head = \"https:\/\/\" + this.https2TestServer.serverAuthority() + \"\/https2\/head\/z\";\n@@ -264,0 +283,7 @@\n+\n+        \/\/ warmup to eliminate delay due to SSL class loading and initialization.\n+        try (var client = HttpClient.newBuilder().sslContext(sslContext).build()) {\n+            var request = HttpRequest.newBuilder(URI.create(h2Head)).HEAD().build();\n+            var resp = client.send(request, BodyHandlers.discarding());\n+            assertEquals(resp.statusCode(), 200);\n+        }\n@@ -282,2 +308,7 @@\n-                System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n-                        + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                if (bytes.length != 0) {\n+                    System.out.println(\"Server \" + t.getLocalAddress() + \" received:\\n\"\n+                            + t.getRequestURI() + \": \" + new String(bytes, StandardCharsets.UTF_8));\n+                } else {\n+                    System.out.println(\"No request body for \" + t.getRequestMethod());\n+                }\n+\n@@ -286,1 +317,4 @@\n-                if (bytes.length == 0) bytes = \"no request body!\".getBytes(StandardCharsets.UTF_8);\n+                if (bytes.length == 0) {\n+                    bytes = \"no request body!\"\n+                            .repeat(100).getBytes(StandardCharsets.UTF_8);\n+                }\n@@ -310,1 +344,7 @@\n-                    ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                    try {\n+                        ((BodyOutputStream) os).writeUncontrolled(resp, 0, resp.length);\n+                    } catch (IOException x) {\n+                        if (t instanceof FCHttp2TestExchange fct) {\n+                            fct.conn.updateConnectionWindow(resp.length);\n+                        }\n+                    }\n@@ -312,0 +352,5 @@\n+            } finally {\n+                if (t instanceof FCHttp2TestExchange fct) {\n+                    fct.responseSent(query);\n+                } else fail(\"Exchange is not %s but %s\"\n+                        .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n@@ -313,4 +358,0 @@\n-            if (t instanceof FCHttp2TestExchange fct) {\n-                fct.responseSent(query);\n-            } else fail(\"Exchange is not %s but %s\"\n-                    .formatted(FCHttp2TestExchange.class.getName(), t.getClass().getName()));\n","filename":"test\/jdk\/java\/net\/httpclient\/http2\/StreamFlowControlTest.java","additions":56,"deletions":15,"binary":false,"changes":71,"status":"modified"},{"patch":"@@ -52,0 +52,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -69,0 +70,3 @@\n+import static java.net.http.HttpClient.Version.HTTP_1_1;\n+import static java.net.http.HttpClient.Version.HTTP_2;\n+\n@@ -271,1 +275,1 @@\n-            public Version getServerVersion() { return Version.HTTP_1_1; }\n+            public Version getServerVersion() { return HTTP_1_1; }\n@@ -273,1 +277,1 @@\n-            public Version getExchangeVersion() { return Version.HTTP_1_1; }\n+            public Version getExchangeVersion() { return HTTP_1_1; }\n@@ -333,1 +337,1 @@\n-            public Version getServerVersion() { return Version.HTTP_2; }\n+            public Version getServerVersion() { return HTTP_2; }\n@@ -335,1 +339,1 @@\n-            public Version getExchangeVersion() { return Version.HTTP_2; }\n+            public Version getExchangeVersion() { return HTTP_2; }\n@@ -424,0 +428,44 @@\n+    \/**\n+     * An {@link HttpTestHandler} that handles only HEAD and GET\n+     * requests. If another method is used 405 is returned with\n+     * an empty body.\n+     * The response is always returned with fixed length.\n+     *\/\n+    public static class HttpHeadHandler implements HttpTestHandler {\n+        final String responseBody;\n+        public HttpHeadHandler() {\n+            this(\"pâté de tête persillé\");\n+        }\n+        public HttpHeadHandler(String responseBody) {\n+            this.responseBody = Objects.requireNonNull(responseBody);\n+        }\n+\n+        @Override\n+        public void handle(HttpTestExchange t) throws IOException {\n+            t.getRequestBody().readAllBytes();\n+            String method = t.getRequestMethod();\n+            switch (method) {\n+                case \"HEAD\" -> {\n+                    byte[] resp = responseBody.getBytes(StandardCharsets.UTF_8);\n+                    if (t.getExchangeVersion() != HTTP_1_1) {\n+                        \/\/ with HTTP\/2 or HTTP\/3 the server will not send content-length\n+                        t.getResponseHeaders().addHeader(\"Content-Length\", String.valueOf(resp.length));\n+                    }\n+                    t.sendResponseHeaders(200, resp.length);\n+                }\n+                case \"GET\" -> {\n+                    byte[] resp = responseBody.getBytes(StandardCharsets.UTF_8);\n+                    t.sendResponseHeaders(200, resp.length);\n+                    try (var os = t.getResponseBody()) {\n+                        os.write(resp);\n+                    }\n+                }\n+                default -> {\n+                    t.sendResponseHeaders(405, 0);\n+                }\n+            }\n+            t.getResponseBody().close();\n+            t.close();\n+        }\n+    }\n+\n@@ -880,1 +928,1 @@\n-            public Version getVersion() { return Version.HTTP_1_1; }\n+            public Version getVersion() { return HTTP_1_1; }\n@@ -905,1 +953,1 @@\n-            @Override public Version getVersion() { return Version.HTTP_1_1; }\n+            @Override public Version getVersion() { return HTTP_1_1; }\n@@ -936,1 +984,1 @@\n-            public Version getVersion() { return Version.HTTP_2; }\n+            public Version getVersion() { return HTTP_2; }\n@@ -974,1 +1022,1 @@\n-            @Override public Version getVersion() { return Version.HTTP_2; }\n+            @Override public Version getVersion() { return HTTP_2; }\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/common\/HttpServerAdapters.java","additions":56,"deletions":8,"binary":false,"changes":64,"status":"modified"},{"patch":"@@ -1387,1 +1387,1 @@\n-    void updateConnectionWindow(int amount) {\n+    public void updateConnectionWindow(int amount) {\n","filename":"test\/jdk\/java\/net\/httpclient\/lib\/jdk\/httpclient\/test\/lib\/http2\/Http2TestServerConnection.java","additions":1,"deletions":1,"binary":false,"changes":2,"status":"modified"}]}