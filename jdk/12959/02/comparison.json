{"files":[{"patch":"@@ -2,1 +2,1 @@\n- * Copyright 2012 Google, Inc.  All Rights Reserved.\n+ * Copyright 2012, 2023 Google, Inc.  All Rights Reserved.\n@@ -27,10 +27,3 @@\n- * @summary Check ability to read zip files created by python zipfile\n- * implementation, which fails to write optional (but recommended) data\n- * descriptor signatures.  Repro scenario is a Java -> Python -> Java round trip:\n- * - ZipOutputStream creates zip file with DEFLATED entries and data\n- *   descriptors with optional signature \"PK0x0708\".\n- * - Python reads those entries, preserving the 0x08 flag byte\n- * - Python outputs those entries with data descriptors lacking the\n- *   optional signature.\n- * - ZipInputStream cannot handle the missing signature\n- *\n+ * @summary Verify the ability to read zip files whose local header\n+ * data descriptor is missing the optional signature\n+ * <p>\n@@ -39,2 +32,1 @@\n- *\n- * @ignore This test has brittle dependencies on an external working python.\n+ * @run testng DataDescriptorSignatureMissing\n@@ -43,0 +35,2 @@\n+import org.testng.annotations.Test;\n+\n@@ -44,0 +38,1 @@\n+import java.nio.charset.StandardCharsets;\n@@ -46,11 +41,3 @@\n-public class DataDescriptorSignatureMissing  {\n-    void printStream(InputStream is) throws IOException {\n-        Reader r = new InputStreamReader(is);\n-        StringBuilder sb = new StringBuilder();\n-        char[] buf = new char[1024];\n-        int n;\n-        while ((n = r.read(buf)) > 0) {\n-            sb.append(buf, 0, n);\n-        }\n-        System.out.print(sb);\n-    }\n+import static org.testng.Assert.assertEquals;\n+\n+public class DataDescriptorSignatureMissing {\n@@ -58,6 +45,19 @@\n-    int entryCount(File zipFile) throws IOException {\n-        try (FileInputStream fis = new FileInputStream(zipFile);\n-             ZipInputStream zis = new ZipInputStream(fis)) {\n-            for (int count = 0;; count++)\n-                if (zis.getNextEntry() == null)\n-                    return count;\n+    \/**\n+     * Verify that ZipInputStream correctly parses a ZIP with a Data Descriptor without\n+     * the recommended but optional signature.\n+     *\/\n+    @Test\n+    public void shouldParseSignaturelessDescriptor() throws IOException {\n+        \/\/ The ZIP with a signature-less descriptor\n+        byte[] zip = makeZipWithSignaturelessDescriptor();\n+\n+        \/\/ ZipInputStream should read the signature-less data descriptor\n+        try (ZipInputStream in = new ZipInputStream(\n+                new ByteArrayInputStream(zip))) {\n+            ZipEntry first = in.getNextEntry();\n+            assertEquals(first.getName(), \"first\");\n+            assertEquals(in.readAllBytes(), \"first\".getBytes(StandardCharsets.UTF_8));\n+\n+            ZipEntry second = in.getNextEntry();\n+            assertEquals(second.getName(), \"second\");\n+            assertEquals(in.readAllBytes(), \"second\".getBytes(StandardCharsets.UTF_8));\n@@ -65,0 +65,1 @@\n+\n@@ -67,3 +68,6 @@\n-    void test(String[] args) throws Throwable {\n-        if (! new File(\"\/usr\/bin\/python\").canExecute())\n-            return;\n+    \/**\n+     * Produce a ZIP file where the first entry has a signature-less data descriptor\n+     *\/\n+    private static byte[] makeZipWithSignaturelessDescriptor() throws IOException {\n+        \/\/ Offset of the signed data descriptor\n+        int sigOffset;\n@@ -71,14 +75,12 @@\n-        \/\/ Create a java zip file with DEFLATED entries and data\n-        \/\/ descriptors with signatures.\n-        final File in = new File(\"in.zip\");\n-        final File out = new File(\"out.zip\");\n-        final int count = 3;\n-        try (FileOutputStream fos = new FileOutputStream(in);\n-             ZipOutputStream zos = new ZipOutputStream(fos)) {\n-            for (int i = 0; i < count; i++) {\n-                ZipEntry ze = new ZipEntry(\"hello.python\" + i);\n-                ze.setMethod(ZipEntry.DEFLATED);\n-                zos.putNextEntry(ze);\n-                zos.write(new byte[10]);\n-                zos.closeEntry();\n-            }\n+        ByteArrayOutputStream out = new ByteArrayOutputStream();\n+        try (ZipOutputStream zo = new ZipOutputStream(out)) {\n+            \/\/ Write a first entry\n+            zo.putNextEntry(new ZipEntry(\"first\"));\n+            zo.write(\"first\".getBytes(StandardCharsets.UTF_8));\n+            \/\/ Force the data descriptor to be written out\n+            zo.closeEntry();\n+            \/\/ Signed data descriptor starts 16 bytes before current offset\n+            sigOffset = out.size() - 4 * Integer.BYTES;\n+            \/\/ Add a second entry\n+            zo.putNextEntry(new ZipEntry(\"second\"));\n+            zo.write(\"second\".getBytes(StandardCharsets.UTF_8));\n@@ -87,27 +89,2 @@\n-        \/\/ Copy the zip file using python's zipfile module\n-        String[] python_program_lines = {\n-            \"import os\",\n-            \"import zipfile\",\n-            \"input_zip = zipfile.ZipFile('in.zip', mode='r')\",\n-            \"output_zip = zipfile.ZipFile('out.zip', mode='w')\",\n-            \"count08 = 0\",\n-            \"for input_info in input_zip.infolist():\",\n-            \"  output_info = input_info\",\n-            \"  if output_info.flag_bits & 0x08 == 0x08:\",\n-            \"    count08 += 1\",\n-            \"  output_zip.writestr(output_info, input_zip.read(input_info))\",\n-            \"output_zip.close()\",\n-            \"if count08 == 0:\",\n-            \"  raise ValueError('Expected to see entries with 0x08 flag_bits set')\",\n-        };\n-        StringBuilder python_program_builder = new StringBuilder();\n-        for (String line : python_program_lines)\n-            python_program_builder.append(line).append('\\n');\n-        String python_program = python_program_builder.toString();\n-        String[] cmdline = { \"\/usr\/bin\/python\", \"-c\", python_program };\n-        ProcessBuilder pb = new ProcessBuilder(cmdline);\n-        pb.redirectErrorStream(true);\n-        Process p = pb.start();\n-        printStream(p.getInputStream());\n-        p.waitFor();\n-        equal(p.exitValue(), 0);\n+        \/\/ The generated ZIP file with a signed data descriptor\n+        byte[] sigZip = out.toByteArray();\n@@ -115,2 +92,2 @@\n-        File pythonZipFile = new File(\"out.zip\");\n-        check(pythonZipFile.exists());\n+        \/\/ The offset of the CRC immediately following the 4-byte signature\n+        int crcOffset = sigOffset + Integer.BYTES;\n@@ -118,2 +95,4 @@\n-        equal(entryCount(in),\n-              entryCount(out));\n+        \/\/ Create a ZIP file with a signature-less data descriptor for the first entry\n+        ByteArrayOutputStream sigLess = new ByteArrayOutputStream();\n+        sigLess.write(sigZip, 0, sigOffset);\n+        sigLess.write(sigZip, crcOffset, sigZip.length - crcOffset);\n@@ -121,8 +100,1 @@\n-        \/\/ We expect out to be identical to in, except for the removal of\n-        \/\/ the optional data descriptor signatures.\n-        final int SIG_LENGTH = 4;       \/\/ length of a zip signature - PKxx\n-        equal(in.length(),\n-              out.length() + SIG_LENGTH * count);\n-\n-        in.delete();\n-        out.delete();\n+        return sigLess.toByteArray();\n@@ -130,17 +102,0 @@\n-\n-    \/\/--------------------- Infrastructure ---------------------------\n-    volatile int passed = 0, failed = 0;\n-    void pass() {passed++;}\n-    void fail() {failed++; Thread.dumpStack();}\n-    void fail(String msg) {System.err.println(msg); fail();}\n-    void unexpected(Throwable t) {failed++; t.printStackTrace();}\n-    void check(boolean cond) {if (cond) pass(); else fail();}\n-    void equal(Object x, Object y) {\n-        if (x == null ? y == null : x.equals(y)) pass();\n-        else fail(x + \" not equal to \" + y);}\n-    public static void main(String[] args) throws Throwable {\n-        new DataDescriptorSignatureMissing().instanceMain(args);}\n-    public void instanceMain(String[] args) throws Throwable {\n-        try {test(args);} catch (Throwable t) {unexpected(t);}\n-        System.out.printf(\"%nPassed = %d, failed = %d%n%n\", passed, failed);\n-        if (failed > 0) throw new AssertionError(\"Some tests failed\");}\n","filename":"test\/jdk\/java\/util\/zip\/DataDescriptorSignatureMissing.java","additions":58,"deletions":103,"binary":false,"changes":161,"status":"modified"}]}