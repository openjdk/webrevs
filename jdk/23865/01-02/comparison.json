{"files":[{"patch":"@@ -26,0 +26,2 @@\n+import compiler.lib.ir_framework.*;\n+\n@@ -33,3 +35,0 @@\n- * @run main\/othervm -XX:CompileCommand=compileonly,*Test*::test\n- *                   -XX:-TieredCompilation -Xcomp -XX:PerMethodTrapLimit=0\n- *                   compiler.loopopts.superword.TestMultiversionRemoveUselessSlowLoop\n@@ -39,0 +38,54 @@\n+\n+    public static void main(String[] args) {\n+        TestFramework framework = new TestFramework(TestMultiversionRemoveUselessSlowLoop.class);\n+        \/\/ No traps means we cannot use the predicates version for SuperWord \/ AutoVectorization,\n+        \/\/ and instead use multiversioning directly.\n+        framework.addFlags(\"-XX:-TieredCompilation\", \"-XX:PerMethodTrapLimit=0\");\n+        framework.setDefaultWarmup(0); \/\/ simulates Xcomp\n+        framework.start();\n+    }\n+\n+    public static final int SIZE = 20;\n+    public static final int[] a = new int[SIZE];\n+    public static final int[] b = new int[SIZE];\n+    public static final int SIZE2 = 10_000;\n+    public static final int[] a2 = new int[SIZE2];\n+    public static final int[] b2 = new int[SIZE2];\n+\n+    @Test\n+    @IR(counts = {\"pre .* multiversion_fast\",  \"= 2\", \/\/ regular pre-main-post for both loops\n+                  \"main .* multiversion_fast\", \"= 2\",\n+                  \"post .* multiversion_fast\", \"= 2\",\n+                  \"multiversion_delayed_slow\", \"= 2\", \/\/ both have the delayed slow_loop\n+                  \"multiversion\",              \"= 8\"}, \/\/ nothing unexpected\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PHASEIDEALLOOP1)\n+    @IR(counts = {\"pre .* multiversion_fast\",  \"= 2\",\n+                  \"main .* multiversion_fast\", \"= 1\", \/\/ The first main loop is fully unrolled\n+                  \"post .* multiversion_fast\", \"= 3\", \/\/ the second loop is vectorized, and has a vectorized post loop\n+                  \"multiversion_delayed_slow\", \"= 1\", \/\/ As a consequence of the first main loop being removed, we constant fold the multiversion_if\n+                  \"multiversion\",              \"= 7\"}, \/\/ nothing unexpected\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PHASEIDEALLOOP_ITERATIONS)\n+    @IR(counts = {\"pre .* multiversion_fast\",  \"= 1\", \/\/ the pre-loop of the first loop only has a single iteration\n+                  \"main .* multiversion_fast\", \"= 1\",\n+                  \"post .* multiversion_fast\", \"= 3\",\n+                  \"multiversion\",              \"= 5\"}, \/\/ nothing unexpected\n+        applyIfPlatform = {\"64-bit\", \"true\"},\n+        applyIfCPUFeatureOr = {\"sse4.1\", \"true\", \"asimd\", \"true\"},\n+        phase = CompilePhase.PRINT_IDEAL)\n+    public static void testIR() {\n+        \/\/ This loop is short, and the multiversion_fast main loop eventuall is fully unrolled.\n+        for (int i = 0; i < SIZE; i++) {\n+            a[i] = b[i];\n+        }\n+        \/\/ We take this second loop with a larger limit so that loop opts keeps going once the loop\n+        \/\/ above is fully optimized. It also gives us a reference where the main loop of the\n+        \/\/ multiverion fast_loop does not disappear.\n+        for (int i = 0; i < SIZE2; i++) {\n+            a2[i] = b2[i];\n+        }\n+    }\n+\n@@ -52,1 +105,2 @@\n-    static void test() {\n+    @Test\n+    public static void testCrash() {\n@@ -64,4 +118,0 @@\n-\n-    public static void main(String[] args) {\n-        test();\n-    }\n","filename":"test\/hotspot\/jtreg\/compiler\/loopopts\/superword\/TestMultiversionRemoveUselessSlowLoop.java","additions":58,"deletions":8,"binary":false,"changes":66,"status":"modified"}]}